========================================
sqlite-amalgamation-3510000/sqlite3.c
========================================
Function: sqlite3_status64
Content: <line0>SQLITE_API int sqlite3_status64(\n<line1>int op,\n<line2>sqlite3_int64 *pCurrent,\n<line3>sqlite3_int64 *pHighwater,\n<line4>int resetFlag\n<line5>){\n<line6>sqlite3_mutex *pMutex;\n<line7>wsdStatInit;\n<line8>if( op<0 || op>=ArraySize(wsdStat.nowValue) ){\n<line9>return SQLITE_MISUSE_BKPT;\n<line10>}\n<line11>#ifdef SQLITE_ENABLE_API_ARMOR\n<line12>if( pCurrent==0 || pHighwater==0 ) return SQLITE_MISUSE_BKPT;\n<line13>#endif\n<line14>pMutex = statMutex[op] ? sqlite3Pcache1Mutex() : sqlite3MallocMutex();\n<line15>sqlite3_mutex_enter(pMutex);\n<line16>*pCurrent = wsdStat.nowValue[op];\n<line17>*pHighwater = wsdStat.mxValue[op];\n<line18>if( resetFlag ){\n<line19>wsdStat.mxValue[op] = wsdStat.nowValue[op];\n<line20>}\n<line21>sqlite3_mutex_leave(pMutex);\n<line22>(void)pMutex;  /* Prevent warning when SQLITE_THREADSAFE=0 */\n<line23>return SQLITE_OK;\n<line24>}
----------------------------------------
Function: sqlite3_status
Content: <line0>SQLITE_API int sqlite3_status(int op, int *pCurrent, int *pHighwater, int resetFlag){\n<line1>sqlite3_int64 iCur = 0, iHwtr = 0;\n<line2>int rc;\n<line3>#ifdef SQLITE_ENABLE_API_ARMOR\n<line4>if( pCurrent==0 || pHighwater==0 ) return SQLITE_MISUSE_BKPT;\n<line5>#endif\n<line6>rc = sqlite3_status64(op, &iCur, &iHwtr, resetFlag);\n<line7>if( rc==0 ){\n<line8>*pCurrent = (int)iCur;\n<line9>*pHighwater = (int)iHwtr;\n<line10>}\n<line11>return rc;\n<line12>}
----------------------------------------
Function: countLookasideSlots
Content: <line0>static u32 countLookasideSlots(LookasideSlot *p){\n<line1>u32 cnt = 0;\n<line2>while( p ){\n<line3>p = p->pNext;\n<line4>cnt++;\n<line5>}\n<line6>return cnt;\n<line7>}
----------------------------------------
Function: sqlite3_db_status64
Content: <line0>SQLITE_API int sqlite3_db_status64(\n<line1>sqlite3 *db,             /* The database connection whose status is desired */\n<line2>int op,                  /* Status verb */\n<line3>sqlite3_int64 *pCurrent, /* Write current value here */\n<line4>sqlite3_int64 *pHighwtr, /* Write high-water mark here */\n<line5>int resetFlag            /* Reset high-water mark if true */\n<line6>){\n<line7>int rc = SQLITE_OK;   /* Return code */\n<line8>#ifdef SQLITE_ENABLE_API_ARMOR\n<line9>if( !sqlite3SafetyCheckOk(db) || pCurrent==0|| pHighwtr==0 ){\n<line10>return SQLITE_MISUSE_BKPT;\n<line11>}\n<line12>#endif\n<line13>sqlite3_mutex_enter(db->mutex);\n<line14>switch( op ){\n<line15>case SQLITE_DBSTATUS_LOOKASIDE_USED: {\n<line16>int H = 0;\n<line17>*pCurrent = sqlite3LookasideUsed(db, &H);\n<line18>*pHighwtr = H;\n<line19>if( resetFlag ){\n<line20>LookasideSlot *p = db->lookaside.pFree;\n<line21>if( p ){\n<line22>while( p->pNext ) p = p->pNext;\n<line23>p->pNext = db->lookaside.pInit;\n<line24>db->lookaside.pInit = db->lookaside.pFree;\n<line25>db->lookaside.pFree = 0;\n<line26>}\n<line27>#ifndef SQLITE_OMIT_TWOSIZE_LOOKASIDE\n<line28>p = db->lookaside.pSmallFree;\n<line29>if( p ){\n<line30>while( p->pNext ) p = p->pNext;\n<line31>p->pNext = db->lookaside.pSmallInit;\n<line32>db->lookaside.pSmallInit = db->lookaside.pSmallFree;\n<line33>db->lookaside.pSmallFree = 0;\n<line34>}\n<line35>#endif\n<line36>}\n<line37>break;\n<line38>}\n<line39>case SQLITE_DBSTATUS_LOOKASIDE_HIT:\n<line40>case SQLITE_DBSTATUS_LOOKASIDE_MISS_SIZE:\n<line41>case SQLITE_DBSTATUS_LOOKASIDE_MISS_FULL: {\n<line42>testcase( op==SQLITE_DBSTATUS_LOOKASIDE_HIT );\n<line43>testcase( op==SQLITE_DBSTATUS_LOOKASIDE_MISS_SIZE );\n<line44>testcase( op==SQLITE_DBSTATUS_LOOKASIDE_MISS_FULL );\n<line45>assert( (op-SQLITE_DBSTATUS_LOOKASIDE_HIT)>=0 );\n<line46>assert( (op-SQLITE_DBSTATUS_LOOKASIDE_HIT)<3 );\n<line47>*pCurrent = 0;\n<line48>*pHighwtr = db->lookaside.anStat[op-SQLITE_DBSTATUS_LOOKASIDE_HIT];\n<line49>if( resetFlag ){\n<line50>db->lookaside.anStat[op - SQLITE_DBSTATUS_LOOKASIDE_HIT] = 0;\n<line51>}\n<line52>break;\n<line53>}\n<line54>/*\n<line55>** Return an approximation for the amount of memory currently used\n<line56>** by all pagers associated with the given database connection.  The\n<line57>** highwater mark is meaningless and is returned as zero.\n<line58>*/\n<line59>case SQLITE_DBSTATUS_CACHE_USED_SHARED:\n<line60>case SQLITE_DBSTATUS_CACHE_USED: {\n<line61>sqlite3_int64 totalUsed = 0;\n<line62>int i;\n<line63>sqlite3BtreeEnterAll(db);\n<line64>for(i=0; i<db->nDb; i++){\n<line65>Btree *pBt = db->aDb[i].pBt;\n<line66>if( pBt ){\n<line67>Pager *pPager = sqlite3BtreePager(pBt);\n<line68>int nByte = sqlite3PagerMemUsed(pPager);\n<line69>if( op==SQLITE_DBSTATUS_CACHE_USED_SHARED ){\n<line70>nByte = nByte / sqlite3BtreeConnectionCount(pBt);\n<line71>}\n<line72>totalUsed += nByte;\n<line73>}\n<line74>}\n<line75>sqlite3BtreeLeaveAll(db);\n<line76>*pCurrent = totalUsed;\n<line77>*pHighwtr = 0;\n<line78>break;\n<line79>}\n<line80>/*\n<line81>** *pCurrent gets an accurate estimate of the amount of memory used\n<line82>** to store the schema for all databases (main, temp, and any ATTACHed\n<line83>** databases.  *pHighwtr is set to zero.\n<line84>*/\n<line85>case SQLITE_DBSTATUS_SCHEMA_USED: {\n<line86>int i;          /* Used to iterate through schemas */\n<line87>int nByte = 0;  /* Used to accumulate return value */\n<line88>sqlite3BtreeEnterAll(db);\n<line89>db->pnBytesFreed = &nByte;\n<line90>assert( db->lookaside.pEnd==db->lookaside.pTrueEnd );\n<line91>db->lookaside.pEnd = db->lookaside.pStart;\n<line92>for(i=0; i<db->nDb; i++){\n<line93>Schema *pSchema = db->aDb[i].pSchema;\n<line94>if( ALWAYS(pSchema!=0) ){\n<line95>HashElem *p;\n<line96>nByte += sqlite3GlobalConfig.m.xRoundup(sizeof(HashElem)) * (\n<line97>pSchema->tblHash.count\n<line98>+ pSchema->trigHash.count\n<line99>+ pSchema->idxHash.count\n<line100>+ pSchema->fkeyHash.count\n<line101>);\n<line102>nByte += sqlite3_msize(pSchema->tblHash.ht);\n<line103>nByte += sqlite3_msize(pSchema->trigHash.ht);\n<line104>nByte += sqlite3_msize(pSchema->idxHash.ht);\n<line105>nByte += sqlite3_msize(pSchema->fkeyHash.ht);\n<line106>for(p=sqliteHashFirst(&pSchema->trigHash); p; p=sqliteHashNext(p)){\n<line107>sqlite3DeleteTrigger(db, (Trigger*)sqliteHashData(p));\n<line108>}\n<line109>for(p=sqliteHashFirst(&pSchema->tblHash); p; p=sqliteHashNext(p)){\n<line110>sqlite3DeleteTable(db, (Table *)sqliteHashData(p));\n<line111>}\n<line112>}\n<line113>}\n<line114>db->pnBytesFreed = 0;\n<line115>db->lookaside.pEnd = db->lookaside.pTrueEnd;\n<line116>sqlite3BtreeLeaveAll(db);\n<line117>*pHighwtr = 0;\n<line118>*pCurrent = nByte;\n<line119>break;\n<line120>}\n<line121>/*\n<line122>** *pCurrent gets an accurate estimate of the amount of memory used\n<line123>** to store all prepared statements.\n<line124>** *pHighwtr is set to zero.\n<line125>*/\n<line126>case SQLITE_DBSTATUS_STMT_USED: {\n<line127>struct Vdbe *pVdbe;         /* Used to iterate through VMs */\n<line128>int nByte = 0;              /* Used to accumulate return value */\n<line129>db->pnBytesFreed = &nByte;\n<line130>assert( db->lookaside.pEnd==db->lookaside.pTrueEnd );\n<line131>db->lookaside.pEnd = db->lookaside.pStart;\n<line132>for(pVdbe=db->pVdbe; pVdbe; pVdbe=pVdbe->pVNext){\n<line133>sqlite3VdbeDelete(pVdbe);\n<line134>}\n<line135>db->lookaside.pEnd = db->lookaside.pTrueEnd;\n<line136>db->pnBytesFreed = 0;\n<line137>*pHighwtr = 0;  /* IMP: R-64479-57858 */\n<line138>*pCurrent = nByte;\n<line139>break;\n<line140>}\n<line141>/*\n<line142>** Set *pCurrent to the total cache hits or misses encountered by all\n<line143>** pagers the database handle is connected to. *pHighwtr is always set\n<line144>** to zero.\n<line145>*/\n<line146>case SQLITE_DBSTATUS_CACHE_SPILL:\n<line147>op = SQLITE_DBSTATUS_CACHE_WRITE+1;\n<line148>/* no break */ deliberate_fall_through\n<line149>case SQLITE_DBSTATUS_CACHE_HIT:\n<line150>case SQLITE_DBSTATUS_CACHE_MISS:\n<line151>case SQLITE_DBSTATUS_CACHE_WRITE:{\n<line152>int i;\n<line153>u64 nRet = 0;\n<line154>assert( SQLITE_DBSTATUS_CACHE_MISS==SQLITE_DBSTATUS_CACHE_HIT+1 );\n<line155>assert( SQLITE_DBSTATUS_CACHE_WRITE==SQLITE_DBSTATUS_CACHE_HIT+2 );\n<line156>for(i=0; i<db->nDb; i++){\n<line157>if( db->aDb[i].pBt ){\n<line158>Pager *pPager = sqlite3BtreePager(db->aDb[i].pBt);\n<line159>sqlite3PagerCacheStat(pPager, op, resetFlag, &nRet);\n<line160>}\n<line161>}\n<line162>*pHighwtr = 0; /* IMP: R-42420-56072 */\n<line163>/* IMP: R-54100-20147 */\n<line164>/* IMP: R-29431-39229 */\n<line165>*pCurrent = nRet;\n<line166>break;\n<line167>}\n<line168>/* Set *pCurrent to the number of bytes that the db database connection\n<line169>** has spilled to the filesystem in temporary files that could have been\n<line170>** stored in memory, had sufficient memory been available.\n<line171>** The *pHighwater is always set to zero.\n<line172>*/\n<line173>case SQLITE_DBSTATUS_TEMPBUF_SPILL: {\n<line174>u64 nRet = 0;\n<line175>if( db->aDb[1].pBt ){\n<line176>Pager *pPager = sqlite3BtreePager(db->aDb[1].pBt);\n<line177>sqlite3PagerCacheStat(pPager, SQLITE_DBSTATUS_CACHE_WRITE,\n<line178>resetFlag, &nRet);\n<line179>nRet *= sqlite3BtreeGetPageSize(db->aDb[1].pBt);\n<line180>}\n<line181>nRet += db->nSpill;\n<line182>if( resetFlag ) db->nSpill = 0;\n<line183>*pHighwtr = 0;\n<line184>*pCurrent = nRet;\n<line185>break;\n<line186>}\n<line187>/* Set *pCurrent to non-zero if there are unresolved deferred foreign\n<line188>** key constraints.  Set *pCurrent to zero if all foreign key constraints\n<line189>** have been satisfied.  The *pHighwtr is always set to zero.\n<line190>*/\n<line191>case SQLITE_DBSTATUS_DEFERRED_FKS: {\n<line192>*pHighwtr = 0;  /* IMP: R-11967-56545 */\n<line193>*pCurrent = db->nDeferredImmCons>0 || db->nDeferredCons>0;\n<line194>break;\n<line195>}\n<line196>default: {\n<line197>rc = SQLITE_ERROR;\n<line198>}\n<line199>}\n<line200>sqlite3_mutex_leave(db->mutex);\n<line201>return rc;\n<line202>}
----------------------------------------
Function: sqlite3_db_status
Content: <line0>SQLITE_API int sqlite3_db_status(\n<line1>sqlite3 *db,             /* The database connection whose status is desired */\n<line2>int op,                  /* Status verb */\n<line3>int *pCurrent,           /* Write current value here */\n<line4>int *pHighwtr,           /* Write high-water mark here */\n<line5>int resetFlag            /* Reset high-water mark if true */\n<line6>){\n<line7>sqlite3_int64 C = 0, H = 0;\n<line8>int rc;\n<line9>#ifdef SQLITE_ENABLE_API_ARMOR\n<line10>if( !sqlite3SafetyCheckOk(db) || pCurrent==0|| pHighwtr==0 ){\n<line11>return SQLITE_MISUSE_BKPT;\n<line12>}\n<line13>#endif\n<line14>rc = sqlite3_db_status64(db, op, &C, &H, resetFlag);\n<line15>if( rc==0 ){\n<line16>*pCurrent = C & 0x7fffffff;\n<line17>*pHighwtr = H & 0x7fffffff;\n<line18>}\n<line19>return rc;\n<line20>}
----------------------------------------
Function: getDigits
Content: <line0>static int getDigits(const char *zDate, const char *zFormat, ...){\n<line1>/* The aMx[] array translates the 3rd character of each format\n<line2>** spec into a max size:    a   b   c   d   e      f */\n<line3>static const u16 aMx[] = { 12, 14, 24, 31, 59, 14712 };\n<line4>va_list ap;\n<line5>int cnt = 0;\n<line6>char nextC;\n<line7>va_start(ap, zFormat);\n<line8>do{\n<line9>char N = zFormat[0] - '0';\n<line10>char min = zFormat[1] - '0';\n<line11>int val = 0;\n<line12>u16 max;\n<line13>assert( zFormat[2]>='a' && zFormat[2]<='f' );\n<line14>max = aMx[zFormat[2] - 'a'];\n<line15>nextC = zFormat[3];\n<line16>val = 0;\n<line17>while( N-- ){\n<line18>if( !sqlite3Isdigit(*zDate) ){\n<line19>goto end_getDigits;\n<line20>}\n<line21>val = val*10 + *zDate - '0';\n<line22>zDate++;\n<line23>}\n<line24>if( val<(int)min || val>(int)max || (nextC!=0 && nextC!=*zDate) ){\n<line25>goto end_getDigits;\n<line26>}\n<line27>*va_arg(ap,int*) = val;\n<line28>zDate++;\n<line29>cnt++;\n<line30>zFormat += 4;\n<line31>}while( nextC );\n<line32>end_getDigits:\n<line33>va_end(ap);\n<line34>return cnt;\n<line35>}
----------------------------------------
Function: parseTimezone
Content: <line0>static int parseTimezone(const char *zDate, DateTime *p){\n<line1>int sgn = 0;\n<line2>int nHr, nMn;\n<line3>int c;\n<line4>while( sqlite3Isspace(*zDate) ){ zDate++; }\n<line5>p->tz = 0;\n<line6>c = *zDate;\n<line7>if( c=='-' ){\n<line8>sgn = -1;\n<line9>}else if( c=='+' ){\n<line10>sgn = +1;\n<line11>}else if( c=='Z' || c=='z' ){\n<line12>zDate++;\n<line13>p->isLocal = 0;\n<line14>p->isUtc = 1;\n<line15>goto zulu_time;\n<line16>}else{\n<line17>return c!=0;\n<line18>}\n<line19>zDate++;\n<line20>if( getDigits(zDate, "20b:20e", &nHr, &nMn)!=2 ){\n<line21>return 1;\n<line22>}\n<line23>zDate += 5;\n<line24>p->tz = sgn*(nMn + nHr*60);\n<line25>if( p->tz==0 ){   /* Forum post 2025-09-17T10:12:14z */\n<line26>p->isLocal = 0;\n<line27>p->isUtc = 1;\n<line28>}\n<line29>zulu_time:\n<line30>while( sqlite3Isspace(*zDate) ){ zDate++; }\n<line31>return *zDate!=0;\n<line32>}
----------------------------------------
Function: parseHhMmSs
Content: <line0>static int parseHhMmSs(const char *zDate, DateTime *p){\n<line1>int h, m, s;\n<line2>double ms = 0.0;\n<line3>if( getDigits(zDate, "20c:20e", &h, &m)!=2 ){\n<line4>return 1;\n<line5>}\n<line6>zDate += 5;\n<line7>if( *zDate==':' ){\n<line8>zDate++;\n<line9>if( getDigits(zDate, "20e", &s)!=1 ){\n<line10>return 1;\n<line11>}\n<line12>zDate += 2;\n<line13>if( *zDate=='.' && sqlite3Isdigit(zDate[1]) ){\n<line14>double rScale = 1.0;\n<line15>zDate++;\n<line16>while( sqlite3Isdigit(*zDate) ){\n<line17>ms = ms*10.0 + *zDate - '0';\n<line18>rScale *= 10.0;\n<line19>zDate++;\n<line20>}\n<line21>ms /= rScale;\n<line22>/* Truncate to avoid problems with sub-milliseconds\n<line23>** rounding. https://sqlite.org/forum/forumpost/766a2c9231 */\n<line24>if( ms>0.999 ) ms = 0.999;\n<line25>}\n<line26>}else{\n<line27>s = 0;\n<line28>}\n<line29>p->validJD = 0;\n<line30>p->rawS = 0;\n<line31>p->validHMS = 1;\n<line32>p->h = h;\n<line33>p->m = m;\n<line34>p->s = s + ms;\n<line35>if( parseTimezone(zDate, p) ) return 1;\n<line36>return 0;\n<line37>}
----------------------------------------
Function: datetimeError
Content: <line0>static void datetimeError(DateTime *p){\n<line1>memset(p, 0, sizeof(*p));\n<line2>p->isError = 1;\n<line3>}
----------------------------------------
Function: computeJD
Content: <line0>static void computeJD(DateTime *p){\n<line1>int Y, M, D, A, B, X1, X2;\n<line2>if( p->validJD ) return;\n<line3>if( p->validYMD ){\n<line4>Y = p->Y;\n<line5>M = p->M;\n<line6>D = p->D;\n<line7>}else{\n<line8>Y = 2000;  /* If no YMD specified, assume 2000-Jan-01 */\n<line9>M = 1;\n<line10>D = 1;\n<line11>}\n<line12>if( Y<-4713 || Y>9999 || p->rawS ){\n<line13>datetimeError(p);\n<line14>return;\n<line15>}\n<line16>if( M<=2 ){\n<line17>Y--;\n<line18>M += 12;\n<line19>}\n<line20>A = (Y+4800)/100;\n<line21>B = 38 - A + (A/4);\n<line22>X1 = 36525*(Y+4716)/100;\n<line23>X2 = 306001*(M+1)/10000;\n<line24>p->iJD = (sqlite3_int64)((X1 + X2 + D + B - 1524.5 ) * 86400000);\n<line25>p->validJD = 1;\n<line26>if( p->validHMS ){\n<line27>p->iJD += p->h*3600000 + p->m*60000 + (sqlite3_int64)(p->s*1000 + 0.5);\n<line28>if( p->tz ){\n<line29>p->iJD -= p->tz*60000;\n<line30>p->validYMD = 0;\n<line31>p->validHMS = 0;\n<line32>p->tz = 0;\n<line33>p->isUtc = 1;\n<line34>p->isLocal = 0;\n<line35>}\n<line36>}\n<line37>}
----------------------------------------
Function: computeFloor
Content: <line0>static void computeFloor(DateTime *p){\n<line1>assert( p->validYMD || p->isError );\n<line2>assert( p->D>=0 && p->D<=31 );\n<line3>assert( p->M>=0 && p->M<=12 );\n<line4>if( p->D<=28 ){\n<line5>p->nFloor = 0;\n<line6>}else if( (1<<p->M) & 0x15aa ){\n<line7>p->nFloor = 0;\n<line8>}else if( p->M!=2 ){\n<line9>p->nFloor = (p->D==31);\n<line10>}else if( p->Y%4!=0 || (p->Y%100==0 && p->Y%400!=0) ){\n<line11>p->nFloor = p->D - 28;\n<line12>}else{\n<line13>p->nFloor = p->D - 29;\n<line14>}\n<line15>}
----------------------------------------
Function: parseYyyyMmDd
Content: <line0>static int parseYyyyMmDd(const char *zDate, DateTime *p){\n<line1>int Y, M, D, neg;\n<line2>if( zDate[0]=='-' ){\n<line3>zDate++;\n<line4>neg = 1;\n<line5>}else{\n<line6>neg = 0;\n<line7>}\n<line8>if( getDigits(zDate, "40f-21a-21d", &Y, &M, &D)!=3 ){\n<line9>return 1;\n<line10>}\n<line11>zDate += 10;\n<line12>while( sqlite3Isspace(*zDate) || 'T'==*(u8*)zDate ){ zDate++; }\n<line13>if( parseHhMmSs(zDate, p)==0 ){\n<line14>/* We got the time */\n<line15>}else if( *zDate==0 ){\n<line16>p->validHMS = 0;\n<line17>}else{\n<line18>return 1;\n<line19>}\n<line20>p->validJD = 0;\n<line21>p->validYMD = 1;\n<line22>p->Y = neg ? -Y : Y;\n<line23>p->M = M;\n<line24>p->D = D;\n<line25>computeFloor(p);\n<line26>if( p->tz ){\n<line27>computeJD(p);\n<line28>}\n<line29>return 0;\n<line30>}
----------------------------------------
Function: setDateTimeToCurrent
Content: <line0>static int setDateTimeToCurrent(sqlite3_context *context, DateTime *p){\n<line1>p->iJD = sqlite3StmtCurrentTime(context);\n<line2>if( p->iJD>0 ){\n<line3>p->validJD = 1;\n<line4>p->isUtc = 1;\n<line5>p->isLocal = 0;\n<line6>clearYMD_HMS_TZ(p);\n<line7>return 0;\n<line8>}else{\n<line9>return 1;\n<line10>}\n<line11>}
----------------------------------------
Function: setRawDateNumber
Content: <line0>static void setRawDateNumber(DateTime *p, double r){\n<line1>p->s = r;\n<line2>p->rawS = 1;\n<line3>if( r>=0.0 && r<5373484.5 ){\n<line4>p->iJD = (sqlite3_int64)(r*86400000.0 + 0.5);\n<line5>p->validJD = 1;\n<line6>}\n<line7>}
----------------------------------------
Function: parseDateOrTime
Content: <line0>static int parseDateOrTime(\n<line1>sqlite3_context *context,\n<line2>const char *zDate,\n<line3>DateTime *p\n<line4>){\n<line5>double r;\n<line6>if( parseYyyyMmDd(zDate,p)==0 ){\n<line7>return 0;\n<line8>}else if( parseHhMmSs(zDate, p)==0 ){\n<line9>return 0;\n<line10>}else if( sqlite3StrICmp(zDate,"now")==0 && sqlite3NotPureFunc(context) ){\n<line11>return setDateTimeToCurrent(context, p);\n<line12>}else if( sqlite3AtoF(zDate, &r, sqlite3Strlen30(zDate), SQLITE_UTF8)>0 ){\n<line13>setRawDateNumber(p, r);\n<line14>return 0;\n<line15>}else if( (sqlite3StrICmp(zDate,"subsec")==0\n<line16>|| sqlite3StrICmp(zDate,"subsecond")==0)\n<line17>&& sqlite3NotPureFunc(context) ){\n<line18>p->useSubsec = 1;\n<line19>return setDateTimeToCurrent(context, p);\n<line20>}\n<line21>return 1;\n<line22>}
----------------------------------------
Function: validJulianDay
Content: <line0>static int validJulianDay(sqlite3_int64 iJD){\n<line1>return iJD>=0 && iJD<=INT_464269060799999;\n<line2>}
----------------------------------------
Function: computeYMD
Content: <line0>static void computeYMD(DateTime *p){\n<line1>int Z, alpha, A, B, C, D, E, X1;\n<line2>if( p->validYMD ) return;\n<line3>if( !p->validJD ){\n<line4>p->Y = 2000;\n<line5>p->M = 1;\n<line6>p->D = 1;\n<line7>}else if( !validJulianDay(p->iJD) ){\n<line8>datetimeError(p);\n<line9>return;\n<line10>}else{\n<line11>Z = (int)((p->iJD + 43200000)/86400000);\n<line12>alpha = (int)((Z + 32044.75)/36524.25) - 52;\n<line13>A = Z + 1 + alpha - ((alpha+100)/4) + 25;\n<line14>B = A + 1524;\n<line15>C = (int)((B - 122.1)/365.25);\n<line16>D = (36525*(C&32767))/100;\n<line17>E = (int)((B-D)/30.6001);\n<line18>X1 = (int)(30.6001*E);\n<line19>p->D = B - D - X1;\n<line20>p->M = E<14 ? E-1 : E-13;\n<line21>p->Y = p->M>2 ? C - 4716 : C - 4715;\n<line22>}\n<line23>p->validYMD = 1;\n<line24>}
----------------------------------------
Function: computeHMS
Content: <line0>static void computeHMS(DateTime *p){\n<line1>int day_ms, day_min; /* milliseconds, minutes into the day */\n<line2>if( p->validHMS ) return;\n<line3>computeJD(p);\n<line4>day_ms = (int)((p->iJD + 43200000) % 86400000);\n<line5>p->s = (day_ms % 60000)/1000.0;\n<line6>day_min = day_ms/60000;\n<line7>p->m = day_min % 60;\n<line8>p->h = day_min / 60;\n<line9>p->rawS = 0;\n<line10>p->validHMS = 1;\n<line11>}
----------------------------------------
Function: computeYMD_HMS
Content: <line0>static void computeYMD_HMS(DateTime *p){\n<line1>computeYMD(p);\n<line2>computeHMS(p);\n<line3>}
----------------------------------------
Function: clearYMD_HMS_TZ
Content: <line0>static void clearYMD_HMS_TZ(DateTime *p){\n<line1>p->validYMD = 0;\n<line2>p->validHMS = 0;\n<line3>p->tz = 0;\n<line4>}
----------------------------------------
Function: osLocaltime
Content: <line0>static int osLocaltime(time_t *t, struct tm *pTm){\n<line1>int rc;\n<line2>#if !HAVE_LOCALTIME_R && !HAVE_LOCALTIME_S\n<line3>struct tm *pX;\n<line4>#if SQLITE_THREADSAFE>0\n<line5>sqlite3_mutex *mutex = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MAIN);\n<line6>#endif\n<line7>sqlite3_mutex_enter(mutex);\n<line8>pX = localtime(t);\n<line9>#ifndef SQLITE_UNTESTABLE\n<line10>if( sqlite3GlobalConfig.bLocaltimeFault ){\n<line11>if( sqlite3GlobalConfig.xAltLocaltime!=0\n<line12>&& 0==sqlite3GlobalConfig.xAltLocaltime((const void*)t,(void*)pTm)\n<line13>){\n<line14>pX = pTm;\n<line15>}else{\n<line16>pX = 0;\n<line17>}\n<line18>}\n<line19>#endif\n<line20>if( pX ) *pTm = *pX;\n<line21>#if SQLITE_THREADSAFE>0\n<line22>sqlite3_mutex_leave(mutex);\n<line23>#endif\n<line24>rc = pX==0;\n<line25>#else\n<line26>#ifndef SQLITE_UNTESTABLE\n<line27>if( sqlite3GlobalConfig.bLocaltimeFault ){\n<line28>if( sqlite3GlobalConfig.xAltLocaltime!=0 ){\n<line29>return sqlite3GlobalConfig.xAltLocaltime((const void*)t,(void*)pTm);\n<line30>}else{\n<line31>return 1;\n<line32>}\n<line33>}\n<line34>#endif\n<line35>#if HAVE_LOCALTIME_R\n<line36>rc = localtime_r(t, pTm)==0;\n<line37>#else\n<line38>rc = localtime_s(pTm, t);\n<line39>#endif /* HAVE_LOCALTIME_R */\n<line40>#endif /* HAVE_LOCALTIME_R || HAVE_LOCALTIME_S */\n<line41>return rc;\n<line42>}
----------------------------------------
Function: toLocaltime
Content: <line0>static int toLocaltime(\n<line1>DateTime *p,                   /* Date at which to calculate offset */\n<line2>sqlite3_context *pCtx          /* Write error here if one occurs */\n<line3>){\n<line4>time_t t;\n<line5>struct tm sLocal;\n<line6>int iYearDiff;\n<line7>/* Initialize the contents of sLocal to avoid a compiler warning. */\n<line8>memset(&sLocal, 0, sizeof(sLocal));\n<line9>computeJD(p);\n<line10>if( p->iJD<2108667600*(i64)100000 /* 1970-01-01 */\n<line11>|| p->iJD>2130141456*(i64)100000 /* 2038-01-18 */\n<line12>){\n<line13>/* EVIDENCE-OF: R-55269-29598 The localtime_r() C function normally only\n<line14>** works for years between 1970 and 2037. For dates outside this range,\n<line15>** SQLite attempts to map the year into an equivalent year within this\n<line16>** range, do the calculation, then map the year back.\n<line17>*/\n<line18>DateTime x = *p;\n<line19>computeYMD_HMS(&x);\n<line20>iYearDiff = (2000 + x.Y%4) - x.Y;\n<line21>x.Y += iYearDiff;\n<line22>x.validJD = 0;\n<line23>computeJD(&x);\n<line24>t = (time_t)(x.iJD/1000 -  21086676*(i64)10000);\n<line25>}else{\n<line26>iYearDiff = 0;\n<line27>t = (time_t)(p->iJD/1000 -  21086676*(i64)10000);\n<line28>}\n<line29>if( osLocaltime(&t, &sLocal) ){\n<line30>sqlite3_result_error(pCtx, "local time unavailable", -1);\n<line31>return SQLITE_ERROR;\n<line32>}\n<line33>p->Y = sLocal.tm_year + 1900 - iYearDiff;\n<line34>p->M = sLocal.tm_mon + 1;\n<line35>p->D = sLocal.tm_mday;\n<line36>p->h = sLocal.tm_hour;\n<line37>p->m = sLocal.tm_min;\n<line38>p->s = sLocal.tm_sec + (p->iJD%1000)*0.001;\n<line39>p->validYMD = 1;\n<line40>p->validHMS = 1;\n<line41>p->validJD = 0;\n<line42>p->rawS = 0;\n<line43>p->tz = 0;\n<line44>p->isError = 0;\n<line45>return SQLITE_OK;\n<line46>}
----------------------------------------
Function: autoAdjustDate
Content: <line0>static void autoAdjustDate(DateTime *p){\n<line1>if( !p->rawS || p->validJD ){\n<line2>p->rawS = 0;\n<line3>}else if( p->s>=-21086676*(i64)10000        /* -4713-11-24 12:00:00 */\n<line4>&& p->s<=(25340230*(i64)10000)+799   /*  9999-12-31 23:59:59 */\n<line5>){\n<line6>double r = p->s*1000.0 + 210866760000000.0;\n<line7>clearYMD_HMS_TZ(p);\n<line8>p->iJD = (sqlite3_int64)(r + 0.5);\n<line9>p->validJD = 1;\n<line10>p->rawS = 0;\n<line11>}\n<line12>}
----------------------------------------
Function: parseModifier
Content: <line0>static int parseModifier(\n<line1>sqlite3_context *pCtx,      /* Function context */\n<line2>const char *z,              /* The text of the modifier */\n<line3>int n,                      /* Length of zMod in bytes */\n<line4>DateTime *p,                /* The date/time value to be modified */\n<line5>int idx                     /* Parameter index of the modifier */\n<line6>){\n<line7>int rc = 1;\n<line8>double r;\n<line9>switch(sqlite3UpperToLower[(u8)z[0]] ){\n<line10>case 'a': {\n<line11>/*\n<line12>**    auto\n<line13>**\n<line14>** If rawS is available, then interpret as a julian day number, or\n<line15>** a unix timestamp, depending on its magnitude.\n<line16>*/\n<line17>if( sqlite3_stricmp(z, "auto")==0 ){\n<line18>if( idx>1 ) return 1; /* IMP: R-33611-57934 */\n<line19>autoAdjustDate(p);\n<line20>rc = 0;\n<line21>}\n<line22>break;\n<line23>}\n<line24>case 'c': {\n<line25>/*\n<line26>**    ceiling\n<line27>**\n<line28>** Resolve day-of-month overflow by rolling forward into the next\n<line29>** month.  As this is the default action, this modifier is really\n<line30>** a no-op that is only included for symmetry.  See "floor".\n<line31>*/\n<line32>if( sqlite3_stricmp(z, "ceiling")==0 ){\n<line33>computeJD(p);\n<line34>clearYMD_HMS_TZ(p);\n<line35>rc = 0;\n<line36>p->nFloor = 0;\n<line37>}\n<line38>break;\n<line39>}\n<line40>case 'f': {\n<line41>/*\n<line42>**    floor\n<line43>**\n<line44>** Resolve day-of-month overflow by rolling back to the end of the\n<line45>** previous month.\n<line46>*/\n<line47>if( sqlite3_stricmp(z, "floor")==0 ){\n<line48>computeJD(p);\n<line49>p->iJD -= p->nFloor*86400000;\n<line50>clearYMD_HMS_TZ(p);\n<line51>rc = 0;\n<line52>}\n<line53>break;\n<line54>}\n<line55>case 'j': {\n<line56>/*\n<line57>**    julianday\n<line58>**\n<line59>** Always interpret the prior number as a julian-day value.  If this\n<line60>** is not the first modifier, or if the prior argument is not a numeric\n<line61>** value in the allowed range of julian day numbers understood by\n<line62>** SQLite (0..5373484.5) then the result will be NULL.\n<line63>*/\n<line64>if( sqlite3_stricmp(z, "julianday")==0 ){\n<line65>if( idx>1 ) return 1;  /* IMP: R-31176-64601 */\n<line66>if( p->validJD && p->rawS ){\n<line67>rc = 0;\n<line68>p->rawS = 0;\n<line69>}\n<line70>}\n<line71>break;\n<line72>}\n<line73>#ifndef SQLITE_OMIT_LOCALTIME\n<line74>case 'l': {\n<line75>/*    localtime\n<line76>**\n<line77>** Assuming the current time value is UTC (a.k.a. GMT), shift it to\n<line78>** show local time.\n<line79>*/\n<line80>if( sqlite3_stricmp(z, "localtime")==0 && sqlite3NotPureFunc(pCtx) ){\n<line81>rc = p->isLocal ? SQLITE_OK : toLocaltime(p, pCtx);\n<line82>p->isUtc = 0;\n<line83>p->isLocal = 1;\n<line84>}\n<line85>break;\n<line86>}\n<line87>#endif\n<line88>case 'u': {\n<line89>/*\n<line90>**    unixepoch\n<line91>**\n<line92>** Treat the current value of p->s as the number of\n<line93>** seconds since 1970.  Convert to a real julian day number.\n<line94>*/\n<line95>if( sqlite3_stricmp(z, "unixepoch")==0 && p->rawS ){\n<line96>if( idx>1 ) return 1;  /* IMP: R-49255-55373 */\n<line97>r = p->s*1000.0 + 210866760000000.0;\n<line98>if( r>=0.0 && r<464269060800000.0 ){\n<line99>clearYMD_HMS_TZ(p);\n<line100>p->iJD = (sqlite3_int64)(r + 0.5);\n<line101>p->validJD = 1;\n<line102>p->rawS = 0;\n<line103>rc = 0;\n<line104>}\n<line105>}\n<line106>#ifndef SQLITE_OMIT_LOCALTIME\n<line107>else if( sqlite3_stricmp(z, "utc")==0 && sqlite3NotPureFunc(pCtx) ){\n<line108>if( p->isUtc==0 ){\n<line109>i64 iOrigJD;              /* Original localtime */\n<line110>i64 iGuess;               /* Guess at the corresponding utc time */\n<line111>int cnt = 0;              /* Safety to prevent infinite loop */\n<line112>i64 iErr;                 /* Guess is off by this much */\n<line113>computeJD(p);\n<line114>iGuess = iOrigJD = p->iJD;\n<line115>iErr = 0;\n<line116>do{\n<line117>DateTime new;\n<line118>memset(&new, 0, sizeof(new));\n<line119>iGuess -= iErr;\n<line120>new.iJD = iGuess;\n<line121>new.validJD = 1;\n<line122>rc = toLocaltime(&new, pCtx);\n<line123>if( rc ) return rc;\n<line124>computeJD(&new);\n<line125>iErr = new.iJD - iOrigJD;\n<line126>}while( iErr && cnt++<3 );\n<line127>memset(p, 0, sizeof(*p));\n<line128>p->iJD = iGuess;\n<line129>p->validJD = 1;\n<line130>p->isUtc = 1;\n<line131>p->isLocal = 0;\n<line132>}\n<line133>rc = SQLITE_OK;\n<line134>}\n<line135>#endif\n<line136>break;\n<line137>}\n<line138>case 'w': {\n<line139>/*\n<line140>**    weekday N\n<line141>**\n<line142>** Move the date to the same time on the next occurrence of\n<line143>** weekday N where 0==Sunday, 1==Monday, and so forth.  If the\n<line144>** date is already on the appropriate weekday, this is a no-op.\n<line145>*/\n<line146>if( sqlite3_strnicmp(z, "weekday ", 8)==0\n<line147>&& sqlite3AtoF(&z[8], &r, sqlite3Strlen30(&z[8]), SQLITE_UTF8)>0\n<line148>&& r>=0.0 && r<7.0 && (n=(int)r)==r ){\n<line149>sqlite3_int64 Z;\n<line150>computeYMD_HMS(p);\n<line151>p->tz = 0;\n<line152>p->validJD = 0;\n<line153>computeJD(p);\n<line154>Z = ((p->iJD + 129600000)/86400000) % 7;\n<line155>if( Z>n ) Z -= 7;\n<line156>p->iJD += (n - Z)*86400000;\n<line157>clearYMD_HMS_TZ(p);\n<line158>rc = 0;\n<line159>}\n<line160>break;\n<line161>}\n<line162>case 's': {\n<line163>/*\n<line164>**    start of TTTTT\n<line165>**\n<line166>** Move the date backwards to the beginning of the current day,\n<line167>** or month or year.\n<line168>**\n<line169>**    subsecond\n<line170>**    subsec\n<line171>**\n<line172>** Show subsecond precision in the output of datetime() and\n<line173>** unixepoch() and strftime('%s').\n<line174>*/\n<line175>if( sqlite3_strnicmp(z, "start of ", 9)!=0 ){\n<line176>if( sqlite3_stricmp(z, "subsec")==0\n<line177>|| sqlite3_stricmp(z, "subsecond")==0\n<line178>){\n<line179>p->useSubsec = 1;\n<line180>rc = 0;\n<line181>}\n<line182>break;\n<line183>}\n<line184>if( !p->validJD && !p->validYMD && !p->validHMS ) break;\n<line185>z += 9;\n<line186>computeYMD(p);\n<line187>p->validHMS = 1;\n<line188>p->h = p->m = 0;\n<line189>p->s = 0.0;\n<line190>p->rawS = 0;\n<line191>p->tz = 0;\n<line192>p->validJD = 0;\n<line193>if( sqlite3_stricmp(z,"month")==0 ){\n<line194>p->D = 1;\n<line195>rc = 0;\n<line196>}else if( sqlite3_stricmp(z,"year")==0 ){\n<line197>p->M = 1;\n<line198>p->D = 1;\n<line199>rc = 0;\n<line200>}else if( sqlite3_stricmp(z,"day")==0 ){\n<line201>rc = 0;\n<line202>}\n<line203>break;\n<line204>}\n<line205>case '+':\n<line206>case '-':\n<line207>case '0':\n<line208>case '1':\n<line209>case '2':\n<line210>case '3':\n<line211>case '4':\n<line212>case '5':\n<line213>case '6':\n<line214>case '7':\n<line215>case '8':\n<line216>case '9': {\n<line217>double rRounder;\n<line218>int i;\n<line219>int Y,M,D,h,m,x;\n<line220>const char *z2 = z;\n<line221>char z0 = z[0];\n<line222>for(n=1; z[n]; n++){\n<line223>if( z[n]==':' ) break;\n<line224>if( sqlite3Isspace(z[n]) ) break;\n<line225>if( z[n]=='-' ){\n<line226>if( n==5 && getDigits(&z[1], "40f", &Y)==1 ) break;\n<line227>if( n==6 && getDigits(&z[1], "50f", &Y)==1 ) break;\n<line228>}\n<line229>}\n<line230>if( sqlite3AtoF(z, &r, n, SQLITE_UTF8)<=0 ){\n<line231>assert( rc==1 );\n<line232>break;\n<line233>}\n<line234>if( z[n]=='-' ){\n<line235>/* A modifier of the form (+|-)YYYY-MM-DD adds or subtracts the\n<line236>** specified number of years, months, and days.  MM is limited to\n<line237>** the range 0-11 and DD is limited to 0-30.\n<line238>*/\n<line239>if( z0!='+' && z0!='-' ) break;  /* Must start with +/- */\n<line240>if( n==5 ){\n<line241>if( getDigits(&z[1], "40f-20a-20d", &Y, &M, &D)!=3 ) break;\n<line242>}else{\n<line243>assert( n==6 );\n<line244>if( getDigits(&z[1], "50f-20a-20d", &Y, &M, &D)!=3 ) break;\n<line245>z++;\n<line246>}\n<line247>if( M>=12 ) break;                   /* M range 0..11 */\n<line248>if( D>=31 ) break;                   /* D range 0..30 */\n<line249>computeYMD_HMS(p);\n<line250>p->validJD = 0;\n<line251>if( z0=='-' ){\n<line252>p->Y -= Y;\n<line253>p->M -= M;\n<line254>D = -D;\n<line255>}else{\n<line256>p->Y += Y;\n<line257>p->M += M;\n<line258>}\n<line259>x = p->M>0 ? (p->M-1)/12 : (p->M-12)/12;\n<line260>p->Y += x;\n<line261>p->M -= x*12;\n<line262>computeFloor(p);\n<line263>computeJD(p);\n<line264>p->validHMS = 0;\n<line265>p->validYMD = 0;\n<line266>p->iJD += (i64)D*86400000;\n<line267>if( z[11]==0 ){\n<line268>rc = 0;\n<line269>break;\n<line270>}\n<line271>if( sqlite3Isspace(z[11])\n<line272>&& getDigits(&z[12], "20c:20e", &h, &m)==2\n<line273>){\n<line274>z2 = &z[12];\n<line275>n = 2;\n<line276>}else{\n<line277>break;\n<line278>}\n<line279>}\n<line280>if( z2[n]==':' ){\n<line281>/* A modifier of the form (+|-)HH:MM:SS.FFF adds (or subtracts) the\n<line282>** specified number of hours, minutes, seconds, and fractional seconds\n<line283>** to the time.  The ".FFF" may be omitted.  The ":SS.FFF" may be\n<line284>** omitted.\n<line285>*/\n<line286>DateTime tx;\n<line287>sqlite3_int64 day;\n<line288>if( !sqlite3Isdigit(*z2) ) z2++;\n<line289>memset(&tx, 0, sizeof(tx));\n<line290>if( parseHhMmSs(z2, &tx) ) break;\n<line291>computeJD(&tx);\n<line292>tx.iJD -= 43200000;\n<line293>day = tx.iJD/86400000;\n<line294>tx.iJD -= day*86400000;\n<line295>if( z0=='-' ) tx.iJD = -tx.iJD;\n<line296>computeJD(p);\n<line297>clearYMD_HMS_TZ(p);\n<line298>p->iJD += tx.iJD;\n<line299>rc = 0;\n<line300>break;\n<line301>}\n<line302>/* If control reaches this point, it means the transformation is\n<line303>** one of the forms like "+NNN days".  */\n<line304>z += n;\n<line305>while( sqlite3Isspace(*z) ) z++;\n<line306>n = sqlite3Strlen30(z);\n<line307>if( n<3 || n>10 ) break;\n<line308>if( sqlite3UpperToLower[(u8)z[n-1]]=='s' ) n--;\n<line309>computeJD(p);\n<line310>assert( rc==1 );\n<line311>rRounder = r<0 ? -0.5 : +0.5;\n<line312>p->nFloor = 0;\n<line313>for(i=0; i<ArraySize(aXformType); i++){\n<line314>if( aXformType[i].nName==n\n<line315>&& sqlite3_strnicmp(aXformType[i].zName, z, n)==0\n<line316>&& r>-aXformType[i].rLimit && r<aXformType[i].rLimit\n<line317>){\n<line318>switch( i ){\n<line319>case 4: { /* Special processing to add months */\n<line320>assert( strcmp(aXformType[4].zName,"month")==0 );\n<line321>computeYMD_HMS(p);\n<line322>p->M += (int)r;\n<line323>x = p->M>0 ? (p->M-1)/12 : (p->M-12)/12;\n<line324>p->Y += x;\n<line325>p->M -= x*12;\n<line326>computeFloor(p);\n<line327>p->validJD = 0;\n<line328>r -= (int)r;\n<line329>break;\n<line330>}\n<line331>case 5: { /* Special processing to add years */\n<line332>int y = (int)r;\n<line333>assert( strcmp(aXformType[5].zName,"year")==0 );\n<line334>computeYMD_HMS(p);\n<line335>assert( p->M>=0 && p->M<=12 );\n<line336>p->Y += y;\n<line337>computeFloor(p);\n<line338>p->validJD = 0;\n<line339>r -= (int)r;\n<line340>break;\n<line341>}\n<line342>}\n<line343>computeJD(p);\n<line344>p->iJD += (sqlite3_int64)(r*1000.0*aXformType[i].rXform + rRounder);\n<line345>rc = 0;\n<line346>break;\n<line347>}\n<line348>}\n<line349>clearYMD_HMS_TZ(p);\n<line350>break;\n<line351>}\n<line352>default: {\n<line353>break;\n<line354>}\n<line355>}\n<line356>return rc;\n<line357>}
----------------------------------------
Function: isDate
Content: <line0>static int isDate(\n<line1>sqlite3_context *context,\n<line2>int argc,\n<line3>sqlite3_value **argv,\n<line4>DateTime *p\n<line5>){\n<line6>int i, n;\n<line7>const unsigned char *z;\n<line8>int eType;\n<line9>memset(p, 0, sizeof(*p));\n<line10>if( argc==0 ){\n<line11>if( !sqlite3NotPureFunc(context) ) return 1;\n<line12>return setDateTimeToCurrent(context, p);\n<line13>}\n<line14>if( (eType = sqlite3_value_type(argv[0]))==SQLITE_FLOAT\n<line15>|| eType==SQLITE_INTEGER ){\n<line16>setRawDateNumber(p, sqlite3_value_double(argv[0]));\n<line17>}else{\n<line18>z = sqlite3_value_text(argv[0]);\n<line19>if( !z || parseDateOrTime(context, (char*)z, p) ){\n<line20>return 1;\n<line21>}\n<line22>}\n<line23>for(i=1; i<argc; i++){\n<line24>z = sqlite3_value_text(argv[i]);\n<line25>n = sqlite3_value_bytes(argv[i]);\n<line26>if( z==0 || parseModifier(context, (char*)z, n, p, i) ) return 1;\n<line27>}\n<line28>computeJD(p);\n<line29>if( p->isError || !validJulianDay(p->iJD) ) return 1;\n<line30>if( argc==1 && p->validYMD && p->D>28 ){\n<line31>/* Make sure a YYYY-MM-DD is normalized.\n<line32>** Example: 2023-02-31 -> 2023-03-03 */\n<line33>assert( p->validJD );\n<line34>p->validYMD = 0;\n<line35>}\n<line36>return 0;\n<line37>}
----------------------------------------
Function: juliandayFunc
Content: <line0>static void juliandayFunc(\n<line1>sqlite3_context *context,\n<line2>int argc,\n<line3>sqlite3_value **argv\n<line4>){\n<line5>DateTime x;\n<line6>if( isDate(context, argc, argv, &x)==0 ){\n<line7>computeJD(&x);\n<line8>sqlite3_result_double(context, x.iJD/86400000.0);\n<line9>}\n<line10>}
----------------------------------------
Function: unixepochFunc
Content: <line0>static void unixepochFunc(\n<line1>sqlite3_context *context,\n<line2>int argc,\n<line3>sqlite3_value **argv\n<line4>){\n<line5>DateTime x;\n<line6>if( isDate(context, argc, argv, &x)==0 ){\n<line7>computeJD(&x);\n<line8>if( x.useSubsec ){\n<line9>sqlite3_result_double(context, (x.iJD - 21086676*(i64)10000000)/1000.0);\n<line10>}else{\n<line11>sqlite3_result_int64(context, x.iJD/1000 - 21086676*(i64)10000);\n<line12>}\n<line13>}\n<line14>}
----------------------------------------
Function: datetimeFunc
Content: <line0>static void datetimeFunc(\n<line1>sqlite3_context *context,\n<line2>int argc,\n<line3>sqlite3_value **argv\n<line4>){\n<line5>DateTime x;\n<line6>if( isDate(context, argc, argv, &x)==0 ){\n<line7>int Y, s, n;\n<line8>char zBuf[32];\n<line9>computeYMD_HMS(&x);\n<line10>Y = x.Y;\n<line11>if( Y<0 ) Y = -Y;\n<line12>zBuf[1] = '0' + (Y/1000)%10;\n<line13>zBuf[2] = '0' + (Y/100)%10;\n<line14>zBuf[3] = '0' + (Y/10)%10;\n<line15>zBuf[4] = '0' + (Y)%10;\n<line16>zBuf[5] = '-';\n<line17>zBuf[6] = '0' + (x.M/10)%10;\n<line18>zBuf[7] = '0' + (x.M)%10;\n<line19>zBuf[8] = '-';\n<line20>zBuf[9] = '0' + (x.D/10)%10;\n<line21>zBuf[10] = '0' + (x.D)%10;\n<line22>zBuf[11] = ' ';\n<line23>zBuf[12] = '0' + (x.h/10)%10;\n<line24>zBuf[13] = '0' + (x.h)%10;\n<line25>zBuf[14] = ':';\n<line26>zBuf[15] = '0' + (x.m/10)%10;\n<line27>zBuf[16] = '0' + (x.m)%10;\n<line28>zBuf[17] = ':';\n<line29>if( x.useSubsec ){\n<line30>s = (int)(1000.0*x.s + 0.5);\n<line31>zBuf[18] = '0' + (s/10000)%10;\n<line32>zBuf[19] = '0' + (s/1000)%10;\n<line33>zBuf[20] = '.';\n<line34>zBuf[21] = '0' + (s/100)%10;\n<line35>zBuf[22] = '0' + (s/10)%10;\n<line36>zBuf[23] = '0' + (s)%10;\n<line37>zBuf[24] = 0;\n<line38>n = 24;\n<line39>}else{\n<line40>s = (int)x.s;\n<line41>zBuf[18] = '0' + (s/10)%10;\n<line42>zBuf[19] = '0' + (s)%10;\n<line43>zBuf[20] = 0;\n<line44>n = 20;\n<line45>}\n<line46>if( x.Y<0 ){\n<line47>zBuf[0] = '-';\n<line48>sqlite3_result_text(context, zBuf, n, SQLITE_TRANSIENT);\n<line49>}else{\n<line50>sqlite3_result_text(context, &zBuf[1], n-1, SQLITE_TRANSIENT);\n<line51>}\n<line52>}\n<line53>}
----------------------------------------
Function: timeFunc
Content: <line0>static void timeFunc(\n<line1>sqlite3_context *context,\n<line2>int argc,\n<line3>sqlite3_value **argv\n<line4>){\n<line5>DateTime x;\n<line6>if( isDate(context, argc, argv, &x)==0 ){\n<line7>int s, n;\n<line8>char zBuf[16];\n<line9>computeHMS(&x);\n<line10>zBuf[0] = '0' + (x.h/10)%10;\n<line11>zBuf[1] = '0' + (x.h)%10;\n<line12>zBuf[2] = ':';\n<line13>zBuf[3] = '0' + (x.m/10)%10;\n<line14>zBuf[4] = '0' + (x.m)%10;\n<line15>zBuf[5] = ':';\n<line16>if( x.useSubsec ){\n<line17>s = (int)(1000.0*x.s + 0.5);\n<line18>zBuf[6] = '0' + (s/10000)%10;\n<line19>zBuf[7] = '0' + (s/1000)%10;\n<line20>zBuf[8] = '.';\n<line21>zBuf[9] = '0' + (s/100)%10;\n<line22>zBuf[10] = '0' + (s/10)%10;\n<line23>zBuf[11] = '0' + (s)%10;\n<line24>zBuf[12] = 0;\n<line25>n = 12;\n<line26>}else{\n<line27>s = (int)x.s;\n<line28>zBuf[6] = '0' + (s/10)%10;\n<line29>zBuf[7] = '0' + (s)%10;\n<line30>zBuf[8] = 0;\n<line31>n = 8;\n<line32>}\n<line33>sqlite3_result_text(context, zBuf, n, SQLITE_TRANSIENT);\n<line34>}\n<line35>}
----------------------------------------
Function: dateFunc
Content: <line0>static void dateFunc(\n<line1>sqlite3_context *context,\n<line2>int argc,\n<line3>sqlite3_value **argv\n<line4>){\n<line5>DateTime x;\n<line6>if( isDate(context, argc, argv, &x)==0 ){\n<line7>int Y;\n<line8>char zBuf[16];\n<line9>computeYMD(&x);\n<line10>Y = x.Y;\n<line11>if( Y<0 ) Y = -Y;\n<line12>zBuf[1] = '0' + (Y/1000)%10;\n<line13>zBuf[2] = '0' + (Y/100)%10;\n<line14>zBuf[3] = '0' + (Y/10)%10;\n<line15>zBuf[4] = '0' + (Y)%10;\n<line16>zBuf[5] = '-';\n<line17>zBuf[6] = '0' + (x.M/10)%10;\n<line18>zBuf[7] = '0' + (x.M)%10;\n<line19>zBuf[8] = '-';\n<line20>zBuf[9] = '0' + (x.D/10)%10;\n<line21>zBuf[10] = '0' + (x.D)%10;\n<line22>zBuf[11] = 0;\n<line23>if( x.Y<0 ){\n<line24>zBuf[0] = '-';\n<line25>sqlite3_result_text(context, zBuf, 11, SQLITE_TRANSIENT);\n<line26>}else{\n<line27>sqlite3_result_text(context, &zBuf[1], 10, SQLITE_TRANSIENT);\n<line28>}\n<line29>}\n<line30>}
----------------------------------------
Function: daysAfterJan01
Content: <line0>static int daysAfterJan01(DateTime *pDate){\n<line1>DateTime jan01 = *pDate;\n<line2>assert( jan01.validYMD );\n<line3>assert( jan01.validHMS );\n<line4>assert( pDate->validJD );\n<line5>jan01.validJD = 0;\n<line6>jan01.M = 1;\n<line7>jan01.D = 1;\n<line8>computeJD(&jan01);\n<line9>return (int)((pDate->iJD-jan01.iJD+43200000)/86400000);\n<line10>}
----------------------------------------
Function: daysAfterMonday
Content: <line0>static int daysAfterMonday(DateTime *pDate){\n<line1>assert( pDate->validJD );\n<line2>return (int)((pDate->iJD+43200000)/86400000) % 7;\n<line3>}
----------------------------------------
Function: daysAfterSunday
Content: <line0>static int daysAfterSunday(DateTime *pDate){\n<line1>assert( pDate->validJD );\n<line2>return (int)((pDate->iJD+129600000)/86400000) % 7;\n<line3>}
----------------------------------------
Function: strftimeFunc
Content: <line0>static void strftimeFunc(\n<line1>sqlite3_context *context,\n<line2>int argc,\n<line3>sqlite3_value **argv\n<line4>){\n<line5>DateTime x;\n<line6>size_t i,j;\n<line7>sqlite3 *db;\n<line8>const char *zFmt;\n<line9>sqlite3_str sRes;\n<line10>if( argc==0 ) return;\n<line11>zFmt = (const char*)sqlite3_value_text(argv[0]);\n<line12>if( zFmt==0 || isDate(context, argc-1, argv+1, &x) ) return;\n<line13>db = sqlite3_context_db_handle(context);\n<line14>sqlite3StrAccumInit(&sRes, 0, 0, 0, db->aLimit[SQLITE_LIMIT_LENGTH]);\n<line15>computeJD(&x);\n<line16>computeYMD_HMS(&x);\n<line17>for(i=j=0; zFmt[i]; i++){\n<line18>char cf;\n<line19>if( zFmt[i]!='%' ) continue;\n<line20>if( j<i ) sqlite3_str_append(&sRes, zFmt+j, (int)(i-j));\n<line21>i++;\n<line22>j = i + 1;\n<line23>cf = zFmt[i];\n<line24>switch( cf ){\n<line25>case 'd':  /* Fall thru */\n<line26>case 'e': {\n<line27>sqlite3_str_appendf(&sRes, cf=='d' ? "%02d" : "%2d", x.D);\n<line28>break;\n<line29>}\n<line30>case 'f': {  /* Fractional seconds.  (Non-standard) */\n<line31>double s = x.s;\n<line32>if( NEVER(s>59.999) ) s = 59.999;\n<line33>sqlite3_str_appendf(&sRes, "%06.3f", s);\n<line34>break;\n<line35>}\n<line36>case 'F': {\n<line37>sqlite3_str_appendf(&sRes, "%04d-%02d-%02d", x.Y, x.M, x.D);\n<line38>break;\n<line39>}\n<line40>case 'G': /* Fall thru */\n<line41>case 'g': {\n<line42>DateTime y = x;\n<line43>assert( y.validJD );\n<line44>/* Move y so that it is the Thursday in the same week as x */\n<line45>y.iJD += (3 - daysAfterMonday(&x))*86400000;\n<line46>y.validYMD = 0;\n<line47>computeYMD(&y);\n<line48>if( cf=='g' ){\n<line49>sqlite3_str_appendf(&sRes, "%02d", y.Y%100);\n<line50>}else{\n<line51>sqlite3_str_appendf(&sRes, "%04d", y.Y);\n<line52>}\n<line53>break;\n<line54>}\n<line55>case 'H':\n<line56>case 'k': {\n<line57>sqlite3_str_appendf(&sRes, cf=='H' ? "%02d" : "%2d", x.h);\n<line58>break;\n<line59>}\n<line60>case 'I': /* Fall thru */\n<line61>case 'l': {\n<line62>int h = x.h;\n<line63>if( h>12 ) h -= 12;\n<line64>if( h==0 ) h = 12;\n<line65>sqlite3_str_appendf(&sRes, cf=='I' ? "%02d" : "%2d", h);\n<line66>break;\n<line67>}\n<line68>case 'j': {  /* Day of year.  Jan01==1, Jan02==2, and so forth */\n<line69>sqlite3_str_appendf(&sRes,"%03d",daysAfterJan01(&x)+1);\n<line70>break;\n<line71>}\n<line72>case 'J': {  /* Julian day number.  (Non-standard) */\n<line73>sqlite3_str_appendf(&sRes,"%.16g",x.iJD/86400000.0);\n<line74>break;\n<line75>}\n<line76>case 'm': {\n<line77>sqlite3_str_appendf(&sRes,"%02d",x.M);\n<line78>break;\n<line79>}\n<line80>case 'M': {\n<line81>sqlite3_str_appendf(&sRes,"%02d",x.m);\n<line82>break;\n<line83>}\n<line84>case 'p': /* Fall thru */\n<line85>case 'P': {\n<line86>if( x.h>=12 ){\n<line87>sqlite3_str_append(&sRes, cf=='p' ? "PM" : "pm", 2);\n<line88>}else{\n<line89>sqlite3_str_append(&sRes, cf=='p' ? "AM" : "am", 2);\n<line90>}\n<line91>break;\n<line92>}\n<line93>case 'R': {\n<line94>sqlite3_str_appendf(&sRes, "%02d:%02d", x.h, x.m);\n<line95>break;\n<line96>}\n<line97>case 's': {\n<line98>if( x.useSubsec ){\n<line99>sqlite3_str_appendf(&sRes,"%.3f",\n<line100>(x.iJD - 21086676*(i64)10000000)/1000.0);\n<line101>}else{\n<line102>i64 iS = (i64)(x.iJD/1000 - 21086676*(i64)10000);\n<line103>sqlite3_str_appendf(&sRes,"%lld",iS);\n<line104>}\n<line105>break;\n<line106>}\n<line107>case 'S': {\n<line108>sqlite3_str_appendf(&sRes,"%02d",(int)x.s);\n<line109>break;\n<line110>}\n<line111>case 'T': {\n<line112>sqlite3_str_appendf(&sRes,"%02d:%02d:%02d", x.h, x.m, (int)x.s);\n<line113>break;\n<line114>}\n<line115>case 'u':    /* Day of week.  1 to 7.  Monday==1, Sunday==7 */\n<line116>case 'w': {  /* Day of week.  0 to 6.  Sunday==0, Monday==1 */\n<line117>char c = (char)daysAfterSunday(&x) + '0';\n<line118>if( c=='0' && cf=='u' ) c = '7';\n<line119>sqlite3_str_appendchar(&sRes, 1, c);\n<line120>break;\n<line121>}\n<line122>case 'U': {  /* Week num. 00-53. First Sun of the year is week 01 */\n<line123>sqlite3_str_appendf(&sRes,"%02d",\n<line124>(daysAfterJan01(&x)-daysAfterSunday(&x)+7)/7);\n<line125>break;\n<line126>}\n<line127>case 'V': {  /* Week num. 01-53. First week with a Thur is week 01 */\n<line128>DateTime y = x;\n<line129>/* Adjust y so that is the Thursday in the same week as x */\n<line130>assert( y.validJD );\n<line131>y.iJD += (3 - daysAfterMonday(&x))*86400000;\n<line132>y.validYMD = 0;\n<line133>computeYMD(&y);\n<line134>sqlite3_str_appendf(&sRes,"%02d", daysAfterJan01(&y)/7+1);\n<line135>break;\n<line136>}\n<line137>case 'W': {  /* Week num. 00-53. First Mon of the year is week 01 */\n<line138>sqlite3_str_appendf(&sRes,"%02d",\n<line139>(daysAfterJan01(&x)-daysAfterMonday(&x)+7)/7);\n<line140>break;\n<line141>}\n<line142>case 'Y': {\n<line143>sqlite3_str_appendf(&sRes,"%04d",x.Y);\n<line144>break;\n<line145>}\n<line146>case '%': {\n<line147>sqlite3_str_appendchar(&sRes, 1, '%');\n<line148>break;\n<line149>}\n<line150>default: {\n<line151>sqlite3_str_reset(&sRes);\n<line152>return;\n<line153>}\n<line154>}\n<line155>}\n<line156>if( j<i ) sqlite3_str_append(&sRes, zFmt+j, (int)(i-j));\n<line157>sqlite3ResultStrAccum(context, &sRes);\n<line158>}
----------------------------------------
Function: ctimeFunc
Content: <line0>static void ctimeFunc(\n<line1>sqlite3_context *context,\n<line2>int NotUsed,\n<line3>sqlite3_value **NotUsed2\n<line4>){\n<line5>UNUSED_PARAMETER2(NotUsed, NotUsed2);\n<line6>timeFunc(context, 0, 0);\n<line7>}
----------------------------------------
Function: cdateFunc
Content: <line0>static void cdateFunc(\n<line1>sqlite3_context *context,\n<line2>int NotUsed,\n<line3>sqlite3_value **NotUsed2\n<line4>){\n<line5>UNUSED_PARAMETER2(NotUsed, NotUsed2);\n<line6>dateFunc(context, 0, 0);\n<line7>}
----------------------------------------
Function: timediffFunc
Content: <line0>static void timediffFunc(\n<line1>sqlite3_context *context,\n<line2>int NotUsed1,\n<line3>sqlite3_value **argv\n<line4>){\n<line5>char sign;\n<line6>int Y, M;\n<line7>DateTime d1, d2;\n<line8>sqlite3_str sRes;\n<line9>UNUSED_PARAMETER(NotUsed1);\n<line10>if( isDate(context, 1, &argv[0], &d1) ) return;\n<line11>if( isDate(context, 1, &argv[1], &d2) ) return;\n<line12>computeYMD_HMS(&d1);\n<line13>computeYMD_HMS(&d2);\n<line14>if( d1.iJD>=d2.iJD ){\n<line15>sign = '+';\n<line16>Y = d1.Y - d2.Y;\n<line17>if( Y ){\n<line18>d2.Y = d1.Y;\n<line19>d2.validJD = 0;\n<line20>computeJD(&d2);\n<line21>}\n<line22>M = d1.M - d2.M;\n<line23>if( M<0 ){\n<line24>Y--;\n<line25>M += 12;\n<line26>}\n<line27>if( M!=0 ){\n<line28>d2.M = d1.M;\n<line29>d2.validJD = 0;\n<line30>computeJD(&d2);\n<line31>}\n<line32>while( d1.iJD<d2.iJD ){\n<line33>M--;\n<line34>if( M<0 ){\n<line35>M = 11;\n<line36>Y--;\n<line37>}\n<line38>d2.M--;\n<line39>if( d2.M<1 ){\n<line40>d2.M = 12;\n<line41>d2.Y--;\n<line42>}\n<line43>d2.validJD = 0;\n<line44>computeJD(&d2);\n<line45>}\n<line46>d1.iJD -= d2.iJD;\n<line47>d1.iJD += (u64)1486995408 * (u64)100000;\n<line48>}else /* d1<d2 */{\n<line49>sign = '-';\n<line50>Y = d2.Y - d1.Y;\n<line51>if( Y ){\n<line52>d2.Y = d1.Y;\n<line53>d2.validJD = 0;\n<line54>computeJD(&d2);\n<line55>}\n<line56>M = d2.M - d1.M;\n<line57>if( M<0 ){\n<line58>Y--;\n<line59>M += 12;\n<line60>}\n<line61>if( M!=0 ){\n<line62>d2.M = d1.M;\n<line63>d2.validJD = 0;\n<line64>computeJD(&d2);\n<line65>}\n<line66>while( d1.iJD>d2.iJD ){\n<line67>M--;\n<line68>if( M<0 ){\n<line69>M = 11;\n<line70>Y--;\n<line71>}\n<line72>d2.M++;\n<line73>if( d2.M>12 ){\n<line74>d2.M = 1;\n<line75>d2.Y++;\n<line76>}\n<line77>d2.validJD = 0;\n<line78>computeJD(&d2);\n<line79>}\n<line80>d1.iJD = d2.iJD - d1.iJD;\n<line81>d1.iJD += (u64)1486995408 * (u64)100000;\n<line82>}\n<line83>clearYMD_HMS_TZ(&d1);\n<line84>computeYMD_HMS(&d1);\n<line85>sqlite3StrAccumInit(&sRes, 0, 0, 0, 100);\n<line86>sqlite3_str_appendf(&sRes, "%c%04d-%02d-%02d %02d:%02d:%06.3f",\n<line87>sign, Y, M, d1.D-1, d1.h, d1.m, d1.s);\n<line88>sqlite3ResultStrAccum(context, &sRes);\n<line89>}
----------------------------------------
Function: ctimestampFunc
Content: <line0>static void ctimestampFunc(\n<line1>sqlite3_context *context,\n<line2>int NotUsed,\n<line3>sqlite3_value **NotUsed2\n<line4>){\n<line5>UNUSED_PARAMETER2(NotUsed, NotUsed2);\n<line6>datetimeFunc(context, 0, 0);\n<line7>}
----------------------------------------
Function: sqlite3_vfs_find
Content: <line0>SQLITE_API sqlite3_vfs *sqlite3_vfs_find(const char *zVfs){\n<line1>sqlite3_vfs *pVfs = 0;\n<line2>#if SQLITE_THREADSAFE\n<line3>sqlite3_mutex *mutex;\n<line4>#endif\n<line5>#ifndef SQLITE_OMIT_AUTOINIT\n<line6>int rc = sqlite3_initialize();\n<line7>if( rc ) return 0;\n<line8>#endif\n<line9>#if SQLITE_THREADSAFE\n<line10>mutex = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MAIN);\n<line11>#endif\n<line12>sqlite3_mutex_enter(mutex);\n<line13>for(pVfs = vfsList; pVfs; pVfs=pVfs->pNext){\n<line14>if( zVfs==0 ) break;\n<line15>if( strcmp(zVfs, pVfs->zName)==0 ) break;\n<line16>}\n<line17>sqlite3_mutex_leave(mutex);\n<line18>return pVfs;\n<line19>}
----------------------------------------
Function: vfsUnlink
Content: <line0>static void vfsUnlink(sqlite3_vfs *pVfs){\n<line1>assert( sqlite3_mutex_held(sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MAIN)) );\n<line2>if( pVfs==0 ){\n<line3>/* No-op */\n<line4>}else if( vfsList==pVfs ){\n<line5>vfsList = pVfs->pNext;\n<line6>}else if( vfsList ){\n<line7>sqlite3_vfs *p = vfsList;\n<line8>while( p->pNext && p->pNext!=pVfs ){\n<line9>p = p->pNext;\n<line10>}\n<line11>if( p->pNext==pVfs ){\n<line12>p->pNext = pVfs->pNext;\n<line13>}\n<line14>}\n<line15>}
----------------------------------------
Function: sqlite3_vfs_register
Content: <line0>SQLITE_API int sqlite3_vfs_register(sqlite3_vfs *pVfs, int makeDflt){\n<line1>MUTEX_LOGIC(sqlite3_mutex *mutex;)\n<line2>#ifndef SQLITE_OMIT_AUTOINIT\n<line3>int rc = sqlite3_initialize();\n<line4>if( rc ) return rc;\n<line5>#endif\n<line6>#ifdef SQLITE_ENABLE_API_ARMOR\n<line7>if( pVfs==0 ) return SQLITE_MISUSE_BKPT;\n<line8>#endif\n<line9>MUTEX_LOGIC( mutex = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MAIN); )\n<line10>sqlite3_mutex_enter(mutex);\n<line11>vfsUnlink(pVfs);\n<line12>if( makeDflt || vfsList==0 ){\n<line13>pVfs->pNext = vfsList;\n<line14>vfsList = pVfs;\n<line15>}else{\n<line16>pVfs->pNext = vfsList->pNext;\n<line17>vfsList->pNext = pVfs;\n<line18>}\n<line19>assert(vfsList);\n<line20>sqlite3_mutex_leave(mutex);\n<line21>return SQLITE_OK;\n<line22>}
----------------------------------------
Function: sqlite3_vfs_unregister
Content: <line0>SQLITE_API int sqlite3_vfs_unregister(sqlite3_vfs *pVfs){\n<line1>MUTEX_LOGIC(sqlite3_mutex *mutex;)\n<line2>#ifndef SQLITE_OMIT_AUTOINIT\n<line3>int rc = sqlite3_initialize();\n<line4>if( rc ) return rc;\n<line5>#endif\n<line6>MUTEX_LOGIC( mutex = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MAIN); )\n<line7>sqlite3_mutex_enter(mutex);\n<line8>vfsUnlink(pVfs);\n<line9>sqlite3_mutex_leave(mutex);\n<line10>return SQLITE_OK;\n<line11>}
----------------------------------------
Function: sqlite3MemMalloc
Content: <line0>static void *sqlite3MemMalloc(int nByte){\n<line1>#ifdef SQLITE_MALLOCSIZE\n<line2>void *p;\n<line3>testcase( ROUND8(nByte)==nByte );\n<line4>p = SQLITE_MALLOC( nByte );\n<line5>if( p==0 ){\n<line6>testcase( sqlite3GlobalConfig.xLog!=0 );\n<line7>sqlite3_log(SQLITE_NOMEM, "failed to allocate %u bytes of memory", nByte);\n<line8>}\n<line9>return p;\n<line10>#else\n<line11>sqlite3_int64 *p;\n<line12>assert( nByte>0 );\n<line13>testcase( ROUND8(nByte)!=nByte );\n<line14>p = SQLITE_MALLOC( nByte+8 );\n<line15>if( p ){\n<line16>p[0] = nByte;\n<line17>p++;\n<line18>}else{\n<line19>testcase( sqlite3GlobalConfig.xLog!=0 );\n<line20>sqlite3_log(SQLITE_NOMEM, "failed to allocate %u bytes of memory", nByte);\n<line21>}\n<line22>return (void *)p;\n<line23>#endif\n<line24>}
----------------------------------------
Function: sqlite3MemFree
Content: <line0>static void sqlite3MemFree(void *pPrior){\n<line1>#ifdef SQLITE_MALLOCSIZE\n<line2>SQLITE_FREE(pPrior);\n<line3>#else\n<line4>sqlite3_int64 *p = (sqlite3_int64*)pPrior;\n<line5>assert( pPrior!=0 );\n<line6>p--;\n<line7>SQLITE_FREE(p);\n<line8>#endif\n<line9>}
----------------------------------------
Function: sqlite3MemSize
Content: <line0>static int sqlite3MemSize(void *pPrior){\n<line1>#ifdef SQLITE_MALLOCSIZE\n<line2>assert( pPrior!=0 );\n<line3>return (int)SQLITE_MALLOCSIZE(pPrior);\n<line4>#else\n<line5>sqlite3_int64 *p;\n<line6>assert( pPrior!=0 );\n<line7>p = (sqlite3_int64*)pPrior;\n<line8>p--;\n<line9>return (int)p[0];\n<line10>#endif\n<line11>}
----------------------------------------
Function: sqlite3MemRealloc
Content: <line0>static void *sqlite3MemRealloc(void *pPrior, int nByte){\n<line1>#ifdef SQLITE_MALLOCSIZE\n<line2>void *p = SQLITE_REALLOC(pPrior, nByte);\n<line3>if( p==0 ){\n<line4>testcase( sqlite3GlobalConfig.xLog!=0 );\n<line5>sqlite3_log(SQLITE_NOMEM,\n<line6>"failed memory resize %u to %u bytes",\n<line7>SQLITE_MALLOCSIZE(pPrior), nByte);\n<line8>}\n<line9>return p;\n<line10>#else\n<line11>sqlite3_int64 *p = (sqlite3_int64*)pPrior;\n<line12>assert( pPrior!=0 && nByte>0 );\n<line13>assert( nByte==ROUND8(nByte) ); /* EV: R-46199-30249 */\n<line14>p--;\n<line15>p = SQLITE_REALLOC(p, nByte+8 );\n<line16>if( p ){\n<line17>p[0] = nByte;\n<line18>p++;\n<line19>}else{\n<line20>testcase( sqlite3GlobalConfig.xLog!=0 );\n<line21>sqlite3_log(SQLITE_NOMEM,\n<line22>"failed memory resize %u to %u bytes",\n<line23>sqlite3MemSize(pPrior), nByte);\n<line24>}\n<line25>return (void*)p;\n<line26>#endif\n<line27>}
----------------------------------------
Function: sqlite3MemRoundup
Content: <line0>static int sqlite3MemRoundup(int n){\n<line1>return ROUND8(n);\n<line2>}
----------------------------------------
Function: sqlite3MemInit
Content: <line0>static int sqlite3MemInit(void *NotUsed){\n<line1>#if defined(__APPLE__) && !defined(SQLITE_WITHOUT_ZONEMALLOC)\n<line2>int cpuCount;\n<line3>size_t len;\n<line4>if( _sqliteZone_ ){\n<line5>return SQLITE_OK;\n<line6>}\n<line7>len = sizeof(cpuCount);\n<line8>/* One usually wants to use hw.activecpu for MT decisions, but not here */\n<line9>sysctlbyname("hw.ncpu", &cpuCount, &len, NULL, 0);\n<line10>if( cpuCount>1 ){\n<line11>/* defer MT decisions to system malloc */\n<line12>_sqliteZone_ = malloc_default_zone();\n<line13>}else{\n<line14>/* only 1 core, use our own zone to contention over global locks,\n<line15>** e.g. we have our own dedicated locks */\n<line16>_sqliteZone_ = malloc_create_zone(4096, 0);\n<line17>malloc_set_zone_name(_sqliteZone_, "Sqlite_Heap");\n<line18>}\n<line19>#endif /*  defined(__APPLE__) && !defined(SQLITE_WITHOUT_ZONEMALLOC) */\n<line20>UNUSED_PARAMETER(NotUsed);\n<line21>return SQLITE_OK;\n<line22>}
----------------------------------------
Function: sqlite3MemShutdown
Content: <line0>static void sqlite3MemShutdown(void *NotUsed){\n<line1>UNUSED_PARAMETER(NotUsed);\n<line2>return;\n<line3>}
----------------------------------------
Function: sqlite3_mutex_alloc
Content: <line0>SQLITE_API sqlite3_mutex *sqlite3_mutex_alloc(int id){\n<line1>#ifndef SQLITE_OMIT_AUTOINIT\n<line2>if( id<=SQLITE_MUTEX_RECURSIVE && sqlite3_initialize() ) return 0;\n<line3>if( id>SQLITE_MUTEX_RECURSIVE && sqlite3MutexInit() ) return 0;\n<line4>#endif\n<line5>assert( sqlite3GlobalConfig.mutex.xMutexAlloc );\n<line6>return sqlite3GlobalConfig.mutex.xMutexAlloc(id);\n<line7>}
----------------------------------------
Function: sqlite3_mutex_free
Content: <line0>SQLITE_API void sqlite3_mutex_free(sqlite3_mutex *p){\n<line1>if( p ){\n<line2>assert( sqlite3GlobalConfig.mutex.xMutexFree );\n<line3>sqlite3GlobalConfig.mutex.xMutexFree(p);\n<line4>}\n<line5>}
----------------------------------------
Function: sqlite3_mutex_enter
Content: <line0>SQLITE_API void sqlite3_mutex_enter(sqlite3_mutex *p){\n<line1>if( p ){\n<line2>assert( sqlite3GlobalConfig.mutex.xMutexEnter );\n<line3>sqlite3GlobalConfig.mutex.xMutexEnter(p);\n<line4>}\n<line5>}
----------------------------------------
Function: sqlite3_mutex_try
Content: <line0>SQLITE_API int sqlite3_mutex_try(sqlite3_mutex *p){\n<line1>int rc = SQLITE_OK;\n<line2>if( p ){\n<line3>assert( sqlite3GlobalConfig.mutex.xMutexTry );\n<line4>return sqlite3GlobalConfig.mutex.xMutexTry(p);\n<line5>}\n<line6>return rc;\n<line7>}
----------------------------------------
Function: sqlite3_mutex_leave
Content: <line0>SQLITE_API void sqlite3_mutex_leave(sqlite3_mutex *p){\n<line1>if( p ){\n<line2>assert( sqlite3GlobalConfig.mutex.xMutexLeave );\n<line3>sqlite3GlobalConfig.mutex.xMutexLeave(p);\n<line4>}\n<line5>}
----------------------------------------
Function: noopMutexInit
Content: <line0>static int noopMutexInit(void){ return SQLITE_OK; }
----------------------------------------
Function: noopMutexEnd
Content: <line0>static int noopMutexEnd(void){ return SQLITE_OK; }
----------------------------------------
Function: noopMutexAlloc
Content: <line0>static sqlite3_mutex *noopMutexAlloc(int id){\n<line1>UNUSED_PARAMETER(id);\n<line2>return (sqlite3_mutex*)8;\n<line3>}
----------------------------------------
Function: noopMutexFree
Content: <line0>static void noopMutexFree(sqlite3_mutex *p){ UNUSED_PARAMETER(p); return; }
----------------------------------------
Function: noopMutexEnter
Content: <line0>static void noopMutexEnter(sqlite3_mutex *p){ UNUSED_PARAMETER(p); return; }
----------------------------------------
Function: noopMutexTry
Content: <line0>static int noopMutexTry(sqlite3_mutex *p){\n<line1>UNUSED_PARAMETER(p);\n<line2>return SQLITE_OK;\n<line3>}
----------------------------------------
Function: noopMutexLeave
Content: <line0>static void noopMutexLeave(sqlite3_mutex *p){ UNUSED_PARAMETER(p); return; }
----------------------------------------
Function: pthreadMutexInit
Content: <line0>static int pthreadMutexInit(void){ return SQLITE_OK; }
----------------------------------------
Function: pthreadMutexEnd
Content: <line0>static int pthreadMutexEnd(void){ return SQLITE_OK; }
----------------------------------------
Function: pthreadMutexAlloc
Content: <line0>static sqlite3_mutex *pthreadMutexAlloc(int iType){\n<line1>static sqlite3_mutex staticMutexes[] = {\n<line2>SQLITE3_MUTEX_INITIALIZER(2),\n<line3>SQLITE3_MUTEX_INITIALIZER(3),\n<line4>SQLITE3_MUTEX_INITIALIZER(4),\n<line5>SQLITE3_MUTEX_INITIALIZER(5),\n<line6>SQLITE3_MUTEX_INITIALIZER(6),\n<line7>SQLITE3_MUTEX_INITIALIZER(7),\n<line8>SQLITE3_MUTEX_INITIALIZER(8),\n<line9>SQLITE3_MUTEX_INITIALIZER(9),\n<line10>SQLITE3_MUTEX_INITIALIZER(10),\n<line11>SQLITE3_MUTEX_INITIALIZER(11),\n<line12>SQLITE3_MUTEX_INITIALIZER(12),\n<line13>SQLITE3_MUTEX_INITIALIZER(13)\n<line14>};\n<line15>sqlite3_mutex *p;\n<line16>switch( iType ){\n<line17>case SQLITE_MUTEX_RECURSIVE: {\n<line18>p = sqlite3MallocZero( sizeof(*p) );\n<line19>if( p ){\n<line20>#ifdef SQLITE_HOMEGROWN_RECURSIVE_MUTEX\n<line21>/* If recursive mutexes are not available, we will have to\n<line22>** build our own.  See below. */\n<line23>pthread_mutex_init(&p->mutex, 0);\n<line24>#else\n<line25>/* Use a recursive mutex if it is available */\n<line26>pthread_mutexattr_t recursiveAttr;\n<line27>pthread_mutexattr_init(&recursiveAttr);\n<line28>pthread_mutexattr_settype(&recursiveAttr, PTHREAD_MUTEX_RECURSIVE);\n<line29>pthread_mutex_init(&p->mutex, &recursiveAttr);\n<line30>pthread_mutexattr_destroy(&recursiveAttr);\n<line31>#endif\n<line32>#if SQLITE_MUTEX_NREF || defined(SQLITE_ENABLE_API_ARMOR)\n<line33>p->id = SQLITE_MUTEX_RECURSIVE;\n<line34>#endif\n<line35>}\n<line36>break;\n<line37>}\n<line38>case SQLITE_MUTEX_FAST: {\n<line39>p = sqlite3MallocZero( sizeof(*p) );\n<line40>if( p ){\n<line41>pthread_mutex_init(&p->mutex, 0);\n<line42>#if SQLITE_MUTEX_NREF || defined(SQLITE_ENABLE_API_ARMOR)\n<line43>p->id = SQLITE_MUTEX_FAST;\n<line44>#endif\n<line45>}\n<line46>break;\n<line47>}\n<line48>default: {\n<line49>#ifdef SQLITE_ENABLE_API_ARMOR\n<line50>if( iType-2<0 || iType-2>=ArraySize(staticMutexes) ){\n<line51>(void)SQLITE_MISUSE_BKPT;\n<line52>return 0;\n<line53>}\n<line54>#endif\n<line55>p = &staticMutexes[iType-2];\n<line56>break;\n<line57>}\n<line58>}\n<line59>#if SQLITE_MUTEX_NREF || defined(SQLITE_ENABLE_API_ARMOR)\n<line60>assert( p==0 || p->id==iType );\n<line61>#endif\n<line62>return p;\n<line63>}
----------------------------------------
Function: pthreadMutexFree
Content: <line0>static void pthreadMutexFree(sqlite3_mutex *p){\n<line1>assert( p->nRef==0 );\n<line2>#ifdef SQLITE_ENABLE_API_ARMOR\n<line3>if( p->id==SQLITE_MUTEX_FAST || p->id==SQLITE_MUTEX_RECURSIVE )\n<line4>#endif\n<line5>{\n<line6>pthread_mutex_destroy(&p->mutex);\n<line7>sqlite3_free(p);\n<line8>}\n<line9>#ifdef SQLITE_ENABLE_API_ARMOR\n<line10>else{\n<line11>(void)SQLITE_MISUSE_BKPT;\n<line12>}\n<line13>#endif\n<line14>}
----------------------------------------
Function: pthreadMutexEnter
Content: <line0>static void pthreadMutexEnter(sqlite3_mutex *p){\n<line1>assert( p->id==SQLITE_MUTEX_RECURSIVE || pthreadMutexNotheld(p) );\n<line2>#ifdef SQLITE_HOMEGROWN_RECURSIVE_MUTEX\n<line3>/* If recursive mutexes are not available, then we have to grow\n<line4>** our own.  This implementation assumes that pthread_equal()\n<line5>** is atomic - that it cannot be deceived into thinking self\n<line6>** and p->owner are equal if p->owner changes between two values\n<line7>** that are not equal to self while the comparison is taking place.\n<line8>** This implementation also assumes a coherent cache - that\n<line9>** separate processes cannot read different values from the same\n<line10>** address at the same time.  If either of these two conditions\n<line11>** are not met, then the mutexes will fail and problems will result.\n<line12>*/\n<line13>{\n<line14>pthread_t self = pthread_self();\n<line15>if( p->nRef>0 && pthread_equal(p->owner, self) ){\n<line16>p->nRef++;\n<line17>}else{\n<line18>pthread_mutex_lock(&p->mutex);\n<line19>assert( p->nRef==0 );\n<line20>p->owner = self;\n<line21>p->nRef = 1;\n<line22>}\n<line23>}\n<line24>#else\n<line25>/* Use the built-in recursive mutexes if they are available.\n<line26>*/\n<line27>pthread_mutex_lock(&p->mutex);\n<line28>#if SQLITE_MUTEX_NREF\n<line29>assert( p->nRef>0 || p->owner==0 );\n<line30>p->owner = pthread_self();\n<line31>p->nRef++;\n<line32>#endif\n<line33>#endif\n<line34>#ifdef SQLITE_DEBUG\n<line35>if( p->trace ){\n<line36>printf("enter mutex %p (%d) with nRef=%d\n", p, p->trace, p->nRef);\n<line37>}\n<line38>#endif\n<line39>}
----------------------------------------
Function: pthreadMutexTry
Content: <line0>static int pthreadMutexTry(sqlite3_mutex *p){\n<line1>int rc;\n<line2>assert( p->id==SQLITE_MUTEX_RECURSIVE || pthreadMutexNotheld(p) );\n<line3>#ifdef SQLITE_HOMEGROWN_RECURSIVE_MUTEX\n<line4>/* If recursive mutexes are not available, then we have to grow\n<line5>** our own.  This implementation assumes that pthread_equal()\n<line6>** is atomic - that it cannot be deceived into thinking self\n<line7>** and p->owner are equal if p->owner changes between two values\n<line8>** that are not equal to self while the comparison is taking place.\n<line9>** This implementation also assumes a coherent cache - that\n<line10>** separate processes cannot read different values from the same\n<line11>** address at the same time.  If either of these two conditions\n<line12>** are not met, then the mutexes will fail and problems will result.\n<line13>*/\n<line14>{\n<line15>pthread_t self = pthread_self();\n<line16>if( p->nRef>0 && pthread_equal(p->owner, self) ){\n<line17>p->nRef++;\n<line18>rc = SQLITE_OK;\n<line19>}else if( pthread_mutex_trylock(&p->mutex)==0 ){\n<line20>assert( p->nRef==0 );\n<line21>p->owner = self;\n<line22>p->nRef = 1;\n<line23>rc = SQLITE_OK;\n<line24>}else{\n<line25>rc = SQLITE_BUSY;\n<line26>}\n<line27>}\n<line28>#else\n<line29>/* Use the built-in recursive mutexes if they are available.\n<line30>*/\n<line31>if( pthread_mutex_trylock(&p->mutex)==0 ){\n<line32>#if SQLITE_MUTEX_NREF\n<line33>p->owner = pthread_self();\n<line34>p->nRef++;\n<line35>#endif\n<line36>rc = SQLITE_OK;\n<line37>}else{\n<line38>rc = SQLITE_BUSY;\n<line39>}\n<line40>#endif\n<line41>#ifdef SQLITE_DEBUG\n<line42>if( rc==SQLITE_OK && p->trace ){\n<line43>printf("enter mutex %p (%d) with nRef=%d\n", p, p->trace, p->nRef);\n<line44>}\n<line45>#endif\n<line46>return rc;\n<line47>}
----------------------------------------
Function: pthreadMutexLeave
Content: <line0>static void pthreadMutexLeave(sqlite3_mutex *p){\n<line1>assert( pthreadMutexHeld(p) );\n<line2>#if SQLITE_MUTEX_NREF\n<line3>p->nRef--;\n<line4>if( p->nRef==0 ) p->owner = 0;\n<line5>#endif\n<line6>assert( p->nRef==0 || p->id==SQLITE_MUTEX_RECURSIVE );\n<line7>#ifdef SQLITE_HOMEGROWN_RECURSIVE_MUTEX\n<line8>if( p->nRef==0 ){\n<line9>pthread_mutex_unlock(&p->mutex);\n<line10>}\n<line11>#else\n<line12>pthread_mutex_unlock(&p->mutex);\n<line13>#endif\n<line14>#ifdef SQLITE_DEBUG\n<line15>if( p->trace ){\n<line16>printf("leave mutex %p (%d) with nRef=%d\n", p, p->trace, p->nRef);\n<line17>}\n<line18>#endif\n<line19>}
----------------------------------------
Function: sqlite3_release_memory
Content: <line0>SQLITE_API int sqlite3_release_memory(int n){\n<line1>#ifdef SQLITE_ENABLE_MEMORY_MANAGEMENT\n<line2>return sqlite3PcacheReleaseMemory(n);\n<line3>#else\n<line4>/* IMPLEMENTATION-OF: R-34391-24921 The sqlite3_release_memory() routine\n<line5>** is a no-op returning zero if SQLite is not compiled with\n<line6>** SQLITE_ENABLE_MEMORY_MANAGEMENT. */\n<line7>UNUSED_PARAMETER(n);\n<line8>return 0;\n<line9>#endif\n<line10>}
----------------------------------------
Function: sqlite3_memory_alarm
Content: <line0>SQLITE_API int sqlite3_memory_alarm(\n<line1>void(*xCallback)(void *pArg, sqlite3_int64 used,int N),\n<line2>void *pArg,\n<line3>sqlite3_int64 iThreshold\n<line4>){\n<line5>(void)xCallback;\n<line6>(void)pArg;\n<line7>(void)iThreshold;\n<line8>return SQLITE_OK;\n<line9>}
----------------------------------------
Function: sqlite3_soft_heap_limit64
Content: <line0>SQLITE_API sqlite3_int64 sqlite3_soft_heap_limit64(sqlite3_int64 n){\n<line1>sqlite3_int64 priorLimit;\n<line2>sqlite3_int64 excess;\n<line3>sqlite3_int64 nUsed;\n<line4>#ifndef SQLITE_OMIT_AUTOINIT\n<line5>int rc = sqlite3_initialize();\n<line6>if( rc ) return -1;\n<line7>#endif\n<line8>sqlite3_mutex_enter(mem0.mutex);\n<line9>priorLimit = mem0.alarmThreshold;\n<line10>if( n<0 ){\n<line11>sqlite3_mutex_leave(mem0.mutex);\n<line12>return priorLimit;\n<line13>}\n<line14>if( mem0.hardLimit>0 && (n>mem0.hardLimit || n==0) ){\n<line15>n = mem0.hardLimit;\n<line16>}\n<line17>mem0.alarmThreshold = n;\n<line18>nUsed = sqlite3StatusValue(SQLITE_STATUS_MEMORY_USED);\n<line19>AtomicStore(&mem0.nearlyFull, n>0 && n<=nUsed);\n<line20>sqlite3_mutex_leave(mem0.mutex);\n<line21>excess = sqlite3_memory_used() - n;\n<line22>if( excess>0 ) sqlite3_release_memory((int)(excess & 0x7fffffff));\n<line23>return priorLimit;\n<line24>}
----------------------------------------
Function: sqlite3_soft_heap_limit
Content: <line0>SQLITE_API void sqlite3_soft_heap_limit(int n){\n<line1>if( n<0 ) n = 0;\n<line2>sqlite3_soft_heap_limit64(n);\n<line3>}
----------------------------------------
Function: sqlite3_hard_heap_limit64
Content: <line0>SQLITE_API sqlite3_int64 sqlite3_hard_heap_limit64(sqlite3_int64 n){\n<line1>sqlite3_int64 priorLimit;\n<line2>#ifndef SQLITE_OMIT_AUTOINIT\n<line3>int rc = sqlite3_initialize();\n<line4>if( rc ) return -1;\n<line5>#endif\n<line6>sqlite3_mutex_enter(mem0.mutex);\n<line7>priorLimit = mem0.hardLimit;\n<line8>if( n>=0 ){\n<line9>mem0.hardLimit = n;\n<line10>if( n<mem0.alarmThreshold || mem0.alarmThreshold==0 ){\n<line11>mem0.alarmThreshold = n;\n<line12>}\n<line13>}\n<line14>sqlite3_mutex_leave(mem0.mutex);\n<line15>return priorLimit;\n<line16>}
----------------------------------------
Function: sqlite3_memory_used
Content: <line0>SQLITE_API sqlite3_int64 sqlite3_memory_used(void){\n<line1>sqlite3_int64 res, mx;\n<line2>sqlite3_status64(SQLITE_STATUS_MEMORY_USED, &res, &mx, 0);\n<line3>return res;\n<line4>}
----------------------------------------
Function: sqlite3_memory_highwater
Content: <line0>SQLITE_API sqlite3_int64 sqlite3_memory_highwater(int resetFlag){\n<line1>sqlite3_int64 res, mx;\n<line2>sqlite3_status64(SQLITE_STATUS_MEMORY_USED, &res, &mx, resetFlag);\n<line3>return mx;\n<line4>}
----------------------------------------
Function: sqlite3MallocAlarm
Content: <line0>static void sqlite3MallocAlarm(int nByte){\n<line1>if( mem0.alarmThreshold<=0 ) return;\n<line2>sqlite3_mutex_leave(mem0.mutex);\n<line3>sqlite3_release_memory(nByte);\n<line4>sqlite3_mutex_enter(mem0.mutex);\n<line5>}
----------------------------------------
Function: mallocWithAlarm
Content: <line0>static void mallocWithAlarm(int n, void **pp){\n<line1>void *p;\n<line2>int nFull;\n<line3>assert( sqlite3_mutex_held(mem0.mutex) );\n<line4>assert( n>0 );\n<line5>/* In Firefox (circa 2017-02-08), xRoundup() is remapped to an internal\n<line6>** implementation of malloc_good_size(), which must be called in debug\n<line7>** mode and specifically when the DMD "Dark Matter Detector" is enabled\n<line8>** or else a crash results.  Hence, do not attempt to optimize out the\n<line9>** following xRoundup() call. */\n<line10>nFull = sqlite3GlobalConfig.m.xRoundup(n);\n<line11>sqlite3StatusHighwater(SQLITE_STATUS_MALLOC_SIZE, n);\n<line12>if( mem0.alarmThreshold>0 ){\n<line13>sqlite3_int64 nUsed = sqlite3StatusValue(SQLITE_STATUS_MEMORY_USED);\n<line14>if( nUsed >= mem0.alarmThreshold - nFull ){\n<line15>AtomicStore(&mem0.nearlyFull, 1);\n<line16>sqlite3MallocAlarm(nFull);\n<line17>if( mem0.hardLimit ){\n<line18>nUsed = sqlite3StatusValue(SQLITE_STATUS_MEMORY_USED);\n<line19>if( nUsed >= mem0.hardLimit - nFull ){\n<line20>test_oom_breakpoint(1);\n<line21>*pp = 0;\n<line22>return;\n<line23>}\n<line24>}\n<line25>}else{\n<line26>AtomicStore(&mem0.nearlyFull, 0);\n<line27>}\n<line28>}\n<line29>p = sqlite3GlobalConfig.m.xMalloc(nFull);\n<line30>#ifdef SQLITE_ENABLE_MEMORY_MANAGEMENT\n<line31>if( p==0 && mem0.alarmThreshold>0 ){\n<line32>sqlite3MallocAlarm(nFull);\n<line33>p = sqlite3GlobalConfig.m.xMalloc(nFull);\n<line34>}\n<line35>#endif\n<line36>if( p ){\n<line37>nFull = sqlite3MallocSize(p);\n<line38>sqlite3StatusUp(SQLITE_STATUS_MEMORY_USED, nFull);\n<line39>sqlite3StatusUp(SQLITE_STATUS_MALLOC_COUNT, 1);\n<line40>}\n<line41>*pp = p;\n<line42>}
----------------------------------------
Function: sqlite3_malloc
Content: <line0>SQLITE_API void *sqlite3_malloc(int n){\n<line1>#ifndef SQLITE_OMIT_AUTOINIT\n<line2>if( sqlite3_initialize() ) return 0;\n<line3>#endif\n<line4>return n<=0 ? 0 : sqlite3Malloc(n);\n<line5>}
----------------------------------------
Function: sqlite3_malloc64
Content: <line0>SQLITE_API void *sqlite3_malloc64(sqlite3_uint64 n){\n<line1>#ifndef SQLITE_OMIT_AUTOINIT\n<line2>if( sqlite3_initialize() ) return 0;\n<line3>#endif\n<line4>return sqlite3Malloc(n);\n<line5>}
----------------------------------------
Function: isLookaside
Content: <line0>static int isLookaside(sqlite3 *db, const void *p){\n<line1>return SQLITE_WITHIN(p, db->lookaside.pStart, db->lookaside.pTrueEnd);\n<line2>}
----------------------------------------
Function: lookasideMallocSize
Content: <line0>static int lookasideMallocSize(sqlite3 *db, const void *p){\n<line1>#ifndef SQLITE_OMIT_TWOSIZE_LOOKASIDE\n<line2>return p<db->lookaside.pMiddle ? db->lookaside.szTrue : LOOKASIDE_SMALL;\n<line3>#else\n<line4>return db->lookaside.szTrue;\n<line5>#endif\n<line6>}
----------------------------------------
Function: sqlite3_msize
Content: <line0>SQLITE_API sqlite3_uint64 sqlite3_msize(void *p){\n<line1>assert( sqlite3MemdebugNoType(p, (u8)~MEMTYPE_HEAP) );\n<line2>assert( sqlite3MemdebugHasType(p, MEMTYPE_HEAP) );\n<line3>return p ? sqlite3GlobalConfig.m.xSize(p) : 0;\n<line4>}
----------------------------------------
Function: sqlite3_free
Content: <line0>SQLITE_API void sqlite3_free(void *p){\n<line1>if( p==0 ) return;  /* IMP: R-49053-54554 */\n<line2>assert( sqlite3MemdebugHasType(p, MEMTYPE_HEAP) );\n<line3>assert( sqlite3MemdebugNoType(p, (u8)~MEMTYPE_HEAP) );\n<line4>if( sqlite3GlobalConfig.bMemstat ){\n<line5>sqlite3_mutex_enter(mem0.mutex);\n<line6>sqlite3StatusDown(SQLITE_STATUS_MEMORY_USED, sqlite3MallocSize(p));\n<line7>sqlite3StatusDown(SQLITE_STATUS_MALLOC_COUNT, 1);\n<line8>sqlite3GlobalConfig.m.xFree(p);\n<line9>sqlite3_mutex_leave(mem0.mutex);\n<line10>}else{\n<line11>sqlite3GlobalConfig.m.xFree(p);\n<line12>}\n<line13>}
----------------------------------------
Function: measureAllocationSize
Content: <line0>static SQLITE_NOINLINE void measureAllocationSize(sqlite3 *db, void *p){\n<line1>*db->pnBytesFreed += sqlite3DbMallocSize(db,p);\n<line2>}
----------------------------------------
Function: sqlite3_realloc
Content: <line0>SQLITE_API void *sqlite3_realloc(void *pOld, int n){\n<line1>#ifndef SQLITE_OMIT_AUTOINIT\n<line2>if( sqlite3_initialize() ) return 0;\n<line3>#endif\n<line4>if( n<0 ) n = 0;  /* IMP: R-26507-47431 */\n<line5>return sqlite3Realloc(pOld, n);\n<line6>}
----------------------------------------
Function: sqlite3_realloc64
Content: <line0>SQLITE_API void *sqlite3_realloc64(void *pOld, sqlite3_uint64 n){\n<line1>#ifndef SQLITE_OMIT_AUTOINIT\n<line2>if( sqlite3_initialize() ) return 0;\n<line3>#endif\n<line4>return sqlite3Realloc(pOld, n);\n<line5>}
----------------------------------------
Function: dbMallocRawFinish
Content: <line0>static SQLITE_NOINLINE void *dbMallocRawFinish(sqlite3 *db, u64 n){\n<line1>void *p;\n<line2>assert( db!=0 );\n<line3>p = sqlite3Malloc(n);\n<line4>if( !p ) sqlite3OomFault(db);\n<line5>sqlite3MemdebugSetType(p,\n<line6>(db->lookaside.bDisable==0) ? MEMTYPE_LOOKASIDE : MEMTYPE_HEAP);\n<line7>return p;\n<line8>}
----------------------------------------
Function: dbReallocFinish
Content: <line0>static SQLITE_NOINLINE void *dbReallocFinish(sqlite3 *db, void *p, u64 n){\n<line1>void *pNew = 0;\n<line2>assert( db!=0 );\n<line3>assert( p!=0 );\n<line4>if( db->mallocFailed==0 ){\n<line5>if( isLookaside(db, p) ){\n<line6>pNew = sqlite3DbMallocRawNN(db, n);\n<line7>if( pNew ){\n<line8>memcpy(pNew, p, lookasideMallocSize(db, p));\n<line9>sqlite3DbFree(db, p);\n<line10>}\n<line11>}else{\n<line12>assert( sqlite3MemdebugHasType(p, (MEMTYPE_LOOKASIDE|MEMTYPE_HEAP)) );\n<line13>assert( sqlite3MemdebugNoType(p, (u8)~(MEMTYPE_LOOKASIDE|MEMTYPE_HEAP)) );\n<line14>sqlite3MemdebugSetType(p, MEMTYPE_HEAP);\n<line15>pNew = sqlite3Realloc(p, n);\n<line16>if( !pNew ){\n<line17>sqlite3OomFault(db);\n<line18>}\n<line19>sqlite3MemdebugSetType(pNew,\n<line20>(db->lookaside.bDisable==0 ? MEMTYPE_LOOKASIDE : MEMTYPE_HEAP));\n<line21>}\n<line22>}\n<line23>return pNew;\n<line24>}
----------------------------------------
Function: apiHandleError
Content: <line0>static SQLITE_NOINLINE int apiHandleError(sqlite3 *db, int rc){\n<line1>if( db->mallocFailed || rc==SQLITE_IOERR_NOMEM ){\n<line2>sqlite3OomClear(db);\n<line3>sqlite3Error(db, SQLITE_NOMEM);\n<line4>return SQLITE_NOMEM_BKPT;\n<line5>}\n<line6>return rc & db->errMask;\n<line7>}
----------------------------------------
Function: getIntArg
Content: <line0>static sqlite3_int64 getIntArg(PrintfArguments *p){\n<line1>if( p->nArg<=p->nUsed ) return 0;\n<line2>return sqlite3_value_int64(p->apArg[p->nUsed++]);\n<line3>}
----------------------------------------
Function: getDoubleArg
Content: <line0>static double getDoubleArg(PrintfArguments *p){\n<line1>if( p->nArg<=p->nUsed ) return 0.0;\n<line2>return sqlite3_value_double(p->apArg[p->nUsed++]);\n<line3>}
----------------------------------------
Function: getTextArg
Content: <line0>static char *getTextArg(PrintfArguments *p){\n<line1>if( p->nArg<=p->nUsed ) return 0;\n<line2>return (char*)sqlite3_value_text(p->apArg[p->nUsed++]);\n<line3>}
----------------------------------------
Function: printfTempBuf
Content: <line0>static char *printfTempBuf(sqlite3_str *pAccum, sqlite3_int64 n){\n<line1>char *z;\n<line2>if( pAccum->accError ) return 0;\n<line3>if( n>pAccum->nAlloc && n>pAccum->mxAlloc ){\n<line4>sqlite3StrAccumSetError(pAccum, SQLITE_TOOBIG);\n<line5>return 0;\n<line6>}\n<line7>z = sqlite3DbMallocRaw(pAccum->db, n);\n<line8>if( z==0 ){\n<line9>sqlite3StrAccumSetError(pAccum, SQLITE_NOMEM);\n<line10>}\n<line11>return z;\n<line12>}
----------------------------------------
Function: sqlite3_str_vappendf
Content: <line0>SQLITE_API void sqlite3_str_vappendf(\n<line1>sqlite3_str *pAccum,       /* Accumulate results here */\n<line2>const char *fmt,           /* Format string */\n<line3>va_list ap                 /* arguments */\n<line4>){\n<line5>int c;                     /* Next character in the format string */\n<line6>char *bufpt;               /* Pointer to the conversion buffer */\n<line7>int precision;             /* Precision of the current field */\n<line8>int length;                /* Length of the field */\n<line9>int idx;                   /* A general purpose loop counter */\n<line10>int width;                 /* Width of the current field */\n<line11>etByte flag_leftjustify;   /* True if "-" flag is present */\n<line12>etByte flag_prefix;        /* '+' or ' ' or 0 for prefix */\n<line13>etByte flag_alternateform; /* True if "#" flag is present */\n<line14>etByte flag_altform2;      /* True if "!" flag is present */\n<line15>etByte flag_zeropad;       /* True if field width constant starts with zero */\n<line16>etByte flag_long;          /* 1 for the "l" flag, 2 for "ll", 0 by default */\n<line17>etByte done;               /* Loop termination flag */\n<line18>etByte cThousand;          /* Thousands separator for %d and %u */\n<line19>etByte xtype = etINVALID;  /* Conversion paradigm */\n<line20>u8 bArgList;               /* True for SQLITE_PRINTF_SQLFUNC */\n<line21>char prefix;               /* Prefix character.  "+" or "-" or " " or '\0'. */\n<line22>sqlite_uint64 longvalue;   /* Value for integer types */\n<line23>double realvalue;          /* Value for real types */\n<line24>const et_info *infop;      /* Pointer to the appropriate info structure */\n<line25>char *zOut;                /* Rendering buffer */\n<line26>int nOut;                  /* Size of the rendering buffer */\n<line27>char *zExtra = 0;          /* Malloced memory used by some conversion */\n<line28>int exp, e2;               /* exponent of real numbers */\n<line29>etByte flag_dp;            /* True if decimal point should be shown */\n<line30>etByte flag_rtz;           /* True if trailing zeros should be removed */\n<line31>PrintfArguments *pArgList = 0; /* Arguments for SQLITE_PRINTF_SQLFUNC */\n<line32>char buf[etBUFSIZE];       /* Conversion buffer */\n<line33>/* pAccum never starts out with an empty buffer that was obtained from\n<line34>** malloc().  This precondition is required by the mprintf("%z...")\n<line35>** optimization. */\n<line36>assert( pAccum->nChar>0 || (pAccum->printfFlags&SQLITE_PRINTF_MALLOCED)==0 );\n<line37>bufpt = 0;\n<line38>if( (pAccum->printfFlags & SQLITE_PRINTF_SQLFUNC)!=0 ){\n<line39>pArgList = va_arg(ap, PrintfArguments*);\n<line40>bArgList = 1;\n<line41>}else{\n<line42>bArgList = 0;\n<line43>}\n<line44>for(; (c=(*fmt))!=0; ++fmt){\n<line45>if( c!='%' ){\n<line46>bufpt = (char *)fmt;\n<line47>#if HAVE_STRCHRNUL\n<line48>fmt = strchrnul(fmt, '%');\n<line49>#else\n<line50>fmt = strchr(fmt, '%');\n<line51>if( fmt==0 ){\n<line52>fmt = bufpt + strlen(bufpt);\n<line53>}\n<line54>#endif\n<line55>sqlite3_str_append(pAccum, bufpt, (int)(fmt - bufpt));\n<line56>if( *fmt==0 ) break;\n<line57>}\n<line58>if( (c=(*++fmt))==0 ){\n<line59>sqlite3_str_append(pAccum, "%", 1);\n<line60>break;\n<line61>}\n<line62>/* Find out what flags are present */\n<line63>flag_leftjustify = flag_prefix = cThousand =\n<line64>flag_alternateform = flag_altform2 = flag_zeropad = 0;\n<line65>done = 0;\n<line66>width = 0;\n<line67>flag_long = 0;\n<line68>precision = -1;\n<line69>do{\n<line70>switch( c ){\n<line71>case '-':   flag_leftjustify = 1;     break;\n<line72>case '+':   flag_prefix = '+';        break;\n<line73>case ' ':   flag_prefix = ' ';        break;\n<line74>case '#':   flag_alternateform = 1;   break;\n<line75>case '!':   flag_altform2 = 1;        break;\n<line76>case '0':   flag_zeropad = 1;         break;\n<line77>case ',':   cThousand = ',';          break;\n<line78>default:    done = 1;                 break;\n<line79>case 'l': {\n<line80>flag_long = 1;\n<line81>c = *++fmt;\n<line82>if( c=='l' ){\n<line83>c = *++fmt;\n<line84>flag_long = 2;\n<line85>}\n<line86>done = 1;\n<line87>break;\n<line88>}\n<line89>case '1': case '2': case '3': case '4': case '5':\n<line90>case '6': case '7': case '8': case '9': {\n<line91>unsigned wx = c - '0';\n<line92>while( (c = *++fmt)>='0' && c<='9' ){\n<line93>wx = wx*10 + c - '0';\n<line94>}\n<line95>testcase( wx>0x7fffffff );\n<line96>width = wx & 0x7fffffff;\n<line97>#ifdef SQLITE_PRINTF_PRECISION_LIMIT\n<line98>if( width>SQLITE_PRINTF_PRECISION_LIMIT ){\n<line99>width = SQLITE_PRINTF_PRECISION_LIMIT;\n<line100>}\n<line101>#endif\n<line102>if( c!='.' && c!='l' ){\n<line103>done = 1;\n<line104>}else{\n<line105>fmt--;\n<line106>}\n<line107>break;\n<line108>}\n<line109>case '*': {\n<line110>if( bArgList ){\n<line111>width = (int)getIntArg(pArgList);\n<line112>}else{\n<line113>width = va_arg(ap,int);\n<line114>}\n<line115>if( width<0 ){\n<line116>flag_leftjustify = 1;\n<line117>width = width >= -2147483647 ? -width : 0;\n<line118>}\n<line119>#ifdef SQLITE_PRINTF_PRECISION_LIMIT\n<line120>if( width>SQLITE_PRINTF_PRECISION_LIMIT ){\n<line121>width = SQLITE_PRINTF_PRECISION_LIMIT;\n<line122>}\n<line123>#endif\n<line124>if( (c = fmt[1])!='.' && c!='l' ){\n<line125>c = *++fmt;\n<line126>done = 1;\n<line127>}\n<line128>break;\n<line129>}\n<line130>case '.': {\n<line131>c = *++fmt;\n<line132>if( c=='*' ){\n<line133>if( bArgList ){\n<line134>precision = (int)getIntArg(pArgList);\n<line135>}else{\n<line136>precision = va_arg(ap,int);\n<line137>}\n<line138>if( precision<0 ){\n<line139>precision = precision >= -2147483647 ? -precision : -1;\n<line140>}\n<line141>c = *++fmt;\n<line142>}else{\n<line143>unsigned px = 0;\n<line144>while( c>='0' && c<='9' ){\n<line145>px = px*10 + c - '0';\n<line146>c = *++fmt;\n<line147>}\n<line148>testcase( px>0x7fffffff );\n<line149>precision = px & 0x7fffffff;\n<line150>}\n<line151>#ifdef SQLITE_PRINTF_PRECISION_LIMIT\n<line152>if( precision>SQLITE_PRINTF_PRECISION_LIMIT ){\n<line153>precision = SQLITE_PRINTF_PRECISION_LIMIT;\n<line154>}\n<line155>#endif\n<line156>if( c=='l' ){\n<line157>--fmt;\n<line158>}else{\n<line159>done = 1;\n<line160>}\n<line161>break;\n<line162>}\n<line163>}\n<line164>}while( !done && (c=(*++fmt))!=0 );\n<line165>/* Fetch the info entry for the field */\n<line166>#ifdef SQLITE_EBCDIC\n<line167>/* The hash table only works for ASCII.  For EBCDIC, we need to do\n<line168>** a linear search of the table */\n<line169>infop = &fmtinfo[0];\n<line170>xtype = etINVALID;\n<line171>for(idx=0; idx<ArraySize(fmtinfo); idx++){\n<line172>if( c==fmtinfo[idx].fmttype ){\n<line173>infop = &fmtinfo[idx];\n<line174>xtype = infop->type;\n<line175>break;\n<line176>}\n<line177>}\n<line178>#else\n<line179>/* Fast hash-table lookup */\n<line180>assert( ArraySize(fmtinfo)==23 );\n<line181>idx = ((unsigned)c) % 23;\n<line182>if( fmtinfo[idx].fmttype==c\n<line183>|| fmtinfo[idx = fmtinfo[idx].iNxt].fmttype==c\n<line184>){\n<line185>infop = &fmtinfo[idx];\n<line186>xtype = infop->type;\n<line187>}else{\n<line188>infop = &fmtinfo[0];\n<line189>xtype = etINVALID;\n<line190>}\n<line191>#endif\n<line192>/*\n<line193>** At this point, variables are initialized as follows:\n<line194>**\n<line195>**   flag_alternateform          TRUE if a '#' is present.\n<line196>**   flag_altform2               TRUE if a '!' is present.\n<line197>**   flag_prefix                 '+' or ' ' or zero\n<line198>**   flag_leftjustify            TRUE if a '-' is present or if the\n<line199>**                               field width was negative.\n<line200>**   flag_zeropad                TRUE if the width began with 0.\n<line201>**   flag_long                   1 for "l", 2 for "ll"\n<line202>**   width                       The specified field width.  This is\n<line203>**                               always non-negative.  Zero is the default.\n<line204>**   precision                   The specified precision.  The default\n<line205>**                               is -1.\n<line206>**   xtype                       The class of the conversion.\n<line207>**   infop                       Pointer to the appropriate info struct.\n<line208>*/\n<line209>assert( width>=0 );\n<line210>assert( precision>=(-1) );\n<line211>switch( xtype ){\n<line212>case etPOINTER:\n<line213>flag_long = sizeof(char*)==sizeof(i64) ? 2 :\n<line214>sizeof(char*)==sizeof(long int) ? 1 : 0;\n<line215>/* no break */ deliberate_fall_through\n<line216>case etORDINAL:\n<line217>case etRADIX:\n<line218>cThousand = 0;\n<line219>/* no break */ deliberate_fall_through\n<line220>case etDECIMAL:\n<line221>if( infop->flags & FLAG_SIGNED ){\n<line222>i64 v;\n<line223>if( bArgList ){\n<line224>v = getIntArg(pArgList);\n<line225>}else if( flag_long ){\n<line226>if( flag_long==2 ){\n<line227>v = va_arg(ap,i64) ;\n<line228>}else{\n<line229>v = va_arg(ap,long int);\n<line230>}\n<line231>}else{\n<line232>v = va_arg(ap,int);\n<line233>}\n<line234>if( v<0 ){\n<line235>testcase( v==SMALLEST_INT64 );\n<line236>testcase( v==(-1) );\n<line237>longvalue = ~v;\n<line238>longvalue++;\n<line239>prefix = '-';\n<line240>}else{\n<line241>longvalue = v;\n<line242>prefix = flag_prefix;\n<line243>}\n<line244>}else{\n<line245>if( bArgList ){\n<line246>longvalue = (u64)getIntArg(pArgList);\n<line247>}else if( flag_long ){\n<line248>if( flag_long==2 ){\n<line249>longvalue = va_arg(ap,u64);\n<line250>}else{\n<line251>longvalue = va_arg(ap,unsigned long int);\n<line252>}\n<line253>}else{\n<line254>longvalue = va_arg(ap,unsigned int);\n<line255>}\n<line256>prefix = 0;\n<line257>}\n<line258>#if WHERETRACE_ENABLED\n<line259>if( xtype==etPOINTER && sqlite3WhereTrace & 0x100000 ) longvalue = 0;\n<line260>#endif\n<line261>#if TREETRACE_ENABLED\n<line262>if( xtype==etPOINTER && sqlite3TreeTrace & 0x100000 ) longvalue = 0;\n<line263>#endif\n<line264>if( longvalue==0 ) flag_alternateform = 0;\n<line265>if( flag_zeropad && precision<width-(prefix!=0) ){\n<line266>precision = width-(prefix!=0);\n<line267>}\n<line268>if( precision<etBUFSIZE-10-etBUFSIZE/3 ){\n<line269>nOut = etBUFSIZE;\n<line270>zOut = buf;\n<line271>}else{\n<line272>u64 n;\n<line273>n = (u64)precision + 10;\n<line274>if( cThousand ) n += precision/3;\n<line275>zOut = zExtra = printfTempBuf(pAccum, n);\n<line276>if( zOut==0 ) return;\n<line277>nOut = (int)n;\n<line278>}\n<line279>bufpt = &zOut[nOut-1];\n<line280>if( xtype==etORDINAL ){\n<line281>static const char zOrd[] = "thstndrd";\n<line282>int x = (int)(longvalue % 10);\n<line283>if( x>=4 || (longvalue/10)%10==1 ){\n<line284>x = 0;\n<line285>}\n<line286>*(--bufpt) = zOrd[x*2+1];\n<line287>*(--bufpt) = zOrd[x*2];\n<line288>}\n<line289>{\n<line290>const char *cset = &aDigits[infop->charset];\n<line291>u8 base = infop->base;\n<line292>do{                                           /* Convert to ascii */\n<line293>*(--bufpt) = cset[longvalue%base];\n<line294>longvalue = longvalue/base;\n<line295>}while( longvalue>0 );\n<line296>}\n<line297>length = (int)(&zOut[nOut-1]-bufpt);\n<line298>while( precision>length ){\n<line299>*(--bufpt) = '0';                             /* Zero pad */\n<line300>length++;\n<line301>}\n<line302>if( cThousand ){\n<line303>int nn = (length - 1)/3;  /* Number of "," to insert */\n<line304>int ix = (length - 1)%3 + 1;\n<line305>bufpt -= nn;\n<line306>for(idx=0; nn>0; idx++){\n<line307>bufpt[idx] = bufpt[idx+nn];\n<line308>ix--;\n<line309>if( ix==0 ){\n<line310>bufpt[++idx] = cThousand;\n<line311>nn--;\n<line312>ix = 3;\n<line313>}\n<line314>}\n<line315>}\n<line316>if( prefix ) *(--bufpt) = prefix;               /* Add sign */\n<line317>if( flag_alternateform && infop->prefix ){      /* Add "0" or "0x" */\n<line318>const char *pre;\n<line319>char x;\n<line320>pre = &aPrefix[infop->prefix];\n<line321>for(; (x=(*pre))!=0; pre++) *(--bufpt) = x;\n<line322>}\n<line323>length = (int)(&zOut[nOut-1]-bufpt);\n<line324>break;\n<line325>case etFLOAT:\n<line326>case etEXP:\n<line327>case etGENERIC: {\n<line328>FpDecode s;\n<line329>int iRound;\n<line330>int j;\n<line331>if( bArgList ){\n<line332>realvalue = getDoubleArg(pArgList);\n<line333>}else{\n<line334>realvalue = va_arg(ap,double);\n<line335>}\n<line336>if( precision<0 ) precision = 6;         /* Set default precision */\n<line337>#ifdef SQLITE_FP_PRECISION_LIMIT\n<line338>if( precision>SQLITE_FP_PRECISION_LIMIT ){\n<line339>precision = SQLITE_FP_PRECISION_LIMIT;\n<line340>}\n<line341>#endif\n<line342>if( xtype==etFLOAT ){\n<line343>iRound = -precision;\n<line344>}else if( xtype==etGENERIC ){\n<line345>if( precision==0 ) precision = 1;\n<line346>iRound = precision;\n<line347>}else{\n<line348>iRound = precision+1;\n<line349>}\n<line350>sqlite3FpDecode(&s, realvalue, iRound, flag_altform2 ? 26 : 16);\n<line351>if( s.isSpecial ){\n<line352>if( s.isSpecial==2 ){\n<line353>bufpt = flag_zeropad ? "null" : "NaN";\n<line354>length = sqlite3Strlen30(bufpt);\n<line355>break;\n<line356>}else if( flag_zeropad ){\n<line357>s.z[0] = '9';\n<line358>s.iDP = 1000;\n<line359>s.n = 1;\n<line360>}else{\n<line361>memcpy(buf, "-Inf", 5);\n<line362>bufpt = buf;\n<line363>if( s.sign=='-' ){\n<line364>/* no-op */\n<line365>}else if( flag_prefix ){\n<line366>buf[0] = flag_prefix;\n<line367>}else{\n<line368>bufpt++;\n<line369>}\n<line370>length = sqlite3Strlen30(bufpt);\n<line371>break;\n<line372>}\n<line373>}\n<line374>if( s.sign=='-' ){\n<line375>if( flag_alternateform\n<line376>&& !flag_prefix\n<line377>&& xtype==etFLOAT\n<line378>&& s.iDP<=iRound\n<line379>){\n<line380>/* Suppress the minus sign if all of the following are true:\n<line381>**   *  The value displayed is zero\n<line382>**   *  The '#' flag is used\n<line383>**   *  The '+' flag is not used, and\n<line384>**   *  The format is %f\n<line385>*/\n<line386>prefix = 0;\n<line387>}else{\n<line388>prefix = '-';\n<line389>}\n<line390>}else{\n<line391>prefix = flag_prefix;\n<line392>}\n<line393>exp = s.iDP-1;\n<line394>/*\n<line395>** If the field type is etGENERIC, then convert to either etEXP\n<line396>** or etFLOAT, as appropriate.\n<line397>*/\n<line398>if( xtype==etGENERIC ){\n<line399>assert( precision>0 );\n<line400>precision--;\n<line401>flag_rtz = !flag_alternateform;\n<line402>if( exp<-4 || exp>precision ){\n<line403>xtype = etEXP;\n<line404>}else{\n<line405>precision = precision - exp;\n<line406>xtype = etFLOAT;\n<line407>}\n<line408>}else{\n<line409>flag_rtz = flag_altform2;\n<line410>}\n<line411>if( xtype==etEXP ){\n<line412>e2 = 0;\n<line413>}else{\n<line414>e2 = s.iDP - 1;\n<line415>}\n<line416>bufpt = buf;\n<line417>{\n<line418>i64 szBufNeeded;           /* Size of a temporary buffer needed */\n<line419>szBufNeeded = MAX(e2,0)+(i64)precision+(i64)width+15;\n<line420>if( cThousand && e2>0 ) szBufNeeded += (e2+2)/3;\n<line421>if( szBufNeeded > etBUFSIZE ){\n<line422>bufpt = zExtra = printfTempBuf(pAccum, szBufNeeded);\n<line423>if( bufpt==0 ) return;\n<line424>}\n<line425>}\n<line426>zOut = bufpt;\n<line427>flag_dp = (precision>0 ?1:0) | flag_alternateform | flag_altform2;\n<line428>/* The sign in front of the number */\n<line429>if( prefix ){\n<line430>*(bufpt++) = prefix;\n<line431>}\n<line432>/* Digits prior to the decimal point */\n<line433>j = 0;\n<line434>if( e2<0 ){\n<line435>*(bufpt++) = '0';\n<line436>}else{\n<line437>for(; e2>=0; e2--){\n<line438>*(bufpt++) = j<s.n ? s.z[j++] : '0';\n<line439>if( cThousand && (e2%3)==0 && e2>1 ) *(bufpt++) = ',';\n<line440>}\n<line441>}\n<line442>/* The decimal point */\n<line443>if( flag_dp ){\n<line444>*(bufpt++) = '.';\n<line445>}\n<line446>/* "0" digits after the decimal point but before the first\n<line447>** significant digit of the number */\n<line448>for(e2++; e2<0 && precision>0; precision--, e2++){\n<line449>*(bufpt++) = '0';\n<line450>}\n<line451>/* Significant digits after the decimal point */\n<line452>while( (precision--)>0 ){\n<line453>*(bufpt++) = j<s.n ? s.z[j++] : '0';\n<line454>}\n<line455>/* Remove trailing zeros and the "." if no digits follow the "." */\n<line456>if( flag_rtz && flag_dp ){\n<line457>while( bufpt[-1]=='0' ) *(--bufpt) = 0;\n<line458>assert( bufpt>zOut );\n<line459>if( bufpt[-1]=='.' ){\n<line460>if( flag_altform2 ){\n<line461>*(bufpt++) = '0';\n<line462>}else{\n<line463>*(--bufpt) = 0;\n<line464>}\n<line465>}\n<line466>}\n<line467>/* Add the "eNNN" suffix */\n<line468>if( xtype==etEXP ){\n<line469>exp = s.iDP - 1;\n<line470>*(bufpt++) = aDigits[infop->charset];\n<line471>if( exp<0 ){\n<line472>*(bufpt++) = '-'; exp = -exp;\n<line473>}else{\n<line474>*(bufpt++) = '+';\n<line475>}\n<line476>if( exp>=100 ){\n<line477>*(bufpt++) = (char)((exp/100)+'0');        /* 100's digit */\n<line478>exp %= 100;\n<line479>}\n<line480>*(bufpt++) = (char)(exp/10+'0');             /* 10's digit */\n<line481>*(bufpt++) = (char)(exp%10+'0');             /* 1's digit */\n<line482>}\n<line483>*bufpt = 0;\n<line484>/* The converted number is in buf[] and zero terminated. Output it.\n<line485>** Note that the number is in the usual order, not reversed as with\n<line486>** integer conversions. */\n<line487>length = (int)(bufpt-zOut);\n<line488>bufpt = zOut;\n<line489>/* Special case:  Add leading zeros if the flag_zeropad flag is\n<line490>** set and we are not left justified */\n<line491>if( flag_zeropad && !flag_leftjustify && length < width){\n<line492>int i;\n<line493>int nPad = width - length;\n<line494>for(i=width; i>=nPad; i--){\n<line495>bufpt[i] = bufpt[i-nPad];\n<line496>}\n<line497>i = prefix!=0;\n<line498>while( nPad-- ) bufpt[i++] = '0';\n<line499>length = width;\n<line500>}\n<line501>break;\n<line502>}\n<line503>case etSIZE:\n<line504>if( !bArgList ){\n<line505>*(va_arg(ap,int*)) = pAccum->nChar;\n<line506>}\n<line507>length = width = 0;\n<line508>break;\n<line509>case etPERCENT:\n<line510>buf[0] = '%';\n<line511>bufpt = buf;\n<line512>length = 1;\n<line513>break;\n<line514>case etCHARX:\n<line515>if( bArgList ){\n<line516>bufpt = getTextArg(pArgList);\n<line517>length = 1;\n<line518>if( bufpt ){\n<line519>buf[0] = c = *(bufpt++);\n<line520>if( (c&0xc0)==0xc0 ){\n<line521>while( length<4 && (bufpt[0]&0xc0)==0x80 ){\n<line522>buf[length++] = *(bufpt++);\n<line523>}\n<line524>}\n<line525>}else{\n<line526>buf[0] = 0;\n<line527>}\n<line528>}else{\n<line529>unsigned int ch = va_arg(ap,unsigned int);\n<line530>length = sqlite3AppendOneUtf8Character(buf, ch);\n<line531>}\n<line532>if( precision>1 ){\n<line533>i64 nPrior = 1;\n<line534>width -= precision-1;\n<line535>if( width>1 && !flag_leftjustify ){\n<line536>sqlite3_str_appendchar(pAccum, width-1, ' ');\n<line537>width = 0;\n<line538>}\n<line539>sqlite3_str_append(pAccum, buf, length);\n<line540>precision--;\n<line541>while( precision > 1 ){\n<line542>i64 nCopyBytes;\n<line543>if( nPrior > precision-1 ) nPrior = precision - 1;\n<line544>nCopyBytes = length*nPrior;\n<line545>if( nCopyBytes + pAccum->nChar >= pAccum->nAlloc ){\n<line546>sqlite3StrAccumEnlarge(pAccum, nCopyBytes);\n<line547>}\n<line548>if( pAccum->accError ) break;\n<line549>sqlite3_str_append(pAccum,\n<line550>&pAccum->zText[pAccum->nChar-nCopyBytes], nCopyBytes);\n<line551>precision -= nPrior;\n<line552>nPrior *= 2;\n<line553>}\n<line554>}\n<line555>bufpt = buf;\n<line556>flag_altform2 = 1;\n<line557>goto adjust_width_for_utf8;\n<line558>case etSTRING:\n<line559>case etDYNSTRING:\n<line560>if( bArgList ){\n<line561>bufpt = getTextArg(pArgList);\n<line562>xtype = etSTRING;\n<line563>}else{\n<line564>bufpt = va_arg(ap,char*);\n<line565>}\n<line566>if( bufpt==0 ){\n<line567>bufpt = "";\n<line568>}else if( xtype==etDYNSTRING ){\n<line569>if( pAccum->nChar==0\n<line570>&& pAccum->mxAlloc\n<line571>&& width==0\n<line572>&& precision<0\n<line573>&& pAccum->accError==0\n<line574>){\n<line575>/* Special optimization for sqlite3_mprintf("%z..."):\n<line576>** Extend an existing memory allocation rather than creating\n<line577>** a new one. */\n<line578>assert( (pAccum->printfFlags&SQLITE_PRINTF_MALLOCED)==0 );\n<line579>pAccum->zText = bufpt;\n<line580>pAccum->nAlloc = sqlite3DbMallocSize(pAccum->db, bufpt);\n<line581>pAccum->nChar = 0x7fffffff & (int)strlen(bufpt);\n<line582>pAccum->printfFlags |= SQLITE_PRINTF_MALLOCED;\n<line583>length = 0;\n<line584>break;\n<line585>}\n<line586>zExtra = bufpt;\n<line587>}\n<line588>if( precision>=0 ){\n<line589>if( flag_altform2 ){\n<line590>/* Set length to the number of bytes needed in order to display\n<line591>** precision characters */\n<line592>unsigned char *z = (unsigned char*)bufpt;\n<line593>while( precision-- > 0 && z[0] ){\n<line594>SQLITE_SKIP_UTF8(z);\n<line595>}\n<line596>length = (int)(z - (unsigned char*)bufpt);\n<line597>}else{\n<line598>for(length=0; length<precision && bufpt[length]; length++){}\n<line599>}\n<line600>}else{\n<line601>length = 0x7fffffff & (int)strlen(bufpt);\n<line602>}\n<line603>adjust_width_for_utf8:\n<line604>if( flag_altform2 && width>0 ){\n<line605>/* Adjust width to account for extra bytes in UTF-8 characters */\n<line606>int ii = length - 1;\n<line607>while( ii>=0 ) if( (bufpt[ii--] & 0xc0)==0x80 ) width++;\n<line608>}\n<line609>break;\n<line610>case etESCAPE_q:          /* %q: Escape ' characters */\n<line611>case etESCAPE_Q:          /* %Q: Escape ' and enclose in '...' */\n<line612>case etESCAPE_w: {        /* %w: Escape " characters */\n<line613>i64 i, j, k, n;\n<line614>int needQuote = 0;\n<line615>char ch;\n<line616>char *escarg;\n<line617>char q;\n<line618>if( bArgList ){\n<line619>escarg = getTextArg(pArgList);\n<line620>}else{\n<line621>escarg = va_arg(ap,char*);\n<line622>}\n<line623>if( escarg==0 ){\n<line624>escarg = (xtype==etESCAPE_Q ? "NULL" : "(NULL)");\n<line625>}else if( xtype==etESCAPE_Q ){\n<line626>needQuote = 1;\n<line627>}\n<line628>if( xtype==etESCAPE_w ){\n<line629>q = '"';\n<line630>flag_alternateform = 0;\n<line631>}else{\n<line632>q = '\'';\n<line633>}\n<line634>/* For %q, %Q, and %w, the precision is the number of bytes (or\n<line635>** characters if the ! flags is present) to use from the input.\n<line636>** Because of the extra quoting characters inserted, the number\n<line637>** of output characters may be larger than the precision.\n<line638>*/\n<line639>k = precision;\n<line640>for(i=n=0; k!=0 && (ch=escarg[i])!=0; i++, k--){\n<line641>if( ch==q )  n++;\n<line642>if( flag_altform2 && (ch&0xc0)==0xc0 ){\n<line643>while( (escarg[i+1]&0xc0)==0x80 ){ i++; }\n<line644>}\n<line645>}\n<line646>if( flag_alternateform ){\n<line647>/* For %#q, do unistr()-style backslash escapes for\n<line648>** all control characters, and for backslash itself.\n<line649>** For %#Q, do the same but only if there is at least\n<line650>** one control character. */\n<line651>u32 nBack = 0;\n<line652>u32 nCtrl = 0;\n<line653>for(k=0; k<i; k++){\n<line654>if( escarg[k]=='\\' ){\n<line655>nBack++;\n<line656>}else if( ((u8*)escarg)[k]<=0x1f ){\n<line657>nCtrl++;\n<line658>}\n<line659>}\n<line660>if( nCtrl || xtype==etESCAPE_q ){\n<line661>n += nBack + 5*nCtrl;\n<line662>if( xtype==etESCAPE_Q ){\n<line663>n += 10;\n<line664>needQuote = 2;\n<line665>}\n<line666>}else{\n<line667>flag_alternateform = 0;\n<line668>}\n<line669>}\n<line670>n += i + 3;\n<line671>if( n>etBUFSIZE ){\n<line672>bufpt = zExtra = printfTempBuf(pAccum, n);\n<line673>if( bufpt==0 ) return;\n<line674>}else{\n<line675>bufpt = buf;\n<line676>}\n<line677>j = 0;\n<line678>if( needQuote ){\n<line679>if( needQuote==2 ){\n<line680>memcpy(&bufpt[j], "unistr('", 8);\n<line681>j += 8;\n<line682>}else{\n<line683>bufpt[j++] = '\'';\n<line684>}\n<line685>}\n<line686>k = i;\n<line687>if( flag_alternateform ){\n<line688>for(i=0; i<k; i++){\n<line689>bufpt[j++] = ch = escarg[i];\n<line690>if( ch==q ){\n<line691>bufpt[j++] = ch;\n<line692>}else if( ch=='\\' ){\n<line693>bufpt[j++] = '\\';\n<line694>}else if( ((unsigned char)ch)<=0x1f ){\n<line695>bufpt[j-1] = '\\';\n<line696>bufpt[j++] = 'u';\n<line697>bufpt[j++] = '0';\n<line698>bufpt[j++] = '0';\n<line699>bufpt[j++] = ch>=0x10 ? '1' : '0';\n<line700>bufpt[j++] = "0123456789abcdef"[ch&0xf];\n<line701>}\n<line702>}\n<line703>}else{\n<line704>for(i=0; i<k; i++){\n<line705>bufpt[j++] = ch = escarg[i];\n<line706>if( ch==q ) bufpt[j++] = ch;\n<line707>}\n<line708>}\n<line709>if( needQuote ){\n<line710>bufpt[j++] = '\'';\n<line711>if( needQuote==2 ) bufpt[j++] = ')';\n<line712>}\n<line713>bufpt[j] = 0;\n<line714>length = j;\n<line715>goto adjust_width_for_utf8;\n<line716>}\n<line717>case etTOKEN: {\n<line718>if( (pAccum->printfFlags & SQLITE_PRINTF_INTERNAL)==0 ) return;\n<line719>if( flag_alternateform ){\n<line720>/* %#T means an Expr pointer that uses Expr.u.zToken */\n<line721>Expr *pExpr = va_arg(ap,Expr*);\n<line722>if( ALWAYS(pExpr) && ALWAYS(!ExprHasProperty(pExpr,EP_IntValue)) ){\n<line723>sqlite3_str_appendall(pAccum, (const char*)pExpr->u.zToken);\n<line724>sqlite3RecordErrorOffsetOfExpr(pAccum->db, pExpr);\n<line725>}\n<line726>}else{\n<line727>/* %T means a Token pointer */\n<line728>Token *pToken = va_arg(ap, Token*);\n<line729>assert( bArgList==0 );\n<line730>if( pToken && pToken->n ){\n<line731>sqlite3_str_append(pAccum, (const char*)pToken->z, pToken->n);\n<line732>sqlite3RecordErrorByteOffset(pAccum->db, pToken->z);\n<line733>}\n<line734>}\n<line735>length = width = 0;\n<line736>break;\n<line737>}\n<line738>case etSRCITEM: {\n<line739>SrcItem *pItem;\n<line740>if( (pAccum->printfFlags & SQLITE_PRINTF_INTERNAL)==0 ) return;\n<line741>pItem = va_arg(ap, SrcItem*);\n<line742>assert( bArgList==0 );\n<line743>if( pItem->zAlias && !flag_altform2 ){\n<line744>sqlite3_str_appendall(pAccum, pItem->zAlias);\n<line745>}else if( pItem->zName ){\n<line746>if( pItem->fg.fixedSchema==0\n<line747>&& pItem->fg.isSubquery==0\n<line748>&& pItem->u4.zDatabase!=0\n<line749>){\n<line750>sqlite3_str_appendall(pAccum, pItem->u4.zDatabase);\n<line751>sqlite3_str_append(pAccum, ".", 1);\n<line752>}\n<line753>sqlite3_str_appendall(pAccum, pItem->zName);\n<line754>}else if( pItem->zAlias ){\n<line755>sqlite3_str_appendall(pAccum, pItem->zAlias);\n<line756>}else if( ALWAYS(pItem->fg.isSubquery) ){/* Because of tag-20240424-1 */\n<line757>Select *pSel = pItem->u4.pSubq->pSelect;\n<line758>assert( pSel!=0 );\n<line759>if( pSel->selFlags & SF_NestedFrom ){\n<line760>sqlite3_str_appendf(pAccum, "(join-%u)", pSel->selId);\n<line761>}else if( pSel->selFlags & SF_MultiValue ){\n<line762>assert( !pItem->fg.isTabFunc && !pItem->fg.isIndexedBy );\n<line763>sqlite3_str_appendf(pAccum, "%u-ROW VALUES CLAUSE",\n<line764>pItem->u1.nRow);\n<line765>}else{\n<line766>sqlite3_str_appendf(pAccum, "(subquery-%u)", pSel->selId);\n<line767>}\n<line768>}\n<line769>length = width = 0;\n<line770>break;\n<line771>}\n<line772>default: {\n<line773>assert( xtype==etINVALID );\n<line774>return;\n<line775>}\n<line776>}/* End switch over the format type */\n<line777>/*\n<line778>** The text of the conversion is pointed to by "bufpt" and is\n<line779>** "length" characters long.  The field width is "width".  Do\n<line780>** the output.  Both length and width are in bytes, not characters,\n<line781>** at this point.  If the "!" flag was present on string conversions\n<line782>** indicating that width and precision should be expressed in characters,\n<line783>** then the values have been translated prior to reaching this point.\n<line784>*/\n<line785>width -= length;\n<line786>if( width>0 ){\n<line787>if( !flag_leftjustify ) sqlite3_str_appendchar(pAccum, width, ' ');\n<line788>sqlite3_str_append(pAccum, bufpt, length);\n<line789>if( flag_leftjustify ) sqlite3_str_appendchar(pAccum, width, ' ');\n<line790>}else{\n<line791>sqlite3_str_append(pAccum, bufpt, length);\n<line792>}\n<line793>if( zExtra ){\n<line794>sqlite3DbFree(pAccum->db, zExtra);\n<line795>zExtra = 0;\n<line796>}\n<line797>}/* End for loop over the format string */\n<line798>} /* End of function */
----------------------------------------
Function: sqlite3_str_appendchar
Content: <line0>SQLITE_API void sqlite3_str_appendchar(sqlite3_str *p, int N, char c){\n<line1>testcase( p->nChar + (i64)N > 0x7fffffff );\n<line2>if( p->nChar+(i64)N >= p->nAlloc && (N = sqlite3StrAccumEnlarge(p, N))<=0 ){\n<line3>return;\n<line4>}\n<line5>while( (N--)>0 ) p->zText[p->nChar++] = c;\n<line6>}
----------------------------------------
Function: enlargeAndAppend
Content: <line0>static void SQLITE_NOINLINE enlargeAndAppend(StrAccum *p, const char *z, int N){\n<line1>N = sqlite3StrAccumEnlarge(p, N);\n<line2>if( N>0 ){\n<line3>memcpy(&p->zText[p->nChar], z, N);\n<line4>p->nChar += N;\n<line5>}\n<line6>}
----------------------------------------
Function: sqlite3_str_append
Content: <line0>SQLITE_API void sqlite3_str_append(sqlite3_str *p, const char *z, int N){\n<line1>assert( z!=0 || N==0 );\n<line2>assert( p->zText!=0 || p->nChar==0 || p->accError );\n<line3>assert( N>=0 );\n<line4>assert( p->accError==0 || p->nAlloc==0 || p->mxAlloc==0 );\n<line5>if( p->nChar+N >= p->nAlloc ){\n<line6>enlargeAndAppend(p,z,N);\n<line7>}else if( N ){\n<line8>assert( p->zText );\n<line9>p->nChar += N;\n<line10>memcpy(&p->zText[p->nChar-N], z, N);\n<line11>}\n<line12>}
----------------------------------------
Function: sqlite3_str_appendall
Content: <line0>SQLITE_API void sqlite3_str_appendall(sqlite3_str *p, const char *z){\n<line1>sqlite3_str_append(p, z, sqlite3Strlen30(z));\n<line2>}
----------------------------------------
Function: strAccumFinishRealloc
Content: <line0>static SQLITE_NOINLINE char *strAccumFinishRealloc(StrAccum *p){\n<line1>char *zText;\n<line2>assert( p->mxAlloc>0 && !isMalloced(p) );\n<line3>zText = sqlite3DbMallocRaw(p->db, 1+(u64)p->nChar );\n<line4>if( zText ){\n<line5>memcpy(zText, p->zText, p->nChar+1);\n<line6>p->printfFlags |= SQLITE_PRINTF_MALLOCED;\n<line7>}else{\n<line8>sqlite3StrAccumSetError(p, SQLITE_NOMEM);\n<line9>}\n<line10>p->zText = zText;\n<line11>return zText;\n<line12>}
----------------------------------------
Function: sqlite3_str_finish
Content: <line0>SQLITE_API char *sqlite3_str_finish(sqlite3_str *p){\n<line1>char *z;\n<line2>if( p!=0 && p!=&sqlite3OomStr ){\n<line3>z = sqlite3StrAccumFinish(p);\n<line4>sqlite3_free(p);\n<line5>}else{\n<line6>z = 0;\n<line7>}\n<line8>return z;\n<line9>}
----------------------------------------
Function: sqlite3_str_errcode
Content: <line0>SQLITE_API int sqlite3_str_errcode(sqlite3_str *p){\n<line1>return p ? p->accError : SQLITE_NOMEM;\n<line2>}
----------------------------------------
Function: sqlite3_str_length
Content: <line0>SQLITE_API int sqlite3_str_length(sqlite3_str *p){\n<line1>return p ? p->nChar : 0;\n<line2>}
----------------------------------------
Function: sqlite3_str_value
Content: <line0>SQLITE_API char *sqlite3_str_value(sqlite3_str *p){\n<line1>if( p==0 || p->nChar==0 ) return 0;\n<line2>p->zText[p->nChar] = 0;\n<line3>return p->zText;\n<line4>}
----------------------------------------
Function: sqlite3_str_reset
Content: <line0>SQLITE_API void sqlite3_str_reset(StrAccum *p){\n<line1>if( isMalloced(p) ){\n<line2>sqlite3DbFree(p->db, p->zText);\n<line3>p->printfFlags &= ~SQLITE_PRINTF_MALLOCED;\n<line4>}\n<line5>p->nAlloc = 0;\n<line6>p->nChar = 0;\n<line7>p->zText = 0;\n<line8>}
----------------------------------------
Function: sqlite3_str_new
Content: <line0>SQLITE_API sqlite3_str *sqlite3_str_new(sqlite3 *db){\n<line1>sqlite3_str *p = sqlite3_malloc64(sizeof(*p));\n<line2>if( p ){\n<line3>sqlite3StrAccumInit(p, 0, 0, 0,\n<line4>db ? db->aLimit[SQLITE_LIMIT_LENGTH] : SQLITE_MAX_LENGTH);\n<line5>}else{\n<line6>p = &sqlite3OomStr;\n<line7>}\n<line8>return p;\n<line9>}
----------------------------------------
Function: sqlite3_vmprintf
Content: <line0>SQLITE_API char *sqlite3_vmprintf(const char *zFormat, va_list ap){\n<line1>char *z;\n<line2>char zBase[SQLITE_PRINT_BUF_SIZE];\n<line3>StrAccum acc;\n<line4>#ifdef SQLITE_ENABLE_API_ARMOR\n<line5>if( zFormat==0 ){\n<line6>(void)SQLITE_MISUSE_BKPT;\n<line7>return 0;\n<line8>}\n<line9>#endif\n<line10>#ifndef SQLITE_OMIT_AUTOINIT\n<line11>if( sqlite3_initialize() ) return 0;\n<line12>#endif\n<line13>sqlite3StrAccumInit(&acc, 0, zBase, sizeof(zBase), SQLITE_MAX_LENGTH);\n<line14>sqlite3_str_vappendf(&acc, zFormat, ap);\n<line15>z = sqlite3StrAccumFinish(&acc);\n<line16>return z;\n<line17>}
----------------------------------------
Function: sqlite3_mprintf
Content: <line0>SQLITE_API char *sqlite3_mprintf(const char *zFormat, ...){\n<line1>va_list ap;\n<line2>char *z;\n<line3>#ifndef SQLITE_OMIT_AUTOINIT\n<line4>if( sqlite3_initialize() ) return 0;\n<line5>#endif\n<line6>va_start(ap, zFormat);\n<line7>z = sqlite3_vmprintf(zFormat, ap);\n<line8>va_end(ap);\n<line9>return z;\n<line10>}
----------------------------------------
Function: sqlite3_vsnprintf
Content: <line0>SQLITE_API char *sqlite3_vsnprintf(int n, char *zBuf, const char *zFormat, va_list ap){\n<line1>StrAccum acc;\n<line2>if( n<=0 ) return zBuf;\n<line3>#ifdef SQLITE_ENABLE_API_ARMOR\n<line4>if( zBuf==0 || zFormat==0 ) {\n<line5>(void)SQLITE_MISUSE_BKPT;\n<line6>if( zBuf ) zBuf[0] = 0;\n<line7>return zBuf;\n<line8>}\n<line9>#endif\n<line10>sqlite3StrAccumInit(&acc, 0, zBuf, n, 0);\n<line11>sqlite3_str_vappendf(&acc, zFormat, ap);\n<line12>zBuf[acc.nChar] = 0;\n<line13>return zBuf;\n<line14>}
----------------------------------------
Function: sqlite3_snprintf
Content: <line0>SQLITE_API char *sqlite3_snprintf(int n, char *zBuf, const char *zFormat, ...){\n<line1>StrAccum acc;\n<line2>va_list ap;\n<line3>if( n<=0 ) return zBuf;\n<line4>#ifdef SQLITE_ENABLE_API_ARMOR\n<line5>if( zBuf==0 || zFormat==0 ) {\n<line6>(void)SQLITE_MISUSE_BKPT;\n<line7>if( zBuf ) zBuf[0] = 0;\n<line8>return zBuf;\n<line9>}\n<line10>#endif\n<line11>sqlite3StrAccumInit(&acc, 0, zBuf, n, 0);\n<line12>va_start(ap,zFormat);\n<line13>sqlite3_str_vappendf(&acc, zFormat, ap);\n<line14>va_end(ap);\n<line15>zBuf[acc.nChar] = 0;\n<line16>return zBuf;\n<line17>}
----------------------------------------
Function: renderLogMsg
Content: <line0>static void renderLogMsg(int iErrCode, const char *zFormat, va_list ap){\n<line1>StrAccum acc;                          /* String accumulator */\n<line2>char zMsg[SQLITE_MAX_LOG_MESSAGE];     /* Complete log message */\n<line3>sqlite3StrAccumInit(&acc, 0, zMsg, sizeof(zMsg), 0);\n<line4>sqlite3_str_vappendf(&acc, zFormat, ap);\n<line5>sqlite3GlobalConfig.xLog(sqlite3GlobalConfig.pLogArg, iErrCode,\n<line6>sqlite3StrAccumFinish(&acc));\n<line7>}
----------------------------------------
Function: sqlite3_log
Content: <line0>SQLITE_API void sqlite3_log(int iErrCode, const char *zFormat, ...){\n<line1>va_list ap;                             /* Vararg list */\n<line2>if( sqlite3GlobalConfig.xLog ){\n<line3>va_start(ap, zFormat);\n<line4>renderLogMsg(iErrCode, zFormat, ap);\n<line5>va_end(ap);\n<line6>}\n<line7>}
----------------------------------------
Function: sqlite3_str_appendf
Content: <line0>SQLITE_API void sqlite3_str_appendf(StrAccum *p, const char *zFormat, ...){\n<line1>va_list ap;\n<line2>va_start(ap,zFormat);\n<line3>sqlite3_str_vappendf(p, zFormat, ap);\n<line4>va_end(ap);\n<line5>}
----------------------------------------
Function: chacha_block
Content: <line0>static void chacha_block(u32 *out, const u32 *in){\n<line1>int i;\n<line2>u32 x[16];\n<line3>memcpy(x, in, 64);\n<line4>for(i=0; i<10; i++){\n<line5>QR(x[0], x[4], x[ 8], x[12]);\n<line6>QR(x[1], x[5], x[ 9], x[13]);\n<line7>QR(x[2], x[6], x[10], x[14]);\n<line8>QR(x[3], x[7], x[11], x[15]);\n<line9>QR(x[0], x[5], x[10], x[15]);\n<line10>QR(x[1], x[6], x[11], x[12]);\n<line11>QR(x[2], x[7], x[ 8], x[13]);\n<line12>QR(x[3], x[4], x[ 9], x[14]);\n<line13>}\n<line14>for(i=0; i<16; i++) out[i] = x[i]+in[i];\n<line15>}
----------------------------------------
Function: sqlite3_randomness
Content: <line0>SQLITE_API void sqlite3_randomness(int N, void *pBuf){\n<line1>unsigned char *zBuf = pBuf;\n<line2>/* The "wsdPrng" macro will resolve to the pseudo-random number generator\n<line3>** state vector.  If writable static data is unsupported on the target,\n<line4>** we have to locate the state vector at run-time.  In the more common\n<line5>** case where writable static data is supported, wsdPrng can refer directly\n<line6>** to the "sqlite3Prng" state vector declared above.\n<line7>*/\n<line8>#ifdef SQLITE_OMIT_WSD\n<line9>struct sqlite3PrngType *p = &GLOBAL(struct sqlite3PrngType, sqlite3Prng);\n<line10># define wsdPrng p[0]\n<line11>#else\n<line12># define wsdPrng sqlite3Prng\n<line13>#endif\n<line14>#if SQLITE_THREADSAFE\n<line15>sqlite3_mutex *mutex;\n<line16>#endif\n<line17>#ifndef SQLITE_OMIT_AUTOINIT\n<line18>if( sqlite3_initialize() ) return;\n<line19>#endif\n<line20>#if SQLITE_THREADSAFE\n<line21>mutex = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_PRNG);\n<line22>#endif\n<line23>sqlite3_mutex_enter(mutex);\n<line24>if( N<=0 || pBuf==0 ){\n<line25>wsdPrng.s[0] = 0;\n<line26>sqlite3_mutex_leave(mutex);\n<line27>return;\n<line28>}\n<line29>/* Initialize the state of the random number generator once,\n<line30>** the first time this routine is called.\n<line31>*/\n<line32>if( wsdPrng.s[0]==0 ){\n<line33>sqlite3_vfs *pVfs = sqlite3_vfs_find(0);\n<line34>static const u32 chacha20_init[] = {\n<line35>0x61707865, 0x3320646e, 0x79622d32, 0x6b206574\n<line36>};\n<line37>memcpy(&wsdPrng.s[0], chacha20_init, 16);\n<line38>if( NEVER(pVfs==0) ){\n<line39>memset(&wsdPrng.s[4], 0, 44);\n<line40>}else{\n<line41>sqlite3OsRandomness(pVfs, 44, (char*)&wsdPrng.s[4]);\n<line42>}\n<line43>wsdPrng.s[15] = wsdPrng.s[12];\n<line44>wsdPrng.s[12] = 0;\n<line45>wsdPrng.n = 0;\n<line46>}\n<line47>assert( N>0 );\n<line48>while( 1 /* exit by break */ ){\n<line49>if( N<=wsdPrng.n ){\n<line50>memcpy(zBuf, &wsdPrng.out[wsdPrng.n-N], N);\n<line51>wsdPrng.n -= N;\n<line52>break;\n<line53>}\n<line54>if( wsdPrng.n>0 ){\n<line55>memcpy(zBuf, wsdPrng.out, wsdPrng.n);\n<line56>N -= wsdPrng.n;\n<line57>zBuf += wsdPrng.n;\n<line58>}\n<line59>wsdPrng.s[12]++;\n<line60>chacha_block((u32*)wsdPrng.out, wsdPrng.s);\n<line61>wsdPrng.n = 64;\n<line62>}\n<line63>sqlite3_mutex_leave(mutex);\n<line64>}
----------------------------------------
Function: sqlite3ErrorFinish
Content: <line0>static SQLITE_NOINLINE void  sqlite3ErrorFinish(sqlite3 *db, int err_code){\n<line1>if( db->pErr ) sqlite3ValueSetNull(db->pErr);\n<line2>sqlite3SystemError(db, err_code);\n<line3>}
----------------------------------------
Function: sqlite3_stricmp
Content: <line0>SQLITE_API int sqlite3_stricmp(const char *zLeft, const char *zRight){\n<line1>if( zLeft==0 ){\n<line2>return zRight ? -1 : 0;\n<line3>}else if( zRight==0 ){\n<line4>return 1;\n<line5>}\n<line6>return sqlite3StrICmp(zLeft, zRight);\n<line7>}
----------------------------------------
Function: sqlite3_strnicmp
Content: <line0>SQLITE_API int sqlite3_strnicmp(const char *zLeft, const char *zRight, int N){\n<line1>register unsigned char *a, *b;\n<line2>if( zLeft==0 ){\n<line3>return zRight ? -1 : 0;\n<line4>}else if( zRight==0 ){\n<line5>return 1;\n<line6>}\n<line7>a = (unsigned char *)zLeft;\n<line8>b = (unsigned char *)zRight;\n<line9>while( N-- > 0 && *a!=0 && UpperToLower[*a]==UpperToLower[*b]){ a++; b++; }\n<line10>return N<0 ? 0 : UpperToLower[*a] - UpperToLower[*b];\n<line11>}
----------------------------------------
Function: dekkerMul2
Content: <line0>static void dekkerMul2(volatile double *x, double y, double yy){\n<line1>/*\n<line2>** The "volatile" keywords on parameter x[] and on local variables\n<line3>** below are needed force intermediate results to be truncated to\n<line4>** binary64 rather than be carried around in an extended-precision\n<line5>** format.  The truncation is necessary for the Dekker algorithm to\n<line6>** work.  Intel x86 floating point might omit the truncation without\n<line7>** the use of volatile.\n<line8>*/\n<line9>volatile double tx, ty, p, q, c, cc;\n<line10>double hx, hy;\n<line11>u64 m;\n<line12>memcpy(&m, (void*)&x[0], 8);\n<line13>m &= 0xfffffffffc000000LL;\n<line14>memcpy(&hx, &m, 8);\n<line15>tx = x[0] - hx;\n<line16>memcpy(&m, &y, 8);\n<line17>m &= 0xfffffffffc000000LL;\n<line18>memcpy(&hy, &m, 8);\n<line19>ty = y - hy;\n<line20>p = hx*hy;\n<line21>q = hx*ty + tx*hy;\n<line22>c = p+q;\n<line23>cc = p - c + q + tx*ty;\n<line24>cc = x[0]*yy + x[1]*y + cc;\n<line25>x[0] = c + cc;\n<line26>x[1] = c - x[0];\n<line27>x[1] += cc;\n<line28>}
----------------------------------------
Function: compare2pow63
Content: <line0>static int compare2pow63(const char *zNum, int incr){\n<line1>int c = 0;\n<line2>int i;\n<line3>/* 012345678901234567 */\n<line4>const char *pow63 = "922337203685477580";\n<line5>for(i=0; c==0 && i<18; i++){\n<line6>c = (zNum[i*incr]-pow63[i])*10;\n<line7>}\n<line8>if( c==0 ){\n<line9>c = zNum[18*incr] - '8';\n<line10>testcase( c==(-1) );\n<line11>testcase( c==0 );\n<line12>testcase( c==(+1) );\n<line13>}\n<line14>return c;\n<line15>}
----------------------------------------
Function: putVarint64
Content: <line0>static int SQLITE_NOINLINE putVarint64(unsigned char *p, u64 v){\n<line1>int i, j, n;\n<line2>u8 buf[10];\n<line3>if( v & (((u64)0xff000000)<<32) ){\n<line4>p[8] = (u8)v;\n<line5>v >>= 8;\n<line6>for(i=7; i>=0; i--){\n<line7>p[i] = (u8)((v & 0x7f) | 0x80);\n<line8>v >>= 7;\n<line9>}\n<line10>return 9;\n<line11>}\n<line12>n = 0;\n<line13>do{\n<line14>buf[n++] = (u8)((v & 0x7f) | 0x80);\n<line15>v >>= 7;\n<line16>}while( v!=0 );\n<line17>buf[0] &= 0x7f;\n<line18>assert( n<=9 );\n<line19>for(i=0, j=n-1; j>=0; j--, i++){\n<line20>p[i] = buf[j];\n<line21>}\n<line22>return n;\n<line23>}
----------------------------------------
Function: logBadConnection
Content: <line0>static void logBadConnection(const char *zType){\n<line1>sqlite3_log(SQLITE_MISUSE,\n<line2>"API call with %s database connection pointer",\n<line3>zType\n<line4>);\n<line5>}
----------------------------------------
Function: strHash
Content: <line0>static unsigned int strHash(const char *z){\n<line1>unsigned int h = 0;\n<line2>while( z[0] ){     /*OPTIMIZATION-IF-TRUE*/\n<line3>/* Knuth multiplicative hashing.  (Sorting & Searching, p. 510).\n<line4>** 0x9e3779b1 is 2654435761 which is the closest prime number to\n<line5>** (2**32)*golden_ratio, where golden_ratio = (sqrt(5) - 1)/2.\n<line6>**\n<line7>** Only bits 0xdf for ASCII and bits 0xbf for EBCDIC each octet are\n<line8>** hashed since the omitted bits determine the upper/lower case difference.\n<line9>*/\n<line10>#ifdef SQLITE_EBCDIC\n<line11>h += 0xbf & (unsigned char)*(z++);\n<line12>#else\n<line13>h += 0xdf & (unsigned char)*(z++);\n<line14>#endif\n<line15>h *= 0x9e3779b1;\n<line16>}\n<line17>return h;\n<line18>}
----------------------------------------
Function: insertElement
Content: <line0>static void insertElement(\n<line1>Hash *pH,              /* The complete hash table */\n<line2>struct _ht *pEntry,    /* The entry into which pNew is inserted */\n<line3>HashElem *pNew         /* The element to be inserted */\n<line4>){\n<line5>HashElem *pHead;       /* First element already in pEntry */\n<line6>if( pEntry ){\n<line7>pHead = pEntry->count ? pEntry->chain : 0;\n<line8>pEntry->count++;\n<line9>pEntry->chain = pNew;\n<line10>}else{\n<line11>pHead = 0;\n<line12>}\n<line13>if( pHead ){\n<line14>pNew->next = pHead;\n<line15>pNew->prev = pHead->prev;\n<line16>if( pHead->prev ){ pHead->prev->next = pNew; }\n<line17>else             { pH->first = pNew; }\n<line18>pHead->prev = pNew;\n<line19>}else{\n<line20>pNew->next = pH->first;\n<line21>if( pH->first ){ pH->first->prev = pNew; }\n<line22>pNew->prev = 0;\n<line23>pH->first = pNew;\n<line24>}\n<line25>}
----------------------------------------
Function: rehash
Content: <line0>static int rehash(Hash *pH, unsigned int new_size){\n<line1>struct _ht *new_ht;            /* The new hash table */\n<line2>HashElem *elem, *next_elem;    /* For looping over existing elements */\n<line3>#if SQLITE_MALLOC_SOFT_LIMIT>0\n<line4>if( new_size*sizeof(struct _ht)>SQLITE_MALLOC_SOFT_LIMIT ){\n<line5>new_size = SQLITE_MALLOC_SOFT_LIMIT/sizeof(struct _ht);\n<line6>}\n<line7>if( new_size==pH->htsize ) return 0;\n<line8>#endif\n<line9>/* The inability to allocates space for a larger hash table is\n<line10>** a performance hit but it is not a fatal error.  So mark the\n<line11>** allocation as a benign. Use sqlite3Malloc()/memset(0) instead of\n<line12>** sqlite3MallocZero() to make the allocation, as sqlite3MallocZero()\n<line13>** only zeroes the requested number of bytes whereas this module will\n<line14>** use the actual amount of space allocated for the hash table (which\n<line15>** may be larger than the requested amount).\n<line16>*/\n<line17>sqlite3BeginBenignMalloc();\n<line18>new_ht = (struct _ht *)sqlite3Malloc( new_size*sizeof(struct _ht) );\n<line19>sqlite3EndBenignMalloc();\n<line20>if( new_ht==0 ) return 0;\n<line21>sqlite3_free(pH->ht);\n<line22>pH->ht = new_ht;\n<line23>pH->htsize = new_size = sqlite3MallocSize(new_ht)/sizeof(struct _ht);\n<line24>memset(new_ht, 0, new_size*sizeof(struct _ht));\n<line25>for(elem=pH->first, pH->first=0; elem; elem = next_elem){\n<line26>next_elem = elem->next;\n<line27>insertElement(pH, &new_ht[elem->h % new_size], elem);\n<line28>}\n<line29>return 1;\n<line30>}
----------------------------------------
Function: findElementWithHash
Content: <line0>static HashElem *findElementWithHash(\n<line1>const Hash *pH,     /* The pH to be searched */\n<line2>const char *pKey,   /* The key we are searching for */\n<line3>unsigned int *pHash /* Write the hash value here */\n<line4>){\n<line5>HashElem *elem;                /* Used to loop thru the element list */\n<line6>unsigned int count;            /* Number of elements left to test */\n<line7>unsigned int h;                /* The computed hash */\n<line8>static HashElem nullElement = { 0, 0, 0, 0, 0 };\n<line9>h = strHash(pKey);\n<line10>if( pH->ht ){   /*OPTIMIZATION-IF-TRUE*/\n<line11>struct _ht *pEntry;\n<line12>pEntry = &pH->ht[h % pH->htsize];\n<line13>elem = pEntry->chain;\n<line14>count = pEntry->count;\n<line15>}else{\n<line16>elem = pH->first;\n<line17>count = pH->count;\n<line18>}\n<line19>if( pHash ) *pHash = h;\n<line20>while( count ){\n<line21>assert( elem!=0 );\n<line22>if( h==elem->h && sqlite3StrICmp(elem->pKey,pKey)==0 ){\n<line23>return elem;\n<line24>}\n<line25>elem = elem->next;\n<line26>count--;\n<line27>}\n<line28>return &nullElement;\n<line29>}
----------------------------------------
Function: removeElement
Content: <line0>static void removeElement(\n<line1>Hash *pH,         /* The pH containing "elem" */\n<line2>HashElem *elem    /* The element to be removed from the pH */\n<line3>){\n<line4>struct _ht *pEntry;\n<line5>if( elem->prev ){\n<line6>elem->prev->next = elem->next;\n<line7>}else{\n<line8>pH->first = elem->next;\n<line9>}\n<line10>if( elem->next ){\n<line11>elem->next->prev = elem->prev;\n<line12>}\n<line13>if( pH->ht ){\n<line14>pEntry = &pH->ht[elem->h % pH->htsize];\n<line15>if( pEntry->chain==elem ){\n<line16>pEntry->chain = elem->next;\n<line17>}\n<line18>assert( pEntry->count>0 );\n<line19>pEntry->count--;\n<line20>}\n<line21>sqlite3_free( elem );\n<line22>pH->count--;\n<line23>if( pH->count==0 ){\n<line24>assert( pH->first==0 );\n<line25>assert( pH->count==0 );\n<line26>sqlite3HashClear(pH);\n<line27>}\n<line28>}
----------------------------------------
Function: posixOpen
Content: <line0>static int posixOpen(const char *zFile, int flags, int mode){\n<line1>return open(zFile, flags, mode);\n<line2>}
----------------------------------------
Function: robustFchown
Content: <line0>static int robustFchown(int fd, uid_t uid, gid_t gid){\n<line1>#if defined(HAVE_FCHOWN)\n<line2>return osGeteuid() ? 0 : osFchown(fd,uid,gid);\n<line3>#else\n<line4>return 0;\n<line5>#endif\n<line6>}
----------------------------------------
Function: unixSetSystemCall
Content: <line0>static int unixSetSystemCall(\n<line1>sqlite3_vfs *pNotUsed,        /* The VFS pointer.  Not used */\n<line2>const char *zName,            /* Name of system call to override */\n<line3>sqlite3_syscall_ptr pNewFunc  /* Pointer to new system call value */\n<line4>){\n<line5>unsigned int i;\n<line6>int rc = SQLITE_NOTFOUND;\n<line7>UNUSED_PARAMETER(pNotUsed);\n<line8>if( zName==0 ){\n<line9>/* If no zName is given, restore all system calls to their default\n<line10>** settings and return NULL\n<line11>*/\n<line12>rc = SQLITE_OK;\n<line13>for(i=0; i<sizeof(aSyscall)/sizeof(aSyscall[0]); i++){\n<line14>if( aSyscall[i].pDefault ){\n<line15>aSyscall[i].pCurrent = aSyscall[i].pDefault;\n<line16>}\n<line17>}\n<line18>}else{\n<line19>/* If zName is specified, operate on only the one system call\n<line20>** specified.\n<line21>*/\n<line22>for(i=0; i<sizeof(aSyscall)/sizeof(aSyscall[0]); i++){\n<line23>if( strcmp(zName, aSyscall[i].zName)==0 ){\n<line24>if( aSyscall[i].pDefault==0 ){\n<line25>aSyscall[i].pDefault = aSyscall[i].pCurrent;\n<line26>}\n<line27>rc = SQLITE_OK;\n<line28>if( pNewFunc==0 ) pNewFunc = aSyscall[i].pDefault;\n<line29>aSyscall[i].pCurrent = pNewFunc;\n<line30>break;\n<line31>}\n<line32>}\n<line33>}\n<line34>return rc;\n<line35>}
----------------------------------------
Function: unixGetSystemCall
Content: <line0>static sqlite3_syscall_ptr unixGetSystemCall(\n<line1>sqlite3_vfs *pNotUsed,\n<line2>const char *zName\n<line3>){\n<line4>unsigned int i;\n<line5>UNUSED_PARAMETER(pNotUsed);\n<line6>for(i=0; i<sizeof(aSyscall)/sizeof(aSyscall[0]); i++){\n<line7>if( strcmp(zName, aSyscall[i].zName)==0 ) return aSyscall[i].pCurrent;\n<line8>}\n<line9>return 0;\n<line10>}
----------------------------------------
Function: unixNextSystemCall
Content: <line0>static const char *unixNextSystemCall(sqlite3_vfs *p, const char *zName){\n<line1>int i = -1;\n<line2>UNUSED_PARAMETER(p);\n<line3>if( zName ){\n<line4>for(i=0; i<ArraySize(aSyscall)-1; i++){\n<line5>if( strcmp(zName, aSyscall[i].zName)==0 ) break;\n<line6>}\n<line7>}\n<line8>for(i++; i<ArraySize(aSyscall); i++){\n<line9>if( aSyscall[i].pCurrent!=0 ) return aSyscall[i].zName;\n<line10>}\n<line11>return 0;\n<line12>}
----------------------------------------
Function: robust_open
Content: <line0>static int robust_open(const char *z, int f, mode_t m){\n<line1>int fd;\n<line2>mode_t m2 = m ? m : SQLITE_DEFAULT_FILE_PERMISSIONS;\n<line3>while(1){\n<line4>#if defined(O_CLOEXEC)\n<line5>fd = osOpen(z,f|O_CLOEXEC,m2);\n<line6>#else\n<line7>fd = osOpen(z,f,m2);\n<line8>#endif\n<line9>if( fd<0 ){\n<line10>if( errno==EINTR ) continue;\n<line11>break;\n<line12>}\n<line13>if( fd>=SQLITE_MINIMUM_FILE_DESCRIPTOR ) break;\n<line14>if( (f & (O_EXCL|O_CREAT))==(O_EXCL|O_CREAT) ){\n<line15>(void)osUnlink(z);\n<line16>}\n<line17>osClose(fd);\n<line18>sqlite3_log(SQLITE_WARNING,\n<line19>"attempt to open \"%s\" as file descriptor %d", z, fd);\n<line20>fd = -1;\n<line21>if( osOpen("/dev/null", O_RDONLY, m)<0 ) break;\n<line22>}\n<line23>if( fd>=0 ){\n<line24>if( m!=0 ){\n<line25>struct stat statbuf;\n<line26>if( osFstat(fd, &statbuf)==0\n<line27>&& statbuf.st_size==0\n<line28>&& (statbuf.st_mode&0777)!=m\n<line29>){\n<line30>osFchmod(fd, m);\n<line31>}\n<line32>}\n<line33>#if defined(FD_CLOEXEC) && (!defined(O_CLOEXEC) || O_CLOEXEC==0)\n<line34>osFcntl(fd, F_SETFD, osFcntl(fd, F_GETFD, 0) | FD_CLOEXEC);\n<line35>#endif\n<line36>}\n<line37>return fd;\n<line38>}
----------------------------------------
Function: unixEnterMutex
Content: <line0>static void unixEnterMutex(void){\n<line1>assert( sqlite3_mutex_notheld(unixBigLock) );  /* Not a recursive mutex */\n<line2>sqlite3_mutex_enter(unixBigLock);\n<line3>}
----------------------------------------
Function: unixLeaveMutex
Content: <line0>static void unixLeaveMutex(void){\n<line1>assert( sqlite3_mutex_held(unixBigLock) );\n<line2>sqlite3_mutex_leave(unixBigLock);\n<line3>}
----------------------------------------
Function: robust_ftruncate
Content: <line0>static int robust_ftruncate(int h, sqlite3_int64 sz){\n<line1>int rc;\n<line2>#ifdef __ANDROID__\n<line3>/* On Android, ftruncate() always uses 32-bit offsets, even if\n<line4>** _FILE_OFFSET_BITS=64 is defined. This means it is unsafe to attempt to\n<line5>** truncate a file to any size larger than 2GiB. Silently ignore any\n<line6>** such attempts.  */\n<line7>if( sz>(sqlite3_int64)0x7FFFFFFF ){\n<line8>rc = SQLITE_OK;\n<line9>}else\n<line10>#endif\n<line11>do{ rc = osFtruncate(h,sz); }while( rc<0 && errno==EINTR );\n<line12>return rc;\n<line13>}
----------------------------------------
Function: sqliteErrorFromPosixError
Content: <line0>static int sqliteErrorFromPosixError(int posixError, int sqliteIOErr) {\n<line1>assert( (sqliteIOErr == SQLITE_IOERR_LOCK) ||\n<line2>(sqliteIOErr == SQLITE_IOERR_UNLOCK) ||\n<line3>(sqliteIOErr == SQLITE_IOERR_RDLOCK) ||\n<line4>(sqliteIOErr == SQLITE_IOERR_CHECKRESERVEDLOCK) );\n<line5>switch (posixError) {\n<line6>case EACCES:\n<line7>case EAGAIN:\n<line8>case ETIMEDOUT:\n<line9>case EBUSY:\n<line10>case EINTR:\n<line11>case ENOLCK:\n<line12>/* random NFS retry error, unless during file system support\n<line13>* introspection, in which it actually means what it says */\n<line14>return SQLITE_BUSY;\n<line15>case EPERM:\n<line16>return SQLITE_PERM;\n<line17>default:\n<line18>return sqliteIOErr;\n<line19>}\n<line20>}
----------------------------------------
Function: unixLogErrorAtLine
Content: <line0>static int unixLogErrorAtLine(\n<line1>int errcode,                    /* SQLite error code */\n<line2>const char *zFunc,              /* Name of OS function that failed */\n<line3>const char *zPath,              /* File path associated with error */\n<line4>int iLine                       /* Source line number where error occurred */\n<line5>){\n<line6>char *zErr;                     /* Message from strerror() or equivalent */\n<line7>int iErrno = errno;             /* Saved syscall error number */\n<line8>/* If this is not a threadsafe build (SQLITE_THREADSAFE==0), then use\n<line9>** the strerror() function to obtain the human-readable error message\n<line10>** equivalent to errno. Otherwise, use strerror_r().\n<line11>*/\n<line12>#if SQLITE_THREADSAFE && defined(HAVE_STRERROR_R)\n<line13>char aErr[80];\n<line14>memset(aErr, 0, sizeof(aErr));\n<line15>zErr = aErr;\n<line16>/* If STRERROR_R_CHAR_P (set by autoconf scripts) or __USE_GNU is defined,\n<line17>** assume that the system provides the GNU version of strerror_r() that\n<line18>** returns a pointer to a buffer containing the error message. That pointer\n<line19>** may point to aErr[], or it may point to some static storage somewhere.\n<line20>** Otherwise, assume that the system provides the POSIX version of\n<line21>** strerror_r(), which always writes an error message into aErr[].\n<line22>**\n<line23>** If the code incorrectly assumes that it is the POSIX version that is\n<line24>** available, the error message will often be an empty string. Not a\n<line25>** huge problem. Incorrectly concluding that the GNU version is available\n<line26>** could lead to a segfault though.\n<line27>**\n<line28>** Forum post 3f13857fa4062301 reports that the Android SDK may use\n<line29>** int-type return, depending on its version.\n<line30>*/\n<line31>#if (defined(STRERROR_R_CHAR_P) || defined(__USE_GNU)) \\n<line32>&& !defined(ANDROID) && !defined(__ANDROID__)\n<line33>zErr =\n<line34># endif\n<line35>strerror_r(iErrno, aErr, sizeof(aErr)-1);\n<line36>#elif SQLITE_THREADSAFE\n<line37>/* This is a threadsafe build, but strerror_r() is not available. */\n<line38>zErr = "";\n<line39>#else\n<line40>/* Non-threadsafe build, use strerror(). */\n<line41>zErr = strerror(iErrno);\n<line42>#endif\n<line43>if( zPath==0 ) zPath = "";\n<line44>sqlite3_log(errcode,\n<line45>"os_unix.c:%d: (%d) %s(%s) - %s",\n<line46>iLine, iErrno, zFunc, zPath, zErr\n<line47>);\n<line48>return errcode;\n<line49>}
----------------------------------------
Function: robust_close
Content: <line0>static void robust_close(unixFile *pFile, int h, int lineno){\n<line1>if( osClose(h) ){\n<line2>unixLogErrorAtLine(SQLITE_IOERR_CLOSE, "close",\n<line3>pFile ? pFile->zPath : 0, lineno);\n<line4>}\n<line5>}
----------------------------------------
Function: storeLastErrno
Content: <line0>static void storeLastErrno(unixFile *pFile, int error){\n<line1>pFile->lastErrno = error;\n<line2>}
----------------------------------------
Function: closePendingFds
Content: <line0>static void closePendingFds(unixFile *pFile){\n<line1>unixInodeInfo *pInode = pFile->pInode;\n<line2>UnixUnusedFd *p;\n<line3>UnixUnusedFd *pNext;\n<line4>assert( unixFileMutexHeld(pFile) );\n<line5>for(p=pInode->pUnused; p; p=pNext){\n<line6>pNext = p->pNext;\n<line7>robust_close(pFile, p->fd, __LINE__);\n<line8>sqlite3_free(p);\n<line9>}\n<line10>pInode->pUnused = 0;\n<line11>}
----------------------------------------
Function: releaseInodeInfo
Content: <line0>static void releaseInodeInfo(unixFile *pFile){\n<line1>unixInodeInfo *pInode = pFile->pInode;\n<line2>assert( unixMutexHeld() );\n<line3>assert( unixFileMutexNotheld(pFile) );\n<line4>if( ALWAYS(pInode) ){\n<line5>pInode->nRef--;\n<line6>if( pInode->nRef==0 ){\n<line7>assert( pInode->pShmNode==0 );\n<line8>sqlite3_mutex_enter(pInode->pLockMutex);\n<line9>closePendingFds(pFile);\n<line10>sqlite3_mutex_leave(pInode->pLockMutex);\n<line11>if( pInode->pPrev ){\n<line12>assert( pInode->pPrev->pNext==pInode );\n<line13>pInode->pPrev->pNext = pInode->pNext;\n<line14>}else{\n<line15>assert( inodeList==pInode );\n<line16>inodeList = pInode->pNext;\n<line17>}\n<line18>if( pInode->pNext ){\n<line19>assert( pInode->pNext->pPrev==pInode );\n<line20>pInode->pNext->pPrev = pInode->pPrev;\n<line21>}\n<line22>sqlite3_mutex_free(pInode->pLockMutex);\n<line23>sqlite3_free(pInode);\n<line24>}\n<line25>}\n<line26>}
----------------------------------------
Function: findInodeInfo
Content: <line0>static int findInodeInfo(\n<line1>unixFile *pFile,               /* Unix file with file desc used in the key */\n<line2>unixInodeInfo **ppInode        /* Return the unixInodeInfo object here */\n<line3>){\n<line4>int rc;                        /* System call return code */\n<line5>int fd;                        /* The file descriptor for pFile */\n<line6>struct unixFileId fileId;      /* Lookup key for the unixInodeInfo */\n<line7>struct stat statbuf;           /* Low-level file information */\n<line8>unixInodeInfo *pInode = 0;     /* Candidate unixInodeInfo object */\n<line9>assert( unixMutexHeld() );\n<line10>/* Get low-level information about the file that we can used to\n<line11>** create a unique name for the file.\n<line12>*/\n<line13>fd = pFile->h;\n<line14>rc = osFstat(fd, &statbuf);\n<line15>if( rc!=0 ){\n<line16>storeLastErrno(pFile, errno);\n<line17>#if defined(EOVERFLOW) && defined(SQLITE_DISABLE_LFS)\n<line18>if( pFile->lastErrno==EOVERFLOW ) return SQLITE_NOLFS;\n<line19>#endif\n<line20>return SQLITE_IOERR;\n<line21>}\n<line22>#ifdef __APPLE__\n<line23>/* On OS X on an msdos filesystem, the inode number is reported\n<line24>** incorrectly for zero-size files.  See ticket #3260.  To work\n<line25>** around this problem (we consider it a bug in OS X, not SQLite)\n<line26>** we always increase the file size to 1 by writing a single byte\n<line27>** prior to accessing the inode number.  The one byte written is\n<line28>** an ASCII 'S' character which also happens to be the first byte\n<line29>** in the header of every SQLite database.  In this way, if there\n<line30>** is a race condition such that another thread has already populated\n<line31>** the first page of the database, no damage is done.\n<line32>*/\n<line33>if( statbuf.st_size==0 && (pFile->fsFlags & SQLITE_FSFLAGS_IS_MSDOS)!=0 ){\n<line34>do{ rc = osWrite(fd, "S", 1); }while( rc<0 && errno==EINTR );\n<line35>if( rc!=1 ){\n<line36>storeLastErrno(pFile, errno);\n<line37>return SQLITE_IOERR;\n<line38>}\n<line39>if( fsync(fd) ){\n<line40>storeLastErrno(pFile, errno);\n<line41>return SQLITE_IOERR_FSYNC;\n<line42>}\n<line43>rc = osFstat(fd, &statbuf);\n<line44>if( rc!=0 ){\n<line45>storeLastErrno(pFile, errno);\n<line46>return SQLITE_IOERR;\n<line47>}\n<line48>}\n<line49>#endif\n<line50>memset(&fileId, 0, sizeof(fileId));\n<line51>fileId.dev = statbuf.st_dev;\n<line52>#if OS_VXWORKS\n<line53>fileId.pId = pFile->pId;\n<line54>#else\n<line55>fileId.ino = (u64)statbuf.st_ino;\n<line56>#endif\n<line57>assert( unixMutexHeld() );\n<line58>pInode = inodeList;\n<line59>while( pInode && memcmp(&fileId, &pInode->fileId, sizeof(fileId)) ){\n<line60>pInode = pInode->pNext;\n<line61>}\n<line62>if( pInode==0 ){\n<line63>pInode = sqlite3_malloc64( sizeof(*pInode) );\n<line64>if( pInode==0 ){\n<line65>return SQLITE_NOMEM_BKPT;\n<line66>}\n<line67>memset(pInode, 0, sizeof(*pInode));\n<line68>memcpy(&pInode->fileId, &fileId, sizeof(fileId));\n<line69>if( sqlite3GlobalConfig.bCoreMutex ){\n<line70>pInode->pLockMutex = sqlite3_mutex_alloc(SQLITE_MUTEX_FAST);\n<line71>if( pInode->pLockMutex==0 ){\n<line72>sqlite3_free(pInode);\n<line73>return SQLITE_NOMEM_BKPT;\n<line74>}\n<line75>}\n<line76>pInode->nRef = 1;\n<line77>assert( unixMutexHeld() );\n<line78>pInode->pNext = inodeList;\n<line79>pInode->pPrev = 0;\n<line80>if( inodeList ) inodeList->pPrev = pInode;\n<line81>inodeList = pInode;\n<line82>}else{\n<line83>pInode->nRef++;\n<line84>}\n<line85>*ppInode = pInode;\n<line86>return SQLITE_OK;\n<line87>}
----------------------------------------
Function: fileHasMoved
Content: <line0>static int fileHasMoved(unixFile *pFile){\n<line1>#if OS_VXWORKS\n<line2>return pFile->pInode!=0 && pFile->pId!=pFile->pInode->fileId.pId;\n<line3>#else\n<line4>struct stat buf;\n<line5>return pFile->pInode!=0 &&\n<line6>(osStat(pFile->zPath, &buf)!=0\n<line7>|| (u64)buf.st_ino!=pFile->pInode->fileId.ino);\n<line8>#endif\n<line9>}
----------------------------------------
Function: verifyDbFile
Content: <line0>static void verifyDbFile(unixFile *pFile){\n<line1>struct stat buf;\n<line2>int rc;\n<line3>/* These verifications occurs for the main database only */\n<line4>if( pFile->ctrlFlags & UNIXFILE_NOLOCK ) return;\n<line5>rc = osFstat(pFile->h, &buf);\n<line6>if( rc!=0 ){\n<line7>sqlite3_log(SQLITE_WARNING, "cannot fstat db file %s", pFile->zPath);\n<line8>return;\n<line9>}\n<line10>if( buf.st_nlink==0 ){\n<line11>sqlite3_log(SQLITE_WARNING, "file unlinked while open: %s", pFile->zPath);\n<line12>return;\n<line13>}\n<line14>if( buf.st_nlink>1 ){\n<line15>sqlite3_log(SQLITE_WARNING, "multiple links to file: %s", pFile->zPath);\n<line16>return;\n<line17>}\n<line18>if( fileHasMoved(pFile) ){\n<line19>sqlite3_log(SQLITE_WARNING, "file renamed while open: %s", pFile->zPath);\n<line20>return;\n<line21>}\n<line22>}
----------------------------------------
Function: unixCheckReservedLock
Content: <line0>static int unixCheckReservedLock(sqlite3_file *id, int *pResOut){\n<line1>int rc = SQLITE_OK;\n<line2>int reserved = 0;\n<line3>unixFile *pFile = (unixFile*)id;\n<line4>SimulateIOError( return SQLITE_IOERR_CHECKRESERVEDLOCK; );\n<line5>assert( pFile );\n<line6>assert( pFile->eFileLock<=SHARED_LOCK );\n<line7>sqlite3_mutex_enter(pFile->pInode->pLockMutex);\n<line8>/* Check if a thread in this process holds such a lock */\n<line9>if( pFile->pInode->eFileLock>SHARED_LOCK ){\n<line10>reserved = 1;\n<line11>}\n<line12>/* Otherwise see if some other process holds it.\n<line13>*/\n<line14>#ifndef __DJGPP__\n<line15>if( !reserved && !pFile->pInode->bProcessLock ){\n<line16>struct flock lock;\n<line17>lock.l_whence = SEEK_SET;\n<line18>lock.l_start = RESERVED_BYTE;\n<line19>lock.l_len = 1;\n<line20>lock.l_type = F_WRLCK;\n<line21>if( osFcntl(pFile->h, F_GETLK, &lock) ){\n<line22>rc = SQLITE_IOERR_CHECKRESERVEDLOCK;\n<line23>storeLastErrno(pFile, errno);\n<line24>} else if( lock.l_type!=F_UNLCK ){\n<line25>reserved = 1;\n<line26>}\n<line27>}\n<line28>#endif\n<line29>sqlite3_mutex_leave(pFile->pInode->pLockMutex);\n<line30>OSTRACE(("TEST WR-LOCK %d %d %d (unix)\n", pFile->h, rc, reserved));\n<line31>*pResOut = reserved;\n<line32>return rc;\n<line33>}
----------------------------------------
Function: unixFileLock
Content: <line0>static int unixFileLock(unixFile *pFile, struct flock *pLock){\n<line1>int rc;\n<line2>unixInodeInfo *pInode = pFile->pInode;\n<line3>assert( pInode!=0 );\n<line4>assert( sqlite3_mutex_held(pInode->pLockMutex) );\n<line5>if( (pFile->ctrlFlags & (UNIXFILE_EXCL|UNIXFILE_RDONLY))==UNIXFILE_EXCL ){\n<line6>if( pInode->bProcessLock==0 ){\n<line7>struct flock lock;\n<line8>/* assert( pInode->nLock==0 ); <-- Not true if unix-excl READONLY used */\n<line9>lock.l_whence = SEEK_SET;\n<line10>lock.l_start = SHARED_FIRST;\n<line11>lock.l_len = SHARED_SIZE;\n<line12>lock.l_type = F_WRLCK;\n<line13>rc = osSetPosixAdvisoryLock(pFile->h, &lock, pFile);\n<line14>if( rc<0 ) return rc;\n<line15>pInode->bProcessLock = 1;\n<line16>pInode->nLock++;\n<line17>}else{\n<line18>rc = 0;\n<line19>}\n<line20>}else{\n<line21>#ifdef SQLITE_ENABLE_SETLK_TIMEOUT\n<line22>if( pFile->bBlockOnConnect && pLock->l_type==F_RDLCK\n<line23>&& pLock->l_start==SHARED_FIRST && pLock->l_len==SHARED_SIZE\n<line24>){\n<line25>rc = osFcntl(pFile->h, F_SETLKW, pLock);\n<line26>}else\n<line27>#endif\n<line28>rc = osSetPosixAdvisoryLock(pFile->h, pLock, pFile);\n<line29>}\n<line30>return rc;\n<line31>}
----------------------------------------
Function: unixLock
Content: <line0>static int unixLock(sqlite3_file *id, int eFileLock){\n<line1>/* The following describes the implementation of the various locks and\n<line2>** lock transitions in terms of the POSIX advisory shared and exclusive\n<line3>** lock primitives (called read-locks and write-locks below, to avoid\n<line4>** confusion with SQLite lock names). The algorithms are complicated\n<line5>** slightly in order to be compatible with Windows95 systems simultaneously\n<line6>** accessing the same database file, in case that is ever required.\n<line7>**\n<line8>** Symbols defined in os.h identify the 'pending byte' and the 'reserved\n<line9>** byte', each single bytes at well known offsets, and the 'shared byte\n<line10>** range', a range of 510 bytes at a well known offset.\n<line11>**\n<line12>** To obtain a SHARED lock, a read-lock is obtained on the 'pending\n<line13>** byte'.  If this is successful, 'shared byte range' is read-locked\n<line14>** and the lock on the 'pending byte' released.  (Legacy note:  When\n<line15>** SQLite was first developed, Windows95 systems were still very common,\n<line16>** and Windows95 lacks a shared-lock capability.  So on Windows95, a\n<line17>** single randomly selected by from the 'shared byte range' is locked.\n<line18>** Windows95 is now pretty much extinct, but this work-around for the\n<line19>** lack of shared-locks on Windows95 lives on, for backwards\n<line20>** compatibility.)\n<line21>**\n<line22>** A process may only obtain a RESERVED lock after it has a SHARED lock.\n<line23>** A RESERVED lock is implemented by grabbing a write-lock on the\n<line24>** 'reserved byte'.\n<line25>**\n<line26>** An EXCLUSIVE lock may only be requested after either a SHARED or\n<line27>** RESERVED lock is held. An EXCLUSIVE lock is implemented by obtaining\n<line28>** a write-lock on the entire 'shared byte range'. Since all other locks\n<line29>** require a read-lock on one of the bytes within this range, this ensures\n<line30>** that no other locks are held on the database.\n<line31>**\n<line32>** If a process that holds a RESERVED lock requests an EXCLUSIVE, then\n<line33>** a PENDING lock is obtained first. A PENDING lock is implemented by\n<line34>** obtaining a write-lock on the 'pending byte'. This ensures that no new\n<line35>** SHARED locks can be obtained, but existing SHARED locks are allowed to\n<line36>** persist. If the call to this function fails to obtain the EXCLUSIVE\n<line37>** lock in this case, it holds the PENDING lock instead. The client may\n<line38>** then re-attempt the EXCLUSIVE lock later on, after existing SHARED\n<line39>** locks have cleared.\n<line40>*/\n<line41>int rc = SQLITE_OK;\n<line42>unixFile *pFile = (unixFile*)id;\n<line43>unixInodeInfo *pInode;\n<line44>struct flock lock;\n<line45>int tErrno = 0;\n<line46>assert( pFile );\n<line47>OSTRACE(("LOCK    %d %s was %s(%s,%d) pid=%d (unix)\n", pFile->h,\n<line48>azFileLock(eFileLock), azFileLock(pFile->eFileLock),\n<line49>azFileLock(pFile->pInode->eFileLock), pFile->pInode->nShared,\n<line50>osGetpid(0)));\n<line51>/* If there is already a lock of this type or more restrictive on the\n<line52>** unixFile, do nothing. Don't use the end_lock: exit path, as\n<line53>** unixEnterMutex() hasn't been called yet.\n<line54>*/\n<line55>if( pFile->eFileLock>=eFileLock ){\n<line56>OSTRACE(("LOCK    %d %s ok (already held) (unix)\n", pFile->h,\n<line57>azFileLock(eFileLock)));\n<line58>return SQLITE_OK;\n<line59>}\n<line60>/* Make sure the locking sequence is correct.\n<line61>**  (1) We never move from unlocked to anything higher than shared lock.\n<line62>**  (2) SQLite never explicitly requests a pending lock.\n<line63>**  (3) A shared lock is always held when a reserve lock is requested.\n<line64>*/\n<line65>assert( pFile->eFileLock!=NO_LOCK || eFileLock==SHARED_LOCK );\n<line66>assert( eFileLock!=PENDING_LOCK );\n<line67>assert( eFileLock!=RESERVED_LOCK || pFile->eFileLock==SHARED_LOCK );\n<line68>/* This mutex is needed because pFile->pInode is shared across threads\n<line69>*/\n<line70>pInode = pFile->pInode;\n<line71>sqlite3_mutex_enter(pInode->pLockMutex);\n<line72>/* If some thread using this PID has a lock via a different unixFile*\n<line73>** handle that precludes the requested lock, return BUSY.\n<line74>*/\n<line75>if( (pFile->eFileLock!=pInode->eFileLock &&\n<line76>(pInode->eFileLock>=PENDING_LOCK || eFileLock>SHARED_LOCK))\n<line77>){\n<line78>rc = SQLITE_BUSY;\n<line79>goto end_lock;\n<line80>}\n<line81>/* If a SHARED lock is requested, and some thread using this PID already\n<line82>** has a SHARED or RESERVED lock, then increment reference counts and\n<line83>** return SQLITE_OK.\n<line84>*/\n<line85>if( eFileLock==SHARED_LOCK &&\n<line86>(pInode->eFileLock==SHARED_LOCK || pInode->eFileLock==RESERVED_LOCK) ){\n<line87>assert( eFileLock==SHARED_LOCK );\n<line88>assert( pFile->eFileLock==0 );\n<line89>assert( pInode->nShared>0 );\n<line90>pFile->eFileLock = SHARED_LOCK;\n<line91>pInode->nShared++;\n<line92>pInode->nLock++;\n<line93>goto end_lock;\n<line94>}\n<line95>/* A PENDING lock is needed before acquiring a SHARED lock and before\n<line96>** acquiring an EXCLUSIVE lock.  For the SHARED lock, the PENDING will\n<line97>** be released.\n<line98>*/\n<line99>lock.l_len = 1L;\n<line100>lock.l_whence = SEEK_SET;\n<line101>if( eFileLock==SHARED_LOCK\n<line102>|| (eFileLock==EXCLUSIVE_LOCK && pFile->eFileLock==RESERVED_LOCK)\n<line103>){\n<line104>lock.l_type = (eFileLock==SHARED_LOCK?F_RDLCK:F_WRLCK);\n<line105>lock.l_start = PENDING_BYTE;\n<line106>if( unixFileLock(pFile, &lock) ){\n<line107>tErrno = errno;\n<line108>rc = sqliteErrorFromPosixError(tErrno, SQLITE_IOERR_LOCK);\n<line109>if( rc!=SQLITE_BUSY ){\n<line110>storeLastErrno(pFile, tErrno);\n<line111>}\n<line112>goto end_lock;\n<line113>}else if( eFileLock==EXCLUSIVE_LOCK ){\n<line114>pFile->eFileLock = PENDING_LOCK;\n<line115>pInode->eFileLock = PENDING_LOCK;\n<line116>}\n<line117>}\n<line118>/* If control gets to this point, then actually go ahead and make\n<line119>** operating system calls for the specified lock.\n<line120>*/\n<line121>if( eFileLock==SHARED_LOCK ){\n<line122>assert( pInode->nShared==0 );\n<line123>assert( pInode->eFileLock==0 );\n<line124>assert( rc==SQLITE_OK );\n<line125>/* Now get the read-lock */\n<line126>lock.l_start = SHARED_FIRST;\n<line127>lock.l_len = SHARED_SIZE;\n<line128>if( unixFileLock(pFile, &lock) ){\n<line129>tErrno = errno;\n<line130>rc = sqliteErrorFromPosixError(tErrno, SQLITE_IOERR_LOCK);\n<line131>}\n<line132>/* Drop the temporary PENDING lock */\n<line133>lock.l_start = PENDING_BYTE;\n<line134>lock.l_len = 1L;\n<line135>lock.l_type = F_UNLCK;\n<line136>if( unixFileLock(pFile, &lock) && rc==SQLITE_OK ){\n<line137>/* This could happen with a network mount */\n<line138>tErrno = errno;\n<line139>rc = SQLITE_IOERR_UNLOCK;\n<line140>}\n<line141>if( rc ){\n<line142>if( rc!=SQLITE_BUSY ){\n<line143>storeLastErrno(pFile, tErrno);\n<line144>}\n<line145>goto end_lock;\n<line146>}else{\n<line147>pFile->eFileLock = SHARED_LOCK;\n<line148>pInode->nLock++;\n<line149>pInode->nShared = 1;\n<line150>}\n<line151>}else if( (eFileLock==EXCLUSIVE_LOCK && pInode->nShared>1)\n<line152>|| unixIsSharingShmNode(pFile)\n<line153>){\n<line154>/* We are trying for an exclusive lock but another thread in this\n<line155>** same process is still holding a shared lock. */\n<line156>rc = SQLITE_BUSY;\n<line157>}else{\n<line158>/* The request was for a RESERVED or EXCLUSIVE lock.  It is\n<line159>** assumed that there is a SHARED or greater lock on the file\n<line160>** already.\n<line161>*/\n<line162>assert( 0!=pFile->eFileLock );\n<line163>lock.l_type = F_WRLCK;\n<line164>assert( eFileLock==RESERVED_LOCK || eFileLock==EXCLUSIVE_LOCK );\n<line165>if( eFileLock==RESERVED_LOCK ){\n<line166>lock.l_start = RESERVED_BYTE;\n<line167>lock.l_len = 1L;\n<line168>}else{\n<line169>lock.l_start = SHARED_FIRST;\n<line170>lock.l_len = SHARED_SIZE;\n<line171>}\n<line172>if( unixFileLock(pFile, &lock) ){\n<line173>tErrno = errno;\n<line174>rc = sqliteErrorFromPosixError(tErrno, SQLITE_IOERR_LOCK);\n<line175>if( rc!=SQLITE_BUSY ){\n<line176>storeLastErrno(pFile, tErrno);\n<line177>}\n<line178>}\n<line179>}\n<line180>#ifdef SQLITE_DEBUG\n<line181>/* Set up the transaction-counter change checking flags when\n<line182>** transitioning from a SHARED to a RESERVED lock.  The change\n<line183>** from SHARED to RESERVED marks the beginning of a normal\n<line184>** write operation (not a hot journal rollback).\n<line185>*/\n<line186>if( rc==SQLITE_OK\n<line187>&& pFile->eFileLock<=SHARED_LOCK\n<line188>&& eFileLock==RESERVED_LOCK\n<line189>){\n<line190>pFile->transCntrChng = 0;\n<line191>pFile->dbUpdate = 0;\n<line192>pFile->inNormalWrite = 1;\n<line193>}\n<line194>#endif\n<line195>if( rc==SQLITE_OK ){\n<line196>pFile->eFileLock = eFileLock;\n<line197>pInode->eFileLock = eFileLock;\n<line198>}\n<line199>end_lock:\n<line200>sqlite3_mutex_leave(pInode->pLockMutex);\n<line201>OSTRACE(("LOCK    %d %s %s (unix)\n", pFile->h, azFileLock(eFileLock),\n<line202>rc==SQLITE_OK ? "ok" : "failed"));\n<line203>return rc;\n<line204>}
----------------------------------------
Function: setPendingFd
Content: <line0>static void setPendingFd(unixFile *pFile){\n<line1>unixInodeInfo *pInode = pFile->pInode;\n<line2>UnixUnusedFd *p = pFile->pPreallocatedUnused;\n<line3>assert( unixFileMutexHeld(pFile) );\n<line4>p->pNext = pInode->pUnused;\n<line5>pInode->pUnused = p;\n<line6>pFile->h = -1;\n<line7>pFile->pPreallocatedUnused = 0;\n<line8>}
----------------------------------------
Function: posixUnlock
Content: <line0>static int posixUnlock(sqlite3_file *id, int eFileLock, int handleNFSUnlock){\n<line1>unixFile *pFile = (unixFile*)id;\n<line2>unixInodeInfo *pInode;\n<line3>struct flock lock;\n<line4>int rc = SQLITE_OK;\n<line5>assert( pFile );\n<line6>OSTRACE(("UNLOCK  %d %d was %d(%d,%d) pid=%d (unix)\n", pFile->h, eFileLock,\n<line7>pFile->eFileLock, pFile->pInode->eFileLock, pFile->pInode->nShared,\n<line8>osGetpid(0)));\n<line9>assert( eFileLock<=SHARED_LOCK );\n<line10>if( pFile->eFileLock<=eFileLock ){\n<line11>return SQLITE_OK;\n<line12>}\n<line13>pInode = pFile->pInode;\n<line14>sqlite3_mutex_enter(pInode->pLockMutex);\n<line15>assert( pInode->nShared!=0 );\n<line16>if( pFile->eFileLock>SHARED_LOCK ){\n<line17>assert( pInode->eFileLock==pFile->eFileLock );\n<line18>#ifdef SQLITE_DEBUG\n<line19>/* When reducing a lock such that other processes can start\n<line20>** reading the database file again, make sure that the\n<line21>** transaction counter was updated if any part of the database\n<line22>** file changed.  If the transaction counter is not updated,\n<line23>** other connections to the same file might not realize that\n<line24>** the file has changed and hence might not know to flush their\n<line25>** cache.  The use of a stale cache can lead to database corruption.\n<line26>*/\n<line27>pFile->inNormalWrite = 0;\n<line28>#endif\n<line29>/* downgrading to a shared lock on NFS involves clearing the write lock\n<line30>** before establishing the readlock - to avoid a race condition we downgrade\n<line31>** the lock in 2 blocks, so that part of the range will be covered by a\n<line32>** write lock until the rest is covered by a read lock:\n<line33>**  1:   [WWWWW]\n<line34>**  2:   [....W]\n<line35>**  3:   [RRRRW]\n<line36>**  4:   [RRRR.]\n<line37>*/\n<line38>if( eFileLock==SHARED_LOCK ){\n<line39>#if !defined(__APPLE__) || !SQLITE_ENABLE_LOCKING_STYLE\n<line40>(void)handleNFSUnlock;\n<line41>assert( handleNFSUnlock==0 );\n<line42>#endif\n<line43>#if defined(__APPLE__) && SQLITE_ENABLE_LOCKING_STYLE\n<line44>if( handleNFSUnlock ){\n<line45>int tErrno;               /* Error code from system call errors */\n<line46>off_t divSize = SHARED_SIZE - 1;\n<line47>lock.l_type = F_UNLCK;\n<line48>lock.l_whence = SEEK_SET;\n<line49>lock.l_start = SHARED_FIRST;\n<line50>lock.l_len = divSize;\n<line51>if( unixFileLock(pFile, &lock)==(-1) ){\n<line52>tErrno = errno;\n<line53>rc = SQLITE_IOERR_UNLOCK;\n<line54>storeLastErrno(pFile, tErrno);\n<line55>goto end_unlock;\n<line56>}\n<line57>lock.l_type = F_RDLCK;\n<line58>lock.l_whence = SEEK_SET;\n<line59>lock.l_start = SHARED_FIRST;\n<line60>lock.l_len = divSize;\n<line61>if( unixFileLock(pFile, &lock)==(-1) ){\n<line62>tErrno = errno;\n<line63>rc = sqliteErrorFromPosixError(tErrno, SQLITE_IOERR_RDLOCK);\n<line64>if( IS_LOCK_ERROR(rc) ){\n<line65>storeLastErrno(pFile, tErrno);\n<line66>}\n<line67>goto end_unlock;\n<line68>}\n<line69>lock.l_type = F_UNLCK;\n<line70>lock.l_whence = SEEK_SET;\n<line71>lock.l_start = SHARED_FIRST+divSize;\n<line72>lock.l_len = SHARED_SIZE-divSize;\n<line73>if( unixFileLock(pFile, &lock)==(-1) ){\n<line74>tErrno = errno;\n<line75>rc = SQLITE_IOERR_UNLOCK;\n<line76>storeLastErrno(pFile, tErrno);\n<line77>goto end_unlock;\n<line78>}\n<line79>}else\n<line80>#endif /* defined(__APPLE__) && SQLITE_ENABLE_LOCKING_STYLE */\n<line81>{\n<line82>lock.l_type = F_RDLCK;\n<line83>lock.l_whence = SEEK_SET;\n<line84>lock.l_start = SHARED_FIRST;\n<line85>lock.l_len = SHARED_SIZE;\n<line86>if( unixFileLock(pFile, &lock) ){\n<line87>/* In theory, the call to unixFileLock() cannot fail because another\n<line88>** process is holding an incompatible lock. If it does, this\n<line89>** indicates that the other process is not following the locking\n<line90>** protocol. If this happens, return SQLITE_IOERR_RDLOCK. Returning\n<line91>** SQLITE_BUSY would confuse the upper layer (in practice it causes\n<line92>** an assert to fail). */\n<line93>rc = SQLITE_IOERR_RDLOCK;\n<line94>storeLastErrno(pFile, errno);\n<line95>goto end_unlock;\n<line96>}\n<line97>}\n<line98>}\n<line99>lock.l_type = F_UNLCK;\n<line100>lock.l_whence = SEEK_SET;\n<line101>lock.l_start = PENDING_BYTE;\n<line102>lock.l_len = 2L;  assert( PENDING_BYTE+1==RESERVED_BYTE );\n<line103>if( unixFileLock(pFile, &lock)==0 ){\n<line104>pInode->eFileLock = SHARED_LOCK;\n<line105>}else{\n<line106>rc = SQLITE_IOERR_UNLOCK;\n<line107>storeLastErrno(pFile, errno);\n<line108>goto end_unlock;\n<line109>}\n<line110>}\n<line111>if( eFileLock==NO_LOCK ){\n<line112>/* Decrement the shared lock counter.  Release the lock using an\n<line113>** OS call only when all threads in this same process have released\n<line114>** the lock.\n<line115>*/\n<line116>pInode->nShared--;\n<line117>if( pInode->nShared==0 ){\n<line118>lock.l_type = F_UNLCK;\n<line119>lock.l_whence = SEEK_SET;\n<line120>lock.l_start = lock.l_len = 0L;\n<line121>if( unixFileLock(pFile, &lock)==0 ){\n<line122>pInode->eFileLock = NO_LOCK;\n<line123>}else{\n<line124>rc = SQLITE_IOERR_UNLOCK;\n<line125>storeLastErrno(pFile, errno);\n<line126>pInode->eFileLock = NO_LOCK;\n<line127>pFile->eFileLock = NO_LOCK;\n<line128>}\n<line129>}\n<line130>/* Decrement the count of locks against this same file.  When the\n<line131>** count reaches zero, close any other file descriptors whose close\n<line132>** was deferred because of outstanding locks.\n<line133>*/\n<line134>pInode->nLock--;\n<line135>assert( pInode->nLock>=0 );\n<line136>if( pInode->nLock==0 ) closePendingFds(pFile);\n<line137>}\n<line138>end_unlock:\n<line139>sqlite3_mutex_leave(pInode->pLockMutex);\n<line140>if( rc==SQLITE_OK ){\n<line141>pFile->eFileLock = eFileLock;\n<line142>}\n<line143>return rc;\n<line144>}
----------------------------------------
Function: unixUnlock
Content: <line0>static int unixUnlock(sqlite3_file *id, int eFileLock){\n<line1>#if SQLITE_MAX_MMAP_SIZE>0\n<line2>assert( eFileLock==SHARED_LOCK || ((unixFile *)id)->nFetchOut==0 );\n<line3>#endif\n<line4>return posixUnlock(id, eFileLock, 0);\n<line5>}
----------------------------------------
Function: closeUnixFile
Content: <line0>static int closeUnixFile(sqlite3_file *id){\n<line1>unixFile *pFile = (unixFile*)id;\n<line2>#if SQLITE_MAX_MMAP_SIZE>0\n<line3>unixUnmapfile(pFile);\n<line4>#endif\n<line5>if( pFile->h>=0 ){\n<line6>robust_close(pFile, pFile->h, __LINE__);\n<line7>pFile->h = -1;\n<line8>}\n<line9>#if OS_VXWORKS\n<line10>if( pFile->pId ){\n<line11>if( pFile->ctrlFlags & UNIXFILE_DELETE ){\n<line12>osUnlink(pFile->pId->zCanonicalName);\n<line13>}\n<line14>vxworksReleaseFileId(pFile->pId);\n<line15>pFile->pId = 0;\n<line16>}\n<line17>#endif\n<line18>#ifdef SQLITE_UNLINK_AFTER_CLOSE\n<line19>if( pFile->ctrlFlags & UNIXFILE_DELETE ){\n<line20>osUnlink(pFile->zPath);\n<line21>sqlite3_free(*(char**)&pFile->zPath);\n<line22>pFile->zPath = 0;\n<line23>}\n<line24>#endif\n<line25>OSTRACE(("CLOSE   %-3d\n", pFile->h));\n<line26>OpenCounter(-1);\n<line27>sqlite3_free(pFile->pPreallocatedUnused);\n<line28>memset(pFile, 0, sizeof(unixFile));\n<line29>return SQLITE_OK;\n<line30>}
----------------------------------------
Function: unixClose
Content: <line0>static int unixClose(sqlite3_file *id){\n<line1>int rc = SQLITE_OK;\n<line2>unixFile *pFile = (unixFile *)id;\n<line3>unixInodeInfo *pInode = pFile->pInode;\n<line4>assert( pInode!=0 );\n<line5>verifyDbFile(pFile);\n<line6>unixUnlock(id, NO_LOCK);\n<line7>assert( unixFileMutexNotheld(pFile) );\n<line8>unixEnterMutex();\n<line9>/* unixFile.pInode is always valid here. Otherwise, a different close\n<line10>** routine (e.g. nolockClose()) would be called instead.\n<line11>*/\n<line12>assert( pFile->pInode->nLock>0 || pFile->pInode->bProcessLock==0 );\n<line13>sqlite3_mutex_enter(pInode->pLockMutex);\n<line14>if( pInode->nLock ){\n<line15>/* If there are outstanding locks, do not actually close the file just\n<line16>** yet because that would clear those locks.  Instead, add the file\n<line17>** descriptor to pInode->pUnused list.  It will be automatically closed\n<line18>** when the last lock is cleared.\n<line19>*/\n<line20>setPendingFd(pFile);\n<line21>}\n<line22>sqlite3_mutex_leave(pInode->pLockMutex);\n<line23>releaseInodeInfo(pFile);\n<line24>assert( pFile->pShm==0 );\n<line25>rc = closeUnixFile(id);\n<line26>unixLeaveMutex();\n<line27>return rc;\n<line28>}
----------------------------------------
Function: nolockCheckReservedLock
Content: <line0>static int nolockCheckReservedLock(sqlite3_file *NotUsed, int *pResOut){\n<line1>UNUSED_PARAMETER(NotUsed);\n<line2>*pResOut = 0;\n<line3>return SQLITE_OK;\n<line4>}
----------------------------------------
Function: nolockLock
Content: <line0>static int nolockLock(sqlite3_file *NotUsed, int NotUsed2){\n<line1>UNUSED_PARAMETER2(NotUsed, NotUsed2);\n<line2>return SQLITE_OK;\n<line3>}
----------------------------------------
Function: nolockUnlock
Content: <line0>static int nolockUnlock(sqlite3_file *NotUsed, int NotUsed2){\n<line1>UNUSED_PARAMETER2(NotUsed, NotUsed2);\n<line2>return SQLITE_OK;\n<line3>}
----------------------------------------
Function: nolockClose
Content: <line0>static int nolockClose(sqlite3_file *id) {\n<line1>return closeUnixFile(id);\n<line2>}
----------------------------------------
Function: dotlockCheckReservedLock
Content: <line0>static int dotlockCheckReservedLock(sqlite3_file *id, int *pResOut) {\n<line1>unixFile *pFile = (unixFile*)id;\n<line2>SimulateIOError( return SQLITE_IOERR_CHECKRESERVEDLOCK; );\n<line3>if( pFile->eFileLock>=SHARED_LOCK ){\n<line4>*pResOut = 0;\n<line5>}else{\n<line6>*pResOut = osAccess((const char*)pFile->lockingContext, 0)==0;\n<line7>}\n<line8>OSTRACE(("TEST WR-LOCK %d %d %d (dotlock)\n", pFile->h, 0, *pResOut));\n<line9>return SQLITE_OK;\n<line10>}
----------------------------------------
Function: dotlockLock
Content: <line0>static int dotlockLock(sqlite3_file *id, int eFileLock) {\n<line1>unixFile *pFile = (unixFile*)id;\n<line2>char *zLockFile = (char *)pFile->lockingContext;\n<line3>int rc = SQLITE_OK;\n<line4>/* If we have any lock, then the lock file already exists.  All we have\n<line5>** to do is adjust our internal record of the lock level.\n<line6>*/\n<line7>if( pFile->eFileLock > NO_LOCK ){\n<line8>pFile->eFileLock = eFileLock;\n<line9>/* Always update the timestamp on the old file */\n<line10>#ifdef HAVE_UTIME\n<line11>utime(zLockFile, NULL);\n<line12>#else\n<line13>utimes(zLockFile, NULL);\n<line14>#endif\n<line15>return SQLITE_OK;\n<line16>}\n<line17>/* grab an exclusive lock */\n<line18>rc = osMkdir(zLockFile, 0777);\n<line19>if( rc<0 ){\n<line20>/* failed to open/create the lock directory */\n<line21>int tErrno = errno;\n<line22>if( EEXIST == tErrno ){\n<line23>rc = SQLITE_BUSY;\n<line24>} else {\n<line25>rc = sqliteErrorFromPosixError(tErrno, SQLITE_IOERR_LOCK);\n<line26>if( rc!=SQLITE_BUSY ){\n<line27>storeLastErrno(pFile, tErrno);\n<line28>}\n<line29>}\n<line30>return rc;\n<line31>}\n<line32>/* got it, set the type and return ok */\n<line33>pFile->eFileLock = eFileLock;\n<line34>return rc;\n<line35>}
----------------------------------------
Function: dotlockUnlock
Content: <line0>static int dotlockUnlock(sqlite3_file *id, int eFileLock) {\n<line1>unixFile *pFile = (unixFile*)id;\n<line2>char *zLockFile = (char *)pFile->lockingContext;\n<line3>int rc;\n<line4>assert( pFile );\n<line5>OSTRACE(("UNLOCK  %d %d was %d pid=%d (dotlock)\n", pFile->h, eFileLock,\n<line6>pFile->eFileLock, osGetpid(0)));\n<line7>assert( eFileLock<=SHARED_LOCK );\n<line8>/* no-op if possible */\n<line9>if( pFile->eFileLock==eFileLock ){\n<line10>return SQLITE_OK;\n<line11>}\n<line12>/* To downgrade to shared, simply update our internal notion of the\n<line13>** lock state.  No need to mess with the file on disk.\n<line14>*/\n<line15>if( eFileLock==SHARED_LOCK ){\n<line16>pFile->eFileLock = SHARED_LOCK;\n<line17>return SQLITE_OK;\n<line18>}\n<line19>/* To fully unlock the database, delete the lock file */\n<line20>assert( eFileLock==NO_LOCK );\n<line21>rc = osRmdir(zLockFile);\n<line22>if( rc<0 ){\n<line23>int tErrno = errno;\n<line24>if( tErrno==ENOENT ){\n<line25>rc = SQLITE_OK;\n<line26>}else{\n<line27>rc = SQLITE_IOERR_UNLOCK;\n<line28>storeLastErrno(pFile, tErrno);\n<line29>}\n<line30>return rc;\n<line31>}\n<line32>pFile->eFileLock = NO_LOCK;\n<line33>return SQLITE_OK;\n<line34>}
----------------------------------------
Function: dotlockClose
Content: <line0>static int dotlockClose(sqlite3_file *id) {\n<line1>unixFile *pFile = (unixFile*)id;\n<line2>assert( id!=0 );\n<line3>dotlockUnlock(id, NO_LOCK);\n<line4>sqlite3_free(pFile->lockingContext);\n<line5>return closeUnixFile(id);\n<line6>}
----------------------------------------
Function: seekAndRead
Content: <line0>static int seekAndRead(unixFile *id, sqlite3_int64 offset, void *pBuf, int cnt){\n<line1>int got;\n<line2>int prior = 0;\n<line3>#if (!defined(USE_PREAD) && !defined(USE_PREAD64))\n<line4>i64 newOffset;\n<line5>#endif\n<line6>TIMER_START;\n<line7>assert( cnt==(cnt&0x1ffff) );\n<line8>assert( id->h>2 );\n<line9>do{\n<line10>#if defined(USE_PREAD)\n<line11>got = osPread(id->h, pBuf, cnt, offset);\n<line12>SimulateIOError( got = -1 );\n<line13>#elif defined(USE_PREAD64)\n<line14>got = osPread64(id->h, pBuf, cnt, offset);\n<line15>SimulateIOError( got = -1 );\n<line16>#else\n<line17>newOffset = lseek(id->h, offset, SEEK_SET);\n<line18>SimulateIOError( newOffset = -1 );\n<line19>if( newOffset<0 ){\n<line20>storeLastErrno((unixFile*)id, errno);\n<line21>return -1;\n<line22>}\n<line23>got = osRead(id->h, pBuf, cnt);\n<line24>#endif\n<line25>if( got==cnt ) break;\n<line26>if( got<0 ){\n<line27>if( errno==EINTR ){ got = 1; continue; }\n<line28>prior = 0;\n<line29>storeLastErrno((unixFile*)id,  errno);\n<line30>break;\n<line31>}else if( got>0 ){\n<line32>cnt -= got;\n<line33>offset += got;\n<line34>prior += got;\n<line35>pBuf = (void*)(got + (char*)pBuf);\n<line36>}\n<line37>}while( got>0 );\n<line38>TIMER_END;\n<line39>OSTRACE(("READ    %-3d %5d %7lld %llu\n",\n<line40>id->h, got+prior, offset-prior, TIMER_ELAPSED));\n<line41>return got+prior;\n<line42>}
----------------------------------------
Function: unixRead
Content: <line0>static int unixRead(\n<line1>sqlite3_file *id,\n<line2>void *pBuf,\n<line3>int amt,\n<line4>sqlite3_int64 offset\n<line5>){\n<line6>unixFile *pFile = (unixFile *)id;\n<line7>int got;\n<line8>assert( id );\n<line9>assert( offset>=0 );\n<line10>assert( amt>0 );\n<line11>/* If this is a database file (not a journal, super-journal or temp\n<line12>** file), the bytes in the locking range should never be read or written. */\n<line13>#if 0\n<line14>assert( pFile->pPreallocatedUnused==0\n<line15>|| offset>=PENDING_BYTE+512\n<line16>|| offset+amt<=PENDING_BYTE\n<line17>);\n<line18>#endif\n<line19>#if SQLITE_MAX_MMAP_SIZE>0\n<line20>/* Deal with as much of this read request as possible by transferring\n<line21>** data from the memory mapping using memcpy().  */\n<line22>if( offset<pFile->mmapSize ){\n<line23>if( offset+amt <= pFile->mmapSize ){\n<line24>memcpy(pBuf, &((u8 *)(pFile->pMapRegion))[offset], amt);\n<line25>return SQLITE_OK;\n<line26>}else{\n<line27>int nCopy = pFile->mmapSize - offset;\n<line28>memcpy(pBuf, &((u8 *)(pFile->pMapRegion))[offset], nCopy);\n<line29>pBuf = &((u8 *)pBuf)[nCopy];\n<line30>amt -= nCopy;\n<line31>offset += nCopy;\n<line32>}\n<line33>}\n<line34>#endif\n<line35>got = seekAndRead(pFile, offset, pBuf, amt);\n<line36>if( got==amt ){\n<line37>return SQLITE_OK;\n<line38>}else if( got<0 ){\n<line39>/* pFile->lastErrno has been set by seekAndRead().\n<line40>** Usually we return SQLITE_IOERR_READ here, though for some\n<line41>** kinds of errors we return SQLITE_IOERR_CORRUPTFS.  The\n<line42>** SQLITE_IOERR_CORRUPTFS will be converted into SQLITE_CORRUPT\n<line43>** prior to returning to the application by the sqlite3ApiExit()\n<line44>** routine.\n<line45>*/\n<line46>switch( pFile->lastErrno ){\n<line47>case ERANGE:\n<line48>case EIO:\n<line49>#ifdef ENXIO\n<line50>case ENXIO:\n<line51>#endif\n<line52>#ifdef EDEVERR\n<line53>case EDEVERR:\n<line54>#endif\n<line55>return SQLITE_IOERR_CORRUPTFS;\n<line56>}\n<line57>return SQLITE_IOERR_READ;\n<line58>}else{\n<line59>storeLastErrno(pFile, 0);   /* not a system error */\n<line60>/* Unread parts of the buffer must be zero-filled */\n<line61>memset(&((char*)pBuf)[got], 0, amt-got);\n<line62>return SQLITE_IOERR_SHORT_READ;\n<line63>}\n<line64>}
----------------------------------------
Function: seekAndWriteFd
Content: <line0>static int seekAndWriteFd(\n<line1>int fd,                         /* File descriptor to write to */\n<line2>i64 iOff,                       /* File offset to begin writing at */\n<line3>const void *pBuf,               /* Copy data from this buffer to the file */\n<line4>int nBuf,                       /* Size of buffer pBuf in bytes */\n<line5>int *piErrno                    /* OUT: Error number if error occurs */\n<line6>){\n<line7>int rc = 0;                     /* Value returned by system call */\n<line8>assert( nBuf==(nBuf&0x1ffff) );\n<line9>assert( fd>2 );\n<line10>assert( piErrno!=0 );\n<line11>nBuf &= 0x1ffff;\n<line12>TIMER_START;\n<line13>#if defined(USE_PREAD)\n<line14>do{ rc = (int)osPwrite(fd, pBuf, nBuf, iOff); }while( rc<0 && errno==EINTR );\n<line15>#elif defined(USE_PREAD64)\n<line16>do{ rc = (int)osPwrite64(fd, pBuf, nBuf, iOff);}while( rc<0 && errno==EINTR);\n<line17>#else\n<line18>do{\n<line19>i64 iSeek = lseek(fd, iOff, SEEK_SET);\n<line20>SimulateIOError( iSeek = -1 );\n<line21>if( iSeek<0 ){\n<line22>rc = -1;\n<line23>break;\n<line24>}\n<line25>rc = osWrite(fd, pBuf, nBuf);\n<line26>}while( rc<0 && errno==EINTR );\n<line27>#endif\n<line28>TIMER_END;\n<line29>OSTRACE(("WRITE   %-3d %5d %7lld %llu\n", fd, rc, iOff, TIMER_ELAPSED));\n<line30>if( rc<0 ) *piErrno = errno;\n<line31>return rc;\n<line32>}
----------------------------------------
Function: seekAndWrite
Content: <line0>static int seekAndWrite(unixFile *id, i64 offset, const void *pBuf, int cnt){\n<line1>return seekAndWriteFd(id->h, offset, pBuf, cnt, &id->lastErrno);\n<line2>}
----------------------------------------
Function: unixWrite
Content: <line0>static int unixWrite(\n<line1>sqlite3_file *id,\n<line2>const void *pBuf,\n<line3>int amt,\n<line4>sqlite3_int64 offset\n<line5>){\n<line6>unixFile *pFile = (unixFile*)id;\n<line7>int wrote = 0;\n<line8>assert( id );\n<line9>assert( amt>0 );\n<line10>/* If this is a database file (not a journal, super-journal or temp\n<line11>** file), the bytes in the locking range should never be read or written. */\n<line12>#if 0\n<line13>assert( pFile->pPreallocatedUnused==0\n<line14>|| offset>=PENDING_BYTE+512\n<line15>|| offset+amt<=PENDING_BYTE\n<line16>);\n<line17>#endif\n<line18>#ifdef SQLITE_DEBUG\n<line19>/* If we are doing a normal write to a database file (as opposed to\n<line20>** doing a hot-journal rollback or a write to some file other than a\n<line21>** normal database file) then record the fact that the database\n<line22>** has changed.  If the transaction counter is modified, record that\n<line23>** fact too.\n<line24>*/\n<line25>if( pFile->inNormalWrite ){\n<line26>pFile->dbUpdate = 1;  /* The database has been modified */\n<line27>if( offset<=24 && offset+amt>=27 ){\n<line28>int rc;\n<line29>char oldCntr[4];\n<line30>SimulateIOErrorBenign(1);\n<line31>rc = seekAndRead(pFile, 24, oldCntr, 4);\n<line32>SimulateIOErrorBenign(0);\n<line33>if( rc!=4 || memcmp(oldCntr, &((char*)pBuf)[24-offset], 4)!=0 ){\n<line34>pFile->transCntrChng = 1;  /* The transaction counter has changed */\n<line35>}\n<line36>}\n<line37>}\n<line38>#endif\n<line39>#if defined(SQLITE_MMAP_READWRITE) && SQLITE_MAX_MMAP_SIZE>0\n<line40>/* Deal with as much of this write request as possible by transferring\n<line41>** data from the memory mapping using memcpy().  */\n<line42>if( offset<pFile->mmapSize ){\n<line43>if( offset+amt <= pFile->mmapSize ){\n<line44>memcpy(&((u8 *)(pFile->pMapRegion))[offset], pBuf, amt);\n<line45>return SQLITE_OK;\n<line46>}else{\n<line47>int nCopy = pFile->mmapSize - offset;\n<line48>memcpy(&((u8 *)(pFile->pMapRegion))[offset], pBuf, nCopy);\n<line49>pBuf = &((u8 *)pBuf)[nCopy];\n<line50>amt -= nCopy;\n<line51>offset += nCopy;\n<line52>}\n<line53>}\n<line54>#endif\n<line55>while( (wrote = seekAndWrite(pFile, offset, pBuf, amt))<amt && wrote>0 ){\n<line56>amt -= wrote;\n<line57>offset += wrote;\n<line58>pBuf = &((char*)pBuf)[wrote];\n<line59>}\n<line60>SimulateIOError(( wrote=(-1), amt=1 ));\n<line61>SimulateDiskfullError(( wrote=0, amt=1 ));\n<line62>if( amt>wrote ){\n<line63>if( wrote<0 && pFile->lastErrno!=ENOSPC ){\n<line64>/* lastErrno set by seekAndWrite */\n<line65>return SQLITE_IOERR_WRITE;\n<line66>}else{\n<line67>storeLastErrno(pFile, 0); /* not a system error */\n<line68>return SQLITE_FULL;\n<line69>}\n<line70>}\n<line71>return SQLITE_OK;\n<line72>}
----------------------------------------
Function: full_fsync
Content: <line0>static int full_fsync(int fd, int fullSync, int dataOnly){\n<line1>int rc;\n<line2>/* The following "ifdef/elif/else/" block has the same structure as\n<line3>** the one below. It is replicated here solely to avoid cluttering\n<line4>** up the real code with the UNUSED_PARAMETER() macros.\n<line5>*/\n<line6>#ifdef SQLITE_NO_SYNC\n<line7>UNUSED_PARAMETER(fd);\n<line8>UNUSED_PARAMETER(fullSync);\n<line9>UNUSED_PARAMETER(dataOnly);\n<line10>#elif HAVE_FULLFSYNC\n<line11>UNUSED_PARAMETER(dataOnly);\n<line12>#else\n<line13>UNUSED_PARAMETER(fullSync);\n<line14>UNUSED_PARAMETER(dataOnly);\n<line15>#endif\n<line16>/* Record the number of times that we do a normal fsync() and\n<line17>** FULLSYNC.  This is used during testing to verify that this procedure\n<line18>** gets called with the correct arguments.\n<line19>*/\n<line20>#ifdef SQLITE_TEST\n<line21>if( fullSync ) sqlite3_fullsync_count++;\n<line22>sqlite3_sync_count++;\n<line23>#endif\n<line24>/* If we compiled with the SQLITE_NO_SYNC flag, then syncing is a\n<line25>** no-op.  But go ahead and call fstat() to validate the file\n<line26>** descriptor as we need a method to provoke a failure during\n<line27>** coverage testing.\n<line28>*/\n<line29>#ifdef SQLITE_NO_SYNC\n<line30>{\n<line31>struct stat buf;\n<line32>rc = osFstat(fd, &buf);\n<line33>}\n<line34>#elif HAVE_FULLFSYNC\n<line35>if( fullSync ){\n<line36>rc = osFcntl(fd, F_FULLFSYNC, 0);\n<line37>}else{\n<line38>rc = 1;\n<line39>}\n<line40>/* If the FULLFSYNC failed, fall back to attempting an fsync().\n<line41>** It shouldn't be possible for fullfsync to fail on the local\n<line42>** file system (on OSX), so failure indicates that FULLFSYNC\n<line43>** isn't supported for this file system. So, attempt an fsync\n<line44>** and (for now) ignore the overhead of a superfluous fcntl call.\n<line45>** It'd be better to detect fullfsync support once and avoid\n<line46>** the fcntl call every time sync is called.\n<line47>*/\n<line48>if( rc ) rc = fsync(fd);\n<line49>#elif defined(__APPLE__)\n<line50>/* fdatasync() on HFS+ doesn't yet flush the file size if it changed correctly\n<line51>** so currently we default to the macro that redefines fdatasync to fsync\n<line52>*/\n<line53>rc = fsync(fd);\n<line54>#else\n<line55>rc = fdatasync(fd);\n<line56>#if OS_VXWORKS\n<line57>if( rc==-1 && errno==ENOTSUP ){\n<line58>rc = fsync(fd);\n<line59>}\n<line60>#endif /* OS_VXWORKS */\n<line61>#endif /* ifdef SQLITE_NO_SYNC elif HAVE_FULLFSYNC */\n<line62>if( OS_VXWORKS && rc!= -1 ){\n<line63>rc = 0;\n<line64>}\n<line65>return rc;\n<line66>}
----------------------------------------
Function: openDirectory
Content: <line0>static int openDirectory(const char *zFilename, int *pFd){\n<line1>int ii;\n<line2>int fd = -1;\n<line3>char zDirname[MAX_PATHNAME+1];\n<line4>sqlite3_snprintf(MAX_PATHNAME, zDirname, "%s", zFilename);\n<line5>for(ii=(int)strlen(zDirname); ii>0 && zDirname[ii]!='/'; ii--);\n<line6>if( ii>0 ){\n<line7>zDirname[ii] = '\0';\n<line8>}else{\n<line9>if( zDirname[0]!='/' ) zDirname[0] = '.';\n<line10>zDirname[1] = 0;\n<line11>}\n<line12>fd = robust_open(zDirname, O_RDONLY|O_BINARY, 0);\n<line13>if( fd>=0 ){\n<line14>OSTRACE(("OPENDIR %-3d %s\n", fd, zDirname));\n<line15>}\n<line16>*pFd = fd;\n<line17>if( fd>=0 ) return SQLITE_OK;\n<line18>return unixLogError(SQLITE_CANTOPEN_BKPT, "openDirectory", zDirname);\n<line19>}
----------------------------------------
Function: unixSync
Content: <line0>static int unixSync(sqlite3_file *id, int flags){\n<line1>int rc;\n<line2>unixFile *pFile = (unixFile*)id;\n<line3>int isDataOnly = (flags&SQLITE_SYNC_DATAONLY);\n<line4>int isFullsync = (flags&0x0F)==SQLITE_SYNC_FULL;\n<line5>/* Check that one of SQLITE_SYNC_NORMAL or FULL was passed */\n<line6>assert((flags&0x0F)==SQLITE_SYNC_NORMAL\n<line7>|| (flags&0x0F)==SQLITE_SYNC_FULL\n<line8>);\n<line9>/* Unix cannot, but some systems may return SQLITE_FULL from here. This\n<line10>** line is to test that doing so does not cause any problems.\n<line11>*/\n<line12>SimulateDiskfullError( return SQLITE_FULL );\n<line13>assert( pFile );\n<line14>OSTRACE(("SYNC    %-3d\n", pFile->h));\n<line15>rc = full_fsync(pFile->h, isFullsync, isDataOnly);\n<line16>SimulateIOError( rc=1 );\n<line17>if( rc ){\n<line18>storeLastErrno(pFile, errno);\n<line19>return unixLogError(SQLITE_IOERR_FSYNC, "full_fsync", pFile->zPath);\n<line20>}\n<line21>/* Also fsync the directory containing the file if the DIRSYNC flag\n<line22>** is set.  This is a one-time occurrence.  Many systems (examples: AIX)\n<line23>** are unable to fsync a directory, so ignore errors on the fsync.\n<line24>*/\n<line25>if( pFile->ctrlFlags & UNIXFILE_DIRSYNC ){\n<line26>int dirfd;\n<line27>OSTRACE(("DIRSYNC %s (have_fullfsync=%d fullsync=%d)\n", pFile->zPath,\n<line28>HAVE_FULLFSYNC, isFullsync));\n<line29>rc = osOpenDirectory(pFile->zPath, &dirfd);\n<line30>if( rc==SQLITE_OK ){\n<line31>full_fsync(dirfd, 0, 0);\n<line32>robust_close(pFile, dirfd, __LINE__);\n<line33>}else{\n<line34>assert( rc==SQLITE_CANTOPEN );\n<line35>rc = SQLITE_OK;\n<line36>}\n<line37>pFile->ctrlFlags &= ~UNIXFILE_DIRSYNC;\n<line38>}\n<line39>return rc;\n<line40>}
----------------------------------------
Function: unixTruncate
Content: <line0>static int unixTruncate(sqlite3_file *id, i64 nByte){\n<line1>unixFile *pFile = (unixFile *)id;\n<line2>int rc;\n<line3>assert( pFile );\n<line4>SimulateIOError( return SQLITE_IOERR_TRUNCATE );\n<line5>/* If the user has configured a chunk-size for this file, truncate the\n<line6>** file so that it consists of an integer number of chunks (i.e. the\n<line7>** actual file size after the operation may be larger than the requested\n<line8>** size).\n<line9>*/\n<line10>if( pFile->szChunk>0 ){\n<line11>nByte = ((nByte + pFile->szChunk - 1)/pFile->szChunk) * pFile->szChunk;\n<line12>}\n<line13>rc = robust_ftruncate(pFile->h, nByte);\n<line14>if( rc ){\n<line15>storeLastErrno(pFile, errno);\n<line16>return unixLogError(SQLITE_IOERR_TRUNCATE, "ftruncate", pFile->zPath);\n<line17>}else{\n<line18>#ifdef SQLITE_DEBUG\n<line19>/* If we are doing a normal write to a database file (as opposed to\n<line20>** doing a hot-journal rollback or a write to some file other than a\n<line21>** normal database file) and we truncate the file to zero length,\n<line22>** that effectively updates the change counter.  This might happen\n<line23>** when restoring a database using the backup API from a zero-length\n<line24>** source.\n<line25>*/\n<line26>if( pFile->inNormalWrite && nByte==0 ){\n<line27>pFile->transCntrChng = 1;\n<line28>}\n<line29>#endif\n<line30>#if SQLITE_MAX_MMAP_SIZE>0\n<line31>/* If the file was just truncated to a size smaller than the currently\n<line32>** mapped region, reduce the effective mapping size as well. SQLite will\n<line33>** use read() and write() to access data beyond this point from now on.\n<line34>*/\n<line35>if( nByte<pFile->mmapSize ){\n<line36>pFile->mmapSize = nByte;\n<line37>}\n<line38>#endif\n<line39>return SQLITE_OK;\n<line40>}\n<line41>}
----------------------------------------
Function: unixFileSize
Content: <line0>static int unixFileSize(sqlite3_file *id, i64 *pSize){\n<line1>int rc;\n<line2>struct stat buf;\n<line3>assert( id );\n<line4>rc = osFstat(((unixFile*)id)->h, &buf);\n<line5>SimulateIOError( rc=1 );\n<line6>if( rc!=0 ){\n<line7>storeLastErrno((unixFile*)id, errno);\n<line8>return SQLITE_IOERR_FSTAT;\n<line9>}\n<line10>*pSize = buf.st_size;\n<line11>/* When opening a zero-size database, the findInodeInfo() procedure\n<line12>** writes a single byte into that file in order to work around a bug\n<line13>** in the OS-X msdos filesystem.  In order to avoid problems with upper\n<line14>** layers, we need to report this file size as zero even though it is\n<line15>** really 1.   Ticket #3260.\n<line16>*/\n<line17>if( *pSize==1 ) *pSize = 0;\n<line18>return SQLITE_OK;\n<line19>}
----------------------------------------
Function: fcntlSizeHint
Content: <line0>static int fcntlSizeHint(unixFile *pFile, i64 nByte){\n<line1>if( pFile->szChunk>0 ){\n<line2>i64 nSize;                    /* Required file size */\n<line3>struct stat buf;              /* Used to hold return values of fstat() */\n<line4>if( osFstat(pFile->h, &buf) ){\n<line5>return SQLITE_IOERR_FSTAT;\n<line6>}\n<line7>nSize = ((nByte+pFile->szChunk-1) / pFile->szChunk) * pFile->szChunk;\n<line8>if( nSize>(i64)buf.st_size ){\n<line9>#if defined(HAVE_POSIX_FALLOCATE) && HAVE_POSIX_FALLOCATE\n<line10>/* The code below is handling the return value of osFallocate()\n<line11>** correctly. posix_fallocate() is defined to "returns zero on success,\n<line12>** or an error number on  failure". See the manpage for details. */\n<line13>int err;\n<line14>do{\n<line15>err = osFallocate(pFile->h, buf.st_size, nSize-buf.st_size);\n<line16>}while( err==EINTR );\n<line17>if( err && err!=EINVAL ) return SQLITE_IOERR_WRITE;\n<line18>#else\n<line19>/* If the OS does not have posix_fallocate(), fake it. Write a\n<line20>** single byte to the last byte in each block that falls entirely\n<line21>** within the extended region. Then, if required, a single byte\n<line22>** at offset (nSize-1), to set the size of the file correctly.\n<line23>** This is a similar technique to that used by glibc on systems\n<line24>** that do not have a real fallocate() call.\n<line25>*/\n<line26>int nBlk = buf.st_blksize;  /* File-system block size */\n<line27>int nWrite = 0;             /* Number of bytes written by seekAndWrite */\n<line28>i64 iWrite;                 /* Next offset to write to */\n<line29>iWrite = (buf.st_size/nBlk)*nBlk + nBlk - 1;\n<line30>assert( iWrite>=buf.st_size );\n<line31>assert( ((iWrite+1)%nBlk)==0 );\n<line32>for(/*no-op*/; iWrite<nSize+nBlk-1; iWrite+=nBlk ){\n<line33>if( iWrite>=nSize ) iWrite = nSize - 1;\n<line34>nWrite = seekAndWrite(pFile, iWrite, "", 1);\n<line35>if( nWrite!=1 ) return SQLITE_IOERR_WRITE;\n<line36>}\n<line37>#endif\n<line38>}\n<line39>}\n<line40>#if SQLITE_MAX_MMAP_SIZE>0\n<line41>if( pFile->mmapSizeMax>0 && nByte>pFile->mmapSize ){\n<line42>int rc;\n<line43>if( pFile->szChunk<=0 ){\n<line44>if( robust_ftruncate(pFile->h, nByte) ){\n<line45>storeLastErrno(pFile, errno);\n<line46>return unixLogError(SQLITE_IOERR_TRUNCATE, "ftruncate", pFile->zPath);\n<line47>}\n<line48>}\n<line49>rc = unixMapfile(pFile, nByte);\n<line50>return rc;\n<line51>}\n<line52>#endif\n<line53>return SQLITE_OK;\n<line54>}
----------------------------------------
Function: unixModeBit
Content: <line0>static void unixModeBit(unixFile *pFile, unsigned char mask, int *pArg){\n<line1>if( *pArg<0 ){\n<line2>*pArg = (pFile->ctrlFlags & mask)!=0;\n<line3>}else if( (*pArg)==0 ){\n<line4>pFile->ctrlFlags &= ~mask;\n<line5>}else{\n<line6>pFile->ctrlFlags |= mask;\n<line7>}\n<line8>}
----------------------------------------
Function: unixFileControl
Content: <line0>static int unixFileControl(sqlite3_file *id, int op, void *pArg){\n<line1>unixFile *pFile = (unixFile*)id;\n<line2>switch( op ){\n<line3>#if defined(__linux__) && defined(SQLITE_ENABLE_BATCH_ATOMIC_WRITE)\n<line4>case SQLITE_FCNTL_BEGIN_ATOMIC_WRITE: {\n<line5>int rc = osIoctl(pFile->h, F2FS_IOC_START_ATOMIC_WRITE);\n<line6>return rc ? SQLITE_IOERR_BEGIN_ATOMIC : SQLITE_OK;\n<line7>}\n<line8>case SQLITE_FCNTL_COMMIT_ATOMIC_WRITE: {\n<line9>int rc = osIoctl(pFile->h, F2FS_IOC_COMMIT_ATOMIC_WRITE);\n<line10>return rc ? SQLITE_IOERR_COMMIT_ATOMIC : SQLITE_OK;\n<line11>}\n<line12>case SQLITE_FCNTL_ROLLBACK_ATOMIC_WRITE: {\n<line13>int rc = osIoctl(pFile->h, F2FS_IOC_ABORT_VOLATILE_WRITE);\n<line14>return rc ? SQLITE_IOERR_ROLLBACK_ATOMIC : SQLITE_OK;\n<line15>}\n<line16>#endif /* __linux__ && SQLITE_ENABLE_BATCH_ATOMIC_WRITE */\n<line17>case SQLITE_FCNTL_NULL_IO: {\n<line18>osClose(pFile->h);\n<line19>pFile->h = -1;\n<line20>return SQLITE_OK;\n<line21>}\n<line22>case SQLITE_FCNTL_LOCKSTATE: {\n<line23>*(int*)pArg = pFile->eFileLock;\n<line24>return SQLITE_OK;\n<line25>}\n<line26>case SQLITE_FCNTL_LAST_ERRNO: {\n<line27>*(int*)pArg = pFile->lastErrno;\n<line28>return SQLITE_OK;\n<line29>}\n<line30>case SQLITE_FCNTL_CHUNK_SIZE: {\n<line31>pFile->szChunk = *(int *)pArg;\n<line32>return SQLITE_OK;\n<line33>}\n<line34>case SQLITE_FCNTL_SIZE_HINT: {\n<line35>int rc;\n<line36>SimulateIOErrorBenign(1);\n<line37>rc = fcntlSizeHint(pFile, *(i64 *)pArg);\n<line38>SimulateIOErrorBenign(0);\n<line39>return rc;\n<line40>}\n<line41>case SQLITE_FCNTL_PERSIST_WAL: {\n<line42>unixModeBit(pFile, UNIXFILE_PERSIST_WAL, (int*)pArg);\n<line43>return SQLITE_OK;\n<line44>}\n<line45>case SQLITE_FCNTL_POWERSAFE_OVERWRITE: {\n<line46>unixModeBit(pFile, UNIXFILE_PSOW, (int*)pArg);\n<line47>return SQLITE_OK;\n<line48>}\n<line49>case SQLITE_FCNTL_VFSNAME: {\n<line50>*(char**)pArg = sqlite3_mprintf("%s", pFile->pVfs->zName);\n<line51>return SQLITE_OK;\n<line52>}\n<line53>case SQLITE_FCNTL_TEMPFILENAME: {\n<line54>char *zTFile = sqlite3_malloc64( pFile->pVfs->mxPathname );\n<line55>if( zTFile ){\n<line56>unixGetTempname(pFile->pVfs->mxPathname, zTFile);\n<line57>*(char**)pArg = zTFile;\n<line58>}\n<line59>return SQLITE_OK;\n<line60>}\n<line61>case SQLITE_FCNTL_HAS_MOVED: {\n<line62>*(int*)pArg = fileHasMoved(pFile);\n<line63>return SQLITE_OK;\n<line64>}\n<line65>#ifdef SQLITE_ENABLE_SETLK_TIMEOUT\n<line66>case SQLITE_FCNTL_LOCK_TIMEOUT: {\n<line67>int iOld = pFile->iBusyTimeout;\n<line68>int iNew = *(int*)pArg;\n<line69>#if SQLITE_ENABLE_SETLK_TIMEOUT==1\n<line70>pFile->iBusyTimeout = iNew<0 ? 0x7FFFFFFF : (unsigned)iNew;\n<line71>#elif SQLITE_ENABLE_SETLK_TIMEOUT==2\n<line72>pFile->iBusyTimeout = !!(*(int*)pArg);\n<line73>#else\n<line74># error "SQLITE_ENABLE_SETLK_TIMEOUT must be set to 1 or 2"\n<line75>#endif\n<line76>*(int*)pArg = iOld;\n<line77>return SQLITE_OK;\n<line78>}\n<line79>case SQLITE_FCNTL_BLOCK_ON_CONNECT: {\n<line80>int iNew = *(int*)pArg;\n<line81>pFile->bBlockOnConnect = iNew;\n<line82>return SQLITE_OK;\n<line83>}\n<line84>#endif /* SQLITE_ENABLE_SETLK_TIMEOUT */\n<line85>#if SQLITE_MAX_MMAP_SIZE>0\n<line86>case SQLITE_FCNTL_MMAP_SIZE: {\n<line87>i64 newLimit = *(i64*)pArg;\n<line88>int rc = SQLITE_OK;\n<line89>if( newLimit>sqlite3GlobalConfig.mxMmap ){\n<line90>newLimit = sqlite3GlobalConfig.mxMmap;\n<line91>}\n<line92>/* The value of newLimit may be eventually cast to (size_t) and passed\n<line93>** to mmap(). Restrict its value to 2GB if (size_t) is not at least a\n<line94>** 64-bit type. */\n<line95>if( newLimit>0 && sizeof(size_t)<8 ){\n<line96>newLimit = (newLimit & 0x7FFFFFFF);\n<line97>}\n<line98>*(i64*)pArg = pFile->mmapSizeMax;\n<line99>if( newLimit>=0 && newLimit!=pFile->mmapSizeMax && pFile->nFetchOut==0 ){\n<line100>pFile->mmapSizeMax = newLimit;\n<line101>if( pFile->mmapSize>0 ){\n<line102>unixUnmapfile(pFile);\n<line103>rc = unixMapfile(pFile, -1);\n<line104>}\n<line105>}\n<line106>return rc;\n<line107>}\n<line108>#endif\n<line109>#ifdef SQLITE_DEBUG\n<line110>/* The pager calls this method to signal that it has done\n<line111>** a rollback and that the database is therefore unchanged and\n<line112>** it hence it is OK for the transaction change counter to be\n<line113>** unchanged.\n<line114>*/\n<line115>case SQLITE_FCNTL_DB_UNCHANGED: {\n<line116>((unixFile*)id)->dbUpdate = 0;\n<line117>return SQLITE_OK;\n<line118>}\n<line119>#endif\n<line120>#if SQLITE_ENABLE_LOCKING_STYLE && defined(__APPLE__)\n<line121>case SQLITE_FCNTL_SET_LOCKPROXYFILE:\n<line122>case SQLITE_FCNTL_GET_LOCKPROXYFILE: {\n<line123>return proxyFileControl(id,op,pArg);\n<line124>}\n<line125>#endif /* SQLITE_ENABLE_LOCKING_STYLE && defined(__APPLE__) */\n<line126>case SQLITE_FCNTL_EXTERNAL_READER: {\n<line127>#if !defined(SQLITE_WASI) && !defined(SQLITE_OMIT_WAL)\n<line128>return unixFcntlExternalReader((unixFile*)id, (int*)pArg);\n<line129>#else\n<line130>*(int*)pArg = 0;\n<line131>return SQLITE_OK;\n<line132>#endif\n<line133>}\n<line134>#if defined(SQLITE_DEBUG) || defined(SQLITE_ENABLE_FILESTAT)\n<line135>case SQLITE_FCNTL_FILESTAT: {\n<line136>sqlite3_str *pStr = (sqlite3_str*)pArg;\n<line137>char aLck[16];\n<line138>unixInodeInfo *pInode;\n<line139>static const char *azLock[] = { "SHARED", "RESERVED",\n<line140>"PENDING", "EXCLUSIVE" };\n<line141>sqlite3_str_appendf(pStr, "{\"h\":%d", pFile->h);\n<line142>sqlite3_str_appendf(pStr, ",\"vfs\":\"%s\"", pFile->pVfs->zName);\n<line143>if( pFile->eFileLock ){\n<line144>sqlite3_str_appendf(pStr, ",\"eFileLock\":\"%s\"",\n<line145>azLock[pFile->eFileLock-1]);\n<line146>if( unixPosixAdvisoryLocks(pFile->h, aLck)==SQLITE_OK ){\n<line147>sqlite3_str_appendf(pStr, ",\"pal\":\"%s\"", aLck);\n<line148>}\n<line149>}\n<line150>unixEnterMutex();\n<line151>if( pFile->pShm ){\n<line152>sqlite3_str_appendall(pStr, ",\"shm\":");\n<line153>unixDescribeShm(pStr, pFile->pShm);\n<line154>}\n<line155>#if SQLITE_MAX_MMAP_SIZE>0\n<line156>if( pFile->mmapSize ){\n<line157>sqlite3_str_appendf(pStr, ",\"mmapSize\":%lld", pFile->mmapSize);\n<line158>sqlite3_str_appendf(pStr, ",\"nFetchOut\":%d", pFile->nFetchOut);\n<line159>}\n<line160>#endif\n<line161>if( (pInode = pFile->pInode)!=0 ){\n<line162>sqlite3_str_appendf(pStr, ",\"inode\":{\"nRef\":%d",pInode->nRef);\n<line163>sqlite3_mutex_enter(pInode->pLockMutex);\n<line164>sqlite3_str_appendf(pStr, ",\"nShared\":%d", pInode->nShared);\n<line165>if( pInode->eFileLock ){\n<line166>sqlite3_str_appendf(pStr, ",\"eFileLock\":\"%s\"",\n<line167>azLock[pInode->eFileLock-1]);\n<line168>}\n<line169>if( pInode->pUnused ){\n<line170>char cSep = '[';\n<line171>UnixUnusedFd *pUFd = pFile->pInode->pUnused;\n<line172>sqlite3_str_appendall(pStr, ",\"unusedFd\":");\n<line173>while( pUFd ){\n<line174>sqlite3_str_appendf(pStr, "%c{\"fd\":%d,\"flags\":%d",\n<line175>cSep, pUFd->fd, pUFd->flags);\n<line176>cSep = ',';\n<line177>if( unixPosixAdvisoryLocks(pUFd->fd, aLck)==SQLITE_OK ){\n<line178>sqlite3_str_appendf(pStr, ",\"pal\":\"%s\"", aLck);\n<line179>}\n<line180>sqlite3_str_append(pStr, "}", 1);\n<line181>pUFd = pUFd->pNext;\n<line182>}\n<line183>sqlite3_str_append(pStr, "]", 1);\n<line184>}\n<line185>sqlite3_mutex_leave(pInode->pLockMutex);\n<line186>sqlite3_str_append(pStr, "}", 1);\n<line187>}\n<line188>unixLeaveMutex();\n<line189>sqlite3_str_append(pStr, "}", 1);\n<line190>return SQLITE_OK;\n<line191>}\n<line192>#endif /* SQLITE_DEBUG || SQLITE_ENABLE_FILESTAT */\n<line193>}\n<line194>return SQLITE_NOTFOUND;\n<line195>}
----------------------------------------
Function: setDeviceCharacteristics
Content: <line0>static void setDeviceCharacteristics(unixFile *pFd){\n<line1>assert( pFd->deviceCharacteristics==0 || pFd->sectorSize!=0 );\n<line2>if( pFd->sectorSize==0 ){\n<line3>#if defined(__linux__) && defined(SQLITE_ENABLE_BATCH_ATOMIC_WRITE)\n<line4>int res;\n<line5>u32 f = 0;\n<line6>/* Check for support for F2FS atomic batch writes. */\n<line7>res = osIoctl(pFd->h, F2FS_IOC_GET_FEATURES, &f);\n<line8>if( res==0 && (f & F2FS_FEATURE_ATOMIC_WRITE) ){\n<line9>pFd->deviceCharacteristics = SQLITE_IOCAP_BATCH_ATOMIC;\n<line10>}\n<line11>#endif /* __linux__ && SQLITE_ENABLE_BATCH_ATOMIC_WRITE */\n<line12>/* Set the POWERSAFE_OVERWRITE flag if requested. */\n<line13>if( pFd->ctrlFlags & UNIXFILE_PSOW ){\n<line14>pFd->deviceCharacteristics |= SQLITE_IOCAP_POWERSAFE_OVERWRITE;\n<line15>}\n<line16>pFd->deviceCharacteristics |= SQLITE_IOCAP_SUBPAGE_READ;\n<line17>pFd->sectorSize = SQLITE_DEFAULT_SECTOR_SIZE;\n<line18>}\n<line19>}
----------------------------------------
Function: unixSectorSize
Content: <line0>static int unixSectorSize(sqlite3_file *id){\n<line1>unixFile *pFd = (unixFile*)id;\n<line2>setDeviceCharacteristics(pFd);\n<line3>return pFd->sectorSize;\n<line4>}
----------------------------------------
Function: unixDeviceCharacteristics
Content: <line0>static int unixDeviceCharacteristics(sqlite3_file *id){\n<line1>unixFile *pFd = (unixFile*)id;\n<line2>setDeviceCharacteristics(pFd);\n<line3>return pFd->deviceCharacteristics;\n<line4>}
----------------------------------------
Function: unixGetpagesize
Content: <line0>static int unixGetpagesize(void){\n<line1>#if OS_VXWORKS\n<line2>return 1024;\n<line3>#elif defined(_BSD_SOURCE)\n<line4>return getpagesize();\n<line5>#else\n<line6>return (int)sysconf(_SC_PAGESIZE);\n<line7>#endif\n<line8>}
----------------------------------------
Function: unixFcntlExternalReader
Content: <line0>static int unixFcntlExternalReader(unixFile *pFile, int *piOut){\n<line1>int rc = SQLITE_OK;\n<line2>*piOut = 0;\n<line3>if( pFile->pShm){\n<line4>unixShmNode *pShmNode = pFile->pShm->pShmNode;\n<line5>struct flock f;\n<line6>memset(&f, 0, sizeof(f));\n<line7>f.l_type = F_WRLCK;\n<line8>f.l_whence = SEEK_SET;\n<line9>f.l_start = UNIX_SHM_BASE + 3;\n<line10>f.l_len = SQLITE_SHM_NLOCK - 3;\n<line11>sqlite3_mutex_enter(pShmNode->pShmMutex);\n<line12>if( osFcntl(pShmNode->hShm, F_GETLK, &f)<0 ){\n<line13>rc = SQLITE_IOERR_LOCK;\n<line14>}else{\n<line15>*piOut = (f.l_type!=F_UNLCK);\n<line16>}\n<line17>sqlite3_mutex_leave(pShmNode->pShmMutex);\n<line18>}\n<line19>return rc;\n<line20>}
----------------------------------------
Function: unixIsSharingShmNode
Content: <line0>static int unixIsSharingShmNode(unixFile *pFile){\n<line1>int rc;\n<line2>unixShmNode *pShmNode;\n<line3>if( pFile->pShm==0 ) return 0;\n<line4>if( pFile->ctrlFlags & UNIXFILE_EXCL ) return 0;\n<line5>pShmNode = pFile->pShm->pShmNode;\n<line6>rc = 1;\n<line7>unixEnterMutex();\n<line8>if( ALWAYS(pShmNode->nRef==1) ){\n<line9>struct flock lock;\n<line10>lock.l_whence = SEEK_SET;\n<line11>lock.l_start = UNIX_SHM_DMS;\n<line12>lock.l_len = 1;\n<line13>lock.l_type = F_WRLCK;\n<line14>osFcntl(pShmNode->hShm, F_GETLK, &lock);\n<line15>if( lock.l_type==F_UNLCK ){\n<line16>rc = 0;\n<line17>}\n<line18>}\n<line19>unixLeaveMutex();\n<line20>return rc;\n<line21>}
----------------------------------------
Function: unixShmSystemLock
Content: <line0>static int unixShmSystemLock(\n<line1>unixFile *pFile,       /* Open connection to the WAL file */\n<line2>int lockType,          /* F_UNLCK, F_RDLCK, or F_WRLCK */\n<line3>int ofst,              /* First byte of the locking range */\n<line4>int n                  /* Number of bytes to lock */\n<line5>){\n<line6>unixShmNode *pShmNode; /* Apply locks to this open shared-memory segment */\n<line7>struct flock f;        /* The posix advisory locking structure */\n<line8>int rc = SQLITE_OK;    /* Result code form fcntl() */\n<line9>pShmNode = pFile->pInode->pShmNode;\n<line10>/* Assert that the parameters are within expected range and that the\n<line11>** correct mutex or mutexes are held. */\n<line12>assert( pShmNode->nRef>=0 );\n<line13>assert( (ofst==UNIX_SHM_DMS && n==1)\n<line14>|| (ofst>=UNIX_SHM_BASE && ofst+n<=(UNIX_SHM_BASE+SQLITE_SHM_NLOCK))\n<line15>);\n<line16>if( ofst==UNIX_SHM_DMS ){\n<line17>assert( pShmNode->nRef>0 || unixMutexHeld() );\n<line18>assert( pShmNode->nRef==0 || sqlite3_mutex_held(pShmNode->pShmMutex) );\n<line19>}else{\n<line20>#ifdef SQLITE_ENABLE_SETLK_TIMEOUT\n<line21>int ii;\n<line22>for(ii=ofst-UNIX_SHM_BASE; ii<ofst-UNIX_SHM_BASE+n; ii++){\n<line23>assert( sqlite3_mutex_held(pShmNode->aMutex[ii]) );\n<line24>}\n<line25>#else\n<line26>assert( sqlite3_mutex_held(pShmNode->pShmMutex) );\n<line27>assert( pShmNode->nRef>0 );\n<line28>#endif\n<line29>}\n<line30>/* Shared locks never span more than one byte */\n<line31>assert( n==1 || lockType!=F_RDLCK );\n<line32>/* Locks are within range */\n<line33>assert( n>=1 && n<=SQLITE_SHM_NLOCK );\n<line34>assert( ofst>=UNIX_SHM_BASE && ofst<=UNIX_SHM_DMS );\n<line35>assert( ofst+n-1<=UNIX_SHM_DMS );\n<line36>if( pShmNode->hShm>=0 ){\n<line37>int res;\n<line38>/* Initialize the locking parameters */\n<line39>f.l_type = lockType;\n<line40>f.l_whence = SEEK_SET;\n<line41>f.l_start = ofst;\n<line42>f.l_len = n;\n<line43>res = osSetPosixAdvisoryLock(pShmNode->hShm, &f, pFile);\n<line44>if( res==-1 ){\n<line45>#if defined(SQLITE_ENABLE_SETLK_TIMEOUT) && SQLITE_ENABLE_SETLK_TIMEOUT==1\n<line46>rc = (pFile->iBusyTimeout ? SQLITE_BUSY_TIMEOUT : SQLITE_BUSY);\n<line47>#else\n<line48>rc = SQLITE_BUSY;\n<line49>#endif\n<line50>}\n<line51>}\n<line52>/* Do debug tracing */\n<line53>#ifdef SQLITE_DEBUG\n<line54>OSTRACE(("SHM-LOCK "));\n<line55>if( rc==SQLITE_OK ){\n<line56>if( lockType==F_UNLCK ){\n<line57>OSTRACE(("unlock %d..%d ok\n", ofst, ofst+n-1));\n<line58>}else if( lockType==F_RDLCK ){\n<line59>OSTRACE(("read-lock %d..%d ok\n", ofst, ofst+n-1));\n<line60>}else{\n<line61>assert( lockType==F_WRLCK );\n<line62>OSTRACE(("write-lock %d..%d ok\n", ofst, ofst+n-1));\n<line63>}\n<line64>}else{\n<line65>if( lockType==F_UNLCK ){\n<line66>OSTRACE(("unlock %d..%d failed\n", ofst, ofst+n-1));\n<line67>}else if( lockType==F_RDLCK ){\n<line68>OSTRACE(("read-lock %d..%d failed\n", ofst, ofst+n-1));\n<line69>}else{\n<line70>assert( lockType==F_WRLCK );\n<line71>OSTRACE(("write-lock %d..%d failed\n", ofst, ofst+n-1));\n<line72>}\n<line73>}\n<line74>#endif\n<line75>return rc;\n<line76>}
----------------------------------------
Function: unixShmRegionPerMap
Content: <line0>static int unixShmRegionPerMap(void){\n<line1>int shmsz = 32*1024;            /* SHM region size */\n<line2>int pgsz = osGetpagesize();   /* System page size */\n<line3>assert( ((pgsz-1)&pgsz)==0 );   /* Page size must be a power of 2 */\n<line4>if( pgsz<shmsz ) return 1;\n<line5>return pgsz/shmsz;\n<line6>}
----------------------------------------
Function: unixShmPurge
Content: <line0>static void unixShmPurge(unixFile *pFd){\n<line1>unixShmNode *p = pFd->pInode->pShmNode;\n<line2>assert( unixMutexHeld() );\n<line3>if( p && ALWAYS(p->nRef==0) ){\n<line4>int nShmPerMap = unixShmRegionPerMap();\n<line5>int i;\n<line6>assert( p->pInode==pFd->pInode );\n<line7>sqlite3_mutex_free(p->pShmMutex);\n<line8>#ifdef SQLITE_ENABLE_SETLK_TIMEOUT\n<line9>for(i=0; i<SQLITE_SHM_NLOCK; i++){\n<line10>sqlite3_mutex_free(p->aMutex[i]);\n<line11>}\n<line12>#endif\n<line13>for(i=0; i<p->nRegion; i+=nShmPerMap){\n<line14>if( p->hShm>=0 ){\n<line15>osMunmap(p->apRegion[i], p->szRegion);\n<line16>}else{\n<line17>sqlite3_free(p->apRegion[i]);\n<line18>}\n<line19>}\n<line20>sqlite3_free(p->apRegion);\n<line21>if( p->hShm>=0 ){\n<line22>robust_close(pFd, p->hShm, __LINE__);\n<line23>p->hShm = -1;\n<line24>}\n<line25>p->pInode->pShmNode = 0;\n<line26>sqlite3_free(p);\n<line27>}\n<line28>}
----------------------------------------
Function: unixLockSharedMemory
Content: <line0>static int unixLockSharedMemory(unixFile *pDbFd, unixShmNode *pShmNode){\n<line1>struct flock lock;\n<line2>int rc = SQLITE_OK;\n<line3>/* Use F_GETLK to determine the locks other processes are holding\n<line4>** on the DMS byte. If it indicates that another process is holding\n<line5>** a SHARED lock, then this process may also take a SHARED lock\n<line6>** and proceed with opening the *-shm file.\n<line7>**\n<line8>** Or, if no other process is holding any lock, then this process\n<line9>** is the first to open it. In this case take an EXCLUSIVE lock on the\n<line10>** DMS byte and truncate the *-shm file to zero bytes in size. Then\n<line11>** downgrade to a SHARED lock on the DMS byte.\n<line12>**\n<line13>** If another process is holding an EXCLUSIVE lock on the DMS byte,\n<line14>** return SQLITE_BUSY to the caller (it will try again). An earlier\n<line15>** version of this code attempted the SHARED lock at this point. But\n<line16>** this introduced a subtle race condition: if the process holding\n<line17>** EXCLUSIVE failed just before truncating the *-shm file, then this\n<line18>** process might open and use the *-shm file without truncating it.\n<line19>** And if the *-shm file has been corrupted by a power failure or\n<line20>** system crash, the database itself may also become corrupt.  */\n<line21>lock.l_whence = SEEK_SET;\n<line22>lock.l_start = UNIX_SHM_DMS;\n<line23>lock.l_len = 1;\n<line24>lock.l_type = F_WRLCK;\n<line25>if( osFcntl(pShmNode->hShm, F_GETLK, &lock)!=0 ) {\n<line26>rc = SQLITE_IOERR_LOCK;\n<line27>}else if( lock.l_type==F_UNLCK ){\n<line28>if( pShmNode->isReadonly ){\n<line29>pShmNode->isUnlocked = 1;\n<line30>rc = SQLITE_READONLY_CANTINIT;\n<line31>}else{\n<line32>#ifdef SQLITE_ENABLE_SETLK_TIMEOUT\n<line33>/* Do not use a blocking lock here. If the lock cannot be obtained\n<line34>** immediately, it means some other connection is truncating the\n<line35>** *-shm file. And after it has done so, it will not release its\n<line36>** lock, but only downgrade it to a shared lock. So no point in\n<line37>** blocking here. The call below to obtain the shared DMS lock may\n<line38>** use a blocking lock. */\n<line39>int iSaveTimeout = pDbFd->iBusyTimeout;\n<line40>pDbFd->iBusyTimeout = 0;\n<line41>#endif\n<line42>rc = unixShmSystemLock(pDbFd, F_WRLCK, UNIX_SHM_DMS, 1);\n<line43>#ifdef SQLITE_ENABLE_SETLK_TIMEOUT\n<line44>pDbFd->iBusyTimeout = iSaveTimeout;\n<line45>#endif\n<line46>/* The first connection to attach must truncate the -shm file.  We\n<line47>** truncate to 3 bytes (an arbitrary small number, less than the\n<line48>** -shm header size) rather than 0 as a system debugging aid, to\n<line49>** help detect if a -shm file truncation is legitimate or is the work\n<line50>** or a rogue process. */\n<line51>if( rc==SQLITE_OK && robust_ftruncate(pShmNode->hShm, 3) ){\n<line52>rc = unixLogError(SQLITE_IOERR_SHMOPEN,"ftruncate",pShmNode->zFilename);\n<line53>}\n<line54>}\n<line55>}else if( lock.l_type==F_WRLCK ){\n<line56>rc = SQLITE_BUSY;\n<line57>}\n<line58>if( rc==SQLITE_OK ){\n<line59>assert( lock.l_type==F_UNLCK || lock.l_type==F_RDLCK );\n<line60>rc = unixShmSystemLock(pDbFd, F_RDLCK, UNIX_SHM_DMS, 1);\n<line61>}\n<line62>return rc;\n<line63>}
----------------------------------------
Function: unixOpenSharedMemory
Content: <line0>static int unixOpenSharedMemory(unixFile *pDbFd){\n<line1>struct unixShm *p = 0;          /* The connection to be opened */\n<line2>struct unixShmNode *pShmNode;   /* The underlying mmapped file */\n<line3>int rc = SQLITE_OK;             /* Result code */\n<line4>unixInodeInfo *pInode;          /* The inode of fd */\n<line5>char *zShm;             /* Name of the file used for SHM */\n<line6>int nShmFilename;               /* Size of the SHM filename in bytes */\n<line7>/* Allocate space for the new unixShm object. */\n<line8>p = sqlite3_malloc64( sizeof(*p) );\n<line9>if( p==0 ) return SQLITE_NOMEM_BKPT;\n<line10>memset(p, 0, sizeof(*p));\n<line11>assert( pDbFd->pShm==0 );\n<line12>/* Check to see if a unixShmNode object already exists. Reuse an existing\n<line13>** one if present. Create a new one if necessary.\n<line14>*/\n<line15>assert( unixFileMutexNotheld(pDbFd) );\n<line16>unixEnterMutex();\n<line17>pInode = pDbFd->pInode;\n<line18>pShmNode = pInode->pShmNode;\n<line19>if( pShmNode==0 ){\n<line20>struct stat sStat;                 /* fstat() info for database file */\n<line21>#ifndef SQLITE_SHM_DIRECTORY\n<line22>const char *zBasePath = pDbFd->zPath;\n<line23>#endif\n<line24>/* Call fstat() to figure out the permissions on the database file. If\n<line25>** a new *-shm file is created, an attempt will be made to create it\n<line26>** with the same permissions.\n<line27>*/\n<line28>if( osFstat(pDbFd->h, &sStat) ){\n<line29>rc = SQLITE_IOERR_FSTAT;\n<line30>goto shm_open_err;\n<line31>}\n<line32>#ifdef SQLITE_SHM_DIRECTORY\n<line33>nShmFilename = sizeof(SQLITE_SHM_DIRECTORY) + 31;\n<line34>#else\n<line35>nShmFilename = 6 + (int)strlen(zBasePath);\n<line36>#endif\n<line37>pShmNode = sqlite3_malloc64( sizeof(*pShmNode) + nShmFilename );\n<line38>if( pShmNode==0 ){\n<line39>rc = SQLITE_NOMEM_BKPT;\n<line40>goto shm_open_err;\n<line41>}\n<line42>memset(pShmNode, 0, sizeof(*pShmNode)+nShmFilename);\n<line43>zShm = pShmNode->zFilename = (char*)&pShmNode[1];\n<line44>#ifdef SQLITE_SHM_DIRECTORY\n<line45>sqlite3_snprintf(nShmFilename, zShm,\n<line46>SQLITE_SHM_DIRECTORY "/sqlite-shm-%x-%x",\n<line47>(u32)sStat.st_ino, (u32)sStat.st_dev);\n<line48>#else\n<line49>sqlite3_snprintf(nShmFilename, zShm, "%s-shm", zBasePath);\n<line50>sqlite3FileSuffix3(pDbFd->zPath, zShm);\n<line51>#endif\n<line52>pShmNode->hShm = -1;\n<line53>pDbFd->pInode->pShmNode = pShmNode;\n<line54>pShmNode->pInode = pDbFd->pInode;\n<line55>if( sqlite3GlobalConfig.bCoreMutex ){\n<line56>pShmNode->pShmMutex = sqlite3_mutex_alloc(SQLITE_MUTEX_FAST);\n<line57>if( pShmNode->pShmMutex==0 ){\n<line58>rc = SQLITE_NOMEM_BKPT;\n<line59>goto shm_open_err;\n<line60>}\n<line61>#ifdef SQLITE_ENABLE_SETLK_TIMEOUT\n<line62>{\n<line63>int ii;\n<line64>for(ii=0; ii<SQLITE_SHM_NLOCK; ii++){\n<line65>pShmNode->aMutex[ii] = sqlite3_mutex_alloc(SQLITE_MUTEX_FAST);\n<line66>if( pShmNode->aMutex[ii]==0 ){\n<line67>rc = SQLITE_NOMEM_BKPT;\n<line68>goto shm_open_err;\n<line69>}\n<line70>}\n<line71>}\n<line72>#endif\n<line73>}\n<line74>if( pInode->bProcessLock==0 ){\n<line75>if( 0==sqlite3_uri_boolean(pDbFd->zPath, "readonly_shm", 0) ){\n<line76>pShmNode->hShm = robust_open(zShm, O_RDWR|O_CREAT|O_NOFOLLOW,\n<line77>(sStat.st_mode&0777));\n<line78>}\n<line79>if( pShmNode->hShm<0 ){\n<line80>pShmNode->hShm = robust_open(zShm, O_RDONLY|O_NOFOLLOW,\n<line81>(sStat.st_mode&0777));\n<line82>if( pShmNode->hShm<0 ){\n<line83>rc = unixLogError(SQLITE_CANTOPEN_BKPT, "open", zShm);\n<line84>goto shm_open_err;\n<line85>}\n<line86>pShmNode->isReadonly = 1;\n<line87>}\n<line88>/* If this process is running as root, make sure that the SHM file\n<line89>** is owned by the same user that owns the original database.  Otherwise,\n<line90>** the original owner will not be able to connect.\n<line91>*/\n<line92>robustFchown(pShmNode->hShm, sStat.st_uid, sStat.st_gid);\n<line93>rc = unixLockSharedMemory(pDbFd, pShmNode);\n<line94>if( rc!=SQLITE_OK && rc!=SQLITE_READONLY_CANTINIT ) goto shm_open_err;\n<line95>}\n<line96>}\n<line97>/* Make the new connection a child of the unixShmNode */\n<line98>p->pShmNode = pShmNode;\n<line99>#ifdef SQLITE_DEBUG\n<line100>p->id = pShmNode->nextShmId++;\n<line101>#endif\n<line102>pShmNode->nRef++;\n<line103>pDbFd->pShm = p;\n<line104>unixLeaveMutex();\n<line105>/* The reference count on pShmNode has already been incremented under\n<line106>** the cover of the unixEnterMutex() mutex and the pointer from the\n<line107>** new (struct unixShm) object to the pShmNode has been set. All that is\n<line108>** left to do is to link the new object into the linked list starting\n<line109>** at pShmNode->pFirst. This must be done while holding the\n<line110>** pShmNode->pShmMutex.\n<line111>*/\n<line112>sqlite3_mutex_enter(pShmNode->pShmMutex);\n<line113>p->pNext = pShmNode->pFirst;\n<line114>pShmNode->pFirst = p;\n<line115>sqlite3_mutex_leave(pShmNode->pShmMutex);\n<line116>return rc;\n<line117>/* Jump here on any error */\n<line118>shm_open_err:\n<line119>unixShmPurge(pDbFd);       /* This call frees pShmNode if required */\n<line120>sqlite3_free(p);\n<line121>unixLeaveMutex();\n<line122>return rc;\n<line123>}
----------------------------------------
Function: unixShmMap
Content: <line0>static int unixShmMap(\n<line1>sqlite3_file *fd,               /* Handle open on database file */\n<line2>int iRegion,                    /* Region to retrieve */\n<line3>int szRegion,                   /* Size of regions */\n<line4>int bExtend,                    /* True to extend file if necessary */\n<line5>void volatile **pp              /* OUT: Mapped memory */\n<line6>){\n<line7>unixFile *pDbFd = (unixFile*)fd;\n<line8>unixShm *p;\n<line9>unixShmNode *pShmNode;\n<line10>int rc = SQLITE_OK;\n<line11>int nShmPerMap = unixShmRegionPerMap();\n<line12>int nReqRegion;\n<line13>/* If the shared-memory file has not yet been opened, open it now. */\n<line14>if( pDbFd->pShm==0 ){\n<line15>rc = unixOpenSharedMemory(pDbFd);\n<line16>if( rc!=SQLITE_OK ) return rc;\n<line17>}\n<line18>p = pDbFd->pShm;\n<line19>pShmNode = p->pShmNode;\n<line20>sqlite3_mutex_enter(pShmNode->pShmMutex);\n<line21>if( pShmNode->isUnlocked ){\n<line22>rc = unixLockSharedMemory(pDbFd, pShmNode);\n<line23>if( rc!=SQLITE_OK ) goto shmpage_out;\n<line24>pShmNode->isUnlocked = 0;\n<line25>}\n<line26>assert( szRegion==pShmNode->szRegion || pShmNode->nRegion==0 );\n<line27>assert( pShmNode->pInode==pDbFd->pInode );\n<line28>assert( pShmNode->hShm>=0 || pDbFd->pInode->bProcessLock==1 );\n<line29>assert( pShmNode->hShm<0 || pDbFd->pInode->bProcessLock==0 );\n<line30>/* Minimum number of regions required to be mapped. */\n<line31>nReqRegion = ((iRegion+nShmPerMap) / nShmPerMap) * nShmPerMap;\n<line32>if( pShmNode->nRegion<nReqRegion ){\n<line33>char **apNew;                      /* New apRegion[] array */\n<line34>int nByte = nReqRegion*szRegion;   /* Minimum required file size */\n<line35>struct stat sStat;                 /* Used by fstat() */\n<line36>pShmNode->szRegion = szRegion;\n<line37>if( pShmNode->hShm>=0 ){\n<line38>/* The requested region is not mapped into this processes address space.\n<line39>** Check to see if it has been allocated (i.e. if the wal-index file is\n<line40>** large enough to contain the requested region).\n<line41>*/\n<line42>if( osFstat(pShmNode->hShm, &sStat) ){\n<line43>rc = SQLITE_IOERR_SHMSIZE;\n<line44>goto shmpage_out;\n<line45>}\n<line46>if( sStat.st_size<nByte ){\n<line47>/* The requested memory region does not exist. If bExtend is set to\n<line48>** false, exit early. *pp will be set to NULL and SQLITE_OK returned.\n<line49>*/\n<line50>if( !bExtend ){\n<line51>goto shmpage_out;\n<line52>}\n<line53>/* Alternatively, if bExtend is true, extend the file. Do this by\n<line54>** writing a single byte to the end of each (OS) page being\n<line55>** allocated or extended. Technically, we need only write to the\n<line56>** last page in order to extend the file. But writing to all new\n<line57>** pages forces the OS to allocate them immediately, which reduces\n<line58>** the chances of SIGBUS while accessing the mapped region later on.\n<line59>*/\n<line60>else{\n<line61>static const int pgsz = 4096;\n<line62>int iPg;\n<line63>/* Write to the last byte of each newly allocated or extended page */\n<line64>assert( (nByte % pgsz)==0 );\n<line65>for(iPg=(sStat.st_size/pgsz); iPg<(nByte/pgsz); iPg++){\n<line66>int x = 0;\n<line67>if( seekAndWriteFd(pShmNode->hShm, iPg*pgsz + pgsz-1,"",1,&x)!=1 ){\n<line68>const char *zFile = pShmNode->zFilename;\n<line69>rc = unixLogError(SQLITE_IOERR_SHMSIZE, "write", zFile);\n<line70>goto shmpage_out;\n<line71>}\n<line72>}\n<line73>}\n<line74>}\n<line75>}\n<line76>/* Map the requested memory region into this processes address space. */\n<line77>apNew = (char **)sqlite3_realloc(\n<line78>pShmNode->apRegion, nReqRegion*sizeof(char *)\n<line79>);\n<line80>if( !apNew ){\n<line81>rc = SQLITE_IOERR_NOMEM_BKPT;\n<line82>goto shmpage_out;\n<line83>}\n<line84>pShmNode->apRegion = apNew;\n<line85>while( pShmNode->nRegion<nReqRegion ){\n<line86>int nMap = szRegion*nShmPerMap;\n<line87>int i;\n<line88>void *pMem;\n<line89>if( pShmNode->hShm>=0 ){\n<line90>pMem = osMmap(0, nMap,\n<line91>pShmNode->isReadonly ? PROT_READ : PROT_READ|PROT_WRITE,\n<line92>MAP_SHARED, pShmNode->hShm, szRegion*(i64)pShmNode->nRegion\n<line93>);\n<line94>if( pMem==MAP_FAILED ){\n<line95>rc = unixLogError(SQLITE_IOERR_SHMMAP, "mmap", pShmNode->zFilename);\n<line96>goto shmpage_out;\n<line97>}\n<line98>}else{\n<line99>pMem = sqlite3_malloc64(nMap);\n<line100>if( pMem==0 ){\n<line101>rc = SQLITE_NOMEM_BKPT;\n<line102>goto shmpage_out;\n<line103>}\n<line104>memset(pMem, 0, nMap);\n<line105>}\n<line106>for(i=0; i<nShmPerMap; i++){\n<line107>pShmNode->apRegion[pShmNode->nRegion+i] = &((char*)pMem)[szRegion*i];\n<line108>}\n<line109>pShmNode->nRegion += nShmPerMap;\n<line110>}\n<line111>}\n<line112>shmpage_out:\n<line113>if( pShmNode->nRegion>iRegion ){\n<line114>*pp = pShmNode->apRegion[iRegion];\n<line115>}else{\n<line116>*pp = 0;\n<line117>}\n<line118>if( pShmNode->isReadonly && rc==SQLITE_OK ) rc = SQLITE_READONLY;\n<line119>sqlite3_mutex_leave(pShmNode->pShmMutex);\n<line120>return rc;\n<line121>}
----------------------------------------
Function: unixShmLock
Content: <line0>static int unixShmLock(\n<line1>sqlite3_file *fd,          /* Database file holding the shared memory */\n<line2>int ofst,                  /* First lock to acquire or release */\n<line3>int n,                     /* Number of locks to acquire or release */\n<line4>int flags                  /* What to do with the lock */\n<line5>){\n<line6>unixFile *pDbFd = (unixFile*)fd;      /* Connection holding shared memory */\n<line7>unixShm *p;                           /* The shared memory being locked */\n<line8>unixShmNode *pShmNode;                /* The underlying file iNode */\n<line9>int rc = SQLITE_OK;                   /* Result code */\n<line10>u16 mask = (1<<(ofst+n)) - (1<<ofst); /* Mask of locks to take or release */\n<line11>int *aLock;\n<line12>p = pDbFd->pShm;\n<line13>if( p==0 ) return SQLITE_IOERR_SHMLOCK;\n<line14>pShmNode = p->pShmNode;\n<line15>if( NEVER(pShmNode==0) ) return SQLITE_IOERR_SHMLOCK;\n<line16>aLock = pShmNode->aLock;\n<line17>assert( pShmNode==pDbFd->pInode->pShmNode );\n<line18>assert( pShmNode->pInode==pDbFd->pInode );\n<line19>assert( ofst>=0 && ofst+n<=SQLITE_SHM_NLOCK );\n<line20>assert( n>=1 );\n<line21>assert( flags==(SQLITE_SHM_LOCK | SQLITE_SHM_SHARED)\n<line22>|| flags==(SQLITE_SHM_LOCK | SQLITE_SHM_EXCLUSIVE)\n<line23>|| flags==(SQLITE_SHM_UNLOCK | SQLITE_SHM_SHARED)\n<line24>|| flags==(SQLITE_SHM_UNLOCK | SQLITE_SHM_EXCLUSIVE) );\n<line25>assert( n==1 || (flags & SQLITE_SHM_EXCLUSIVE)!=0 );\n<line26>assert( pShmNode->hShm>=0 || pDbFd->pInode->bProcessLock==1 );\n<line27>assert( pShmNode->hShm<0 || pDbFd->pInode->bProcessLock==0 );\n<line28>/* Check that, if this to be a blocking lock, no locks that occur later\n<line29>** in the following list than the lock being obtained are already held:\n<line30>**\n<line31>**   1. Recovery lock (ofst==2).\n<line32>**   2. Checkpointer lock (ofst==1).\n<line33>**   3. Write lock (ofst==0).\n<line34>**   4. Read locks (ofst>=3 && ofst<SQLITE_SHM_NLOCK).\n<line35>**\n<line36>** In other words, if this is a blocking lock, none of the locks that\n<line37>** occur later in the above list than the lock being obtained may be\n<line38>** held.\n<line39>*/\n<line40>#if defined(SQLITE_ENABLE_SETLK_TIMEOUT) && defined(SQLITE_DEBUG)\n<line41>{\n<line42>u16 lockMask = (p->exclMask|p->sharedMask);\n<line43>assert( (flags & SQLITE_SHM_UNLOCK) || pDbFd->iBusyTimeout==0 || (\n<line44>(ofst!=2 || lockMask==0)\n<line45>&& (ofst!=1 || lockMask==0 || lockMask==2)\n<line46>&& (ofst!=0 || lockMask<3)\n<line47>&& (ofst<3  || lockMask<(1<<ofst))\n<line48>));\n<line49>}\n<line50>#endif\n<line51>/* Check if there is any work to do. There are three cases:\n<line52>**\n<line53>**    a) An unlock operation where there are locks to unlock,\n<line54>**    b) An shared lock where the requested lock is not already held\n<line55>**    c) An exclusive lock where the requested lock is not already held\n<line56>**\n<line57>** The SQLite core never requests an exclusive lock that it already holds.\n<line58>** This is assert()ed below.\n<line59>*/\n<line60>assert( flags!=(SQLITE_SHM_EXCLUSIVE|SQLITE_SHM_LOCK)\n<line61>|| 0==(p->exclMask & mask)\n<line62>);\n<line63>if( ((flags & SQLITE_SHM_UNLOCK) && ((p->exclMask|p->sharedMask) & mask))\n<line64>|| (flags==(SQLITE_SHM_SHARED|SQLITE_SHM_LOCK) && 0==(p->sharedMask & mask))\n<line65>|| (flags==(SQLITE_SHM_EXCLUSIVE|SQLITE_SHM_LOCK))\n<line66>){\n<line67>/* Take the required mutexes. In SETLK_TIMEOUT mode (blocking locks), if\n<line68>** this is an attempt on an exclusive lock use sqlite3_mutex_try(). If any\n<line69>** other thread is holding this mutex, then it is either holding or about\n<line70>** to hold a lock exclusive to the one being requested, and we may\n<line71>** therefore return SQLITE_BUSY to the caller.\n<line72>**\n<line73>** Doing this prevents some deadlock scenarios. For example, thread 1 may\n<line74>** be a checkpointer blocked waiting on the WRITER lock. And thread 2\n<line75>** may be a normal SQL client upgrading to a write transaction. In this\n<line76>** case thread 2 does a non-blocking request for the WRITER lock. But -\n<line77>** if it were to use sqlite3_mutex_enter() then it would effectively\n<line78>** become a (doomed) blocking request, as thread 2 would block until thread\n<line79>** 1 obtained WRITER and released the mutex. Since thread 2 already holds\n<line80>** a lock on a read-locking slot at this point, this breaks the\n<line81>** anti-deadlock rules (see above).  */\n<line82>#ifdef SQLITE_ENABLE_SETLK_TIMEOUT\n<line83>int iMutex;\n<line84>for(iMutex=ofst; iMutex<ofst+n; iMutex++){\n<line85>if( flags==(SQLITE_SHM_LOCK|SQLITE_SHM_EXCLUSIVE) ){\n<line86>rc = sqlite3_mutex_try(pShmNode->aMutex[iMutex]);\n<line87>if( rc!=SQLITE_OK ) goto leave_shmnode_mutexes;\n<line88>}else{\n<line89>sqlite3_mutex_enter(pShmNode->aMutex[iMutex]);\n<line90>}\n<line91>}\n<line92>#else\n<line93>sqlite3_mutex_enter(pShmNode->pShmMutex);\n<line94>#endif\n<line95>if( ALWAYS(rc==SQLITE_OK) ){\n<line96>if( flags & SQLITE_SHM_UNLOCK ){\n<line97>/* Case (a) - unlock.  */\n<line98>int bUnlock = 1;\n<line99>assert( (p->exclMask & p->sharedMask)==0 );\n<line100>assert( !(flags & SQLITE_SHM_EXCLUSIVE) || (p->exclMask & mask)==mask );\n<line101>assert( !(flags & SQLITE_SHM_SHARED) || (p->sharedMask & mask)==mask );\n<line102>/* If this is a SHARED lock being unlocked, it is possible that other\n<line103>** clients within this process are holding the same SHARED lock. In\n<line104>** this case, set bUnlock to 0 so that the posix lock is not removed\n<line105>** from the file-descriptor below.  */\n<line106>if( flags & SQLITE_SHM_SHARED ){\n<line107>assert( n==1 );\n<line108>assert( aLock[ofst]>=1 );\n<line109>if( aLock[ofst]>1 ){\n<line110>bUnlock = 0;\n<line111>aLock[ofst]--;\n<line112>p->sharedMask &= ~mask;\n<line113>}\n<line114>}\n<line115>if( bUnlock ){\n<line116>rc = unixShmSystemLock(pDbFd, F_UNLCK, ofst+UNIX_SHM_BASE, n);\n<line117>if( rc==SQLITE_OK ){\n<line118>memset(&aLock[ofst], 0, sizeof(int)*n);\n<line119>p->sharedMask &= ~mask;\n<line120>p->exclMask &= ~mask;\n<line121>}\n<line122>}\n<line123>}else if( flags & SQLITE_SHM_SHARED ){\n<line124>/* Case (b) - a shared lock.  */\n<line125>if( aLock[ofst]<0 ){\n<line126>/* An exclusive lock is held by some other connection. BUSY. */\n<line127>rc = SQLITE_BUSY;\n<line128>}else if( aLock[ofst]==0 ){\n<line129>rc = unixShmSystemLock(pDbFd, F_RDLCK, ofst+UNIX_SHM_BASE, n);\n<line130>}\n<line131>/* Get the local shared locks */\n<line132>if( rc==SQLITE_OK ){\n<line133>p->sharedMask |= mask;\n<line134>aLock[ofst]++;\n<line135>}\n<line136>}else{\n<line137>/* Case (c) - an exclusive lock.  */\n<line138>int ii;\n<line139>assert( flags==(SQLITE_SHM_LOCK|SQLITE_SHM_EXCLUSIVE) );\n<line140>assert( (p->sharedMask & mask)==0 );\n<line141>assert( (p->exclMask & mask)==0 );\n<line142>/* Make sure no sibling connections hold locks that will block this\n<line143>** lock.  If any do, return SQLITE_BUSY right away.  */\n<line144>for(ii=ofst; ii<ofst+n; ii++){\n<line145>if( aLock[ii] ){\n<line146>rc = SQLITE_BUSY;\n<line147>break;\n<line148>}\n<line149>}\n<line150>/* Get the exclusive locks at the system level. Then if successful\n<line151>** also update the in-memory values. */\n<line152>if( rc==SQLITE_OK ){\n<line153>rc = unixShmSystemLock(pDbFd, F_WRLCK, ofst+UNIX_SHM_BASE, n);\n<line154>if( rc==SQLITE_OK ){\n<line155>p->exclMask |= mask;\n<line156>for(ii=ofst; ii<ofst+n; ii++){\n<line157>aLock[ii] = -1;\n<line158>}\n<line159>}\n<line160>}\n<line161>}\n<line162>assert( assertLockingArrayOk(pShmNode) );\n<line163>}\n<line164>/* Drop the mutexes acquired above. */\n<line165>#ifdef SQLITE_ENABLE_SETLK_TIMEOUT\n<line166>leave_shmnode_mutexes:\n<line167>for(iMutex--; iMutex>=ofst; iMutex--){\n<line168>sqlite3_mutex_leave(pShmNode->aMutex[iMutex]);\n<line169>}\n<line170>#else\n<line171>sqlite3_mutex_leave(pShmNode->pShmMutex);\n<line172>#endif\n<line173>}\n<line174>OSTRACE(("SHM-LOCK shmid-%d, pid-%d got %03x,%03x\n",\n<line175>p->id, osGetpid(0), p->sharedMask, p->exclMask));\n<line176>return rc;\n<line177>}
----------------------------------------
Function: unixShmBarrier
Content: <line0>static void unixShmBarrier(\n<line1>sqlite3_file *fd                /* Database file holding the shared memory */\n<line2>){\n<line3>UNUSED_PARAMETER(fd);\n<line4>sqlite3MemoryBarrier();         /* compiler-defined memory barrier */\n<line5>assert( fd->pMethods->xLock==nolockLock\n<line6>|| unixFileMutexNotheld((unixFile*)fd)\n<line7>);\n<line8>unixEnterMutex();               /* Also mutex, for redundancy */\n<line9>unixLeaveMutex();\n<line10>}
----------------------------------------
Function: unixShmUnmap
Content: <line0>static int unixShmUnmap(\n<line1>sqlite3_file *fd,               /* The underlying database file */\n<line2>int deleteFlag                  /* Delete shared-memory if true */\n<line3>){\n<line4>unixShm *p;                     /* The connection to be closed */\n<line5>unixShmNode *pShmNode;          /* The underlying shared-memory file */\n<line6>unixShm **pp;                   /* For looping over sibling connections */\n<line7>unixFile *pDbFd;                /* The underlying database file */\n<line8>pDbFd = (unixFile*)fd;\n<line9>p = pDbFd->pShm;\n<line10>if( p==0 ) return SQLITE_OK;\n<line11>pShmNode = p->pShmNode;\n<line12>assert( pShmNode==pDbFd->pInode->pShmNode );\n<line13>assert( pShmNode->pInode==pDbFd->pInode );\n<line14>/* Remove connection p from the set of connections associated\n<line15>** with pShmNode */\n<line16>sqlite3_mutex_enter(pShmNode->pShmMutex);\n<line17>for(pp=&pShmNode->pFirst; (*pp)!=p; pp = &(*pp)->pNext){}\n<line18>*pp = p->pNext;\n<line19>/* Free the connection p */\n<line20>sqlite3_free(p);\n<line21>pDbFd->pShm = 0;\n<line22>sqlite3_mutex_leave(pShmNode->pShmMutex);\n<line23>/* If pShmNode->nRef has reached 0, then close the underlying\n<line24>** shared-memory file, too */\n<line25>assert( unixFileMutexNotheld(pDbFd) );\n<line26>unixEnterMutex();\n<line27>assert( pShmNode->nRef>0 );\n<line28>pShmNode->nRef--;\n<line29>if( pShmNode->nRef==0 ){\n<line30>if( deleteFlag && pShmNode->hShm>=0 ){\n<line31>osUnlink(pShmNode->zFilename);\n<line32>}\n<line33>unixShmPurge(pDbFd);\n<line34>}\n<line35>unixLeaveMutex();\n<line36>return SQLITE_OK;\n<line37>}
----------------------------------------
Function: unixUnmapfile
Content: <line0>static void unixUnmapfile(unixFile *pFd){\n<line1>assert( pFd->nFetchOut==0 );\n<line2>if( pFd->pMapRegion ){\n<line3>osMunmap(pFd->pMapRegion, pFd->mmapSizeActual);\n<line4>pFd->pMapRegion = 0;\n<line5>pFd->mmapSize = 0;\n<line6>pFd->mmapSizeActual = 0;\n<line7>}\n<line8>}
----------------------------------------
Function: unixRemapfile
Content: <line0>static void unixRemapfile(\n<line1>unixFile *pFd,                  /* File descriptor object */\n<line2>i64 nNew                        /* Required mapping size */\n<line3>){\n<line4>const char *zErr = "mmap";\n<line5>int h = pFd->h;                      /* File descriptor open on db file */\n<line6>u8 *pOrig = (u8 *)pFd->pMapRegion;   /* Pointer to current file mapping */\n<line7>i64 nOrig = pFd->mmapSizeActual;     /* Size of pOrig region in bytes */\n<line8>u8 *pNew = 0;                        /* Location of new mapping */\n<line9>int flags = PROT_READ;               /* Flags to pass to mmap() */\n<line10>assert( pFd->nFetchOut==0 );\n<line11>assert( nNew>pFd->mmapSize );\n<line12>assert( nNew<=pFd->mmapSizeMax );\n<line13>assert( nNew>0 );\n<line14>assert( pFd->mmapSizeActual>=pFd->mmapSize );\n<line15>assert( MAP_FAILED!=0 );\n<line16>#ifdef SQLITE_MMAP_READWRITE\n<line17>if( (pFd->ctrlFlags & UNIXFILE_RDONLY)==0 ) flags |= PROT_WRITE;\n<line18>#endif\n<line19>if( pOrig ){\n<line20>#if HAVE_MREMAP\n<line21>i64 nReuse = pFd->mmapSize;\n<line22>#else\n<line23>const int szSyspage = osGetpagesize();\n<line24>i64 nReuse = (pFd->mmapSize & ~(szSyspage-1));\n<line25>#endif\n<line26>u8 *pReq = &pOrig[nReuse];\n<line27>/* Unmap any pages of the existing mapping that cannot be reused. */\n<line28>if( nReuse!=nOrig ){\n<line29>osMunmap(pReq, nOrig-nReuse);\n<line30>}\n<line31>#if HAVE_MREMAP\n<line32>pNew = osMremap(pOrig, nReuse, nNew, MREMAP_MAYMOVE);\n<line33>zErr = "mremap";\n<line34>#else\n<line35>pNew = osMmap(pReq, nNew-nReuse, flags, MAP_SHARED, h, nReuse);\n<line36>if( pNew!=MAP_FAILED ){\n<line37>if( pNew!=pReq ){\n<line38>osMunmap(pNew, nNew - nReuse);\n<line39>pNew = 0;\n<line40>}else{\n<line41>pNew = pOrig;\n<line42>}\n<line43>}\n<line44>#endif\n<line45>/* The attempt to extend the existing mapping failed. Free it. */\n<line46>if( pNew==MAP_FAILED || pNew==0 ){\n<line47>osMunmap(pOrig, nReuse);\n<line48>}\n<line49>}\n<line50>/* If pNew is still NULL, try to create an entirely new mapping. */\n<line51>if( pNew==0 ){\n<line52>pNew = osMmap(0, nNew, flags, MAP_SHARED, h, 0);\n<line53>}\n<line54>if( pNew==MAP_FAILED ){\n<line55>pNew = 0;\n<line56>nNew = 0;\n<line57>unixLogError(SQLITE_OK, zErr, pFd->zPath);\n<line58>/* If the mmap() above failed, assume that all subsequent mmap() calls\n<line59>** will probably fail too. Fall back to using xRead/xWrite exclusively\n<line60>** in this case.  */\n<line61>pFd->mmapSizeMax = 0;\n<line62>}\n<line63>pFd->pMapRegion = (void *)pNew;\n<line64>pFd->mmapSize = pFd->mmapSizeActual = nNew;\n<line65>}
----------------------------------------
Function: unixMapfile
Content: <line0>static int unixMapfile(unixFile *pFd, i64 nMap){\n<line1>assert( nMap>=0 || pFd->nFetchOut==0 );\n<line2>assert( nMap>0 || (pFd->mmapSize==0 && pFd->pMapRegion==0) );\n<line3>if( pFd->nFetchOut>0 ) return SQLITE_OK;\n<line4>if( nMap<0 ){\n<line5>struct stat statbuf;          /* Low-level file information */\n<line6>if( osFstat(pFd->h, &statbuf) ){\n<line7>return SQLITE_IOERR_FSTAT;\n<line8>}\n<line9>nMap = statbuf.st_size;\n<line10>}\n<line11>if( nMap>pFd->mmapSizeMax ){\n<line12>nMap = pFd->mmapSizeMax;\n<line13>}\n<line14>assert( nMap>0 || (pFd->mmapSize==0 && pFd->pMapRegion==0) );\n<line15>if( nMap!=pFd->mmapSize ){\n<line16>unixRemapfile(pFd, nMap);\n<line17>}\n<line18>return SQLITE_OK;\n<line19>}
----------------------------------------
Function: unixFetch
Content: <line0>static int unixFetch(sqlite3_file *fd, i64 iOff, int nAmt, void **pp){\n<line1>#if SQLITE_MAX_MMAP_SIZE>0\n<line2>unixFile *pFd = (unixFile *)fd;   /* The underlying database file */\n<line3>#endif\n<line4>*pp = 0;\n<line5>#if SQLITE_MAX_MMAP_SIZE>0\n<line6>if( pFd->mmapSizeMax>0 ){\n<line7>/* Ensure that there is always at least a 256 byte buffer of addressable\n<line8>** memory following the returned page. If the database is corrupt,\n<line9>** SQLite may overread the page slightly (in practice only a few bytes,\n<line10>** but 256 is safe, round, number).  */\n<line11>const int nEofBuffer = 256;\n<line12>if( pFd->pMapRegion==0 ){\n<line13>int rc = unixMapfile(pFd, -1);\n<line14>if( rc!=SQLITE_OK ) return rc;\n<line15>}\n<line16>if( pFd->mmapSize >= (iOff+nAmt+nEofBuffer) ){\n<line17>*pp = &((u8 *)pFd->pMapRegion)[iOff];\n<line18>pFd->nFetchOut++;\n<line19>}\n<line20>}\n<line21>#endif\n<line22>return SQLITE_OK;\n<line23>}
----------------------------------------
Function: unixUnfetch
Content: <line0>static int unixUnfetch(sqlite3_file *fd, i64 iOff, void *p){\n<line1>#if SQLITE_MAX_MMAP_SIZE>0\n<line2>unixFile *pFd = (unixFile *)fd;   /* The underlying database file */\n<line3>UNUSED_PARAMETER(iOff);\n<line4>/* If p==0 (unmap the entire file) then there must be no outstanding\n<line5>** xFetch references. Or, if p!=0 (meaning it is an xFetch reference),\n<line6>** then there must be at least one outstanding.  */\n<line7>assert( (p==0)==(pFd->nFetchOut==0) );\n<line8>/* If p!=0, it must match the iOff value. */\n<line9>assert( p==0 || p==&((u8 *)pFd->pMapRegion)[iOff] );\n<line10>if( p ){\n<line11>pFd->nFetchOut--;\n<line12>}else{\n<line13>unixUnmapfile(pFd);\n<line14>}\n<line15>assert( pFd->nFetchOut>=0 );\n<line16>#else\n<line17>UNUSED_PARAMETER(fd);\n<line18>UNUSED_PARAMETER(p);\n<line19>UNUSED_PARAMETER(iOff);\n<line20>#endif\n<line21>return SQLITE_OK;\n<line22>}
----------------------------------------
Function: fillInUnixFile
Content: <line0>static int fillInUnixFile(\n<line1>sqlite3_vfs *pVfs,      /* Pointer to vfs object */\n<line2>int h,                  /* Open file descriptor of file being opened */\n<line3>sqlite3_file *pId,      /* Write to the unixFile structure here */\n<line4>const char *zFilename,  /* Name of the file being opened */\n<line5>int ctrlFlags           /* Zero or more UNIXFILE_* values */\n<line6>){\n<line7>const sqlite3_io_methods *pLockingStyle;\n<line8>unixFile *pNew = (unixFile *)pId;\n<line9>int rc = SQLITE_OK;\n<line10>assert( pNew->pInode==NULL );\n<line11>/* No locking occurs in temporary files */\n<line12>assert( zFilename!=0 || (ctrlFlags & UNIXFILE_NOLOCK)!=0 );\n<line13>OSTRACE(("OPEN    %-3d %s\n", h, zFilename));\n<line14>pNew->h = h;\n<line15>pNew->pVfs = pVfs;\n<line16>pNew->zPath = zFilename;\n<line17>pNew->ctrlFlags = (u8)ctrlFlags;\n<line18>#if SQLITE_MAX_MMAP_SIZE>0\n<line19>pNew->mmapSizeMax = sqlite3GlobalConfig.szMmap;\n<line20>#endif\n<line21>if( sqlite3_uri_boolean(((ctrlFlags & UNIXFILE_URI) ? zFilename : 0),\n<line22>"psow", SQLITE_POWERSAFE_OVERWRITE) ){\n<line23>pNew->ctrlFlags |= UNIXFILE_PSOW;\n<line24>}\n<line25>if( strcmp(pVfs->zName,"unix-excl")==0 ){\n<line26>pNew->ctrlFlags |= UNIXFILE_EXCL;\n<line27>}\n<line28>#if OS_VXWORKS\n<line29>pNew->pId = vxworksFindFileId(zFilename);\n<line30>if( pNew->pId==0 ){\n<line31>ctrlFlags |= UNIXFILE_NOLOCK;\n<line32>rc = SQLITE_NOMEM_BKPT;\n<line33>}\n<line34>#endif\n<line35>if( ctrlFlags & UNIXFILE_NOLOCK ){\n<line36>pLockingStyle = &nolockIoMethods;\n<line37>}else{\n<line38>pLockingStyle = (**(finder_type*)pVfs->pAppData)(zFilename, pNew);\n<line39>#if SQLITE_ENABLE_LOCKING_STYLE\n<line40>/* Cache zFilename in the locking context (AFP and dotlock override) for\n<line41>** proxyLock activation is possible (remote proxy is based on db name)\n<line42>** zFilename remains valid until file is closed, to support */\n<line43>pNew->lockingContext = (void*)zFilename;\n<line44>#endif\n<line45>}\n<line46>if( pLockingStyle == &posixIoMethods\n<line47>#if defined(__APPLE__) && SQLITE_ENABLE_LOCKING_STYLE\n<line48>|| pLockingStyle == &nfsIoMethods\n<line49>#endif\n<line50>){\n<line51>unixEnterMutex();\n<line52>rc = findInodeInfo(pNew, &pNew->pInode);\n<line53>if( rc!=SQLITE_OK ){\n<line54>/* If an error occurred in findInodeInfo(), close the file descriptor\n<line55>** immediately, before releasing the mutex. findInodeInfo() may fail\n<line56>** in two scenarios:\n<line57>**\n<line58>**   (a) A call to fstat() failed.\n<line59>**   (b) A malloc failed.\n<line60>**\n<line61>** Scenario (b) may only occur if the process is holding no other\n<line62>** file descriptors open on the same file. If there were other file\n<line63>** descriptors on this file, then no malloc would be required by\n<line64>** findInodeInfo(). If this is the case, it is quite safe to close\n<line65>** handle h - as it is guaranteed that no posix locks will be released\n<line66>** by doing so.\n<line67>**\n<line68>** If scenario (a) caused the error then things are not so safe. The\n<line69>** implicit assumption here is that if fstat() fails, things are in\n<line70>** such bad shape that dropping a lock or two doesn't matter much.\n<line71>*/\n<line72>robust_close(pNew, h, __LINE__);\n<line73>h = -1;\n<line74>}\n<line75>unixLeaveMutex();\n<line76>}\n<line77>#if SQLITE_ENABLE_LOCKING_STYLE && defined(__APPLE__)\n<line78>else if( pLockingStyle == &afpIoMethods ){\n<line79>/* AFP locking uses the file path so it needs to be included in\n<line80>** the afpLockingContext.\n<line81>*/\n<line82>afpLockingContext *pCtx;\n<line83>pNew->lockingContext = pCtx = sqlite3_malloc64( sizeof(*pCtx) );\n<line84>if( pCtx==0 ){\n<line85>rc = SQLITE_NOMEM_BKPT;\n<line86>}else{\n<line87>/* NB: zFilename exists and remains valid until the file is closed\n<line88>** according to requirement F11141.  So we do not need to make a\n<line89>** copy of the filename. */\n<line90>pCtx->dbPath = zFilename;\n<line91>pCtx->reserved = 0;\n<line92>srandomdev();\n<line93>unixEnterMutex();\n<line94>rc = findInodeInfo(pNew, &pNew->pInode);\n<line95>if( rc!=SQLITE_OK ){\n<line96>sqlite3_free(pNew->lockingContext);\n<line97>robust_close(pNew, h, __LINE__);\n<line98>h = -1;\n<line99>}\n<line100>unixLeaveMutex();\n<line101>}\n<line102>}\n<line103>#endif\n<line104>else if( pLockingStyle == &dotlockIoMethods ){\n<line105>/* Dotfile locking uses the file path so it needs to be included in\n<line106>** the dotlockLockingContext\n<line107>*/\n<line108>char *zLockFile;\n<line109>int nFilename;\n<line110>assert( zFilename!=0 );\n<line111>nFilename = (int)strlen(zFilename) + 6;\n<line112>zLockFile = (char *)sqlite3_malloc64(nFilename);\n<line113>if( zLockFile==0 ){\n<line114>rc = SQLITE_NOMEM_BKPT;\n<line115>}else{\n<line116>sqlite3_snprintf(nFilename, zLockFile, "%s" DOTLOCK_SUFFIX, zFilename);\n<line117>}\n<line118>pNew->lockingContext = zLockFile;\n<line119>}\n<line120>#if OS_VXWORKS\n<line121>else if( pLockingStyle == &semIoMethods ){\n<line122>/* Named semaphore locking uses the file path so it needs to be\n<line123>** included in the semLockingContext\n<line124>*/\n<line125>unixEnterMutex();\n<line126>rc = findInodeInfo(pNew, &pNew->pInode);\n<line127>if( (rc==SQLITE_OK) && (pNew->pInode->pSem==NULL) ){\n<line128>char *zSemName = pNew->pInode->aSemName;\n<line129>int n;\n<line130>sqlite3_snprintf(MAX_PATHNAME, zSemName, "/%s.sem",\n<line131>pNew->pId->zCanonicalName);\n<line132>for( n=1; zSemName[n]; n++ )\n<line133>if( zSemName[n]=='/' ) zSemName[n] = '_';\n<line134>pNew->pInode->pSem = sem_open(zSemName, O_CREAT, 0666, 1);\n<line135>if( pNew->pInode->pSem == SEM_FAILED ){\n<line136>rc = SQLITE_NOMEM_BKPT;\n<line137>pNew->pInode->aSemName[0] = '\0';\n<line138>}\n<line139>}\n<line140>unixLeaveMutex();\n<line141>}\n<line142>#endif\n<line143>storeLastErrno(pNew, 0);\n<line144>#if OS_VXWORKS\n<line145>if( rc!=SQLITE_OK ){\n<line146>if( h>=0 ){\n<line147>robust_close(pNew, h, __LINE__);\n<line148>h = -1;\n<line149>}\n<line150>if( pNew->ctrlFlags & UNIXFILE_DELETE ){\n<line151>osUnlink(zFilename);\n<line152>}\n<line153>if( pNew->pId ){\n<line154>vxworksReleaseFileId(pNew->pId);\n<line155>pNew->pId = 0;\n<line156>}\n<line157>}\n<line158>#endif\n<line159>if( rc!=SQLITE_OK ){\n<line160>if( h>=0 ) robust_close(pNew, h, __LINE__);\n<line161>}else{\n<line162>pId->pMethods = pLockingStyle;\n<line163>OpenCounter(+1);\n<line164>verifyDbFile(pNew);\n<line165>}\n<line166>return rc;\n<line167>}
----------------------------------------
Function: unixTempFileInit
Content: <line0>static void unixTempFileInit(void){\n<line1>azTempDirs[0] = getenv("SQLITE_TMPDIR");\n<line2>azTempDirs[1] = getenv("TMPDIR");\n<line3>}
----------------------------------------
Function: unixTempFileDir
Content: <line0>static const char *unixTempFileDir(void){\n<line1>unsigned int i = 0;\n<line2>struct stat buf;\n<line3>const char *zDir = sqlite3_temp_directory;\n<line4>while(1){\n<line5>if( zDir!=0\n<line6>#if OS_VXWORKS\n<line7>&& zDir[0]=='/'\n<line8>#endif\n<line9>&& osStat(zDir, &buf)==0\n<line10>&& S_ISDIR(buf.st_mode)\n<line11>&& osAccess(zDir, 03)==0\n<line12>){\n<line13>return zDir;\n<line14>}\n<line15>if( i>=sizeof(azTempDirs)/sizeof(azTempDirs[0]) ) break;\n<line16>zDir = azTempDirs[i++];\n<line17>}\n<line18>return 0;\n<line19>}
----------------------------------------
Function: unixGetTempname
Content: <line0>static int unixGetTempname(int nBuf, char *zBuf){\n<line1>const char *zDir;\n<line2>int iLimit = 0;\n<line3>int rc = SQLITE_OK;\n<line4>/* It's odd to simulate an io-error here, but really this is just\n<line5>** using the io-error infrastructure to test that SQLite handles this\n<line6>** function failing.\n<line7>*/\n<line8>zBuf[0] = 0;\n<line9>SimulateIOError( return SQLITE_IOERR );\n<line10>sqlite3_mutex_enter(sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_TEMPDIR));\n<line11>zDir = unixTempFileDir();\n<line12>if( zDir==0 ){\n<line13>rc = SQLITE_IOERR_GETTEMPPATH;\n<line14>}else{\n<line15>do{\n<line16>u64 r;\n<line17>sqlite3_randomness(sizeof(r), &r);\n<line18>assert( nBuf>2 );\n<line19>zBuf[nBuf-2] = 0;\n<line20>sqlite3_snprintf(nBuf, zBuf, "%s/"SQLITE_TEMP_FILE_PREFIX"%llx%c",\n<line21>zDir, r, 0);\n<line22>if( zBuf[nBuf-2]!=0 || (iLimit++)>10 ){\n<line23>rc = SQLITE_ERROR;\n<line24>break;\n<line25>}\n<line26>}while( osAccess(zBuf,0)==0 );\n<line27>}\n<line28>sqlite3_mutex_leave(sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_TEMPDIR));\n<line29>return rc;\n<line30>}
----------------------------------------
Function: findReusableFd
Content: <line0>static UnixUnusedFd *findReusableFd(const char *zPath, int flags){\n<line1>UnixUnusedFd *pUnused = 0;\n<line2>/* Do not search for an unused file descriptor on vxworks. Not because\n<line3>** vxworks would not benefit from the change (it might, we're not sure),\n<line4>** but because no way to test it is currently available. It is better\n<line5>** not to risk breaking vxworks support for the sake of such an obscure\n<line6>** feature.  */\n<line7>#if !OS_VXWORKS\n<line8>struct stat sStat;                   /* Results of stat() call */\n<line9>unixEnterMutex();\n<line10>/* A stat() call may fail for various reasons. If this happens, it is\n<line11>** almost certain that an open() call on the same path will also fail.\n<line12>** For this reason, if an error occurs in the stat() call here, it is\n<line13>** ignored and -1 is returned. The caller will try to open a new file\n<line14>** descriptor on the same path, fail, and return an error to SQLite.\n<line15>**\n<line16>** Even if a subsequent open() call does succeed, the consequences of\n<line17>** not searching for a reusable file descriptor are not dire.  */\n<line18>if( inodeList!=0 && 0==osStat(zPath, &sStat) ){\n<line19>unixInodeInfo *pInode;\n<line20>pInode = inodeList;\n<line21>while( pInode && (pInode->fileId.dev!=sStat.st_dev\n<line22>|| pInode->fileId.ino!=(u64)sStat.st_ino) ){\n<line23>pInode = pInode->pNext;\n<line24>}\n<line25>if( pInode ){\n<line26>UnixUnusedFd **pp;\n<line27>assert( sqlite3_mutex_notheld(pInode->pLockMutex) );\n<line28>sqlite3_mutex_enter(pInode->pLockMutex);\n<line29>flags &= (SQLITE_OPEN_READONLY|SQLITE_OPEN_READWRITE);\n<line30>for(pp=&pInode->pUnused; *pp && (*pp)->flags!=flags; pp=&((*pp)->pNext));\n<line31>pUnused = *pp;\n<line32>if( pUnused ){\n<line33>*pp = pUnused->pNext;\n<line34>}\n<line35>sqlite3_mutex_leave(pInode->pLockMutex);\n<line36>}\n<line37>}\n<line38>unixLeaveMutex();\n<line39>#endif    /* if !OS_VXWORKS */\n<line40>return pUnused;\n<line41>}
----------------------------------------
Function: getFileMode
Content: <line0>static int getFileMode(\n<line1>const char *zFile,              /* File name */\n<line2>mode_t *pMode,                  /* OUT: Permissions of zFile */\n<line3>uid_t *pUid,                    /* OUT: uid of zFile. */\n<line4>gid_t *pGid                     /* OUT: gid of zFile. */\n<line5>){\n<line6>struct stat sStat;              /* Output of stat() on database file */\n<line7>int rc = SQLITE_OK;\n<line8>if( 0==osStat(zFile, &sStat) ){\n<line9>*pMode = sStat.st_mode & 0777;\n<line10>*pUid = sStat.st_uid;\n<line11>*pGid = sStat.st_gid;\n<line12>}else{\n<line13>rc = SQLITE_IOERR_FSTAT;\n<line14>}\n<line15>return rc;\n<line16>}
----------------------------------------
Function: findCreateFileMode
Content: <line0>static int findCreateFileMode(\n<line1>const char *zPath,              /* Path of file (possibly) being created */\n<line2>int flags,                      /* Flags passed as 4th argument to xOpen() */\n<line3>mode_t *pMode,                  /* OUT: Permissions to open file with */\n<line4>uid_t *pUid,                    /* OUT: uid to set on the file */\n<line5>gid_t *pGid                     /* OUT: gid to set on the file */\n<line6>){\n<line7>int rc = SQLITE_OK;             /* Return Code */\n<line8>*pMode = 0;\n<line9>*pUid = 0;\n<line10>*pGid = 0;\n<line11>if( flags & (SQLITE_OPEN_WAL|SQLITE_OPEN_MAIN_JOURNAL) ){\n<line12>char zDb[MAX_PATHNAME+1];     /* Database file path */\n<line13>int nDb;                      /* Number of valid bytes in zDb */\n<line14>/* zPath is a path to a WAL or journal file. The following block derives\n<line15>** the path to the associated database file from zPath. This block handles\n<line16>** the following naming conventions:\n<line17>**\n<line18>**   "<path to db>-journal"\n<line19>**   "<path to db>-wal"\n<line20>**   "<path to db>-journalNN"\n<line21>**   "<path to db>-walNN"\n<line22>**\n<line23>** where NN is a decimal number. The NN naming schemes are\n<line24>** used by the test_multiplex.c module.\n<line25>**\n<line26>** In normal operation, the journal file name will always contain\n<line27>** a '-' character.  However in 8+3 filename mode, or if a corrupt\n<line28>** rollback journal specifies a super-journal with a goofy name, then\n<line29>** the '-' might be missing or the '-' might be the first character in\n<line30>** the filename.  In that case, just return SQLITE_OK with *pMode==0.\n<line31>*/\n<line32>nDb = sqlite3Strlen30(zPath) - 1;\n<line33>while( nDb>0 && zPath[nDb]!='.' ){\n<line34>if( zPath[nDb]=='-' ){\n<line35>memcpy(zDb, zPath, nDb);\n<line36>zDb[nDb] = '\0';\n<line37>rc = getFileMode(zDb, pMode, pUid, pGid);\n<line38>break;\n<line39>}\n<line40>nDb--;\n<line41>}\n<line42>}else if( flags & SQLITE_OPEN_DELETEONCLOSE ){\n<line43>*pMode = 0600;\n<line44>}else if( flags & SQLITE_OPEN_URI ){\n<line45>/* If this is a main database file and the file was opened using a URI\n<line46>** filename, check for the "modeof" parameter. If present, interpret\n<line47>** its value as a filename and try to copy the mode, uid and gid from\n<line48>** that file.  */\n<line49>const char *z = sqlite3_uri_parameter(zPath, "modeof");\n<line50>if( z ){\n<line51>rc = getFileMode(z, pMode, pUid, pGid);\n<line52>}\n<line53>}\n<line54>return rc;\n<line55>}
----------------------------------------
Function: unixOpen
Content: <line0>static int unixOpen(\n<line1>sqlite3_vfs *pVfs,           /* The VFS for which this is the xOpen method */\n<line2>const char *zPath,           /* Pathname of file to be opened */\n<line3>sqlite3_file *pFile,         /* The file descriptor to be filled in */\n<line4>int flags,                   /* Input flags to control the opening */\n<line5>int *pOutFlags               /* Output flags returned to SQLite core */\n<line6>){\n<line7>unixFile *p = (unixFile *)pFile;\n<line8>int fd = -1;                   /* File descriptor returned by open() */\n<line9>int openFlags = 0;             /* Flags to pass to open() */\n<line10>int eType = flags&0x0FFF00;  /* Type of file to open */\n<line11>int noLock;                    /* True to omit locking primitives */\n<line12>int rc = SQLITE_OK;            /* Function Return Code */\n<line13>int ctrlFlags = 0;             /* UNIXFILE_* flags */\n<line14>int isExclusive  = (flags & SQLITE_OPEN_EXCLUSIVE);\n<line15>int isDelete     = (flags & SQLITE_OPEN_DELETEONCLOSE);\n<line16>int isCreate     = (flags & SQLITE_OPEN_CREATE);\n<line17>int isReadonly   = (flags & SQLITE_OPEN_READONLY);\n<line18>int isReadWrite  = (flags & SQLITE_OPEN_READWRITE);\n<line19>#if SQLITE_ENABLE_LOCKING_STYLE\n<line20>int isAutoProxy  = (flags & SQLITE_OPEN_AUTOPROXY);\n<line21>#endif\n<line22>#if defined(__APPLE__) || SQLITE_ENABLE_LOCKING_STYLE\n<line23>struct statfs fsInfo;\n<line24>#endif\n<line25>/* If creating a super- or main-file journal, this function will open\n<line26>** a file-descriptor on the directory too. The first time unixSync()\n<line27>** is called the directory file descriptor will be fsync()ed and close()d.\n<line28>*/\n<line29>int isNewJrnl = (isCreate && (\n<line30>eType==SQLITE_OPEN_SUPER_JOURNAL\n<line31>|| eType==SQLITE_OPEN_MAIN_JOURNAL\n<line32>|| eType==SQLITE_OPEN_WAL\n<line33>));\n<line34>/* If argument zPath is a NULL pointer, this function is required to open\n<line35>** a temporary file. Use this buffer to store the file name in.\n<line36>*/\n<line37>char zTmpname[MAX_PATHNAME+2];\n<line38>const char *zName = zPath;\n<line39>/* Check the following statements are true:\n<line40>**\n<line41>**   (a) Exactly one of the READWRITE and READONLY flags must be set, and\n<line42>**   (b) if CREATE is set, then READWRITE must also be set, and\n<line43>**   (c) if EXCLUSIVE is set, then CREATE must also be set.\n<line44>**   (d) if DELETEONCLOSE is set, then CREATE must also be set.\n<line45>*/\n<line46>assert((isReadonly==0 || isReadWrite==0) && (isReadWrite || isReadonly));\n<line47>assert(isCreate==0 || isReadWrite);\n<line48>assert(isExclusive==0 || isCreate);\n<line49>assert(isDelete==0 || isCreate);\n<line50>/* The main DB, main journal, WAL file and super-journal are never\n<line51>** automatically deleted. Nor are they ever temporary files.  */\n<line52>assert( (!isDelete && zName) || eType!=SQLITE_OPEN_MAIN_DB );\n<line53>assert( (!isDelete && zName) || eType!=SQLITE_OPEN_MAIN_JOURNAL );\n<line54>assert( (!isDelete && zName) || eType!=SQLITE_OPEN_SUPER_JOURNAL );\n<line55>assert( (!isDelete && zName) || eType!=SQLITE_OPEN_WAL );\n<line56>/* Assert that the upper layer has set one of the "file-type" flags. */\n<line57>assert( eType==SQLITE_OPEN_MAIN_DB      || eType==SQLITE_OPEN_TEMP_DB\n<line58>|| eType==SQLITE_OPEN_MAIN_JOURNAL || eType==SQLITE_OPEN_TEMP_JOURNAL\n<line59>|| eType==SQLITE_OPEN_SUBJOURNAL   || eType==SQLITE_OPEN_SUPER_JOURNAL\n<line60>|| eType==SQLITE_OPEN_TRANSIENT_DB || eType==SQLITE_OPEN_WAL\n<line61>);\n<line62>#if OS_VXWORKS\n<line63>/* The file-ID mechanism used in Vxworks requires that all pathnames\n<line64>** provided to unixOpen must be absolute pathnames. */\n<line65>if( zPath!=0 && zPath[0]!='/' ){ return SQLITE_CANTOPEN; }\n<line66>#endif\n<line67>/* Detect a pid change and reset the PRNG.  There is a race condition\n<line68>** here such that two or more threads all trying to open databases at\n<line69>** the same instant might all reset the PRNG.  But multiple resets\n<line70>** are harmless.\n<line71>*/\n<line72>if( randomnessPid!=osGetpid(0) ){\n<line73>randomnessPid = osGetpid(0);\n<line74>sqlite3_randomness(0,0);\n<line75>}\n<line76>memset(p, 0, sizeof(unixFile));\n<line77>#ifdef SQLITE_ASSERT_NO_FILES\n<line78>/* Applications that never read or write a persistent disk files */\n<line79>assert( zName==0 );\n<line80>#endif\n<line81>if( eType==SQLITE_OPEN_MAIN_DB ){\n<line82>UnixUnusedFd *pUnused;\n<line83>pUnused = findReusableFd(zName, flags);\n<line84>if( pUnused ){\n<line85>fd = pUnused->fd;\n<line86>}else{\n<line87>pUnused = sqlite3_malloc64(sizeof(*pUnused));\n<line88>if( !pUnused ){\n<line89>return SQLITE_NOMEM_BKPT;\n<line90>}\n<line91>}\n<line92>p->pPreallocatedUnused = pUnused;\n<line93>/* Database filenames are double-zero terminated if they are not\n<line94>** URIs with parameters.  Hence, they can always be passed into\n<line95>** sqlite3_uri_parameter(). */\n<line96>assert( (flags & SQLITE_OPEN_URI) || zName[strlen(zName)+1]==0 );\n<line97>}else if( !zName ){\n<line98>/* If zName is NULL, the upper layer is requesting a temp file. */\n<line99>assert(isDelete && !isNewJrnl);\n<line100>rc = unixGetTempname(pVfs->mxPathname, zTmpname);\n<line101>if( rc!=SQLITE_OK ){\n<line102>return rc;\n<line103>}\n<line104>zName = zTmpname;\n<line105>/* Generated temporary filenames are always double-zero terminated\n<line106>** for use by sqlite3_uri_parameter(). */\n<line107>assert( zName[strlen(zName)+1]==0 );\n<line108>}\n<line109>/* Determine the value of the flags parameter passed to POSIX function\n<line110>** open(). These must be calculated even if open() is not called, as\n<line111>** they may be stored as part of the file handle and used by the\n<line112>** 'conch file' locking functions later on.  */\n<line113>if( isReadonly )  openFlags |= O_RDONLY;\n<line114>if( isReadWrite ) openFlags |= O_RDWR;\n<line115>if( isCreate )    openFlags |= O_CREAT;\n<line116>if( isExclusive ) openFlags |= (O_EXCL|O_NOFOLLOW);\n<line117>openFlags |= (O_LARGEFILE|O_BINARY|O_NOFOLLOW);\n<line118>if( fd<0 ){\n<line119>mode_t openMode;              /* Permissions to create file with */\n<line120>uid_t uid;                    /* Userid for the file */\n<line121>gid_t gid;                    /* Groupid for the file */\n<line122>rc = findCreateFileMode(zName, flags, &openMode, &uid, &gid);\n<line123>if( rc!=SQLITE_OK ){\n<line124>assert( !p->pPreallocatedUnused );\n<line125>assert( eType==SQLITE_OPEN_WAL || eType==SQLITE_OPEN_MAIN_JOURNAL );\n<line126>return rc;\n<line127>}\n<line128>fd = robust_open(zName, openFlags, openMode);\n<line129>OSTRACE(("OPENX   %-3d %s 0%o\n", fd, zName, openFlags));\n<line130>assert( !isExclusive || (openFlags & O_CREAT)!=0 );\n<line131>if( fd<0 ){\n<line132>if( isNewJrnl && errno==EACCES && osAccess(zName, F_OK) ){\n<line133>/* If unable to create a journal because the directory is not\n<line134>** writable, change the error code to indicate that. */\n<line135>rc = SQLITE_READONLY_DIRECTORY;\n<line136>}else if( errno!=EISDIR && isReadWrite ){\n<line137>/* Failed to open the file for read/write access. Try read-only. */\n<line138>UnixUnusedFd *pReadonly = 0;\n<line139>flags &= ~(SQLITE_OPEN_READWRITE|SQLITE_OPEN_CREATE);\n<line140>openFlags &= ~(O_RDWR|O_CREAT);\n<line141>flags |= SQLITE_OPEN_READONLY;\n<line142>openFlags |= O_RDONLY;\n<line143>isReadonly = 1;\n<line144>pReadonly = findReusableFd(zName, flags);\n<line145>if( pReadonly ){\n<line146>fd = pReadonly->fd;\n<line147>sqlite3_free(pReadonly);\n<line148>}else{\n<line149>fd = robust_open(zName, openFlags, openMode);\n<line150>}\n<line151>}\n<line152>}\n<line153>if( fd<0 ){\n<line154>int rc2 = unixLogError(SQLITE_CANTOPEN_BKPT, "open", zName);\n<line155>if( rc==SQLITE_OK ) rc = rc2;\n<line156>goto open_finished;\n<line157>}\n<line158>/* The owner of the rollback journal or WAL file should always be the\n<line159>** same as the owner of the database file.  Try to ensure that this is\n<line160>** the case.  The chown() system call will be a no-op if the current\n<line161>** process lacks root privileges, be we should at least try.  Without\n<line162>** this step, if a root process opens a database file, it can leave\n<line163>** behinds a journal/WAL that is owned by root and hence make the\n<line164>** database inaccessible to unprivileged processes.\n<line165>**\n<line166>** If openMode==0, then that means uid and gid are not set correctly\n<line167>** (probably because SQLite is configured to use 8+3 filename mode) and\n<line168>** in that case we do not want to attempt the chown().\n<line169>*/\n<line170>if( openMode && (flags & (SQLITE_OPEN_WAL|SQLITE_OPEN_MAIN_JOURNAL))!=0 ){\n<line171>robustFchown(fd, uid, gid);\n<line172>}\n<line173>}\n<line174>assert( fd>=0 );\n<line175>if( pOutFlags ){\n<line176>*pOutFlags = flags;\n<line177>}\n<line178>if( p->pPreallocatedUnused ){\n<line179>p->pPreallocatedUnused->fd = fd;\n<line180>p->pPreallocatedUnused->flags =\n<line181>flags & (SQLITE_OPEN_READONLY|SQLITE_OPEN_READWRITE);\n<line182>}\n<line183>if( isDelete ){\n<line184>#if OS_VXWORKS\n<line185>zPath = zName;\n<line186>#elif defined(SQLITE_UNLINK_AFTER_CLOSE)\n<line187>zPath = sqlite3_mprintf("%s", zName);\n<line188>if( zPath==0 ){\n<line189>robust_close(p, fd, __LINE__);\n<line190>return SQLITE_NOMEM_BKPT;\n<line191>}\n<line192>#else\n<line193>osUnlink(zName);\n<line194>#endif\n<line195>}\n<line196>#if SQLITE_ENABLE_LOCKING_STYLE\n<line197>else{\n<line198>p->openFlags = openFlags;\n<line199>}\n<line200>#endif\n<line201>#if defined(__APPLE__) || SQLITE_ENABLE_LOCKING_STYLE\n<line202>if( fstatfs(fd, &fsInfo) == -1 ){\n<line203>storeLastErrno(p, errno);\n<line204>robust_close(p, fd, __LINE__);\n<line205>return SQLITE_IOERR_ACCESS;\n<line206>}\n<line207>if (0 == strncmp("msdos", fsInfo.f_fstypename, 5)) {\n<line208>((unixFile*)pFile)->fsFlags |= SQLITE_FSFLAGS_IS_MSDOS;\n<line209>}\n<line210>if (0 == strncmp("exfat", fsInfo.f_fstypename, 5)) {\n<line211>((unixFile*)pFile)->fsFlags |= SQLITE_FSFLAGS_IS_MSDOS;\n<line212>}\n<line213>#endif\n<line214>/* Set up appropriate ctrlFlags */\n<line215>if( isDelete )                ctrlFlags |= UNIXFILE_DELETE;\n<line216>if( isReadonly )              ctrlFlags |= UNIXFILE_RDONLY;\n<line217>noLock = eType!=SQLITE_OPEN_MAIN_DB;\n<line218>if( noLock )                  ctrlFlags |= UNIXFILE_NOLOCK;\n<line219>if( isNewJrnl )               ctrlFlags |= UNIXFILE_DIRSYNC;\n<line220>if( flags & SQLITE_OPEN_URI ) ctrlFlags |= UNIXFILE_URI;\n<line221>#if SQLITE_ENABLE_LOCKING_STYLE\n<line222>#if SQLITE_PREFER_PROXY_LOCKING\n<line223>isAutoProxy = 1;\n<line224>#endif\n<line225>if( isAutoProxy && (zPath!=NULL) && (!noLock) && pVfs->xOpen ){\n<line226>char *envforce = getenv("SQLITE_FORCE_PROXY_LOCKING");\n<line227>int useProxy = 0;\n<line228>/* SQLITE_FORCE_PROXY_LOCKING==1 means force always use proxy, 0 means\n<line229>** never use proxy, NULL means use proxy for non-local files only.  */\n<line230>if( envforce!=NULL ){\n<line231>useProxy = atoi(envforce)>0;\n<line232>}else{\n<line233>useProxy = !(fsInfo.f_flags&MNT_LOCAL);\n<line234>}\n<line235>if( useProxy ){\n<line236>rc = fillInUnixFile(pVfs, fd, pFile, zPath, ctrlFlags);\n<line237>if( rc==SQLITE_OK ){\n<line238>rc = proxyTransformUnixFile((unixFile*)pFile, ":auto:");\n<line239>if( rc!=SQLITE_OK ){\n<line240>/* Use unixClose to clean up the resources added in fillInUnixFile\n<line241>** and clear all the structure's references.  Specifically,\n<line242>** pFile->pMethods will be NULL so sqlite3OsClose will be a no-op\n<line243>*/\n<line244>unixClose(pFile);\n<line245>return rc;\n<line246>}\n<line247>}\n<line248>goto open_finished;\n<line249>}\n<line250>}\n<line251>#endif\n<line252>assert( zPath==0\n<line253>|| zPath[0]=='/'\n<line254>|| eType==SQLITE_OPEN_SUPER_JOURNAL\n<line255>|| eType==SQLITE_OPEN_MAIN_JOURNAL\n<line256>|| eType==SQLITE_OPEN_TEMP_JOURNAL\n<line257>);\n<line258>rc = fillInUnixFile(pVfs, fd, pFile, zPath, ctrlFlags);\n<line259>open_finished:\n<line260>if( rc!=SQLITE_OK ){\n<line261>sqlite3_free(p->pPreallocatedUnused);\n<line262>}\n<line263>return rc;\n<line264>}
----------------------------------------
Function: unixDelete
Content: <line0>static int unixDelete(\n<line1>sqlite3_vfs *NotUsed,     /* VFS containing this as the xDelete method */\n<line2>const char *zPath,        /* Name of file to be deleted */\n<line3>int dirSync               /* If true, fsync() directory after deleting file */\n<line4>){\n<line5>int rc = SQLITE_OK;\n<line6>UNUSED_PARAMETER(NotUsed);\n<line7>SimulateIOError(return SQLITE_IOERR_DELETE);\n<line8>if( osUnlink(zPath)==(-1) ){\n<line9>if( errno==ENOENT\n<line10>#if OS_VXWORKS\n<line11>|| osAccess(zPath,0)!=0\n<line12>#endif\n<line13>){\n<line14>rc = SQLITE_IOERR_DELETE_NOENT;\n<line15>}else{\n<line16>rc = unixLogError(SQLITE_IOERR_DELETE, "unlink", zPath);\n<line17>}\n<line18>return rc;\n<line19>}\n<line20>#ifndef SQLITE_DISABLE_DIRSYNC\n<line21>if( (dirSync & 1)!=0 ){\n<line22>int fd;\n<line23>rc = osOpenDirectory(zPath, &fd);\n<line24>if( rc==SQLITE_OK ){\n<line25>if( full_fsync(fd,0,0) ){\n<line26>rc = unixLogError(SQLITE_IOERR_DIR_FSYNC, "fsync", zPath);\n<line27>}\n<line28>robust_close(0, fd, __LINE__);\n<line29>}else{\n<line30>assert( rc==SQLITE_CANTOPEN );\n<line31>rc = SQLITE_OK;\n<line32>}\n<line33>}\n<line34>#endif\n<line35>return rc;\n<line36>}
----------------------------------------
Function: unixAccess
Content: <line0>static int unixAccess(\n<line1>sqlite3_vfs *NotUsed,   /* The VFS containing this xAccess method */\n<line2>const char *zPath,      /* Path of the file to examine */\n<line3>int flags,              /* What do we want to learn about the zPath file? */\n<line4>int *pResOut            /* Write result boolean here */\n<line5>){\n<line6>UNUSED_PARAMETER(NotUsed);\n<line7>SimulateIOError( return SQLITE_IOERR_ACCESS; );\n<line8>assert( pResOut!=0 );\n<line9>/* The spec says there are three possible values for flags.  But only\n<line10>** two of them are actually used */\n<line11>assert( flags==SQLITE_ACCESS_EXISTS || flags==SQLITE_ACCESS_READWRITE );\n<line12>if( flags==SQLITE_ACCESS_EXISTS ){\n<line13>struct stat buf;\n<line14>*pResOut = 0==osStat(zPath, &buf) &&\n<line15>(!S_ISREG(buf.st_mode) || buf.st_size>0);\n<line16>}else{\n<line17>*pResOut = osAccess(zPath, W_OK|R_OK)==0;\n<line18>}\n<line19>return SQLITE_OK;\n<line20>}
----------------------------------------
Function: appendOnePathElement
Content: <line0>static void appendOnePathElement(\n<line1>DbPath *pPath,       /* Path under construction, to which to append zName */\n<line2>const char *zName,   /* Name to append to pPath.  Not zero-terminated */\n<line3>int nName            /* Number of significant bytes in zName */\n<line4>){\n<line5>assert( nName>0 );\n<line6>assert( zName!=0 );\n<line7>if( zName[0]=='.' ){\n<line8>if( nName==1 ) return;\n<line9>if( zName[1]=='.' && nName==2 ){\n<line10>if( pPath->nUsed>1 ){\n<line11>assert( pPath->zOut[0]=='/' );\n<line12>while( pPath->zOut[--pPath->nUsed]!='/' ){}\n<line13>}\n<line14>return;\n<line15>}\n<line16>}\n<line17>if( pPath->nUsed + nName + 2 >= pPath->nOut ){\n<line18>pPath->rc = SQLITE_ERROR;\n<line19>return;\n<line20>}\n<line21>pPath->zOut[pPath->nUsed++] = '/';\n<line22>memcpy(&pPath->zOut[pPath->nUsed], zName, nName);\n<line23>pPath->nUsed += nName;\n<line24>#if defined(HAVE_READLINK) && defined(HAVE_LSTAT)\n<line25>if( pPath->rc==SQLITE_OK ){\n<line26>const char *zIn;\n<line27>struct stat buf;\n<line28>pPath->zOut[pPath->nUsed] = 0;\n<line29>zIn = pPath->zOut;\n<line30>if( osLstat(zIn, &buf)!=0 ){\n<line31>if( errno!=ENOENT ){\n<line32>pPath->rc = unixLogError(SQLITE_CANTOPEN_BKPT, "lstat", zIn);\n<line33>}\n<line34>}else if( S_ISLNK(buf.st_mode) ){\n<line35>ssize_t got;\n<line36>char zLnk[SQLITE_MAX_PATHLEN+2];\n<line37>if( pPath->nSymlink++ > SQLITE_MAX_SYMLINK ){\n<line38>pPath->rc = SQLITE_CANTOPEN_BKPT;\n<line39>return;\n<line40>}\n<line41>got = osReadlink(zIn, zLnk, sizeof(zLnk)-2);\n<line42>if( got<=0 || got>=(ssize_t)sizeof(zLnk)-2 ){\n<line43>pPath->rc = unixLogError(SQLITE_CANTOPEN_BKPT, "readlink", zIn);\n<line44>return;\n<line45>}\n<line46>zLnk[got] = 0;\n<line47>if( zLnk[0]=='/' ){\n<line48>pPath->nUsed = 0;\n<line49>}else{\n<line50>pPath->nUsed -= nName + 1;\n<line51>}\n<line52>appendAllPathElements(pPath, zLnk);\n<line53>}\n<line54>}\n<line55>#endif\n<line56>}
----------------------------------------
Function: appendAllPathElements
Content: <line0>static void appendAllPathElements(\n<line1>DbPath *pPath,       /* Path under construction, to which to append zName */\n<line2>const char *zPath    /* Path to append to pPath.  Is zero-terminated */\n<line3>){\n<line4>int i = 0;\n<line5>int j = 0;\n<line6>do{\n<line7>while( zPath[i] && zPath[i]!='/' ){ i++; }\n<line8>if( i>j ){\n<line9>appendOnePathElement(pPath, &zPath[j], i-j);\n<line10>}\n<line11>j = i+1;\n<line12>}while( zPath[i++] );\n<line13>}
----------------------------------------
Function: unixFullPathname
Content: <line0>static int unixFullPathname(\n<line1>sqlite3_vfs *pVfs,            /* Pointer to vfs object */\n<line2>const char *zPath,            /* Possibly relative input path */\n<line3>int nOut,                     /* Size of output buffer in bytes */\n<line4>char *zOut                    /* Output buffer */\n<line5>){\n<line6>DbPath path;\n<line7>UNUSED_PARAMETER(pVfs);\n<line8>path.rc = 0;\n<line9>path.nUsed = 0;\n<line10>path.nSymlink = 0;\n<line11>path.nOut = nOut;\n<line12>path.zOut = zOut;\n<line13>if( zPath[0]!='/' ){\n<line14>char zPwd[SQLITE_MAX_PATHLEN+2];\n<line15>if( osGetcwd(zPwd, sizeof(zPwd)-2)==0 ){\n<line16>return unixLogError(SQLITE_CANTOPEN_BKPT, "getcwd", zPath);\n<line17>}\n<line18>appendAllPathElements(&path, zPwd);\n<line19>}\n<line20>appendAllPathElements(&path, zPath);\n<line21>zOut[path.nUsed] = 0;\n<line22>if( path.rc || path.nUsed<2 ) return SQLITE_CANTOPEN_BKPT;\n<line23>if( path.nSymlink ) return SQLITE_OK_SYMLINK;\n<line24>return SQLITE_OK;\n<line25>}
----------------------------------------
Function: unixDlOpen
Content: <line0>static void *unixDlOpen(sqlite3_vfs *NotUsed, const char *zFilename){\n<line1>UNUSED_PARAMETER(NotUsed);\n<line2>return dlopen(zFilename, RTLD_NOW | RTLD_GLOBAL);\n<line3>}
----------------------------------------
Function: unixDlError
Content: <line0>static void unixDlError(sqlite3_vfs *NotUsed, int nBuf, char *zBufOut){\n<line1>const char *zErr;\n<line2>UNUSED_PARAMETER(NotUsed);\n<line3>unixEnterMutex();\n<line4>zErr = dlerror();\n<line5>if( zErr ){\n<line6>sqlite3_snprintf(nBuf, zBufOut, "%s", zErr);\n<line7>}\n<line8>unixLeaveMutex();\n<line9>}
----------------------------------------
Function: unixDlSym
Content: <line0>static void (*unixDlSym(sqlite3_vfs *NotUsed, void *p, const char*zSym))(void){\n<line1>/*\n<line2>** GCC with -pedantic-errors says that C90 does not allow a void* to be\n<line3>** cast into a pointer to a function.  And yet the library dlsym() routine\n<line4>** returns a void* which is really a pointer to a function.  So how do we\n<line5>** use dlsym() with -pedantic-errors?\n<line6>**\n<line7>** Variable x below is defined to be a pointer to a function taking\n<line8>** parameters void* and const char* and returning a pointer to a function.\n<line9>** We initialize x by assigning it a pointer to the dlsym() function.\n<line10>** (That assignment requires a cast.)  Then we call the function that\n<line11>** x points to.\n<line12>**\n<line13>** This work-around is unlikely to work correctly on any system where\n<line14>** you really cannot cast a function pointer into void*.  But then, on the\n<line15>** other hand, dlsym() will not work on such a system either, so we have\n<line16>** not really lost anything.\n<line17>*/\n<line18>void (*(*x)(void*,const char*))(void);\n<line19>UNUSED_PARAMETER(NotUsed);\n<line20>x = (void(*(*)(void*,const char*))(void))dlsym;\n<line21>return (*x)(p, zSym);\n<line22>}
----------------------------------------
Function: unixDlClose
Content: <line0>static void unixDlClose(sqlite3_vfs *NotUsed, void *pHandle){\n<line1>UNUSED_PARAMETER(NotUsed);\n<line2>dlclose(pHandle);\n<line3>}
----------------------------------------
Function: unixRandomness
Content: <line0>static int unixRandomness(sqlite3_vfs *NotUsed, int nBuf, char *zBuf){\n<line1>UNUSED_PARAMETER(NotUsed);\n<line2>assert((size_t)nBuf>=(sizeof(time_t)+sizeof(int)));\n<line3>/* We have to initialize zBuf to prevent valgrind from reporting\n<line4>** errors.  The reports issued by valgrind are incorrect - we would\n<line5>** prefer that the randomness be increased by making use of the\n<line6>** uninitialized space in zBuf - but valgrind errors tend to worry\n<line7>** some users.  Rather than argue, it seems easier just to initialize\n<line8>** the whole array and silence valgrind, even if that means less randomness\n<line9>** in the random seed.\n<line10>**\n<line11>** When testing, initializing zBuf[] to zero is all we do.  That means\n<line12>** that we always use the same random number sequence.  This makes the\n<line13>** tests repeatable.\n<line14>*/\n<line15>memset(zBuf, 0, nBuf);\n<line16>randomnessPid = osGetpid(0);\n<line17>#if !defined(SQLITE_TEST) && !defined(SQLITE_OMIT_RANDOMNESS)\n<line18>{\n<line19>int fd, got;\n<line20>fd = robust_open("/dev/urandom", O_RDONLY, 0);\n<line21>if( fd<0 ){\n<line22>time_t t;\n<line23>time(&t);\n<line24>memcpy(zBuf, &t, sizeof(t));\n<line25>memcpy(&zBuf[sizeof(t)], &randomnessPid, sizeof(randomnessPid));\n<line26>assert( sizeof(t)+sizeof(randomnessPid)<=(size_t)nBuf );\n<line27>nBuf = sizeof(t) + sizeof(randomnessPid);\n<line28>}else{\n<line29>do{ got = osRead(fd, zBuf, nBuf); }while( got<0 && errno==EINTR );\n<line30>robust_close(0, fd, __LINE__);\n<line31>}\n<line32>}\n<line33>#endif\n<line34>return nBuf;\n<line35>}
----------------------------------------
Function: unixSleep
Content: <line0>static int unixSleep(sqlite3_vfs *NotUsed, int microseconds){\n<line1>#if !defined(HAVE_NANOSLEEP) || HAVE_NANOSLEEP+0\n<line2>struct timespec sp;\n<line3>sp.tv_sec = microseconds / 1000000;\n<line4>sp.tv_nsec = (microseconds % 1000000) * 1000;\n<line5>/* Almost all modern unix systems support nanosleep().  But if you are\n<line6>** compiling for one of the rare exceptions, you can use\n<line7>** -DHAVE_NANOSLEEP=0 (perhaps in conjunction with -DHAVE_USLEEP if\n<line8>** usleep() is available) in order to bypass the use of nanosleep() */\n<line9>nanosleep(&sp, NULL);\n<line10>UNUSED_PARAMETER(NotUsed);\n<line11>return microseconds;\n<line12>#elif defined(HAVE_USLEEP) && HAVE_USLEEP\n<line13>if( microseconds>=1000000 ) sleep(microseconds/1000000);\n<line14>if( microseconds%1000000 ) usleep(microseconds%1000000);\n<line15>UNUSED_PARAMETER(NotUsed);\n<line16>return microseconds;\n<line17>#else\n<line18>int seconds = (microseconds+999999)/1000000;\n<line19>sleep(seconds);\n<line20>UNUSED_PARAMETER(NotUsed);\n<line21>return seconds*1000000;\n<line22>#endif\n<line23>}
----------------------------------------
Function: unixCurrentTimeInt64
Content: <line0>static int unixCurrentTimeInt64(sqlite3_vfs *NotUsed, sqlite3_int64 *piNow){\n<line1>static const sqlite3_int64 unixEpoch = 24405875*(sqlite3_int64)8640000;\n<line2>int rc = SQLITE_OK;\n<line3>#if defined(NO_GETTOD)\n<line4>time_t t;\n<line5>time(&t);\n<line6>*piNow = ((sqlite3_int64)t)*1000 + unixEpoch;\n<line7>#elif OS_VXWORKS\n<line8>struct timespec sNow;\n<line9>clock_gettime(CLOCK_REALTIME, &sNow);\n<line10>*piNow = unixEpoch + 1000*(sqlite3_int64)sNow.tv_sec + sNow.tv_nsec/1000000;\n<line11>#else\n<line12>struct timeval sNow;\n<line13>(void)gettimeofday(&sNow, 0);  /* Cannot fail given valid arguments */\n<line14>*piNow = unixEpoch + 1000*(sqlite3_int64)sNow.tv_sec + sNow.tv_usec/1000;\n<line15>#endif\n<line16>#ifdef SQLITE_TEST\n<line17>if( sqlite3_current_time ){\n<line18>*piNow = 1000*(sqlite3_int64)sqlite3_current_time + unixEpoch;\n<line19>}\n<line20>#endif\n<line21>UNUSED_PARAMETER(NotUsed);\n<line22>return rc;\n<line23>}
----------------------------------------
Function: unixCurrentTime
Content: <line0>static int unixCurrentTime(sqlite3_vfs *NotUsed, double *prNow){\n<line1>sqlite3_int64 i = 0;\n<line2>int rc;\n<line3>UNUSED_PARAMETER(NotUsed);\n<line4>rc = unixCurrentTimeInt64(0, &i);\n<line5>*prNow = i/86400000.0;\n<line6>return rc;\n<line7>}
----------------------------------------
Function: unixGetLastError
Content: <line0>static int unixGetLastError(sqlite3_vfs *NotUsed, int NotUsed2, char *NotUsed3){\n<line1>UNUSED_PARAMETER(NotUsed);\n<line2>UNUSED_PARAMETER(NotUsed2);\n<line3>UNUSED_PARAMETER(NotUsed3);\n<line4>return errno;\n<line5>}
----------------------------------------
Function: sqlite3_os_init
Content: <line0>SQLITE_API int sqlite3_os_init(void){\n<line1>/*\n<line2>** The following macro defines an initializer for an sqlite3_vfs object.\n<line3>** The name of the VFS is NAME.  The pAppData is a pointer to a pointer\n<line4>** to the "finder" function.  (pAppData is a pointer to a pointer because\n<line5>** silly C90 rules prohibit a void* from being cast to a function pointer\n<line6>** and so we have to go through the intermediate pointer to avoid problems\n<line7>** when compiling with -pedantic-errors on GCC.)\n<line8>**\n<line9>** The FINDER parameter to this macro is the name of the pointer to the\n<line10>** finder-function.  The finder-function returns a pointer to the\n<line11>** sqlite_io_methods object that implements the desired locking\n<line12>** behaviors.  See the division above that contains the IOMETHODS\n<line13>** macro for addition information on finder-functions.\n<line14>**\n<line15>** Most finders simply return a pointer to a fixed sqlite3_io_methods\n<line16>** object.  But the "autolockIoFinder" available on MacOSX does a little\n<line17>** more than that; it looks at the filesystem type that hosts the\n<line18>** database file and tries to choose an locking method appropriate for\n<line19>** that filesystem time.\n<line20>*/\n<line21>#define UNIXVFS(VFSNAME, FINDER) {                        \\n<line22>3,                    /* iVersion */                    \\n<line23>sizeof(unixFile),     /* szOsFile */                    \\n<line24>MAX_PATHNAME,         /* mxPathname */                  \\n<line25>0,                    /* pNext */                       \\n<line26>VFSNAME,              /* zName */                       \\n<line27>(void*)&FINDER,       /* pAppData */                    \\n<line28>unixOpen,             /* xOpen */                       \\n<line29>unixDelete,           /* xDelete */                     \\n<line30>unixAccess,           /* xAccess */                     \\n<line31>unixFullPathname,     /* xFullPathname */               \\n<line32>unixDlOpen,           /* xDlOpen */                     \\n<line33>unixDlError,          /* xDlError */                    \\n<line34>unixDlSym,            /* xDlSym */                      \\n<line35>unixDlClose,          /* xDlClose */                    \\n<line36>unixRandomness,       /* xRandomness */                 \\n<line37>unixSleep,            /* xSleep */                      \\n<line38>unixCurrentTime,      /* xCurrentTime */                \\n<line39>unixGetLastError,     /* xGetLastError */               \\n<line40>unixCurrentTimeInt64, /* xCurrentTimeInt64 */           \\n<line41>unixSetSystemCall,    /* xSetSystemCall */              \\n<line42>unixGetSystemCall,    /* xGetSystemCall */              \\n<line43>unixNextSystemCall,   /* xNextSystemCall */             \\n<line44>}\n<line45>/*\n<line46>** All default VFSes for unix are contained in the following array.\n<line47>**\n<line48>** Note that the sqlite3_vfs.pNext field of the VFS object is modified\n<line49>** by the SQLite core when the VFS is registered.  So the following\n<line50>** array cannot be const.\n<line51>*/\n<line52>static sqlite3_vfs aVfs[] = {\n<line53>#if SQLITE_ENABLE_LOCKING_STYLE && defined(__APPLE__)\n<line54>UNIXVFS("unix",          autolockIoFinder ),\n<line55>#elif OS_VXWORKS\n<line56>UNIXVFS("unix",          vxworksIoFinder ),\n<line57>#else\n<line58>UNIXVFS("unix",          posixIoFinder ),\n<line59>#endif\n<line60>UNIXVFS("unix-none",     nolockIoFinder ),\n<line61>UNIXVFS("unix-dotfile",  dotlockIoFinder ),\n<line62>UNIXVFS("unix-excl",     posixIoFinder ),\n<line63>#if OS_VXWORKS\n<line64>UNIXVFS("unix-namedsem", semIoFinder ),\n<line65>#endif\n<line66>#if SQLITE_ENABLE_LOCKING_STYLE || OS_VXWORKS\n<line67>UNIXVFS("unix-posix",    posixIoFinder ),\n<line68>#endif\n<line69>#if SQLITE_ENABLE_LOCKING_STYLE\n<line70>UNIXVFS("unix-flock",    flockIoFinder ),\n<line71>#endif\n<line72>#if SQLITE_ENABLE_LOCKING_STYLE && defined(__APPLE__)\n<line73>UNIXVFS("unix-afp",      afpIoFinder ),\n<line74>UNIXVFS("unix-nfs",      nfsIoFinder ),\n<line75>UNIXVFS("unix-proxy",    proxyIoFinder ),\n<line76>#endif\n<line77>};\n<line78>unsigned int i;          /* Loop counter */\n<line79>/* Double-check that the aSyscall[] array has been constructed\n<line80>** correctly.  See ticket [bb3a86e890c8e96ab] */\n<line81>assert( ArraySize(aSyscall)==29 );\n<line82>/* Register all VFSes defined in the aVfs[] array */\n<line83>for(i=0; i<(sizeof(aVfs)/sizeof(sqlite3_vfs)); i++){\n<line84>#ifdef SQLITE_DEFAULT_UNIX_VFS\n<line85>sqlite3_vfs_register(&aVfs[i],\n<line86>0==strcmp(aVfs[i].zName,SQLITE_DEFAULT_UNIX_VFS));\n<line87>#else\n<line88>sqlite3_vfs_register(&aVfs[i], i==0);\n<line89>#endif\n<line90>}\n<line91>#ifdef SQLITE_OS_KV_OPTIONAL\n<line92>sqlite3KvvfsInit();\n<line93>#endif\n<line94>unixBigLock = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_VFS1);\n<line95>#if OS_VXWORKS\n<line96>vxworksMutex = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_VFS2);\n<line97>#endif\n<line98>#ifndef SQLITE_OMIT_WAL\n<line99>/* Validate lock assumptions */\n<line100>assert( SQLITE_SHM_NLOCK==8 );  /* Number of available locks */\n<line101>assert( UNIX_SHM_BASE==120  );  /* Start of locking area */\n<line102>/* Locks:\n<line103>**    WRITE       UNIX_SHM_BASE      120\n<line104>**    CKPT        UNIX_SHM_BASE+1    121\n<line105>**    RECOVER     UNIX_SHM_BASE+2    122\n<line106>**    READ-0      UNIX_SHM_BASE+3    123\n<line107>**    READ-1      UNIX_SHM_BASE+4    124\n<line108>**    READ-2      UNIX_SHM_BASE+5    125\n<line109>**    READ-3      UNIX_SHM_BASE+6    126\n<line110>**    READ-4      UNIX_SHM_BASE+7    127\n<line111>**    DMS         UNIX_SHM_BASE+8    128\n<line112>*/\n<line113>assert( UNIX_SHM_DMS==128   );  /* Byte offset of the deadman-switch */\n<line114>#endif\n<line115>/* Initialize temp file dir array. */\n<line116>unixTempFileInit();\n<line117>return SQLITE_OK;\n<line118>}
----------------------------------------
Function: sqlite3_os_end
Content: <line0>SQLITE_API int sqlite3_os_end(void){\n<line1>unixBigLock = 0;\n<line2>#if OS_VXWORKS\n<line3>vxworksMutex = 0;\n<line4>#endif\n<line5>return SQLITE_OK;\n<line6>}
----------------------------------------
Function: memdbEnter
Content: <line0>static void memdbEnter(MemStore *p){\n<line1>sqlite3_mutex_enter(p->pMutex);\n<line2>}
----------------------------------------
Function: memdbLeave
Content: <line0>static void memdbLeave(MemStore *p){\n<line1>sqlite3_mutex_leave(p->pMutex);\n<line2>}
----------------------------------------
Function: memdbClose
Content: <line0>static int memdbClose(sqlite3_file *pFile){\n<line1>MemStore *p = ((MemFile*)pFile)->pStore;\n<line2>if( p->zFName ){\n<line3>int i;\n<line4>#ifndef SQLITE_MUTEX_OMIT\n<line5>sqlite3_mutex *pVfsMutex = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_VFS1);\n<line6>#endif\n<line7>sqlite3_mutex_enter(pVfsMutex);\n<line8>for(i=0; ALWAYS(i<memdb_g.nMemStore); i++){\n<line9>if( memdb_g.apMemStore[i]==p ){\n<line10>memdbEnter(p);\n<line11>if( p->nRef==1 ){\n<line12>memdb_g.apMemStore[i] = memdb_g.apMemStore[--memdb_g.nMemStore];\n<line13>if( memdb_g.nMemStore==0 ){\n<line14>sqlite3_free(memdb_g.apMemStore);\n<line15>memdb_g.apMemStore = 0;\n<line16>}\n<line17>}\n<line18>break;\n<line19>}\n<line20>}\n<line21>sqlite3_mutex_leave(pVfsMutex);\n<line22>}else{\n<line23>memdbEnter(p);\n<line24>}\n<line25>p->nRef--;\n<line26>if( p->nRef<=0 ){\n<line27>if( p->mFlags & SQLITE_DESERIALIZE_FREEONCLOSE ){\n<line28>sqlite3_free(p->aData);\n<line29>}\n<line30>memdbLeave(p);\n<line31>sqlite3_mutex_free(p->pMutex);\n<line32>sqlite3_free(p);\n<line33>}else{\n<line34>memdbLeave(p);\n<line35>}\n<line36>return SQLITE_OK;\n<line37>}
----------------------------------------
Function: memdbRead
Content: <line0>static int memdbRead(\n<line1>sqlite3_file *pFile,\n<line2>void *zBuf,\n<line3>int iAmt,\n<line4>sqlite_int64 iOfst\n<line5>){\n<line6>MemStore *p = ((MemFile*)pFile)->pStore;\n<line7>memdbEnter(p);\n<line8>if( iOfst+iAmt>p->sz ){\n<line9>memset(zBuf, 0, iAmt);\n<line10>if( iOfst<p->sz ) memcpy(zBuf, p->aData+iOfst, p->sz - iOfst);\n<line11>memdbLeave(p);\n<line12>return SQLITE_IOERR_SHORT_READ;\n<line13>}\n<line14>memcpy(zBuf, p->aData+iOfst, iAmt);\n<line15>memdbLeave(p);\n<line16>return SQLITE_OK;\n<line17>}
----------------------------------------
Function: memdbEnlarge
Content: <line0>static int memdbEnlarge(MemStore *p, sqlite3_int64 newSz){\n<line1>unsigned char *pNew;\n<line2>if( (p->mFlags & SQLITE_DESERIALIZE_RESIZEABLE)==0 || NEVER(p->nMmap>0) ){\n<line3>return SQLITE_FULL;\n<line4>}\n<line5>if( newSz>p->szMax ){\n<line6>return SQLITE_FULL;\n<line7>}\n<line8>newSz *= 2;\n<line9>if( newSz>p->szMax ) newSz = p->szMax;\n<line10>pNew = sqlite3Realloc(p->aData, newSz);\n<line11>if( pNew==0 ) return SQLITE_IOERR_NOMEM;\n<line12>p->aData = pNew;\n<line13>p->szAlloc = newSz;\n<line14>return SQLITE_OK;\n<line15>}
----------------------------------------
Function: memdbWrite
Content: <line0>static int memdbWrite(\n<line1>sqlite3_file *pFile,\n<line2>const void *z,\n<line3>int iAmt,\n<line4>sqlite_int64 iOfst\n<line5>){\n<line6>MemStore *p = ((MemFile*)pFile)->pStore;\n<line7>memdbEnter(p);\n<line8>if( NEVER(p->mFlags & SQLITE_DESERIALIZE_READONLY) ){\n<line9>/* Can't happen: memdbLock() will return SQLITE_READONLY before\n<line10>** reaching this point */\n<line11>memdbLeave(p);\n<line12>return SQLITE_IOERR_WRITE;\n<line13>}\n<line14>if( iOfst+iAmt>p->sz ){\n<line15>int rc;\n<line16>if( iOfst+iAmt>p->szAlloc\n<line17>&& (rc = memdbEnlarge(p, iOfst+iAmt))!=SQLITE_OK\n<line18>){\n<line19>memdbLeave(p);\n<line20>return rc;\n<line21>}\n<line22>if( iOfst>p->sz ) memset(p->aData+p->sz, 0, iOfst-p->sz);\n<line23>p->sz = iOfst+iAmt;\n<line24>}\n<line25>memcpy(p->aData+iOfst, z, iAmt);\n<line26>memdbLeave(p);\n<line27>return SQLITE_OK;\n<line28>}
----------------------------------------
Function: memdbTruncate
Content: <line0>static int memdbTruncate(sqlite3_file *pFile, sqlite_int64 size){\n<line1>MemStore *p = ((MemFile*)pFile)->pStore;\n<line2>int rc = SQLITE_OK;\n<line3>memdbEnter(p);\n<line4>if( size>p->sz ){\n<line5>/* This can only happen with a corrupt wal mode db */\n<line6>rc = SQLITE_CORRUPT;\n<line7>}else{\n<line8>p->sz = size;\n<line9>}\n<line10>memdbLeave(p);\n<line11>return rc;\n<line12>}
----------------------------------------
Function: memdbSync
Content: <line0>static int memdbSync(sqlite3_file *pFile, int flags){\n<line1>UNUSED_PARAMETER(pFile);\n<line2>UNUSED_PARAMETER(flags);\n<line3>return SQLITE_OK;\n<line4>}
----------------------------------------
Function: memdbFileSize
Content: <line0>static int memdbFileSize(sqlite3_file *pFile, sqlite_int64 *pSize){\n<line1>MemStore *p = ((MemFile*)pFile)->pStore;\n<line2>memdbEnter(p);\n<line3>*pSize = p->sz;\n<line4>memdbLeave(p);\n<line5>return SQLITE_OK;\n<line6>}
----------------------------------------
Function: memdbLock
Content: <line0>static int memdbLock(sqlite3_file *pFile, int eLock){\n<line1>MemFile *pThis = (MemFile*)pFile;\n<line2>MemStore *p = pThis->pStore;\n<line3>int rc = SQLITE_OK;\n<line4>if( eLock<=pThis->eLock ) return SQLITE_OK;\n<line5>memdbEnter(p);\n<line6>assert( p->nWrLock==0 || p->nWrLock==1 );\n<line7>assert( pThis->eLock<=SQLITE_LOCK_SHARED || p->nWrLock==1 );\n<line8>assert( pThis->eLock==SQLITE_LOCK_NONE || p->nRdLock>=1 );\n<line9>if( eLock>SQLITE_LOCK_SHARED && (p->mFlags & SQLITE_DESERIALIZE_READONLY) ){\n<line10>rc = SQLITE_READONLY;\n<line11>}else{\n<line12>switch( eLock ){\n<line13>case SQLITE_LOCK_SHARED: {\n<line14>assert( pThis->eLock==SQLITE_LOCK_NONE );\n<line15>if( p->nWrLock>0 ){\n<line16>rc = SQLITE_BUSY;\n<line17>}else{\n<line18>p->nRdLock++;\n<line19>}\n<line20>break;\n<line21>};\n<line22>case SQLITE_LOCK_RESERVED:\n<line23>case SQLITE_LOCK_PENDING: {\n<line24>assert( pThis->eLock>=SQLITE_LOCK_SHARED );\n<line25>if( ALWAYS(pThis->eLock==SQLITE_LOCK_SHARED) ){\n<line26>if( p->nWrLock>0 ){\n<line27>rc = SQLITE_BUSY;\n<line28>}else{\n<line29>p->nWrLock = 1;\n<line30>}\n<line31>}\n<line32>break;\n<line33>}\n<line34>default: {\n<line35>assert(  eLock==SQLITE_LOCK_EXCLUSIVE );\n<line36>assert( pThis->eLock>=SQLITE_LOCK_SHARED );\n<line37>if( p->nRdLock>1 ){\n<line38>rc = SQLITE_BUSY;\n<line39>}else if( pThis->eLock==SQLITE_LOCK_SHARED ){\n<line40>p->nWrLock = 1;\n<line41>}\n<line42>break;\n<line43>}\n<line44>}\n<line45>}\n<line46>if( rc==SQLITE_OK ) pThis->eLock = eLock;\n<line47>memdbLeave(p);\n<line48>return rc;\n<line49>}
----------------------------------------
Function: memdbUnlock
Content: <line0>static int memdbUnlock(sqlite3_file *pFile, int eLock){\n<line1>MemFile *pThis = (MemFile*)pFile;\n<line2>MemStore *p = pThis->pStore;\n<line3>if( eLock>=pThis->eLock ) return SQLITE_OK;\n<line4>memdbEnter(p);\n<line5>assert( eLock==SQLITE_LOCK_SHARED || eLock==SQLITE_LOCK_NONE );\n<line6>if( eLock==SQLITE_LOCK_SHARED ){\n<line7>if( ALWAYS(pThis->eLock>SQLITE_LOCK_SHARED) ){\n<line8>p->nWrLock--;\n<line9>}\n<line10>}else{\n<line11>if( pThis->eLock>SQLITE_LOCK_SHARED ){\n<line12>p->nWrLock--;\n<line13>}\n<line14>p->nRdLock--;\n<line15>}\n<line16>pThis->eLock = eLock;\n<line17>memdbLeave(p);\n<line18>return SQLITE_OK;\n<line19>}
----------------------------------------
Function: memdbFileControl
Content: <line0>static int memdbFileControl(sqlite3_file *pFile, int op, void *pArg){\n<line1>MemStore *p = ((MemFile*)pFile)->pStore;\n<line2>int rc = SQLITE_NOTFOUND;\n<line3>memdbEnter(p);\n<line4>if( op==SQLITE_FCNTL_VFSNAME ){\n<line5>*(char**)pArg = sqlite3_mprintf("memdb(%p,%lld)", p->aData, p->sz);\n<line6>rc = SQLITE_OK;\n<line7>}\n<line8>if( op==SQLITE_FCNTL_SIZE_LIMIT ){\n<line9>sqlite3_int64 iLimit = *(sqlite3_int64*)pArg;\n<line10>if( iLimit<p->sz ){\n<line11>if( iLimit<0 ){\n<line12>iLimit = p->szMax;\n<line13>}else{\n<line14>iLimit = p->sz;\n<line15>}\n<line16>}\n<line17>p->szMax = iLimit;\n<line18>*(sqlite3_int64*)pArg = iLimit;\n<line19>rc = SQLITE_OK;\n<line20>}\n<line21>memdbLeave(p);\n<line22>return rc;\n<line23>}
----------------------------------------
Function: memdbDeviceCharacteristics
Content: <line0>static int memdbDeviceCharacteristics(sqlite3_file *pFile){\n<line1>UNUSED_PARAMETER(pFile);\n<line2>return SQLITE_IOCAP_ATOMIC |\n<line3>SQLITE_IOCAP_POWERSAFE_OVERWRITE |\n<line4>SQLITE_IOCAP_SAFE_APPEND |\n<line5>SQLITE_IOCAP_SEQUENTIAL;\n<line6>}
----------------------------------------
Function: memdbFetch
Content: <line0>static int memdbFetch(\n<line1>sqlite3_file *pFile,\n<line2>sqlite3_int64 iOfst,\n<line3>int iAmt,\n<line4>void **pp\n<line5>){\n<line6>MemStore *p = ((MemFile*)pFile)->pStore;\n<line7>memdbEnter(p);\n<line8>if( iOfst+iAmt>p->sz || (p->mFlags & SQLITE_DESERIALIZE_RESIZEABLE)!=0 ){\n<line9>*pp = 0;\n<line10>}else{\n<line11>p->nMmap++;\n<line12>*pp = (void*)(p->aData + iOfst);\n<line13>}\n<line14>memdbLeave(p);\n<line15>return SQLITE_OK;\n<line16>}
----------------------------------------
Function: memdbUnfetch
Content: <line0>static int memdbUnfetch(sqlite3_file *pFile, sqlite3_int64 iOfst, void *pPage){\n<line1>MemStore *p = ((MemFile*)pFile)->pStore;\n<line2>UNUSED_PARAMETER(iOfst);\n<line3>UNUSED_PARAMETER(pPage);\n<line4>memdbEnter(p);\n<line5>p->nMmap--;\n<line6>memdbLeave(p);\n<line7>return SQLITE_OK;\n<line8>}
----------------------------------------
Function: memdbOpen
Content: <line0>static int memdbOpen(\n<line1>sqlite3_vfs *pVfs,\n<line2>const char *zName,\n<line3>sqlite3_file *pFd,\n<line4>int flags,\n<line5>int *pOutFlags\n<line6>){\n<line7>MemFile *pFile = (MemFile*)pFd;\n<line8>MemStore *p = 0;\n<line9>int szName;\n<line10>UNUSED_PARAMETER(pVfs);\n<line11>memset(pFile, 0, sizeof(*pFile));\n<line12>szName = sqlite3Strlen30(zName);\n<line13>if( szName>1 && (zName[0]=='/' || zName[0]=='\\') ){\n<line14>int i;\n<line15>#ifndef SQLITE_MUTEX_OMIT\n<line16>sqlite3_mutex *pVfsMutex = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_VFS1);\n<line17>#endif\n<line18>sqlite3_mutex_enter(pVfsMutex);\n<line19>for(i=0; i<memdb_g.nMemStore; i++){\n<line20>if( strcmp(memdb_g.apMemStore[i]->zFName,zName)==0 ){\n<line21>p = memdb_g.apMemStore[i];\n<line22>break;\n<line23>}\n<line24>}\n<line25>if( p==0 ){\n<line26>MemStore **apNew;\n<line27>p = sqlite3Malloc( sizeof(*p) + (i64)szName + 3 );\n<line28>if( p==0 ){\n<line29>sqlite3_mutex_leave(pVfsMutex);\n<line30>return SQLITE_NOMEM;\n<line31>}\n<line32>apNew = sqlite3Realloc(memdb_g.apMemStore,\n<line33>sizeof(apNew[0])*(1+(i64)memdb_g.nMemStore) );\n<line34>if( apNew==0 ){\n<line35>sqlite3_free(p);\n<line36>sqlite3_mutex_leave(pVfsMutex);\n<line37>return SQLITE_NOMEM;\n<line38>}\n<line39>apNew[memdb_g.nMemStore++] = p;\n<line40>memdb_g.apMemStore = apNew;\n<line41>memset(p, 0, sizeof(*p));\n<line42>p->mFlags = SQLITE_DESERIALIZE_RESIZEABLE|SQLITE_DESERIALIZE_FREEONCLOSE;\n<line43>p->szMax = sqlite3GlobalConfig.mxMemdbSize;\n<line44>p->zFName = (char*)&p[1];\n<line45>memcpy(p->zFName, zName, szName+1);\n<line46>p->pMutex = sqlite3_mutex_alloc(SQLITE_MUTEX_FAST);\n<line47>if( p->pMutex==0 ){\n<line48>memdb_g.nMemStore--;\n<line49>sqlite3_free(p);\n<line50>sqlite3_mutex_leave(pVfsMutex);\n<line51>return SQLITE_NOMEM;\n<line52>}\n<line53>p->nRef = 1;\n<line54>memdbEnter(p);\n<line55>}else{\n<line56>memdbEnter(p);\n<line57>p->nRef++;\n<line58>}\n<line59>sqlite3_mutex_leave(pVfsMutex);\n<line60>}else{\n<line61>p = sqlite3Malloc( sizeof(*p) );\n<line62>if( p==0 ){\n<line63>return SQLITE_NOMEM;\n<line64>}\n<line65>memset(p, 0, sizeof(*p));\n<line66>p->mFlags = SQLITE_DESERIALIZE_RESIZEABLE | SQLITE_DESERIALIZE_FREEONCLOSE;\n<line67>p->szMax = sqlite3GlobalConfig.mxMemdbSize;\n<line68>}\n<line69>pFile->pStore = p;\n<line70>if( pOutFlags!=0 ){\n<line71>*pOutFlags = flags | SQLITE_OPEN_MEMORY;\n<line72>}\n<line73>pFd->pMethods = &memdb_io_methods;\n<line74>memdbLeave(p);\n<line75>return SQLITE_OK;\n<line76>}
----------------------------------------
Function: memdbAccess
Content: <line0>static int memdbAccess(\n<line1>sqlite3_vfs *pVfs,\n<line2>const char *zPath,\n<line3>int flags,\n<line4>int *pResOut\n<line5>){\n<line6>UNUSED_PARAMETER(pVfs);\n<line7>UNUSED_PARAMETER(zPath);\n<line8>UNUSED_PARAMETER(flags);\n<line9>*pResOut = 0;\n<line10>return SQLITE_OK;\n<line11>}
----------------------------------------
Function: memdbFullPathname
Content: <line0>static int memdbFullPathname(\n<line1>sqlite3_vfs *pVfs,\n<line2>const char *zPath,\n<line3>int nOut,\n<line4>char *zOut\n<line5>){\n<line6>UNUSED_PARAMETER(pVfs);\n<line7>sqlite3_snprintf(nOut, zOut, "%s", zPath);\n<line8>return SQLITE_OK;\n<line9>}
----------------------------------------
Function: memdbDlOpen
Content: <line0>static void *memdbDlOpen(sqlite3_vfs *pVfs, const char *zPath){\n<line1>return ORIGVFS(pVfs)->xDlOpen(ORIGVFS(pVfs), zPath);\n<line2>}
----------------------------------------
Function: memdbDlError
Content: <line0>static void memdbDlError(sqlite3_vfs *pVfs, int nByte, char *zErrMsg){\n<line1>ORIGVFS(pVfs)->xDlError(ORIGVFS(pVfs), nByte, zErrMsg);\n<line2>}
----------------------------------------
Function: memdbDlSym
Content: <line0>static void (*memdbDlSym(sqlite3_vfs *pVfs, void *p, const char *zSym))(void){\n<line1>return ORIGVFS(pVfs)->xDlSym(ORIGVFS(pVfs), p, zSym);\n<line2>}
----------------------------------------
Function: memdbDlClose
Content: <line0>static void memdbDlClose(sqlite3_vfs *pVfs, void *pHandle){\n<line1>ORIGVFS(pVfs)->xDlClose(ORIGVFS(pVfs), pHandle);\n<line2>}
----------------------------------------
Function: memdbRandomness
Content: <line0>static int memdbRandomness(sqlite3_vfs *pVfs, int nByte, char *zBufOut){\n<line1>return ORIGVFS(pVfs)->xRandomness(ORIGVFS(pVfs), nByte, zBufOut);\n<line2>}
----------------------------------------
Function: memdbSleep
Content: <line0>static int memdbSleep(sqlite3_vfs *pVfs, int nMicro){\n<line1>return ORIGVFS(pVfs)->xSleep(ORIGVFS(pVfs), nMicro);\n<line2>}
----------------------------------------
Function: memdbGetLastError
Content: <line0>static int memdbGetLastError(sqlite3_vfs *pVfs, int a, char *b){\n<line1>return ORIGVFS(pVfs)->xGetLastError(ORIGVFS(pVfs), a, b);\n<line2>}
----------------------------------------
Function: memdbCurrentTimeInt64
Content: <line0>static int memdbCurrentTimeInt64(sqlite3_vfs *pVfs, sqlite3_int64 *p){\n<line1>return ORIGVFS(pVfs)->xCurrentTimeInt64(ORIGVFS(pVfs), p);\n<line2>}
----------------------------------------
Function: memdbFromDbSchema
Content: <line0>static MemFile *memdbFromDbSchema(sqlite3 *db, const char *zSchema){\n<line1>MemFile *p = 0;\n<line2>MemStore *pStore;\n<line3>int rc = sqlite3_file_control(db, zSchema, SQLITE_FCNTL_FILE_POINTER, &p);\n<line4>if( rc ) return 0;\n<line5>if( p->base.pMethods!=&memdb_io_methods ) return 0;\n<line6>pStore = p->pStore;\n<line7>memdbEnter(pStore);\n<line8>if( pStore->zFName!=0 ) p = 0;\n<line9>memdbLeave(pStore);\n<line10>return p;\n<line11>}
----------------------------------------
Function: sqlite3_serialize
Content: <line0>SQLITE_API unsigned char *sqlite3_serialize(\n<line1>sqlite3 *db,              /* The database connection */\n<line2>const char *zSchema,      /* Which database within the connection */\n<line3>sqlite3_int64 *piSize,    /* Write size here, if not NULL */\n<line4>unsigned int mFlags       /* Maybe SQLITE_SERIALIZE_NOCOPY */\n<line5>){\n<line6>MemFile *p;\n<line7>int iDb;\n<line8>Btree *pBt;\n<line9>sqlite3_int64 sz;\n<line10>int szPage = 0;\n<line11>sqlite3_stmt *pStmt = 0;\n<line12>unsigned char *pOut;\n<line13>char *zSql;\n<line14>int rc;\n<line15>#ifdef SQLITE_ENABLE_API_ARMOR\n<line16>if( !sqlite3SafetyCheckOk(db) ){\n<line17>(void)SQLITE_MISUSE_BKPT;\n<line18>return 0;\n<line19>}\n<line20>#endif\n<line21>if( zSchema==0 ) zSchema = db->aDb[0].zDbSName;\n<line22>p = memdbFromDbSchema(db, zSchema);\n<line23>iDb = sqlite3FindDbName(db, zSchema);\n<line24>if( piSize ) *piSize = -1;\n<line25>if( iDb<0 ) return 0;\n<line26>if( p ){\n<line27>MemStore *pStore = p->pStore;\n<line28>assert( pStore->pMutex==0 );\n<line29>if( piSize ) *piSize = pStore->sz;\n<line30>if( mFlags & SQLITE_SERIALIZE_NOCOPY ){\n<line31>pOut = pStore->aData;\n<line32>}else{\n<line33>pOut = sqlite3_malloc64( pStore->sz );\n<line34>if( pOut ) memcpy(pOut, pStore->aData, pStore->sz);\n<line35>}\n<line36>return pOut;\n<line37>}\n<line38>pBt = db->aDb[iDb].pBt;\n<line39>if( pBt==0 ) return 0;\n<line40>szPage = sqlite3BtreeGetPageSize(pBt);\n<line41>zSql = sqlite3_mprintf("PRAGMA \"%w\".page_count", zSchema);\n<line42>rc = zSql ? sqlite3_prepare_v2(db, zSql, -1, &pStmt, 0) : SQLITE_NOMEM;\n<line43>sqlite3_free(zSql);\n<line44>if( rc ) return 0;\n<line45>rc = sqlite3_step(pStmt);\n<line46>if( rc!=SQLITE_ROW ){\n<line47>pOut = 0;\n<line48>}else{\n<line49>sz = sqlite3_column_int64(pStmt, 0)*szPage;\n<line50>if( sz==0 ){\n<line51>sqlite3_reset(pStmt);\n<line52>sqlite3_exec(db, "BEGIN IMMEDIATE; COMMIT;", 0, 0, 0);\n<line53>rc = sqlite3_step(pStmt);\n<line54>if( rc==SQLITE_ROW ){\n<line55>sz = sqlite3_column_int64(pStmt, 0)*szPage;\n<line56>}\n<line57>}\n<line58>if( piSize ) *piSize = sz;\n<line59>if( mFlags & SQLITE_SERIALIZE_NOCOPY ){\n<line60>pOut = 0;\n<line61>}else{\n<line62>pOut = sqlite3_malloc64( sz );\n<line63>if( pOut ){\n<line64>int nPage = sqlite3_column_int(pStmt, 0);\n<line65>Pager *pPager = sqlite3BtreePager(pBt);\n<line66>int pgno;\n<line67>for(pgno=1; pgno<=nPage; pgno++){\n<line68>DbPage *pPage = 0;\n<line69>unsigned char *pTo = pOut + szPage*(sqlite3_int64)(pgno-1);\n<line70>rc = sqlite3PagerGet(pPager, pgno, (DbPage**)&pPage, 0);\n<line71>if( rc==SQLITE_OK ){\n<line72>memcpy(pTo, sqlite3PagerGetData(pPage), szPage);\n<line73>}else{\n<line74>memset(pTo, 0, szPage);\n<line75>}\n<line76>sqlite3PagerUnref(pPage);\n<line77>}\n<line78>}\n<line79>}\n<line80>}\n<line81>sqlite3_finalize(pStmt);\n<line82>return pOut;\n<line83>}
----------------------------------------
Function: sqlite3_deserialize
Content: <line0>SQLITE_API int sqlite3_deserialize(\n<line1>sqlite3 *db,            /* The database connection */\n<line2>const char *zSchema,    /* Which DB to reopen with the deserialization */\n<line3>unsigned char *pData,   /* The serialized database content */\n<line4>sqlite3_int64 szDb,     /* Number bytes in the deserialization */\n<line5>sqlite3_int64 szBuf,    /* Total size of buffer pData[] */\n<line6>unsigned mFlags         /* Zero or more SQLITE_DESERIALIZE_* flags */\n<line7>){\n<line8>MemFile *p;\n<line9>char *zSql;\n<line10>sqlite3_stmt *pStmt = 0;\n<line11>int rc;\n<line12>int iDb;\n<line13>#ifdef SQLITE_ENABLE_API_ARMOR\n<line14>if( !sqlite3SafetyCheckOk(db) ){\n<line15>return SQLITE_MISUSE_BKPT;\n<line16>}\n<line17>if( szDb<0 ) return SQLITE_MISUSE_BKPT;\n<line18>if( szBuf<0 ) return SQLITE_MISUSE_BKPT;\n<line19>#endif\n<line20>sqlite3_mutex_enter(db->mutex);\n<line21>if( zSchema==0 ) zSchema = db->aDb[0].zDbSName;\n<line22>iDb = sqlite3FindDbName(db, zSchema);\n<line23>testcase( iDb==1 );\n<line24>if( iDb<2 && iDb!=0 ){\n<line25>rc = SQLITE_ERROR;\n<line26>goto end_deserialize;\n<line27>}\n<line28>zSql = sqlite3_mprintf("ATTACH x AS %Q", zSchema);\n<line29>if( zSql==0 ){\n<line30>rc = SQLITE_NOMEM;\n<line31>}else{\n<line32>rc = sqlite3_prepare_v2(db, zSql, -1, &pStmt, 0);\n<line33>sqlite3_free(zSql);\n<line34>}\n<line35>if( rc ) goto end_deserialize;\n<line36>db->init.iDb = (u8)iDb;\n<line37>db->init.reopenMemdb = 1;\n<line38>rc = sqlite3_step(pStmt);\n<line39>db->init.reopenMemdb = 0;\n<line40>if( rc!=SQLITE_DONE ){\n<line41>rc = SQLITE_ERROR;\n<line42>goto end_deserialize;\n<line43>}\n<line44>p = memdbFromDbSchema(db, zSchema);\n<line45>if( p==0 ){\n<line46>rc = SQLITE_ERROR;\n<line47>}else{\n<line48>MemStore *pStore = p->pStore;\n<line49>pStore->aData = pData;\n<line50>pData = 0;\n<line51>pStore->sz = szDb;\n<line52>pStore->szAlloc = szBuf;\n<line53>pStore->szMax = szBuf;\n<line54>if( pStore->szMax<sqlite3GlobalConfig.mxMemdbSize ){\n<line55>pStore->szMax = sqlite3GlobalConfig.mxMemdbSize;\n<line56>}\n<line57>pStore->mFlags = mFlags;\n<line58>rc = SQLITE_OK;\n<line59>}\n<line60>end_deserialize:\n<line61>sqlite3_finalize(pStmt);\n<line62>if( pData && (mFlags & SQLITE_DESERIALIZE_FREEONCLOSE)!=0 ){\n<line63>sqlite3_free(pData);\n<line64>}\n<line65>sqlite3_mutex_leave(db->mutex);\n<line66>return rc;\n<line67>}
----------------------------------------
Function: pcacheManageDirtyList
Content: <line0>static void pcacheManageDirtyList(PgHdr *pPage, u8 addRemove){\n<line1>PCache *p = pPage->pCache;\n<line2>pcacheTrace(("%p.DIRTYLIST.%s %d\n", p,\n<line3>addRemove==1 ? "REMOVE" : addRemove==2 ? "ADD" : "FRONT",\n<line4>pPage->pgno));\n<line5>if( addRemove & PCACHE_DIRTYLIST_REMOVE ){\n<line6>assert( pPage->pDirtyNext || pPage==p->pDirtyTail );\n<line7>assert( pPage->pDirtyPrev || pPage==p->pDirty );\n<line8>/* Update the PCache1.pSynced variable if necessary. */\n<line9>if( p->pSynced==pPage ){\n<line10>p->pSynced = pPage->pDirtyPrev;\n<line11>}\n<line12>if( pPage->pDirtyNext ){\n<line13>pPage->pDirtyNext->pDirtyPrev = pPage->pDirtyPrev;\n<line14>}else{\n<line15>assert( pPage==p->pDirtyTail );\n<line16>p->pDirtyTail = pPage->pDirtyPrev;\n<line17>}\n<line18>if( pPage->pDirtyPrev ){\n<line19>pPage->pDirtyPrev->pDirtyNext = pPage->pDirtyNext;\n<line20>}else{\n<line21>/* If there are now no dirty pages in the cache, set eCreate to 2.\n<line22>** This is an optimization that allows sqlite3PcacheFetch() to skip\n<line23>** searching for a dirty page to eject from the cache when it might\n<line24>** otherwise have to.  */\n<line25>assert( pPage==p->pDirty );\n<line26>p->pDirty = pPage->pDirtyNext;\n<line27>assert( p->bPurgeable || p->eCreate==2 );\n<line28>if( p->pDirty==0 ){         /*OPTIMIZATION-IF-TRUE*/\n<line29>assert( p->bPurgeable==0 || p->eCreate==1 );\n<line30>p->eCreate = 2;\n<line31>}\n<line32>}\n<line33>}\n<line34>if( addRemove & PCACHE_DIRTYLIST_ADD ){\n<line35>pPage->pDirtyPrev = 0;\n<line36>pPage->pDirtyNext = p->pDirty;\n<line37>if( pPage->pDirtyNext ){\n<line38>assert( pPage->pDirtyNext->pDirtyPrev==0 );\n<line39>pPage->pDirtyNext->pDirtyPrev = pPage;\n<line40>}else{\n<line41>p->pDirtyTail = pPage;\n<line42>if( p->bPurgeable ){\n<line43>assert( p->eCreate==2 );\n<line44>p->eCreate = 1;\n<line45>}\n<line46>}\n<line47>p->pDirty = pPage;\n<line48>/* If pSynced is NULL and this page has a clear NEED_SYNC flag, set\n<line49>** pSynced to point to it. Checking the NEED_SYNC flag is an\n<line50>** optimization, as if pSynced points to a page with the NEED_SYNC\n<line51>** flag set sqlite3PcacheFetchStress() searches through all newer\n<line52>** entries of the dirty-list for a page with NEED_SYNC clear anyway.  */\n<line53>if( !p->pSynced\n<line54>&& 0==(pPage->flags&PGHDR_NEED_SYNC)   /*OPTIMIZATION-IF-FALSE*/\n<line55>){\n<line56>p->pSynced = pPage;\n<line57>}\n<line58>}\n<line59>pcacheDump(p);\n<line60>}
----------------------------------------
Function: pcacheUnpin
Content: <line0>static void pcacheUnpin(PgHdr *p){\n<line1>if( p->pCache->bPurgeable ){\n<line2>pcacheTrace(("%p.UNPIN %d\n", p->pCache, p->pgno));\n<line3>sqlite3GlobalConfig.pcache2.xUnpin(p->pCache->pCache, p->pPage, 0);\n<line4>pcacheDump(p->pCache);\n<line5>}\n<line6>}
----------------------------------------
Function: numberOfCachePages
Content: <line0>static int numberOfCachePages(PCache *p){\n<line1>if( p->szCache>=0 ){\n<line2>/* IMPLEMENTATION-OF: R-42059-47211 If the argument N is positive then the\n<line3>** suggested cache size is set to N. */\n<line4>return p->szCache;\n<line5>}else{\n<line6>i64 n;\n<line7>/* IMPLEMENTATION-OF: R-59858-46238 If the argument N is negative, then the\n<line8>** number of cache pages is adjusted to be a number of pages that would\n<line9>** use approximately abs(N*1024) bytes of memory based on the current\n<line10>** page size. */\n<line11>n = ((-1024*(i64)p->szCache)/(p->szPage+p->szExtra));\n<line12>if( n>1000000000 ) n = 1000000000;\n<line13>return (int)n;\n<line14>}\n<line15>}
----------------------------------------
Function: pcacheFetchFinishWithInit
Content: <line0>static SQLITE_NOINLINE PgHdr *pcacheFetchFinishWithInit(\n<line1>PCache *pCache,             /* Obtain the page from this cache */\n<line2>Pgno pgno,                  /* Page number obtained */\n<line3>sqlite3_pcache_page *pPage  /* Page obtained by prior PcacheFetch() call */\n<line4>){\n<line5>PgHdr *pPgHdr;\n<line6>assert( pPage!=0 );\n<line7>pPgHdr = (PgHdr*)pPage->pExtra;\n<line8>assert( pPgHdr->pPage==0 );\n<line9>memset(&pPgHdr->pDirty, 0, sizeof(PgHdr) - offsetof(PgHdr,pDirty));\n<line10>pPgHdr->pPage = pPage;\n<line11>pPgHdr->pData = pPage->pBuf;\n<line12>pPgHdr->pExtra = (void *)&pPgHdr[1];\n<line13>memset(pPgHdr->pExtra, 0, 8);\n<line14>assert( EIGHT_BYTE_ALIGNMENT( pPgHdr->pExtra ) );\n<line15>pPgHdr->pCache = pCache;\n<line16>pPgHdr->pgno = pgno;\n<line17>pPgHdr->flags = PGHDR_CLEAN;\n<line18>return sqlite3PcacheFetchFinish(pCache,pgno,pPage);\n<line19>}
----------------------------------------
Function: pcacheMergeDirtyList
Content: <line0>static PgHdr *pcacheMergeDirtyList(PgHdr *pA, PgHdr *pB){\n<line1>PgHdr result, *pTail;\n<line2>pTail = &result;\n<line3>assert( pA!=0 && pB!=0 );\n<line4>for(;;){\n<line5>if( pA->pgno<pB->pgno ){\n<line6>pTail->pDirty = pA;\n<line7>pTail = pA;\n<line8>pA = pA->pDirty;\n<line9>if( pA==0 ){\n<line10>pTail->pDirty = pB;\n<line11>break;\n<line12>}\n<line13>}else{\n<line14>pTail->pDirty = pB;\n<line15>pTail = pB;\n<line16>pB = pB->pDirty;\n<line17>if( pB==0 ){\n<line18>pTail->pDirty = pA;\n<line19>break;\n<line20>}\n<line21>}\n<line22>}\n<line23>return result.pDirty;\n<line24>}
----------------------------------------
Function: pcacheSortDirtyList
Content: <line0>static PgHdr *pcacheSortDirtyList(PgHdr *pIn){\n<line1>PgHdr *a[N_SORT_BUCKET], *p;\n<line2>int i;\n<line3>memset(a, 0, sizeof(a));\n<line4>while( pIn ){\n<line5>p = pIn;\n<line6>pIn = p->pDirty;\n<line7>p->pDirty = 0;\n<line8>for(i=0; ALWAYS(i<N_SORT_BUCKET-1); i++){\n<line9>if( a[i]==0 ){\n<line10>a[i] = p;\n<line11>break;\n<line12>}else{\n<line13>p = pcacheMergeDirtyList(a[i], p);\n<line14>a[i] = 0;\n<line15>}\n<line16>}\n<line17>if( NEVER(i==N_SORT_BUCKET-1) ){\n<line18>/* To get here, there need to be 2^(N_SORT_BUCKET) elements in\n<line19>** the input list.  But that is impossible.\n<line20>*/\n<line21>a[i] = pcacheMergeDirtyList(a[i], p);\n<line22>}\n<line23>}\n<line24>p = a[0];\n<line25>for(i=1; i<N_SORT_BUCKET; i++){\n<line26>if( a[i]==0 ) continue;\n<line27>p = p ? pcacheMergeDirtyList(p, a[i]) : a[i];\n<line28>}\n<line29>return p;\n<line30>}
----------------------------------------
Function: pcache1InitBulk
Content: <line0>static int pcache1InitBulk(PCache1 *pCache){\n<line1>i64 szBulk;\n<line2>char *zBulk;\n<line3>if( pcache1.nInitPage==0 ) return 0;\n<line4>/* Do not bother with a bulk allocation if the cache size very small */\n<line5>if( pCache->nMax<3 ) return 0;\n<line6>sqlite3BeginBenignMalloc();\n<line7>if( pcache1.nInitPage>0 ){\n<line8>szBulk = pCache->szAlloc * (i64)pcache1.nInitPage;\n<line9>}else{\n<line10>szBulk = -1024 * (i64)pcache1.nInitPage;\n<line11>}\n<line12>if( szBulk > pCache->szAlloc*(i64)pCache->nMax ){\n<line13>szBulk = pCache->szAlloc*(i64)pCache->nMax;\n<line14>}\n<line15>zBulk = pCache->pBulk = sqlite3Malloc( szBulk );\n<line16>sqlite3EndBenignMalloc();\n<line17>if( zBulk ){\n<line18>int nBulk = sqlite3MallocSize(zBulk)/pCache->szAlloc;\n<line19>do{\n<line20>PgHdr1 *pX = (PgHdr1*)&zBulk[pCache->szPage];\n<line21>pX->page.pBuf = zBulk;\n<line22>pX->page.pExtra = (u8*)pX + ROUND8(sizeof(*pX));\n<line23>assert( EIGHT_BYTE_ALIGNMENT( pX->page.pExtra ) );\n<line24>pX->isBulkLocal = 1;\n<line25>pX->isAnchor = 0;\n<line26>pX->pNext = pCache->pFree;\n<line27>pX->pLruPrev = 0;           /* Initializing this saves a valgrind error */\n<line28>pCache->pFree = pX;\n<line29>zBulk += pCache->szAlloc;\n<line30>}while( --nBulk );\n<line31>}\n<line32>return pCache->pFree!=0;\n<line33>}
----------------------------------------
Function: pcache1Alloc
Content: <line0>static void *pcache1Alloc(int nByte){\n<line1>void *p = 0;\n<line2>assert( sqlite3_mutex_notheld(pcache1.grp.mutex) );\n<line3>if( nByte<=pcache1.szSlot ){\n<line4>sqlite3_mutex_enter(pcache1.mutex);\n<line5>p = (PgHdr1 *)pcache1.pFree;\n<line6>if( p ){\n<line7>pcache1.pFree = pcache1.pFree->pNext;\n<line8>pcache1.nFreeSlot--;\n<line9>AtomicStore(&pcache1.bUnderPressure,pcache1.nFreeSlot<pcache1.nReserve);\n<line10>assert( pcache1.nFreeSlot>=0 );\n<line11>sqlite3StatusHighwater(SQLITE_STATUS_PAGECACHE_SIZE, nByte);\n<line12>sqlite3StatusUp(SQLITE_STATUS_PAGECACHE_USED, 1);\n<line13>}\n<line14>sqlite3_mutex_leave(pcache1.mutex);\n<line15>}\n<line16>if( p==0 ){\n<line17>/* Memory is not available in the SQLITE_CONFIG_PAGECACHE pool.  Get\n<line18>** it from sqlite3Malloc instead.\n<line19>*/\n<line20>p = sqlite3Malloc(nByte);\n<line21>#ifndef SQLITE_DISABLE_PAGECACHE_OVERFLOW_STATS\n<line22>if( p ){\n<line23>int sz = sqlite3MallocSize(p);\n<line24>sqlite3_mutex_enter(pcache1.mutex);\n<line25>sqlite3StatusHighwater(SQLITE_STATUS_PAGECACHE_SIZE, nByte);\n<line26>sqlite3StatusUp(SQLITE_STATUS_PAGECACHE_OVERFLOW, sz);\n<line27>sqlite3_mutex_leave(pcache1.mutex);\n<line28>}\n<line29>#endif\n<line30>sqlite3MemdebugSetType(p, MEMTYPE_PCACHE);\n<line31>}\n<line32>return p;\n<line33>}
----------------------------------------
Function: pcache1Free
Content: <line0>static void pcache1Free(void *p){\n<line1>if( p==0 ) return;\n<line2>if( SQLITE_WITHIN(p, pcache1.pStart, pcache1.pEnd) ){\n<line3>PgFreeslot *pSlot;\n<line4>sqlite3_mutex_enter(pcache1.mutex);\n<line5>sqlite3StatusDown(SQLITE_STATUS_PAGECACHE_USED, 1);\n<line6>pSlot = (PgFreeslot*)p;\n<line7>pSlot->pNext = pcache1.pFree;\n<line8>pcache1.pFree = pSlot;\n<line9>pcache1.nFreeSlot++;\n<line10>AtomicStore(&pcache1.bUnderPressure,pcache1.nFreeSlot<pcache1.nReserve);\n<line11>assert( pcache1.nFreeSlot<=pcache1.nSlot );\n<line12>sqlite3_mutex_leave(pcache1.mutex);\n<line13>}else{\n<line14>assert( sqlite3MemdebugHasType(p, MEMTYPE_PCACHE) );\n<line15>sqlite3MemdebugSetType(p, MEMTYPE_HEAP);\n<line16>#ifndef SQLITE_DISABLE_PAGECACHE_OVERFLOW_STATS\n<line17>{\n<line18>int nFreed = 0;\n<line19>nFreed = sqlite3MallocSize(p);\n<line20>sqlite3_mutex_enter(pcache1.mutex);\n<line21>sqlite3StatusDown(SQLITE_STATUS_PAGECACHE_OVERFLOW, nFreed);\n<line22>sqlite3_mutex_leave(pcache1.mutex);\n<line23>}\n<line24>#endif\n<line25>sqlite3_free(p);\n<line26>}\n<line27>}
----------------------------------------
Function: pcache1AllocPage
Content: <line0>static PgHdr1 *pcache1AllocPage(PCache1 *pCache, int benignMalloc){\n<line1>PgHdr1 *p = 0;\n<line2>void *pPg;\n<line3>assert( sqlite3_mutex_held(pCache->pGroup->mutex) );\n<line4>if( pCache->pFree || (pCache->nPage==0 && pcache1InitBulk(pCache)) ){\n<line5>assert( pCache->pFree!=0 );\n<line6>p = pCache->pFree;\n<line7>pCache->pFree = p->pNext;\n<line8>p->pNext = 0;\n<line9>}else{\n<line10>#ifdef SQLITE_ENABLE_MEMORY_MANAGEMENT\n<line11>/* The group mutex must be released before pcache1Alloc() is called. This\n<line12>** is because it might call sqlite3_release_memory(), which assumes that\n<line13>** this mutex is not held. */\n<line14>assert( pcache1.separateCache==0 );\n<line15>assert( pCache->pGroup==&pcache1.grp );\n<line16>pcache1LeaveMutex(pCache->pGroup);\n<line17>#endif\n<line18>if( benignMalloc ){ sqlite3BeginBenignMalloc(); }\n<line19>pPg = pcache1Alloc(pCache->szAlloc);\n<line20>if( benignMalloc ){ sqlite3EndBenignMalloc(); }\n<line21>#ifdef SQLITE_ENABLE_MEMORY_MANAGEMENT\n<line22>pcache1EnterMutex(pCache->pGroup);\n<line23>#endif\n<line24>if( pPg==0 ) return 0;\n<line25>p = (PgHdr1 *)&((u8 *)pPg)[pCache->szPage];\n<line26>p->page.pBuf = pPg;\n<line27>p->page.pExtra = (u8*)p + ROUND8(sizeof(*p));\n<line28>assert( EIGHT_BYTE_ALIGNMENT( p->page.pExtra ) );\n<line29>p->isBulkLocal = 0;\n<line30>p->isAnchor = 0;\n<line31>p->pLruPrev = 0;           /* Initializing this saves a valgrind error */\n<line32>}\n<line33>(*pCache->pnPurgeable)++;\n<line34>return p;\n<line35>}
----------------------------------------
Function: pcache1FreePage
Content: <line0>static void pcache1FreePage(PgHdr1 *p){\n<line1>PCache1 *pCache;\n<line2>assert( p!=0 );\n<line3>pCache = p->pCache;\n<line4>assert( sqlite3_mutex_held(p->pCache->pGroup->mutex) );\n<line5>if( p->isBulkLocal ){\n<line6>p->pNext = pCache->pFree;\n<line7>pCache->pFree = p;\n<line8>}else{\n<line9>pcache1Free(p->page.pBuf);\n<line10>}\n<line11>(*pCache->pnPurgeable)--;\n<line12>}
----------------------------------------
Function: pcache1UnderMemoryPressure
Content: <line0>static int pcache1UnderMemoryPressure(PCache1 *pCache){\n<line1>if( pcache1.nSlot && (pCache->szPage+pCache->szExtra)<=pcache1.szSlot ){\n<line2>return AtomicLoad(&pcache1.bUnderPressure);\n<line3>}else{\n<line4>return sqlite3HeapNearlyFull();\n<line5>}\n<line6>}
----------------------------------------
Function: pcache1ResizeHash
Content: <line0>static void pcache1ResizeHash(PCache1 *p){\n<line1>PgHdr1 **apNew;\n<line2>u64 nNew;\n<line3>u32 i;\n<line4>assert( sqlite3_mutex_held(p->pGroup->mutex) );\n<line5>nNew = 2*(u64)p->nHash;\n<line6>if( nNew<256 ){\n<line7>nNew = 256;\n<line8>}\n<line9>pcache1LeaveMutex(p->pGroup);\n<line10>if( p->nHash ){ sqlite3BeginBenignMalloc(); }\n<line11>apNew = (PgHdr1 **)sqlite3MallocZero(sizeof(PgHdr1 *)*nNew);\n<line12>if( p->nHash ){ sqlite3EndBenignMalloc(); }\n<line13>pcache1EnterMutex(p->pGroup);\n<line14>if( apNew ){\n<line15>for(i=0; i<p->nHash; i++){\n<line16>PgHdr1 *pPage;\n<line17>PgHdr1 *pNext = p->apHash[i];\n<line18>while( (pPage = pNext)!=0 ){\n<line19>unsigned int h = pPage->iKey % nNew;\n<line20>pNext = pPage->pNext;\n<line21>pPage->pNext = apNew[h];\n<line22>apNew[h] = pPage;\n<line23>}\n<line24>}\n<line25>sqlite3_free(p->apHash);\n<line26>p->apHash = apNew;\n<line27>p->nHash = nNew;\n<line28>}\n<line29>}
----------------------------------------
Function: pcache1PinPage
Content: <line0>static PgHdr1 *pcache1PinPage(PgHdr1 *pPage){\n<line1>assert( pPage!=0 );\n<line2>assert( PAGE_IS_UNPINNED(pPage) );\n<line3>assert( pPage->pLruNext );\n<line4>assert( pPage->pLruPrev );\n<line5>assert( sqlite3_mutex_held(pPage->pCache->pGroup->mutex) );\n<line6>pPage->pLruPrev->pLruNext = pPage->pLruNext;\n<line7>pPage->pLruNext->pLruPrev = pPage->pLruPrev;\n<line8>pPage->pLruNext = 0;\n<line9>/* pPage->pLruPrev = 0;\n<line10>** No need to clear pLruPrev as it is never accessed if pLruNext is 0 */\n<line11>assert( pPage->isAnchor==0 );\n<line12>assert( pPage->pCache->pGroup->lru.isAnchor==1 );\n<line13>pPage->pCache->nRecyclable--;\n<line14>return pPage;\n<line15>}
----------------------------------------
Function: pcache1RemoveFromHash
Content: <line0>static void pcache1RemoveFromHash(PgHdr1 *pPage, int freeFlag){\n<line1>unsigned int h;\n<line2>PCache1 *pCache = pPage->pCache;\n<line3>PgHdr1 **pp;\n<line4>assert( sqlite3_mutex_held(pCache->pGroup->mutex) );\n<line5>h = pPage->iKey % pCache->nHash;\n<line6>for(pp=&pCache->apHash[h]; (*pp)!=pPage; pp=&(*pp)->pNext);\n<line7>*pp = (*pp)->pNext;\n<line8>pCache->nPage--;\n<line9>if( freeFlag ) pcache1FreePage(pPage);\n<line10>}
----------------------------------------
Function: pcache1EnforceMaxPage
Content: <line0>static void pcache1EnforceMaxPage(PCache1 *pCache){\n<line1>PGroup *pGroup = pCache->pGroup;\n<line2>PgHdr1 *p;\n<line3>assert( sqlite3_mutex_held(pGroup->mutex) );\n<line4>while( pGroup->nPurgeable>pGroup->nMaxPage\n<line5>&& (p=pGroup->lru.pLruPrev)->isAnchor==0\n<line6>){\n<line7>assert( p->pCache->pGroup==pGroup );\n<line8>assert( PAGE_IS_UNPINNED(p) );\n<line9>pcache1PinPage(p);\n<line10>pcache1RemoveFromHash(p, 1);\n<line11>}\n<line12>if( pCache->nPage==0 && pCache->pBulk ){\n<line13>sqlite3_free(pCache->pBulk);\n<line14>pCache->pBulk = pCache->pFree = 0;\n<line15>}\n<line16>}
----------------------------------------
Function: pcache1TruncateUnsafe
Content: <line0>static void pcache1TruncateUnsafe(\n<line1>PCache1 *pCache,             /* The cache to truncate */\n<line2>unsigned int iLimit          /* Drop pages with this pgno or larger */\n<line3>){\n<line4>TESTONLY( int nPage = 0; )  /* To assert pCache->nPage is correct */\n<line5>unsigned int h, iStop;\n<line6>assert( sqlite3_mutex_held(pCache->pGroup->mutex) );\n<line7>assert( pCache->iMaxKey >= iLimit );\n<line8>assert( pCache->nHash > 0 );\n<line9>if( pCache->iMaxKey - iLimit < pCache->nHash ){\n<line10>/* If we are just shaving the last few pages off the end of the\n<line11>** cache, then there is no point in scanning the entire hash table.\n<line12>** Only scan those hash slots that might contain pages that need to\n<line13>** be removed. */\n<line14>h = iLimit % pCache->nHash;\n<line15>iStop = pCache->iMaxKey % pCache->nHash;\n<line16>TESTONLY( nPage = -10; )  /* Disable the pCache->nPage validity check */\n<line17>}else{\n<line18>/* This is the general case where many pages are being removed.\n<line19>** It is necessary to scan the entire hash table */\n<line20>h = pCache->nHash/2;\n<line21>iStop = h - 1;\n<line22>}\n<line23>for(;;){\n<line24>PgHdr1 **pp;\n<line25>PgHdr1 *pPage;\n<line26>assert( h<pCache->nHash );\n<line27>pp = &pCache->apHash[h];\n<line28>while( (pPage = *pp)!=0 ){\n<line29>if( pPage->iKey>=iLimit ){\n<line30>pCache->nPage--;\n<line31>*pp = pPage->pNext;\n<line32>if( PAGE_IS_UNPINNED(pPage) ) pcache1PinPage(pPage);\n<line33>pcache1FreePage(pPage);\n<line34>}else{\n<line35>pp = &pPage->pNext;\n<line36>TESTONLY( if( nPage>=0 ) nPage++; )\n<line37>}\n<line38>}\n<line39>if( h==iStop ) break;\n<line40>h = (h+1) % pCache->nHash;\n<line41>}\n<line42>assert( nPage<0 || pCache->nPage==(unsigned)nPage );\n<line43>}
----------------------------------------
Function: pcache1Init
Content: <line0>static int pcache1Init(void *NotUsed){\n<line1>UNUSED_PARAMETER(NotUsed);\n<line2>assert( pcache1.isInit==0 );\n<line3>memset(&pcache1, 0, sizeof(pcache1));\n<line4>/*\n<line5>** The pcache1.separateCache variable is true if each PCache has its own\n<line6>** private PGroup (mode-1).  pcache1.separateCache is false if the single\n<line7>** PGroup in pcache1.grp is used for all page caches (mode-2).\n<line8>**\n<line9>**   *  Always use a unified cache (mode-2) if ENABLE_MEMORY_MANAGEMENT\n<line10>**\n<line11>**   *  Use a unified cache in single-threaded applications that have\n<line12>**      configured a start-time buffer for use as page-cache memory using\n<line13>**      sqlite3_config(SQLITE_CONFIG_PAGECACHE, pBuf, sz, N) with non-NULL\n<line14>**      pBuf argument.\n<line15>**\n<line16>**   *  Otherwise use separate caches (mode-1)\n<line17>*/\n<line18>#if defined(SQLITE_ENABLE_MEMORY_MANAGEMENT)\n<line19>pcache1.separateCache = 0;\n<line20>#elif SQLITE_THREADSAFE\n<line21>pcache1.separateCache = sqlite3GlobalConfig.pPage==0\n<line22>|| sqlite3GlobalConfig.bCoreMutex>0;\n<line23>#else\n<line24>pcache1.separateCache = sqlite3GlobalConfig.pPage==0;\n<line25>#endif\n<line26>#if SQLITE_THREADSAFE\n<line27>if( sqlite3GlobalConfig.bCoreMutex ){\n<line28>pcache1.grp.mutex = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_LRU);\n<line29>pcache1.mutex = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_PMEM);\n<line30>}\n<line31>#endif\n<line32>if( pcache1.separateCache\n<line33>&& sqlite3GlobalConfig.nPage!=0\n<line34>&& sqlite3GlobalConfig.pPage==0\n<line35>){\n<line36>pcache1.nInitPage = sqlite3GlobalConfig.nPage;\n<line37>}else{\n<line38>pcache1.nInitPage = 0;\n<line39>}\n<line40>pcache1.grp.mxPinned = 10;\n<line41>pcache1.isInit = 1;\n<line42>return SQLITE_OK;\n<line43>}
----------------------------------------
Function: pcache1Shutdown
Content: <line0>static void pcache1Shutdown(void *NotUsed){\n<line1>UNUSED_PARAMETER(NotUsed);\n<line2>assert( pcache1.isInit!=0 );\n<line3>memset(&pcache1, 0, sizeof(pcache1));\n<line4>}
----------------------------------------
Function: pcache1Create
Content: <line0>static sqlite3_pcache *pcache1Create(int szPage, int szExtra, int bPurgeable){\n<line1>PCache1 *pCache;      /* The newly created page cache */\n<line2>PGroup *pGroup;       /* The group the new page cache will belong to */\n<line3>i64 sz;               /* Bytes of memory required to allocate the new cache */\n<line4>assert( (szPage & (szPage-1))==0 && szPage>=512 && szPage<=65536 );\n<line5>assert( szExtra < 300 );\n<line6>sz = sizeof(PCache1) + sizeof(PGroup)*pcache1.separateCache;\n<line7>pCache = (PCache1 *)sqlite3MallocZero(sz);\n<line8>if( pCache ){\n<line9>if( pcache1.separateCache ){\n<line10>pGroup = (PGroup*)&pCache[1];\n<line11>pGroup->mxPinned = 10;\n<line12>}else{\n<line13>pGroup = &pcache1.grp;\n<line14>}\n<line15>pcache1EnterMutex(pGroup);\n<line16>if( pGroup->lru.isAnchor==0 ){\n<line17>pGroup->lru.isAnchor = 1;\n<line18>pGroup->lru.pLruPrev = pGroup->lru.pLruNext = &pGroup->lru;\n<line19>}\n<line20>pCache->pGroup = pGroup;\n<line21>pCache->szPage = szPage;\n<line22>pCache->szExtra = szExtra;\n<line23>pCache->szAlloc = szPage + szExtra + ROUND8(sizeof(PgHdr1));\n<line24>pCache->bPurgeable = (bPurgeable ? 1 : 0);\n<line25>pcache1ResizeHash(pCache);\n<line26>if( bPurgeable ){\n<line27>pCache->nMin = 10;\n<line28>pGroup->nMinPage += pCache->nMin;\n<line29>pGroup->mxPinned = pGroup->nMaxPage + 10 - pGroup->nMinPage;\n<line30>pCache->pnPurgeable = &pGroup->nPurgeable;\n<line31>}else{\n<line32>pCache->pnPurgeable = &pCache->nPurgeableDummy;\n<line33>}\n<line34>pcache1LeaveMutex(pGroup);\n<line35>if( pCache->nHash==0 ){\n<line36>pcache1Destroy((sqlite3_pcache*)pCache);\n<line37>pCache = 0;\n<line38>}\n<line39>}\n<line40>return (sqlite3_pcache *)pCache;\n<line41>}
----------------------------------------
Function: pcache1Cachesize
Content: <line0>static void pcache1Cachesize(sqlite3_pcache *p, int nMax){\n<line1>PCache1 *pCache = (PCache1 *)p;\n<line2>u32 n;\n<line3>assert( nMax>=0 );\n<line4>if( pCache->bPurgeable ){\n<line5>PGroup *pGroup = pCache->pGroup;\n<line6>pcache1EnterMutex(pGroup);\n<line7>n = (u32)nMax;\n<line8>if( n > 0x7fff0000 - pGroup->nMaxPage + pCache->nMax ){\n<line9>n = 0x7fff0000 - pGroup->nMaxPage + pCache->nMax;\n<line10>}\n<line11>pGroup->nMaxPage += (n - pCache->nMax);\n<line12>pGroup->mxPinned = pGroup->nMaxPage + 10 - pGroup->nMinPage;\n<line13>pCache->nMax = n;\n<line14>pCache->n90pct = pCache->nMax*9/10;\n<line15>pcache1EnforceMaxPage(pCache);\n<line16>pcache1LeaveMutex(pGroup);\n<line17>}\n<line18>}
----------------------------------------
Function: pcache1Shrink
Content: <line0>static void pcache1Shrink(sqlite3_pcache *p){\n<line1>PCache1 *pCache = (PCache1*)p;\n<line2>if( pCache->bPurgeable ){\n<line3>PGroup *pGroup = pCache->pGroup;\n<line4>unsigned int savedMaxPage;\n<line5>pcache1EnterMutex(pGroup);\n<line6>savedMaxPage = pGroup->nMaxPage;\n<line7>pGroup->nMaxPage = 0;\n<line8>pcache1EnforceMaxPage(pCache);\n<line9>pGroup->nMaxPage = savedMaxPage;\n<line10>pcache1LeaveMutex(pGroup);\n<line11>}\n<line12>}
----------------------------------------
Function: pcache1Pagecount
Content: <line0>static int pcache1Pagecount(sqlite3_pcache *p){\n<line1>int n;\n<line2>PCache1 *pCache = (PCache1*)p;\n<line3>pcache1EnterMutex(pCache->pGroup);\n<line4>n = pCache->nPage;\n<line5>pcache1LeaveMutex(pCache->pGroup);\n<line6>return n;\n<line7>}
----------------------------------------
Function: pcache1FetchStage2
Content: <line0>static SQLITE_NOINLINE PgHdr1 *pcache1FetchStage2(\n<line1>PCache1 *pCache,\n<line2>unsigned int iKey,\n<line3>int createFlag\n<line4>){\n<line5>unsigned int nPinned;\n<line6>PGroup *pGroup = pCache->pGroup;\n<line7>PgHdr1 *pPage = 0;\n<line8>/* Step 3: Abort if createFlag is 1 but the cache is nearly full */\n<line9>assert( pCache->nPage >= pCache->nRecyclable );\n<line10>nPinned = pCache->nPage - pCache->nRecyclable;\n<line11>assert( pGroup->mxPinned == pGroup->nMaxPage + 10 - pGroup->nMinPage );\n<line12>assert( pCache->n90pct == pCache->nMax*9/10 );\n<line13>if( createFlag==1 && (\n<line14>nPinned>=pGroup->mxPinned\n<line15>|| nPinned>=pCache->n90pct\n<line16>|| (pcache1UnderMemoryPressure(pCache) && pCache->nRecyclable<nPinned)\n<line17>)){\n<line18>return 0;\n<line19>}\n<line20>if( pCache->nPage>=pCache->nHash ) pcache1ResizeHash(pCache);\n<line21>assert( pCache->nHash>0 && pCache->apHash );\n<line22>/* Step 4. Try to recycle a page. */\n<line23>if( pCache->bPurgeable\n<line24>&& !pGroup->lru.pLruPrev->isAnchor\n<line25>&& ((pCache->nPage+1>=pCache->nMax) || pcache1UnderMemoryPressure(pCache))\n<line26>){\n<line27>PCache1 *pOther;\n<line28>pPage = pGroup->lru.pLruPrev;\n<line29>assert( PAGE_IS_UNPINNED(pPage) );\n<line30>pcache1RemoveFromHash(pPage, 0);\n<line31>pcache1PinPage(pPage);\n<line32>pOther = pPage->pCache;\n<line33>if( pOther->szAlloc != pCache->szAlloc ){\n<line34>pcache1FreePage(pPage);\n<line35>pPage = 0;\n<line36>}else{\n<line37>pGroup->nPurgeable -= (pOther->bPurgeable - pCache->bPurgeable);\n<line38>}\n<line39>}\n<line40>/* Step 5. If a usable page buffer has still not been found,\n<line41>** attempt to allocate a new one.\n<line42>*/\n<line43>if( !pPage ){\n<line44>pPage = pcache1AllocPage(pCache, createFlag==1);\n<line45>}\n<line46>if( pPage ){\n<line47>unsigned int h = iKey % pCache->nHash;\n<line48>pCache->nPage++;\n<line49>pPage->iKey = iKey;\n<line50>pPage->pNext = pCache->apHash[h];\n<line51>pPage->pCache = pCache;\n<line52>pPage->pLruNext = 0;\n<line53>/* pPage->pLruPrev = 0;\n<line54>** No need to clear pLruPrev since it is not accessed when pLruNext==0 */\n<line55>*(void **)pPage->page.pExtra = 0;\n<line56>pCache->apHash[h] = pPage;\n<line57>if( iKey>pCache->iMaxKey ){\n<line58>pCache->iMaxKey = iKey;\n<line59>}\n<line60>}\n<line61>return pPage;\n<line62>}
----------------------------------------
Function: pcache1FetchNoMutex
Content: <line0>static PgHdr1 *pcache1FetchNoMutex(\n<line1>sqlite3_pcache *p,\n<line2>unsigned int iKey,\n<line3>int createFlag\n<line4>){\n<line5>PCache1 *pCache = (PCache1 *)p;\n<line6>PgHdr1 *pPage = 0;\n<line7>/* Step 1: Search the hash table for an existing entry. */\n<line8>pPage = pCache->apHash[iKey % pCache->nHash];\n<line9>while( pPage && pPage->iKey!=iKey ){ pPage = pPage->pNext; }\n<line10>/* Step 2: If the page was found in the hash table, then return it.\n<line11>** If the page was not in the hash table and createFlag is 0, abort.\n<line12>** Otherwise (page not in hash and createFlag!=0) continue with\n<line13>** subsequent steps to try to create the page. */\n<line14>if( pPage ){\n<line15>if( PAGE_IS_UNPINNED(pPage) ){\n<line16>return pcache1PinPage(pPage);\n<line17>}else{\n<line18>return pPage;\n<line19>}\n<line20>}else if( createFlag ){\n<line21>/* Steps 3, 4, and 5 implemented by this subroutine */\n<line22>return pcache1FetchStage2(pCache, iKey, createFlag);\n<line23>}else{\n<line24>return 0;\n<line25>}\n<line26>}
----------------------------------------
Function: pcache1Fetch
Content: <line0>static sqlite3_pcache_page *pcache1Fetch(\n<line1>sqlite3_pcache *p,\n<line2>unsigned int iKey,\n<line3>int createFlag\n<line4>){\n<line5>#if PCACHE1_MIGHT_USE_GROUP_MUTEX || defined(SQLITE_DEBUG)\n<line6>PCache1 *pCache = (PCache1 *)p;\n<line7>#endif\n<line8>assert( offsetof(PgHdr1,page)==0 );\n<line9>assert( pCache->bPurgeable || createFlag!=1 );\n<line10>assert( pCache->bPurgeable || pCache->nMin==0 );\n<line11>assert( pCache->bPurgeable==0 || pCache->nMin==10 );\n<line12>assert( pCache->nMin==0 || pCache->bPurgeable );\n<line13>assert( pCache->nHash>0 );\n<line14>#if PCACHE1_MIGHT_USE_GROUP_MUTEX\n<line15>if( pCache->pGroup->mutex ){\n<line16>return (sqlite3_pcache_page*)pcache1FetchWithMutex(p, iKey, createFlag);\n<line17>}else\n<line18>#endif\n<line19>{\n<line20>return (sqlite3_pcache_page*)pcache1FetchNoMutex(p, iKey, createFlag);\n<line21>}\n<line22>}
----------------------------------------
Function: pcache1Unpin
Content: <line0>static void pcache1Unpin(\n<line1>sqlite3_pcache *p,\n<line2>sqlite3_pcache_page *pPg,\n<line3>int reuseUnlikely\n<line4>){\n<line5>PCache1 *pCache = (PCache1 *)p;\n<line6>PgHdr1 *pPage = (PgHdr1 *)pPg;\n<line7>PGroup *pGroup = pCache->pGroup;\n<line8>assert( pPage->pCache==pCache );\n<line9>pcache1EnterMutex(pGroup);\n<line10>/* It is an error to call this function if the page is already\n<line11>** part of the PGroup LRU list.\n<line12>*/\n<line13>assert( pPage->pLruNext==0 );\n<line14>assert( PAGE_IS_PINNED(pPage) );\n<line15>if( reuseUnlikely || pGroup->nPurgeable>pGroup->nMaxPage ){\n<line16>pcache1RemoveFromHash(pPage, 1);\n<line17>}else{\n<line18>/* Add the page to the PGroup LRU list. */\n<line19>PgHdr1 **ppFirst = &pGroup->lru.pLruNext;\n<line20>pPage->pLruPrev = &pGroup->lru;\n<line21>(pPage->pLruNext = *ppFirst)->pLruPrev = pPage;\n<line22>*ppFirst = pPage;\n<line23>pCache->nRecyclable++;\n<line24>}\n<line25>pcache1LeaveMutex(pCache->pGroup);\n<line26>}
----------------------------------------
Function: pcache1Rekey
Content: <line0>static void pcache1Rekey(\n<line1>sqlite3_pcache *p,\n<line2>sqlite3_pcache_page *pPg,\n<line3>unsigned int iOld,\n<line4>unsigned int iNew\n<line5>){\n<line6>PCache1 *pCache = (PCache1 *)p;\n<line7>PgHdr1 *pPage = (PgHdr1 *)pPg;\n<line8>PgHdr1 **pp;\n<line9>unsigned int hOld, hNew;\n<line10>assert( pPage->iKey==iOld );\n<line11>assert( pPage->pCache==pCache );\n<line12>assert( iOld!=iNew );               /* The page number really is changing */\n<line13>pcache1EnterMutex(pCache->pGroup);\n<line14>assert( pcache1FetchNoMutex(p, iOld, 0)==pPage ); /* pPg really is iOld */\n<line15>hOld = iOld%pCache->nHash;\n<line16>pp = &pCache->apHash[hOld];\n<line17>while( (*pp)!=pPage ){\n<line18>pp = &(*pp)->pNext;\n<line19>}\n<line20>*pp = pPage->pNext;\n<line21>assert( pcache1FetchNoMutex(p, iNew, 0)==0 ); /* iNew not in cache */\n<line22>hNew = iNew%pCache->nHash;\n<line23>pPage->iKey = iNew;\n<line24>pPage->pNext = pCache->apHash[hNew];\n<line25>pCache->apHash[hNew] = pPage;\n<line26>if( iNew>pCache->iMaxKey ){\n<line27>pCache->iMaxKey = iNew;\n<line28>}\n<line29>pcache1LeaveMutex(pCache->pGroup);\n<line30>}
----------------------------------------
Function: pcache1Truncate
Content: <line0>static void pcache1Truncate(sqlite3_pcache *p, unsigned int iLimit){\n<line1>PCache1 *pCache = (PCache1 *)p;\n<line2>pcache1EnterMutex(pCache->pGroup);\n<line3>if( iLimit<=pCache->iMaxKey ){\n<line4>pcache1TruncateUnsafe(pCache, iLimit);\n<line5>pCache->iMaxKey = iLimit-1;\n<line6>}\n<line7>pcache1LeaveMutex(pCache->pGroup);\n<line8>}
----------------------------------------
Function: pcache1Destroy
Content: <line0>static void pcache1Destroy(sqlite3_pcache *p){\n<line1>PCache1 *pCache = (PCache1 *)p;\n<line2>PGroup *pGroup = pCache->pGroup;\n<line3>assert( pCache->bPurgeable || (pCache->nMax==0 && pCache->nMin==0) );\n<line4>pcache1EnterMutex(pGroup);\n<line5>if( pCache->nPage ) pcache1TruncateUnsafe(pCache, 0);\n<line6>assert( pGroup->nMaxPage >= pCache->nMax );\n<line7>pGroup->nMaxPage -= pCache->nMax;\n<line8>assert( pGroup->nMinPage >= pCache->nMin );\n<line9>pGroup->nMinPage -= pCache->nMin;\n<line10>pGroup->mxPinned = pGroup->nMaxPage + 10 - pGroup->nMinPage;\n<line11>pcache1EnforceMaxPage(pCache);\n<line12>pcache1LeaveMutex(pGroup);\n<line13>sqlite3_free(pCache->pBulk);\n<line14>sqlite3_free(pCache->apHash);\n<line15>sqlite3_free(pCache);\n<line16>}
----------------------------------------
Function: rowSetEntryAlloc
Content: <line0>static struct RowSetEntry *rowSetEntryAlloc(RowSet *p){\n<line1>assert( p!=0 );\n<line2>if( p->nFresh==0 ){  /*OPTIMIZATION-IF-FALSE*/\n<line3>/* We could allocate a fresh RowSetEntry each time one is needed, but it\n<line4>** is more efficient to pull a preallocated entry from the pool */\n<line5>struct RowSetChunk *pNew;\n<line6>pNew = sqlite3DbMallocRawNN(p->db, sizeof(*pNew));\n<line7>if( pNew==0 ){\n<line8>return 0;\n<line9>}\n<line10>pNew->pNextChunk = p->pChunk;\n<line11>p->pChunk = pNew;\n<line12>p->pFresh = pNew->aEntry;\n<line13>p->nFresh = ROWSET_ENTRY_PER_CHUNK;\n<line14>}\n<line15>p->nFresh--;\n<line16>return p->pFresh++;\n<line17>}
----------------------------------------
Function: rowSetEntryMerge
Content: <line0>static struct RowSetEntry *rowSetEntryMerge(\n<line1>struct RowSetEntry *pA,    /* First sorted list to be merged */\n<line2>struct RowSetEntry *pB     /* Second sorted list to be merged */\n<line3>){\n<line4>struct RowSetEntry head;\n<line5>struct RowSetEntry *pTail;\n<line6>pTail = &head;\n<line7>assert( pA!=0 && pB!=0 );\n<line8>for(;;){\n<line9>assert( pA->pRight==0 || pA->v<=pA->pRight->v );\n<line10>assert( pB->pRight==0 || pB->v<=pB->pRight->v );\n<line11>if( pA->v<=pB->v ){\n<line12>if( pA->v<pB->v ) pTail = pTail->pRight = pA;\n<line13>pA = pA->pRight;\n<line14>if( pA==0 ){\n<line15>pTail->pRight = pB;\n<line16>break;\n<line17>}\n<line18>}else{\n<line19>pTail = pTail->pRight = pB;\n<line20>pB = pB->pRight;\n<line21>if( pB==0 ){\n<line22>pTail->pRight = pA;\n<line23>break;\n<line24>}\n<line25>}\n<line26>}\n<line27>return head.pRight;\n<line28>}
----------------------------------------
Function: rowSetEntrySort
Content: <line0>static struct RowSetEntry *rowSetEntrySort(struct RowSetEntry *pIn){\n<line1>unsigned int i;\n<line2>struct RowSetEntry *pNext, *aBucket[40];\n<line3>memset(aBucket, 0, sizeof(aBucket));\n<line4>while( pIn ){\n<line5>pNext = pIn->pRight;\n<line6>pIn->pRight = 0;\n<line7>for(i=0; aBucket[i]; i++){\n<line8>pIn = rowSetEntryMerge(aBucket[i], pIn);\n<line9>aBucket[i] = 0;\n<line10>}\n<line11>aBucket[i] = pIn;\n<line12>pIn = pNext;\n<line13>}\n<line14>pIn = aBucket[0];\n<line15>for(i=1; i<sizeof(aBucket)/sizeof(aBucket[0]); i++){\n<line16>if( aBucket[i]==0 ) continue;\n<line17>pIn = pIn ? rowSetEntryMerge(pIn, aBucket[i]) : aBucket[i];\n<line18>}\n<line19>return pIn;\n<line20>}
----------------------------------------
Function: rowSetTreeToList
Content: <line0>static void rowSetTreeToList(\n<line1>struct RowSetEntry *pIn,         /* Root of the input tree */\n<line2>struct RowSetEntry **ppFirst,    /* Write head of the output list here */\n<line3>struct RowSetEntry **ppLast      /* Write tail of the output list here */\n<line4>){\n<line5>assert( pIn!=0 );\n<line6>if( pIn->pLeft ){\n<line7>struct RowSetEntry *p;\n<line8>rowSetTreeToList(pIn->pLeft, ppFirst, &p);\n<line9>p->pRight = pIn;\n<line10>}else{\n<line11>*ppFirst = pIn;\n<line12>}\n<line13>if( pIn->pRight ){\n<line14>rowSetTreeToList(pIn->pRight, &pIn->pRight, ppLast);\n<line15>}else{\n<line16>*ppLast = pIn;\n<line17>}\n<line18>assert( (*ppLast)->pRight==0 );\n<line19>}
----------------------------------------
Function: rowSetNDeepTree
Content: <line0>static struct RowSetEntry *rowSetNDeepTree(\n<line1>struct RowSetEntry **ppList,\n<line2>int iDepth\n<line3>){\n<line4>struct RowSetEntry *p;         /* Root of the new tree */\n<line5>struct RowSetEntry *pLeft;     /* Left subtree */\n<line6>if( *ppList==0 ){ /*OPTIMIZATION-IF-TRUE*/\n<line7>/* Prevent unnecessary deep recursion when we run out of entries */\n<line8>return 0;\n<line9>}\n<line10>if( iDepth>1 ){   /*OPTIMIZATION-IF-TRUE*/\n<line11>/* This branch causes a *balanced* tree to be generated.  A valid tree\n<line12>** is still generated without this branch, but the tree is wildly\n<line13>** unbalanced and inefficient. */\n<line14>pLeft = rowSetNDeepTree(ppList, iDepth-1);\n<line15>p = *ppList;\n<line16>if( p==0 ){     /*OPTIMIZATION-IF-FALSE*/\n<line17>/* It is safe to always return here, but the resulting tree\n<line18>** would be unbalanced */\n<line19>return pLeft;\n<line20>}\n<line21>p->pLeft = pLeft;\n<line22>*ppList = p->pRight;\n<line23>p->pRight = rowSetNDeepTree(ppList, iDepth-1);\n<line24>}else{\n<line25>p = *ppList;\n<line26>*ppList = p->pRight;\n<line27>p->pLeft = p->pRight = 0;\n<line28>}\n<line29>return p;\n<line30>}
----------------------------------------
Function: rowSetListToTree
Content: <line0>static struct RowSetEntry *rowSetListToTree(struct RowSetEntry *pList){\n<line1>int iDepth;           /* Depth of the tree so far */\n<line2>struct RowSetEntry *p;       /* Current tree root */\n<line3>struct RowSetEntry *pLeft;   /* Left subtree */\n<line4>assert( pList!=0 );\n<line5>p = pList;\n<line6>pList = p->pRight;\n<line7>p->pLeft = p->pRight = 0;\n<line8>for(iDepth=1; pList; iDepth++){\n<line9>pLeft = p;\n<line10>p = pList;\n<line11>pList = p->pRight;\n<line12>p->pLeft = pLeft;\n<line13>p->pRight = rowSetNDeepTree(&pList, iDepth);\n<line14>}\n<line15>return p;\n<line16>}
----------------------------------------
Function: setGetterMethod
Content: <line0>static void setGetterMethod(Pager *pPager){\n<line1>if( pPager->errCode ){\n<line2>pPager->xGet = getPageError;\n<line3>#if SQLITE_MAX_MMAP_SIZE>0\n<line4>}else if( USEFETCH(pPager) ){\n<line5>pPager->xGet = getPageMMap;\n<line6>#endif /* SQLITE_MAX_MMAP_SIZE>0 */\n<line7>}else{\n<line8>pPager->xGet = getPageNormal;\n<line9>}\n<line10>}
----------------------------------------
Function: subjRequiresPage
Content: <line0>static int subjRequiresPage(PgHdr *pPg){\n<line1>Pager *pPager = pPg->pPager;\n<line2>PagerSavepoint *p;\n<line3>Pgno pgno = pPg->pgno;\n<line4>int i;\n<line5>for(i=0; i<pPager->nSavepoint; i++){\n<line6>p = &pPager->aSavepoint[i];\n<line7>if( p->nOrig>=pgno && 0==sqlite3BitvecTestNotNull(p->pInSavepoint, pgno) ){\n<line8>for(i=i+1; i<pPager->nSavepoint; i++){\n<line9>pPager->aSavepoint[i].bTruncateOnRelease = 0;\n<line10>}\n<line11>return 1;\n<line12>}\n<line13>}\n<line14>return 0;\n<line15>}
----------------------------------------
Function: read32bits
Content: <line0>static int read32bits(sqlite3_file *fd, i64 offset, u32 *pRes){\n<line1>unsigned char ac[4];\n<line2>int rc = sqlite3OsRead(fd, ac, sizeof(ac), offset);\n<line3>if( rc==SQLITE_OK ){\n<line4>*pRes = sqlite3Get4byte(ac);\n<line5>}\n<line6>return rc;\n<line7>}
----------------------------------------
Function: write32bits
Content: <line0>static int write32bits(sqlite3_file *fd, i64 offset, u32 val){\n<line1>char ac[4];\n<line2>put32bits(ac, val);\n<line3>return sqlite3OsWrite(fd, ac, 4, offset);\n<line4>}
----------------------------------------
Function: pagerUnlockDb
Content: <line0>static int pagerUnlockDb(Pager *pPager, int eLock){\n<line1>int rc = SQLITE_OK;\n<line2>assert( !pPager->exclusiveMode || pPager->eLock==eLock );\n<line3>assert( eLock==NO_LOCK || eLock==SHARED_LOCK );\n<line4>assert( eLock!=NO_LOCK || pagerUseWal(pPager)==0 );\n<line5>if( isOpen(pPager->fd) ){\n<line6>assert( pPager->eLock>=eLock );\n<line7>rc = pPager->noLock ? SQLITE_OK : sqlite3OsUnlock(pPager->fd, eLock);\n<line8>if( pPager->eLock!=UNKNOWN_LOCK ){\n<line9>pPager->eLock = (u8)eLock;\n<line10>}\n<line11>IOTRACE(("UNLOCK %p %d\n", pPager, eLock))\n<line12>}\n<line13>pPager->changeCountDone = pPager->tempFile; /* ticket fb3b3024ea238d5c */\n<line14>return rc;\n<line15>}
----------------------------------------
Function: pagerLockDb
Content: <line0>static int pagerLockDb(Pager *pPager, int eLock){\n<line1>int rc = SQLITE_OK;\n<line2>assert( eLock==SHARED_LOCK || eLock==RESERVED_LOCK || eLock==EXCLUSIVE_LOCK );\n<line3>if( pPager->eLock<eLock || pPager->eLock==UNKNOWN_LOCK ){\n<line4>rc = pPager->noLock ? SQLITE_OK : sqlite3OsLock(pPager->fd, eLock);\n<line5>if( rc==SQLITE_OK && (pPager->eLock!=UNKNOWN_LOCK||eLock==EXCLUSIVE_LOCK) ){\n<line6>pPager->eLock = (u8)eLock;\n<line7>IOTRACE(("LOCK %p %d\n", pPager, eLock))\n<line8>}\n<line9>}\n<line10>return rc;\n<line11>}
----------------------------------------
Function: jrnlBufferSize
Content: <line0>static int jrnlBufferSize(Pager *pPager){\n<line1>assert( !MEMDB );\n<line2>#if defined(SQLITE_ENABLE_ATOMIC_WRITE) \\n<line3>|| defined(SQLITE_ENABLE_BATCH_ATOMIC_WRITE)\n<line4>int dc;                           /* Device characteristics */\n<line5>assert( isOpen(pPager->fd) );\n<line6>dc = sqlite3OsDeviceCharacteristics(pPager->fd);\n<line7>#else\n<line8>UNUSED_PARAMETER(pPager);\n<line9>#endif\n<line10>#ifdef SQLITE_ENABLE_BATCH_ATOMIC_WRITE\n<line11>if( pPager->dbSize>0 && (dc&SQLITE_IOCAP_BATCH_ATOMIC) ){\n<line12>return -1;\n<line13>}\n<line14>#endif\n<line15>#ifdef SQLITE_ENABLE_ATOMIC_WRITE\n<line16>{\n<line17>int nSector = pPager->sectorSize;\n<line18>int szPage = pPager->pageSize;\n<line19>assert(SQLITE_IOCAP_ATOMIC512==(512>>8));\n<line20>assert(SQLITE_IOCAP_ATOMIC64K==(65536>>8));\n<line21>if( 0==(dc&(SQLITE_IOCAP_ATOMIC|(szPage>>8)) || nSector>szPage) ){\n<line22>return 0;\n<line23>}\n<line24>}\n<line25>return JOURNAL_HDR_SZ(pPager) + JOURNAL_PG_SZ(pPager);\n<line26>#endif\n<line27>return 0;\n<line28>}
----------------------------------------
Function: readSuperJournal
Content: <line0>static int readSuperJournal(sqlite3_file *pJrnl, char *zSuper, u64 nSuper){\n<line1>int rc;                    /* Return code */\n<line2>u32 len;                   /* Length in bytes of super-journal name */\n<line3>i64 szJ;                   /* Total size in bytes of journal file pJrnl */\n<line4>u32 cksum;                 /* MJ checksum value read from journal */\n<line5>u32 u;                     /* Unsigned loop counter */\n<line6>unsigned char aMagic[8];   /* A buffer to hold the magic header */\n<line7>zSuper[0] = '\0';\n<line8>if( SQLITE_OK!=(rc = sqlite3OsFileSize(pJrnl, &szJ))\n<line9>|| szJ<16\n<line10>|| SQLITE_OK!=(rc = read32bits(pJrnl, szJ-16, &len))\n<line11>|| len>=nSuper\n<line12>|| len>szJ-16\n<line13>|| len==0\n<line14>|| SQLITE_OK!=(rc = read32bits(pJrnl, szJ-12, &cksum))\n<line15>|| SQLITE_OK!=(rc = sqlite3OsRead(pJrnl, aMagic, 8, szJ-8))\n<line16>|| memcmp(aMagic, aJournalMagic, 8)\n<line17>|| SQLITE_OK!=(rc = sqlite3OsRead(pJrnl, zSuper, len, szJ-16-len))\n<line18>){\n<line19>return rc;\n<line20>}\n<line21>/* See if the checksum matches the super-journal name */\n<line22>for(u=0; u<len; u++){\n<line23>cksum -= zSuper[u];\n<line24>}\n<line25>if( cksum ){\n<line26>/* If the checksum doesn't add up, then one or more of the disk sectors\n<line27>** containing the super-journal filename is corrupted. This means\n<line28>** definitely roll back, so just return SQLITE_OK and report a (nul)\n<line29>** super-journal filename.\n<line30>*/\n<line31>len = 0;\n<line32>}\n<line33>zSuper[len] = '\0';\n<line34>zSuper[len+1] = '\0';\n<line35>return SQLITE_OK;\n<line36>}
----------------------------------------
Function: journalHdrOffset
Content: <line0>static i64 journalHdrOffset(Pager *pPager){\n<line1>i64 offset = 0;\n<line2>i64 c = pPager->journalOff;\n<line3>if( c ){\n<line4>offset = ((c-1)/JOURNAL_HDR_SZ(pPager) + 1) * JOURNAL_HDR_SZ(pPager);\n<line5>}\n<line6>assert( offset%JOURNAL_HDR_SZ(pPager)==0 );\n<line7>assert( offset>=c );\n<line8>assert( (offset-c)<JOURNAL_HDR_SZ(pPager) );\n<line9>return offset;\n<line10>}
----------------------------------------
Function: zeroJournalHdr
Content: <line0>static int zeroJournalHdr(Pager *pPager, int doTruncate){\n<line1>int rc = SQLITE_OK;                               /* Return code */\n<line2>assert( isOpen(pPager->jfd) );\n<line3>assert( !sqlite3JournalIsInMemory(pPager->jfd) );\n<line4>if( pPager->journalOff ){\n<line5>const i64 iLimit = pPager->journalSizeLimit;    /* Local cache of jsl */\n<line6>IOTRACE(("JZEROHDR %p\n", pPager))\n<line7>if( doTruncate || iLimit==0 ){\n<line8>rc = sqlite3OsTruncate(pPager->jfd, 0);\n<line9>}else{\n<line10>static const char zeroHdr[28] = {0};\n<line11>rc = sqlite3OsWrite(pPager->jfd, zeroHdr, sizeof(zeroHdr), 0);\n<line12>}\n<line13>if( rc==SQLITE_OK && !pPager->noSync ){\n<line14>rc = sqlite3OsSync(pPager->jfd, SQLITE_SYNC_DATAONLY|pPager->syncFlags);\n<line15>}\n<line16>/* At this point the transaction is committed but the write lock\n<line17>** is still held on the file. If there is a size limit configured for\n<line18>** the persistent journal and the journal file currently consumes more\n<line19>** space than that limit allows for, truncate it now. There is no need\n<line20>** to sync the file following this operation.\n<line21>*/\n<line22>if( rc==SQLITE_OK && iLimit>0 ){\n<line23>i64 sz;\n<line24>rc = sqlite3OsFileSize(pPager->jfd, &sz);\n<line25>if( rc==SQLITE_OK && sz>iLimit ){\n<line26>rc = sqlite3OsTruncate(pPager->jfd, iLimit);\n<line27>}\n<line28>}\n<line29>}\n<line30>return rc;\n<line31>}
----------------------------------------
Function: writeJournalHdr
Content: <line0>static int writeJournalHdr(Pager *pPager){\n<line1>int rc = SQLITE_OK;                 /* Return code */\n<line2>char *zHeader = pPager->pTmpSpace;  /* Temporary space used to build header */\n<line3>u32 nHeader = (u32)pPager->pageSize;/* Size of buffer pointed to by zHeader */\n<line4>u32 nWrite;                         /* Bytes of header sector written */\n<line5>int ii;                             /* Loop counter */\n<line6>assert( isOpen(pPager->jfd) );      /* Journal file must be open. */\n<line7>if( nHeader>JOURNAL_HDR_SZ(pPager) ){\n<line8>nHeader = JOURNAL_HDR_SZ(pPager);\n<line9>}\n<line10>/* If there are active savepoints and any of them were created\n<line11>** since the most recent journal header was written, update the\n<line12>** PagerSavepoint.iHdrOffset fields now.\n<line13>*/\n<line14>for(ii=0; ii<pPager->nSavepoint; ii++){\n<line15>if( pPager->aSavepoint[ii].iHdrOffset==0 ){\n<line16>pPager->aSavepoint[ii].iHdrOffset = pPager->journalOff;\n<line17>}\n<line18>}\n<line19>pPager->journalHdr = pPager->journalOff = journalHdrOffset(pPager);\n<line20>/*\n<line21>** Write the nRec Field - the number of page records that follow this\n<line22>** journal header. Normally, zero is written to this value at this time.\n<line23>** After the records are added to the journal (and the journal synced,\n<line24>** if in full-sync mode), the zero is overwritten with the true number\n<line25>** of records (see syncJournal()).\n<line26>**\n<line27>** A faster alternative is to write 0xFFFFFFFF to the nRec field. When\n<line28>** reading the journal this value tells SQLite to assume that the\n<line29>** rest of the journal file contains valid page records. This assumption\n<line30>** is dangerous, as if a failure occurred whilst writing to the journal\n<line31>** file it may contain some garbage data. There are two scenarios\n<line32>** where this risk can be ignored:\n<line33>**\n<line34>**   * When the pager is in no-sync mode. Corruption can follow a\n<line35>**     power failure in this case anyway.\n<line36>**\n<line37>**   * When the SQLITE_IOCAP_SAFE_APPEND flag is set. This guarantees\n<line38>**     that garbage data is never appended to the journal file.\n<line39>*/\n<line40>assert( isOpen(pPager->fd) || pPager->noSync );\n<line41>if( pPager->noSync || (pPager->journalMode==PAGER_JOURNALMODE_MEMORY)\n<line42>|| (sqlite3OsDeviceCharacteristics(pPager->fd)&SQLITE_IOCAP_SAFE_APPEND)\n<line43>){\n<line44>memcpy(zHeader, aJournalMagic, sizeof(aJournalMagic));\n<line45>put32bits(&zHeader[sizeof(aJournalMagic)], 0xffffffff);\n<line46>}else{\n<line47>memset(zHeader, 0, sizeof(aJournalMagic)+4);\n<line48>}\n<line49>/* The random check-hash initializer */\n<line50>if( pPager->journalMode!=PAGER_JOURNALMODE_MEMORY ){\n<line51>sqlite3_randomness(sizeof(pPager->cksumInit), &pPager->cksumInit);\n<line52>}\n<line53>#ifdef SQLITE_DEBUG\n<line54>else{\n<line55>/* The Pager.cksumInit variable is usually randomized above to protect\n<line56>** against there being existing records in the journal file. This is\n<line57>** dangerous, as following a crash they may be mistaken for records\n<line58>** written by the current transaction and rolled back into the database\n<line59>** file, causing corruption. The following assert statements verify\n<line60>** that this is not required in "journal_mode=memory" mode, as in that\n<line61>** case the journal file is always 0 bytes in size at this point.\n<line62>** It is advantageous to avoid the sqlite3_randomness() call if possible\n<line63>** as it takes the global PRNG mutex.  */\n<line64>i64 sz = 0;\n<line65>sqlite3OsFileSize(pPager->jfd, &sz);\n<line66>assert( sz==0 );\n<line67>assert( pPager->journalOff==journalHdrOffset(pPager) );\n<line68>assert( sqlite3JournalIsInMemory(pPager->jfd) );\n<line69>}\n<line70>#endif\n<line71>put32bits(&zHeader[sizeof(aJournalMagic)+4], pPager->cksumInit);\n<line72>/* The initial database size */\n<line73>put32bits(&zHeader[sizeof(aJournalMagic)+8], pPager->dbOrigSize);\n<line74>/* The assumed sector size for this process */\n<line75>put32bits(&zHeader[sizeof(aJournalMagic)+12], pPager->sectorSize);\n<line76>/* The page size */\n<line77>put32bits(&zHeader[sizeof(aJournalMagic)+16], pPager->pageSize);\n<line78>/* Initializing the tail of the buffer is not necessary.  Everything\n<line79>** works find if the following memset() is omitted.  But initializing\n<line80>** the memory prevents valgrind from complaining, so we are willing to\n<line81>** take the performance hit.\n<line82>*/\n<line83>memset(&zHeader[sizeof(aJournalMagic)+20], 0,\n<line84>nHeader-(sizeof(aJournalMagic)+20));\n<line85>/* In theory, it is only necessary to write the 28 bytes that the\n<line86>** journal header consumes to the journal file here. Then increment the\n<line87>** Pager.journalOff variable by JOURNAL_HDR_SZ so that the next\n<line88>** record is written to the following sector (leaving a gap in the file\n<line89>** that will be implicitly filled in by the OS).\n<line90>**\n<line91>** However it has been discovered that on some systems this pattern can\n<line92>** be significantly slower than contiguously writing data to the file,\n<line93>** even if that means explicitly writing data to the block of\n<line94>** (JOURNAL_HDR_SZ - 28) bytes that will not be used. So that is what\n<line95>** is done.\n<line96>**\n<line97>** The loop is required here in case the sector-size is larger than the\n<line98>** database page size. Since the zHeader buffer is only Pager.pageSize\n<line99>** bytes in size, more than one call to sqlite3OsWrite() may be required\n<line100>** to populate the entire journal header sector.\n<line101>*/\n<line102>for(nWrite=0; rc==SQLITE_OK&&nWrite<JOURNAL_HDR_SZ(pPager); nWrite+=nHeader){\n<line103>IOTRACE(("JHDR %p %lld %d\n", pPager, pPager->journalHdr, nHeader))\n<line104>rc = sqlite3OsWrite(pPager->jfd, zHeader, nHeader, pPager->journalOff);\n<line105>assert( pPager->journalHdr <= pPager->journalOff );\n<line106>pPager->journalOff += nHeader;\n<line107>}\n<line108>return rc;\n<line109>}
----------------------------------------
Function: readJournalHdr
Content: <line0>static int readJournalHdr(\n<line1>Pager *pPager,               /* Pager object */\n<line2>int isHot,\n<line3>i64 journalSize,             /* Size of the open journal file in bytes */\n<line4>u32 *pNRec,                  /* OUT: Value read from the nRec field */\n<line5>u32 *pDbSize                 /* OUT: Value of original database size field */\n<line6>){\n<line7>int rc;                      /* Return code */\n<line8>unsigned char aMagic[8];     /* A buffer to hold the magic header */\n<line9>i64 iHdrOff;                 /* Offset of journal header being read */\n<line10>assert( isOpen(pPager->jfd) );      /* Journal file must be open. */\n<line11>/* Advance Pager.journalOff to the start of the next sector. If the\n<line12>** journal file is too small for there to be a header stored at this\n<line13>** point, return SQLITE_DONE.\n<line14>*/\n<line15>pPager->journalOff = journalHdrOffset(pPager);\n<line16>if( pPager->journalOff+JOURNAL_HDR_SZ(pPager) > journalSize ){\n<line17>return SQLITE_DONE;\n<line18>}\n<line19>iHdrOff = pPager->journalOff;\n<line20>/* Read in the first 8 bytes of the journal header. If they do not match\n<line21>** the  magic string found at the start of each journal header, return\n<line22>** SQLITE_DONE. If an IO error occurs, return an error code. Otherwise,\n<line23>** proceed.\n<line24>*/\n<line25>if( isHot || iHdrOff!=pPager->journalHdr ){\n<line26>rc = sqlite3OsRead(pPager->jfd, aMagic, sizeof(aMagic), iHdrOff);\n<line27>if( rc ){\n<line28>return rc;\n<line29>}\n<line30>if( memcmp(aMagic, aJournalMagic, sizeof(aMagic))!=0 ){\n<line31>return SQLITE_DONE;\n<line32>}\n<line33>}\n<line34>/* Read the first three 32-bit fields of the journal header: The nRec\n<line35>** field, the checksum-initializer and the database size at the start\n<line36>** of the transaction. Return an error code if anything goes wrong.\n<line37>*/\n<line38>if( SQLITE_OK!=(rc = read32bits(pPager->jfd, iHdrOff+8, pNRec))\n<line39>|| SQLITE_OK!=(rc = read32bits(pPager->jfd, iHdrOff+12, &pPager->cksumInit))\n<line40>|| SQLITE_OK!=(rc = read32bits(pPager->jfd, iHdrOff+16, pDbSize))\n<line41>){\n<line42>return rc;\n<line43>}\n<line44>if( pPager->journalOff==0 ){\n<line45>u32 iPageSize;               /* Page-size field of journal header */\n<line46>u32 iSectorSize;             /* Sector-size field of journal header */\n<line47>/* Read the page-size and sector-size journal header fields. */\n<line48>if( SQLITE_OK!=(rc = read32bits(pPager->jfd, iHdrOff+20, &iSectorSize))\n<line49>|| SQLITE_OK!=(rc = read32bits(pPager->jfd, iHdrOff+24, &iPageSize))\n<line50>){\n<line51>return rc;\n<line52>}\n<line53>/* Versions of SQLite prior to 3.5.8 set the page-size field of the\n<line54>** journal header to zero. In this case, assume that the Pager.pageSize\n<line55>** variable is already set to the correct page size.\n<line56>*/\n<line57>if( iPageSize==0 ){\n<line58>iPageSize = pPager->pageSize;\n<line59>}\n<line60>/* Check that the values read from the page-size and sector-size fields\n<line61>** are within range. To be 'in range', both values need to be a power\n<line62>** of two greater than or equal to 512 or 32, and not greater than their\n<line63>** respective compile time maximum limits.\n<line64>*/\n<line65>if( iPageSize<512                  || iSectorSize<32\n<line66>|| iPageSize>SQLITE_MAX_PAGE_SIZE || iSectorSize>MAX_SECTOR_SIZE\n<line67>|| ((iPageSize-1)&iPageSize)!=0   || ((iSectorSize-1)&iSectorSize)!=0\n<line68>){\n<line69>/* If the either the page-size or sector-size in the journal-header is\n<line70>** invalid, then the process that wrote the journal-header must have\n<line71>** crashed before the header was synced. In this case stop reading\n<line72>** the journal file here.\n<line73>*/\n<line74>return SQLITE_DONE;\n<line75>}\n<line76>/* Update the page-size to match the value read from the journal.\n<line77>** Use a testcase() macro to make sure that malloc failure within\n<line78>** PagerSetPagesize() is tested.\n<line79>*/\n<line80>rc = sqlite3PagerSetPagesize(pPager, &iPageSize, -1);\n<line81>testcase( rc!=SQLITE_OK );\n<line82>/* Update the assumed sector-size to match the value used by\n<line83>** the process that created this journal. If this journal was\n<line84>** created by a process other than this one, then this routine\n<line85>** is being called from within pager_playback(). The local value\n<line86>** of Pager.sectorSize is restored at the end of that routine.\n<line87>*/\n<line88>pPager->sectorSize = iSectorSize;\n<line89>}\n<line90>pPager->journalOff += JOURNAL_HDR_SZ(pPager);\n<line91>return rc;\n<line92>}
----------------------------------------
Function: writeSuperJournal
Content: <line0>static int writeSuperJournal(Pager *pPager, const char *zSuper){\n<line1>int rc;                          /* Return code */\n<line2>int nSuper;                      /* Length of string zSuper */\n<line3>i64 iHdrOff;                     /* Offset of header in journal file */\n<line4>i64 jrnlSize;                    /* Size of journal file on disk */\n<line5>u32 cksum = 0;                   /* Checksum of string zSuper */\n<line6>assert( pPager->setSuper==0 );\n<line7>assert( !pagerUseWal(pPager) );\n<line8>if( !zSuper\n<line9>|| pPager->journalMode==PAGER_JOURNALMODE_MEMORY\n<line10>|| !isOpen(pPager->jfd)\n<line11>){\n<line12>return SQLITE_OK;\n<line13>}\n<line14>pPager->setSuper = 1;\n<line15>assert( pPager->journalHdr <= pPager->journalOff );\n<line16>/* Calculate the length in bytes and the checksum of zSuper */\n<line17>for(nSuper=0; zSuper[nSuper]; nSuper++){\n<line18>cksum += zSuper[nSuper];\n<line19>}\n<line20>/* If in full-sync mode, advance to the next disk sector before writing\n<line21>** the super-journal name. This is in case the previous page written to\n<line22>** the journal has already been synced.\n<line23>*/\n<line24>if( pPager->fullSync ){\n<line25>pPager->journalOff = journalHdrOffset(pPager);\n<line26>}\n<line27>iHdrOff = pPager->journalOff;\n<line28>/* Write the super-journal data to the end of the journal file. If\n<line29>** an error occurs, return the error code to the caller.\n<line30>*/\n<line31>if( (0 != (rc = write32bits(pPager->jfd, iHdrOff, PAGER_SJ_PGNO(pPager))))\n<line32>|| (0 != (rc = sqlite3OsWrite(pPager->jfd, zSuper, nSuper, iHdrOff+4)))\n<line33>|| (0 != (rc = write32bits(pPager->jfd, iHdrOff+4+nSuper, nSuper)))\n<line34>|| (0 != (rc = write32bits(pPager->jfd, iHdrOff+4+nSuper+4, cksum)))\n<line35>|| (0 != (rc = sqlite3OsWrite(pPager->jfd, aJournalMagic, 8,\n<line36>iHdrOff+4+nSuper+8)))\n<line37>){\n<line38>return rc;\n<line39>}\n<line40>pPager->journalOff += (nSuper+20);\n<line41>/* If the pager is in persistent-journal mode, then the physical\n<line42>** journal-file may extend past the end of the super-journal name\n<line43>** and 8 bytes of magic data just written to the file. This is\n<line44>** dangerous because the code to rollback a hot-journal file\n<line45>** will not be able to find the super-journal name to determine\n<line46>** whether or not the journal is hot.\n<line47>**\n<line48>** Easiest thing to do in this scenario is to truncate the journal\n<line49>** file to the required size.\n<line50>*/\n<line51>if( SQLITE_OK==(rc = sqlite3OsFileSize(pPager->jfd, &jrnlSize))\n<line52>&& jrnlSize>pPager->journalOff\n<line53>){\n<line54>rc = sqlite3OsTruncate(pPager->jfd, pPager->journalOff);\n<line55>}\n<line56>return rc;\n<line57>}
----------------------------------------
Function: pager_reset
Content: <line0>static void pager_reset(Pager *pPager){\n<line1>pPager->iDataVersion++;\n<line2>sqlite3BackupRestart(pPager->pBackup);\n<line3>sqlite3PcacheClear(pPager->pPCache);\n<line4>}
----------------------------------------
Function: releaseAllSavepoints
Content: <line0>static void releaseAllSavepoints(Pager *pPager){\n<line1>int ii;               /* Iterator for looping through Pager.aSavepoint */\n<line2>for(ii=0; ii<pPager->nSavepoint; ii++){\n<line3>sqlite3BitvecDestroy(pPager->aSavepoint[ii].pInSavepoint);\n<line4>}\n<line5>if( !pPager->exclusiveMode || sqlite3JournalIsInMemory(pPager->sjfd) ){\n<line6>sqlite3OsClose(pPager->sjfd);\n<line7>}\n<line8>sqlite3_free(pPager->aSavepoint);\n<line9>pPager->aSavepoint = 0;\n<line10>pPager->nSavepoint = 0;\n<line11>pPager->nSubRec = 0;\n<line12>}
----------------------------------------
Function: addToSavepointBitvecs
Content: <line0>static int addToSavepointBitvecs(Pager *pPager, Pgno pgno){\n<line1>int ii;                   /* Loop counter */\n<line2>int rc = SQLITE_OK;       /* Result code */\n<line3>for(ii=0; ii<pPager->nSavepoint; ii++){\n<line4>PagerSavepoint *p = &pPager->aSavepoint[ii];\n<line5>if( pgno<=p->nOrig ){\n<line6>rc |= sqlite3BitvecSet(p->pInSavepoint, pgno);\n<line7>testcase( rc==SQLITE_NOMEM );\n<line8>assert( rc==SQLITE_OK || rc==SQLITE_NOMEM );\n<line9>}\n<line10>}\n<line11>return rc;\n<line12>}
----------------------------------------
Function: pager_unlock
Content: <line0>static void pager_unlock(Pager *pPager){\n<line1>assert( pPager->eState==PAGER_READER\n<line2>|| pPager->eState==PAGER_OPEN\n<line3>|| pPager->eState==PAGER_ERROR\n<line4>);\n<line5>sqlite3BitvecDestroy(pPager->pInJournal);\n<line6>pPager->pInJournal = 0;\n<line7>releaseAllSavepoints(pPager);\n<line8>if( pagerUseWal(pPager) ){\n<line9>assert( !isOpen(pPager->jfd) );\n<line10>if( pPager->eState==PAGER_ERROR ){\n<line11>/* If an IO error occurs in wal.c while attempting to wrap the wal file,\n<line12>** then the Wal object may be holding a write-lock but no read-lock.\n<line13>** This call ensures that the write-lock is dropped as well. We cannot\n<line14>** have sqlite3WalEndReadTransaction() drop the write-lock, as it once\n<line15>** did, because this would break "BEGIN EXCLUSIVE" handling for\n<line16>** SQLITE_ENABLE_SETLK_TIMEOUT builds.  */\n<line17>(void)sqlite3WalEndWriteTransaction(pPager->pWal);\n<line18>}\n<line19>sqlite3WalEndReadTransaction(pPager->pWal);\n<line20>pPager->eState = PAGER_OPEN;\n<line21>}else if( !pPager->exclusiveMode ){\n<line22>int rc;                       /* Error code returned by pagerUnlockDb() */\n<line23>int iDc = isOpen(pPager->fd)?sqlite3OsDeviceCharacteristics(pPager->fd):0;\n<line24>/* If the operating system support deletion of open files, then\n<line25>** close the journal file when dropping the database lock.  Otherwise\n<line26>** another connection with journal_mode=delete might delete the file\n<line27>** out from under us.\n<line28>*/\n<line29>assert( (PAGER_JOURNALMODE_MEMORY   & 5)!=1 );\n<line30>assert( (PAGER_JOURNALMODE_OFF      & 5)!=1 );\n<line31>assert( (PAGER_JOURNALMODE_WAL      & 5)!=1 );\n<line32>assert( (PAGER_JOURNALMODE_DELETE   & 5)!=1 );\n<line33>assert( (PAGER_JOURNALMODE_TRUNCATE & 5)==1 );\n<line34>assert( (PAGER_JOURNALMODE_PERSIST  & 5)==1 );\n<line35>if( 0==(iDc & SQLITE_IOCAP_UNDELETABLE_WHEN_OPEN)\n<line36>|| 1!=(pPager->journalMode & 5)\n<line37>){\n<line38>sqlite3OsClose(pPager->jfd);\n<line39>}\n<line40>/* If the pager is in the ERROR state and the call to unlock the database\n<line41>** file fails, set the current lock to UNKNOWN_LOCK. See the comment\n<line42>** above the #define for UNKNOWN_LOCK for an explanation of why this\n<line43>** is necessary.\n<line44>*/\n<line45>rc = pagerUnlockDb(pPager, NO_LOCK);\n<line46>if( rc!=SQLITE_OK && pPager->eState==PAGER_ERROR ){\n<line47>pPager->eLock = UNKNOWN_LOCK;\n<line48>}\n<line49>/* The pager state may be changed from PAGER_ERROR to PAGER_OPEN here\n<line50>** without clearing the error code. This is intentional - the error\n<line51>** code is cleared and the cache reset in the block below.\n<line52>*/\n<line53>assert( pPager->errCode || pPager->eState!=PAGER_ERROR );\n<line54>pPager->eState = PAGER_OPEN;\n<line55>}\n<line56>/* If Pager.errCode is set, the contents of the pager cache cannot be\n<line57>** trusted. Now that there are no outstanding references to the pager,\n<line58>** it can safely move back to PAGER_OPEN state. This happens in both\n<line59>** normal and exclusive-locking mode.\n<line60>*/\n<line61>assert( pPager->errCode==SQLITE_OK || !MEMDB );\n<line62>if( pPager->errCode ){\n<line63>if( pPager->tempFile==0 ){\n<line64>pager_reset(pPager);\n<line65>pPager->changeCountDone = 0;\n<line66>pPager->eState = PAGER_OPEN;\n<line67>}else{\n<line68>pPager->eState = (isOpen(pPager->jfd) ? PAGER_OPEN : PAGER_READER);\n<line69>}\n<line70>if( USEFETCH(pPager) ) sqlite3OsUnfetch(pPager->fd, 0, 0);\n<line71>pPager->errCode = SQLITE_OK;\n<line72>setGetterMethod(pPager);\n<line73>}\n<line74>pPager->journalOff = 0;\n<line75>pPager->journalHdr = 0;\n<line76>pPager->setSuper = 0;\n<line77>}
----------------------------------------
Function: pager_error
Content: <line0>static int pager_error(Pager *pPager, int rc){\n<line1>int rc2 = rc & 0xff;\n<line2>assert( rc==SQLITE_OK || !MEMDB );\n<line3>assert(\n<line4>pPager->errCode==SQLITE_FULL ||\n<line5>pPager->errCode==SQLITE_OK ||\n<line6>(pPager->errCode & 0xff)==SQLITE_IOERR\n<line7>);\n<line8>if( rc2==SQLITE_FULL || rc2==SQLITE_IOERR ){\n<line9>pPager->errCode = rc;\n<line10>pPager->eState = PAGER_ERROR;\n<line11>setGetterMethod(pPager);\n<line12>}\n<line13>return rc;\n<line14>}
----------------------------------------
Function: pagerFlushOnCommit
Content: <line0>static int pagerFlushOnCommit(Pager *pPager, int bCommit){\n<line1>if( pPager->tempFile==0 ) return 1;\n<line2>if( !bCommit ) return 0;\n<line3>if( !isOpen(pPager->fd) ) return 0;\n<line4>return (sqlite3PCachePercentDirty(pPager->pPCache)>=25);\n<line5>}
----------------------------------------
Function: pager_end_transaction
Content: <line0>static int pager_end_transaction(Pager *pPager, int hasSuper, int bCommit){\n<line1>int rc = SQLITE_OK;      /* Error code from journal finalization operation */\n<line2>int rc2 = SQLITE_OK;     /* Error code from db file unlock operation */\n<line3>/* Do nothing if the pager does not have an open write transaction\n<line4>** or at least a RESERVED lock. This function may be called when there\n<line5>** is no write-transaction active but a RESERVED or greater lock is\n<line6>** held under two circumstances:\n<line7>**\n<line8>**   1. After a successful hot-journal rollback, it is called with\n<line9>**      eState==PAGER_NONE and eLock==EXCLUSIVE_LOCK.\n<line10>**\n<line11>**   2. If a connection with locking_mode=exclusive holding an EXCLUSIVE\n<line12>**      lock switches back to locking_mode=normal and then executes a\n<line13>**      read-transaction, this function is called with eState==PAGER_READER\n<line14>**      and eLock==EXCLUSIVE_LOCK when the read-transaction is closed.\n<line15>*/\n<line16>assert( assert_pager_state(pPager) );\n<line17>assert( pPager->eState!=PAGER_ERROR );\n<line18>if( pPager->eState<PAGER_WRITER_LOCKED && pPager->eLock<RESERVED_LOCK ){\n<line19>return SQLITE_OK;\n<line20>}\n<line21>releaseAllSavepoints(pPager);\n<line22>assert( isOpen(pPager->jfd) || pPager->pInJournal==0\n<line23>|| (sqlite3OsDeviceCharacteristics(pPager->fd)&SQLITE_IOCAP_BATCH_ATOMIC)\n<line24>);\n<line25>if( isOpen(pPager->jfd) ){\n<line26>assert( !pagerUseWal(pPager) );\n<line27>/* Finalize the journal file. */\n<line28>if( sqlite3JournalIsInMemory(pPager->jfd) ){\n<line29>/* assert( pPager->journalMode==PAGER_JOURNALMODE_MEMORY ); */\n<line30>sqlite3OsClose(pPager->jfd);\n<line31>}else if( pPager->journalMode==PAGER_JOURNALMODE_TRUNCATE ){\n<line32>if( pPager->journalOff==0 ){\n<line33>rc = SQLITE_OK;\n<line34>}else{\n<line35>rc = sqlite3OsTruncate(pPager->jfd, 0);\n<line36>if( rc==SQLITE_OK && pPager->fullSync ){\n<line37>/* Make sure the new file size is written into the inode right away.\n<line38>** Otherwise the journal might resurrect following a power loss and\n<line39>** cause the last transaction to roll back.  See\n<line40>** https://bugzilla.mozilla.org/show_bug.cgi?id=1072773\n<line41>*/\n<line42>rc = sqlite3OsSync(pPager->jfd, pPager->syncFlags);\n<line43>}\n<line44>}\n<line45>pPager->journalOff = 0;\n<line46>}else if( pPager->journalMode==PAGER_JOURNALMODE_PERSIST\n<line47>|| (pPager->exclusiveMode && pPager->journalMode<PAGER_JOURNALMODE_WAL)\n<line48>){\n<line49>rc = zeroJournalHdr(pPager, hasSuper||pPager->tempFile);\n<line50>pPager->journalOff = 0;\n<line51>}else{\n<line52>/* This branch may be executed with Pager.journalMode==MEMORY if\n<line53>** a hot-journal was just rolled back. In this case the journal\n<line54>** file should be closed and deleted. If this connection writes to\n<line55>** the database file, it will do so using an in-memory journal.\n<line56>*/\n<line57>int bDelete = !pPager->tempFile;\n<line58>assert( sqlite3JournalIsInMemory(pPager->jfd)==0 );\n<line59>assert( pPager->journalMode==PAGER_JOURNALMODE_DELETE\n<line60>|| pPager->journalMode==PAGER_JOURNALMODE_MEMORY\n<line61>|| pPager->journalMode==PAGER_JOURNALMODE_WAL\n<line62>);\n<line63>sqlite3OsClose(pPager->jfd);\n<line64>if( bDelete ){\n<line65>rc = sqlite3OsDelete(pPager->pVfs, pPager->zJournal, pPager->extraSync);\n<line66>}\n<line67>}\n<line68>}\n<line69>#ifdef SQLITE_CHECK_PAGES\n<line70>sqlite3PcacheIterateDirty(pPager->pPCache, pager_set_pagehash);\n<line71>if( pPager->dbSize==0 && sqlite3PcacheRefCount(pPager->pPCache)>0 ){\n<line72>PgHdr *p = sqlite3PagerLookup(pPager, 1);\n<line73>if( p ){\n<line74>p->pageHash = 0;\n<line75>sqlite3PagerUnrefNotNull(p);\n<line76>}\n<line77>}\n<line78>#endif\n<line79>sqlite3BitvecDestroy(pPager->pInJournal);\n<line80>pPager->pInJournal = 0;\n<line81>pPager->nRec = 0;\n<line82>if( rc==SQLITE_OK ){\n<line83>if( MEMDB || pagerFlushOnCommit(pPager, bCommit) ){\n<line84>sqlite3PcacheCleanAll(pPager->pPCache);\n<line85>}else{\n<line86>sqlite3PcacheClearWritable(pPager->pPCache);\n<line87>}\n<line88>sqlite3PcacheTruncate(pPager->pPCache, pPager->dbSize);\n<line89>}\n<line90>if( pagerUseWal(pPager) ){\n<line91>/* Drop the WAL write-lock, if any. Also, if the connection was in\n<line92>** locking_mode=exclusive mode but is no longer, drop the EXCLUSIVE\n<line93>** lock held on the database file.\n<line94>*/\n<line95>rc2 = sqlite3WalEndWriteTransaction(pPager->pWal);\n<line96>assert( rc2==SQLITE_OK );\n<line97>}else if( rc==SQLITE_OK && bCommit && pPager->dbFileSize>pPager->dbSize ){\n<line98>/* This branch is taken when committing a transaction in rollback-journal\n<line99>** mode if the database file on disk is larger than the database image.\n<line100>** At this point the journal has been finalized and the transaction\n<line101>** successfully committed, but the EXCLUSIVE lock is still held on the\n<line102>** file. So it is safe to truncate the database file to its minimum\n<line103>** required size.  */\n<line104>assert( pPager->eLock==EXCLUSIVE_LOCK );\n<line105>rc = pager_truncate(pPager, pPager->dbSize);\n<line106>}\n<line107>if( rc==SQLITE_OK && bCommit ){\n<line108>rc = sqlite3OsFileControl(pPager->fd, SQLITE_FCNTL_COMMIT_PHASETWO, 0);\n<line109>if( rc==SQLITE_NOTFOUND ) rc = SQLITE_OK;\n<line110>}\n<line111>if( !pPager->exclusiveMode\n<line112>&& (!pagerUseWal(pPager) || sqlite3WalExclusiveMode(pPager->pWal, 0))\n<line113>){\n<line114>rc2 = pagerUnlockDb(pPager, SHARED_LOCK);\n<line115>}\n<line116>pPager->eState = PAGER_READER;\n<line117>pPager->setSuper = 0;\n<line118>return (rc==SQLITE_OK?rc2:rc);\n<line119>}
----------------------------------------
Function: pagerUnlockAndRollback
Content: <line0>static void pagerUnlockAndRollback(Pager *pPager){\n<line1>if( pPager->eState!=PAGER_ERROR && pPager->eState!=PAGER_OPEN ){\n<line2>assert( assert_pager_state(pPager) );\n<line3>if( pPager->eState>=PAGER_WRITER_LOCKED ){\n<line4>sqlite3BeginBenignMalloc();\n<line5>sqlite3PagerRollback(pPager);\n<line6>sqlite3EndBenignMalloc();\n<line7>}else if( !pPager->exclusiveMode ){\n<line8>assert( pPager->eState==PAGER_READER );\n<line9>pager_end_transaction(pPager, 0, 0);\n<line10>}\n<line11>}else if( pPager->eState==PAGER_ERROR\n<line12>&& pPager->journalMode==PAGER_JOURNALMODE_MEMORY\n<line13>&& isOpen(pPager->jfd)\n<line14>){\n<line15>/* Special case for a ROLLBACK due to I/O error with an in-memory\n<line16>** journal:  We have to rollback immediately, before the journal is\n<line17>** closed, because once it is closed, all content is forgotten. */\n<line18>int errCode = pPager->errCode;\n<line19>u8 eLock = pPager->eLock;\n<line20>pPager->eState = PAGER_OPEN;\n<line21>pPager->errCode = SQLITE_OK;\n<line22>pPager->eLock = EXCLUSIVE_LOCK;\n<line23>pager_playback(pPager, 1);\n<line24>pPager->errCode = errCode;\n<line25>pPager->eLock = eLock;\n<line26>}\n<line27>pager_unlock(pPager);\n<line28>}
----------------------------------------
Function: pager_cksum
Content: <line0>static u32 pager_cksum(Pager *pPager, const u8 *aData){\n<line1>u32 cksum = pPager->cksumInit;         /* Checksum value to return */\n<line2>int i = pPager->pageSize-200;          /* Loop counter */\n<line3>while( i>0 ){\n<line4>cksum += aData[i];\n<line5>i -= 200;\n<line6>}\n<line7>return cksum;\n<line8>}
----------------------------------------
Function: pager_playback_one_page
Content: <line0>static int pager_playback_one_page(\n<line1>Pager *pPager,                /* The pager being played back */\n<line2>i64 *pOffset,                 /* Offset of record to playback */\n<line3>Bitvec *pDone,                /* Bitvec of pages already played back */\n<line4>int isMainJrnl,               /* 1 -> main journal. 0 -> sub-journal. */\n<line5>int isSavepnt                 /* True for a savepoint rollback */\n<line6>){\n<line7>int rc;\n<line8>PgHdr *pPg;                   /* An existing page in the cache */\n<line9>Pgno pgno;                    /* The page number of a page in journal */\n<line10>u32 cksum;                    /* Checksum used for sanity checking */\n<line11>char *aData;                  /* Temporary storage for the page */\n<line12>sqlite3_file *jfd;            /* The file descriptor for the journal file */\n<line13>int isSynced;                 /* True if journal page is synced */\n<line14>assert( (isMainJrnl&~1)==0 );      /* isMainJrnl is 0 or 1 */\n<line15>assert( (isSavepnt&~1)==0 );       /* isSavepnt is 0 or 1 */\n<line16>assert( isMainJrnl || pDone );     /* pDone always used on sub-journals */\n<line17>assert( isSavepnt || pDone==0 );   /* pDone never used on non-savepoint */\n<line18>aData = pPager->pTmpSpace;\n<line19>assert( aData );         /* Temp storage must have already been allocated */\n<line20>assert( pagerUseWal(pPager)==0 || (!isMainJrnl && isSavepnt) );\n<line21>/* Either the state is greater than PAGER_WRITER_CACHEMOD (a transaction\n<line22>** or savepoint rollback done at the request of the caller) or this is\n<line23>** a hot-journal rollback. If it is a hot-journal rollback, the pager\n<line24>** is in state OPEN and holds an EXCLUSIVE lock. Hot-journal rollback\n<line25>** only reads from the main journal, not the sub-journal.\n<line26>*/\n<line27>assert( pPager->eState>=PAGER_WRITER_CACHEMOD\n<line28>|| (pPager->eState==PAGER_OPEN && pPager->eLock==EXCLUSIVE_LOCK)\n<line29>);\n<line30>assert( pPager->eState>=PAGER_WRITER_CACHEMOD || isMainJrnl );\n<line31>/* Read the page number and page data from the journal or sub-journal\n<line32>** file. Return an error code to the caller if an IO error occurs.\n<line33>*/\n<line34>jfd = isMainJrnl ? pPager->jfd : pPager->sjfd;\n<line35>rc = read32bits(jfd, *pOffset, &pgno);\n<line36>if( rc!=SQLITE_OK ) return rc;\n<line37>rc = sqlite3OsRead(jfd, (u8*)aData, pPager->pageSize, (*pOffset)+4);\n<line38>if( rc!=SQLITE_OK ) return rc;\n<line39>*pOffset += pPager->pageSize + 4 + isMainJrnl*4;\n<line40>/* Sanity checking on the page.  This is more important that I originally\n<line41>** thought.  If a power failure occurs while the journal is being written,\n<line42>** it could cause invalid data to be written into the journal.  We need to\n<line43>** detect this invalid data (with high probability) and ignore it.\n<line44>*/\n<line45>if( pgno==0 || pgno==PAGER_SJ_PGNO(pPager) ){\n<line46>assert( !isSavepnt );\n<line47>return SQLITE_DONE;\n<line48>}\n<line49>if( pgno>(Pgno)pPager->dbSize || sqlite3BitvecTest(pDone, pgno) ){\n<line50>return SQLITE_OK;\n<line51>}\n<line52>if( isMainJrnl ){\n<line53>rc = read32bits(jfd, (*pOffset)-4, &cksum);\n<line54>if( rc ) return rc;\n<line55>if( !isSavepnt && pager_cksum(pPager, (u8*)aData)!=cksum ){\n<line56>return SQLITE_DONE;\n<line57>}\n<line58>}\n<line59>/* If this page has already been played back before during the current\n<line60>** rollback, then don't bother to play it back again.\n<line61>*/\n<line62>if( pDone && (rc = sqlite3BitvecSet(pDone, pgno))!=SQLITE_OK ){\n<line63>return rc;\n<line64>}\n<line65>/* When playing back page 1, restore the nReserve setting\n<line66>*/\n<line67>if( pgno==1 && pPager->nReserve!=((u8*)aData)[20] ){\n<line68>pPager->nReserve = ((u8*)aData)[20];\n<line69>}\n<line70>/* If the pager is in CACHEMOD state, then there must be a copy of this\n<line71>** page in the pager cache. In this case just update the pager cache,\n<line72>** not the database file. The page is left marked dirty in this case.\n<line73>**\n<line74>** An exception to the above rule: If the database is in no-sync mode\n<line75>** and a page is moved during an incremental vacuum then the page may\n<line76>** not be in the pager cache. Later: if a malloc() or IO error occurs\n<line77>** during a Movepage() call, then the page may not be in the cache\n<line78>** either. So the condition described in the above paragraph is not\n<line79>** assert()able.\n<line80>**\n<line81>** If in WRITER_DBMOD, WRITER_FINISHED or OPEN state, then we update the\n<line82>** pager cache if it exists and the main file. The page is then marked\n<line83>** not dirty. Since this code is only executed in PAGER_OPEN state for\n<line84>** a hot-journal rollback, it is guaranteed that the page-cache is empty\n<line85>** if the pager is in OPEN state.\n<line86>**\n<line87>** Ticket #1171:  The statement journal might contain page content that is\n<line88>** different from the page content at the start of the transaction.\n<line89>** This occurs when a page is changed prior to the start of a statement\n<line90>** then changed again within the statement.  When rolling back such a\n<line91>** statement we must not write to the original database unless we know\n<line92>** for certain that original page contents are synced into the main rollback\n<line93>** journal.  Otherwise, a power loss might leave modified data in the\n<line94>** database file without an entry in the rollback journal that can\n<line95>** restore the database to its original form.  Two conditions must be\n<line96>** met before writing to the database files. (1) the database must be\n<line97>** locked.  (2) we know that the original page content is fully synced\n<line98>** in the main journal either because the page is not in cache or else\n<line99>** the page is marked as needSync==0.\n<line100>**\n<line101>** 2008-04-14:  When attempting to vacuum a corrupt database file, it\n<line102>** is possible to fail a statement on a database that does not yet exist.\n<line103>** Do not attempt to write if database file has never been opened.\n<line104>*/\n<line105>if( pagerUseWal(pPager) ){\n<line106>pPg = 0;\n<line107>}else{\n<line108>pPg = sqlite3PagerLookup(pPager, pgno);\n<line109>}\n<line110>assert( pPg || !MEMDB );\n<line111>assert( pPager->eState!=PAGER_OPEN || pPg==0 || pPager->tempFile );\n<line112>PAGERTRACE(("PLAYBACK %d page %d hash(%08x) %s\n",\n<line113>PAGERID(pPager), pgno, pager_datahash(pPager->pageSize, (u8*)aData),\n<line114>(isMainJrnl?"main-journal":"sub-journal")\n<line115>));\n<line116>if( isMainJrnl ){\n<line117>isSynced = pPager->noSync || (*pOffset <= pPager->journalHdr);\n<line118>}else{\n<line119>isSynced = (pPg==0 || 0==(pPg->flags & PGHDR_NEED_SYNC));\n<line120>}\n<line121>if( isOpen(pPager->fd)\n<line122>&& (pPager->eState>=PAGER_WRITER_DBMOD || pPager->eState==PAGER_OPEN)\n<line123>&& isSynced\n<line124>){\n<line125>i64 ofst = (pgno-1)*(i64)pPager->pageSize;\n<line126>testcase( !isSavepnt && pPg!=0 && (pPg->flags&PGHDR_NEED_SYNC)!=0 );\n<line127>assert( !pagerUseWal(pPager) );\n<line128>/* Write the data read from the journal back into the database file.\n<line129>** This is usually safe even for an encrypted database - as the data\n<line130>** was encrypted before it was written to the journal file. The exception\n<line131>** is if the data was just read from an in-memory sub-journal. In that\n<line132>** case it must be encrypted here before it is copied into the database\n<line133>** file.  */\n<line134>rc = sqlite3OsWrite(pPager->fd, (u8 *)aData, pPager->pageSize, ofst);\n<line135>if( pgno>pPager->dbFileSize ){\n<line136>pPager->dbFileSize = pgno;\n<line137>}\n<line138>if( pPager->pBackup ){\n<line139>sqlite3BackupUpdate(pPager->pBackup, pgno, (u8*)aData);\n<line140>}\n<line141>}else if( !isMainJrnl && pPg==0 ){\n<line142>/* If this is a rollback of a savepoint and data was not written to\n<line143>** the database and the page is not in-memory, there is a potential\n<line144>** problem. When the page is next fetched by the b-tree layer, it\n<line145>** will be read from the database file, which may or may not be\n<line146>** current.\n<line147>**\n<line148>** There are a couple of different ways this can happen. All are quite\n<line149>** obscure. When running in synchronous mode, this can only happen\n<line150>** if the page is on the free-list at the start of the transaction, then\n<line151>** populated, then moved using sqlite3PagerMovepage().\n<line152>**\n<line153>** The solution is to add an in-memory page to the cache containing\n<line154>** the data just read from the sub-journal. Mark the page as dirty\n<line155>** and if the pager requires a journal-sync, then mark the page as\n<line156>** requiring a journal-sync before it is written.\n<line157>*/\n<line158>assert( isSavepnt );\n<line159>assert( (pPager->doNotSpill & SPILLFLAG_ROLLBACK)==0 );\n<line160>pPager->doNotSpill |= SPILLFLAG_ROLLBACK;\n<line161>rc = sqlite3PagerGet(pPager, pgno, &pPg, 1);\n<line162>assert( (pPager->doNotSpill & SPILLFLAG_ROLLBACK)!=0 );\n<line163>pPager->doNotSpill &= ~SPILLFLAG_ROLLBACK;\n<line164>if( rc!=SQLITE_OK ) return rc;\n<line165>sqlite3PcacheMakeDirty(pPg);\n<line166>}\n<line167>if( pPg ){\n<line168>/* No page should ever be explicitly rolled back that is in use, except\n<line169>** for page 1 which is held in use in order to keep the lock on the\n<line170>** database active. However such a page may be rolled back as a result\n<line171>** of an internal error resulting in an automatic call to\n<line172>** sqlite3PagerRollback().\n<line173>*/\n<line174>void *pData;\n<line175>pData = pPg->pData;\n<line176>memcpy(pData, (u8*)aData, pPager->pageSize);\n<line177>pPager->xReiniter(pPg);\n<line178>/* It used to be that sqlite3PcacheMakeClean(pPg) was called here.  But\n<line179>** that call was dangerous and had no detectable benefit since the cache\n<line180>** is normally cleaned by sqlite3PcacheCleanAll() after rollback and so\n<line181>** has been removed. */\n<line182>pager_set_pagehash(pPg);\n<line183>/* If this was page 1, then restore the value of Pager.dbFileVers.\n<line184>** Do this before any decoding. */\n<line185>if( pgno==1 ){\n<line186>memcpy(&pPager->dbFileVers, &((u8*)pData)[24],sizeof(pPager->dbFileVers));\n<line187>}\n<line188>sqlite3PcacheRelease(pPg);\n<line189>}\n<line190>return rc;\n<line191>}
----------------------------------------
Function: pager_delsuper
Content: <line0>static int pager_delsuper(Pager *pPager, const char *zSuper){\n<line1>sqlite3_vfs *pVfs = pPager->pVfs;\n<line2>int rc;                   /* Return code */\n<line3>sqlite3_file *pSuper;     /* Malloc'd super-journal file descriptor */\n<line4>sqlite3_file *pJournal;   /* Malloc'd child-journal file descriptor */\n<line5>char *zSuperJournal = 0;  /* Contents of super-journal file */\n<line6>i64 nSuperJournal;        /* Size of super-journal file */\n<line7>char *zJournal;           /* Pointer to one journal within MJ file */\n<line8>char *zSuperPtr;          /* Space to hold super-journal filename */\n<line9>char *zFree = 0;          /* Free this buffer */\n<line10>i64 nSuperPtr;            /* Amount of space allocated to zSuperPtr[] */\n<line11>/* Allocate space for both the pJournal and pSuper file descriptors.\n<line12>** If successful, open the super-journal file for reading.\n<line13>*/\n<line14>pSuper = (sqlite3_file *)sqlite3MallocZero(2 * (i64)pVfs->szOsFile);\n<line15>if( !pSuper ){\n<line16>rc = SQLITE_NOMEM_BKPT;\n<line17>pJournal = 0;\n<line18>}else{\n<line19>const int flags = (SQLITE_OPEN_READONLY|SQLITE_OPEN_SUPER_JOURNAL);\n<line20>rc = sqlite3OsOpen(pVfs, zSuper, pSuper, flags, 0);\n<line21>pJournal = (sqlite3_file *)(((u8 *)pSuper) + pVfs->szOsFile);\n<line22>}\n<line23>if( rc!=SQLITE_OK ) goto delsuper_out;\n<line24>/* Load the entire super-journal file into space obtained from\n<line25>** sqlite3_malloc() and pointed to by zSuperJournal.   Also obtain\n<line26>** sufficient space (in zSuperPtr) to hold the names of super-journal\n<line27>** files extracted from regular rollback-journals.\n<line28>*/\n<line29>rc = sqlite3OsFileSize(pSuper, &nSuperJournal);\n<line30>if( rc!=SQLITE_OK ) goto delsuper_out;\n<line31>nSuperPtr = 1 + (i64)pVfs->mxPathname;\n<line32>assert( nSuperJournal>=0 && nSuperPtr>0 );\n<line33>zFree = sqlite3Malloc(4 + nSuperJournal + nSuperPtr + 2);\n<line34>if( !zFree ){\n<line35>rc = SQLITE_NOMEM_BKPT;\n<line36>goto delsuper_out;\n<line37>}else{\n<line38>assert( nSuperJournal<=0x7fffffff );\n<line39>}\n<line40>zFree[0] = zFree[1] = zFree[2] = zFree[3] = 0;\n<line41>zSuperJournal = &zFree[4];\n<line42>zSuperPtr = &zSuperJournal[nSuperJournal+2];\n<line43>rc = sqlite3OsRead(pSuper, zSuperJournal, (int)nSuperJournal, 0);\n<line44>if( rc!=SQLITE_OK ) goto delsuper_out;\n<line45>zSuperJournal[nSuperJournal] = 0;\n<line46>zSuperJournal[nSuperJournal+1] = 0;\n<line47>zJournal = zSuperJournal;\n<line48>while( (zJournal-zSuperJournal)<nSuperJournal ){\n<line49>int exists;\n<line50>rc = sqlite3OsAccess(pVfs, zJournal, SQLITE_ACCESS_EXISTS, &exists);\n<line51>if( rc!=SQLITE_OK ){\n<line52>goto delsuper_out;\n<line53>}\n<line54>if( exists ){\n<line55>/* One of the journals pointed to by the super-journal exists.\n<line56>** Open it and check if it points at the super-journal. If\n<line57>** so, return without deleting the super-journal file.\n<line58>** NB:  zJournal is really a MAIN_JOURNAL.  But call it a\n<line59>** SUPER_JOURNAL here so that the VFS will not send the zJournal\n<line60>** name into sqlite3_database_file_object().\n<line61>*/\n<line62>int c;\n<line63>int flags = (SQLITE_OPEN_READONLY|SQLITE_OPEN_SUPER_JOURNAL);\n<line64>rc = sqlite3OsOpen(pVfs, zJournal, pJournal, flags, 0);\n<line65>if( rc!=SQLITE_OK ){\n<line66>goto delsuper_out;\n<line67>}\n<line68>rc = readSuperJournal(pJournal, zSuperPtr, nSuperPtr);\n<line69>sqlite3OsClose(pJournal);\n<line70>if( rc!=SQLITE_OK ){\n<line71>goto delsuper_out;\n<line72>}\n<line73>c = zSuperPtr[0]!=0 && strcmp(zSuperPtr, zSuper)==0;\n<line74>if( c ){\n<line75>/* We have a match. Do not delete the super-journal file. */\n<line76>goto delsuper_out;\n<line77>}\n<line78>}\n<line79>zJournal += (sqlite3Strlen30(zJournal)+1);\n<line80>}\n<line81>sqlite3OsClose(pSuper);\n<line82>rc = sqlite3OsDelete(pVfs, zSuper, 0);\n<line83>delsuper_out:\n<line84>sqlite3_free(zFree);\n<line85>if( pSuper ){\n<line86>sqlite3OsClose(pSuper);\n<line87>assert( !isOpen(pJournal) );\n<line88>sqlite3_free(pSuper);\n<line89>}\n<line90>return rc;\n<line91>}
----------------------------------------
Function: pager_truncate
Content: <line0>static int pager_truncate(Pager *pPager, Pgno nPage){\n<line1>int rc = SQLITE_OK;\n<line2>assert( pPager->eState!=PAGER_ERROR );\n<line3>assert( pPager->eState!=PAGER_READER );\n<line4>PAGERTRACE(("Truncate %d npage %u\n", PAGERID(pPager), nPage));\n<line5>if( isOpen(pPager->fd)\n<line6>&& (pPager->eState>=PAGER_WRITER_DBMOD || pPager->eState==PAGER_OPEN)\n<line7>){\n<line8>i64 currentSize, newSize;\n<line9>int szPage = pPager->pageSize;\n<line10>assert( pPager->eLock==EXCLUSIVE_LOCK );\n<line11>/* TODO: Is it safe to use Pager.dbFileSize here? */\n<line12>rc = sqlite3OsFileSize(pPager->fd, &currentSize);\n<line13>newSize = szPage*(i64)nPage;\n<line14>if( rc==SQLITE_OK && currentSize!=newSize ){\n<line15>if( currentSize>newSize ){\n<line16>rc = sqlite3OsTruncate(pPager->fd, newSize);\n<line17>}else if( (currentSize+szPage)<=newSize ){\n<line18>char *pTmp = pPager->pTmpSpace;\n<line19>memset(pTmp, 0, szPage);\n<line20>testcase( (newSize-szPage) == currentSize );\n<line21>testcase( (newSize-szPage) >  currentSize );\n<line22>sqlite3OsFileControlHint(pPager->fd, SQLITE_FCNTL_SIZE_HINT, &newSize);\n<line23>rc = sqlite3OsWrite(pPager->fd, pTmp, szPage, newSize-szPage);\n<line24>}\n<line25>if( rc==SQLITE_OK ){\n<line26>pPager->dbFileSize = nPage;\n<line27>}\n<line28>}\n<line29>}\n<line30>return rc;\n<line31>}
----------------------------------------
Function: setSectorSize
Content: <line0>static void setSectorSize(Pager *pPager){\n<line1>assert( isOpen(pPager->fd) || pPager->tempFile );\n<line2>if( pPager->tempFile\n<line3>|| (sqlite3OsDeviceCharacteristics(pPager->fd) &\n<line4>SQLITE_IOCAP_POWERSAFE_OVERWRITE)!=0\n<line5>){\n<line6>/* Sector size doesn't matter for temporary files. Also, the file\n<line7>** may not have been opened yet, in which case the OsSectorSize()\n<line8>** call will segfault. */\n<line9>pPager->sectorSize = 512;\n<line10>}else{\n<line11>pPager->sectorSize = sqlite3SectorSize(pPager->fd);\n<line12>}\n<line13>}
----------------------------------------
Function: pager_playback
Content: <line0>static int pager_playback(Pager *pPager, int isHot){\n<line1>sqlite3_vfs *pVfs = pPager->pVfs;\n<line2>i64 szJ;                 /* Size of the journal file in bytes */\n<line3>u32 nRec;                /* Number of Records in the journal */\n<line4>u32 u;                   /* Unsigned loop counter */\n<line5>Pgno mxPg = 0;           /* Size of the original file in pages */\n<line6>int rc;                  /* Result code of a subroutine */\n<line7>int res = 1;             /* Value returned by sqlite3OsAccess() */\n<line8>char *zSuper = 0;        /* Name of super-journal file if any */\n<line9>int needPagerReset;      /* True to reset page prior to first page rollback */\n<line10>int nPlayback = 0;       /* Total number of pages restored from journal */\n<line11>u32 savedPageSize = pPager->pageSize;\n<line12>/* Figure out how many records are in the journal.  Abort early if\n<line13>** the journal is empty.\n<line14>*/\n<line15>assert( isOpen(pPager->jfd) );\n<line16>rc = sqlite3OsFileSize(pPager->jfd, &szJ);\n<line17>if( rc!=SQLITE_OK ){\n<line18>goto end_playback;\n<line19>}\n<line20>/* Read the super-journal name from the journal, if it is present.\n<line21>** If a super-journal file name is specified, but the file is not\n<line22>** present on disk, then the journal is not hot and does not need to be\n<line23>** played back.\n<line24>**\n<line25>** TODO: Technically the following is an error because it assumes that\n<line26>** buffer Pager.pTmpSpace is (mxPathname+1) bytes or larger. i.e. that\n<line27>** (pPager->pageSize >= pPager->pVfs->mxPathname+1). Using os_unix.c,\n<line28>** mxPathname is 512, which is the same as the minimum allowable value\n<line29>** for pageSize.\n<line30>*/\n<line31>zSuper = pPager->pTmpSpace;\n<line32>rc = readSuperJournal(pPager->jfd, zSuper, 1+(i64)pPager->pVfs->mxPathname);\n<line33>if( rc==SQLITE_OK && zSuper[0] ){\n<line34>rc = sqlite3OsAccess(pVfs, zSuper, SQLITE_ACCESS_EXISTS, &res);\n<line35>}\n<line36>zSuper = 0;\n<line37>if( rc!=SQLITE_OK || !res ){\n<line38>goto end_playback;\n<line39>}\n<line40>pPager->journalOff = 0;\n<line41>needPagerReset = isHot;\n<line42>/* This loop terminates either when a readJournalHdr() or\n<line43>** pager_playback_one_page() call returns SQLITE_DONE or an IO error\n<line44>** occurs.\n<line45>*/\n<line46>while( 1 ){\n<line47>/* Read the next journal header from the journal file.  If there are\n<line48>** not enough bytes left in the journal file for a complete header, or\n<line49>** it is corrupted, then a process must have failed while writing it.\n<line50>** This indicates nothing more needs to be rolled back.\n<line51>*/\n<line52>rc = readJournalHdr(pPager, isHot, szJ, &nRec, &mxPg);\n<line53>if( rc!=SQLITE_OK ){\n<line54>if( rc==SQLITE_DONE ){\n<line55>rc = SQLITE_OK;\n<line56>}\n<line57>goto end_playback;\n<line58>}\n<line59>/* If nRec is 0xffffffff, then this journal was created by a process\n<line60>** working in no-sync mode. This means that the rest of the journal\n<line61>** file consists of pages, there are no more journal headers. Compute\n<line62>** the value of nRec based on this assumption.\n<line63>*/\n<line64>if( nRec==0xffffffff ){\n<line65>assert( pPager->journalOff==JOURNAL_HDR_SZ(pPager) );\n<line66>nRec = (int)((szJ - JOURNAL_HDR_SZ(pPager))/JOURNAL_PG_SZ(pPager));\n<line67>}\n<line68>/* If nRec is 0 and this rollback is of a transaction created by this\n<line69>** process and if this is the final header in the journal, then it means\n<line70>** that this part of the journal was being filled but has not yet been\n<line71>** synced to disk.  Compute the number of pages based on the remaining\n<line72>** size of the file.\n<line73>**\n<line74>** The third term of the test was added to fix ticket #2565.\n<line75>** When rolling back a hot journal, nRec==0 always means that the next\n<line76>** chunk of the journal contains zero pages to be rolled back.  But\n<line77>** when doing a ROLLBACK and the nRec==0 chunk is the last chunk in\n<line78>** the journal, it means that the journal might contain additional\n<line79>** pages that need to be rolled back and that the number of pages\n<line80>** should be computed based on the journal file size.\n<line81>*/\n<line82>if( nRec==0 && !isHot &&\n<line83>pPager->journalHdr+JOURNAL_HDR_SZ(pPager)==pPager->journalOff ){\n<line84>nRec = (int)((szJ - pPager->journalOff) / JOURNAL_PG_SZ(pPager));\n<line85>}\n<line86>/* If this is the first header read from the journal, truncate the\n<line87>** database file back to its original size.\n<line88>*/\n<line89>if( pPager->journalOff==JOURNAL_HDR_SZ(pPager) ){\n<line90>rc = pager_truncate(pPager, mxPg);\n<line91>if( rc!=SQLITE_OK ){\n<line92>goto end_playback;\n<line93>}\n<line94>pPager->dbSize = mxPg;\n<line95>if( pPager->mxPgno<mxPg ){\n<line96>pPager->mxPgno = mxPg;\n<line97>}\n<line98>}\n<line99>/* Copy original pages out of the journal and back into the\n<line100>** database file and/or page cache.\n<line101>*/\n<line102>for(u=0; u<nRec; u++){\n<line103>if( needPagerReset ){\n<line104>pager_reset(pPager);\n<line105>needPagerReset = 0;\n<line106>}\n<line107>rc = pager_playback_one_page(pPager,&pPager->journalOff,0,1,0);\n<line108>if( rc==SQLITE_OK ){\n<line109>nPlayback++;\n<line110>}else{\n<line111>if( rc==SQLITE_DONE ){\n<line112>pPager->journalOff = szJ;\n<line113>break;\n<line114>}else if( rc==SQLITE_IOERR_SHORT_READ ){\n<line115>/* If the journal has been truncated, simply stop reading and\n<line116>** processing the journal. This might happen if the journal was\n<line117>** not completely written and synced prior to a crash.  In that\n<line118>** case, the database should have never been written in the\n<line119>** first place so it is OK to simply abandon the rollback. */\n<line120>rc = SQLITE_OK;\n<line121>goto end_playback;\n<line122>}else{\n<line123>/* If we are unable to rollback, quit and return the error\n<line124>** code.  This will cause the pager to enter the error state\n<line125>** so that no further harm will be done.  Perhaps the next\n<line126>** process to come along will be able to rollback the database.\n<line127>*/\n<line128>goto end_playback;\n<line129>}\n<line130>}\n<line131>}\n<line132>}\n<line133>/*NOTREACHED*/\n<line134>assert( 0 );\n<line135>end_playback:\n<line136>if( rc==SQLITE_OK ){\n<line137>rc = sqlite3PagerSetPagesize(pPager, &savedPageSize, -1);\n<line138>}\n<line139>/* Following a rollback, the database file should be back in its original\n<line140>** state prior to the start of the transaction, so invoke the\n<line141>** SQLITE_FCNTL_DB_UNCHANGED file-control method to disable the\n<line142>** assertion that the transaction counter was modified.\n<line143>*/\n<line144>#ifdef SQLITE_DEBUG\n<line145>sqlite3OsFileControlHint(pPager->fd,SQLITE_FCNTL_DB_UNCHANGED,0);\n<line146>#endif\n<line147>/* If this playback is happening automatically as a result of an IO or\n<line148>** malloc error that occurred after the change-counter was updated but\n<line149>** before the transaction was committed, then the change-counter\n<line150>** modification may just have been reverted. If this happens in exclusive\n<line151>** mode, then subsequent transactions performed by the connection will not\n<line152>** update the change-counter at all. This may lead to cache inconsistency\n<line153>** problems for other processes at some point in the future. So, just\n<line154>** in case this has happened, clear the changeCountDone flag now.\n<line155>*/\n<line156>pPager->changeCountDone = pPager->tempFile;\n<line157>if( rc==SQLITE_OK ){\n<line158>/* Leave 4 bytes of space before the super-journal filename in memory.\n<line159>** This is because it may end up being passed to sqlite3OsOpen(), in\n<line160>** which case it requires 4 0x00 bytes in memory immediately before\n<line161>** the filename. */\n<line162>zSuper = &pPager->pTmpSpace[4];\n<line163>rc = readSuperJournal(pPager->jfd, zSuper, 1+(i64)pPager->pVfs->mxPathname);\n<line164>testcase( rc!=SQLITE_OK );\n<line165>}\n<line166>if( rc==SQLITE_OK\n<line167>&& (pPager->eState>=PAGER_WRITER_DBMOD || pPager->eState==PAGER_OPEN)\n<line168>){\n<line169>rc = sqlite3PagerSync(pPager, 0);\n<line170>}\n<line171>if( rc==SQLITE_OK ){\n<line172>rc = pager_end_transaction(pPager, zSuper[0]!='\0', 0);\n<line173>testcase( rc!=SQLITE_OK );\n<line174>}\n<line175>if( rc==SQLITE_OK && zSuper[0] && res ){\n<line176>/* If there was a super-journal and this routine will return success,\n<line177>** see if it is possible to delete the super-journal.\n<line178>*/\n<line179>assert( zSuper==&pPager->pTmpSpace[4] );\n<line180>memset(pPager->pTmpSpace, 0, 4);\n<line181>rc = pager_delsuper(pPager, zSuper);\n<line182>testcase( rc!=SQLITE_OK );\n<line183>}\n<line184>if( isHot && nPlayback ){\n<line185>sqlite3_log(SQLITE_NOTICE_RECOVER_ROLLBACK, "recovered %d pages from %s",\n<line186>nPlayback, pPager->zJournal);\n<line187>}\n<line188>/* The Pager.sectorSize variable may have been updated while rolling\n<line189>** back a journal created by a process with a different sector size\n<line190>** value. Reset it to the correct value for this process.\n<line191>*/\n<line192>setSectorSize(pPager);\n<line193>return rc;\n<line194>}
----------------------------------------
Function: readDbPage
Content: <line0>static int readDbPage(PgHdr *pPg){\n<line1>Pager *pPager = pPg->pPager; /* Pager object associated with page pPg */\n<line2>int rc = SQLITE_OK;          /* Return code */\n<line3>#ifndef SQLITE_OMIT_WAL\n<line4>u32 iFrame = 0;              /* Frame of WAL containing pgno */\n<line5>assert( pPager->eState>=PAGER_READER && !MEMDB );\n<line6>assert( isOpen(pPager->fd) );\n<line7>if( pagerUseWal(pPager) ){\n<line8>rc = sqlite3WalFindFrame(pPager->pWal, pPg->pgno, &iFrame);\n<line9>if( rc ) return rc;\n<line10>}\n<line11>if( iFrame ){\n<line12>rc = sqlite3WalReadFrame(pPager->pWal, iFrame,pPager->pageSize,pPg->pData);\n<line13>}else\n<line14>#endif\n<line15>{\n<line16>i64 iOffset = (pPg->pgno-1)*(i64)pPager->pageSize;\n<line17>rc = sqlite3OsRead(pPager->fd, pPg->pData, pPager->pageSize, iOffset);\n<line18>if( rc==SQLITE_IOERR_SHORT_READ ){\n<line19>rc = SQLITE_OK;\n<line20>}\n<line21>}\n<line22>if( pPg->pgno==1 ){\n<line23>if( rc ){\n<line24>/* If the read is unsuccessful, set the dbFileVers[] to something\n<line25>** that will never be a valid file version.  dbFileVers[] is a copy\n<line26>** of bytes 24..39 of the database.  Bytes 28..31 should always be\n<line27>** zero or the size of the database in page. Bytes 32..35 and 35..39\n<line28>** should be page numbers which are never 0xffffffff.  So filling\n<line29>** pPager->dbFileVers[] with all 0xff bytes should suffice.\n<line30>**\n<line31>** For an encrypted database, the situation is more complex:  bytes\n<line32>** 24..39 of the database are white noise.  But the probability of\n<line33>** white noise equaling 16 bytes of 0xff is vanishingly small so\n<line34>** we should still be ok.\n<line35>*/\n<line36>memset(pPager->dbFileVers, 0xff, sizeof(pPager->dbFileVers));\n<line37>}else{\n<line38>u8 *dbFileVers = &((u8*)pPg->pData)[24];\n<line39>memcpy(&pPager->dbFileVers, dbFileVers, sizeof(pPager->dbFileVers));\n<line40>}\n<line41>}\n<line42>PAGER_INCR(sqlite3_pager_readdb_count);\n<line43>PAGER_INCR(pPager->nRead);\n<line44>IOTRACE(("PGIN %p %d\n", pPager, pPg->pgno));\n<line45>PAGERTRACE(("FETCH %d page %d hash(%08x)\n",\n<line46>PAGERID(pPager), pPg->pgno, pager_pagehash(pPg)));\n<line47>return rc;\n<line48>}
----------------------------------------
Function: pager_write_changecounter
Content: <line0>static void pager_write_changecounter(PgHdr *pPg){\n<line1>u32 change_counter;\n<line2>if( NEVER(pPg==0) ) return;\n<line3>/* Increment the value just read and write it back to byte 24. */\n<line4>change_counter = sqlite3Get4byte((u8*)pPg->pPager->dbFileVers)+1;\n<line5>put32bits(((char*)pPg->pData)+24, change_counter);\n<line6>/* Also store the SQLite version number in bytes 96..99 and in\n<line7>** bytes 92..95 store the change counter for which the version number\n<line8>** is valid. */\n<line9>put32bits(((char*)pPg->pData)+92, change_counter);\n<line10>put32bits(((char*)pPg->pData)+96, SQLITE_VERSION_NUMBER);\n<line11>}
----------------------------------------
Function: pagerUndoCallback
Content: <line0>static int pagerUndoCallback(void *pCtx, Pgno iPg){\n<line1>int rc = SQLITE_OK;\n<line2>Pager *pPager = (Pager *)pCtx;\n<line3>PgHdr *pPg;\n<line4>assert( pagerUseWal(pPager) );\n<line5>pPg = sqlite3PagerLookup(pPager, iPg);\n<line6>if( pPg ){\n<line7>if( sqlite3PcachePageRefcount(pPg)==1 ){\n<line8>sqlite3PcacheDrop(pPg);\n<line9>}else{\n<line10>rc = readDbPage(pPg);\n<line11>if( rc==SQLITE_OK ){\n<line12>pPager->xReiniter(pPg);\n<line13>}\n<line14>sqlite3PagerUnrefNotNull(pPg);\n<line15>}\n<line16>}\n<line17>/* Normally, if a transaction is rolled back, any backup processes are\n<line18>** updated as data is copied out of the rollback journal and into the\n<line19>** database. This is not generally possible with a WAL database, as\n<line20>** rollback involves simply truncating the log file. Therefore, if one\n<line21>** or more frames have already been written to the log (and therefore\n<line22>** also copied into the backup databases) as part of this transaction,\n<line23>** the backups must be restarted.\n<line24>*/\n<line25>sqlite3BackupRestart(pPager->pBackup);\n<line26>return rc;\n<line27>}
----------------------------------------
Function: pagerRollbackWal
Content: <line0>static int pagerRollbackWal(Pager *pPager){\n<line1>int rc;                         /* Return Code */\n<line2>PgHdr *pList;                   /* List of dirty pages to revert */\n<line3>/* For all pages in the cache that are currently dirty or have already\n<line4>** been written (but not committed) to the log file, do one of the\n<line5>** following:\n<line6>**\n<line7>**   + Discard the cached page (if refcount==0), or\n<line8>**   + Reload page content from the database (if refcount>0).\n<line9>*/\n<line10>pPager->dbSize = pPager->dbOrigSize;\n<line11>rc = sqlite3WalUndo(pPager->pWal, pagerUndoCallback, (void *)pPager);\n<line12>pList = sqlite3PcacheDirtyList(pPager->pPCache);\n<line13>while( pList && rc==SQLITE_OK ){\n<line14>PgHdr *pNext = pList->pDirty;\n<line15>rc = pagerUndoCallback((void *)pPager, pList->pgno);\n<line16>pList = pNext;\n<line17>}\n<line18>return rc;\n<line19>}
----------------------------------------
Function: pagerWalFrames
Content: <line0>static int pagerWalFrames(\n<line1>Pager *pPager,                  /* Pager object */\n<line2>PgHdr *pList,                   /* List of frames to log */\n<line3>Pgno nTruncate,                 /* Database size after this commit */\n<line4>int isCommit                    /* True if this is a commit */\n<line5>){\n<line6>int rc;                         /* Return code */\n<line7>int nList;                      /* Number of pages in pList */\n<line8>PgHdr *p;                       /* For looping over pages */\n<line9>assert( pPager->pWal );\n<line10>assert( pList );\n<line11>#ifdef SQLITE_DEBUG\n<line12>/* Verify that the page list is in ascending order */\n<line13>for(p=pList; p && p->pDirty; p=p->pDirty){\n<line14>assert( p->pgno < p->pDirty->pgno );\n<line15>}\n<line16>#endif\n<line17>assert( pList->pDirty==0 || isCommit );\n<line18>if( isCommit ){\n<line19>/* If a WAL transaction is being committed, there is no point in writing\n<line20>** any pages with page numbers greater than nTruncate into the WAL file.\n<line21>** They will never be read by any client. So remove them from the pDirty\n<line22>** list here. */\n<line23>PgHdr **ppNext = &pList;\n<line24>nList = 0;\n<line25>for(p=pList; (*ppNext = p)!=0; p=p->pDirty){\n<line26>if( p->pgno<=nTruncate ){\n<line27>ppNext = &p->pDirty;\n<line28>nList++;\n<line29>}\n<line30>}\n<line31>assert( pList );\n<line32>}else{\n<line33>nList = 1;\n<line34>}\n<line35>pPager->aStat[PAGER_STAT_WRITE] += nList;\n<line36>if( pList->pgno==1 ) pager_write_changecounter(pList);\n<line37>rc = sqlite3WalFrames(pPager->pWal,\n<line38>pPager->pageSize, pList, nTruncate, isCommit, pPager->walSyncFlags\n<line39>);\n<line40>if( rc==SQLITE_OK && pPager->pBackup ){\n<line41>for(p=pList; p; p=p->pDirty){\n<line42>sqlite3BackupUpdate(pPager->pBackup, p->pgno, (u8 *)p->pData);\n<line43>}\n<line44>}\n<line45>#ifdef SQLITE_CHECK_PAGES\n<line46>pList = sqlite3PcacheDirtyList(pPager->pPCache);\n<line47>for(p=pList; p; p=p->pDirty){\n<line48>pager_set_pagehash(p);\n<line49>}\n<line50>#endif\n<line51>return rc;\n<line52>}
----------------------------------------
Function: pagerBeginReadTransaction
Content: <line0>static int pagerBeginReadTransaction(Pager *pPager){\n<line1>int rc;                         /* Return code */\n<line2>int changed = 0;                /* True if cache must be reset */\n<line3>assert( pagerUseWal(pPager) );\n<line4>assert( pPager->eState==PAGER_OPEN || pPager->eState==PAGER_READER );\n<line5>/* sqlite3WalEndReadTransaction() was not called for the previous\n<line6>** transaction in locking_mode=EXCLUSIVE.  So call it now.  If we\n<line7>** are in locking_mode=NORMAL and EndRead() was previously called,\n<line8>** the duplicate call is harmless.\n<line9>*/\n<line10>sqlite3WalEndReadTransaction(pPager->pWal);\n<line11>rc = sqlite3WalBeginReadTransaction(pPager->pWal, &changed);\n<line12>if( rc!=SQLITE_OK || changed ){\n<line13>pager_reset(pPager);\n<line14>if( USEFETCH(pPager) ) sqlite3OsUnfetch(pPager->fd, 0, 0);\n<line15>}\n<line16>return rc;\n<line17>}
----------------------------------------
Function: pagerPagecount
Content: <line0>static int pagerPagecount(Pager *pPager, Pgno *pnPage){\n<line1>Pgno nPage;                     /* Value to return via *pnPage */\n<line2>/* Query the WAL sub-system for the database size. The WalDbsize()\n<line3>** function returns zero if the WAL is not open (i.e. Pager.pWal==0), or\n<line4>** if the database size is not available. The database size is not\n<line5>** available from the WAL sub-system if the log file is empty or\n<line6>** contains no valid committed transactions.\n<line7>*/\n<line8>assert( pPager->eState==PAGER_OPEN );\n<line9>assert( pPager->eLock>=SHARED_LOCK );\n<line10>assert( isOpen(pPager->fd) );\n<line11>assert( pPager->tempFile==0 );\n<line12>nPage = sqlite3WalDbsize(pPager->pWal);\n<line13>/* If the number of pages in the database is not available from the\n<line14>** WAL sub-system, determine the page count based on the size of\n<line15>** the database file.  If the size of the database file is not an\n<line16>** integer multiple of the page-size, round up the result.\n<line17>*/\n<line18>if( nPage==0 && ALWAYS(isOpen(pPager->fd)) ){\n<line19>i64 n = 0;                    /* Size of db file in bytes */\n<line20>int rc = sqlite3OsFileSize(pPager->fd, &n);\n<line21>if( rc!=SQLITE_OK ){\n<line22>return rc;\n<line23>}\n<line24>nPage = (Pgno)((n+pPager->pageSize-1) / pPager->pageSize);\n<line25>}\n<line26>/* If the current number of pages in the file is greater than the\n<line27>** configured maximum pager number, increase the allowed limit so\n<line28>** that the file can be read.\n<line29>*/\n<line30>if( nPage>pPager->mxPgno ){\n<line31>pPager->mxPgno = (Pgno)nPage;\n<line32>}\n<line33>*pnPage = nPage;\n<line34>return SQLITE_OK;\n<line35>}
----------------------------------------
Function: pagerOpenWalIfPresent
Content: <line0>static int pagerOpenWalIfPresent(Pager *pPager){\n<line1>int rc = SQLITE_OK;\n<line2>assert( pPager->eState==PAGER_OPEN );\n<line3>assert( pPager->eLock>=SHARED_LOCK );\n<line4>if( !pPager->tempFile ){\n<line5>int isWal;                    /* True if WAL file exists */\n<line6>rc = sqlite3OsAccess(\n<line7>pPager->pVfs, pPager->zWal, SQLITE_ACCESS_EXISTS, &isWal\n<line8>);\n<line9>if( rc==SQLITE_OK ){\n<line10>if( isWal ){\n<line11>Pgno nPage;                   /* Size of the database file */\n<line12>rc = pagerPagecount(pPager, &nPage);\n<line13>if( rc ) return rc;\n<line14>if( nPage==0 ){\n<line15>rc = sqlite3OsDelete(pPager->pVfs, pPager->zWal, 0);\n<line16>}else{\n<line17>testcase( sqlite3PcachePagecount(pPager->pPCache)==0 );\n<line18>rc = sqlite3PagerOpenWal(pPager, 0);\n<line19>}\n<line20>}else if( pPager->journalMode==PAGER_JOURNALMODE_WAL ){\n<line21>pPager->journalMode = PAGER_JOURNALMODE_DELETE;\n<line22>}\n<line23>}\n<line24>}\n<line25>return rc;\n<line26>}
----------------------------------------
Function: pagerPlaybackSavepoint
Content: <line0>static int pagerPlaybackSavepoint(Pager *pPager, PagerSavepoint *pSavepoint){\n<line1>i64 szJ;                 /* Effective size of the main journal */\n<line2>i64 iHdrOff;             /* End of first segment of main-journal records */\n<line3>int rc = SQLITE_OK;      /* Return code */\n<line4>Bitvec *pDone = 0;       /* Bitvec to ensure pages played back only once */\n<line5>assert( pPager->eState!=PAGER_ERROR );\n<line6>assert( pPager->eState>=PAGER_WRITER_LOCKED );\n<line7>/* Allocate a bitvec to use to store the set of pages rolled back */\n<line8>if( pSavepoint ){\n<line9>pDone = sqlite3BitvecCreate(pSavepoint->nOrig);\n<line10>if( !pDone ){\n<line11>return SQLITE_NOMEM_BKPT;\n<line12>}\n<line13>}\n<line14>/* Set the database size back to the value it was before the savepoint\n<line15>** being reverted was opened.\n<line16>*/\n<line17>pPager->dbSize = pSavepoint ? pSavepoint->nOrig : pPager->dbOrigSize;\n<line18>pPager->changeCountDone = pPager->tempFile;\n<line19>if( !pSavepoint && pagerUseWal(pPager) ){\n<line20>return pagerRollbackWal(pPager);\n<line21>}\n<line22>/* Use pPager->journalOff as the effective size of the main rollback\n<line23>** journal.  The actual file might be larger than this in\n<line24>** PAGER_JOURNALMODE_TRUNCATE or PAGER_JOURNALMODE_PERSIST.  But anything\n<line25>** past pPager->journalOff is off-limits to us.\n<line26>*/\n<line27>szJ = pPager->journalOff;\n<line28>assert( pagerUseWal(pPager)==0 || szJ==0 );\n<line29>/* Begin by rolling back records from the main journal starting at\n<line30>** PagerSavepoint.iOffset and continuing to the next journal header.\n<line31>** There might be records in the main journal that have a page number\n<line32>** greater than the current database size (pPager->dbSize) but those\n<line33>** will be skipped automatically.  Pages are added to pDone as they\n<line34>** are played back.\n<line35>*/\n<line36>if( pSavepoint && !pagerUseWal(pPager) ){\n<line37>iHdrOff = pSavepoint->iHdrOffset ? pSavepoint->iHdrOffset : szJ;\n<line38>pPager->journalOff = pSavepoint->iOffset;\n<line39>while( rc==SQLITE_OK && pPager->journalOff<iHdrOff ){\n<line40>rc = pager_playback_one_page(pPager, &pPager->journalOff, pDone, 1, 1);\n<line41>}\n<line42>assert( rc!=SQLITE_DONE );\n<line43>}else{\n<line44>pPager->journalOff = 0;\n<line45>}\n<line46>/* Continue rolling back records out of the main journal starting at\n<line47>** the first journal header seen and continuing until the effective end\n<line48>** of the main journal file.  Continue to skip out-of-range pages and\n<line49>** continue adding pages rolled back to pDone.\n<line50>*/\n<line51>while( rc==SQLITE_OK && pPager->journalOff<szJ ){\n<line52>u32 ii;            /* Loop counter */\n<line53>u32 nJRec = 0;     /* Number of Journal Records */\n<line54>u32 dummy;\n<line55>rc = readJournalHdr(pPager, 0, szJ, &nJRec, &dummy);\n<line56>assert( rc!=SQLITE_DONE );\n<line57>/*\n<line58>** The "pPager->journalHdr+JOURNAL_HDR_SZ(pPager)==pPager->journalOff"\n<line59>** test is related to ticket #2565.  See the discussion in the\n<line60>** pager_playback() function for additional information.\n<line61>*/\n<line62>if( nJRec==0\n<line63>&& pPager->journalHdr+JOURNAL_HDR_SZ(pPager)==pPager->journalOff\n<line64>){\n<line65>nJRec = (u32)((szJ - pPager->journalOff)/JOURNAL_PG_SZ(pPager));\n<line66>}\n<line67>for(ii=0; rc==SQLITE_OK && ii<nJRec && pPager->journalOff<szJ; ii++){\n<line68>rc = pager_playback_one_page(pPager, &pPager->journalOff, pDone, 1, 1);\n<line69>}\n<line70>assert( rc!=SQLITE_DONE );\n<line71>}\n<line72>assert( rc!=SQLITE_OK || pPager->journalOff>=szJ );\n<line73>/* Finally,  rollback pages from the sub-journal.  Page that were\n<line74>** previously rolled back out of the main journal (and are hence in pDone)\n<line75>** will be skipped.  Out-of-range pages are also skipped.\n<line76>*/\n<line77>if( pSavepoint ){\n<line78>u32 ii;            /* Loop counter */\n<line79>i64 offset = (i64)pSavepoint->iSubRec*(4+pPager->pageSize);\n<line80>if( pagerUseWal(pPager) ){\n<line81>rc = sqlite3WalSavepointUndo(pPager->pWal, pSavepoint->aWalData);\n<line82>}\n<line83>for(ii=pSavepoint->iSubRec; rc==SQLITE_OK && ii<pPager->nSubRec; ii++){\n<line84>assert( offset==(i64)ii*(4+pPager->pageSize) );\n<line85>rc = pager_playback_one_page(pPager, &offset, pDone, 0, 1);\n<line86>}\n<line87>assert( rc!=SQLITE_DONE );\n<line88>}\n<line89>sqlite3BitvecDestroy(pDone);\n<line90>if( rc==SQLITE_OK ){\n<line91>pPager->journalOff = szJ;\n<line92>}\n<line93>return rc;\n<line94>}
----------------------------------------
Function: pagerFixMaplimit
Content: <line0>static void pagerFixMaplimit(Pager *pPager){\n<line1>#if SQLITE_MAX_MMAP_SIZE>0\n<line2>sqlite3_file *fd = pPager->fd;\n<line3>if( isOpen(fd) && fd->pMethods->iVersion>=3 ){\n<line4>sqlite3_int64 sz;\n<line5>sz = pPager->szMmap;\n<line6>pPager->bUseFetch = (sz>0);\n<line7>setGetterMethod(pPager);\n<line8>sqlite3OsFileControlHint(pPager->fd, SQLITE_FCNTL_MMAP_SIZE, &sz);\n<line9>}\n<line10>#endif\n<line11>}
----------------------------------------
Function: pagerOpentemp
Content: <line0>static int pagerOpentemp(\n<line1>Pager *pPager,        /* The pager object */\n<line2>sqlite3_file *pFile,  /* Write the file descriptor here */\n<line3>int vfsFlags          /* Flags passed through to the VFS */\n<line4>){\n<line5>int rc;               /* Return code */\n<line6>#ifdef SQLITE_TEST\n<line7>sqlite3_opentemp_count++;  /* Used for testing and analysis only */\n<line8>#endif\n<line9>vfsFlags |=  SQLITE_OPEN_READWRITE | SQLITE_OPEN_CREATE |\n<line10>SQLITE_OPEN_EXCLUSIVE | SQLITE_OPEN_DELETEONCLOSE;\n<line11>rc = sqlite3OsOpen(pPager->pVfs, 0, pFile, vfsFlags, 0);\n<line12>assert( rc!=SQLITE_OK || isOpen(pFile) );\n<line13>return rc;\n<line14>}
----------------------------------------
Function: pager_wait_on_lock
Content: <line0>static int pager_wait_on_lock(Pager *pPager, int locktype){\n<line1>int rc;                              /* Return code */\n<line2>/* Check that this is either a no-op (because the requested lock is\n<line3>** already held), or one of the transitions that the busy-handler\n<line4>** may be invoked during, according to the comment above\n<line5>** sqlite3PagerSetBusyhandler().\n<line6>*/\n<line7>assert( (pPager->eLock>=locktype)\n<line8>|| (pPager->eLock==NO_LOCK && locktype==SHARED_LOCK)\n<line9>|| (pPager->eLock==RESERVED_LOCK && locktype==EXCLUSIVE_LOCK)\n<line10>);\n<line11>do {\n<line12>rc = pagerLockDb(pPager, locktype);\n<line13>}while( rc==SQLITE_BUSY && pPager->xBusyHandler(pPager->pBusyHandlerArg) );\n<line14>return rc;\n<line15>}
----------------------------------------
Function: pagerSyncHotJournal
Content: <line0>static int pagerSyncHotJournal(Pager *pPager){\n<line1>int rc = SQLITE_OK;\n<line2>if( !pPager->noSync ){\n<line3>rc = sqlite3OsSync(pPager->jfd, SQLITE_SYNC_NORMAL);\n<line4>}\n<line5>if( rc==SQLITE_OK ){\n<line6>rc = sqlite3OsFileSize(pPager->jfd, &pPager->journalHdr);\n<line7>}\n<line8>return rc;\n<line9>}
----------------------------------------
Function: pagerAcquireMapPage
Content: <line0>static int pagerAcquireMapPage(\n<line1>Pager *pPager,                  /* Pager object */\n<line2>Pgno pgno,                      /* Page number */\n<line3>void *pData,                    /* xFetch()'d data for this page */\n<line4>PgHdr **ppPage                  /* OUT: Acquired page object */\n<line5>){\n<line6>PgHdr *p;                       /* Memory mapped page to return */\n<line7>if( pPager->pMmapFreelist ){\n<line8>*ppPage = p = pPager->pMmapFreelist;\n<line9>pPager->pMmapFreelist = p->pDirty;\n<line10>p->pDirty = 0;\n<line11>assert( pPager->nExtra>=8 );\n<line12>memset(p->pExtra, 0, 8);\n<line13>}else{\n<line14>*ppPage = p = (PgHdr *)sqlite3MallocZero(sizeof(PgHdr) + pPager->nExtra);\n<line15>if( p==0 ){\n<line16>sqlite3OsUnfetch(pPager->fd, (i64)(pgno-1) * pPager->pageSize, pData);\n<line17>return SQLITE_NOMEM_BKPT;\n<line18>}\n<line19>p->pExtra = (void *)&p[1];\n<line20>assert( EIGHT_BYTE_ALIGNMENT( p->pExtra ) );\n<line21>p->flags = PGHDR_MMAP;\n<line22>p->nRef = 1;\n<line23>p->pPager = pPager;\n<line24>}\n<line25>assert( p->pExtra==(void *)&p[1] );\n<line26>assert( p->pPage==0 );\n<line27>assert( p->flags==PGHDR_MMAP );\n<line28>assert( p->pPager==pPager );\n<line29>assert( p->nRef==1 );\n<line30>p->pgno = pgno;\n<line31>p->pData = pData;\n<line32>pPager->nMmapOut++;\n<line33>return SQLITE_OK;\n<line34>}
----------------------------------------
Function: pagerReleaseMapPage
Content: <line0>static void pagerReleaseMapPage(PgHdr *pPg){\n<line1>Pager *pPager = pPg->pPager;\n<line2>pPager->nMmapOut--;\n<line3>pPg->pDirty = pPager->pMmapFreelist;\n<line4>pPager->pMmapFreelist = pPg;\n<line5>assert( pPager->fd->pMethods->iVersion>=3 );\n<line6>sqlite3OsUnfetch(pPager->fd, (i64)(pPg->pgno-1)*pPager->pageSize, pPg->pData);\n<line7>}
----------------------------------------
Function: pagerFreeMapHdrs
Content: <line0>static void pagerFreeMapHdrs(Pager *pPager){\n<line1>PgHdr *p;\n<line2>PgHdr *pNext;\n<line3>for(p=pPager->pMmapFreelist; p; p=pNext){\n<line4>pNext = p->pDirty;\n<line5>sqlite3_free(p);\n<line6>}\n<line7>}
----------------------------------------
Function: databaseIsUnmoved
Content: <line0>static int databaseIsUnmoved(Pager *pPager){\n<line1>int bHasMoved = 0;\n<line2>int rc;\n<line3>if( pPager->tempFile ) return SQLITE_OK;\n<line4>if( pPager->dbSize==0 ) return SQLITE_OK;\n<line5>assert( pPager->zFilename && pPager->zFilename[0] );\n<line6>rc = sqlite3OsFileControl(pPager->fd, SQLITE_FCNTL_HAS_MOVED, &bHasMoved);\n<line7>if( rc==SQLITE_NOTFOUND ){\n<line8>/* If the HAS_MOVED file-control is unimplemented, assume that the file\n<line9>** has not been moved.  That is the historical behavior of SQLite: prior to\n<line10>** version 3.8.3, it never checked */\n<line11>rc = SQLITE_OK;\n<line12>}else if( rc==SQLITE_OK && bHasMoved ){\n<line13>rc = SQLITE_READONLY_DBMOVED;\n<line14>}\n<line15>return rc;\n<line16>}
----------------------------------------
Function: syncJournal
Content: <line0>static int syncJournal(Pager *pPager, int newHdr){\n<line1>int rc;                         /* Return code */\n<line2>assert( pPager->eState==PAGER_WRITER_CACHEMOD\n<line3>|| pPager->eState==PAGER_WRITER_DBMOD\n<line4>);\n<line5>assert( assert_pager_state(pPager) );\n<line6>assert( !pagerUseWal(pPager) );\n<line7>rc = sqlite3PagerExclusiveLock(pPager);\n<line8>if( rc!=SQLITE_OK ) return rc;\n<line9>if( !pPager->noSync ){\n<line10>assert( !pPager->tempFile );\n<line11>if( isOpen(pPager->jfd) && pPager->journalMode!=PAGER_JOURNALMODE_MEMORY ){\n<line12>const int iDc = sqlite3OsDeviceCharacteristics(pPager->fd);\n<line13>assert( isOpen(pPager->jfd) );\n<line14>if( 0==(iDc&SQLITE_IOCAP_SAFE_APPEND) ){\n<line15>/* This block deals with an obscure problem. If the last connection\n<line16>** that wrote to this database was operating in persistent-journal\n<line17>** mode, then the journal file may at this point actually be larger\n<line18>** than Pager.journalOff bytes. If the next thing in the journal\n<line19>** file happens to be a journal-header (written as part of the\n<line20>** previous connection's transaction), and a crash or power-failure\n<line21>** occurs after nRec is updated but before this connection writes\n<line22>** anything else to the journal file (or commits/rolls back its\n<line23>** transaction), then SQLite may become confused when doing the\n<line24>** hot-journal rollback following recovery. It may roll back all\n<line25>** of this connections data, then proceed to rolling back the old,\n<line26>** out-of-date data that follows it. Database corruption.\n<line27>**\n<line28>** To work around this, if the journal file does appear to contain\n<line29>** a valid header following Pager.journalOff, then write a 0x00\n<line30>** byte to the start of it to prevent it from being recognized.\n<line31>**\n<line32>** Variable iNextHdrOffset is set to the offset at which this\n<line33>** problematic header will occur, if it exists. aMagic is used\n<line34>** as a temporary buffer to inspect the first couple of bytes of\n<line35>** the potential journal header.\n<line36>*/\n<line37>i64 iNextHdrOffset;\n<line38>u8 aMagic[8];\n<line39>u8 zHeader[sizeof(aJournalMagic)+4];\n<line40>memcpy(zHeader, aJournalMagic, sizeof(aJournalMagic));\n<line41>put32bits(&zHeader[sizeof(aJournalMagic)], pPager->nRec);\n<line42>iNextHdrOffset = journalHdrOffset(pPager);\n<line43>rc = sqlite3OsRead(pPager->jfd, aMagic, 8, iNextHdrOffset);\n<line44>if( rc==SQLITE_OK && 0==memcmp(aMagic, aJournalMagic, 8) ){\n<line45>static const u8 zerobyte = 0;\n<line46>rc = sqlite3OsWrite(pPager->jfd, &zerobyte, 1, iNextHdrOffset);\n<line47>}\n<line48>if( rc!=SQLITE_OK && rc!=SQLITE_IOERR_SHORT_READ ){\n<line49>return rc;\n<line50>}\n<line51>/* Write the nRec value into the journal file header. If in\n<line52>** full-synchronous mode, sync the journal first. This ensures that\n<line53>** all data has really hit the disk before nRec is updated to mark\n<line54>** it as a candidate for rollback.\n<line55>**\n<line56>** This is not required if the persistent media supports the\n<line57>** SAFE_APPEND property. Because in this case it is not possible\n<line58>** for garbage data to be appended to the file, the nRec field\n<line59>** is populated with 0xFFFFFFFF when the journal header is written\n<line60>** and never needs to be updated.\n<line61>*/\n<line62>if( pPager->fullSync && 0==(iDc&SQLITE_IOCAP_SEQUENTIAL) ){\n<line63>PAGERTRACE(("SYNC journal of %d\n", PAGERID(pPager)));\n<line64>IOTRACE(("JSYNC %p\n", pPager))\n<line65>rc = sqlite3OsSync(pPager->jfd, pPager->syncFlags);\n<line66>if( rc!=SQLITE_OK ) return rc;\n<line67>}\n<line68>IOTRACE(("JHDR %p %lld\n", pPager, pPager->journalHdr));\n<line69>rc = sqlite3OsWrite(\n<line70>pPager->jfd, zHeader, sizeof(zHeader), pPager->journalHdr\n<line71>);\n<line72>if( rc!=SQLITE_OK ) return rc;\n<line73>}\n<line74>if( 0==(iDc&SQLITE_IOCAP_SEQUENTIAL) ){\n<line75>PAGERTRACE(("SYNC journal of %d\n", PAGERID(pPager)));\n<line76>IOTRACE(("JSYNC %p\n", pPager))\n<line77>rc = sqlite3OsSync(pPager->jfd, pPager->syncFlags|\n<line78>(pPager->syncFlags==SQLITE_SYNC_FULL?SQLITE_SYNC_DATAONLY:0)\n<line79>);\n<line80>if( rc!=SQLITE_OK ) return rc;\n<line81>}\n<line82>pPager->journalHdr = pPager->journalOff;\n<line83>if( newHdr && 0==(iDc&SQLITE_IOCAP_SAFE_APPEND) ){\n<line84>pPager->nRec = 0;\n<line85>rc = writeJournalHdr(pPager);\n<line86>if( rc!=SQLITE_OK ) return rc;\n<line87>}\n<line88>}else{\n<line89>pPager->journalHdr = pPager->journalOff;\n<line90>}\n<line91>}\n<line92>/* Unless the pager is in noSync mode, the journal file was just\n<line93>** successfully synced. Either way, clear the PGHDR_NEED_SYNC flag on\n<line94>** all pages.\n<line95>*/\n<line96>sqlite3PcacheClearSyncFlags(pPager->pPCache);\n<line97>pPager->eState = PAGER_WRITER_DBMOD;\n<line98>assert( assert_pager_state(pPager) );\n<line99>return SQLITE_OK;\n<line100>}
----------------------------------------
Function: pager_write_pagelist
Content: <line0>static int pager_write_pagelist(Pager *pPager, PgHdr *pList){\n<line1>int rc = SQLITE_OK;                  /* Return code */\n<line2>/* This function is only called for rollback pagers in WRITER_DBMOD state. */\n<line3>assert( !pagerUseWal(pPager) );\n<line4>assert( pPager->tempFile || pPager->eState==PAGER_WRITER_DBMOD );\n<line5>assert( pPager->eLock==EXCLUSIVE_LOCK );\n<line6>assert( isOpen(pPager->fd) || pList->pDirty==0 );\n<line7>/* If the file is a temp-file has not yet been opened, open it now. It\n<line8>** is not possible for rc to be other than SQLITE_OK if this branch\n<line9>** is taken, as pager_wait_on_lock() is a no-op for temp-files.\n<line10>*/\n<line11>if( !isOpen(pPager->fd) ){\n<line12>assert( pPager->tempFile && rc==SQLITE_OK );\n<line13>rc = pagerOpentemp(pPager, pPager->fd, pPager->vfsFlags);\n<line14>}\n<line15>/* Before the first write, give the VFS a hint of what the final\n<line16>** file size will be.\n<line17>*/\n<line18>assert( rc!=SQLITE_OK || isOpen(pPager->fd) );\n<line19>if( rc==SQLITE_OK\n<line20>&& pPager->dbHintSize<pPager->dbSize\n<line21>&& (pList->pDirty || pList->pgno>pPager->dbHintSize)\n<line22>){\n<line23>sqlite3_int64 szFile = pPager->pageSize * (sqlite3_int64)pPager->dbSize;\n<line24>sqlite3OsFileControlHint(pPager->fd, SQLITE_FCNTL_SIZE_HINT, &szFile);\n<line25>pPager->dbHintSize = pPager->dbSize;\n<line26>}\n<line27>while( rc==SQLITE_OK && pList ){\n<line28>Pgno pgno = pList->pgno;\n<line29>/* If there are dirty pages in the page cache with page numbers greater\n<line30>** than Pager.dbSize, this means sqlite3PagerTruncateImage() was called to\n<line31>** make the file smaller (presumably by auto-vacuum code). Do not write\n<line32>** any such pages to the file.\n<line33>**\n<line34>** Also, do not write out any page that has the PGHDR_DONT_WRITE flag\n<line35>** set (set by sqlite3PagerDontWrite()).\n<line36>*/\n<line37>if( pgno<=pPager->dbSize && 0==(pList->flags&PGHDR_DONT_WRITE) ){\n<line38>i64 offset = (pgno-1)*(i64)pPager->pageSize;   /* Offset to write */\n<line39>char *pData;                                   /* Data to write */\n<line40>assert( (pList->flags&PGHDR_NEED_SYNC)==0 );\n<line41>if( pList->pgno==1 ) pager_write_changecounter(pList);\n<line42>pData = pList->pData;\n<line43>/* Write out the page data. */\n<line44>rc = sqlite3OsWrite(pPager->fd, pData, pPager->pageSize, offset);\n<line45>/* If page 1 was just written, update Pager.dbFileVers to match\n<line46>** the value now stored in the database file. If writing this\n<line47>** page caused the database file to grow, update dbFileSize.\n<line48>*/\n<line49>if( pgno==1 ){\n<line50>memcpy(&pPager->dbFileVers, &pData[24], sizeof(pPager->dbFileVers));\n<line51>}\n<line52>if( pgno>pPager->dbFileSize ){\n<line53>pPager->dbFileSize = pgno;\n<line54>}\n<line55>pPager->aStat[PAGER_STAT_WRITE]++;\n<line56>/* Update any backup objects copying the contents of this pager. */\n<line57>sqlite3BackupUpdate(pPager->pBackup, pgno, (u8*)pList->pData);\n<line58>PAGERTRACE(("STORE %d page %d hash(%08x)\n",\n<line59>PAGERID(pPager), pgno, pager_pagehash(pList)));\n<line60>IOTRACE(("PGOUT %p %d\n", pPager, pgno));\n<line61>PAGER_INCR(sqlite3_pager_writedb_count);\n<line62>}else{\n<line63>PAGERTRACE(("NOSTORE %d page %d\n", PAGERID(pPager), pgno));\n<line64>}\n<line65>pager_set_pagehash(pList);\n<line66>pList = pList->pDirty;\n<line67>}\n<line68>return rc;\n<line69>}
----------------------------------------
Function: openSubJournal
Content: <line0>static int openSubJournal(Pager *pPager){\n<line1>int rc = SQLITE_OK;\n<line2>if( !isOpen(pPager->sjfd) ){\n<line3>const int flags =  SQLITE_OPEN_SUBJOURNAL | SQLITE_OPEN_READWRITE\n<line4>| SQLITE_OPEN_CREATE | SQLITE_OPEN_EXCLUSIVE\n<line5>| SQLITE_OPEN_DELETEONCLOSE;\n<line6>int nStmtSpill = sqlite3Config.nStmtSpill;\n<line7>if( pPager->journalMode==PAGER_JOURNALMODE_MEMORY || pPager->subjInMemory ){\n<line8>nStmtSpill = -1;\n<line9>}\n<line10>rc = sqlite3JournalOpen(pPager->pVfs, 0, pPager->sjfd, flags, nStmtSpill);\n<line11>}\n<line12>return rc;\n<line13>}
----------------------------------------
Function: subjournalPage
Content: <line0>static int subjournalPage(PgHdr *pPg){\n<line1>int rc = SQLITE_OK;\n<line2>Pager *pPager = pPg->pPager;\n<line3>if( pPager->journalMode!=PAGER_JOURNALMODE_OFF ){\n<line4>/* Open the sub-journal, if it has not already been opened */\n<line5>assert( pPager->useJournal );\n<line6>assert( isOpen(pPager->jfd) || pagerUseWal(pPager) );\n<line7>assert( isOpen(pPager->sjfd) || pPager->nSubRec==0 );\n<line8>assert( pagerUseWal(pPager)\n<line9>|| pageInJournal(pPager, pPg)\n<line10>|| pPg->pgno>pPager->dbOrigSize\n<line11>);\n<line12>rc = openSubJournal(pPager);\n<line13>/* If the sub-journal was opened successfully (or was already open),\n<line14>** write the journal record into the file.  */\n<line15>if( rc==SQLITE_OK ){\n<line16>void *pData = pPg->pData;\n<line17>i64 offset = (i64)pPager->nSubRec*(4+pPager->pageSize);\n<line18>char *pData2;\n<line19>pData2 = pData;\n<line20>PAGERTRACE(("STMT-JOURNAL %d page %d\n", PAGERID(pPager), pPg->pgno));\n<line21>rc = write32bits(pPager->sjfd, offset, pPg->pgno);\n<line22>if( rc==SQLITE_OK ){\n<line23>rc = sqlite3OsWrite(pPager->sjfd, pData2, pPager->pageSize, offset+4);\n<line24>}\n<line25>}\n<line26>}\n<line27>if( rc==SQLITE_OK ){\n<line28>pPager->nSubRec++;\n<line29>assert( pPager->nSavepoint>0 );\n<line30>rc = addToSavepointBitvecs(pPager, pPg->pgno);\n<line31>}\n<line32>return rc;\n<line33>}
----------------------------------------
Function: subjournalPageIfRequired
Content: <line0>static int subjournalPageIfRequired(PgHdr *pPg){\n<line1>if( subjRequiresPage(pPg) ){\n<line2>return subjournalPage(pPg);\n<line3>}else{\n<line4>return SQLITE_OK;\n<line5>}\n<line6>}
----------------------------------------
Function: pagerStress
Content: <line0>static int pagerStress(void *p, PgHdr *pPg){\n<line1>Pager *pPager = (Pager *)p;\n<line2>int rc = SQLITE_OK;\n<line3>assert( pPg->pPager==pPager );\n<line4>assert( pPg->flags&PGHDR_DIRTY );\n<line5>/* The doNotSpill NOSYNC bit is set during times when doing a sync of\n<line6>** journal (and adding a new header) is not allowed.  This occurs\n<line7>** during calls to sqlite3PagerWrite() while trying to journal multiple\n<line8>** pages belonging to the same sector.\n<line9>**\n<line10>** The doNotSpill ROLLBACK and OFF bits inhibits all cache spilling\n<line11>** regardless of whether or not a sync is required.  This is set during\n<line12>** a rollback or by user request, respectively.\n<line13>**\n<line14>** Spilling is also prohibited when in an error state since that could\n<line15>** lead to database corruption.   In the current implementation it\n<line16>** is impossible for sqlite3PcacheFetch() to be called with createFlag==3\n<line17>** while in the error state, hence it is impossible for this routine to\n<line18>** be called in the error state.  Nevertheless, we include a NEVER()\n<line19>** test for the error state as a safeguard against future changes.\n<line20>*/\n<line21>if( NEVER(pPager->errCode) ) return SQLITE_OK;\n<line22>testcase( pPager->doNotSpill & SPILLFLAG_ROLLBACK );\n<line23>testcase( pPager->doNotSpill & SPILLFLAG_OFF );\n<line24>testcase( pPager->doNotSpill & SPILLFLAG_NOSYNC );\n<line25>if( pPager->doNotSpill\n<line26>&& ((pPager->doNotSpill & (SPILLFLAG_ROLLBACK|SPILLFLAG_OFF))!=0\n<line27>|| (pPg->flags & PGHDR_NEED_SYNC)!=0)\n<line28>){\n<line29>return SQLITE_OK;\n<line30>}\n<line31>pPager->aStat[PAGER_STAT_SPILL]++;\n<line32>pPg->pDirty = 0;\n<line33>if( pagerUseWal(pPager) ){\n<line34>/* Write a single frame for this page to the log. */\n<line35>rc = subjournalPageIfRequired(pPg);\n<line36>if( rc==SQLITE_OK ){\n<line37>rc = pagerWalFrames(pPager, pPg, 0, 0);\n<line38>}\n<line39>}else{\n<line40>#ifdef SQLITE_ENABLE_BATCH_ATOMIC_WRITE\n<line41>if( pPager->tempFile==0 ){\n<line42>rc = sqlite3JournalCreate(pPager->jfd);\n<line43>if( rc!=SQLITE_OK ) return pager_error(pPager, rc);\n<line44>}\n<line45>#endif\n<line46>/* Sync the journal file if required. */\n<line47>if( pPg->flags&PGHDR_NEED_SYNC\n<line48>|| pPager->eState==PAGER_WRITER_CACHEMOD\n<line49>){\n<line50>rc = syncJournal(pPager, 1);\n<line51>}\n<line52>/* Write the contents of the page out to the database file. */\n<line53>if( rc==SQLITE_OK ){\n<line54>assert( (pPg->flags&PGHDR_NEED_SYNC)==0 );\n<line55>rc = pager_write_pagelist(pPager, pPg);\n<line56>}\n<line57>}\n<line58>/* Mark the page as clean. */\n<line59>if( rc==SQLITE_OK ){\n<line60>PAGERTRACE(("STRESS %d page %d\n", PAGERID(pPager), pPg->pgno));\n<line61>sqlite3PcacheMakeClean(pPg);\n<line62>}\n<line63>return pager_error(pPager, rc);\n<line64>}
----------------------------------------
Function: sqlite3_database_file_object
Content: <line0>SQLITE_API sqlite3_file *sqlite3_database_file_object(const char *zName){\n<line1>Pager *pPager;\n<line2>const char *p;\n<line3>while( zName[-1]!=0 || zName[-2]!=0 || zName[-3]!=0 || zName[-4]!=0 ){\n<line4>zName--;\n<line5>}\n<line6>p = zName - 4 - sizeof(Pager*);\n<line7>assert( EIGHT_BYTE_ALIGNMENT(p) );\n<line8>pPager = *(Pager**)p;\n<line9>return pPager->fd;\n<line10>}
----------------------------------------
Function: hasHotJournal
Content: <line0>static int hasHotJournal(Pager *pPager, int *pExists){\n<line1>sqlite3_vfs * const pVfs = pPager->pVfs;\n<line2>int rc = SQLITE_OK;           /* Return code */\n<line3>int exists = 1;               /* True if a journal file is present */\n<line4>int jrnlOpen = !!isOpen(pPager->jfd);\n<line5>assert( pPager->useJournal );\n<line6>assert( isOpen(pPager->fd) );\n<line7>assert( pPager->eState==PAGER_OPEN );\n<line8>assert( jrnlOpen==0 || ( sqlite3OsDeviceCharacteristics(pPager->jfd) &\n<line9>SQLITE_IOCAP_UNDELETABLE_WHEN_OPEN\n<line10>));\n<line11>*pExists = 0;\n<line12>if( !jrnlOpen ){\n<line13>rc = sqlite3OsAccess(pVfs, pPager->zJournal, SQLITE_ACCESS_EXISTS, &exists);\n<line14>}\n<line15>if( rc==SQLITE_OK && exists ){\n<line16>int locked = 0;             /* True if some process holds a RESERVED lock */\n<line17>/* Race condition here:  Another process might have been holding the\n<line18>** the RESERVED lock and have a journal open at the sqlite3OsAccess()\n<line19>** call above, but then delete the journal and drop the lock before\n<line20>** we get to the following sqlite3OsCheckReservedLock() call.  If that\n<line21>** is the case, this routine might think there is a hot journal when\n<line22>** in fact there is none.  This results in a false-positive which will\n<line23>** be dealt with by the playback routine.  Ticket #3883.\n<line24>*/\n<line25>rc = sqlite3OsCheckReservedLock(pPager->fd, &locked);\n<line26>if( rc==SQLITE_OK && !locked ){\n<line27>Pgno nPage;                 /* Number of pages in database file */\n<line28>assert( pPager->tempFile==0 );\n<line29>rc = pagerPagecount(pPager, &nPage);\n<line30>if( rc==SQLITE_OK ){\n<line31>/* If the database is zero pages in size, that means that either (1) the\n<line32>** journal is a remnant from a prior database with the same name where\n<line33>** the database file but not the journal was deleted, or (2) the initial\n<line34>** transaction that populates a new database is being rolled back.\n<line35>** In either case, the journal file can be deleted.  However, take care\n<line36>** not to delete the journal file if it is already open due to\n<line37>** journal_mode=PERSIST.\n<line38>*/\n<line39>if( nPage==0 && !jrnlOpen ){\n<line40>sqlite3BeginBenignMalloc();\n<line41>if( pagerLockDb(pPager, RESERVED_LOCK)==SQLITE_OK ){\n<line42>sqlite3OsDelete(pVfs, pPager->zJournal, 0);\n<line43>if( !pPager->exclusiveMode ) pagerUnlockDb(pPager, SHARED_LOCK);\n<line44>}\n<line45>sqlite3EndBenignMalloc();\n<line46>}else{\n<line47>/* The journal file exists and no other connection has a reserved\n<line48>** or greater lock on the database file. Now check that there is\n<line49>** at least one non-zero bytes at the start of the journal file.\n<line50>** If there is, then we consider this journal to be hot. If not,\n<line51>** it can be ignored.\n<line52>*/\n<line53>if( !jrnlOpen ){\n<line54>int f = SQLITE_OPEN_READONLY|SQLITE_OPEN_MAIN_JOURNAL;\n<line55>rc = sqlite3OsOpen(pVfs, pPager->zJournal, pPager->jfd, f, &f);\n<line56>}\n<line57>if( rc==SQLITE_OK ){\n<line58>u8 first = 0;\n<line59>rc = sqlite3OsRead(pPager->jfd, (void *)&first, 1, 0);\n<line60>if( rc==SQLITE_IOERR_SHORT_READ ){\n<line61>rc = SQLITE_OK;\n<line62>}\n<line63>if( !jrnlOpen ){\n<line64>sqlite3OsClose(pPager->jfd);\n<line65>}\n<line66>*pExists = (first!=0);\n<line67>}else if( rc==SQLITE_CANTOPEN ){\n<line68>/* If we cannot open the rollback journal file in order to see if\n<line69>** it has a zero header, that might be due to an I/O error, or\n<line70>** it might be due to the race condition described above and in\n<line71>** ticket #3883.  Either way, assume that the journal is hot.\n<line72>** This might be a false positive.  But if it is, then the\n<line73>** automatic journal playback and recovery mechanism will deal\n<line74>** with it under an EXCLUSIVE lock where we do not need to\n<line75>** worry so much with race conditions.\n<line76>*/\n<line77>*pExists = 1;\n<line78>rc = SQLITE_OK;\n<line79>}\n<line80>}\n<line81>}\n<line82>}\n<line83>}\n<line84>return rc;\n<line85>}
----------------------------------------
Function: pagerUnlockIfUnused
Content: <line0>static void pagerUnlockIfUnused(Pager *pPager){\n<line1>if( sqlite3PcacheRefCount(pPager->pPCache)==0 ){\n<line2>assert( pPager->nMmapOut==0 ); /* because page1 is never memory mapped */\n<line3>pagerUnlockAndRollback(pPager);\n<line4>}\n<line5>}
----------------------------------------
Function: getPageNormal
Content: <line0>static int getPageNormal(\n<line1>Pager *pPager,      /* The pager open on the database file */\n<line2>Pgno pgno,          /* Page number to fetch */\n<line3>DbPage **ppPage,    /* Write a pointer to the page here */\n<line4>int flags           /* PAGER_GET_XXX flags */\n<line5>){\n<line6>int rc = SQLITE_OK;\n<line7>PgHdr *pPg;\n<line8>u8 noContent;                   /* True if PAGER_GET_NOCONTENT is set */\n<line9>sqlite3_pcache_page *pBase;\n<line10>assert( pPager->errCode==SQLITE_OK );\n<line11>assert( pPager->eState>=PAGER_READER );\n<line12>assert( assert_pager_state(pPager) );\n<line13>assert( pPager->hasHeldSharedLock==1 );\n<line14>if( pgno==0 ) return SQLITE_CORRUPT_BKPT;\n<line15>pBase = sqlite3PcacheFetch(pPager->pPCache, pgno, 3);\n<line16>if( pBase==0 ){\n<line17>pPg = 0;\n<line18>rc = sqlite3PcacheFetchStress(pPager->pPCache, pgno, &pBase);\n<line19>if( rc!=SQLITE_OK ) goto pager_acquire_err;\n<line20>if( pBase==0 ){\n<line21>rc = SQLITE_NOMEM_BKPT;\n<line22>goto pager_acquire_err;\n<line23>}\n<line24>}\n<line25>pPg = *ppPage = sqlite3PcacheFetchFinish(pPager->pPCache, pgno, pBase);\n<line26>assert( pPg==(*ppPage) );\n<line27>assert( pPg->pgno==pgno );\n<line28>assert( pPg->pPager==pPager || pPg->pPager==0 );\n<line29>noContent = (flags & PAGER_GET_NOCONTENT)!=0;\n<line30>if( pPg->pPager && !noContent ){\n<line31>/* In this case the pcache already contains an initialized copy of\n<line32>** the page. Return without further ado.  */\n<line33>assert( pgno!=PAGER_SJ_PGNO(pPager) );\n<line34>pPager->aStat[PAGER_STAT_HIT]++;\n<line35>return SQLITE_OK;\n<line36>}else{\n<line37>/* The pager cache has created a new page. Its content needs to\n<line38>** be initialized. But first some error checks:\n<line39>**\n<line40>** (*) obsolete.  Was: maximum page number is 2^31\n<line41>** (2) Never try to fetch the locking page\n<line42>*/\n<line43>if( pgno==PAGER_SJ_PGNO(pPager) ){\n<line44>rc = SQLITE_CORRUPT_BKPT;\n<line45>goto pager_acquire_err;\n<line46>}\n<line47>pPg->pPager = pPager;\n<line48>assert( !isOpen(pPager->fd) || !MEMDB );\n<line49>if( !isOpen(pPager->fd) || pPager->dbSize<pgno || noContent ){\n<line50>if( pgno>pPager->mxPgno ){\n<line51>rc = SQLITE_FULL;\n<line52>if( pgno<=pPager->dbSize ){\n<line53>sqlite3PcacheRelease(pPg);\n<line54>pPg = 0;\n<line55>}\n<line56>goto pager_acquire_err;\n<line57>}\n<line58>if( noContent ){\n<line59>/* Failure to set the bits in the InJournal bit-vectors is benign.\n<line60>** It merely means that we might do some extra work to journal a\n<line61>** page that does not need to be journaled.  Nevertheless, be sure\n<line62>** to test the case where a malloc error occurs while trying to set\n<line63>** a bit in a bit vector.\n<line64>*/\n<line65>sqlite3BeginBenignMalloc();\n<line66>if( pgno<=pPager->dbOrigSize ){\n<line67>TESTONLY( rc = ) sqlite3BitvecSet(pPager->pInJournal, pgno);\n<line68>testcase( rc==SQLITE_NOMEM );\n<line69>}\n<line70>TESTONLY( rc = ) addToSavepointBitvecs(pPager, pgno);\n<line71>testcase( rc==SQLITE_NOMEM );\n<line72>sqlite3EndBenignMalloc();\n<line73>}\n<line74>memset(pPg->pData, 0, pPager->pageSize);\n<line75>IOTRACE(("ZERO %p %d\n", pPager, pgno));\n<line76>}else{\n<line77>assert( pPg->pPager==pPager );\n<line78>pPager->aStat[PAGER_STAT_MISS]++;\n<line79>rc = readDbPage(pPg);\n<line80>if( rc!=SQLITE_OK ){\n<line81>goto pager_acquire_err;\n<line82>}\n<line83>}\n<line84>pager_set_pagehash(pPg);\n<line85>}\n<line86>return SQLITE_OK;\n<line87>pager_acquire_err:\n<line88>assert( rc!=SQLITE_OK );\n<line89>if( pPg ){\n<line90>sqlite3PcacheDrop(pPg);\n<line91>}\n<line92>pagerUnlockIfUnused(pPager);\n<line93>*ppPage = 0;\n<line94>return rc;\n<line95>}
----------------------------------------
Function: getPageMMap
Content: <line0>static int getPageMMap(\n<line1>Pager *pPager,      /* The pager open on the database file */\n<line2>Pgno pgno,          /* Page number to fetch */\n<line3>DbPage **ppPage,    /* Write a pointer to the page here */\n<line4>int flags           /* PAGER_GET_XXX flags */\n<line5>){\n<line6>int rc = SQLITE_OK;\n<line7>PgHdr *pPg = 0;\n<line8>u32 iFrame = 0;                 /* Frame to read from WAL file */\n<line9>/* It is acceptable to use a read-only (mmap) page for any page except\n<line10>** page 1 if there is no write-transaction open or the ACQUIRE_READONLY\n<line11>** flag was specified by the caller. And so long as the db is not a\n<line12>** temporary or in-memory database.  */\n<line13>const int bMmapOk = (pgno>1\n<line14>&& (pPager->eState==PAGER_READER || (flags & PAGER_GET_READONLY))\n<line15>);\n<line16>assert( USEFETCH(pPager) );\n<line17>/* Optimization note:  Adding the "pgno<=1" term before "pgno==0" here\n<line18>** allows the compiler optimizer to reuse the results of the "pgno>1"\n<line19>** test in the previous statement, and avoid testing pgno==0 in the\n<line20>** common case where pgno is large. */\n<line21>if( pgno<=1 && pgno==0 ){\n<line22>return SQLITE_CORRUPT_BKPT;\n<line23>}\n<line24>assert( pPager->eState>=PAGER_READER );\n<line25>assert( assert_pager_state(pPager) );\n<line26>assert( pPager->hasHeldSharedLock==1 );\n<line27>assert( pPager->errCode==SQLITE_OK );\n<line28>if( bMmapOk && pagerUseWal(pPager) ){\n<line29>rc = sqlite3WalFindFrame(pPager->pWal, pgno, &iFrame);\n<line30>if( rc!=SQLITE_OK ){\n<line31>*ppPage = 0;\n<line32>return rc;\n<line33>}\n<line34>}\n<line35>if( bMmapOk && iFrame==0 ){\n<line36>void *pData = 0;\n<line37>rc = sqlite3OsFetch(pPager->fd,\n<line38>(i64)(pgno-1) * pPager->pageSize, pPager->pageSize, &pData\n<line39>);\n<line40>if( rc==SQLITE_OK && pData ){\n<line41>if( pPager->eState>PAGER_READER || pPager->tempFile ){\n<line42>pPg = sqlite3PagerLookup(pPager, pgno);\n<line43>}\n<line44>if( pPg==0 ){\n<line45>rc = pagerAcquireMapPage(pPager, pgno, pData, &pPg);\n<line46>}else{\n<line47>sqlite3OsUnfetch(pPager->fd, (i64)(pgno-1)*pPager->pageSize, pData);\n<line48>}\n<line49>if( pPg ){\n<line50>assert( rc==SQLITE_OK );\n<line51>*ppPage = pPg;\n<line52>return SQLITE_OK;\n<line53>}\n<line54>}\n<line55>if( rc!=SQLITE_OK ){\n<line56>*ppPage = 0;\n<line57>return rc;\n<line58>}\n<line59>}\n<line60>return getPageNormal(pPager, pgno, ppPage, flags);\n<line61>}
----------------------------------------
Function: getPageError
Content: <line0>static int getPageError(\n<line1>Pager *pPager,      /* The pager open on the database file */\n<line2>Pgno pgno,          /* Page number to fetch */\n<line3>DbPage **ppPage,    /* Write a pointer to the page here */\n<line4>int flags           /* PAGER_GET_XXX flags */\n<line5>){\n<line6>UNUSED_PARAMETER(pgno);\n<line7>UNUSED_PARAMETER(flags);\n<line8>assert( pPager->errCode!=SQLITE_OK );\n<line9>*ppPage = 0;\n<line10>return pPager->errCode;\n<line11>}
----------------------------------------
Function: pager_open_journal
Content: <line0>static int pager_open_journal(Pager *pPager){\n<line1>int rc = SQLITE_OK;                        /* Return code */\n<line2>sqlite3_vfs * const pVfs = pPager->pVfs;   /* Local cache of vfs pointer */\n<line3>assert( pPager->eState==PAGER_WRITER_LOCKED );\n<line4>assert( assert_pager_state(pPager) );\n<line5>assert( pPager->pInJournal==0 );\n<line6>/* If already in the error state, this function is a no-op.  But on\n<line7>** the other hand, this routine is never called if we are already in\n<line8>** an error state. */\n<line9>if( NEVER(pPager->errCode) ) return pPager->errCode;\n<line10>if( !pagerUseWal(pPager) && pPager->journalMode!=PAGER_JOURNALMODE_OFF ){\n<line11>pPager->pInJournal = sqlite3BitvecCreate(pPager->dbSize);\n<line12>if( pPager->pInJournal==0 ){\n<line13>return SQLITE_NOMEM_BKPT;\n<line14>}\n<line15>/* Open the journal file if it is not already open. */\n<line16>if( !isOpen(pPager->jfd) ){\n<line17>if( pPager->journalMode==PAGER_JOURNALMODE_MEMORY ){\n<line18>sqlite3MemJournalOpen(pPager->jfd);\n<line19>}else{\n<line20>int flags = SQLITE_OPEN_READWRITE|SQLITE_OPEN_CREATE;\n<line21>int nSpill;\n<line22>if( pPager->tempFile ){\n<line23>flags |= (SQLITE_OPEN_DELETEONCLOSE|SQLITE_OPEN_TEMP_JOURNAL);\n<line24>flags |= SQLITE_OPEN_EXCLUSIVE;\n<line25>nSpill = sqlite3Config.nStmtSpill;\n<line26>}else{\n<line27>flags |= SQLITE_OPEN_MAIN_JOURNAL;\n<line28>nSpill = jrnlBufferSize(pPager);\n<line29>}\n<line30>/* Verify that the database still has the same name as it did when\n<line31>** it was originally opened. */\n<line32>rc = databaseIsUnmoved(pPager);\n<line33>if( rc==SQLITE_OK ){\n<line34>rc = sqlite3JournalOpen (\n<line35>pVfs, pPager->zJournal, pPager->jfd, flags, nSpill\n<line36>);\n<line37>}\n<line38>}\n<line39>assert( rc!=SQLITE_OK || isOpen(pPager->jfd) );\n<line40>}\n<line41>/* Write the first journal header to the journal file and open\n<line42>** the sub-journal if necessary.\n<line43>*/\n<line44>if( rc==SQLITE_OK ){\n<line45>/* TODO: Check if all of these are really required. */\n<line46>pPager->nRec = 0;\n<line47>pPager->journalOff = 0;\n<line48>pPager->setSuper = 0;\n<line49>pPager->journalHdr = 0;\n<line50>rc = writeJournalHdr(pPager);\n<line51>}\n<line52>}\n<line53>if( rc!=SQLITE_OK ){\n<line54>sqlite3BitvecDestroy(pPager->pInJournal);\n<line55>pPager->pInJournal = 0;\n<line56>pPager->journalOff = 0;\n<line57>}else{\n<line58>assert( pPager->eState==PAGER_WRITER_LOCKED );\n<line59>pPager->eState = PAGER_WRITER_CACHEMOD;\n<line60>}\n<line61>return rc;\n<line62>}
----------------------------------------
Function: pagerAddPageToRollbackJournal
Content: <line0>static SQLITE_NOINLINE int pagerAddPageToRollbackJournal(PgHdr *pPg){\n<line1>Pager *pPager = pPg->pPager;\n<line2>int rc;\n<line3>u32 cksum;\n<line4>char *pData2;\n<line5>i64 iOff = pPager->journalOff;\n<line6>/* We should never write to the journal file the page that\n<line7>** contains the database locks.  The following assert verifies\n<line8>** that we do not. */\n<line9>assert( pPg->pgno!=PAGER_SJ_PGNO(pPager) );\n<line10>assert( pPager->journalHdr<=pPager->journalOff );\n<line11>pData2 = pPg->pData;\n<line12>cksum = pager_cksum(pPager, (u8*)pData2);\n<line13>/* Even if an IO or diskfull error occurs while journalling the\n<line14>** page in the block above, set the need-sync flag for the page.\n<line15>** Otherwise, when the transaction is rolled back, the logic in\n<line16>** playback_one_page() will think that the page needs to be restored\n<line17>** in the database file. And if an IO error occurs while doing so,\n<line18>** then corruption may follow.\n<line19>*/\n<line20>pPg->flags |= PGHDR_NEED_SYNC;\n<line21>rc = write32bits(pPager->jfd, iOff, pPg->pgno);\n<line22>if( rc!=SQLITE_OK ) return rc;\n<line23>rc = sqlite3OsWrite(pPager->jfd, pData2, pPager->pageSize, iOff+4);\n<line24>if( rc!=SQLITE_OK ) return rc;\n<line25>rc = write32bits(pPager->jfd, iOff+pPager->pageSize+4, cksum);\n<line26>if( rc!=SQLITE_OK ) return rc;\n<line27>IOTRACE(("JOUT %p %d %lld %d\n", pPager, pPg->pgno,\n<line28>pPager->journalOff, pPager->pageSize));\n<line29>PAGER_INCR(sqlite3_pager_writej_count);\n<line30>PAGERTRACE(("JOURNAL %d page %d needSync=%d hash(%08x)\n",\n<line31>PAGERID(pPager), pPg->pgno,\n<line32>((pPg->flags&PGHDR_NEED_SYNC)?1:0), pager_pagehash(pPg)));\n<line33>pPager->journalOff += 8 + pPager->pageSize;\n<line34>pPager->nRec++;\n<line35>assert( pPager->pInJournal!=0 );\n<line36>rc = sqlite3BitvecSet(pPager->pInJournal, pPg->pgno);\n<line37>testcase( rc==SQLITE_NOMEM );\n<line38>assert( rc==SQLITE_OK || rc==SQLITE_NOMEM );\n<line39>rc |= addToSavepointBitvecs(pPager, pPg->pgno);\n<line40>assert( rc==SQLITE_OK || rc==SQLITE_NOMEM );\n<line41>return rc;\n<line42>}
----------------------------------------
Function: pager_write
Content: <line0>static int pager_write(PgHdr *pPg){\n<line1>Pager *pPager = pPg->pPager;\n<line2>int rc = SQLITE_OK;\n<line3>/* This routine is not called unless a write-transaction has already\n<line4>** been started. The journal file may or may not be open at this point.\n<line5>** It is never called in the ERROR state.\n<line6>*/\n<line7>assert( pPager->eState==PAGER_WRITER_LOCKED\n<line8>|| pPager->eState==PAGER_WRITER_CACHEMOD\n<line9>|| pPager->eState==PAGER_WRITER_DBMOD\n<line10>);\n<line11>assert( assert_pager_state(pPager) );\n<line12>assert( pPager->errCode==0 );\n<line13>assert( pPager->readOnly==0 );\n<line14>CHECK_PAGE(pPg);\n<line15>/* The journal file needs to be opened. Higher level routines have already\n<line16>** obtained the necessary locks to begin the write-transaction, but the\n<line17>** rollback journal might not yet be open. Open it now if this is the case.\n<line18>**\n<line19>** This is done before calling sqlite3PcacheMakeDirty() on the page.\n<line20>** Otherwise, if it were done after calling sqlite3PcacheMakeDirty(), then\n<line21>** an error might occur and the pager would end up in WRITER_LOCKED state\n<line22>** with pages marked as dirty in the cache.\n<line23>*/\n<line24>if( pPager->eState==PAGER_WRITER_LOCKED ){\n<line25>rc = pager_open_journal(pPager);\n<line26>if( rc!=SQLITE_OK ) return rc;\n<line27>}\n<line28>assert( pPager->eState>=PAGER_WRITER_CACHEMOD );\n<line29>assert( assert_pager_state(pPager) );\n<line30>/* Mark the page that is about to be modified as dirty. */\n<line31>sqlite3PcacheMakeDirty(pPg);\n<line32>/* If a rollback journal is in use, them make sure the page that is about\n<line33>** to change is in the rollback journal, or if the page is a new page off\n<line34>** then end of the file, make sure it is marked as PGHDR_NEED_SYNC.\n<line35>*/\n<line36>assert( (pPager->pInJournal!=0) == isOpen(pPager->jfd) );\n<line37>if( pPager->pInJournal!=0\n<line38>&& sqlite3BitvecTestNotNull(pPager->pInJournal, pPg->pgno)==0\n<line39>){\n<line40>assert( pagerUseWal(pPager)==0 );\n<line41>if( pPg->pgno<=pPager->dbOrigSize ){\n<line42>rc = pagerAddPageToRollbackJournal(pPg);\n<line43>if( rc!=SQLITE_OK ){\n<line44>return rc;\n<line45>}\n<line46>}else{\n<line47>if( pPager->eState!=PAGER_WRITER_DBMOD ){\n<line48>pPg->flags |= PGHDR_NEED_SYNC;\n<line49>}\n<line50>PAGERTRACE(("APPEND %d page %d needSync=%d\n",\n<line51>PAGERID(pPager), pPg->pgno,\n<line52>((pPg->flags&PGHDR_NEED_SYNC)?1:0)));\n<line53>}\n<line54>}\n<line55>/* The PGHDR_DIRTY bit is set above when the page was added to the dirty-list\n<line56>** and before writing the page into the rollback journal.  Wait until now,\n<line57>** after the page has been successfully journalled, before setting the\n<line58>** PGHDR_WRITEABLE bit that indicates that the page can be safely modified.\n<line59>*/\n<line60>pPg->flags |= PGHDR_WRITEABLE;\n<line61>/* If the statement journal is open and the page is not in it,\n<line62>** then write the page into the statement journal.\n<line63>*/\n<line64>if( pPager->nSavepoint>0 ){\n<line65>rc = subjournalPageIfRequired(pPg);\n<line66>}\n<line67>/* Update the database size and return. */\n<line68>if( pPager->dbSize<pPg->pgno ){\n<line69>pPager->dbSize = pPg->pgno;\n<line70>}\n<line71>return rc;\n<line72>}
----------------------------------------
Function: pagerWriteLargeSector
Content: <line0>static SQLITE_NOINLINE int pagerWriteLargeSector(PgHdr *pPg){\n<line1>int rc = SQLITE_OK;          /* Return code */\n<line2>Pgno nPageCount;             /* Total number of pages in database file */\n<line3>Pgno pg1;                    /* First page of the sector pPg is located on. */\n<line4>int nPage = 0;               /* Number of pages starting at pg1 to journal */\n<line5>int ii;                      /* Loop counter */\n<line6>int needSync = 0;            /* True if any page has PGHDR_NEED_SYNC */\n<line7>Pager *pPager = pPg->pPager; /* The pager that owns pPg */\n<line8>Pgno nPagePerSector = (pPager->sectorSize/pPager->pageSize);\n<line9>/* Set the doNotSpill NOSYNC bit to 1. This is because we cannot allow\n<line10>** a journal header to be written between the pages journaled by\n<line11>** this function.\n<line12>*/\n<line13>assert( !MEMDB );\n<line14>assert( (pPager->doNotSpill & SPILLFLAG_NOSYNC)==0 );\n<line15>pPager->doNotSpill |= SPILLFLAG_NOSYNC;\n<line16>/* This trick assumes that both the page-size and sector-size are\n<line17>** an integer power of 2. It sets variable pg1 to the identifier\n<line18>** of the first page of the sector pPg is located on.\n<line19>*/\n<line20>pg1 = ((pPg->pgno-1) & ~(nPagePerSector-1)) + 1;\n<line21>nPageCount = pPager->dbSize;\n<line22>if( pPg->pgno>nPageCount ){\n<line23>nPage = (pPg->pgno - pg1)+1;\n<line24>}else if( (pg1+nPagePerSector-1)>nPageCount ){\n<line25>nPage = nPageCount+1-pg1;\n<line26>}else{\n<line27>nPage = nPagePerSector;\n<line28>}\n<line29>assert(nPage>0);\n<line30>assert(pg1<=pPg->pgno);\n<line31>assert((pg1+nPage)>pPg->pgno);\n<line32>for(ii=0; ii<nPage && rc==SQLITE_OK; ii++){\n<line33>Pgno pg = pg1+ii;\n<line34>PgHdr *pPage;\n<line35>if( pg==pPg->pgno || !sqlite3BitvecTest(pPager->pInJournal, pg) ){\n<line36>if( pg!=PAGER_SJ_PGNO(pPager) ){\n<line37>rc = sqlite3PagerGet(pPager, pg, &pPage, 0);\n<line38>if( rc==SQLITE_OK ){\n<line39>rc = pager_write(pPage);\n<line40>if( pPage->flags&PGHDR_NEED_SYNC ){\n<line41>needSync = 1;\n<line42>}\n<line43>sqlite3PagerUnrefNotNull(pPage);\n<line44>}\n<line45>}\n<line46>}else if( (pPage = sqlite3PagerLookup(pPager, pg))!=0 ){\n<line47>if( pPage->flags&PGHDR_NEED_SYNC ){\n<line48>needSync = 1;\n<line49>}\n<line50>sqlite3PagerUnrefNotNull(pPage);\n<line51>}\n<line52>}\n<line53>/* If the PGHDR_NEED_SYNC flag is set for any of the nPage pages\n<line54>** starting at pg1, then it needs to be set for all of them. Because\n<line55>** writing to any of these nPage pages may damage the others, the\n<line56>** journal file must contain sync()ed copies of all of them\n<line57>** before any of them can be written out to the database file.\n<line58>*/\n<line59>if( rc==SQLITE_OK && needSync ){\n<line60>assert( !MEMDB );\n<line61>for(ii=0; ii<nPage; ii++){\n<line62>PgHdr *pPage = sqlite3PagerLookup(pPager, pg1+ii);\n<line63>if( pPage ){\n<line64>pPage->flags |= PGHDR_NEED_SYNC;\n<line65>sqlite3PagerUnrefNotNull(pPage);\n<line66>}\n<line67>}\n<line68>}\n<line69>assert( (pPager->doNotSpill & SPILLFLAG_NOSYNC)!=0 );\n<line70>pPager->doNotSpill &= ~SPILLFLAG_NOSYNC;\n<line71>return rc;\n<line72>}
----------------------------------------
Function: pager_incr_changecounter
Content: <line0>static int pager_incr_changecounter(Pager *pPager, int isDirectMode){\n<line1>int rc = SQLITE_OK;\n<line2>assert( pPager->eState==PAGER_WRITER_CACHEMOD\n<line3>|| pPager->eState==PAGER_WRITER_DBMOD\n<line4>);\n<line5>assert( assert_pager_state(pPager) );\n<line6>/* Declare and initialize constant integer 'isDirect'. If the\n<line7>** atomic-write optimization is enabled in this build, then isDirect\n<line8>** is initialized to the value passed as the isDirectMode parameter\n<line9>** to this function. Otherwise, it is always set to zero.\n<line10>**\n<line11>** The idea is that if the atomic-write optimization is not\n<line12>** enabled at compile time, the compiler can omit the tests of\n<line13>** 'isDirect' below, as well as the block enclosed in the\n<line14>** "if( isDirect )" condition.\n<line15>*/\n<line16>#ifndef SQLITE_ENABLE_ATOMIC_WRITE\n<line17># define DIRECT_MODE 0\n<line18>assert( isDirectMode==0 );\n<line19>UNUSED_PARAMETER(isDirectMode);\n<line20>#else\n<line21># define DIRECT_MODE isDirectMode\n<line22>#endif\n<line23>if( !pPager->changeCountDone && pPager->dbSize>0 ){\n<line24>PgHdr *pPgHdr;                /* Reference to page 1 */\n<line25>assert( !pPager->tempFile && isOpen(pPager->fd) );\n<line26>/* Open page 1 of the file for writing. */\n<line27>rc = sqlite3PagerGet(pPager, 1, &pPgHdr, 0);\n<line28>assert( pPgHdr==0 || rc==SQLITE_OK );\n<line29>/* If page one was fetched successfully, and this function is not\n<line30>** operating in direct-mode, make page 1 writable.  When not in\n<line31>** direct mode, page 1 is always held in cache and hence the PagerGet()\n<line32>** above is always successful - hence the ALWAYS on rc==SQLITE_OK.\n<line33>*/\n<line34>if( !DIRECT_MODE && ALWAYS(rc==SQLITE_OK) ){\n<line35>rc = sqlite3PagerWrite(pPgHdr);\n<line36>}\n<line37>if( rc==SQLITE_OK ){\n<line38>/* Actually do the update of the change counter */\n<line39>pager_write_changecounter(pPgHdr);\n<line40>/* If running in direct mode, write the contents of page 1 to the file. */\n<line41>if( DIRECT_MODE ){\n<line42>const void *zBuf;\n<line43>assert( pPager->dbFileSize>0 );\n<line44>zBuf = pPgHdr->pData;\n<line45>if( rc==SQLITE_OK ){\n<line46>rc = sqlite3OsWrite(pPager->fd, zBuf, pPager->pageSize, 0);\n<line47>pPager->aStat[PAGER_STAT_WRITE]++;\n<line48>}\n<line49>if( rc==SQLITE_OK ){\n<line50>/* Update the pager's copy of the change-counter. Otherwise, the\n<line51>** next time a read transaction is opened the cache will be\n<line52>** flushed (as the change-counter values will not match).  */\n<line53>const void *pCopy = (const void *)&((const char *)zBuf)[24];\n<line54>memcpy(&pPager->dbFileVers, pCopy, sizeof(pPager->dbFileVers));\n<line55>pPager->changeCountDone = 1;\n<line56>}\n<line57>}else{\n<line58>pPager->changeCountDone = 1;\n<line59>}\n<line60>}\n<line61>/* Release the page reference. */\n<line62>sqlite3PagerUnref(pPgHdr);\n<line63>}\n<line64>return rc;\n<line65>}
----------------------------------------
Function: pagerOpenSavepoint
Content: <line0>static SQLITE_NOINLINE int pagerOpenSavepoint(Pager *pPager, int nSavepoint){\n<line1>int rc = SQLITE_OK;                       /* Return code */\n<line2>int nCurrent = pPager->nSavepoint;        /* Current number of savepoints */\n<line3>int ii;                                   /* Iterator variable */\n<line4>PagerSavepoint *aNew;                     /* New Pager.aSavepoint array */\n<line5>assert( pPager->eState>=PAGER_WRITER_LOCKED );\n<line6>assert( assert_pager_state(pPager) );\n<line7>assert( nSavepoint>nCurrent && pPager->useJournal );\n<line8>/* Grow the Pager.aSavepoint array using realloc(). Return SQLITE_NOMEM\n<line9>** if the allocation fails. Otherwise, zero the new portion in case a\n<line10>** malloc failure occurs while populating it in the for(...) loop below.\n<line11>*/\n<line12>aNew = (PagerSavepoint *)sqlite3Realloc(\n<line13>pPager->aSavepoint, sizeof(PagerSavepoint)*nSavepoint\n<line14>);\n<line15>if( !aNew ){\n<line16>return SQLITE_NOMEM_BKPT;\n<line17>}\n<line18>memset(&aNew[nCurrent], 0, (nSavepoint-nCurrent) * sizeof(PagerSavepoint));\n<line19>pPager->aSavepoint = aNew;\n<line20>/* Populate the PagerSavepoint structures just allocated. */\n<line21>for(ii=nCurrent; ii<nSavepoint; ii++){\n<line22>aNew[ii].nOrig = pPager->dbSize;\n<line23>if( isOpen(pPager->jfd) && pPager->journalOff>0 ){\n<line24>aNew[ii].iOffset = pPager->journalOff;\n<line25>}else{\n<line26>aNew[ii].iOffset = JOURNAL_HDR_SZ(pPager);\n<line27>}\n<line28>aNew[ii].iSubRec = pPager->nSubRec;\n<line29>aNew[ii].pInSavepoint = sqlite3BitvecCreate(pPager->dbSize);\n<line30>aNew[ii].bTruncateOnRelease = 1;\n<line31>if( !aNew[ii].pInSavepoint ){\n<line32>return SQLITE_NOMEM_BKPT;\n<line33>}\n<line34>if( pagerUseWal(pPager) ){\n<line35>sqlite3WalSavepoint(pPager->pWal, aNew[ii].aWalData);\n<line36>}\n<line37>pPager->nSavepoint = ii+1;\n<line38>}\n<line39>assert( pPager->nSavepoint==nSavepoint );\n<line40>assertTruncateConstraint(pPager);\n<line41>return rc;\n<line42>}
----------------------------------------
Function: pagerExclusiveLock
Content: <line0>static int pagerExclusiveLock(Pager *pPager){\n<line1>int rc;                         /* Return code */\n<line2>u8 eOrigLock;                   /* Original lock */\n<line3>assert( pPager->eLock>=SHARED_LOCK );\n<line4>eOrigLock = pPager->eLock;\n<line5>rc = pagerLockDb(pPager, EXCLUSIVE_LOCK);\n<line6>if( rc!=SQLITE_OK ){\n<line7>/* If the attempt to grab the exclusive lock failed, release the\n<line8>** pending lock that may have been obtained instead.  */\n<line9>pagerUnlockDb(pPager, eOrigLock);\n<line10>}\n<line11>return rc;\n<line12>}
----------------------------------------
Function: pagerOpenWal
Content: <line0>static int pagerOpenWal(Pager *pPager){\n<line1>int rc = SQLITE_OK;\n<line2>assert( pPager->pWal==0 && pPager->tempFile==0 );\n<line3>assert( pPager->eLock==SHARED_LOCK || pPager->eLock==EXCLUSIVE_LOCK );\n<line4>/* If the pager is already in exclusive-mode, the WAL module will use\n<line5>** heap-memory for the wal-index instead of the VFS shared-memory\n<line6>** implementation. Take the exclusive lock now, before opening the WAL\n<line7>** file, to make sure this is safe.\n<line8>*/\n<line9>if( pPager->exclusiveMode ){\n<line10>rc = pagerExclusiveLock(pPager);\n<line11>}\n<line12>/* Open the connection to the log file. If this operation fails,\n<line13>** (e.g. due to malloc() failure), return an error code.\n<line14>*/\n<line15>if( rc==SQLITE_OK ){\n<line16>rc = sqlite3WalOpen(pPager->pVfs,\n<line17>pPager->fd, pPager->zWal, pPager->exclusiveMode,\n<line18>pPager->journalSizeLimit, &pPager->pWal\n<line19>);\n<line20>#ifdef SQLITE_ENABLE_SETLK_TIMEOUT\n<line21>if( rc==SQLITE_OK ){\n<line22>sqlite3WalDb(pPager->pWal, pPager->dbWal);\n<line23>}\n<line24>#endif\n<line25>}\n<line26>pagerFixMaplimit(pPager);\n<line27>return rc;\n<line28>}
----------------------------------------
Function: walIndexPageRealloc
Content: <line0>static SQLITE_NOINLINE int walIndexPageRealloc(\n<line1>Wal *pWal,               /* The WAL context */\n<line2>int iPage,               /* The page we seek */\n<line3>volatile u32 **ppPage    /* Write the page pointer here */\n<line4>){\n<line5>int rc = SQLITE_OK;\n<line6>/* Enlarge the pWal->apWiData[] array if required */\n<line7>if( pWal->nWiData<=iPage ){\n<line8>sqlite3_int64 nByte = sizeof(u32*)*(1+(i64)iPage);\n<line9>volatile u32 **apNew;\n<line10>apNew = (volatile u32 **)sqlite3Realloc((void *)pWal->apWiData, nByte);\n<line11>if( !apNew ){\n<line12>*ppPage = 0;\n<line13>return SQLITE_NOMEM_BKPT;\n<line14>}\n<line15>memset((void*)&apNew[pWal->nWiData], 0,\n<line16>sizeof(u32*)*(iPage+1-pWal->nWiData));\n<line17>pWal->apWiData = apNew;\n<line18>pWal->nWiData = iPage+1;\n<line19>}\n<line20>/* Request a pointer to the required page from the VFS */\n<line21>assert( pWal->apWiData[iPage]==0 );\n<line22>if( pWal->exclusiveMode==WAL_HEAPMEMORY_MODE ){\n<line23>pWal->apWiData[iPage] = (u32 volatile *)sqlite3MallocZero(WALINDEX_PGSZ);\n<line24>if( !pWal->apWiData[iPage] ) rc = SQLITE_NOMEM_BKPT;\n<line25>}else{\n<line26>rc = sqlite3OsShmMap(pWal->pDbFd, iPage, WALINDEX_PGSZ,\n<line27>pWal->writeLock, (void volatile **)&pWal->apWiData[iPage]\n<line28>);\n<line29>assert( pWal->apWiData[iPage]!=0\n<line30>|| rc!=SQLITE_OK\n<line31>|| (pWal->writeLock==0 && iPage==0) );\n<line32>testcase( pWal->apWiData[iPage]==0 && rc==SQLITE_OK );\n<line33>if( rc==SQLITE_OK ){\n<line34>if( iPage>0 && sqlite3FaultSim(600) ) rc = SQLITE_NOMEM;\n<line35>}else if( (rc&0xff)==SQLITE_READONLY ){\n<line36>pWal->readOnly |= WAL_SHM_RDONLY;\n<line37>if( rc==SQLITE_READONLY ){\n<line38>rc = SQLITE_OK;\n<line39>}\n<line40>}\n<line41>}\n<line42>*ppPage = pWal->apWiData[iPage];\n<line43>assert( iPage==0 || *ppPage || rc!=SQLITE_OK );\n<line44>return rc;\n<line45>}
----------------------------------------
Function: walIndexPage
Content: <line0>static int walIndexPage(\n<line1>Wal *pWal,               /* The WAL context */\n<line2>int iPage,               /* The page we seek */\n<line3>volatile u32 **ppPage    /* Write the page pointer here */\n<line4>){\n<line5>SEH_INJECT_FAULT;\n<line6>if( pWal->nWiData<=iPage || (*ppPage = pWal->apWiData[iPage])==0 ){\n<line7>return walIndexPageRealloc(pWal, iPage, ppPage);\n<line8>}\n<line9>return SQLITE_OK;\n<line10>}
----------------------------------------
Function: walCkptInfo
Content: <line0>static volatile WalCkptInfo *walCkptInfo(Wal *pWal){\n<line1>assert( pWal->nWiData>0 && pWal->apWiData[0] );\n<line2>SEH_INJECT_FAULT;\n<line3>return (volatile WalCkptInfo*)&(pWal->apWiData[0][sizeof(WalIndexHdr)/2]);\n<line4>}
----------------------------------------
Function: walIndexHdr
Content: <line0>static volatile WalIndexHdr *walIndexHdr(Wal *pWal){\n<line1>assert( pWal->nWiData>0 && pWal->apWiData[0] );\n<line2>SEH_INJECT_FAULT;\n<line3>return (volatile WalIndexHdr*)pWal->apWiData[0];\n<line4>}
----------------------------------------
Function: walChecksumBytes
Content: <line0>static void walChecksumBytes(\n<line1>int nativeCksum, /* True for native byte-order, false for non-native */\n<line2>u8 *a,           /* Content to be checksummed */\n<line3>int nByte,       /* Bytes of content in a[].  Must be a multiple of 8. */\n<line4>const u32 *aIn,  /* Initial checksum value input */\n<line5>u32 *aOut        /* OUT: Final checksum value output */\n<line6>){\n<line7>u32 s1, s2;\n<line8>u32 *aData = (u32 *)a;\n<line9>u32 *aEnd = (u32 *)&a[nByte];\n<line10>if( aIn ){\n<line11>s1 = aIn[0];\n<line12>s2 = aIn[1];\n<line13>}else{\n<line14>s1 = s2 = 0;\n<line15>}\n<line16>/* nByte is a multiple of 8 between 8 and 65536 */\n<line17>assert( nByte>=8 && (nByte&7)==0 && nByte<=65536 );\n<line18>if( !nativeCksum ){\n<line19>do {\n<line20>s1 += BYTESWAP32(aData[0]) + s2;\n<line21>s2 += BYTESWAP32(aData[1]) + s1;\n<line22>aData += 2;\n<line23>}while( aData<aEnd );\n<line24>}else if( nByte%64==0 ){\n<line25>do {\n<line26>s1 += *aData++ + s2;\n<line27>s2 += *aData++ + s1;\n<line28>s1 += *aData++ + s2;\n<line29>s2 += *aData++ + s1;\n<line30>s1 += *aData++ + s2;\n<line31>s2 += *aData++ + s1;\n<line32>s1 += *aData++ + s2;\n<line33>s2 += *aData++ + s1;\n<line34>s1 += *aData++ + s2;\n<line35>s2 += *aData++ + s1;\n<line36>s1 += *aData++ + s2;\n<line37>s2 += *aData++ + s1;\n<line38>s1 += *aData++ + s2;\n<line39>s2 += *aData++ + s1;\n<line40>s1 += *aData++ + s2;\n<line41>s2 += *aData++ + s1;\n<line42>}while( aData<aEnd );\n<line43>}else{\n<line44>do {\n<line45>s1 += *aData++ + s2;\n<line46>s2 += *aData++ + s1;\n<line47>}while( aData<aEnd );\n<line48>}\n<line49>assert( aData==aEnd );\n<line50>aOut[0] = s1;\n<line51>aOut[1] = s2;\n<line52>}
----------------------------------------
Function: walShmBarrier
Content: <line0>static void walShmBarrier(Wal *pWal){\n<line1>if( pWal->exclusiveMode!=WAL_HEAPMEMORY_MODE ){\n<line2>sqlite3OsShmBarrier(pWal->pDbFd);\n<line3>}\n<line4>}
----------------------------------------
Function: walIndexWriteHdr
Content: <line0>static SQLITE_NO_TSAN void walIndexWriteHdr(Wal *pWal){\n<line1>volatile WalIndexHdr *aHdr = walIndexHdr(pWal);\n<line2>const int nCksum = offsetof(WalIndexHdr, aCksum);\n<line3>assert( pWal->writeLock );\n<line4>pWal->hdr.isInit = 1;\n<line5>pWal->hdr.iVersion = WALINDEX_MAX_VERSION;\n<line6>walChecksumBytes(1, (u8*)&pWal->hdr, nCksum, 0, pWal->hdr.aCksum);\n<line7>/* Possible TSAN false-positive.  See tag-20200519-1 */\n<line8>memcpy((void*)&aHdr[1], (const void*)&pWal->hdr, sizeof(WalIndexHdr));\n<line9>walShmBarrier(pWal);\n<line10>memcpy((void*)&aHdr[0], (const void*)&pWal->hdr, sizeof(WalIndexHdr));\n<line11>}
----------------------------------------
Function: walEncodeFrame
Content: <line0>static void walEncodeFrame(\n<line1>Wal *pWal,                      /* The write-ahead log */\n<line2>u32 iPage,                      /* Database page number for frame */\n<line3>u32 nTruncate,                  /* New db size (or 0 for non-commit frames) */\n<line4>u8 *aData,                      /* Pointer to page data */\n<line5>u8 *aFrame                      /* OUT: Write encoded frame here */\n<line6>){\n<line7>int nativeCksum;                /* True for native byte-order checksums */\n<line8>u32 *aCksum = pWal->hdr.aFrameCksum;\n<line9>assert( WAL_FRAME_HDRSIZE==24 );\n<line10>sqlite3Put4byte(&aFrame[0], iPage);\n<line11>sqlite3Put4byte(&aFrame[4], nTruncate);\n<line12>if( pWal->iReCksum==0 ){\n<line13>memcpy(&aFrame[8], pWal->hdr.aSalt, 8);\n<line14>nativeCksum = (pWal->hdr.bigEndCksum==SQLITE_BIGENDIAN);\n<line15>walChecksumBytes(nativeCksum, aFrame, 8, aCksum, aCksum);\n<line16>walChecksumBytes(nativeCksum, aData, pWal->szPage, aCksum, aCksum);\n<line17>sqlite3Put4byte(&aFrame[16], aCksum[0]);\n<line18>sqlite3Put4byte(&aFrame[20], aCksum[1]);\n<line19>}else{\n<line20>memset(&aFrame[8], 0, 16);\n<line21>}\n<line22>}
----------------------------------------
Function: walDecodeFrame
Content: <line0>static int walDecodeFrame(\n<line1>Wal *pWal,                      /* The write-ahead log */\n<line2>u32 *piPage,                    /* OUT: Database page number for frame */\n<line3>u32 *pnTruncate,                /* OUT: New db size (or 0 if not commit) */\n<line4>u8 *aData,                      /* Pointer to page data (for checksum) */\n<line5>u8 *aFrame                      /* Frame data */\n<line6>){\n<line7>int nativeCksum;                /* True for native byte-order checksums */\n<line8>u32 *aCksum = pWal->hdr.aFrameCksum;\n<line9>u32 pgno;                       /* Page number of the frame */\n<line10>assert( WAL_FRAME_HDRSIZE==24 );\n<line11>/* A frame is only valid if the salt values in the frame-header\n<line12>** match the salt values in the wal-header.\n<line13>*/\n<line14>if( memcmp(&pWal->hdr.aSalt, &aFrame[8], 8)!=0 ){\n<line15>return 0;\n<line16>}\n<line17>/* A frame is only valid if the page number is greater than zero.\n<line18>*/\n<line19>pgno = sqlite3Get4byte(&aFrame[0]);\n<line20>if( pgno==0 ){\n<line21>return 0;\n<line22>}\n<line23>/* A frame is only valid if a checksum of the WAL header,\n<line24>** all prior frames, the first 16 bytes of this frame-header,\n<line25>** and the frame-data matches the checksum in the last 8\n<line26>** bytes of this frame-header.\n<line27>*/\n<line28>nativeCksum = (pWal->hdr.bigEndCksum==SQLITE_BIGENDIAN);\n<line29>walChecksumBytes(nativeCksum, aFrame, 8, aCksum, aCksum);\n<line30>walChecksumBytes(nativeCksum, aData, pWal->szPage, aCksum, aCksum);\n<line31>if( aCksum[0]!=sqlite3Get4byte(&aFrame[16])\n<line32>|| aCksum[1]!=sqlite3Get4byte(&aFrame[20])\n<line33>){\n<line34>/* Checksum failed. */\n<line35>return 0;\n<line36>}\n<line37>/* If we reach this point, the frame is valid.  Return the page number\n<line38>** and the new database size.\n<line39>*/\n<line40>*piPage = pgno;\n<line41>*pnTruncate = sqlite3Get4byte(&aFrame[4]);\n<line42>return 1;\n<line43>}
----------------------------------------
Function: walLockShared
Content: <line0>static int walLockShared(Wal *pWal, int lockIdx){\n<line1>int rc;\n<line2>if( pWal->exclusiveMode ) return SQLITE_OK;\n<line3>rc = sqlite3OsShmLock(pWal->pDbFd, lockIdx, 1,\n<line4>SQLITE_SHM_LOCK | SQLITE_SHM_SHARED);\n<line5>WALTRACE(("WAL%p: acquire SHARED-%s %s\n", pWal,\n<line6>walLockName(lockIdx), rc ? "failed" : "ok"));\n<line7>VVA_ONLY( pWal->lockError = (u8)(rc!=SQLITE_OK && (rc&0xFF)!=SQLITE_BUSY); )\n<line8>#ifdef SQLITE_USE_SEH\n<line9>if( rc==SQLITE_OK ) pWal->lockMask |= (1 << lockIdx);\n<line10>#endif\n<line11>return rc;\n<line12>}
----------------------------------------
Function: walUnlockShared
Content: <line0>static void walUnlockShared(Wal *pWal, int lockIdx){\n<line1>if( pWal->exclusiveMode ) return;\n<line2>(void)sqlite3OsShmLock(pWal->pDbFd, lockIdx, 1,\n<line3>SQLITE_SHM_UNLOCK | SQLITE_SHM_SHARED);\n<line4>#ifdef SQLITE_USE_SEH\n<line5>pWal->lockMask &= ~(1 << lockIdx);\n<line6>#endif\n<line7>WALTRACE(("WAL%p: release SHARED-%s\n", pWal, walLockName(lockIdx)));\n<line8>}
----------------------------------------
Function: walLockExclusive
Content: <line0>static int walLockExclusive(Wal *pWal, int lockIdx, int n){\n<line1>int rc;\n<line2>if( pWal->exclusiveMode ) return SQLITE_OK;\n<line3>rc = sqlite3OsShmLock(pWal->pDbFd, lockIdx, n,\n<line4>SQLITE_SHM_LOCK | SQLITE_SHM_EXCLUSIVE);\n<line5>WALTRACE(("WAL%p: acquire EXCLUSIVE-%s cnt=%d %s\n", pWal,\n<line6>walLockName(lockIdx), n, rc ? "failed" : "ok"));\n<line7>VVA_ONLY( pWal->lockError = (u8)(rc!=SQLITE_OK && (rc&0xFF)!=SQLITE_BUSY); )\n<line8>#ifdef SQLITE_USE_SEH\n<line9>if( rc==SQLITE_OK ){\n<line10>pWal->lockMask |= (((1<<n)-1) << (SQLITE_SHM_NLOCK+lockIdx));\n<line11>}\n<line12>#endif\n<line13>return rc;\n<line14>}
----------------------------------------
Function: walUnlockExclusive
Content: <line0>static void walUnlockExclusive(Wal *pWal, int lockIdx, int n){\n<line1>if( pWal->exclusiveMode ) return;\n<line2>(void)sqlite3OsShmLock(pWal->pDbFd, lockIdx, n,\n<line3>SQLITE_SHM_UNLOCK | SQLITE_SHM_EXCLUSIVE);\n<line4>#ifdef SQLITE_USE_SEH\n<line5>pWal->lockMask &= ~(((1<<n)-1) << (SQLITE_SHM_NLOCK+lockIdx));\n<line6>#endif\n<line7>WALTRACE(("WAL%p: release EXCLUSIVE-%s cnt=%d\n", pWal,\n<line8>walLockName(lockIdx), n));\n<line9>}
----------------------------------------
Function: walHash
Content: <line0>static int walHash(u32 iPage){\n<line1>assert( iPage>0 );\n<line2>assert( (HASHTABLE_NSLOT & (HASHTABLE_NSLOT-1))==0 );\n<line3>return (iPage*HASHTABLE_HASH_1) & (HASHTABLE_NSLOT-1);\n<line4>}
----------------------------------------
Function: walNextHash
Content: <line0>static int walNextHash(int iPriorHash){\n<line1>return (iPriorHash+1)&(HASHTABLE_NSLOT-1);\n<line2>}
----------------------------------------
Function: walHashGet
Content: <line0>static int walHashGet(\n<line1>Wal *pWal,                      /* WAL handle */\n<line2>int iHash,                      /* Find the iHash'th table */\n<line3>WalHashLoc *pLoc                /* OUT: Hash table location */\n<line4>){\n<line5>int rc;                         /* Return code */\n<line6>rc = walIndexPage(pWal, iHash, &pLoc->aPgno);\n<line7>assert( rc==SQLITE_OK || iHash>0 );\n<line8>if( pLoc->aPgno ){\n<line9>pLoc->aHash = (volatile ht_slot *)&pLoc->aPgno[HASHTABLE_NPAGE];\n<line10>if( iHash==0 ){\n<line11>pLoc->aPgno = &pLoc->aPgno[WALINDEX_HDR_SIZE/sizeof(u32)];\n<line12>pLoc->iZero = 0;\n<line13>}else{\n<line14>pLoc->iZero = HASHTABLE_NPAGE_ONE + (iHash-1)*HASHTABLE_NPAGE;\n<line15>}\n<line16>}else if( NEVER(rc==SQLITE_OK) ){\n<line17>rc = SQLITE_ERROR;\n<line18>}\n<line19>return rc;\n<line20>}
----------------------------------------
Function: walFramePage
Content: <line0>static int walFramePage(u32 iFrame){\n<line1>int iHash = (iFrame+HASHTABLE_NPAGE-HASHTABLE_NPAGE_ONE-1) / HASHTABLE_NPAGE;\n<line2>assert( (iHash==0 || iFrame>HASHTABLE_NPAGE_ONE)\n<line3>&& (iHash>=1 || iFrame<=HASHTABLE_NPAGE_ONE)\n<line4>&& (iHash<=1 || iFrame>(HASHTABLE_NPAGE_ONE+HASHTABLE_NPAGE))\n<line5>&& (iHash>=2 || iFrame<=HASHTABLE_NPAGE_ONE+HASHTABLE_NPAGE)\n<line6>&& (iHash<=2 || iFrame>(HASHTABLE_NPAGE_ONE+2*HASHTABLE_NPAGE))\n<line7>);\n<line8>assert( iHash>=0 );\n<line9>return iHash;\n<line10>}
----------------------------------------
Function: walFramePgno
Content: <line0>static u32 walFramePgno(Wal *pWal, u32 iFrame){\n<line1>int iHash = walFramePage(iFrame);\n<line2>SEH_INJECT_FAULT;\n<line3>if( iHash==0 ){\n<line4>return pWal->apWiData[0][WALINDEX_HDR_SIZE/sizeof(u32) + iFrame - 1];\n<line5>}\n<line6>return pWal->apWiData[iHash][(iFrame-1-HASHTABLE_NPAGE_ONE)%HASHTABLE_NPAGE];\n<line7>}
----------------------------------------
Function: walCleanupHash
Content: <line0>static void walCleanupHash(Wal *pWal){\n<line1>WalHashLoc sLoc;                /* Hash table location */\n<line2>int iLimit = 0;                 /* Zero values greater than this */\n<line3>int nByte;                      /* Number of bytes to zero in aPgno[] */\n<line4>int i;                          /* Used to iterate through aHash[] */\n<line5>assert( pWal->writeLock );\n<line6>testcase( pWal->hdr.mxFrame==HASHTABLE_NPAGE_ONE-1 );\n<line7>testcase( pWal->hdr.mxFrame==HASHTABLE_NPAGE_ONE );\n<line8>testcase( pWal->hdr.mxFrame==HASHTABLE_NPAGE_ONE+1 );\n<line9>if( pWal->hdr.mxFrame==0 ) return;\n<line10>/* Obtain pointers to the hash-table and page-number array containing\n<line11>** the entry that corresponds to frame pWal->hdr.mxFrame. It is guaranteed\n<line12>** that the page said hash-table and array reside on is already mapped.(1)\n<line13>*/\n<line14>assert( pWal->nWiData>walFramePage(pWal->hdr.mxFrame) );\n<line15>assert( pWal->apWiData[walFramePage(pWal->hdr.mxFrame)] );\n<line16>i = walHashGet(pWal, walFramePage(pWal->hdr.mxFrame), &sLoc);\n<line17>if( NEVER(i) ) return; /* Defense-in-depth, in case (1) above is wrong */\n<line18>/* Zero all hash-table entries that correspond to frame numbers greater\n<line19>** than pWal->hdr.mxFrame.\n<line20>*/\n<line21>iLimit = pWal->hdr.mxFrame - sLoc.iZero;\n<line22>assert( iLimit>0 );\n<line23>for(i=0; i<HASHTABLE_NSLOT; i++){\n<line24>if( sLoc.aHash[i]>iLimit ){\n<line25>sLoc.aHash[i] = 0;\n<line26>}\n<line27>}\n<line28>/* Zero the entries in the aPgno array that correspond to frames with\n<line29>** frame numbers greater than pWal->hdr.mxFrame.\n<line30>*/\n<line31>nByte = (int)((char *)sLoc.aHash - (char *)&sLoc.aPgno[iLimit]);\n<line32>assert( nByte>=0 );\n<line33>memset((void *)&sLoc.aPgno[iLimit], 0, nByte);\n<line34>#ifdef SQLITE_ENABLE_EXPENSIVE_ASSERT\n<line35>/* Verify that the every entry in the mapping region is still reachable\n<line36>** via the hash table even after the cleanup.\n<line37>*/\n<line38>if( iLimit ){\n<line39>int j;           /* Loop counter */\n<line40>int iKey;        /* Hash key */\n<line41>for(j=0; j<iLimit; j++){\n<line42>for(iKey=walHash(sLoc.aPgno[j]);sLoc.aHash[iKey];iKey=walNextHash(iKey)){\n<line43>if( sLoc.aHash[iKey]==j+1 ) break;\n<line44>}\n<line45>assert( sLoc.aHash[iKey]==j+1 );\n<line46>}\n<line47>}\n<line48>#endif /* SQLITE_ENABLE_EXPENSIVE_ASSERT */\n<line49>}
----------------------------------------
Function: walIndexAppend
Content: <line0>static int walIndexAppend(Wal *pWal, u32 iFrame, u32 iPage){\n<line1>int rc;                         /* Return code */\n<line2>WalHashLoc sLoc;                /* Wal-index hash table location */\n<line3>rc = walHashGet(pWal, walFramePage(iFrame), &sLoc);\n<line4>/* Assuming the wal-index file was successfully mapped, populate the\n<line5>** page number array and hash table entry.\n<line6>*/\n<line7>if( rc==SQLITE_OK ){\n<line8>int iKey;                     /* Hash table key */\n<line9>int idx;                      /* Value to write to hash-table slot */\n<line10>int nCollide;                 /* Number of hash collisions */\n<line11>idx = iFrame - sLoc.iZero;\n<line12>assert( idx <= HASHTABLE_NSLOT/2 + 1 );\n<line13>/* If this is the first entry to be added to this hash-table, zero the\n<line14>** entire hash table and aPgno[] array before proceeding.\n<line15>*/\n<line16>if( idx==1 ){\n<line17>int nByte = (int)((u8*)&sLoc.aHash[HASHTABLE_NSLOT] - (u8*)sLoc.aPgno);\n<line18>assert( nByte>=0 );\n<line19>memset((void*)sLoc.aPgno, 0, nByte);\n<line20>}\n<line21>/* If the entry in aPgno[] is already set, then the previous writer\n<line22>** must have exited unexpectedly in the middle of a transaction (after\n<line23>** writing one or more dirty pages to the WAL to free up memory).\n<line24>** Remove the remnants of that writers uncommitted transaction from\n<line25>** the hash-table before writing any new entries.\n<line26>*/\n<line27>if( sLoc.aPgno[idx-1] ){\n<line28>walCleanupHash(pWal);\n<line29>assert( !sLoc.aPgno[idx-1] );\n<line30>}\n<line31>/* Write the aPgno[] array entry and the hash-table slot. */\n<line32>nCollide = idx;\n<line33>for(iKey=walHash(iPage); sLoc.aHash[iKey]; iKey=walNextHash(iKey)){\n<line34>if( (nCollide--)==0 ) return SQLITE_CORRUPT_BKPT;\n<line35>}\n<line36>sLoc.aPgno[idx-1] = iPage;\n<line37>AtomicStore(&sLoc.aHash[iKey], (ht_slot)idx);\n<line38>#ifdef SQLITE_ENABLE_EXPENSIVE_ASSERT\n<line39>/* Verify that the number of entries in the hash table exactly equals\n<line40>** the number of entries in the mapping region.\n<line41>*/\n<line42>{\n<line43>int i;           /* Loop counter */\n<line44>int nEntry = 0;  /* Number of entries in the hash table */\n<line45>for(i=0; i<HASHTABLE_NSLOT; i++){ if( sLoc.aHash[i] ) nEntry++; }\n<line46>assert( nEntry==idx );\n<line47>}\n<line48>/* Verify that the every entry in the mapping region is reachable\n<line49>** via the hash table.  This turns out to be a really, really expensive\n<line50>** thing to check, so only do this occasionally - not on every\n<line51>** iteration.\n<line52>*/\n<line53>if( (idx&0x3ff)==0 ){\n<line54>int i;           /* Loop counter */\n<line55>for(i=0; i<idx; i++){\n<line56>for(iKey=walHash(sLoc.aPgno[i]);\n<line57>sLoc.aHash[iKey];\n<line58>iKey=walNextHash(iKey)){\n<line59>if( sLoc.aHash[iKey]==i+1 ) break;\n<line60>}\n<line61>assert( sLoc.aHash[iKey]==i+1 );\n<line62>}\n<line63>}\n<line64>#endif /* SQLITE_ENABLE_EXPENSIVE_ASSERT */\n<line65>}\n<line66>return rc;\n<line67>}
----------------------------------------
Function: walIndexRecover
Content: <line0>static int walIndexRecover(Wal *pWal){\n<line1>int rc;                         /* Return Code */\n<line2>i64 nSize;                      /* Size of log file */\n<line3>u32 aFrameCksum[2] = {0, 0};\n<line4>int iLock;                      /* Lock offset to lock for checkpoint */\n<line5>/* Obtain an exclusive lock on all byte in the locking range not already\n<line6>** locked by the caller. The caller is guaranteed to have locked the\n<line7>** WAL_WRITE_LOCK byte, and may have also locked the WAL_CKPT_LOCK byte.\n<line8>** If successful, the same bytes that are locked here are unlocked before\n<line9>** this function returns.\n<line10>*/\n<line11>assert( pWal->ckptLock==1 || pWal->ckptLock==0 );\n<line12>assert( WAL_ALL_BUT_WRITE==WAL_WRITE_LOCK+1 );\n<line13>assert( WAL_CKPT_LOCK==WAL_ALL_BUT_WRITE );\n<line14>assert( pWal->writeLock );\n<line15>iLock = WAL_ALL_BUT_WRITE + pWal->ckptLock;\n<line16>rc = walLockExclusive(pWal, iLock, WAL_READ_LOCK(0)-iLock);\n<line17>if( rc ){\n<line18>return rc;\n<line19>}\n<line20>WALTRACE(("WAL%p: recovery begin...\n", pWal));\n<line21>memset(&pWal->hdr, 0, sizeof(WalIndexHdr));\n<line22>rc = sqlite3OsFileSize(pWal->pWalFd, &nSize);\n<line23>if( rc!=SQLITE_OK ){\n<line24>goto recovery_error;\n<line25>}\n<line26>if( nSize>WAL_HDRSIZE ){\n<line27>u8 aBuf[WAL_HDRSIZE];         /* Buffer to load WAL header into */\n<line28>u32 *aPrivate = 0;            /* Heap copy of *-shm hash being populated */\n<line29>u8 *aFrame = 0;               /* Malloc'd buffer to load entire frame */\n<line30>int szFrame;                  /* Number of bytes in buffer aFrame[] */\n<line31>u8 *aData;                    /* Pointer to data part of aFrame buffer */\n<line32>int szPage;                   /* Page size according to the log */\n<line33>u32 magic;                    /* Magic value read from WAL header */\n<line34>u32 version;                  /* Magic value read from WAL header */\n<line35>int isValid;                  /* True if this frame is valid */\n<line36>u32 iPg;                      /* Current 32KB wal-index page */\n<line37>u32 iLastFrame;               /* Last frame in wal, based on nSize alone */\n<line38>/* Read in the WAL header. */\n<line39>rc = sqlite3OsRead(pWal->pWalFd, aBuf, WAL_HDRSIZE, 0);\n<line40>if( rc!=SQLITE_OK ){\n<line41>goto recovery_error;\n<line42>}\n<line43>/* If the database page size is not a power of two, or is greater than\n<line44>** SQLITE_MAX_PAGE_SIZE, conclude that the WAL file contains no valid\n<line45>** data. Similarly, if the 'magic' value is invalid, ignore the whole\n<line46>** WAL file.\n<line47>*/\n<line48>magic = sqlite3Get4byte(&aBuf[0]);\n<line49>szPage = sqlite3Get4byte(&aBuf[8]);\n<line50>if( (magic&0xFFFFFFFE)!=WAL_MAGIC\n<line51>|| szPage&(szPage-1)\n<line52>|| szPage>SQLITE_MAX_PAGE_SIZE\n<line53>|| szPage<512\n<line54>){\n<line55>goto finished;\n<line56>}\n<line57>pWal->hdr.bigEndCksum = (u8)(magic&0x00000001);\n<line58>pWal->szPage = szPage;\n<line59>pWal->nCkpt = sqlite3Get4byte(&aBuf[12]);\n<line60>memcpy(&pWal->hdr.aSalt, &aBuf[16], 8);\n<line61>/* Verify that the WAL header checksum is correct */\n<line62>walChecksumBytes(pWal->hdr.bigEndCksum==SQLITE_BIGENDIAN,\n<line63>aBuf, WAL_HDRSIZE-2*4, 0, pWal->hdr.aFrameCksum\n<line64>);\n<line65>if( pWal->hdr.aFrameCksum[0]!=sqlite3Get4byte(&aBuf[24])\n<line66>|| pWal->hdr.aFrameCksum[1]!=sqlite3Get4byte(&aBuf[28])\n<line67>){\n<line68>goto finished;\n<line69>}\n<line70>/* Verify that the version number on the WAL format is one that\n<line71>** are able to understand */\n<line72>version = sqlite3Get4byte(&aBuf[4]);\n<line73>if( version!=WAL_MAX_VERSION ){\n<line74>rc = SQLITE_CANTOPEN_BKPT;\n<line75>goto finished;\n<line76>}\n<line77>/* Malloc a buffer to read frames into. */\n<line78>szFrame = szPage + WAL_FRAME_HDRSIZE;\n<line79>aFrame = (u8 *)sqlite3_malloc64(szFrame + WALINDEX_PGSZ);\n<line80>SEH_FREE_ON_ERROR(0, aFrame);\n<line81>if( !aFrame ){\n<line82>rc = SQLITE_NOMEM_BKPT;\n<line83>goto recovery_error;\n<line84>}\n<line85>aData = &aFrame[WAL_FRAME_HDRSIZE];\n<line86>aPrivate = (u32*)&aData[szPage];\n<line87>/* Read all frames from the log file. */\n<line88>iLastFrame = (nSize - WAL_HDRSIZE) / szFrame;\n<line89>for(iPg=0; iPg<=(u32)walFramePage(iLastFrame); iPg++){\n<line90>u32 *aShare;\n<line91>u32 iFrame;                 /* Index of last frame read */\n<line92>u32 iLast = MIN(iLastFrame, HASHTABLE_NPAGE_ONE+iPg*HASHTABLE_NPAGE);\n<line93>u32 iFirst = 1 + (iPg==0?0:HASHTABLE_NPAGE_ONE+(iPg-1)*HASHTABLE_NPAGE);\n<line94>u32 nHdr, nHdr32;\n<line95>rc = walIndexPage(pWal, iPg, (volatile u32**)&aShare);\n<line96>assert( aShare!=0 || rc!=SQLITE_OK );\n<line97>if( aShare==0 ) break;\n<line98>SEH_SET_ON_ERROR(iPg, aShare);\n<line99>pWal->apWiData[iPg] = aPrivate;\n<line100>for(iFrame=iFirst; iFrame<=iLast; iFrame++){\n<line101>i64 iOffset = walFrameOffset(iFrame, szPage);\n<line102>u32 pgno;                 /* Database page number for frame */\n<line103>u32 nTruncate;            /* dbsize field from frame header */\n<line104>/* Read and decode the next log frame. */\n<line105>rc = sqlite3OsRead(pWal->pWalFd, aFrame, szFrame, iOffset);\n<line106>if( rc!=SQLITE_OK ) break;\n<line107>isValid = walDecodeFrame(pWal, &pgno, &nTruncate, aData, aFrame);\n<line108>if( !isValid ) break;\n<line109>rc = walIndexAppend(pWal, iFrame, pgno);\n<line110>if( NEVER(rc!=SQLITE_OK) ) break;\n<line111>/* If nTruncate is non-zero, this is a commit record. */\n<line112>if( nTruncate ){\n<line113>pWal->hdr.mxFrame = iFrame;\n<line114>pWal->hdr.nPage = nTruncate;\n<line115>pWal->hdr.szPage = (u16)((szPage&0xff00) | (szPage>>16));\n<line116>testcase( szPage<=32768 );\n<line117>testcase( szPage>=65536 );\n<line118>aFrameCksum[0] = pWal->hdr.aFrameCksum[0];\n<line119>aFrameCksum[1] = pWal->hdr.aFrameCksum[1];\n<line120>}\n<line121>}\n<line122>pWal->apWiData[iPg] = aShare;\n<line123>SEH_SET_ON_ERROR(0,0);\n<line124>nHdr = (iPg==0 ? WALINDEX_HDR_SIZE : 0);\n<line125>nHdr32 = nHdr / sizeof(u32);\n<line126>#ifndef SQLITE_SAFER_WALINDEX_RECOVERY\n<line127>/* Memcpy() should work fine here, on all reasonable implementations.\n<line128>** Technically, memcpy() might change the destination to some\n<line129>** intermediate value before setting to the final value, and that might\n<line130>** cause a concurrent reader to malfunction.  Memcpy() is allowed to\n<line131>** do that, according to the spec, but no memcpy() implementation that\n<line132>** we know of actually does that, which is why we say that memcpy()\n<line133>** is safe for this.  Memcpy() is certainly a lot faster.\n<line134>*/\n<line135>memcpy(&aShare[nHdr32], &aPrivate[nHdr32], WALINDEX_PGSZ-nHdr);\n<line136>#else\n<line137>/* In the event that some platform is found for which memcpy()\n<line138>** changes the destination to some intermediate value before\n<line139>** setting the final value, this alternative copy routine is\n<line140>** provided.\n<line141>*/\n<line142>{\n<line143>int i;\n<line144>for(i=nHdr32; i<WALINDEX_PGSZ/sizeof(u32); i++){\n<line145>if( aShare[i]!=aPrivate[i] ){\n<line146>/* Atomic memory operations are not required here because if\n<line147>** the value needs to be changed, that means it is not being\n<line148>** accessed concurrently. */\n<line149>aShare[i] = aPrivate[i];\n<line150>}\n<line151>}\n<line152>}\n<line153>#endif\n<line154>SEH_INJECT_FAULT;\n<line155>if( iFrame<=iLast ) break;\n<line156>}\n<line157>SEH_FREE_ON_ERROR(aFrame, 0);\n<line158>sqlite3_free(aFrame);\n<line159>}\n<line160>finished:\n<line161>if( rc==SQLITE_OK ){\n<line162>volatile WalCkptInfo *pInfo;\n<line163>int i;\n<line164>pWal->hdr.aFrameCksum[0] = aFrameCksum[0];\n<line165>pWal->hdr.aFrameCksum[1] = aFrameCksum[1];\n<line166>walIndexWriteHdr(pWal);\n<line167>/* Reset the checkpoint-header. This is safe because this thread is\n<line168>** currently holding locks that exclude all other writers and\n<line169>** checkpointers. Then set the values of read-mark slots 1 through N.\n<line170>*/\n<line171>pInfo = walCkptInfo(pWal);\n<line172>pInfo->nBackfill = 0;\n<line173>pInfo->nBackfillAttempted = pWal->hdr.mxFrame;\n<line174>pInfo->aReadMark[0] = 0;\n<line175>for(i=1; i<WAL_NREADER; i++){\n<line176>rc = walLockExclusive(pWal, WAL_READ_LOCK(i), 1);\n<line177>if( rc==SQLITE_OK ){\n<line178>if( i==1 && pWal->hdr.mxFrame ){\n<line179>pInfo->aReadMark[i] = pWal->hdr.mxFrame;\n<line180>}else{\n<line181>pInfo->aReadMark[i] = READMARK_NOT_USED;\n<line182>}\n<line183>SEH_INJECT_FAULT;\n<line184>walUnlockExclusive(pWal, WAL_READ_LOCK(i), 1);\n<line185>}else if( rc!=SQLITE_BUSY ){\n<line186>goto recovery_error;\n<line187>}\n<line188>}\n<line189>/* If more than one frame was recovered from the log file, report an\n<line190>** event via sqlite3_log(). This is to help with identifying performance\n<line191>** problems caused by applications routinely shutting down without\n<line192>** checkpointing the log file.\n<line193>*/\n<line194>if( pWal->hdr.nPage ){\n<line195>sqlite3_log(SQLITE_NOTICE_RECOVER_WAL,\n<line196>"recovered %d frames from WAL file %s",\n<line197>pWal->hdr.mxFrame, pWal->zWalName\n<line198>);\n<line199>}\n<line200>}\n<line201>recovery_error:\n<line202>WALTRACE(("WAL%p: recovery %s\n", pWal, rc ? "failed" : "ok"));\n<line203>walUnlockExclusive(pWal, iLock, WAL_READ_LOCK(0)-iLock);\n<line204>return rc;\n<line205>}
----------------------------------------
Function: walIndexClose
Content: <line0>static void walIndexClose(Wal *pWal, int isDelete){\n<line1>if( pWal->exclusiveMode==WAL_HEAPMEMORY_MODE || pWal->bShmUnreliable ){\n<line2>int i;\n<line3>for(i=0; i<pWal->nWiData; i++){\n<line4>sqlite3_free((void *)pWal->apWiData[i]);\n<line5>pWal->apWiData[i] = 0;\n<line6>}\n<line7>}\n<line8>if( pWal->exclusiveMode!=WAL_HEAPMEMORY_MODE ){\n<line9>sqlite3OsShmUnmap(pWal->pDbFd, isDelete);\n<line10>}\n<line11>}
----------------------------------------
Function: walIteratorNext
Content: <line0>static int walIteratorNext(\n<line1>WalIterator *p,               /* Iterator */\n<line2>u32 *piPage,                  /* OUT: The page number of the next page */\n<line3>u32 *piFrame                  /* OUT: Wal frame index of next page */\n<line4>){\n<line5>u32 iMin;                     /* Result pgno must be greater than iMin */\n<line6>u32 iRet = 0xFFFFFFFF;        /* 0xffffffff is never a valid page number */\n<line7>int i;                        /* For looping through segments */\n<line8>iMin = p->iPrior;\n<line9>assert( iMin<0xffffffff );\n<line10>for(i=p->nSegment-1; i>=0; i--){\n<line11>struct WalSegment *pSegment = &p->aSegment[i];\n<line12>while( pSegment->iNext<pSegment->nEntry ){\n<line13>u32 iPg = pSegment->aPgno[pSegment->aIndex[pSegment->iNext]];\n<line14>if( iPg>iMin ){\n<line15>if( iPg<iRet ){\n<line16>iRet = iPg;\n<line17>*piFrame = pSegment->iZero + pSegment->aIndex[pSegment->iNext];\n<line18>}\n<line19>break;\n<line20>}\n<line21>pSegment->iNext++;\n<line22>}\n<line23>}\n<line24>*piPage = p->iPrior = iRet;\n<line25>return (iRet==0xFFFFFFFF);\n<line26>}
----------------------------------------
Function: walMerge
Content: <line0>static void walMerge(\n<line1>const u32 *aContent,            /* Pages in wal - keys for the sort */\n<line2>ht_slot *aLeft,                 /* IN: Left hand input list */\n<line3>int nLeft,                      /* IN: Elements in array *paLeft */\n<line4>ht_slot **paRight,              /* IN/OUT: Right hand input list */\n<line5>int *pnRight,                   /* IN/OUT: Elements in *paRight */\n<line6>ht_slot *aTmp                   /* Temporary buffer */\n<line7>){\n<line8>int iLeft = 0;                  /* Current index in aLeft */\n<line9>int iRight = 0;                 /* Current index in aRight */\n<line10>int iOut = 0;                   /* Current index in output buffer */\n<line11>int nRight = *pnRight;\n<line12>ht_slot *aRight = *paRight;\n<line13>assert( nLeft>0 && nRight>0 );\n<line14>while( iRight<nRight || iLeft<nLeft ){\n<line15>ht_slot logpage;\n<line16>Pgno dbpage;\n<line17>if( (iLeft<nLeft)\n<line18>&& (iRight>=nRight || aContent[aLeft[iLeft]]<aContent[aRight[iRight]])\n<line19>){\n<line20>logpage = aLeft[iLeft++];\n<line21>}else{\n<line22>logpage = aRight[iRight++];\n<line23>}\n<line24>dbpage = aContent[logpage];\n<line25>aTmp[iOut++] = logpage;\n<line26>if( iLeft<nLeft && aContent[aLeft[iLeft]]==dbpage ) iLeft++;\n<line27>assert( iLeft>=nLeft || aContent[aLeft[iLeft]]>dbpage );\n<line28>assert( iRight>=nRight || aContent[aRight[iRight]]>dbpage );\n<line29>}\n<line30>*paRight = aLeft;\n<line31>*pnRight = iOut;\n<line32>memcpy(aLeft, aTmp, sizeof(aTmp[0])*iOut);\n<line33>}
----------------------------------------
Function: walMergesort
Content: <line0>static void walMergesort(\n<line1>const u32 *aContent,            /* Pages in wal */\n<line2>ht_slot *aBuffer,               /* Buffer of at least *pnList items to use */\n<line3>ht_slot *aList,                 /* IN/OUT: List to sort */\n<line4>int *pnList                     /* IN/OUT: Number of elements in aList[] */\n<line5>){\n<line6>struct Sublist {\n<line7>int nList;                    /* Number of elements in aList */\n<line8>ht_slot *aList;               /* Pointer to sub-list content */\n<line9>};\n<line10>const int nList = *pnList;      /* Size of input list */\n<line11>int nMerge = 0;                 /* Number of elements in list aMerge */\n<line12>ht_slot *aMerge = 0;            /* List to be merged */\n<line13>int iList;                      /* Index into input list */\n<line14>u32 iSub = 0;                   /* Index into aSub array */\n<line15>struct Sublist aSub[13];        /* Array of sub-lists */\n<line16>memset(aSub, 0, sizeof(aSub));\n<line17>assert( nList<=HASHTABLE_NPAGE && nList>0 );\n<line18>assert( HASHTABLE_NPAGE==(1<<(ArraySize(aSub)-1)) );\n<line19>for(iList=0; iList<nList; iList++){\n<line20>nMerge = 1;\n<line21>aMerge = &aList[iList];\n<line22>for(iSub=0; iList & (1<<iSub); iSub++){\n<line23>struct Sublist *p;\n<line24>assert( iSub<ArraySize(aSub) );\n<line25>p = &aSub[iSub];\n<line26>assert( p->aList && p->nList<=(1<<iSub) );\n<line27>assert( p->aList==&aList[iList&~((2<<iSub)-1)] );\n<line28>walMerge(aContent, p->aList, p->nList, &aMerge, &nMerge, aBuffer);\n<line29>}\n<line30>aSub[iSub].aList = aMerge;\n<line31>aSub[iSub].nList = nMerge;\n<line32>}\n<line33>for(iSub++; iSub<ArraySize(aSub); iSub++){\n<line34>if( nList & (1<<iSub) ){\n<line35>struct Sublist *p;\n<line36>assert( iSub<ArraySize(aSub) );\n<line37>p = &aSub[iSub];\n<line38>assert( p->nList<=(1<<iSub) );\n<line39>assert( p->aList==&aList[nList&~((2<<iSub)-1)] );\n<line40>walMerge(aContent, p->aList, p->nList, &aMerge, &nMerge, aBuffer);\n<line41>}\n<line42>}\n<line43>assert( aMerge==aList );\n<line44>*pnList = nMerge;\n<line45>#ifdef SQLITE_DEBUG\n<line46>{\n<line47>int i;\n<line48>for(i=1; i<*pnList; i++){\n<line49>assert( aContent[aList[i]] > aContent[aList[i-1]] );\n<line50>}\n<line51>}\n<line52>#endif\n<line53>}
----------------------------------------
Function: walIteratorFree
Content: <line0>static void walIteratorFree(WalIterator *p){\n<line1>sqlite3_free(p);\n<line2>}
----------------------------------------
Function: walIteratorInit
Content: <line0>static int walIteratorInit(Wal *pWal, u32 nBackfill, WalIterator **pp){\n<line1>WalIterator *p;                 /* Return value */\n<line2>int nSegment;                   /* Number of segments to merge */\n<line3>u32 iLast;                      /* Last frame in log */\n<line4>sqlite3_int64 nByte;            /* Number of bytes to allocate */\n<line5>int i;                          /* Iterator variable */\n<line6>ht_slot *aTmp;                  /* Temp space used by merge-sort */\n<line7>int rc = SQLITE_OK;             /* Return Code */\n<line8>/* This routine only runs while holding the checkpoint lock. And\n<line9>** it only runs if there is actually content in the log (mxFrame>0).\n<line10>*/\n<line11>assert( pWal->ckptLock && pWal->hdr.mxFrame>0 );\n<line12>iLast = pWal->hdr.mxFrame;\n<line13>/* Allocate space for the WalIterator object. */\n<line14>nSegment = walFramePage(iLast) + 1;\n<line15>nByte = SZ_WALITERATOR(nSegment)\n<line16>+ iLast*sizeof(ht_slot);\n<line17>p = (WalIterator *)sqlite3_malloc64(nByte\n<line18>+ sizeof(ht_slot) * (iLast>HASHTABLE_NPAGE?HASHTABLE_NPAGE:iLast)\n<line19>);\n<line20>if( !p ){\n<line21>return SQLITE_NOMEM_BKPT;\n<line22>}\n<line23>memset(p, 0, nByte);\n<line24>p->nSegment = nSegment;\n<line25>aTmp = (ht_slot*)&(((u8*)p)[nByte]);\n<line26>SEH_FREE_ON_ERROR(0, p);\n<line27>for(i=walFramePage(nBackfill+1); rc==SQLITE_OK && i<nSegment; i++){\n<line28>WalHashLoc sLoc;\n<line29>rc = walHashGet(pWal, i, &sLoc);\n<line30>if( rc==SQLITE_OK ){\n<line31>int j;                      /* Counter variable */\n<line32>int nEntry;                 /* Number of entries in this segment */\n<line33>ht_slot *aIndex;            /* Sorted index for this segment */\n<line34>if( (i+1)==nSegment ){\n<line35>nEntry = (int)(iLast - sLoc.iZero);\n<line36>}else{\n<line37>nEntry = (int)((u32*)sLoc.aHash - (u32*)sLoc.aPgno);\n<line38>}\n<line39>aIndex = &((ht_slot *)&p->aSegment[p->nSegment])[sLoc.iZero];\n<line40>sLoc.iZero++;\n<line41>for(j=0; j<nEntry; j++){\n<line42>aIndex[j] = (ht_slot)j;\n<line43>}\n<line44>walMergesort((u32 *)sLoc.aPgno, aTmp, aIndex, &nEntry);\n<line45>p->aSegment[i].iZero = sLoc.iZero;\n<line46>p->aSegment[i].nEntry = nEntry;\n<line47>p->aSegment[i].aIndex = aIndex;\n<line48>p->aSegment[i].aPgno = (u32 *)sLoc.aPgno;\n<line49>}\n<line50>}\n<line51>if( rc!=SQLITE_OK ){\n<line52>SEH_FREE_ON_ERROR(p, 0);\n<line53>walIteratorFree(p);\n<line54>p = 0;\n<line55>}\n<line56>*pp = p;\n<line57>return rc;\n<line58>}
----------------------------------------
Function: walBusyLock
Content: <line0>static int walBusyLock(\n<line1>Wal *pWal,                      /* WAL connection */\n<line2>int (*xBusy)(void*),            /* Function to call when busy */\n<line3>void *pBusyArg,                 /* Context argument for xBusyHandler */\n<line4>int lockIdx,                    /* Offset of first byte to lock */\n<line5>int n                           /* Number of bytes to lock */\n<line6>){\n<line7>int rc;\n<line8>do {\n<line9>rc = walLockExclusive(pWal, lockIdx, n);\n<line10>}while( xBusy && rc==SQLITE_BUSY && xBusy(pBusyArg) );\n<line11>#ifdef SQLITE_ENABLE_SETLK_TIMEOUT\n<line12>if( rc==SQLITE_BUSY_TIMEOUT ){\n<line13>walDisableBlocking(pWal);\n<line14>rc = SQLITE_BUSY;\n<line15>}\n<line16>#endif\n<line17>return rc;\n<line18>}
----------------------------------------
Function: walPagesize
Content: <line0>static int walPagesize(Wal *pWal){\n<line1>return (pWal->hdr.szPage&0xfe00) + ((pWal->hdr.szPage&0x0001)<<16);\n<line2>}
----------------------------------------
Function: walRestartHdr
Content: <line0>static void walRestartHdr(Wal *pWal, u32 salt1){\n<line1>volatile WalCkptInfo *pInfo = walCkptInfo(pWal);\n<line2>int i;                          /* Loop counter */\n<line3>u32 *aSalt = pWal->hdr.aSalt;   /* Big-endian salt values */\n<line4>pWal->nCkpt++;\n<line5>pWal->hdr.mxFrame = 0;\n<line6>sqlite3Put4byte((u8*)&aSalt[0], 1 + sqlite3Get4byte((u8*)&aSalt[0]));\n<line7>memcpy(&pWal->hdr.aSalt[1], &salt1, 4);\n<line8>walIndexWriteHdr(pWal);\n<line9>AtomicStore(&pInfo->nBackfill, 0);\n<line10>pInfo->nBackfillAttempted = 0;\n<line11>pInfo->aReadMark[1] = 0;\n<line12>for(i=2; i<WAL_NREADER; i++) pInfo->aReadMark[i] = READMARK_NOT_USED;\n<line13>assert( pInfo->aReadMark[0]==0 );\n<line14>}
----------------------------------------
Function: walCheckpoint
Content: <line0>static int walCheckpoint(\n<line1>Wal *pWal,                      /* Wal connection */\n<line2>sqlite3 *db,                    /* Check for interrupts on this handle */\n<line3>int eMode,                      /* One of PASSIVE, FULL or RESTART */\n<line4>int (*xBusy)(void*),            /* Function to call when busy */\n<line5>void *pBusyArg,                 /* Context argument for xBusyHandler */\n<line6>int sync_flags,                 /* Flags for OsSync() (or 0) */\n<line7>u8 *zBuf                        /* Temporary buffer to use */\n<line8>){\n<line9>int rc = SQLITE_OK;             /* Return code */\n<line10>int szPage;                     /* Database page-size */\n<line11>WalIterator *pIter = 0;         /* Wal iterator context */\n<line12>u32 iDbpage = 0;                /* Next database page to write */\n<line13>u32 iFrame = 0;                 /* Wal frame containing data for iDbpage */\n<line14>u32 mxSafeFrame;                /* Max frame that can be backfilled */\n<line15>u32 mxPage;                     /* Max database page to write */\n<line16>int i;                          /* Loop counter */\n<line17>volatile WalCkptInfo *pInfo;    /* The checkpoint status information */\n<line18>szPage = walPagesize(pWal);\n<line19>testcase( szPage<=32768 );\n<line20>testcase( szPage>=65536 );\n<line21>pInfo = walCkptInfo(pWal);\n<line22>if( pInfo->nBackfill<pWal->hdr.mxFrame ){\n<line23>/* EVIDENCE-OF: R-62920-47450 The busy-handler callback is never invoked\n<line24>** in the SQLITE_CHECKPOINT_PASSIVE mode. */\n<line25>assert( eMode!=SQLITE_CHECKPOINT_PASSIVE || xBusy==0 );\n<line26>/* Compute in mxSafeFrame the index of the last frame of the WAL that is\n<line27>** safe to write into the database.  Frames beyond mxSafeFrame might\n<line28>** overwrite database pages that are in use by active readers and thus\n<line29>** cannot be backfilled from the WAL.\n<line30>*/\n<line31>mxSafeFrame = pWal->hdr.mxFrame;\n<line32>mxPage = pWal->hdr.nPage;\n<line33>for(i=1; i<WAL_NREADER; i++){\n<line34>u32 y = AtomicLoad(pInfo->aReadMark+i); SEH_INJECT_FAULT;\n<line35>if( mxSafeFrame>y ){\n<line36>assert( y<=pWal->hdr.mxFrame );\n<line37>rc = walBusyLock(pWal, xBusy, pBusyArg, WAL_READ_LOCK(i), 1);\n<line38>if( rc==SQLITE_OK ){\n<line39>u32 iMark = (i==1 ? mxSafeFrame : READMARK_NOT_USED);\n<line40>AtomicStore(pInfo->aReadMark+i, iMark); SEH_INJECT_FAULT;\n<line41>walUnlockExclusive(pWal, WAL_READ_LOCK(i), 1);\n<line42>}else if( rc==SQLITE_BUSY ){\n<line43>mxSafeFrame = y;\n<line44>xBusy = 0;\n<line45>}else{\n<line46>goto walcheckpoint_out;\n<line47>}\n<line48>}\n<line49>}\n<line50>/* Allocate the iterator */\n<line51>if( pInfo->nBackfill<mxSafeFrame ){\n<line52>rc = walIteratorInit(pWal, pInfo->nBackfill, &pIter);\n<line53>assert( rc==SQLITE_OK || pIter==0 );\n<line54>}\n<line55>if( pIter\n<line56>&& (rc = walBusyLock(pWal,xBusy,pBusyArg,WAL_READ_LOCK(0),1))==SQLITE_OK\n<line57>){\n<line58>u32 nBackfill = pInfo->nBackfill;\n<line59>pInfo->nBackfillAttempted = mxSafeFrame; SEH_INJECT_FAULT;\n<line60>/* Sync the WAL to disk */\n<line61>rc = sqlite3OsSync(pWal->pWalFd, CKPT_SYNC_FLAGS(sync_flags));\n<line62>/* If the database may grow as a result of this checkpoint, hint\n<line63>** about the eventual size of the db file to the VFS layer.\n<line64>*/\n<line65>if( rc==SQLITE_OK ){\n<line66>i64 nReq = ((i64)mxPage * szPage);\n<line67>i64 nSize;                    /* Current size of database file */\n<line68>sqlite3OsFileControl(pWal->pDbFd, SQLITE_FCNTL_CKPT_START, 0);\n<line69>rc = sqlite3OsFileSize(pWal->pDbFd, &nSize);\n<line70>if( rc==SQLITE_OK && nSize<nReq ){\n<line71>if( (nSize+65536+(i64)pWal->hdr.mxFrame*szPage)<nReq ){\n<line72>/* If the size of the final database is larger than the current\n<line73>** database plus the amount of data in the wal file, plus the\n<line74>** maximum size of the pending-byte page (65536 bytes), then\n<line75>** must be corruption somewhere.  */\n<line76>rc = SQLITE_CORRUPT_BKPT;\n<line77>}else{\n<line78>sqlite3OsFileControlHint(pWal->pDbFd, SQLITE_FCNTL_SIZE_HINT,&nReq);\n<line79>}\n<line80>}\n<line81>}\n<line82>/* Iterate through the contents of the WAL, copying data to the db file */\n<line83>while( rc==SQLITE_OK && 0==walIteratorNext(pIter, &iDbpage, &iFrame) ){\n<line84>i64 iOffset;\n<line85>assert( walFramePgno(pWal, iFrame)==iDbpage );\n<line86>SEH_INJECT_FAULT;\n<line87>if( AtomicLoad(&db->u1.isInterrupted) ){\n<line88>rc = db->mallocFailed ? SQLITE_NOMEM_BKPT : SQLITE_INTERRUPT;\n<line89>break;\n<line90>}\n<line91>if( iFrame<=nBackfill || iFrame>mxSafeFrame || iDbpage>mxPage ){\n<line92>continue;\n<line93>}\n<line94>iOffset = walFrameOffset(iFrame, szPage) + WAL_FRAME_HDRSIZE;\n<line95>/* testcase( IS_BIG_INT(iOffset) ); // requires a 4GiB WAL file */\n<line96>rc = sqlite3OsRead(pWal->pWalFd, zBuf, szPage, iOffset);\n<line97>if( rc!=SQLITE_OK ) break;\n<line98>iOffset = (iDbpage-1)*(i64)szPage;\n<line99>testcase( IS_BIG_INT(iOffset) );\n<line100>rc = sqlite3OsWrite(pWal->pDbFd, zBuf, szPage, iOffset);\n<line101>if( rc!=SQLITE_OK ) break;\n<line102>}\n<line103>sqlite3OsFileControl(pWal->pDbFd, SQLITE_FCNTL_CKPT_DONE, 0);\n<line104>/* If work was actually accomplished... */\n<line105>if( rc==SQLITE_OK ){\n<line106>if( mxSafeFrame==walIndexHdr(pWal)->mxFrame ){\n<line107>i64 szDb = pWal->hdr.nPage*(i64)szPage;\n<line108>testcase( IS_BIG_INT(szDb) );\n<line109>rc = sqlite3OsTruncate(pWal->pDbFd, szDb);\n<line110>if( rc==SQLITE_OK ){\n<line111>rc = sqlite3OsSync(pWal->pDbFd, CKPT_SYNC_FLAGS(sync_flags));\n<line112>}\n<line113>}\n<line114>if( rc==SQLITE_OK ){\n<line115>AtomicStore(&pInfo->nBackfill, mxSafeFrame); SEH_INJECT_FAULT;\n<line116>}\n<line117>}\n<line118>/* Release the reader lock held while backfilling */\n<line119>walUnlockExclusive(pWal, WAL_READ_LOCK(0), 1);\n<line120>}\n<line121>if( rc==SQLITE_BUSY ){\n<line122>/* Reset the return code so as not to report a checkpoint failure\n<line123>** just because there are active readers.  */\n<line124>rc = SQLITE_OK;\n<line125>}\n<line126>}\n<line127>/* If this is an SQLITE_CHECKPOINT_RESTART or TRUNCATE operation, and the\n<line128>** entire wal file has been copied into the database file, then block\n<line129>** until all readers have finished using the wal file. This ensures that\n<line130>** the next process to write to the database restarts the wal file.\n<line131>*/\n<line132>if( rc==SQLITE_OK && eMode!=SQLITE_CHECKPOINT_PASSIVE ){\n<line133>assert( pWal->writeLock );\n<line134>SEH_INJECT_FAULT;\n<line135>if( pInfo->nBackfill<pWal->hdr.mxFrame ){\n<line136>rc = SQLITE_BUSY;\n<line137>}else if( eMode>=SQLITE_CHECKPOINT_RESTART ){\n<line138>u32 salt1;\n<line139>sqlite3_randomness(4, &salt1);\n<line140>assert( pInfo->nBackfill==pWal->hdr.mxFrame );\n<line141>rc = walBusyLock(pWal, xBusy, pBusyArg, WAL_READ_LOCK(1), WAL_NREADER-1);\n<line142>if( rc==SQLITE_OK ){\n<line143>if( eMode==SQLITE_CHECKPOINT_TRUNCATE ){\n<line144>/* IMPLEMENTATION-OF: R-44699-57140 This mode works the same way as\n<line145>** SQLITE_CHECKPOINT_RESTART with the addition that it also\n<line146>** truncates the log file to zero bytes just prior to a\n<line147>** successful return.\n<line148>**\n<line149>** In theory, it might be safe to do this without updating the\n<line150>** wal-index header in shared memory, as all subsequent reader or\n<line151>** writer clients should see that the entire log file has been\n<line152>** checkpointed and behave accordingly. This seems unsafe though,\n<line153>** as it would leave the system in a state where the contents of\n<line154>** the wal-index header do not match the contents of the\n<line155>** file-system. To avoid this, update the wal-index header to\n<line156>** indicate that the log file contains zero valid frames.  */\n<line157>walRestartHdr(pWal, salt1);\n<line158>rc = sqlite3OsTruncate(pWal->pWalFd, 0);\n<line159>}\n<line160>walUnlockExclusive(pWal, WAL_READ_LOCK(1), WAL_NREADER-1);\n<line161>}\n<line162>}\n<line163>}\n<line164>walcheckpoint_out:\n<line165>SEH_FREE_ON_ERROR(pIter, 0);\n<line166>walIteratorFree(pIter);\n<line167>return rc;\n<line168>}
----------------------------------------
Function: walLimitSize
Content: <line0>static void walLimitSize(Wal *pWal, i64 nMax){\n<line1>i64 sz;\n<line2>int rx;\n<line3>sqlite3BeginBenignMalloc();\n<line4>rx = sqlite3OsFileSize(pWal->pWalFd, &sz);\n<line5>if( rx==SQLITE_OK && (sz > nMax ) ){\n<line6>rx = sqlite3OsTruncate(pWal->pWalFd, nMax);\n<line7>}\n<line8>sqlite3EndBenignMalloc();\n<line9>if( rx ){\n<line10>sqlite3_log(rx, "cannot limit WAL size: %s", pWal->zWalName);\n<line11>}\n<line12>}
----------------------------------------
Function: walIndexTryHdr
Content: <line0>static SQLITE_NO_TSAN int walIndexTryHdr(Wal *pWal, int *pChanged){\n<line1>u32 aCksum[2];                  /* Checksum on the header content */\n<line2>WalIndexHdr h1, h2;             /* Two copies of the header content */\n<line3>WalIndexHdr volatile *aHdr;     /* Header in shared memory */\n<line4>/* The first page of the wal-index must be mapped at this point. */\n<line5>assert( pWal->nWiData>0 && pWal->apWiData[0] );\n<line6>/* Read the header. This might happen concurrently with a write to the\n<line7>** same area of shared memory on a different CPU in a SMP,\n<line8>** meaning it is possible that an inconsistent snapshot is read\n<line9>** from the file. If this happens, return non-zero.\n<line10>**\n<line11>** tag-20200519-1:\n<line12>** There are two copies of the header at the beginning of the wal-index.\n<line13>** When reading, read [0] first then [1].  Writes are in the reverse order.\n<line14>** Memory barriers are used to prevent the compiler or the hardware from\n<line15>** reordering the reads and writes.  TSAN and similar tools can sometimes\n<line16>** give false-positive warnings about these accesses because the tools do not\n<line17>** account for the double-read and the memory barrier. The use of mutexes\n<line18>** here would be problematic as the memory being accessed is potentially\n<line19>** shared among multiple processes and not all mutex implementations work\n<line20>** reliably in that environment.\n<line21>*/\n<line22>aHdr = walIndexHdr(pWal);\n<line23>memcpy(&h1, (void *)&aHdr[0], sizeof(h1)); /* Possible TSAN false-positive */\n<line24>walShmBarrier(pWal);\n<line25>memcpy(&h2, (void *)&aHdr[1], sizeof(h2));\n<line26>if( memcmp(&h1, &h2, sizeof(h1))!=0 ){\n<line27>return 1;   /* Dirty read */\n<line28>}\n<line29>if( h1.isInit==0 ){\n<line30>return 1;   /* Malformed header - probably all zeros */\n<line31>}\n<line32>walChecksumBytes(1, (u8*)&h1, sizeof(h1)-sizeof(h1.aCksum), 0, aCksum);\n<line33>if( aCksum[0]!=h1.aCksum[0] || aCksum[1]!=h1.aCksum[1] ){\n<line34>return 1;   /* Checksum does not match */\n<line35>}\n<line36>if( memcmp(&pWal->hdr, &h1, sizeof(WalIndexHdr)) ){\n<line37>*pChanged = 1;\n<line38>memcpy(&pWal->hdr, &h1, sizeof(WalIndexHdr));\n<line39>pWal->szPage = (pWal->hdr.szPage&0xfe00) + ((pWal->hdr.szPage&0x0001)<<16);\n<line40>testcase( pWal->szPage<=32768 );\n<line41>testcase( pWal->szPage>=65536 );\n<line42>}\n<line43>/* The header was successfully read. Return zero. */\n<line44>return 0;\n<line45>}
----------------------------------------
Function: walIndexReadHdr
Content: <line0>static int walIndexReadHdr(Wal *pWal, int *pChanged){\n<line1>int rc;                         /* Return code */\n<line2>int badHdr;                     /* True if a header read failed */\n<line3>volatile u32 *page0;            /* Chunk of wal-index containing header */\n<line4>/* Ensure that page 0 of the wal-index (the page that contains the\n<line5>** wal-index header) is mapped. Return early if an error occurs here.\n<line6>*/\n<line7>assert( pChanged );\n<line8>rc = walIndexPage(pWal, 0, &page0);\n<line9>if( rc!=SQLITE_OK ){\n<line10>assert( rc!=SQLITE_READONLY ); /* READONLY changed to OK in walIndexPage */\n<line11>if( rc==SQLITE_READONLY_CANTINIT ){\n<line12>/* The SQLITE_READONLY_CANTINIT return means that the shared-memory\n<line13>** was openable but is not writable, and this thread is unable to\n<line14>** confirm that another write-capable connection has the shared-memory\n<line15>** open, and hence the content of the shared-memory is unreliable,\n<line16>** since the shared-memory might be inconsistent with the WAL file\n<line17>** and there is no writer on hand to fix it. */\n<line18>assert( page0==0 );\n<line19>assert( pWal->writeLock==0 );\n<line20>assert( pWal->readOnly & WAL_SHM_RDONLY );\n<line21>pWal->bShmUnreliable = 1;\n<line22>pWal->exclusiveMode = WAL_HEAPMEMORY_MODE;\n<line23>*pChanged = 1;\n<line24>}else{\n<line25>return rc; /* Any other non-OK return is just an error */\n<line26>}\n<line27>}else{\n<line28>/* page0 can be NULL if the SHM is zero bytes in size and pWal->writeLock\n<line29>** is zero, which prevents the SHM from growing */\n<line30>testcase( page0!=0 );\n<line31>}\n<line32>assert( page0!=0 || pWal->writeLock==0 );\n<line33>/* If the first page of the wal-index has been mapped, try to read the\n<line34>** wal-index header immediately, without holding any lock. This usually\n<line35>** works, but may fail if the wal-index header is corrupt or currently\n<line36>** being modified by another thread or process.\n<line37>*/\n<line38>badHdr = (page0 ? walIndexTryHdr(pWal, pChanged) : 1);\n<line39>/* If the first attempt failed, it might have been due to a race\n<line40>** with a writer.  So get a WRITE lock and try again.\n<line41>*/\n<line42>if( badHdr ){\n<line43>if( pWal->bShmUnreliable==0 && (pWal->readOnly & WAL_SHM_RDONLY) ){\n<line44>if( SQLITE_OK==(rc = walLockShared(pWal, WAL_WRITE_LOCK)) ){\n<line45>walUnlockShared(pWal, WAL_WRITE_LOCK);\n<line46>rc = SQLITE_READONLY_RECOVERY;\n<line47>}\n<line48>}else{\n<line49>int bWriteLock = pWal->writeLock;\n<line50>if( bWriteLock\n<line51>|| SQLITE_OK==(rc = walLockExclusive(pWal, WAL_WRITE_LOCK, 1))\n<line52>){\n<line53>/* If the write-lock was just obtained, set writeLock to 2 instead of\n<line54>** the usual 1. This causes walIndexPage() to behave as if the\n<line55>** write-lock were held (so that it allocates new pages as required),\n<line56>** and walHandleException() to unlock the write-lock if a SEH exception\n<line57>** is thrown.  */\n<line58>if( !bWriteLock ) pWal->writeLock = 2;\n<line59>if( SQLITE_OK==(rc = walIndexPage(pWal, 0, &page0)) ){\n<line60>badHdr = walIndexTryHdr(pWal, pChanged);\n<line61>if( badHdr ){\n<line62>/* If the wal-index header is still malformed even while holding\n<line63>** a WRITE lock, it can only mean that the header is corrupted and\n<line64>** needs to be reconstructed.  So run recovery to do exactly that.\n<line65>** Disable blocking locks first.  */\n<line66>walDisableBlocking(pWal);\n<line67>rc = walIndexRecover(pWal);\n<line68>*pChanged = 1;\n<line69>}\n<line70>}\n<line71>if( bWriteLock==0 ){\n<line72>pWal->writeLock = 0;\n<line73>walUnlockExclusive(pWal, WAL_WRITE_LOCK, 1);\n<line74>}\n<line75>}\n<line76>}\n<line77>}\n<line78>/* If the header is read successfully, check the version number to make\n<line79>** sure the wal-index was not constructed with some future format that\n<line80>** this version of SQLite cannot understand.\n<line81>*/\n<line82>if( badHdr==0 && pWal->hdr.iVersion!=WALINDEX_MAX_VERSION ){\n<line83>rc = SQLITE_CANTOPEN_BKPT;\n<line84>}\n<line85>if( pWal->bShmUnreliable ){\n<line86>if( rc!=SQLITE_OK ){\n<line87>walIndexClose(pWal, 0);\n<line88>pWal->bShmUnreliable = 0;\n<line89>assert( pWal->nWiData>0 && pWal->apWiData[0]==0 );\n<line90>/* walIndexRecover() might have returned SHORT_READ if a concurrent\n<line91>** writer truncated the WAL out from under it.  If that happens, it\n<line92>** indicates that a writer has fixed the SHM file for us, so retry */\n<line93>if( rc==SQLITE_IOERR_SHORT_READ ) rc = WAL_RETRY;\n<line94>}\n<line95>pWal->exclusiveMode = WAL_NORMAL_MODE;\n<line96>}\n<line97>return rc;\n<line98>}
----------------------------------------
Function: walBeginShmUnreliable
Content: <line0>static int walBeginShmUnreliable(Wal *pWal, int *pChanged){\n<line1>i64 szWal;                      /* Size of wal file on disk in bytes */\n<line2>i64 iOffset;                    /* Current offset when reading wal file */\n<line3>u8 aBuf[WAL_HDRSIZE];           /* Buffer to load WAL header into */\n<line4>u8 *aFrame = 0;                 /* Malloc'd buffer to load entire frame */\n<line5>int szFrame;                    /* Number of bytes in buffer aFrame[] */\n<line6>u8 *aData;                      /* Pointer to data part of aFrame buffer */\n<line7>volatile void *pDummy;          /* Dummy argument for xShmMap */\n<line8>int rc;                         /* Return code */\n<line9>u32 aSaveCksum[2];              /* Saved copy of pWal->hdr.aFrameCksum */\n<line10>assert( pWal->bShmUnreliable );\n<line11>assert( pWal->readOnly & WAL_SHM_RDONLY );\n<line12>assert( pWal->nWiData>0 && pWal->apWiData[0] );\n<line13>/* Take WAL_READ_LOCK(0). This has the effect of preventing any\n<line14>** writers from running a checkpoint, but does not stop them\n<line15>** from running recovery.  */\n<line16>rc = walLockShared(pWal, WAL_READ_LOCK(0));\n<line17>if( rc!=SQLITE_OK ){\n<line18>if( rc==SQLITE_BUSY ) rc = WAL_RETRY;\n<line19>goto begin_unreliable_shm_out;\n<line20>}\n<line21>pWal->readLock = 0;\n<line22>/* Check to see if a separate writer has attached to the shared-memory area,\n<line23>** thus making the shared-memory "reliable" again.  Do this by invoking\n<line24>** the xShmMap() routine of the VFS and looking to see if the return\n<line25>** is SQLITE_READONLY instead of SQLITE_READONLY_CANTINIT.\n<line26>**\n<line27>** If the shared-memory is now "reliable" return WAL_RETRY, which will\n<line28>** cause the heap-memory WAL-index to be discarded and the actual\n<line29>** shared memory to be used in its place.\n<line30>**\n<line31>** This step is important because, even though this connection is holding\n<line32>** the WAL_READ_LOCK(0) which prevents a checkpoint, a writer might\n<line33>** have already checkpointed the WAL file and, while the current\n<line34>** is active, wrap the WAL and start overwriting frames that this\n<line35>** process wants to use.\n<line36>**\n<line37>** Once sqlite3OsShmMap() has been called for an sqlite3_file and has\n<line38>** returned any SQLITE_READONLY value, it must return only SQLITE_READONLY\n<line39>** or SQLITE_READONLY_CANTINIT or some error for all subsequent invocations,\n<line40>** even if some external agent does a "chmod" to make the shared-memory\n<line41>** writable by us, until sqlite3OsShmUnmap() has been called.\n<line42>** This is a requirement on the VFS implementation.\n<line43>*/\n<line44>rc = sqlite3OsShmMap(pWal->pDbFd, 0, WALINDEX_PGSZ, 0, &pDummy);\n<line45>assert( rc!=SQLITE_OK ); /* SQLITE_OK not possible for read-only connection */\n<line46>if( rc!=SQLITE_READONLY_CANTINIT ){\n<line47>rc = (rc==SQLITE_READONLY ? WAL_RETRY : rc);\n<line48>goto begin_unreliable_shm_out;\n<line49>}\n<line50>/* We reach this point only if the real shared-memory is still unreliable.\n<line51>** Assume the in-memory WAL-index substitute is correct and load it\n<line52>** into pWal->hdr.\n<line53>*/\n<line54>memcpy(&pWal->hdr, (void*)walIndexHdr(pWal), sizeof(WalIndexHdr));\n<line55>/* Make sure some writer hasn't come in and changed the WAL file out\n<line56>** from under us, then disconnected, while we were not looking.\n<line57>*/\n<line58>rc = sqlite3OsFileSize(pWal->pWalFd, &szWal);\n<line59>if( rc!=SQLITE_OK ){\n<line60>goto begin_unreliable_shm_out;\n<line61>}\n<line62>if( szWal<WAL_HDRSIZE ){\n<line63>/* If the wal file is too small to contain a wal-header and the\n<line64>** wal-index header has mxFrame==0, then it must be safe to proceed\n<line65>** reading the database file only. However, the page cache cannot\n<line66>** be trusted, as a read/write connection may have connected, written\n<line67>** the db, run a checkpoint, truncated the wal file and disconnected\n<line68>** since this client's last read transaction.  */\n<line69>*pChanged = 1;\n<line70>rc = (pWal->hdr.mxFrame==0 ? SQLITE_OK : WAL_RETRY);\n<line71>goto begin_unreliable_shm_out;\n<line72>}\n<line73>/* Check the salt keys at the start of the wal file still match. */\n<line74>rc = sqlite3OsRead(pWal->pWalFd, aBuf, WAL_HDRSIZE, 0);\n<line75>if( rc!=SQLITE_OK ){\n<line76>goto begin_unreliable_shm_out;\n<line77>}\n<line78>if( memcmp(&pWal->hdr.aSalt, &aBuf[16], 8) ){\n<line79>/* Some writer has wrapped the WAL file while we were not looking.\n<line80>** Return WAL_RETRY which will cause the in-memory WAL-index to be\n<line81>** rebuilt. */\n<line82>rc = WAL_RETRY;\n<line83>goto begin_unreliable_shm_out;\n<line84>}\n<line85>/* Allocate a buffer to read frames into */\n<line86>assert( (pWal->szPage & (pWal->szPage-1))==0 );\n<line87>assert( pWal->szPage>=512 && pWal->szPage<=65536 );\n<line88>szFrame = pWal->szPage + WAL_FRAME_HDRSIZE;\n<line89>aFrame = (u8 *)sqlite3_malloc64(szFrame);\n<line90>if( aFrame==0 ){\n<line91>rc = SQLITE_NOMEM_BKPT;\n<line92>goto begin_unreliable_shm_out;\n<line93>}\n<line94>aData = &aFrame[WAL_FRAME_HDRSIZE];\n<line95>/* Check to see if a complete transaction has been appended to the\n<line96>** wal file since the heap-memory wal-index was created. If so, the\n<line97>** heap-memory wal-index is discarded and WAL_RETRY returned to\n<line98>** the caller.  */\n<line99>aSaveCksum[0] = pWal->hdr.aFrameCksum[0];\n<line100>aSaveCksum[1] = pWal->hdr.aFrameCksum[1];\n<line101>for(iOffset=walFrameOffset(pWal->hdr.mxFrame+1, pWal->szPage);\n<line102>iOffset+szFrame<=szWal;\n<line103>iOffset+=szFrame\n<line104>){\n<line105>u32 pgno;                   /* Database page number for frame */\n<line106>u32 nTruncate;              /* dbsize field from frame header */\n<line107>/* Read and decode the next log frame. */\n<line108>rc = sqlite3OsRead(pWal->pWalFd, aFrame, szFrame, iOffset);\n<line109>if( rc!=SQLITE_OK ) break;\n<line110>if( !walDecodeFrame(pWal, &pgno, &nTruncate, aData, aFrame) ) break;\n<line111>/* If nTruncate is non-zero, then a complete transaction has been\n<line112>** appended to this wal file. Set rc to WAL_RETRY and break out of\n<line113>** the loop.  */\n<line114>if( nTruncate ){\n<line115>rc = WAL_RETRY;\n<line116>break;\n<line117>}\n<line118>}\n<line119>pWal->hdr.aFrameCksum[0] = aSaveCksum[0];\n<line120>pWal->hdr.aFrameCksum[1] = aSaveCksum[1];\n<line121>begin_unreliable_shm_out:\n<line122>sqlite3_free(aFrame);\n<line123>if( rc!=SQLITE_OK ){\n<line124>int i;\n<line125>for(i=0; i<pWal->nWiData; i++){\n<line126>sqlite3_free((void*)pWal->apWiData[i]);\n<line127>pWal->apWiData[i] = 0;\n<line128>}\n<line129>pWal->bShmUnreliable = 0;\n<line130>sqlite3WalEndReadTransaction(pWal);\n<line131>*pChanged = 1;\n<line132>}\n<line133>return rc;\n<line134>}
----------------------------------------
Function: walTryBeginRead
Content: <line0>static int walTryBeginRead(Wal *pWal, int *pChanged, int useWal, int *pCnt){\n<line1>volatile WalCkptInfo *pInfo;    /* Checkpoint information in wal-index */\n<line2>int rc = SQLITE_OK;             /* Return code  */\n<line3>#ifdef SQLITE_ENABLE_SETLK_TIMEOUT\n<line4>int nBlockTmout = 0;\n<line5>#endif\n<line6>assert( pWal->readLock<0 );     /* Not currently locked */\n<line7>/* useWal may only be set for read/write connections */\n<line8>assert( (pWal->readOnly & WAL_SHM_RDONLY)==0 || useWal==0 );\n<line9>/* Take steps to avoid spinning forever if there is a protocol error.\n<line10>**\n<line11>** Circumstances that cause a RETRY should only last for the briefest\n<line12>** instances of time.  No I/O or other system calls are done while the\n<line13>** locks are held, so the locks should not be held for very long. But\n<line14>** if we are unlucky, another process that is holding a lock might get\n<line15>** paged out or take a page-fault that is time-consuming to resolve,\n<line16>** during the few nanoseconds that it is holding the lock.  In that case,\n<line17>** it might take longer than normal for the lock to free.\n<line18>**\n<line19>** After 5 RETRYs, we begin calling sqlite3OsSleep().  The first few\n<line20>** calls to sqlite3OsSleep() have a delay of 1 microsecond.  Really this\n<line21>** is more of a scheduler yield than an actual delay.  But on the 10th\n<line22>** an subsequent retries, the delays start becoming longer and longer,\n<line23>** so that on the 100th (and last) RETRY we delay for 323 milliseconds.\n<line24>** The total delay time before giving up is less than 10 seconds.\n<line25>*/\n<line26>(*pCnt)++;\n<line27>if( *pCnt>5 ){\n<line28>int nDelay = 1;                      /* Pause time in microseconds */\n<line29>int cnt = (*pCnt & ~WAL_RETRY_BLOCKED_MASK);\n<line30>if( cnt>WAL_RETRY_PROTOCOL_LIMIT ){\n<line31>VVA_ONLY( pWal->lockError = 1; )\n<line32>return SQLITE_PROTOCOL;\n<line33>}\n<line34>if( *pCnt>=10 ) nDelay = (cnt-9)*(cnt-9)*39;\n<line35>#ifdef SQLITE_ENABLE_SETLK_TIMEOUT\n<line36>/* In SQLITE_ENABLE_SETLK_TIMEOUT builds, configure the file-descriptor\n<line37>** to block for locks for approximately nDelay us. This affects three\n<line38>** locks: (a) the shared lock taken on the DMS slot in os_unix.c (if\n<line39>** using os_unix.c), (b) the WRITER lock taken in walIndexReadHdr() if the\n<line40>** first attempted read fails, and (c) the shared lock taken on the\n<line41>** read-mark.\n<line42>**\n<line43>** If the previous call failed due to an SQLITE_BUSY_TIMEOUT error,\n<line44>** then sleep for the minimum of 1us. The previous call already provided\n<line45>** an extra delay while it was blocking on the lock.\n<line46>*/\n<line47>nBlockTmout = (nDelay+998) / 1000;\n<line48>if( !useWal && walEnableBlockingMs(pWal, nBlockTmout) ){\n<line49>if( *pCnt & WAL_RETRY_BLOCKED_MASK ) nDelay = 1;\n<line50>}\n<line51>#endif\n<line52>sqlite3OsSleep(pWal->pVfs, nDelay);\n<line53>*pCnt &= ~WAL_RETRY_BLOCKED_MASK;\n<line54>}\n<line55>if( !useWal ){\n<line56>assert( rc==SQLITE_OK );\n<line57>if( pWal->bShmUnreliable==0 ){\n<line58>rc = walIndexReadHdr(pWal, pChanged);\n<line59>}\n<line60>#ifdef SQLITE_ENABLE_SETLK_TIMEOUT\n<line61>if( rc==SQLITE_BUSY_TIMEOUT ){\n<line62>rc = SQLITE_BUSY;\n<line63>*pCnt |= WAL_RETRY_BLOCKED_MASK;\n<line64>}\n<line65>#endif\n<line66>if( rc==SQLITE_BUSY ){\n<line67>/* If there is not a recovery running in another thread or process\n<line68>** then convert BUSY errors to WAL_RETRY.  If recovery is known to\n<line69>** be running, convert BUSY to BUSY_RECOVERY.  There is a race here\n<line70>** which might cause WAL_RETRY to be returned even if BUSY_RECOVERY\n<line71>** would be technically correct.  But the race is benign since with\n<line72>** WAL_RETRY this routine will be called again and will probably be\n<line73>** right on the second iteration.\n<line74>*/\n<line75>(void)walEnableBlocking(pWal);\n<line76>if( pWal->apWiData[0]==0 ){\n<line77>/* This branch is taken when the xShmMap() method returns SQLITE_BUSY.\n<line78>** We assume this is a transient condition, so return WAL_RETRY. The\n<line79>** xShmMap() implementation used by the default unix and win32 VFS\n<line80>** modules may return SQLITE_BUSY due to a race condition in the\n<line81>** code that determines whether or not the shared-memory region\n<line82>** must be zeroed before the requested page is returned.\n<line83>*/\n<line84>rc = WAL_RETRY;\n<line85>}else if( SQLITE_OK==(rc = walLockShared(pWal, WAL_RECOVER_LOCK)) ){\n<line86>walUnlockShared(pWal, WAL_RECOVER_LOCK);\n<line87>rc = WAL_RETRY;\n<line88>}else if( rc==SQLITE_BUSY ){\n<line89>rc = SQLITE_BUSY_RECOVERY;\n<line90>}\n<line91>}\n<line92>walDisableBlocking(pWal);\n<line93>if( rc!=SQLITE_OK ){\n<line94>return rc;\n<line95>}\n<line96>else if( pWal->bShmUnreliable ){\n<line97>return walBeginShmUnreliable(pWal, pChanged);\n<line98>}\n<line99>}\n<line100>assert( pWal->nWiData>0 );\n<line101>assert( pWal->apWiData[0]!=0 );\n<line102>pInfo = walCkptInfo(pWal);\n<line103>SEH_INJECT_FAULT;\n<line104>{\n<line105>u32 mxReadMark;               /* Largest aReadMark[] value */\n<line106>int mxI;                      /* Index of largest aReadMark[] value */\n<line107>int i;                        /* Loop counter */\n<line108>u32 mxFrame;                  /* Wal frame to lock to */\n<line109>if( !useWal && AtomicLoad(&pInfo->nBackfill)==pWal->hdr.mxFrame\n<line110>#ifdef SQLITE_ENABLE_SNAPSHOT\n<line111>&& ((pWal->bGetSnapshot==0 && pWal->pSnapshot==0) || pWal->hdr.mxFrame==0)\n<line112>#endif\n<line113>){\n<line114>/* The WAL has been completely backfilled (or it is empty).\n<line115>** and can be safely ignored.\n<line116>*/\n<line117>rc = walLockShared(pWal, WAL_READ_LOCK(0));\n<line118>walShmBarrier(pWal);\n<line119>if( rc==SQLITE_OK ){\n<line120>if( memcmp((void *)walIndexHdr(pWal), &pWal->hdr,sizeof(WalIndexHdr)) ){\n<line121>/* It is not safe to allow the reader to continue here if frames\n<line122>** may have been appended to the log before READ_LOCK(0) was obtained.\n<line123>** When holding READ_LOCK(0), the reader ignores the entire log file,\n<line124>** which implies that the database file contains a trustworthy\n<line125>** snapshot. Since holding READ_LOCK(0) prevents a checkpoint from\n<line126>** happening, this is usually correct.\n<line127>**\n<line128>** However, if frames have been appended to the log (or if the log\n<line129>** is wrapped and written for that matter) before the READ_LOCK(0)\n<line130>** is obtained, that is not necessarily true. A checkpointer may\n<line131>** have started to backfill the appended frames but crashed before\n<line132>** it finished. Leaving a corrupt image in the database file.\n<line133>*/\n<line134>walUnlockShared(pWal, WAL_READ_LOCK(0));\n<line135>return WAL_RETRY;\n<line136>}\n<line137>pWal->readLock = 0;\n<line138>return SQLITE_OK;\n<line139>}else if( rc!=SQLITE_BUSY ){\n<line140>return rc;\n<line141>}\n<line142>}\n<line143>/* If we get this far, it means that the reader will want to use\n<line144>** the WAL to get at content from recent commits.  The job now is\n<line145>** to select one of the aReadMark[] entries that is closest to\n<line146>** but not exceeding pWal->hdr.mxFrame and lock that entry.\n<line147>*/\n<line148>mxReadMark = 0;\n<line149>mxI = 0;\n<line150>mxFrame = pWal->hdr.mxFrame;\n<line151>#ifdef SQLITE_ENABLE_SNAPSHOT\n<line152>if( pWal->pSnapshot && pWal->pSnapshot->mxFrame<mxFrame ){\n<line153>mxFrame = pWal->pSnapshot->mxFrame;\n<line154>}\n<line155>#endif\n<line156>for(i=1; i<WAL_NREADER; i++){\n<line157>u32 thisMark = AtomicLoad(pInfo->aReadMark+i); SEH_INJECT_FAULT;\n<line158>if( mxReadMark<=thisMark && thisMark<=mxFrame ){\n<line159>assert( thisMark!=READMARK_NOT_USED );\n<line160>mxReadMark = thisMark;\n<line161>mxI = i;\n<line162>}\n<line163>}\n<line164>if( (pWal->readOnly & WAL_SHM_RDONLY)==0\n<line165>&& (mxReadMark<mxFrame || mxI==0)\n<line166>){\n<line167>for(i=1; i<WAL_NREADER; i++){\n<line168>rc = walLockExclusive(pWal, WAL_READ_LOCK(i), 1);\n<line169>if( rc==SQLITE_OK ){\n<line170>AtomicStore(pInfo->aReadMark+i,mxFrame);\n<line171>mxReadMark = mxFrame;\n<line172>mxI = i;\n<line173>walUnlockExclusive(pWal, WAL_READ_LOCK(i), 1);\n<line174>break;\n<line175>}else if( rc!=SQLITE_BUSY ){\n<line176>return rc;\n<line177>}\n<line178>}\n<line179>}\n<line180>if( mxI==0 ){\n<line181>assert( rc==SQLITE_BUSY || (pWal->readOnly & WAL_SHM_RDONLY)!=0 );\n<line182>return rc==SQLITE_BUSY ? WAL_RETRY : SQLITE_READONLY_CANTINIT;\n<line183>}\n<line184>(void)walEnableBlockingMs(pWal, nBlockTmout);\n<line185>rc = walLockShared(pWal, WAL_READ_LOCK(mxI));\n<line186>walDisableBlocking(pWal);\n<line187>if( rc ){\n<line188>#ifdef SQLITE_ENABLE_SETLK_TIMEOUT\n<line189>if( rc==SQLITE_BUSY_TIMEOUT ){\n<line190>*pCnt |= WAL_RETRY_BLOCKED_MASK;\n<line191>}\n<line192>#else\n<line193>assert( rc!=SQLITE_BUSY_TIMEOUT );\n<line194>#endif\n<line195>assert((rc&0xFF)!=SQLITE_BUSY||rc==SQLITE_BUSY||rc==SQLITE_BUSY_TIMEOUT);\n<line196>return (rc&0xFF)==SQLITE_BUSY ? WAL_RETRY : rc;\n<line197>}\n<line198>/* Now that the read-lock has been obtained, check that neither the\n<line199>** value in the aReadMark[] array or the contents of the wal-index\n<line200>** header have changed.\n<line201>**\n<line202>** It is necessary to check that the wal-index header did not change\n<line203>** between the time it was read and when the shared-lock was obtained\n<line204>** on WAL_READ_LOCK(mxI) was obtained to account for the possibility\n<line205>** that the log file may have been wrapped by a writer, or that frames\n<line206>** that occur later in the log than pWal->hdr.mxFrame may have been\n<line207>** copied into the database by a checkpointer. If either of these things\n<line208>** happened, then reading the database with the current value of\n<line209>** pWal->hdr.mxFrame risks reading a corrupted snapshot. So, retry\n<line210>** instead.\n<line211>**\n<line212>** Before checking that the live wal-index header has not changed\n<line213>** since it was read, set Wal.minFrame to the first frame in the wal\n<line214>** file that has not yet been checkpointed. This client will not need\n<line215>** to read any frames earlier than minFrame from the wal file - they\n<line216>** can be safely read directly from the database file.\n<line217>**\n<line218>** Because a ShmBarrier() call is made between taking the copy of\n<line219>** nBackfill and checking that the wal-header in shared-memory still\n<line220>** matches the one cached in pWal->hdr, it is guaranteed that the\n<line221>** checkpointer that set nBackfill was not working with a wal-index\n<line222>** header newer than that cached in pWal->hdr. If it were, that could\n<line223>** cause a problem. The checkpointer could omit to checkpoint\n<line224>** a version of page X that lies before pWal->minFrame (call that version\n<line225>** A) on the basis that there is a newer version (version B) of the same\n<line226>** page later in the wal file. But if version B happens to like past\n<line227>** frame pWal->hdr.mxFrame - then the client would incorrectly assume\n<line228>** that it can read version A from the database file. However, since\n<line229>** we can guarantee that the checkpointer that set nBackfill could not\n<line230>** see any pages past pWal->hdr.mxFrame, this problem does not come up.\n<line231>*/\n<line232>pWal->minFrame = AtomicLoad(&pInfo->nBackfill)+1; SEH_INJECT_FAULT;\n<line233>walShmBarrier(pWal);\n<line234>if( AtomicLoad(pInfo->aReadMark+mxI)!=mxReadMark\n<line235>|| memcmp((void *)walIndexHdr(pWal), &pWal->hdr, sizeof(WalIndexHdr))\n<line236>){\n<line237>walUnlockShared(pWal, WAL_READ_LOCK(mxI));\n<line238>return WAL_RETRY;\n<line239>}else{\n<line240>assert( mxReadMark<=pWal->hdr.mxFrame );\n<line241>pWal->readLock = (i16)mxI;\n<line242>}\n<line243>}\n<line244>return rc;\n<line245>}
----------------------------------------
Function: walBeginReadTransaction
Content: <line0>static int walBeginReadTransaction(Wal *pWal, int *pChanged){\n<line1>int rc;                         /* Return code */\n<line2>int cnt = 0;                    /* Number of TryBeginRead attempts */\n<line3>#ifdef SQLITE_ENABLE_SNAPSHOT\n<line4>int ckptLock = 0;\n<line5>int bChanged = 0;\n<line6>WalIndexHdr *pSnapshot = pWal->pSnapshot;\n<line7>#endif\n<line8>assert( pWal->ckptLock==0 );\n<line9>assert( pWal->nSehTry>0 );\n<line10>#ifdef SQLITE_ENABLE_SNAPSHOT\n<line11>if( pSnapshot ){\n<line12>if( memcmp(pSnapshot, &pWal->hdr, sizeof(WalIndexHdr))!=0 ){\n<line13>bChanged = 1;\n<line14>}\n<line15>/* It is possible that there is a checkpointer thread running\n<line16>** concurrent with this code. If this is the case, it may be that the\n<line17>** checkpointer has already determined that it will checkpoint\n<line18>** snapshot X, where X is later in the wal file than pSnapshot, but\n<line19>** has not yet set the pInfo->nBackfillAttempted variable to indicate\n<line20>** its intent. To avoid the race condition this leads to, ensure that\n<line21>** there is no checkpointer process by taking a shared CKPT lock\n<line22>** before checking pInfo->nBackfillAttempted.  */\n<line23>(void)walEnableBlocking(pWal);\n<line24>rc = walLockShared(pWal, WAL_CKPT_LOCK);\n<line25>walDisableBlocking(pWal);\n<line26>if( rc!=SQLITE_OK ){\n<line27>return rc;\n<line28>}\n<line29>ckptLock = 1;\n<line30>}\n<line31>#endif\n<line32>do{\n<line33>rc = walTryBeginRead(pWal, pChanged, 0, &cnt);\n<line34>}while( rc==WAL_RETRY );\n<line35>testcase( (rc&0xff)==SQLITE_BUSY );\n<line36>testcase( (rc&0xff)==SQLITE_IOERR );\n<line37>testcase( rc==SQLITE_PROTOCOL );\n<line38>testcase( rc==SQLITE_OK );\n<line39>#ifdef SQLITE_ENABLE_SNAPSHOT\n<line40>if( rc==SQLITE_OK ){\n<line41>if( pSnapshot && memcmp(pSnapshot, &pWal->hdr, sizeof(WalIndexHdr))!=0 ){\n<line42>/* At this point the client has a lock on an aReadMark[] slot holding\n<line43>** a value equal to or smaller than pSnapshot->mxFrame, but pWal->hdr\n<line44>** is populated with the wal-index header corresponding to the head\n<line45>** of the wal file. Verify that pSnapshot is still valid before\n<line46>** continuing.  Reasons why pSnapshot might no longer be valid:\n<line47>**\n<line48>**    (1)  The WAL file has been reset since the snapshot was taken.\n<line49>**         In this case, the salt will have changed.\n<line50>**\n<line51>**    (2)  A checkpoint as been attempted that wrote frames past\n<line52>**         pSnapshot->mxFrame into the database file.  Note that the\n<line53>**         checkpoint need not have completed for this to cause problems.\n<line54>*/\n<line55>volatile WalCkptInfo *pInfo = walCkptInfo(pWal);\n<line56>assert( pWal->readLock>0 || pWal->hdr.mxFrame==0 );\n<line57>assert( pInfo->aReadMark[pWal->readLock]<=pSnapshot->mxFrame );\n<line58>/* Check that the wal file has not been wrapped. Assuming that it has\n<line59>** not, also check that no checkpointer has attempted to checkpoint any\n<line60>** frames beyond pSnapshot->mxFrame. If either of these conditions are\n<line61>** true, return SQLITE_ERROR_SNAPSHOT. Otherwise, overwrite pWal->hdr\n<line62>** with *pSnapshot and set *pChanged as appropriate for opening the\n<line63>** snapshot.  */\n<line64>if( !memcmp(pSnapshot->aSalt, pWal->hdr.aSalt, sizeof(pWal->hdr.aSalt))\n<line65>&& pSnapshot->mxFrame>=pInfo->nBackfillAttempted\n<line66>){\n<line67>assert( pWal->readLock>0 );\n<line68>memcpy(&pWal->hdr, pSnapshot, sizeof(WalIndexHdr));\n<line69>*pChanged = bChanged;\n<line70>}else{\n<line71>rc = SQLITE_ERROR_SNAPSHOT;\n<line72>}\n<line73>/* A client using a non-current snapshot may not ignore any frames\n<line74>** from the start of the wal file. This is because, for a system\n<line75>** where (minFrame < iSnapshot < maxFrame), a checkpointer may\n<line76>** have omitted to checkpoint a frame earlier than minFrame in\n<line77>** the file because there exists a frame after iSnapshot that\n<line78>** is the same database page.  */\n<line79>pWal->minFrame = 1;\n<line80>if( rc!=SQLITE_OK ){\n<line81>sqlite3WalEndReadTransaction(pWal);\n<line82>}\n<line83>}\n<line84>}\n<line85>/* Release the shared CKPT lock obtained above. */\n<line86>if( ckptLock ){\n<line87>assert( pSnapshot );\n<line88>walUnlockShared(pWal, WAL_CKPT_LOCK);\n<line89>}\n<line90>#endif\n<line91>return rc;\n<line92>}
----------------------------------------
Function: walFindFrame
Content: <line0>static int walFindFrame(\n<line1>Wal *pWal,                      /* WAL handle */\n<line2>Pgno pgno,                      /* Database page number to read data for */\n<line3>u32 *piRead                     /* OUT: Frame number (or zero) */\n<line4>){\n<line5>u32 iRead = 0;                  /* If !=0, WAL frame to return data from */\n<line6>u32 iLast = pWal->hdr.mxFrame;  /* Last page in WAL for this reader */\n<line7>int iHash;                      /* Used to loop through N hash tables */\n<line8>int iMinHash;\n<line9>/* This routine is only be called from within a read transaction. */\n<line10>assert( pWal->readLock>=0 || pWal->lockError );\n<line11>/* If the "last page" field of the wal-index header snapshot is 0, then\n<line12>** no data will be read from the wal under any circumstances. Return early\n<line13>** in this case as an optimization.  Likewise, if pWal->readLock==0,\n<line14>** then the WAL is ignored by the reader so return early, as if the\n<line15>** WAL were empty.\n<line16>*/\n<line17>if( iLast==0 || (pWal->readLock==0 && pWal->bShmUnreliable==0) ){\n<line18>*piRead = 0;\n<line19>return SQLITE_OK;\n<line20>}\n<line21>/* Search the hash table or tables for an entry matching page number\n<line22>** pgno. Each iteration of the following for() loop searches one\n<line23>** hash table (each hash table indexes up to HASHTABLE_NPAGE frames).\n<line24>**\n<line25>** This code might run concurrently to the code in walIndexAppend()\n<line26>** that adds entries to the wal-index (and possibly to this hash\n<line27>** table). This means the value just read from the hash\n<line28>** slot (aHash[iKey]) may have been added before or after the\n<line29>** current read transaction was opened. Values added after the\n<line30>** read transaction was opened may have been written incorrectly -\n<line31>** i.e. these slots may contain garbage data. However, we assume\n<line32>** that any slots written before the current read transaction was\n<line33>** opened remain unmodified.\n<line34>**\n<line35>** For the reasons above, the if(...) condition featured in the inner\n<line36>** loop of the following block is more stringent that would be required\n<line37>** if we had exclusive access to the hash-table:\n<line38>**\n<line39>**   (aPgno[iFrame]==pgno):\n<line40>**     This condition filters out normal hash-table collisions.\n<line41>**\n<line42>**   (iFrame<=iLast):\n<line43>**     This condition filters out entries that were added to the hash\n<line44>**     table after the current read-transaction had started.\n<line45>*/\n<line46>iMinHash = walFramePage(pWal->minFrame);\n<line47>for(iHash=walFramePage(iLast); iHash>=iMinHash; iHash--){\n<line48>WalHashLoc sLoc;              /* Hash table location */\n<line49>int iKey;                     /* Hash slot index */\n<line50>int nCollide;                 /* Number of hash collisions remaining */\n<line51>int rc;                       /* Error code */\n<line52>u32 iH;\n<line53>rc = walHashGet(pWal, iHash, &sLoc);\n<line54>if( rc!=SQLITE_OK ){\n<line55>return rc;\n<line56>}\n<line57>nCollide = HASHTABLE_NSLOT;\n<line58>iKey = walHash(pgno);\n<line59>SEH_INJECT_FAULT;\n<line60>while( (iH = AtomicLoad(&sLoc.aHash[iKey]))!=0 ){\n<line61>u32 iFrame = iH + sLoc.iZero;\n<line62>if( iFrame<=iLast && iFrame>=pWal->minFrame && sLoc.aPgno[iH-1]==pgno ){\n<line63>assert( iFrame>iRead || CORRUPT_DB );\n<line64>iRead = iFrame;\n<line65>}\n<line66>if( (nCollide--)==0 ){\n<line67>*piRead = 0;\n<line68>return SQLITE_CORRUPT_BKPT;\n<line69>}\n<line70>iKey = walNextHash(iKey);\n<line71>}\n<line72>if( iRead ) break;\n<line73>}\n<line74>#ifdef SQLITE_ENABLE_EXPENSIVE_ASSERT\n<line75>/* If expensive assert() statements are available, do a linear search\n<line76>** of the wal-index file content. Make sure the results agree with the\n<line77>** result obtained using the hash indexes above.  */\n<line78>{\n<line79>u32 iRead2 = 0;\n<line80>u32 iTest;\n<line81>assert( pWal->bShmUnreliable || pWal->minFrame>0 );\n<line82>for(iTest=iLast; iTest>=pWal->minFrame && iTest>0; iTest--){\n<line83>if( walFramePgno(pWal, iTest)==pgno ){\n<line84>iRead2 = iTest;\n<line85>break;\n<line86>}\n<line87>}\n<line88>assert( iRead==iRead2 );\n<line89>}\n<line90>#endif\n<line91>*piRead = iRead;\n<line92>return SQLITE_OK;\n<line93>}
----------------------------------------
Function: walRestartLog
Content: <line0>static int walRestartLog(Wal *pWal){\n<line1>int rc = SQLITE_OK;\n<line2>int cnt;\n<line3>if( pWal->readLock==0 ){\n<line4>volatile WalCkptInfo *pInfo = walCkptInfo(pWal);\n<line5>assert( pInfo->nBackfill==pWal->hdr.mxFrame );\n<line6>if( pInfo->nBackfill>0 ){\n<line7>u32 salt1;\n<line8>sqlite3_randomness(4, &salt1);\n<line9>rc = walLockExclusive(pWal, WAL_READ_LOCK(1), WAL_NREADER-1);\n<line10>if( rc==SQLITE_OK ){\n<line11>/* If all readers are using WAL_READ_LOCK(0) (in other words if no\n<line12>** readers are currently using the WAL), then the transactions\n<line13>** frames will overwrite the start of the existing log. Update the\n<line14>** wal-index header to reflect this.\n<line15>**\n<line16>** In theory it would be Ok to update the cache of the header only\n<line17>** at this point. But updating the actual wal-index header is also\n<line18>** safe and means there is no special case for sqlite3WalUndo()\n<line19>** to handle if this transaction is rolled back.  */\n<line20>walRestartHdr(pWal, salt1);\n<line21>walUnlockExclusive(pWal, WAL_READ_LOCK(1), WAL_NREADER-1);\n<line22>}else if( rc!=SQLITE_BUSY ){\n<line23>return rc;\n<line24>}\n<line25>}\n<line26>walUnlockShared(pWal, WAL_READ_LOCK(0));\n<line27>pWal->readLock = -1;\n<line28>cnt = 0;\n<line29>do{\n<line30>int notUsed;\n<line31>rc = walTryBeginRead(pWal, &notUsed, 1, &cnt);\n<line32>}while( rc==WAL_RETRY );\n<line33>assert( (rc&0xff)!=SQLITE_BUSY ); /* BUSY not possible when useWal==1 */\n<line34>testcase( (rc&0xff)==SQLITE_IOERR );\n<line35>testcase( rc==SQLITE_PROTOCOL );\n<line36>testcase( rc==SQLITE_OK );\n<line37>}\n<line38>return rc;\n<line39>}
----------------------------------------
Function: walWriteToLog
Content: <line0>static int walWriteToLog(\n<line1>WalWriter *p,              /* WAL to write to */\n<line2>void *pContent,            /* Content to be written */\n<line3>int iAmt,                  /* Number of bytes to write */\n<line4>sqlite3_int64 iOffset      /* Start writing at this offset */\n<line5>){\n<line6>int rc;\n<line7>if( iOffset<p->iSyncPoint && iOffset+iAmt>=p->iSyncPoint ){\n<line8>int iFirstAmt = (int)(p->iSyncPoint - iOffset);\n<line9>rc = sqlite3OsWrite(p->pFd, pContent, iFirstAmt, iOffset);\n<line10>if( rc ) return rc;\n<line11>iOffset += iFirstAmt;\n<line12>iAmt -= iFirstAmt;\n<line13>pContent = (void*)(iFirstAmt + (char*)pContent);\n<line14>assert( WAL_SYNC_FLAGS(p->syncFlags)!=0 );\n<line15>rc = sqlite3OsSync(p->pFd, WAL_SYNC_FLAGS(p->syncFlags));\n<line16>if( iAmt==0 || rc ) return rc;\n<line17>}\n<line18>rc = sqlite3OsWrite(p->pFd, pContent, iAmt, iOffset);\n<line19>return rc;\n<line20>}
----------------------------------------
Function: walWriteOneFrame
Content: <line0>static int walWriteOneFrame(\n<line1>WalWriter *p,               /* Where to write the frame */\n<line2>PgHdr *pPage,               /* The page of the frame to be written */\n<line3>int nTruncate,              /* The commit flag.  Usually 0.  >0 for commit */\n<line4>sqlite3_int64 iOffset       /* Byte offset at which to write */\n<line5>){\n<line6>int rc;                         /* Result code from subfunctions */\n<line7>void *pData;                    /* Data actually written */\n<line8>u8 aFrame[WAL_FRAME_HDRSIZE];   /* Buffer to assemble frame-header in */\n<line9>pData = pPage->pData;\n<line10>walEncodeFrame(p->pWal, pPage->pgno, nTruncate, pData, aFrame);\n<line11>rc = walWriteToLog(p, aFrame, sizeof(aFrame), iOffset);\n<line12>if( rc ) return rc;\n<line13>/* Write the page data */\n<line14>rc = walWriteToLog(p, pData, p->szPage, iOffset+sizeof(aFrame));\n<line15>return rc;\n<line16>}
----------------------------------------
Function: walRewriteChecksums
Content: <line0>static int walRewriteChecksums(Wal *pWal, u32 iLast){\n<line1>const int szPage = pWal->szPage;/* Database page size */\n<line2>int rc = SQLITE_OK;             /* Return code */\n<line3>u8 *aBuf;                       /* Buffer to load data from wal file into */\n<line4>u8 aFrame[WAL_FRAME_HDRSIZE];   /* Buffer to assemble frame-headers in */\n<line5>u32 iRead;                      /* Next frame to read from wal file */\n<line6>i64 iCksumOff;\n<line7>aBuf = sqlite3_malloc(szPage + WAL_FRAME_HDRSIZE);\n<line8>if( aBuf==0 ) return SQLITE_NOMEM_BKPT;\n<line9>/* Find the checksum values to use as input for the recalculating the\n<line10>** first checksum. If the first frame is frame 1 (implying that the current\n<line11>** transaction restarted the wal file), these values must be read from the\n<line12>** wal-file header. Otherwise, read them from the frame header of the\n<line13>** previous frame.  */\n<line14>assert( pWal->iReCksum>0 );\n<line15>if( pWal->iReCksum==1 ){\n<line16>iCksumOff = 24;\n<line17>}else{\n<line18>iCksumOff = walFrameOffset(pWal->iReCksum-1, szPage) + 16;\n<line19>}\n<line20>rc = sqlite3OsRead(pWal->pWalFd, aBuf, sizeof(u32)*2, iCksumOff);\n<line21>pWal->hdr.aFrameCksum[0] = sqlite3Get4byte(aBuf);\n<line22>pWal->hdr.aFrameCksum[1] = sqlite3Get4byte(&aBuf[sizeof(u32)]);\n<line23>iRead = pWal->iReCksum;\n<line24>pWal->iReCksum = 0;\n<line25>for(; rc==SQLITE_OK && iRead<=iLast; iRead++){\n<line26>i64 iOff = walFrameOffset(iRead, szPage);\n<line27>rc = sqlite3OsRead(pWal->pWalFd, aBuf, szPage+WAL_FRAME_HDRSIZE, iOff);\n<line28>if( rc==SQLITE_OK ){\n<line29>u32 iPgno, nDbSize;\n<line30>iPgno = sqlite3Get4byte(aBuf);\n<line31>nDbSize = sqlite3Get4byte(&aBuf[4]);\n<line32>walEncodeFrame(pWal, iPgno, nDbSize, &aBuf[WAL_FRAME_HDRSIZE], aFrame);\n<line33>rc = sqlite3OsWrite(pWal->pWalFd, aFrame, sizeof(aFrame), iOff);\n<line34>}\n<line35>}\n<line36>sqlite3_free(aBuf);\n<line37>return rc;\n<line38>}
----------------------------------------
Function: walFrames
Content: <line0>static int walFrames(\n<line1>Wal *pWal,                      /* Wal handle to write to */\n<line2>int szPage,                     /* Database page-size in bytes */\n<line3>PgHdr *pList,                   /* List of dirty pages to write */\n<line4>Pgno nTruncate,                 /* Database size after this commit */\n<line5>int isCommit,                   /* True if this is a commit */\n<line6>int sync_flags                  /* Flags to pass to OsSync() (or 0) */\n<line7>){\n<line8>int rc;                         /* Used to catch return codes */\n<line9>u32 iFrame;                     /* Next frame address */\n<line10>PgHdr *p;                       /* Iterator to run through pList with. */\n<line11>PgHdr *pLast = 0;               /* Last frame in list */\n<line12>int nExtra = 0;                 /* Number of extra copies of last page */\n<line13>int szFrame;                    /* The size of a single frame */\n<line14>i64 iOffset;                    /* Next byte to write in WAL file */\n<line15>WalWriter w;                    /* The writer */\n<line16>u32 iFirst = 0;                 /* First frame that may be overwritten */\n<line17>WalIndexHdr *pLive;             /* Pointer to shared header */\n<line18>assert( pList );\n<line19>assert( pWal->writeLock );\n<line20>/* If this frame set completes a transaction, then nTruncate>0.  If\n<line21>** nTruncate==0 then this frame set does not complete the transaction. */\n<line22>assert( (isCommit!=0)==(nTruncate!=0) );\n<line23>#if defined(SQLITE_TEST) && defined(SQLITE_DEBUG)\n<line24>{ int cnt; for(cnt=0, p=pList; p; p=p->pDirty, cnt++){}\n<line25>WALTRACE(("WAL%p: frame write begin. %d frames. mxFrame=%d. %s\n",\n<line26>pWal, cnt, pWal->hdr.mxFrame, isCommit ? "Commit" : "Spill"));\n<line27>}\n<line28>#endif\n<line29>pLive = (WalIndexHdr*)walIndexHdr(pWal);\n<line30>if( memcmp(&pWal->hdr, (void *)pLive, sizeof(WalIndexHdr))!=0 ){\n<line31>iFirst = pLive->mxFrame+1;\n<line32>}\n<line33>/* See if it is possible to write these frames into the start of the\n<line34>** log file, instead of appending to it at pWal->hdr.mxFrame.\n<line35>*/\n<line36>if( SQLITE_OK!=(rc = walRestartLog(pWal)) ){\n<line37>return rc;\n<line38>}\n<line39>/* If this is the first frame written into the log, write the WAL\n<line40>** header to the start of the WAL file. See comments at the top of\n<line41>** this source file for a description of the WAL header format.\n<line42>*/\n<line43>iFrame = pWal->hdr.mxFrame;\n<line44>if( iFrame==0 ){\n<line45>u8 aWalHdr[WAL_HDRSIZE];      /* Buffer to assemble wal-header in */\n<line46>u32 aCksum[2];                /* Checksum for wal-header */\n<line47>sqlite3Put4byte(&aWalHdr[0], (WAL_MAGIC | SQLITE_BIGENDIAN));\n<line48>sqlite3Put4byte(&aWalHdr[4], WAL_MAX_VERSION);\n<line49>sqlite3Put4byte(&aWalHdr[8], szPage);\n<line50>sqlite3Put4byte(&aWalHdr[12], pWal->nCkpt);\n<line51>if( pWal->nCkpt==0 ) sqlite3_randomness(8, pWal->hdr.aSalt);\n<line52>memcpy(&aWalHdr[16], pWal->hdr.aSalt, 8);\n<line53>walChecksumBytes(1, aWalHdr, WAL_HDRSIZE-2*4, 0, aCksum);\n<line54>sqlite3Put4byte(&aWalHdr[24], aCksum[0]);\n<line55>sqlite3Put4byte(&aWalHdr[28], aCksum[1]);\n<line56>pWal->szPage = szPage;\n<line57>pWal->hdr.bigEndCksum = SQLITE_BIGENDIAN;\n<line58>pWal->hdr.aFrameCksum[0] = aCksum[0];\n<line59>pWal->hdr.aFrameCksum[1] = aCksum[1];\n<line60>pWal->truncateOnCommit = 1;\n<line61>rc = sqlite3OsWrite(pWal->pWalFd, aWalHdr, sizeof(aWalHdr), 0);\n<line62>WALTRACE(("WAL%p: wal-header write %s\n", pWal, rc ? "failed" : "ok"));\n<line63>if( rc!=SQLITE_OK ){\n<line64>return rc;\n<line65>}\n<line66>/* Sync the header (unless SQLITE_IOCAP_SEQUENTIAL is true or unless\n<line67>** all syncing is turned off by PRAGMA synchronous=OFF).  Otherwise\n<line68>** an out-of-order write following a WAL restart could result in\n<line69>** database corruption.  See the ticket:\n<line70>**\n<line71>**     https://sqlite.org/src/info/ff5be73dee\n<line72>*/\n<line73>if( pWal->syncHeader ){\n<line74>rc = sqlite3OsSync(pWal->pWalFd, CKPT_SYNC_FLAGS(sync_flags));\n<line75>if( rc ) return rc;\n<line76>}\n<line77>}\n<line78>if( (int)pWal->szPage!=szPage ){\n<line79>return SQLITE_CORRUPT_BKPT;  /* TH3 test case: cov1/corrupt155.test */\n<line80>}\n<line81>/* Setup information needed to write frames into the WAL */\n<line82>w.pWal = pWal;\n<line83>w.pFd = pWal->pWalFd;\n<line84>w.iSyncPoint = 0;\n<line85>w.syncFlags = sync_flags;\n<line86>w.szPage = szPage;\n<line87>iOffset = walFrameOffset(iFrame+1, szPage);\n<line88>szFrame = szPage + WAL_FRAME_HDRSIZE;\n<line89>/* Write all frames into the log file exactly once */\n<line90>for(p=pList; p; p=p->pDirty){\n<line91>int nDbSize;   /* 0 normally.  Positive == commit flag */\n<line92>/* Check if this page has already been written into the wal file by\n<line93>** the current transaction. If so, overwrite the existing frame and\n<line94>** set Wal.writeLock to WAL_WRITELOCK_RECKSUM - indicating that\n<line95>** checksums must be recomputed when the transaction is committed.  */\n<line96>if( iFirst && (p->pDirty || isCommit==0) ){\n<line97>u32 iWrite = 0;\n<line98>VVA_ONLY(rc =) walFindFrame(pWal, p->pgno, &iWrite);\n<line99>assert( rc==SQLITE_OK || iWrite==0 );\n<line100>if( iWrite>=iFirst ){\n<line101>i64 iOff = walFrameOffset(iWrite, szPage) + WAL_FRAME_HDRSIZE;\n<line102>void *pData;\n<line103>if( pWal->iReCksum==0 || iWrite<pWal->iReCksum ){\n<line104>pWal->iReCksum = iWrite;\n<line105>}\n<line106>pData = p->pData;\n<line107>rc = sqlite3OsWrite(pWal->pWalFd, pData, szPage, iOff);\n<line108>if( rc ) return rc;\n<line109>p->flags &= ~PGHDR_WAL_APPEND;\n<line110>continue;\n<line111>}\n<line112>}\n<line113>iFrame++;\n<line114>assert( iOffset==walFrameOffset(iFrame, szPage) );\n<line115>nDbSize = (isCommit && p->pDirty==0) ? nTruncate : 0;\n<line116>rc = walWriteOneFrame(&w, p, nDbSize, iOffset);\n<line117>if( rc ) return rc;\n<line118>pLast = p;\n<line119>iOffset += szFrame;\n<line120>p->flags |= PGHDR_WAL_APPEND;\n<line121>}\n<line122>/* Recalculate checksums within the wal file if required. */\n<line123>if( isCommit && pWal->iReCksum ){\n<line124>rc = walRewriteChecksums(pWal, iFrame);\n<line125>if( rc ) return rc;\n<line126>}\n<line127>/* If this is the end of a transaction, then we might need to pad\n<line128>** the transaction and/or sync the WAL file.\n<line129>**\n<line130>** Padding and syncing only occur if this set of frames complete a\n<line131>** transaction and if PRAGMA synchronous=FULL.  If synchronous==NORMAL\n<line132>** or synchronous==OFF, then no padding or syncing are needed.\n<line133>**\n<line134>** If SQLITE_IOCAP_POWERSAFE_OVERWRITE is defined, then padding is not\n<line135>** needed and only the sync is done.  If padding is needed, then the\n<line136>** final frame is repeated (with its commit mark) until the next sector\n<line137>** boundary is crossed.  Only the part of the WAL prior to the last\n<line138>** sector boundary is synced; the part of the last frame that extends\n<line139>** past the sector boundary is written after the sync.\n<line140>*/\n<line141>if( isCommit && WAL_SYNC_FLAGS(sync_flags)!=0 ){\n<line142>int bSync = 1;\n<line143>if( pWal->padToSectorBoundary ){\n<line144>int sectorSize = sqlite3SectorSize(pWal->pWalFd);\n<line145>w.iSyncPoint = ((iOffset+sectorSize-1)/sectorSize)*sectorSize;\n<line146>bSync = (w.iSyncPoint==iOffset);\n<line147>testcase( bSync );\n<line148>while( iOffset<w.iSyncPoint ){\n<line149>rc = walWriteOneFrame(&w, pLast, nTruncate, iOffset);\n<line150>if( rc ) return rc;\n<line151>iOffset += szFrame;\n<line152>nExtra++;\n<line153>assert( pLast!=0 );\n<line154>}\n<line155>}\n<line156>if( bSync ){\n<line157>assert( rc==SQLITE_OK );\n<line158>rc = sqlite3OsSync(w.pFd, WAL_SYNC_FLAGS(sync_flags));\n<line159>}\n<line160>}\n<line161>/* If this frame set completes the first transaction in the WAL and\n<line162>** if PRAGMA journal_size_limit is set, then truncate the WAL to the\n<line163>** journal size limit, if possible.\n<line164>*/\n<line165>if( isCommit && pWal->truncateOnCommit && pWal->mxWalSize>=0 ){\n<line166>i64 sz = pWal->mxWalSize;\n<line167>if( walFrameOffset(iFrame+nExtra+1, szPage)>pWal->mxWalSize ){\n<line168>sz = walFrameOffset(iFrame+nExtra+1, szPage);\n<line169>}\n<line170>walLimitSize(pWal, sz);\n<line171>pWal->truncateOnCommit = 0;\n<line172>}\n<line173>/* Append data to the wal-index. It is not necessary to lock the\n<line174>** wal-index to do this as the SQLITE_SHM_WRITE lock held on the wal-index\n<line175>** guarantees that there are no other writers, and no data that may\n<line176>** be in use by existing readers is being overwritten.\n<line177>*/\n<line178>iFrame = pWal->hdr.mxFrame;\n<line179>for(p=pList; p && rc==SQLITE_OK; p=p->pDirty){\n<line180>if( (p->flags & PGHDR_WAL_APPEND)==0 ) continue;\n<line181>iFrame++;\n<line182>rc = walIndexAppend(pWal, iFrame, p->pgno);\n<line183>}\n<line184>assert( pLast!=0 || nExtra==0 );\n<line185>while( rc==SQLITE_OK && nExtra>0 ){\n<line186>iFrame++;\n<line187>nExtra--;\n<line188>rc = walIndexAppend(pWal, iFrame, pLast->pgno);\n<line189>}\n<line190>if( rc==SQLITE_OK ){\n<line191>/* Update the private copy of the header. */\n<line192>pWal->hdr.szPage = (u16)((szPage&0xff00) | (szPage>>16));\n<line193>testcase( szPage<=32768 );\n<line194>testcase( szPage>=65536 );\n<line195>pWal->hdr.mxFrame = iFrame;\n<line196>if( isCommit ){\n<line197>pWal->hdr.iChange++;\n<line198>pWal->hdr.nPage = nTruncate;\n<line199>}\n<line200>/* If this is a commit, update the wal-index header too. */\n<line201>if( isCommit ){\n<line202>walIndexWriteHdr(pWal);\n<line203>pWal->iCallback = iFrame;\n<line204>}\n<line205>}\n<line206>WALTRACE(("WAL%p: frame write %s\n", pWal, rc ? "failed" : "ok"));\n<line207>return rc;\n<line208>}
----------------------------------------
Function: lockBtreeMutex
Content: <line0>static void lockBtreeMutex(Btree *p){\n<line1>assert( p->locked==0 );\n<line2>assert( sqlite3_mutex_notheld(p->pBt->mutex) );\n<line3>assert( sqlite3_mutex_held(p->db->mutex) );\n<line4>sqlite3_mutex_enter(p->pBt->mutex);\n<line5>p->pBt->db = p->db;\n<line6>p->locked = 1;\n<line7>}
----------------------------------------
Function: unlockBtreeMutex
Content: <line0>static void SQLITE_NOINLINE unlockBtreeMutex(Btree *p){\n<line1>BtShared *pBt = p->pBt;\n<line2>assert( p->locked==1 );\n<line3>assert( sqlite3_mutex_held(pBt->mutex) );\n<line4>assert( sqlite3_mutex_held(p->db->mutex) );\n<line5>assert( p->db==pBt->db );\n<line6>sqlite3_mutex_leave(pBt->mutex);\n<line7>p->locked = 0;\n<line8>}
----------------------------------------
Function: btreeLockCarefully
Content: <line0>static void SQLITE_NOINLINE btreeLockCarefully(Btree *p){\n<line1>Btree *pLater;\n<line2>/* In most cases, we should be able to acquire the lock we\n<line3>** want without having to go through the ascending lock\n<line4>** procedure that follows.  Just be sure not to block.\n<line5>*/\n<line6>if( sqlite3_mutex_try(p->pBt->mutex)==SQLITE_OK ){\n<line7>p->pBt->db = p->db;\n<line8>p->locked = 1;\n<line9>return;\n<line10>}\n<line11>/* To avoid deadlock, first release all locks with a larger\n<line12>** BtShared address.  Then acquire our lock.  Then reacquire\n<line13>** the other BtShared locks that we used to hold in ascending\n<line14>** order.\n<line15>*/\n<line16>for(pLater=p->pNext; pLater; pLater=pLater->pNext){\n<line17>assert( pLater->sharable );\n<line18>assert( pLater->pNext==0 || pLater->pNext->pBt>pLater->pBt );\n<line19>assert( !pLater->locked || pLater->wantToLock>0 );\n<line20>if( pLater->locked ){\n<line21>unlockBtreeMutex(pLater);\n<line22>}\n<line23>}\n<line24>lockBtreeMutex(p);\n<line25>for(pLater=p->pNext; pLater; pLater=pLater->pNext){\n<line26>if( pLater->wantToLock ){\n<line27>lockBtreeMutex(pLater);\n<line28>}\n<line29>}\n<line30>}
----------------------------------------
Function: btreeEnterAll
Content: <line0>static void SQLITE_NOINLINE btreeEnterAll(sqlite3 *db){\n<line1>int i;\n<line2>u8 skipOk = 1;\n<line3>Btree *p;\n<line4>assert( sqlite3_mutex_held(db->mutex) );\n<line5>for(i=0; i<db->nDb; i++){\n<line6>p = db->aDb[i].pBt;\n<line7>if( p && p->sharable ){\n<line8>sqlite3BtreeEnter(p);\n<line9>skipOk = 0;\n<line10>}\n<line11>}\n<line12>db->noSharedCache = skipOk;\n<line13>}
----------------------------------------
Function: btreeLeaveAll
Content: <line0>static void SQLITE_NOINLINE btreeLeaveAll(sqlite3 *db){\n<line1>int i;\n<line2>Btree *p;\n<line3>assert( sqlite3_mutex_held(db->mutex) );\n<line4>for(i=0; i<db->nDb; i++){\n<line5>p = db->aDb[i].pBt;\n<line6>if( p ) sqlite3BtreeLeave(p);\n<line7>}\n<line8>}
----------------------------------------
Function: sqlite3_enable_shared_cache
Content: <line0>SQLITE_API int sqlite3_enable_shared_cache(int enable){\n<line1>sqlite3GlobalConfig.sharedCacheEnabled = enable;\n<line2>return SQLITE_OK;\n<line3>}
----------------------------------------
Function: querySharedCacheTableLock
Content: <line0>static int querySharedCacheTableLock(Btree *p, Pgno iTab, u8 eLock){\n<line1>BtShared *pBt = p->pBt;\n<line2>BtLock *pIter;\n<line3>assert( sqlite3BtreeHoldsMutex(p) );\n<line4>assert( eLock==READ_LOCK || eLock==WRITE_LOCK );\n<line5>assert( p->db!=0 );\n<line6>assert( !(p->db->flags&SQLITE_ReadUncommit)||eLock==WRITE_LOCK||iTab==1 );\n<line7>/* If requesting a write-lock, then the Btree must have an open write\n<line8>** transaction on this file. And, obviously, for this to be so there\n<line9>** must be an open write transaction on the file itself.\n<line10>*/\n<line11>assert( eLock==READ_LOCK || (p==pBt->pWriter && p->inTrans==TRANS_WRITE) );\n<line12>assert( eLock==READ_LOCK || pBt->inTransaction==TRANS_WRITE );\n<line13>/* This routine is a no-op if the shared-cache is not enabled */\n<line14>if( !p->sharable ){\n<line15>return SQLITE_OK;\n<line16>}\n<line17>/* If some other connection is holding an exclusive lock, the\n<line18>** requested lock may not be obtained.\n<line19>*/\n<line20>if( pBt->pWriter!=p && (pBt->btsFlags & BTS_EXCLUSIVE)!=0 ){\n<line21>sqlite3ConnectionBlocked(p->db, pBt->pWriter->db);\n<line22>return SQLITE_LOCKED_SHAREDCACHE;\n<line23>}\n<line24>for(pIter=pBt->pLock; pIter; pIter=pIter->pNext){\n<line25>/* The condition (pIter->eLock!=eLock) in the following if(...)\n<line26>** statement is a simplification of:\n<line27>**\n<line28>**   (eLock==WRITE_LOCK || pIter->eLock==WRITE_LOCK)\n<line29>**\n<line30>** since we know that if eLock==WRITE_LOCK, then no other connection\n<line31>** may hold a WRITE_LOCK on any table in this file (since there can\n<line32>** only be a single writer).\n<line33>*/\n<line34>assert( pIter->eLock==READ_LOCK || pIter->eLock==WRITE_LOCK );\n<line35>assert( eLock==READ_LOCK || pIter->pBtree==p || pIter->eLock==READ_LOCK);\n<line36>if( pIter->pBtree!=p && pIter->iTable==iTab && pIter->eLock!=eLock ){\n<line37>sqlite3ConnectionBlocked(p->db, pIter->pBtree->db);\n<line38>if( eLock==WRITE_LOCK ){\n<line39>assert( p==pBt->pWriter );\n<line40>pBt->btsFlags |= BTS_PENDING;\n<line41>}\n<line42>return SQLITE_LOCKED_SHAREDCACHE;\n<line43>}\n<line44>}\n<line45>return SQLITE_OK;\n<line46>}
----------------------------------------
Function: setSharedCacheTableLock
Content: <line0>static int setSharedCacheTableLock(Btree *p, Pgno iTable, u8 eLock){\n<line1>BtShared *pBt = p->pBt;\n<line2>BtLock *pLock = 0;\n<line3>BtLock *pIter;\n<line4>SHARED_LOCK_TRACE(pBt,"setLock", iTable, eLock);\n<line5>assert( sqlite3BtreeHoldsMutex(p) );\n<line6>assert( eLock==READ_LOCK || eLock==WRITE_LOCK );\n<line7>assert( p->db!=0 );\n<line8>/* A connection with the read-uncommitted flag set will never try to\n<line9>** obtain a read-lock using this function. The only read-lock obtained\n<line10>** by a connection in read-uncommitted mode is on the sqlite_schema\n<line11>** table, and that lock is obtained in BtreeBeginTrans().  */\n<line12>assert( 0==(p->db->flags&SQLITE_ReadUncommit) || eLock==WRITE_LOCK );\n<line13>/* This function should only be called on a sharable b-tree after it\n<line14>** has been determined that no other b-tree holds a conflicting lock.  */\n<line15>assert( p->sharable );\n<line16>assert( SQLITE_OK==querySharedCacheTableLock(p, iTable, eLock) );\n<line17>/* First search the list for an existing lock on this table. */\n<line18>for(pIter=pBt->pLock; pIter; pIter=pIter->pNext){\n<line19>if( pIter->iTable==iTable && pIter->pBtree==p ){\n<line20>pLock = pIter;\n<line21>break;\n<line22>}\n<line23>}\n<line24>/* If the above search did not find a BtLock struct associating Btree p\n<line25>** with table iTable, allocate one and link it into the list.\n<line26>*/\n<line27>if( !pLock ){\n<line28>pLock = (BtLock *)sqlite3MallocZero(sizeof(BtLock));\n<line29>if( !pLock ){\n<line30>return SQLITE_NOMEM_BKPT;\n<line31>}\n<line32>pLock->iTable = iTable;\n<line33>pLock->pBtree = p;\n<line34>pLock->pNext = pBt->pLock;\n<line35>pBt->pLock = pLock;\n<line36>}\n<line37>/* Set the BtLock.eLock variable to the maximum of the current lock\n<line38>** and the requested lock. This means if a write-lock was already held\n<line39>** and a read-lock requested, we don't incorrectly downgrade the lock.\n<line40>*/\n<line41>assert( WRITE_LOCK>READ_LOCK );\n<line42>if( eLock>pLock->eLock ){\n<line43>pLock->eLock = eLock;\n<line44>}\n<line45>return SQLITE_OK;\n<line46>}
----------------------------------------
Function: clearAllSharedCacheTableLocks
Content: <line0>static void clearAllSharedCacheTableLocks(Btree *p){\n<line1>BtShared *pBt = p->pBt;\n<line2>BtLock **ppIter = &pBt->pLock;\n<line3>assert( sqlite3BtreeHoldsMutex(p) );\n<line4>assert( p->sharable || 0==*ppIter );\n<line5>assert( p->inTrans>0 );\n<line6>SHARED_LOCK_TRACE(pBt, "clearAllLocks", 0, 0);\n<line7>while( *ppIter ){\n<line8>BtLock *pLock = *ppIter;\n<line9>assert( (pBt->btsFlags & BTS_EXCLUSIVE)==0 || pBt->pWriter==pLock->pBtree );\n<line10>assert( pLock->pBtree->inTrans>=pLock->eLock );\n<line11>if( pLock->pBtree==p ){\n<line12>*ppIter = pLock->pNext;\n<line13>assert( pLock->iTable!=1 || pLock==&p->lock );\n<line14>if( pLock->iTable!=1 ){\n<line15>sqlite3_free(pLock);\n<line16>}\n<line17>}else{\n<line18>ppIter = &pLock->pNext;\n<line19>}\n<line20>}\n<line21>assert( (pBt->btsFlags & BTS_PENDING)==0 || pBt->pWriter );\n<line22>if( pBt->pWriter==p ){\n<line23>pBt->pWriter = 0;\n<line24>pBt->btsFlags &= ~(BTS_EXCLUSIVE|BTS_PENDING);\n<line25>}else if( pBt->nTransaction==2 ){\n<line26>/* This function is called when Btree p is concluding its\n<line27>** transaction. If there currently exists a writer, and p is not\n<line28>** that writer, then the number of locks held by connections other\n<line29>** than the writer must be about to drop to zero. In this case\n<line30>** set the BTS_PENDING flag to 0.\n<line31>**\n<line32>** If there is not currently a writer, then BTS_PENDING must\n<line33>** be zero already. So this next line is harmless in that case.\n<line34>*/\n<line35>pBt->btsFlags &= ~BTS_PENDING;\n<line36>}\n<line37>}
----------------------------------------
Function: downgradeAllSharedCacheTableLocks
Content: <line0>static void downgradeAllSharedCacheTableLocks(Btree *p){\n<line1>BtShared *pBt = p->pBt;\n<line2>SHARED_LOCK_TRACE(pBt, "downgradeLocks", 0, 0);\n<line3>if( pBt->pWriter==p ){\n<line4>BtLock *pLock;\n<line5>pBt->pWriter = 0;\n<line6>pBt->btsFlags &= ~(BTS_EXCLUSIVE|BTS_PENDING);\n<line7>for(pLock=pBt->pLock; pLock; pLock=pLock->pNext){\n<line8>assert( pLock->eLock==READ_LOCK || pLock->pBtree==p );\n<line9>pLock->eLock = READ_LOCK;\n<line10>}\n<line11>}\n<line12>}
----------------------------------------
Function: invalidateAllOverflowCache
Content: <line0>static void invalidateAllOverflowCache(BtShared *pBt){\n<line1>BtCursor *p;\n<line2>assert( sqlite3_mutex_held(pBt->mutex) );\n<line3>for(p=pBt->pCursor; p; p=p->pNext){\n<line4>invalidateOverflowCache(p);\n<line5>}\n<line6>}
----------------------------------------
Function: invalidateIncrblobCursors
Content: <line0>static void invalidateIncrblobCursors(\n<line1>Btree *pBtree,          /* The database file to check */\n<line2>Pgno pgnoRoot,          /* The table that might be changing */\n<line3>i64 iRow,               /* The rowid that might be changing */\n<line4>int isClearTable        /* True if all rows are being deleted */\n<line5>){\n<line6>BtCursor *p;\n<line7>assert( pBtree->hasIncrblobCur );\n<line8>assert( sqlite3BtreeHoldsMutex(pBtree) );\n<line9>pBtree->hasIncrblobCur = 0;\n<line10>for(p=pBtree->pBt->pCursor; p; p=p->pNext){\n<line11>if( (p->curFlags & BTCF_Incrblob)!=0 ){\n<line12>pBtree->hasIncrblobCur = 1;\n<line13>if( p->pgnoRoot==pgnoRoot && (isClearTable || p->info.nKey==iRow) ){\n<line14>p->eState = CURSOR_INVALID;\n<line15>}\n<line16>}\n<line17>}\n<line18>}
----------------------------------------
Function: btreeSetHasContent
Content: <line0>static int btreeSetHasContent(BtShared *pBt, Pgno pgno){\n<line1>int rc = SQLITE_OK;\n<line2>if( !pBt->pHasContent ){\n<line3>assert( pgno<=pBt->nPage );\n<line4>pBt->pHasContent = sqlite3BitvecCreate(pBt->nPage);\n<line5>if( !pBt->pHasContent ){\n<line6>rc = SQLITE_NOMEM_BKPT;\n<line7>}\n<line8>}\n<line9>if( rc==SQLITE_OK && pgno<=sqlite3BitvecSize(pBt->pHasContent) ){\n<line10>rc = sqlite3BitvecSet(pBt->pHasContent, pgno);\n<line11>}\n<line12>return rc;\n<line13>}
----------------------------------------
Function: btreeGetHasContent
Content: <line0>static int btreeGetHasContent(BtShared *pBt, Pgno pgno){\n<line1>Bitvec *p = pBt->pHasContent;\n<line2>return p && (pgno>sqlite3BitvecSize(p) || sqlite3BitvecTestNotNull(p, pgno));\n<line3>}
----------------------------------------
Function: btreeClearHasContent
Content: <line0>static void btreeClearHasContent(BtShared *pBt){\n<line1>sqlite3BitvecDestroy(pBt->pHasContent);\n<line2>pBt->pHasContent = 0;\n<line3>}
----------------------------------------
Function: btreeReleaseAllCursorPages
Content: <line0>static void btreeReleaseAllCursorPages(BtCursor *pCur){\n<line1>int i;\n<line2>if( pCur->iPage>=0 ){\n<line3>for(i=0; i<pCur->iPage; i++){\n<line4>releasePageNotNull(pCur->apPage[i]);\n<line5>}\n<line6>releasePageNotNull(pCur->pPage);\n<line7>pCur->iPage = -1;\n<line8>}\n<line9>}
----------------------------------------
Function: saveCursorKey
Content: <line0>static int saveCursorKey(BtCursor *pCur){\n<line1>int rc = SQLITE_OK;\n<line2>assert( CURSOR_VALID==pCur->eState );\n<line3>assert( 0==pCur->pKey );\n<line4>assert( cursorHoldsMutex(pCur) );\n<line5>if( pCur->curIntKey ){\n<line6>/* Only the rowid is required for a table btree */\n<line7>pCur->nKey = sqlite3BtreeIntegerKey(pCur);\n<line8>}else{\n<line9>/* For an index btree, save the complete key content. It is possible\n<line10>** that the current key is corrupt. In that case, it is possible that\n<line11>** the sqlite3VdbeRecordUnpack() function may overread the buffer by\n<line12>** up to the size of 1 varint plus 1 8-byte value when the cursor\n<line13>** position is restored. Hence the 17 bytes of padding allocated\n<line14>** below. */\n<line15>void *pKey;\n<line16>pCur->nKey = sqlite3BtreePayloadSize(pCur);\n<line17>pKey = sqlite3Malloc( ((i64)pCur->nKey) + 9 + 8 );\n<line18>if( pKey ){\n<line19>rc = sqlite3BtreePayload(pCur, 0, (int)pCur->nKey, pKey);\n<line20>if( rc==SQLITE_OK ){\n<line21>memset(((u8*)pKey)+pCur->nKey, 0, 9+8);\n<line22>pCur->pKey = pKey;\n<line23>}else{\n<line24>sqlite3_free(pKey);\n<line25>}\n<line26>}else{\n<line27>rc = SQLITE_NOMEM_BKPT;\n<line28>}\n<line29>}\n<line30>assert( !pCur->curIntKey || !pCur->pKey );\n<line31>return rc;\n<line32>}
----------------------------------------
Function: saveCursorPosition
Content: <line0>static int saveCursorPosition(BtCursor *pCur){\n<line1>int rc;\n<line2>assert( CURSOR_VALID==pCur->eState || CURSOR_SKIPNEXT==pCur->eState );\n<line3>assert( 0==pCur->pKey );\n<line4>assert( cursorHoldsMutex(pCur) );\n<line5>if( pCur->curFlags & BTCF_Pinned ){\n<line6>return SQLITE_CONSTRAINT_PINNED;\n<line7>}\n<line8>if( pCur->eState==CURSOR_SKIPNEXT ){\n<line9>pCur->eState = CURSOR_VALID;\n<line10>}else{\n<line11>pCur->skipNext = 0;\n<line12>}\n<line13>rc = saveCursorKey(pCur);\n<line14>if( rc==SQLITE_OK ){\n<line15>btreeReleaseAllCursorPages(pCur);\n<line16>pCur->eState = CURSOR_REQUIRESEEK;\n<line17>}\n<line18>pCur->curFlags &= ~(BTCF_ValidNKey|BTCF_ValidOvfl|BTCF_AtLast);\n<line19>return rc;\n<line20>}
----------------------------------------
Function: saveAllCursors
Content: <line0>static int saveAllCursors(BtShared *pBt, Pgno iRoot, BtCursor *pExcept){\n<line1>BtCursor *p;\n<line2>assert( sqlite3_mutex_held(pBt->mutex) );\n<line3>assert( pExcept==0 || pExcept->pBt==pBt );\n<line4>for(p=pBt->pCursor; p; p=p->pNext){\n<line5>if( p!=pExcept && (0==iRoot || p->pgnoRoot==iRoot) ) break;\n<line6>}\n<line7>if( p ) return saveCursorsOnList(p, iRoot, pExcept);\n<line8>if( pExcept ) pExcept->curFlags &= ~BTCF_Multiple;\n<line9>return SQLITE_OK;\n<line10>}
----------------------------------------
Function: saveCursorsOnList
Content: <line0>static int SQLITE_NOINLINE saveCursorsOnList(\n<line1>BtCursor *p,         /* The first cursor that needs saving */\n<line2>Pgno iRoot,          /* Only save cursor with this iRoot. Save all if zero */\n<line3>BtCursor *pExcept    /* Do not save this cursor */\n<line4>){\n<line5>do{\n<line6>if( p!=pExcept && (0==iRoot || p->pgnoRoot==iRoot) ){\n<line7>if( p->eState==CURSOR_VALID || p->eState==CURSOR_SKIPNEXT ){\n<line8>int rc = saveCursorPosition(p);\n<line9>if( SQLITE_OK!=rc ){\n<line10>return rc;\n<line11>}\n<line12>}else{\n<line13>testcase( p->iPage>=0 );\n<line14>btreeReleaseAllCursorPages(p);\n<line15>}\n<line16>}\n<line17>p = p->pNext;\n<line18>}while( p );\n<line19>return SQLITE_OK;\n<line20>}
----------------------------------------
Function: btreeMoveto
Content: <line0>static int btreeMoveto(\n<line1>BtCursor *pCur,     /* Cursor open on the btree to be searched */\n<line2>const void *pKey,   /* Packed key if the btree is an index */\n<line3>i64 nKey,           /* Integer key for tables.  Size of pKey for indices */\n<line4>int bias,           /* Bias search to the high end */\n<line5>int *pRes           /* Write search results here */\n<line6>){\n<line7>int rc;                    /* Status code */\n<line8>UnpackedRecord *pIdxKey;   /* Unpacked index key */\n<line9>if( pKey ){\n<line10>KeyInfo *pKeyInfo = pCur->pKeyInfo;\n<line11>assert( nKey==(i64)(int)nKey );\n<line12>pIdxKey = sqlite3VdbeAllocUnpackedRecord(pKeyInfo);\n<line13>if( pIdxKey==0 ) return SQLITE_NOMEM_BKPT;\n<line14>sqlite3VdbeRecordUnpack((int)nKey, pKey, pIdxKey);\n<line15>if( pIdxKey->nField==0 || pIdxKey->nField>pKeyInfo->nAllField ){\n<line16>rc = SQLITE_CORRUPT_BKPT;\n<line17>}else{\n<line18>rc = sqlite3BtreeIndexMoveto(pCur, pIdxKey, pRes);\n<line19>}\n<line20>sqlite3DbFree(pCur->pKeyInfo->db, pIdxKey);\n<line21>}else{\n<line22>pIdxKey = 0;\n<line23>rc = sqlite3BtreeTableMoveto(pCur, nKey, bias, pRes);\n<line24>}\n<line25>return rc;\n<line26>}
----------------------------------------
Function: btreeRestoreCursorPosition
Content: <line0>static int btreeRestoreCursorPosition(BtCursor *pCur){\n<line1>int rc;\n<line2>int skipNext = 0;\n<line3>assert( cursorOwnsBtShared(pCur) );\n<line4>assert( pCur->eState>=CURSOR_REQUIRESEEK );\n<line5>if( pCur->eState==CURSOR_FAULT ){\n<line6>return pCur->skipNext;\n<line7>}\n<line8>pCur->eState = CURSOR_INVALID;\n<line9>if( sqlite3FaultSim(410) ){\n<line10>rc = SQLITE_IOERR;\n<line11>}else{\n<line12>rc = btreeMoveto(pCur, pCur->pKey, pCur->nKey, 0, &skipNext);\n<line13>}\n<line14>if( rc==SQLITE_OK ){\n<line15>sqlite3_free(pCur->pKey);\n<line16>pCur->pKey = 0;\n<line17>assert( pCur->eState==CURSOR_VALID || pCur->eState==CURSOR_INVALID );\n<line18>if( skipNext ) pCur->skipNext = skipNext;\n<line19>if( pCur->skipNext && pCur->eState==CURSOR_VALID ){\n<line20>pCur->eState = CURSOR_SKIPNEXT;\n<line21>}\n<line22>}\n<line23>return rc;\n<line24>}
----------------------------------------
Function: ptrmapPageno
Content: <line0>static Pgno ptrmapPageno(BtShared *pBt, Pgno pgno){\n<line1>int nPagesPerMapPage;\n<line2>Pgno iPtrMap, ret;\n<line3>assert( sqlite3_mutex_held(pBt->mutex) );\n<line4>if( pgno<2 ) return 0;\n<line5>nPagesPerMapPage = (pBt->usableSize/5)+1;\n<line6>iPtrMap = (pgno-2)/nPagesPerMapPage;\n<line7>ret = (iPtrMap*nPagesPerMapPage) + 2;\n<line8>if( ret==PENDING_BYTE_PAGE(pBt) ){\n<line9>ret++;\n<line10>}\n<line11>return ret;\n<line12>}
----------------------------------------
Function: ptrmapPut
Content: <line0>static void ptrmapPut(BtShared *pBt, Pgno key, u8 eType, Pgno parent, int *pRC){\n<line1>DbPage *pDbPage;  /* The pointer map page */\n<line2>u8 *pPtrmap;      /* The pointer map data */\n<line3>Pgno iPtrmap;     /* The pointer map page number */\n<line4>int offset;       /* Offset in pointer map page */\n<line5>int rc;           /* Return code from subfunctions */\n<line6>if( *pRC ) return;\n<line7>assert( sqlite3_mutex_held(pBt->mutex) );\n<line8>/* The super-journal page number must never be used as a pointer map page */\n<line9>assert( 0==PTRMAP_ISPAGE(pBt, PENDING_BYTE_PAGE(pBt)) );\n<line10>assert( pBt->autoVacuum );\n<line11>if( key==0 ){\n<line12>*pRC = SQLITE_CORRUPT_BKPT;\n<line13>return;\n<line14>}\n<line15>iPtrmap = PTRMAP_PAGENO(pBt, key);\n<line16>rc = sqlite3PagerGet(pBt->pPager, iPtrmap, &pDbPage, 0);\n<line17>if( rc!=SQLITE_OK ){\n<line18>*pRC = rc;\n<line19>return;\n<line20>}\n<line21>if( ((char*)sqlite3PagerGetExtra(pDbPage))[0]!=0 ){\n<line22>/* The first byte of the extra data is the MemPage.isInit byte.\n<line23>** If that byte is set, it means this page is also being used\n<line24>** as a btree page. */\n<line25>*pRC = SQLITE_CORRUPT_BKPT;\n<line26>goto ptrmap_exit;\n<line27>}\n<line28>offset = PTRMAP_PTROFFSET(iPtrmap, key);\n<line29>if( offset<0 ){\n<line30>*pRC = SQLITE_CORRUPT_BKPT;\n<line31>goto ptrmap_exit;\n<line32>}\n<line33>assert( offset <= (int)pBt->usableSize-5 );\n<line34>pPtrmap = (u8 *)sqlite3PagerGetData(pDbPage);\n<line35>if( eType!=pPtrmap[offset] || get4byte(&pPtrmap[offset+1])!=parent ){\n<line36>TRACE(("PTRMAP_UPDATE: %u->(%u,%u)\n", key, eType, parent));\n<line37>*pRC= rc = sqlite3PagerWrite(pDbPage);\n<line38>if( rc==SQLITE_OK ){\n<line39>pPtrmap[offset] = eType;\n<line40>put4byte(&pPtrmap[offset+1], parent);\n<line41>}\n<line42>}\n<line43>ptrmap_exit:\n<line44>sqlite3PagerUnref(pDbPage);\n<line45>}
----------------------------------------
Function: ptrmapGet
Content: <line0>static int ptrmapGet(BtShared *pBt, Pgno key, u8 *pEType, Pgno *pPgno){\n<line1>DbPage *pDbPage;   /* The pointer map page */\n<line2>int iPtrmap;       /* Pointer map page index */\n<line3>u8 *pPtrmap;       /* Pointer map page data */\n<line4>int offset;        /* Offset of entry in pointer map */\n<line5>int rc;\n<line6>assert( sqlite3_mutex_held(pBt->mutex) );\n<line7>iPtrmap = PTRMAP_PAGENO(pBt, key);\n<line8>rc = sqlite3PagerGet(pBt->pPager, iPtrmap, &pDbPage, 0);\n<line9>if( rc!=0 ){\n<line10>return rc;\n<line11>}\n<line12>pPtrmap = (u8 *)sqlite3PagerGetData(pDbPage);\n<line13>offset = PTRMAP_PTROFFSET(iPtrmap, key);\n<line14>if( offset<0 ){\n<line15>sqlite3PagerUnref(pDbPage);\n<line16>return SQLITE_CORRUPT_BKPT;\n<line17>}\n<line18>assert( offset <= (int)pBt->usableSize-5 );\n<line19>assert( pEType!=0 );\n<line20>*pEType = pPtrmap[offset];\n<line21>if( pPgno ) *pPgno = get4byte(&pPtrmap[offset+1]);\n<line22>sqlite3PagerUnref(pDbPage);\n<line23>if( *pEType<1 || *pEType>5 ) return SQLITE_CORRUPT_PGNO(iPtrmap);\n<line24>return SQLITE_OK;\n<line25>}
----------------------------------------
Function: btreeParseCellAdjustSizeForOverflow
Content: <line0>static SQLITE_NOINLINE void btreeParseCellAdjustSizeForOverflow(\n<line1>MemPage *pPage,         /* Page containing the cell */\n<line2>u8 *pCell,              /* Pointer to the cell text. */\n<line3>CellInfo *pInfo         /* Fill in this structure */\n<line4>){\n<line5>/* If the payload will not fit completely on the local page, we have\n<line6>** to decide how much to store locally and how much to spill onto\n<line7>** overflow pages.  The strategy is to minimize the amount of unused\n<line8>** space on overflow pages while keeping the amount of local storage\n<line9>** in between minLocal and maxLocal.\n<line10>**\n<line11>** Warning:  changing the way overflow payload is distributed in any\n<line12>** way will result in an incompatible file format.\n<line13>*/\n<line14>int minLocal;  /* Minimum amount of payload held locally */\n<line15>int maxLocal;  /* Maximum amount of payload held locally */\n<line16>int surplus;   /* Overflow payload available for local storage */\n<line17>minLocal = pPage->minLocal;\n<line18>maxLocal = pPage->maxLocal;\n<line19>surplus = minLocal + (pInfo->nPayload - minLocal)%(pPage->pBt->usableSize-4);\n<line20>testcase( surplus==maxLocal );\n<line21>testcase( surplus==maxLocal+1 );\n<line22>if( surplus <= maxLocal ){\n<line23>pInfo->nLocal = (u16)surplus;\n<line24>}else{\n<line25>pInfo->nLocal = (u16)minLocal;\n<line26>}\n<line27>pInfo->nSize = (u16)(&pInfo->pPayload[pInfo->nLocal] - pCell) + 4;\n<line28>}
----------------------------------------
Function: btreePayloadToLocal
Content: <line0>static int btreePayloadToLocal(MemPage *pPage, i64 nPayload){\n<line1>int maxLocal;  /* Maximum amount of payload held locally */\n<line2>maxLocal = pPage->maxLocal;\n<line3>assert( nPayload>=0 );\n<line4>if( nPayload<=maxLocal ){\n<line5>return (int)nPayload;\n<line6>}else{\n<line7>int minLocal;  /* Minimum amount of payload held locally */\n<line8>int surplus;   /* Overflow payload available for local storage */\n<line9>minLocal = pPage->minLocal;\n<line10>surplus = (int)(minLocal +(nPayload - minLocal)%(pPage->pBt->usableSize-4));\n<line11>return (surplus <= maxLocal) ? surplus : minLocal;\n<line12>}\n<line13>}
----------------------------------------
Function: btreeParseCellPtrNoPayload
Content: <line0>static void btreeParseCellPtrNoPayload(\n<line1>MemPage *pPage,         /* Page containing the cell */\n<line2>u8 *pCell,              /* Pointer to the cell text. */\n<line3>CellInfo *pInfo         /* Fill in this structure */\n<line4>){\n<line5>assert( sqlite3_mutex_held(pPage->pBt->mutex) );\n<line6>assert( pPage->leaf==0 );\n<line7>assert( pPage->childPtrSize==4 );\n<line8>#ifndef SQLITE_DEBUG\n<line9>UNUSED_PARAMETER(pPage);\n<line10>#endif\n<line11>pInfo->nSize = 4 + getVarint(&pCell[4], (u64*)&pInfo->nKey);\n<line12>pInfo->nPayload = 0;\n<line13>pInfo->nLocal = 0;\n<line14>pInfo->pPayload = 0;\n<line15>return;\n<line16>}
----------------------------------------
Function: btreeParseCellPtr
Content: <line0>static void btreeParseCellPtr(\n<line1>MemPage *pPage,         /* Page containing the cell */\n<line2>u8 *pCell,              /* Pointer to the cell text. */\n<line3>CellInfo *pInfo         /* Fill in this structure */\n<line4>){\n<line5>u8 *pIter;              /* For scanning through pCell */\n<line6>u32 nPayload;           /* Number of bytes of cell payload */\n<line7>u64 iKey;               /* Extracted Key value */\n<line8>assert( sqlite3_mutex_held(pPage->pBt->mutex) );\n<line9>assert( pPage->leaf==0 || pPage->leaf==1 );\n<line10>assert( pPage->intKeyLeaf );\n<line11>assert( pPage->childPtrSize==0 );\n<line12>pIter = pCell;\n<line13>/* The next block of code is equivalent to:\n<line14>**\n<line15>**     pIter += getVarint32(pIter, nPayload);\n<line16>**\n<line17>** The code is inlined to avoid a function call.\n<line18>*/\n<line19>nPayload = *pIter;\n<line20>if( nPayload>=0x80 ){\n<line21>u8 *pEnd = &pIter[8];\n<line22>nPayload &= 0x7f;\n<line23>do{\n<line24>nPayload = (nPayload<<7) | (*++pIter & 0x7f);\n<line25>}while( (*pIter)>=0x80 && pIter<pEnd );\n<line26>}\n<line27>pIter++;\n<line28>/* The next block of code is equivalent to:\n<line29>**\n<line30>**     pIter += getVarint(pIter, (u64*)&pInfo->nKey);\n<line31>**\n<line32>** The code is inlined and the loop is unrolled for performance.\n<line33>** This routine is a high-runner.\n<line34>*/\n<line35>iKey = *pIter;\n<line36>if( iKey>=0x80 ){\n<line37>u8 x;\n<line38>iKey = (iKey<<7) ^ (x = *++pIter);\n<line39>if( x>=0x80 ){\n<line40>iKey = (iKey<<7) ^ (x = *++pIter);\n<line41>if( x>=0x80 ){\n<line42>iKey = (iKey<<7) ^ 0x10204000 ^ (x = *++pIter);\n<line43>if( x>=0x80 ){\n<line44>iKey = (iKey<<7) ^ 0x4000 ^ (x = *++pIter);\n<line45>if( x>=0x80 ){\n<line46>iKey = (iKey<<7) ^ 0x4000 ^ (x = *++pIter);\n<line47>if( x>=0x80 ){\n<line48>iKey = (iKey<<7) ^ 0x4000 ^ (x = *++pIter);\n<line49>if( x>=0x80 ){\n<line50>iKey = (iKey<<7) ^ 0x4000 ^ (x = *++pIter);\n<line51>if( x>=0x80 ){\n<line52>iKey = (iKey<<8) ^ 0x8000 ^ (*++pIter);\n<line53>}\n<line54>}\n<line55>}\n<line56>}\n<line57>}\n<line58>}else{\n<line59>iKey ^= 0x204000;\n<line60>}\n<line61>}else{\n<line62>iKey ^= 0x4000;\n<line63>}\n<line64>}\n<line65>pIter++;\n<line66>pInfo->nKey = *(i64*)&iKey;\n<line67>pInfo->nPayload = nPayload;\n<line68>pInfo->pPayload = pIter;\n<line69>testcase( nPayload==pPage->maxLocal );\n<line70>testcase( nPayload==(u32)pPage->maxLocal+1 );\n<line71>assert( nPayload>=0 );\n<line72>assert( pPage->maxLocal <= BT_MAX_LOCAL );\n<line73>if( nPayload<=pPage->maxLocal ){\n<line74>/* This is the (easy) common case where the entire payload fits\n<line75>** on the local page.  No overflow is required.\n<line76>*/\n<line77>pInfo->nSize = (u16)nPayload + (u16)(pIter - pCell);\n<line78>if( pInfo->nSize<4 ) pInfo->nSize = 4;\n<line79>pInfo->nLocal = (u16)nPayload;\n<line80>}else{\n<line81>btreeParseCellAdjustSizeForOverflow(pPage, pCell, pInfo);\n<line82>}\n<line83>}
----------------------------------------
Function: btreeParseCellPtrIndex
Content: <line0>static void btreeParseCellPtrIndex(\n<line1>MemPage *pPage,         /* Page containing the cell */\n<line2>u8 *pCell,              /* Pointer to the cell text. */\n<line3>CellInfo *pInfo         /* Fill in this structure */\n<line4>){\n<line5>u8 *pIter;              /* For scanning through pCell */\n<line6>u32 nPayload;           /* Number of bytes of cell payload */\n<line7>assert( sqlite3_mutex_held(pPage->pBt->mutex) );\n<line8>assert( pPage->leaf==0 || pPage->leaf==1 );\n<line9>assert( pPage->intKeyLeaf==0 );\n<line10>pIter = pCell + pPage->childPtrSize;\n<line11>nPayload = *pIter;\n<line12>if( nPayload>=0x80 ){\n<line13>u8 *pEnd = &pIter[8];\n<line14>nPayload &= 0x7f;\n<line15>do{\n<line16>nPayload = (nPayload<<7) | (*++pIter & 0x7f);\n<line17>}while( *(pIter)>=0x80 && pIter<pEnd );\n<line18>}\n<line19>pIter++;\n<line20>pInfo->nKey = nPayload;\n<line21>pInfo->nPayload = nPayload;\n<line22>pInfo->pPayload = pIter;\n<line23>testcase( nPayload==pPage->maxLocal );\n<line24>testcase( nPayload==(u32)pPage->maxLocal+1 );\n<line25>assert( nPayload>=0 );\n<line26>assert( pPage->maxLocal <= BT_MAX_LOCAL );\n<line27>if( nPayload<=pPage->maxLocal ){\n<line28>/* This is the (easy) common case where the entire payload fits\n<line29>** on the local page.  No overflow is required.\n<line30>*/\n<line31>pInfo->nSize = (u16)nPayload + (u16)(pIter - pCell);\n<line32>if( pInfo->nSize<4 ) pInfo->nSize = 4;\n<line33>pInfo->nLocal = (u16)nPayload;\n<line34>}else{\n<line35>btreeParseCellAdjustSizeForOverflow(pPage, pCell, pInfo);\n<line36>}\n<line37>}
----------------------------------------
Function: btreeParseCell
Content: <line0>static void btreeParseCell(\n<line1>MemPage *pPage,         /* Page containing the cell */\n<line2>int iCell,              /* The cell index.  First cell is 0 */\n<line3>CellInfo *pInfo         /* Fill in this structure */\n<line4>){\n<line5>pPage->xParseCell(pPage, findCell(pPage, iCell), pInfo);\n<line6>}
----------------------------------------
Function: cellSizePtr
Content: <line0>static u16 cellSizePtr(MemPage *pPage, u8 *pCell){\n<line1>u8 *pIter = pCell + 4;                   /* For looping over bytes of pCell */\n<line2>u8 *pEnd;                                /* End mark for a varint */\n<line3>u32 nSize;                               /* Size value to return */\n<line4>#ifdef SQLITE_DEBUG\n<line5>/* The value returned by this function should always be the same as\n<line6>** the (CellInfo.nSize) value found by doing a full parse of the\n<line7>** cell. If SQLITE_DEBUG is defined, an assert() at the bottom of\n<line8>** this function verifies that this invariant is not violated. */\n<line9>CellInfo debuginfo;\n<line10>pPage->xParseCell(pPage, pCell, &debuginfo);\n<line11>#endif\n<line12>assert( pPage->childPtrSize==4 );\n<line13>nSize = *pIter;\n<line14>if( nSize>=0x80 ){\n<line15>pEnd = &pIter[8];\n<line16>nSize &= 0x7f;\n<line17>do{\n<line18>nSize = (nSize<<7) | (*++pIter & 0x7f);\n<line19>}while( *(pIter)>=0x80 && pIter<pEnd );\n<line20>}\n<line21>pIter++;\n<line22>testcase( nSize==pPage->maxLocal );\n<line23>testcase( nSize==(u32)pPage->maxLocal+1 );\n<line24>if( nSize<=pPage->maxLocal ){\n<line25>nSize += (u32)(pIter - pCell);\n<line26>assert( nSize>4 );\n<line27>}else{\n<line28>int minLocal = pPage->minLocal;\n<line29>nSize = minLocal + (nSize - minLocal) % (pPage->pBt->usableSize - 4);\n<line30>testcase( nSize==pPage->maxLocal );\n<line31>testcase( nSize==(u32)pPage->maxLocal+1 );\n<line32>if( nSize>pPage->maxLocal ){\n<line33>nSize = minLocal;\n<line34>}\n<line35>nSize += 4 + (u16)(pIter - pCell);\n<line36>}\n<line37>assert( nSize==debuginfo.nSize || CORRUPT_DB );\n<line38>return (u16)nSize;\n<line39>}
----------------------------------------
Function: cellSizePtrIdxLeaf
Content: <line0>static u16 cellSizePtrIdxLeaf(MemPage *pPage, u8 *pCell){\n<line1>u8 *pIter = pCell;                       /* For looping over bytes of pCell */\n<line2>u8 *pEnd;                                /* End mark for a varint */\n<line3>u32 nSize;                               /* Size value to return */\n<line4>#ifdef SQLITE_DEBUG\n<line5>/* The value returned by this function should always be the same as\n<line6>** the (CellInfo.nSize) value found by doing a full parse of the\n<line7>** cell. If SQLITE_DEBUG is defined, an assert() at the bottom of\n<line8>** this function verifies that this invariant is not violated. */\n<line9>CellInfo debuginfo;\n<line10>pPage->xParseCell(pPage, pCell, &debuginfo);\n<line11>#endif\n<line12>assert( pPage->childPtrSize==0 );\n<line13>nSize = *pIter;\n<line14>if( nSize>=0x80 ){\n<line15>pEnd = &pIter[8];\n<line16>nSize &= 0x7f;\n<line17>do{\n<line18>nSize = (nSize<<7) | (*++pIter & 0x7f);\n<line19>}while( *(pIter)>=0x80 && pIter<pEnd );\n<line20>}\n<line21>pIter++;\n<line22>testcase( nSize==pPage->maxLocal );\n<line23>testcase( nSize==(u32)pPage->maxLocal+1 );\n<line24>if( nSize<=pPage->maxLocal ){\n<line25>nSize += (u32)(pIter - pCell);\n<line26>if( nSize<4 ) nSize = 4;\n<line27>}else{\n<line28>int minLocal = pPage->minLocal;\n<line29>nSize = minLocal + (nSize - minLocal) % (pPage->pBt->usableSize - 4);\n<line30>testcase( nSize==pPage->maxLocal );\n<line31>testcase( nSize==(u32)pPage->maxLocal+1 );\n<line32>if( nSize>pPage->maxLocal ){\n<line33>nSize = minLocal;\n<line34>}\n<line35>nSize += 4 + (u16)(pIter - pCell);\n<line36>}\n<line37>assert( nSize==debuginfo.nSize || CORRUPT_DB );\n<line38>return (u16)nSize;\n<line39>}
----------------------------------------
Function: cellSizePtrNoPayload
Content: <line0>static u16 cellSizePtrNoPayload(MemPage *pPage, u8 *pCell){\n<line1>u8 *pIter = pCell + 4; /* For looping over bytes of pCell */\n<line2>u8 *pEnd;              /* End mark for a varint */\n<line3>#ifdef SQLITE_DEBUG\n<line4>/* The value returned by this function should always be the same as\n<line5>** the (CellInfo.nSize) value found by doing a full parse of the\n<line6>** cell. If SQLITE_DEBUG is defined, an assert() at the bottom of\n<line7>** this function verifies that this invariant is not violated. */\n<line8>CellInfo debuginfo;\n<line9>pPage->xParseCell(pPage, pCell, &debuginfo);\n<line10>#else\n<line11>UNUSED_PARAMETER(pPage);\n<line12>#endif\n<line13>assert( pPage->childPtrSize==4 );\n<line14>pEnd = pIter + 9;\n<line15>while( (*pIter++)&0x80 && pIter<pEnd );\n<line16>assert( debuginfo.nSize==(u16)(pIter - pCell) || CORRUPT_DB );\n<line17>return (u16)(pIter - pCell);\n<line18>}
----------------------------------------
Function: cellSizePtrTableLeaf
Content: <line0>static u16 cellSizePtrTableLeaf(MemPage *pPage, u8 *pCell){\n<line1>u8 *pIter = pCell;   /* For looping over bytes of pCell */\n<line2>u8 *pEnd;            /* End mark for a varint */\n<line3>u32 nSize;           /* Size value to return */\n<line4>#ifdef SQLITE_DEBUG\n<line5>/* The value returned by this function should always be the same as\n<line6>** the (CellInfo.nSize) value found by doing a full parse of the\n<line7>** cell. If SQLITE_DEBUG is defined, an assert() at the bottom of\n<line8>** this function verifies that this invariant is not violated. */\n<line9>CellInfo debuginfo;\n<line10>pPage->xParseCell(pPage, pCell, &debuginfo);\n<line11>#endif\n<line12>nSize = *pIter;\n<line13>if( nSize>=0x80 ){\n<line14>pEnd = &pIter[8];\n<line15>nSize &= 0x7f;\n<line16>do{\n<line17>nSize = (nSize<<7) | (*++pIter & 0x7f);\n<line18>}while( *(pIter)>=0x80 && pIter<pEnd );\n<line19>}\n<line20>pIter++;\n<line21>/* pIter now points at the 64-bit integer key value, a variable length\n<line22>** integer. The following block moves pIter to point at the first byte\n<line23>** past the end of the key value. */\n<line24>if( (*pIter++)&0x80\n<line25>&& (*pIter++)&0x80\n<line26>&& (*pIter++)&0x80\n<line27>&& (*pIter++)&0x80\n<line28>&& (*pIter++)&0x80\n<line29>&& (*pIter++)&0x80\n<line30>&& (*pIter++)&0x80\n<line31>&& (*pIter++)&0x80 ){ pIter++; }\n<line32>testcase( nSize==pPage->maxLocal );\n<line33>testcase( nSize==(u32)pPage->maxLocal+1 );\n<line34>if( nSize<=pPage->maxLocal ){\n<line35>nSize += (u32)(pIter - pCell);\n<line36>if( nSize<4 ) nSize = 4;\n<line37>}else{\n<line38>int minLocal = pPage->minLocal;\n<line39>nSize = minLocal + (nSize - minLocal) % (pPage->pBt->usableSize - 4);\n<line40>testcase( nSize==pPage->maxLocal );\n<line41>testcase( nSize==(u32)pPage->maxLocal+1 );\n<line42>if( nSize>pPage->maxLocal ){\n<line43>nSize = minLocal;\n<line44>}\n<line45>nSize += 4 + (u16)(pIter - pCell);\n<line46>}\n<line47>assert( nSize==debuginfo.nSize || CORRUPT_DB );\n<line48>return (u16)nSize;\n<line49>}
----------------------------------------
Function: ptrmapPutOvflPtr
Content: <line0>static void ptrmapPutOvflPtr(MemPage *pPage, MemPage *pSrc, u8 *pCell,int *pRC){\n<line1>CellInfo info;\n<line2>if( *pRC ) return;\n<line3>assert( pCell!=0 );\n<line4>pPage->xParseCell(pPage, pCell, &info);\n<line5>if( info.nLocal<info.nPayload ){\n<line6>Pgno ovfl;\n<line7>if( SQLITE_OVERFLOW(pSrc->aDataEnd, pCell, pCell+info.nLocal) ){\n<line8>testcase( pSrc!=pPage );\n<line9>*pRC = SQLITE_CORRUPT_BKPT;\n<line10>return;\n<line11>}\n<line12>ovfl = get4byte(&pCell[info.nSize-4]);\n<line13>ptrmapPut(pPage->pBt, ovfl, PTRMAP_OVERFLOW1, pPage->pgno, pRC);\n<line14>}\n<line15>}
----------------------------------------
Function: defragmentPage
Content: <line0>static int defragmentPage(MemPage *pPage, int nMaxFrag){\n<line1>int i;                     /* Loop counter */\n<line2>int pc;                    /* Address of the i-th cell */\n<line3>int hdr;                   /* Offset to the page header */\n<line4>int size;                  /* Size of a cell */\n<line5>int usableSize;            /* Number of usable bytes on a page */\n<line6>int cellOffset;            /* Offset to the cell pointer array */\n<line7>int cbrk;                  /* Offset to the cell content area */\n<line8>int nCell;                 /* Number of cells on the page */\n<line9>unsigned char *data;       /* The page data */\n<line10>unsigned char *temp;       /* Temp area for cell content */\n<line11>unsigned char *src;        /* Source of content */\n<line12>int iCellFirst;            /* First allowable cell index */\n<line13>int iCellLast;             /* Last possible cell index */\n<line14>int iCellStart;            /* First cell offset in input */\n<line15>assert( sqlite3PagerIswriteable(pPage->pDbPage) );\n<line16>assert( pPage->pBt!=0 );\n<line17>assert( pPage->pBt->usableSize <= SQLITE_MAX_PAGE_SIZE );\n<line18>assert( pPage->nOverflow==0 );\n<line19>assert( sqlite3_mutex_held(pPage->pBt->mutex) );\n<line20>data = pPage->aData;\n<line21>hdr = pPage->hdrOffset;\n<line22>cellOffset = pPage->cellOffset;\n<line23>nCell = pPage->nCell;\n<line24>assert( nCell==get2byte(&data[hdr+3]) || CORRUPT_DB );\n<line25>iCellFirst = cellOffset + 2*nCell;\n<line26>usableSize = pPage->pBt->usableSize;\n<line27>/* This block handles pages with two or fewer free blocks and nMaxFrag\n<line28>** or fewer fragmented bytes. In this case it is faster to move the\n<line29>** two (or one) blocks of cells using memmove() and add the required\n<line30>** offsets to each pointer in the cell-pointer array than it is to\n<line31>** reconstruct the entire page.  */\n<line32>if( (int)data[hdr+7]<=nMaxFrag ){\n<line33>int iFree = get2byte(&data[hdr+1]);\n<line34>if( iFree>usableSize-4 ) return SQLITE_CORRUPT_PAGE(pPage);\n<line35>if( iFree ){\n<line36>int iFree2 = get2byte(&data[iFree]);\n<line37>if( iFree2>usableSize-4 ) return SQLITE_CORRUPT_PAGE(pPage);\n<line38>if( 0==iFree2 || (data[iFree2]==0 && data[iFree2+1]==0) ){\n<line39>u8 *pEnd = &data[cellOffset + nCell*2];\n<line40>u8 *pAddr;\n<line41>int sz2 = 0;\n<line42>int sz = get2byte(&data[iFree+2]);\n<line43>int top = get2byte(&data[hdr+5]);\n<line44>if( top>=iFree ){\n<line45>return SQLITE_CORRUPT_PAGE(pPage);\n<line46>}\n<line47>if( iFree2 ){\n<line48>if( iFree+sz>iFree2 ) return SQLITE_CORRUPT_PAGE(pPage);\n<line49>sz2 = get2byte(&data[iFree2+2]);\n<line50>if( iFree2+sz2 > usableSize ) return SQLITE_CORRUPT_PAGE(pPage);\n<line51>memmove(&data[iFree+sz+sz2], &data[iFree+sz], iFree2-(iFree+sz));\n<line52>sz += sz2;\n<line53>}else if( iFree+sz>usableSize ){\n<line54>return SQLITE_CORRUPT_PAGE(pPage);\n<line55>}\n<line56>cbrk = top+sz;\n<line57>assert( cbrk+(iFree-top) <= usableSize );\n<line58>memmove(&data[cbrk], &data[top], iFree-top);\n<line59>for(pAddr=&data[cellOffset]; pAddr<pEnd; pAddr+=2){\n<line60>pc = get2byte(pAddr);\n<line61>if( pc<iFree ){ put2byte(pAddr, pc+sz); }\n<line62>else if( pc<iFree2 ){ put2byte(pAddr, pc+sz2); }\n<line63>}\n<line64>goto defragment_out;\n<line65>}\n<line66>}\n<line67>}\n<line68>cbrk = usableSize;\n<line69>iCellLast = usableSize - 4;\n<line70>iCellStart = get2byte(&data[hdr+5]);\n<line71>if( nCell>0 ){\n<line72>temp = sqlite3PagerTempSpace(pPage->pBt->pPager);\n<line73>memcpy(temp, data, usableSize);\n<line74>src = temp;\n<line75>for(i=0; i<nCell; i++){\n<line76>u8 *pAddr;     /* The i-th cell pointer */\n<line77>pAddr = &data[cellOffset + i*2];\n<line78>pc = get2byte(pAddr);\n<line79>testcase( pc==iCellFirst );\n<line80>testcase( pc==iCellLast );\n<line81>/* These conditions have already been verified in btreeInitPage()\n<line82>** if PRAGMA cell_size_check=ON.\n<line83>*/\n<line84>if( pc>iCellLast ){\n<line85>return SQLITE_CORRUPT_PAGE(pPage);\n<line86>}\n<line87>assert( pc>=0 && pc<=iCellLast );\n<line88>size = pPage->xCellSize(pPage, &src[pc]);\n<line89>cbrk -= size;\n<line90>if( cbrk<iCellStart || pc+size>usableSize ){\n<line91>return SQLITE_CORRUPT_PAGE(pPage);\n<line92>}\n<line93>assert( cbrk+size<=usableSize && cbrk>=iCellStart );\n<line94>testcase( cbrk+size==usableSize );\n<line95>testcase( pc+size==usableSize );\n<line96>put2byte(pAddr, cbrk);\n<line97>memcpy(&data[cbrk], &src[pc], size);\n<line98>}\n<line99>}\n<line100>data[hdr+7] = 0;\n<line101>defragment_out:\n<line102>assert( pPage->nFree>=0 );\n<line103>if( data[hdr+7]+cbrk-iCellFirst!=pPage->nFree ){\n<line104>return SQLITE_CORRUPT_PAGE(pPage);\n<line105>}\n<line106>assert( cbrk>=iCellFirst );\n<line107>put2byte(&data[hdr+5], cbrk);\n<line108>data[hdr+1] = 0;\n<line109>data[hdr+2] = 0;\n<line110>memset(&data[iCellFirst], 0, cbrk-iCellFirst);\n<line111>assert( sqlite3PagerIswriteable(pPage->pDbPage) );\n<line112>return SQLITE_OK;\n<line113>}
----------------------------------------
Function: pageFindSlot
Content: <line0>static u8 *pageFindSlot(MemPage *pPg, int nByte, int *pRc){\n<line1>const int hdr = pPg->hdrOffset;            /* Offset to page header */\n<line2>u8 * const aData = pPg->aData;             /* Page data */\n<line3>int iAddr = hdr + 1;                       /* Address of ptr to pc */\n<line4>u8 *pTmp = &aData[iAddr];                  /* Temporary ptr into aData[] */\n<line5>int pc = get2byte(pTmp);                   /* Address of a free slot */\n<line6>int x;                                     /* Excess size of the slot */\n<line7>int maxPC = pPg->pBt->usableSize - nByte;  /* Max address for a usable slot */\n<line8>int size;                                  /* Size of the free slot */\n<line9>assert( pc>0 );\n<line10>while( pc<=maxPC ){\n<line11>/* EVIDENCE-OF: R-22710-53328 The third and fourth bytes of each\n<line12>** freeblock form a big-endian integer which is the size of the freeblock\n<line13>** in bytes, including the 4-byte header. */\n<line14>pTmp = &aData[pc+2];\n<line15>size = get2byte(pTmp);\n<line16>if( (x = size - nByte)>=0 ){\n<line17>testcase( x==4 );\n<line18>testcase( x==3 );\n<line19>if( x<4 ){\n<line20>/* EVIDENCE-OF: R-11498-58022 In a well-formed b-tree page, the total\n<line21>** number of bytes in fragments may not exceed 60. */\n<line22>if( aData[hdr+7]>57 ) return 0;\n<line23>/* Remove the slot from the free-list. Update the number of\n<line24>** fragmented bytes within the page. */\n<line25>memcpy(&aData[iAddr], &aData[pc], 2);\n<line26>aData[hdr+7] += (u8)x;\n<line27>return &aData[pc];\n<line28>}else if( x+pc > maxPC ){\n<line29>/* This slot extends off the end of the usable part of the page */\n<line30>*pRc = SQLITE_CORRUPT_PAGE(pPg);\n<line31>return 0;\n<line32>}else{\n<line33>/* The slot remains on the free-list. Reduce its size to account\n<line34>** for the portion used by the new allocation. */\n<line35>put2byte(&aData[pc+2], x);\n<line36>}\n<line37>return &aData[pc + x];\n<line38>}\n<line39>iAddr = pc;\n<line40>pTmp = &aData[pc];\n<line41>pc = get2byte(pTmp);\n<line42>if( pc<=iAddr ){\n<line43>if( pc ){\n<line44>/* The next slot in the chain comes before the current slot */\n<line45>*pRc = SQLITE_CORRUPT_PAGE(pPg);\n<line46>}\n<line47>return 0;\n<line48>}\n<line49>}\n<line50>if( pc>maxPC+nByte-4 ){\n<line51>/* The free slot chain extends off the end of the page */\n<line52>*pRc = SQLITE_CORRUPT_PAGE(pPg);\n<line53>}\n<line54>return 0;\n<line55>}
----------------------------------------
Function: allocateSpace
Content: <line0>static SQLITE_INLINE int allocateSpace(MemPage *pPage, int nByte, int *pIdx){\n<line1>const int hdr = pPage->hdrOffset;    /* Local cache of pPage->hdrOffset */\n<line2>u8 * const data = pPage->aData;      /* Local cache of pPage->aData */\n<line3>int top;                             /* First byte of cell content area */\n<line4>int rc = SQLITE_OK;                  /* Integer return code */\n<line5>u8 *pTmp;                            /* Temp ptr into data[] */\n<line6>int gap;        /* First byte of gap between cell pointers and cell content */\n<line7>assert( sqlite3PagerIswriteable(pPage->pDbPage) );\n<line8>assert( pPage->pBt );\n<line9>assert( sqlite3_mutex_held(pPage->pBt->mutex) );\n<line10>assert( nByte>=0 );  /* Minimum cell size is 4 */\n<line11>assert( pPage->nFree>=nByte );\n<line12>assert( pPage->nOverflow==0 );\n<line13>assert( nByte < (int)(pPage->pBt->usableSize-8) );\n<line14>assert( pPage->cellOffset == hdr + 12 - 4*pPage->leaf );\n<line15>gap = pPage->cellOffset + 2*pPage->nCell;\n<line16>assert( gap<=65536 );\n<line17>/* EVIDENCE-OF: R-29356-02391 If the database uses a 65536-byte page size\n<line18>** and the reserved space is zero (the usual value for reserved space)\n<line19>** then the cell content offset of an empty page wants to be 65536.\n<line20>** However, that integer is too large to be stored in a 2-byte unsigned\n<line21>** integer, so a value of 0 is used in its place. */\n<line22>pTmp = &data[hdr+5];\n<line23>top = get2byte(pTmp);\n<line24>if( gap>top ){\n<line25>if( top==0 && pPage->pBt->usableSize==65536 ){\n<line26>top = 65536;\n<line27>}else{\n<line28>return SQLITE_CORRUPT_PAGE(pPage);\n<line29>}\n<line30>}else if( top>(int)pPage->pBt->usableSize ){\n<line31>return SQLITE_CORRUPT_PAGE(pPage);\n<line32>}\n<line33>/* If there is enough space between gap and top for one more cell pointer,\n<line34>** and if the freelist is not empty, then search the\n<line35>** freelist looking for a slot big enough to satisfy the request.\n<line36>*/\n<line37>testcase( gap+2==top );\n<line38>testcase( gap+1==top );\n<line39>testcase( gap==top );\n<line40>if( (data[hdr+2] || data[hdr+1]) && gap+2<=top ){\n<line41>u8 *pSpace = pageFindSlot(pPage, nByte, &rc);\n<line42>if( pSpace ){\n<line43>int g2;\n<line44>assert( pSpace+nByte<=data+pPage->pBt->usableSize );\n<line45>*pIdx = g2 = (int)(pSpace-data);\n<line46>if( g2<=gap ){\n<line47>return SQLITE_CORRUPT_PAGE(pPage);\n<line48>}else{\n<line49>return SQLITE_OK;\n<line50>}\n<line51>}else if( rc ){\n<line52>return rc;\n<line53>}\n<line54>}\n<line55>/* The request could not be fulfilled using a freelist slot.  Check\n<line56>** to see if defragmentation is necessary.\n<line57>*/\n<line58>testcase( gap+2+nByte==top );\n<line59>if( gap+2+nByte>top ){\n<line60>assert( pPage->nCell>0 || CORRUPT_DB );\n<line61>assert( pPage->nFree>=0 );\n<line62>rc = defragmentPage(pPage, MIN(4, pPage->nFree - (2+nByte)));\n<line63>if( rc ) return rc;\n<line64>top = get2byteNotZero(&data[hdr+5]);\n<line65>assert( gap+2+nByte<=top );\n<line66>}\n<line67>/* Allocate memory from the gap in between the cell pointer array\n<line68>** and the cell content area.  The btreeComputeFreeSpace() call has already\n<line69>** validated the freelist.  Given that the freelist is valid, there\n<line70>** is no way that the allocation can extend off the end of the page.\n<line71>** The assert() below verifies the previous sentence.\n<line72>*/\n<line73>top -= nByte;\n<line74>put2byte(&data[hdr+5], top);\n<line75>assert( top+nByte <= (int)pPage->pBt->usableSize );\n<line76>*pIdx = top;\n<line77>return SQLITE_OK;\n<line78>}
----------------------------------------
Function: freeSpace
Content: <line0>static int freeSpace(MemPage *pPage, int iStart, int iSize){\n<line1>int iPtr;                             /* Address of ptr to next freeblock */\n<line2>int iFreeBlk;                         /* Address of the next freeblock */\n<line3>u8 hdr;                               /* Page header size.  0 or 100 */\n<line4>int nFrag = 0;                        /* Reduction in fragmentation */\n<line5>int iOrigSize = iSize;                /* Original value of iSize */\n<line6>int x;                                /* Offset to cell content area */\n<line7>int iEnd = iStart + iSize;            /* First byte past the iStart buffer */\n<line8>unsigned char *data = pPage->aData;   /* Page content */\n<line9>u8 *pTmp;                             /* Temporary ptr into data[] */\n<line10>assert( pPage->pBt!=0 );\n<line11>assert( sqlite3PagerIswriteable(pPage->pDbPage) );\n<line12>assert( CORRUPT_DB || iStart>=pPage->hdrOffset+6+pPage->childPtrSize );\n<line13>assert( CORRUPT_DB || iEnd <= (int)pPage->pBt->usableSize );\n<line14>assert( sqlite3_mutex_held(pPage->pBt->mutex) );\n<line15>assert( iSize>=4 );   /* Minimum cell size is 4 */\n<line16>assert( CORRUPT_DB || iStart<=(int)pPage->pBt->usableSize-4 );\n<line17>/* The list of freeblocks must be in ascending order.  Find the\n<line18>** spot on the list where iStart should be inserted.\n<line19>*/\n<line20>hdr = pPage->hdrOffset;\n<line21>iPtr = hdr + 1;\n<line22>if( data[iPtr+1]==0 && data[iPtr]==0 ){\n<line23>iFreeBlk = 0;  /* Shortcut for the case when the freelist is empty */\n<line24>}else{\n<line25>while( (iFreeBlk = get2byte(&data[iPtr]))<iStart ){\n<line26>if( iFreeBlk<=iPtr ){\n<line27>if( iFreeBlk==0 ) break; /* TH3: corrupt082.100 */\n<line28>return SQLITE_CORRUPT_PAGE(pPage);\n<line29>}\n<line30>iPtr = iFreeBlk;\n<line31>}\n<line32>if( iFreeBlk>(int)pPage->pBt->usableSize-4 ){ /* TH3: corrupt081.100 */\n<line33>return SQLITE_CORRUPT_PAGE(pPage);\n<line34>}\n<line35>assert( iFreeBlk>iPtr || iFreeBlk==0 || CORRUPT_DB );\n<line36>/* At this point:\n<line37>**    iFreeBlk:   First freeblock after iStart, or zero if none\n<line38>**    iPtr:       The address of a pointer to iFreeBlk\n<line39>**\n<line40>** Check to see if iFreeBlk should be coalesced onto the end of iStart.\n<line41>*/\n<line42>if( iFreeBlk && iEnd+3>=iFreeBlk ){\n<line43>nFrag = iFreeBlk - iEnd;\n<line44>if( iEnd>iFreeBlk ) return SQLITE_CORRUPT_PAGE(pPage);\n<line45>iEnd = iFreeBlk + get2byte(&data[iFreeBlk+2]);\n<line46>if( iEnd > (int)pPage->pBt->usableSize ){\n<line47>return SQLITE_CORRUPT_PAGE(pPage);\n<line48>}\n<line49>iSize = iEnd - iStart;\n<line50>iFreeBlk = get2byte(&data[iFreeBlk]);\n<line51>}\n<line52>/* If iPtr is another freeblock (that is, if iPtr is not the freelist\n<line53>** pointer in the page header) then check to see if iStart should be\n<line54>** coalesced onto the end of iPtr.\n<line55>*/\n<line56>if( iPtr>hdr+1 ){\n<line57>int iPtrEnd = iPtr + get2byte(&data[iPtr+2]);\n<line58>if( iPtrEnd+3>=iStart ){\n<line59>if( iPtrEnd>iStart ) return SQLITE_CORRUPT_PAGE(pPage);\n<line60>nFrag += iStart - iPtrEnd;\n<line61>iSize = iEnd - iPtr;\n<line62>iStart = iPtr;\n<line63>}\n<line64>}\n<line65>if( nFrag>data[hdr+7] ) return SQLITE_CORRUPT_PAGE(pPage);\n<line66>data[hdr+7] -= (u8)nFrag;\n<line67>}\n<line68>pTmp = &data[hdr+5];\n<line69>x = get2byte(pTmp);\n<line70>if( pPage->pBt->btsFlags & BTS_FAST_SECURE ){\n<line71>/* Overwrite deleted information with zeros when the secure_delete\n<line72>** option is enabled */\n<line73>memset(&data[iStart], 0, iSize);\n<line74>}\n<line75>if( iStart<=x ){\n<line76>/* The new freeblock is at the beginning of the cell content area,\n<line77>** so just extend the cell content area rather than create another\n<line78>** freelist entry */\n<line79>if( iStart<x ) return SQLITE_CORRUPT_PAGE(pPage);\n<line80>if( iPtr!=hdr+1 ) return SQLITE_CORRUPT_PAGE(pPage);\n<line81>put2byte(&data[hdr+1], iFreeBlk);\n<line82>put2byte(&data[hdr+5], iEnd);\n<line83>}else{\n<line84>/* Insert the new freeblock into the freelist */\n<line85>put2byte(&data[iPtr], iStart);\n<line86>put2byte(&data[iStart], iFreeBlk);\n<line87>assert( iSize>=0 && iSize<=0xffff );\n<line88>put2byte(&data[iStart+2], (u16)iSize);\n<line89>}\n<line90>pPage->nFree += iOrigSize;\n<line91>return SQLITE_OK;\n<line92>}
----------------------------------------
Function: decodeFlags
Content: <line0>static int decodeFlags(MemPage *pPage, int flagByte){\n<line1>BtShared *pBt;     /* A copy of pPage->pBt */\n<line2>assert( pPage->hdrOffset==(pPage->pgno==1 ? 100 : 0) );\n<line3>assert( sqlite3_mutex_held(pPage->pBt->mutex) );\n<line4>pBt = pPage->pBt;\n<line5>pPage->max1bytePayload = pBt->max1bytePayload;\n<line6>if( flagByte>=(PTF_ZERODATA | PTF_LEAF) ){\n<line7>pPage->childPtrSize = 0;\n<line8>pPage->leaf = 1;\n<line9>if( flagByte==(PTF_LEAFDATA | PTF_INTKEY | PTF_LEAF) ){\n<line10>pPage->intKeyLeaf = 1;\n<line11>pPage->xCellSize = cellSizePtrTableLeaf;\n<line12>pPage->xParseCell = btreeParseCellPtr;\n<line13>pPage->intKey = 1;\n<line14>pPage->maxLocal = pBt->maxLeaf;\n<line15>pPage->minLocal = pBt->minLeaf;\n<line16>}else if( flagByte==(PTF_ZERODATA | PTF_LEAF) ){\n<line17>pPage->intKey = 0;\n<line18>pPage->intKeyLeaf = 0;\n<line19>pPage->xCellSize = cellSizePtrIdxLeaf;\n<line20>pPage->xParseCell = btreeParseCellPtrIndex;\n<line21>pPage->maxLocal = pBt->maxLocal;\n<line22>pPage->minLocal = pBt->minLocal;\n<line23>}else{\n<line24>pPage->intKey = 0;\n<line25>pPage->intKeyLeaf = 0;\n<line26>pPage->xCellSize = cellSizePtrIdxLeaf;\n<line27>pPage->xParseCell = btreeParseCellPtrIndex;\n<line28>return SQLITE_CORRUPT_PAGE(pPage);\n<line29>}\n<line30>}else{\n<line31>pPage->childPtrSize = 4;\n<line32>pPage->leaf = 0;\n<line33>if( flagByte==(PTF_ZERODATA) ){\n<line34>pPage->intKey = 0;\n<line35>pPage->intKeyLeaf = 0;\n<line36>pPage->xCellSize = cellSizePtr;\n<line37>pPage->xParseCell = btreeParseCellPtrIndex;\n<line38>pPage->maxLocal = pBt->maxLocal;\n<line39>pPage->minLocal = pBt->minLocal;\n<line40>}else if( flagByte==(PTF_LEAFDATA | PTF_INTKEY) ){\n<line41>pPage->intKeyLeaf = 0;\n<line42>pPage->xCellSize = cellSizePtrNoPayload;\n<line43>pPage->xParseCell = btreeParseCellPtrNoPayload;\n<line44>pPage->intKey = 1;\n<line45>pPage->maxLocal = pBt->maxLeaf;\n<line46>pPage->minLocal = pBt->minLeaf;\n<line47>}else{\n<line48>pPage->intKey = 0;\n<line49>pPage->intKeyLeaf = 0;\n<line50>pPage->xCellSize = cellSizePtr;\n<line51>pPage->xParseCell = btreeParseCellPtrIndex;\n<line52>return SQLITE_CORRUPT_PAGE(pPage);\n<line53>}\n<line54>}\n<line55>return SQLITE_OK;\n<line56>}
----------------------------------------
Function: btreeComputeFreeSpace
Content: <line0>static int btreeComputeFreeSpace(MemPage *pPage){\n<line1>int pc;            /* Address of a freeblock within pPage->aData[] */\n<line2>u8 hdr;            /* Offset to beginning of page header */\n<line3>u8 *data;          /* Equal to pPage->aData */\n<line4>int usableSize;    /* Amount of usable space on each page */\n<line5>int nFree;         /* Number of unused bytes on the page */\n<line6>int top;           /* First byte of the cell content area */\n<line7>int iCellFirst;    /* First allowable cell or freeblock offset */\n<line8>int iCellLast;     /* Last possible cell or freeblock offset */\n<line9>assert( pPage->pBt!=0 );\n<line10>assert( pPage->pBt->db!=0 );\n<line11>assert( sqlite3_mutex_held(pPage->pBt->mutex) );\n<line12>assert( pPage->pgno==sqlite3PagerPagenumber(pPage->pDbPage) );\n<line13>assert( pPage == sqlite3PagerGetExtra(pPage->pDbPage) );\n<line14>assert( pPage->aData == sqlite3PagerGetData(pPage->pDbPage) );\n<line15>assert( pPage->isInit==1 );\n<line16>assert( pPage->nFree<0 );\n<line17>usableSize = pPage->pBt->usableSize;\n<line18>hdr = pPage->hdrOffset;\n<line19>data = pPage->aData;\n<line20>/* EVIDENCE-OF: R-58015-48175 The two-byte integer at offset 5 designates\n<line21>** the start of the cell content area. A zero value for this integer is\n<line22>** interpreted as 65536. */\n<line23>top = get2byteNotZero(&data[hdr+5]);\n<line24>iCellFirst = hdr + 8 + pPage->childPtrSize + 2*pPage->nCell;\n<line25>iCellLast = usableSize - 4;\n<line26>/* Compute the total free space on the page\n<line27>** EVIDENCE-OF: R-23588-34450 The two-byte integer at offset 1 gives the\n<line28>** start of the first freeblock on the page, or is zero if there are no\n<line29>** freeblocks. */\n<line30>pc = get2byte(&data[hdr+1]);\n<line31>nFree = data[hdr+7] + top;  /* Init nFree to non-freeblock free space */\n<line32>if( pc>0 ){\n<line33>u32 next, size;\n<line34>if( pc<top ){\n<line35>/* EVIDENCE-OF: R-55530-52930 In a well-formed b-tree page, there will\n<line36>** always be at least one cell before the first freeblock.\n<line37>*/\n<line38>return SQLITE_CORRUPT_PAGE(pPage);\n<line39>}\n<line40>while( 1 ){\n<line41>if( pc>iCellLast ){\n<line42>/* Freeblock off the end of the page */\n<line43>return SQLITE_CORRUPT_PAGE(pPage);\n<line44>}\n<line45>next = get2byte(&data[pc]);\n<line46>size = get2byte(&data[pc+2]);\n<line47>nFree = nFree + size;\n<line48>if( next<=pc+size+3 ) break;\n<line49>pc = next;\n<line50>}\n<line51>if( next>0 ){\n<line52>/* Freeblock not in ascending order */\n<line53>return SQLITE_CORRUPT_PAGE(pPage);\n<line54>}\n<line55>if( pc+size>(unsigned int)usableSize ){\n<line56>/* Last freeblock extends past page end */\n<line57>return SQLITE_CORRUPT_PAGE(pPage);\n<line58>}\n<line59>}\n<line60>/* At this point, nFree contains the sum of the offset to the start\n<line61>** of the cell-content area plus the number of free bytes within\n<line62>** the cell-content area. If this is greater than the usable-size\n<line63>** of the page, then the page must be corrupted. This check also\n<line64>** serves to verify that the offset to the start of the cell-content\n<line65>** area, according to the page header, lies within the page.\n<line66>*/\n<line67>if( nFree>usableSize || nFree<iCellFirst ){\n<line68>return SQLITE_CORRUPT_PAGE(pPage);\n<line69>}\n<line70>pPage->nFree = (u16)(nFree - iCellFirst);\n<line71>return SQLITE_OK;\n<line72>}
----------------------------------------
Function: btreeCellSizeCheck
Content: <line0>static SQLITE_NOINLINE int btreeCellSizeCheck(MemPage *pPage){\n<line1>int iCellFirst;    /* First allowable cell or freeblock offset */\n<line2>int iCellLast;     /* Last possible cell or freeblock offset */\n<line3>int i;             /* Index into the cell pointer array */\n<line4>int sz;            /* Size of a cell */\n<line5>int pc;            /* Address of a freeblock within pPage->aData[] */\n<line6>u8 *data;          /* Equal to pPage->aData */\n<line7>int usableSize;    /* Maximum usable space on the page */\n<line8>int cellOffset;    /* Start of cell content area */\n<line9>iCellFirst = pPage->cellOffset + 2*pPage->nCell;\n<line10>usableSize = pPage->pBt->usableSize;\n<line11>iCellLast = usableSize - 4;\n<line12>data = pPage->aData;\n<line13>cellOffset = pPage->cellOffset;\n<line14>if( !pPage->leaf ) iCellLast--;\n<line15>for(i=0; i<pPage->nCell; i++){\n<line16>pc = get2byteAligned(&data[cellOffset+i*2]);\n<line17>testcase( pc==iCellFirst );\n<line18>testcase( pc==iCellLast );\n<line19>if( pc<iCellFirst || pc>iCellLast ){\n<line20>return SQLITE_CORRUPT_PAGE(pPage);\n<line21>}\n<line22>sz = pPage->xCellSize(pPage, &data[pc]);\n<line23>testcase( pc+sz==usableSize );\n<line24>if( pc+sz>usableSize ){\n<line25>return SQLITE_CORRUPT_PAGE(pPage);\n<line26>}\n<line27>}\n<line28>return SQLITE_OK;\n<line29>}
----------------------------------------
Function: btreeInitPage
Content: <line0>static int btreeInitPage(MemPage *pPage){\n<line1>u8 *data;          /* Equal to pPage->aData */\n<line2>BtShared *pBt;        /* The main btree structure */\n<line3>assert( pPage->pBt!=0 );\n<line4>assert( pPage->pBt->db!=0 );\n<line5>assert( sqlite3_mutex_held(pPage->pBt->mutex) );\n<line6>assert( pPage->pgno==sqlite3PagerPagenumber(pPage->pDbPage) );\n<line7>assert( pPage == sqlite3PagerGetExtra(pPage->pDbPage) );\n<line8>assert( pPage->aData == sqlite3PagerGetData(pPage->pDbPage) );\n<line9>assert( pPage->isInit==0 );\n<line10>pBt = pPage->pBt;\n<line11>data = pPage->aData + pPage->hdrOffset;\n<line12>/* EVIDENCE-OF: R-28594-02890 The one-byte flag at offset 0 indicating\n<line13>** the b-tree page type. */\n<line14>if( decodeFlags(pPage, data[0]) ){\n<line15>return SQLITE_CORRUPT_PAGE(pPage);\n<line16>}\n<line17>assert( pBt->pageSize>=512 && pBt->pageSize<=65536 );\n<line18>pPage->maskPage = (u16)(pBt->pageSize - 1);\n<line19>pPage->nOverflow = 0;\n<line20>pPage->cellOffset = (u16)(pPage->hdrOffset + 8 + pPage->childPtrSize);\n<line21>pPage->aCellIdx = data + pPage->childPtrSize + 8;\n<line22>pPage->aDataEnd = pPage->aData + pBt->pageSize;\n<line23>pPage->aDataOfst = pPage->aData + pPage->childPtrSize;\n<line24>/* EVIDENCE-OF: R-37002-32774 The two-byte integer at offset 3 gives the\n<line25>** number of cells on the page. */\n<line26>pPage->nCell = get2byte(&data[3]);\n<line27>if( pPage->nCell>MX_CELL(pBt) ){\n<line28>/* To many cells for a single page.  The page must be corrupt */\n<line29>return SQLITE_CORRUPT_PAGE(pPage);\n<line30>}\n<line31>testcase( pPage->nCell==MX_CELL(pBt) );\n<line32>/* EVIDENCE-OF: R-24089-57979 If a page contains no cells (which is only\n<line33>** possible for a root page of a table that contains no rows) then the\n<line34>** offset to the cell content area will equal the page size minus the\n<line35>** bytes of reserved space. */\n<line36>assert( pPage->nCell>0\n<line37>|| get2byteNotZero(&data[5])==(int)pBt->usableSize\n<line38>|| CORRUPT_DB );\n<line39>pPage->nFree = -1;  /* Indicate that this value is yet uncomputed */\n<line40>pPage->isInit = 1;\n<line41>if( pBt->db->flags & SQLITE_CellSizeCk ){\n<line42>return btreeCellSizeCheck(pPage);\n<line43>}\n<line44>return SQLITE_OK;\n<line45>}
----------------------------------------
Function: zeroPage
Content: <line0>static void zeroPage(MemPage *pPage, int flags){\n<line1>unsigned char *data = pPage->aData;\n<line2>BtShared *pBt = pPage->pBt;\n<line3>int hdr = pPage->hdrOffset;\n<line4>int first;\n<line5>assert( sqlite3PagerPagenumber(pPage->pDbPage)==pPage->pgno || CORRUPT_DB );\n<line6>assert( sqlite3PagerGetExtra(pPage->pDbPage) == (void*)pPage );\n<line7>assert( sqlite3PagerGetData(pPage->pDbPage) == data );\n<line8>assert( sqlite3PagerIswriteable(pPage->pDbPage) );\n<line9>assert( sqlite3_mutex_held(pBt->mutex) );\n<line10>if( pBt->btsFlags & BTS_FAST_SECURE ){\n<line11>memset(&data[hdr], 0, pBt->usableSize - hdr);\n<line12>}\n<line13>data[hdr] = (char)flags;\n<line14>first = hdr + ((flags&PTF_LEAF)==0 ? 12 : 8);\n<line15>memset(&data[hdr+1], 0, 4);\n<line16>data[hdr+7] = 0;\n<line17>put2byte(&data[hdr+5], pBt->usableSize);\n<line18>pPage->nFree = (u16)(pBt->usableSize - first);\n<line19>decodeFlags(pPage, flags);\n<line20>pPage->cellOffset = (u16)first;\n<line21>pPage->aDataEnd = &data[pBt->pageSize];\n<line22>pPage->aCellIdx = &data[first];\n<line23>pPage->aDataOfst = &data[pPage->childPtrSize];\n<line24>pPage->nOverflow = 0;\n<line25>assert( pBt->pageSize>=512 && pBt->pageSize<=65536 );\n<line26>pPage->maskPage = (u16)(pBt->pageSize - 1);\n<line27>pPage->nCell = 0;\n<line28>pPage->isInit = 1;\n<line29>}
----------------------------------------
Function: btreePageFromDbPage
Content: <line0>static MemPage *btreePageFromDbPage(DbPage *pDbPage, Pgno pgno, BtShared *pBt){\n<line1>MemPage *pPage = (MemPage*)sqlite3PagerGetExtra(pDbPage);\n<line2>if( pgno!=pPage->pgno ){\n<line3>pPage->aData = sqlite3PagerGetData(pDbPage);\n<line4>pPage->pDbPage = pDbPage;\n<line5>pPage->pBt = pBt;\n<line6>pPage->pgno = pgno;\n<line7>pPage->hdrOffset = pgno==1 ? 100 : 0;\n<line8>}\n<line9>assert( pPage->aData==sqlite3PagerGetData(pDbPage) );\n<line10>return pPage;\n<line11>}
----------------------------------------
Function: btreeGetPage
Content: <line0>static int btreeGetPage(\n<line1>BtShared *pBt,       /* The btree */\n<line2>Pgno pgno,           /* Number of the page to fetch */\n<line3>MemPage **ppPage,    /* Return the page in this parameter */\n<line4>int flags            /* PAGER_GET_NOCONTENT or PAGER_GET_READONLY */\n<line5>){\n<line6>int rc;\n<line7>DbPage *pDbPage;\n<line8>assert( flags==0 || flags==PAGER_GET_NOCONTENT || flags==PAGER_GET_READONLY );\n<line9>assert( sqlite3_mutex_held(pBt->mutex) );\n<line10>rc = sqlite3PagerGet(pBt->pPager, pgno, (DbPage**)&pDbPage, flags);\n<line11>if( rc ) return rc;\n<line12>*ppPage = btreePageFromDbPage(pDbPage, pgno, pBt);\n<line13>return SQLITE_OK;\n<line14>}
----------------------------------------
Function: btreePageLookup
Content: <line0>static MemPage *btreePageLookup(BtShared *pBt, Pgno pgno){\n<line1>DbPage *pDbPage;\n<line2>assert( sqlite3_mutex_held(pBt->mutex) );\n<line3>pDbPage = sqlite3PagerLookup(pBt->pPager, pgno);\n<line4>if( pDbPage ){\n<line5>return btreePageFromDbPage(pDbPage, pgno, pBt);\n<line6>}\n<line7>return 0;\n<line8>}
----------------------------------------
Function: btreePagecount
Content: <line0>static Pgno btreePagecount(BtShared *pBt){\n<line1>return pBt->nPage;\n<line2>}
----------------------------------------
Function: getAndInitPage
Content: <line0>static int getAndInitPage(\n<line1>BtShared *pBt,                  /* The database file */\n<line2>Pgno pgno,                      /* Number of the page to get */\n<line3>MemPage **ppPage,               /* Write the page pointer here */\n<line4>int bReadOnly                   /* True for a read-only page */\n<line5>){\n<line6>int rc;\n<line7>DbPage *pDbPage;\n<line8>MemPage *pPage;\n<line9>assert( sqlite3_mutex_held(pBt->mutex) );\n<line10>if( pgno>btreePagecount(pBt) ){\n<line11>*ppPage = 0;\n<line12>return SQLITE_CORRUPT_BKPT;\n<line13>}\n<line14>rc = sqlite3PagerGet(pBt->pPager, pgno, (DbPage**)&pDbPage, bReadOnly);\n<line15>if( rc ){\n<line16>*ppPage = 0;\n<line17>return rc;\n<line18>}\n<line19>pPage = (MemPage*)sqlite3PagerGetExtra(pDbPage);\n<line20>if( pPage->isInit==0 ){\n<line21>btreePageFromDbPage(pDbPage, pgno, pBt);\n<line22>rc = btreeInitPage(pPage);\n<line23>if( rc!=SQLITE_OK ){\n<line24>releasePage(pPage);\n<line25>*ppPage = 0;\n<line26>return rc;\n<line27>}\n<line28>}\n<line29>assert( pPage->pgno==pgno || CORRUPT_DB );\n<line30>assert( pPage->aData==sqlite3PagerGetData(pDbPage) );\n<line31>*ppPage = pPage;\n<line32>return SQLITE_OK;\n<line33>}
----------------------------------------
Function: releasePageNotNull
Content: <line0>static void releasePageNotNull(MemPage *pPage){\n<line1>assert( pPage->aData );\n<line2>assert( pPage->pBt );\n<line3>assert( pPage->pDbPage!=0 );\n<line4>assert( sqlite3PagerGetExtra(pPage->pDbPage) == (void*)pPage );\n<line5>assert( sqlite3PagerGetData(pPage->pDbPage)==pPage->aData );\n<line6>assert( sqlite3_mutex_held(pPage->pBt->mutex) );\n<line7>sqlite3PagerUnrefNotNull(pPage->pDbPage);\n<line8>}
----------------------------------------
Function: releasePage
Content: <line0>static void releasePage(MemPage *pPage){\n<line1>if( pPage ) releasePageNotNull(pPage);\n<line2>}
----------------------------------------
Function: releasePageOne
Content: <line0>static void releasePageOne(MemPage *pPage){\n<line1>assert( pPage!=0 );\n<line2>assert( pPage->aData );\n<line3>assert( pPage->pBt );\n<line4>assert( pPage->pDbPage!=0 );\n<line5>assert( sqlite3PagerGetExtra(pPage->pDbPage) == (void*)pPage );\n<line6>assert( sqlite3PagerGetData(pPage->pDbPage)==pPage->aData );\n<line7>assert( sqlite3_mutex_held(pPage->pBt->mutex) );\n<line8>sqlite3PagerUnrefPageOne(pPage->pDbPage);\n<line9>}
----------------------------------------
Function: btreeGetUnusedPage
Content: <line0>static int btreeGetUnusedPage(\n<line1>BtShared *pBt,       /* The btree */\n<line2>Pgno pgno,           /* Number of the page to fetch */\n<line3>MemPage **ppPage,    /* Return the page in this parameter */\n<line4>int flags            /* PAGER_GET_NOCONTENT or PAGER_GET_READONLY */\n<line5>){\n<line6>int rc = btreeGetPage(pBt, pgno, ppPage, flags);\n<line7>if( rc==SQLITE_OK ){\n<line8>if( sqlite3PagerPageRefcount((*ppPage)->pDbPage)>1 ){\n<line9>releasePage(*ppPage);\n<line10>*ppPage = 0;\n<line11>return SQLITE_CORRUPT_BKPT;\n<line12>}\n<line13>(*ppPage)->isInit = 0;\n<line14>}else{\n<line15>*ppPage = 0;\n<line16>}\n<line17>return rc;\n<line18>}
----------------------------------------
Function: pageReinit
Content: <line0>static void pageReinit(DbPage *pData){\n<line1>MemPage *pPage;\n<line2>pPage = (MemPage *)sqlite3PagerGetExtra(pData);\n<line3>assert( sqlite3PagerPageRefcount(pData)>0 );\n<line4>if( pPage->isInit ){\n<line5>assert( sqlite3_mutex_held(pPage->pBt->mutex) );\n<line6>pPage->isInit = 0;\n<line7>if( sqlite3PagerPageRefcount(pData)>1 ){\n<line8>/* pPage might not be a btree page;  it might be an overflow page\n<line9>** or ptrmap page or a free page.  In those cases, the following\n<line10>** call to btreeInitPage() will likely return SQLITE_CORRUPT.\n<line11>** But no harm is done by this.  And it is very important that\n<line12>** btreeInitPage() be called on every btree page so we make\n<line13>** the call for every page that comes in for re-initializing. */\n<line14>btreeInitPage(pPage);\n<line15>}\n<line16>}\n<line17>}
----------------------------------------
Function: btreeInvokeBusyHandler
Content: <line0>static int btreeInvokeBusyHandler(void *pArg){\n<line1>BtShared *pBt = (BtShared*)pArg;\n<line2>assert( pBt->db );\n<line3>assert( sqlite3_mutex_held(pBt->db->mutex) );\n<line4>return sqlite3InvokeBusyHandler(&pBt->db->busyHandler);\n<line5>}
----------------------------------------
Function: removeFromSharingList
Content: <line0>static int removeFromSharingList(BtShared *pBt){\n<line1>#ifndef SQLITE_OMIT_SHARED_CACHE\n<line2>MUTEX_LOGIC( sqlite3_mutex *pMainMtx; )\n<line3>BtShared *pList;\n<line4>int removed = 0;\n<line5>assert( sqlite3_mutex_notheld(pBt->mutex) );\n<line6>MUTEX_LOGIC( pMainMtx = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MAIN); )\n<line7>sqlite3_mutex_enter(pMainMtx);\n<line8>pBt->nRef--;\n<line9>if( pBt->nRef<=0 ){\n<line10>if( GLOBAL(BtShared*,sqlite3SharedCacheList)==pBt ){\n<line11>GLOBAL(BtShared*,sqlite3SharedCacheList) = pBt->pNext;\n<line12>}else{\n<line13>pList = GLOBAL(BtShared*,sqlite3SharedCacheList);\n<line14>while( ALWAYS(pList) && pList->pNext!=pBt ){\n<line15>pList=pList->pNext;\n<line16>}\n<line17>if( ALWAYS(pList) ){\n<line18>pList->pNext = pBt->pNext;\n<line19>}\n<line20>}\n<line21>if( SQLITE_THREADSAFE ){\n<line22>sqlite3_mutex_free(pBt->mutex);\n<line23>}\n<line24>removed = 1;\n<line25>}\n<line26>sqlite3_mutex_leave(pMainMtx);\n<line27>return removed;\n<line28>#else\n<line29>UNUSED_PARAMETER( pBt );\n<line30>return 1;\n<line31>#endif\n<line32>}
----------------------------------------
Function: allocateTempSpace
Content: <line0>static SQLITE_NOINLINE int allocateTempSpace(BtShared *pBt){\n<line1>assert( pBt!=0 );\n<line2>assert( pBt->pTmpSpace==0 );\n<line3>/* This routine is called only by btreeCursor() when allocating the\n<line4>** first write cursor for the BtShared object */\n<line5>assert( pBt->pCursor!=0 && (pBt->pCursor->curFlags & BTCF_WriteFlag)!=0 );\n<line6>pBt->pTmpSpace = sqlite3PageMalloc( pBt->pageSize );\n<line7>if( pBt->pTmpSpace==0 ){\n<line8>BtCursor *pCur = pBt->pCursor;\n<line9>pBt->pCursor = pCur->pNext;  /* Unlink the cursor */\n<line10>memset(pCur, 0, sizeof(*pCur));\n<line11>return SQLITE_NOMEM_BKPT;\n<line12>}\n<line13>/* One of the uses of pBt->pTmpSpace is to format cells before\n<line14>** inserting them into a leaf page (function fillInCell()). If\n<line15>** a cell is less than 4 bytes in size, it is rounded up to 4 bytes\n<line16>** by the various routines that manipulate binary cells. Which\n<line17>** can mean that fillInCell() only initializes the first 2 or 3\n<line18>** bytes of pTmpSpace, but that the first 4 bytes are copied from\n<line19>** it into a database page. This is not actually a problem, but it\n<line20>** does cause a valgrind error when the 1 or 2 bytes of uninitialized\n<line21>** data is passed to system call write(). So to avoid this error,\n<line22>** zero the first 4 bytes of temp space here.\n<line23>**\n<line24>** Also:  Provide four bytes of initialized space before the\n<line25>** beginning of pTmpSpace as an area available to prepend the\n<line26>** left-child pointer to the beginning of a cell.\n<line27>*/\n<line28>memset(pBt->pTmpSpace, 0, 8);\n<line29>pBt->pTmpSpace += 4;\n<line30>return SQLITE_OK;\n<line31>}
----------------------------------------
Function: freeTempSpace
Content: <line0>static void freeTempSpace(BtShared *pBt){\n<line1>if( pBt->pTmpSpace ){\n<line2>pBt->pTmpSpace -= 4;\n<line3>sqlite3PageFree(pBt->pTmpSpace);\n<line4>pBt->pTmpSpace = 0;\n<line5>}\n<line6>}
----------------------------------------
Function: lockBtree
Content: <line0>static int lockBtree(BtShared *pBt){\n<line1>int rc;              /* Result code from subfunctions */\n<line2>MemPage *pPage1;     /* Page 1 of the database file */\n<line3>u32 nPage;           /* Number of pages in the database */\n<line4>u32 nPageFile = 0;   /* Number of pages in the database file */\n<line5>assert( sqlite3_mutex_held(pBt->mutex) );\n<line6>assert( pBt->pPage1==0 );\n<line7>rc = sqlite3PagerSharedLock(pBt->pPager);\n<line8>if( rc!=SQLITE_OK ) return rc;\n<line9>rc = btreeGetPage(pBt, 1, &pPage1, 0);\n<line10>if( rc!=SQLITE_OK ) return rc;\n<line11>/* Do some checking to help insure the file we opened really is\n<line12>** a valid database file.\n<line13>*/\n<line14>nPage = get4byte(28+(u8*)pPage1->aData);\n<line15>sqlite3PagerPagecount(pBt->pPager, (int*)&nPageFile);\n<line16>if( nPage==0 || memcmp(24+(u8*)pPage1->aData, 92+(u8*)pPage1->aData,4)!=0 ){\n<line17>nPage = nPageFile;\n<line18>}\n<line19>if( (pBt->db->flags & SQLITE_ResetDatabase)!=0 ){\n<line20>nPage = 0;\n<line21>}\n<line22>if( nPage>0 ){\n<line23>u32 pageSize;\n<line24>u32 usableSize;\n<line25>u8 *page1 = pPage1->aData;\n<line26>rc = SQLITE_NOTADB;\n<line27>/* EVIDENCE-OF: R-43737-39999 Every valid SQLite database file begins\n<line28>** with the following 16 bytes (in hex): 53 51 4c 69 74 65 20 66 6f 72 6d\n<line29>** 61 74 20 33 00. */\n<line30>if( memcmp(page1, zMagicHeader, 16)!=0 ){\n<line31>goto page1_init_failed;\n<line32>}\n<line33>#ifdef SQLITE_OMIT_WAL\n<line34>if( page1[18]>1 ){\n<line35>pBt->btsFlags |= BTS_READ_ONLY;\n<line36>}\n<line37>if( page1[19]>1 ){\n<line38>goto page1_init_failed;\n<line39>}\n<line40>#else\n<line41>if( page1[18]>2 ){\n<line42>pBt->btsFlags |= BTS_READ_ONLY;\n<line43>}\n<line44>if( page1[19]>2 ){\n<line45>goto page1_init_failed;\n<line46>}\n<line47>/* If the read version is set to 2, this database should be accessed\n<line48>** in WAL mode. If the log is not already open, open it now. Then\n<line49>** return SQLITE_OK and return without populating BtShared.pPage1.\n<line50>** The caller detects this and calls this function again. This is\n<line51>** required as the version of page 1 currently in the page1 buffer\n<line52>** may not be the latest version - there may be a newer one in the log\n<line53>** file.\n<line54>*/\n<line55>if( page1[19]==2 && (pBt->btsFlags & BTS_NO_WAL)==0 ){\n<line56>int isOpen = 0;\n<line57>rc = sqlite3PagerOpenWal(pBt->pPager, &isOpen);\n<line58>if( rc!=SQLITE_OK ){\n<line59>goto page1_init_failed;\n<line60>}else{\n<line61>setDefaultSyncFlag(pBt, SQLITE_DEFAULT_WAL_SYNCHRONOUS+1);\n<line62>if( isOpen==0 ){\n<line63>releasePageOne(pPage1);\n<line64>return SQLITE_OK;\n<line65>}\n<line66>}\n<line67>rc = SQLITE_NOTADB;\n<line68>}else{\n<line69>setDefaultSyncFlag(pBt, SQLITE_DEFAULT_SYNCHRONOUS+1);\n<line70>}\n<line71>#endif\n<line72>/* EVIDENCE-OF: R-15465-20813 The maximum and minimum embedded payload\n<line73>** fractions and the leaf payload fraction values must be 64, 32, and 32.\n<line74>**\n<line75>** The original design allowed these amounts to vary, but as of\n<line76>** version 3.6.0, we require them to be fixed.\n<line77>*/\n<line78>if( memcmp(&page1[21], "\100\040\040",3)!=0 ){\n<line79>goto page1_init_failed;\n<line80>}\n<line81>/* EVIDENCE-OF: R-51873-39618 The page size for a database file is\n<line82>** determined by the 2-byte integer located at an offset of 16 bytes from\n<line83>** the beginning of the database file. */\n<line84>pageSize = (page1[16]<<8) | (page1[17]<<16);\n<line85>/* EVIDENCE-OF: R-25008-21688 The size of a page is a power of two\n<line86>** between 512 and 65536 inclusive. */\n<line87>if( ((pageSize-1)&pageSize)!=0\n<line88>|| pageSize>SQLITE_MAX_PAGE_SIZE\n<line89>|| pageSize<=256\n<line90>){\n<line91>goto page1_init_failed;\n<line92>}\n<line93>assert( (pageSize & 7)==0 );\n<line94>/* EVIDENCE-OF: R-59310-51205 The "reserved space" size in the 1-byte\n<line95>** integer at offset 20 is the number of bytes of space at the end of\n<line96>** each page to reserve for extensions.\n<line97>**\n<line98>** EVIDENCE-OF: R-37497-42412 The size of the reserved region is\n<line99>** determined by the one-byte unsigned integer found at an offset of 20\n<line100>** into the database file header. */\n<line101>usableSize = pageSize - page1[20];\n<line102>if( (u32)pageSize!=pBt->pageSize ){\n<line103>/* After reading the first page of the database assuming a page size\n<line104>** of BtShared.pageSize, we have discovered that the page-size is\n<line105>** actually pageSize. Unlock the database, leave pBt->pPage1 at\n<line106>** zero and return SQLITE_OK. The caller will call this function\n<line107>** again with the correct page-size.\n<line108>*/\n<line109>releasePageOne(pPage1);\n<line110>pBt->usableSize = usableSize;\n<line111>pBt->pageSize = pageSize;\n<line112>pBt->btsFlags |= BTS_PAGESIZE_FIXED;\n<line113>freeTempSpace(pBt);\n<line114>rc = sqlite3PagerSetPagesize(pBt->pPager, &pBt->pageSize,\n<line115>pageSize-usableSize);\n<line116>return rc;\n<line117>}\n<line118>if( nPage>nPageFile ){\n<line119>if( sqlite3WritableSchema(pBt->db)==0 ){\n<line120>rc = SQLITE_CORRUPT_BKPT;\n<line121>goto page1_init_failed;\n<line122>}else{\n<line123>nPage = nPageFile;\n<line124>}\n<line125>}\n<line126>/* EVIDENCE-OF: R-28312-64704 However, the usable size is not allowed to\n<line127>** be less than 480. In other words, if the page size is 512, then the\n<line128>** reserved space size cannot exceed 32. */\n<line129>if( usableSize<480 ){\n<line130>goto page1_init_failed;\n<line131>}\n<line132>pBt->btsFlags |= BTS_PAGESIZE_FIXED;\n<line133>pBt->pageSize = pageSize;\n<line134>pBt->usableSize = usableSize;\n<line135>#ifndef SQLITE_OMIT_AUTOVACUUM\n<line136>pBt->autoVacuum = (get4byte(&page1[36 + 4*4])?1:0);\n<line137>pBt->incrVacuum = (get4byte(&page1[36 + 7*4])?1:0);\n<line138>#endif\n<line139>}\n<line140>/* maxLocal is the maximum amount of payload to store locally for\n<line141>** a cell.  Make sure it is small enough so that at least minFanout\n<line142>** cells can will fit on one page.  We assume a 10-byte page header.\n<line143>** Besides the payload, the cell must store:\n<line144>**     2-byte pointer to the cell\n<line145>**     4-byte child pointer\n<line146>**     9-byte nKey value\n<line147>**     4-byte nData value\n<line148>**     4-byte overflow page pointer\n<line149>** So a cell consists of a 2-byte pointer, a header which is as much as\n<line150>** 17 bytes long, 0 to N bytes of payload, and an optional 4 byte overflow\n<line151>** page pointer.\n<line152>*/\n<line153>pBt->maxLocal = (u16)((pBt->usableSize-12)*64/255 - 23);\n<line154>pBt->minLocal = (u16)((pBt->usableSize-12)*32/255 - 23);\n<line155>pBt->maxLeaf = (u16)(pBt->usableSize - 35);\n<line156>pBt->minLeaf = (u16)((pBt->usableSize-12)*32/255 - 23);\n<line157>if( pBt->maxLocal>127 ){\n<line158>pBt->max1bytePayload = 127;\n<line159>}else{\n<line160>pBt->max1bytePayload = (u8)pBt->maxLocal;\n<line161>}\n<line162>assert( pBt->maxLeaf + 23 <= MX_CELL_SIZE(pBt) );\n<line163>pBt->pPage1 = pPage1;\n<line164>pBt->nPage = nPage;\n<line165>return SQLITE_OK;\n<line166>page1_init_failed:\n<line167>releasePageOne(pPage1);\n<line168>pBt->pPage1 = 0;\n<line169>return rc;\n<line170>}
----------------------------------------
Function: unlockBtreeIfUnused
Content: <line0>static void unlockBtreeIfUnused(BtShared *pBt){\n<line1>assert( sqlite3_mutex_held(pBt->mutex) );\n<line2>assert( countValidCursors(pBt,0)==0 || pBt->inTransaction>TRANS_NONE );\n<line3>if( pBt->inTransaction==TRANS_NONE && pBt->pPage1!=0 ){\n<line4>MemPage *pPage1 = pBt->pPage1;\n<line5>assert( pPage1->aData );\n<line6>assert( sqlite3PagerRefcount(pBt->pPager)==1 );\n<line7>pBt->pPage1 = 0;\n<line8>releasePageOne(pPage1);\n<line9>}\n<line10>}
----------------------------------------
Function: newDatabase
Content: <line0>static int newDatabase(BtShared *pBt){\n<line1>MemPage *pP1;\n<line2>unsigned char *data;\n<line3>int rc;\n<line4>assert( sqlite3_mutex_held(pBt->mutex) );\n<line5>if( pBt->nPage>0 ){\n<line6>return SQLITE_OK;\n<line7>}\n<line8>pP1 = pBt->pPage1;\n<line9>assert( pP1!=0 );\n<line10>data = pP1->aData;\n<line11>rc = sqlite3PagerWrite(pP1->pDbPage);\n<line12>if( rc ) return rc;\n<line13>memcpy(data, zMagicHeader, sizeof(zMagicHeader));\n<line14>assert( sizeof(zMagicHeader)==16 );\n<line15>data[16] = (u8)((pBt->pageSize>>8)&0xff);\n<line16>data[17] = (u8)((pBt->pageSize>>16)&0xff);\n<line17>data[18] = 1;\n<line18>data[19] = 1;\n<line19>assert( pBt->usableSize<=pBt->pageSize && pBt->usableSize+255>=pBt->pageSize);\n<line20>data[20] = (u8)(pBt->pageSize - pBt->usableSize);\n<line21>data[21] = 64;\n<line22>data[22] = 32;\n<line23>data[23] = 32;\n<line24>memset(&data[24], 0, 100-24);\n<line25>zeroPage(pP1, PTF_INTKEY|PTF_LEAF|PTF_LEAFDATA );\n<line26>pBt->btsFlags |= BTS_PAGESIZE_FIXED;\n<line27>#ifndef SQLITE_OMIT_AUTOVACUUM\n<line28>assert( pBt->autoVacuum==1 || pBt->autoVacuum==0 );\n<line29>assert( pBt->incrVacuum==1 || pBt->incrVacuum==0 );\n<line30>put4byte(&data[36 + 4*4], pBt->autoVacuum);\n<line31>put4byte(&data[36 + 7*4], pBt->incrVacuum);\n<line32>#endif\n<line33>pBt->nPage = 1;\n<line34>data[31] = 1;\n<line35>return SQLITE_OK;\n<line36>}
----------------------------------------
Function: btreeBeginTrans
Content: <line0>static SQLITE_NOINLINE int btreeBeginTrans(\n<line1>Btree *p,                 /* The btree in which to start the transaction */\n<line2>int wrflag,               /* True to start a write transaction */\n<line3>int *pSchemaVersion       /* Put schema version number here, if not NULL */\n<line4>){\n<line5>BtShared *pBt = p->pBt;\n<line6>Pager *pPager = pBt->pPager;\n<line7>int rc = SQLITE_OK;\n<line8>sqlite3BtreeEnter(p);\n<line9>btreeIntegrity(p);\n<line10>/* If the btree is already in a write-transaction, or it\n<line11>** is already in a read-transaction and a read-transaction\n<line12>** is requested, this is a no-op.\n<line13>*/\n<line14>if( p->inTrans==TRANS_WRITE || (p->inTrans==TRANS_READ && !wrflag) ){\n<line15>goto trans_begun;\n<line16>}\n<line17>assert( pBt->inTransaction==TRANS_WRITE || IfNotOmitAV(pBt->bDoTruncate)==0 );\n<line18>if( (p->db->flags & SQLITE_ResetDatabase)\n<line19>&& sqlite3PagerIsreadonly(pPager)==0\n<line20>){\n<line21>pBt->btsFlags &= ~BTS_READ_ONLY;\n<line22>}\n<line23>/* Write transactions are not possible on a read-only database */\n<line24>if( (pBt->btsFlags & BTS_READ_ONLY)!=0 && wrflag ){\n<line25>rc = SQLITE_READONLY;\n<line26>goto trans_begun;\n<line27>}\n<line28>#ifndef SQLITE_OMIT_SHARED_CACHE\n<line29>{\n<line30>sqlite3 *pBlock = 0;\n<line31>/* If another database handle has already opened a write transaction\n<line32>** on this shared-btree structure and a second write transaction is\n<line33>** requested, return SQLITE_LOCKED.\n<line34>*/\n<line35>if( (wrflag && pBt->inTransaction==TRANS_WRITE)\n<line36>|| (pBt->btsFlags & BTS_PENDING)!=0\n<line37>){\n<line38>pBlock = pBt->pWriter->db;\n<line39>}else if( wrflag>1 ){\n<line40>BtLock *pIter;\n<line41>for(pIter=pBt->pLock; pIter; pIter=pIter->pNext){\n<line42>if( pIter->pBtree!=p ){\n<line43>pBlock = pIter->pBtree->db;\n<line44>break;\n<line45>}\n<line46>}\n<line47>}\n<line48>if( pBlock ){\n<line49>sqlite3ConnectionBlocked(p->db, pBlock);\n<line50>rc = SQLITE_LOCKED_SHAREDCACHE;\n<line51>goto trans_begun;\n<line52>}\n<line53>}\n<line54>#endif\n<line55>/* Any read-only or read-write transaction implies a read-lock on\n<line56>** page 1. So if some other shared-cache client already has a write-lock\n<line57>** on page 1, the transaction cannot be opened. */\n<line58>rc = querySharedCacheTableLock(p, SCHEMA_ROOT, READ_LOCK);\n<line59>if( SQLITE_OK!=rc ) goto trans_begun;\n<line60>pBt->btsFlags &= ~BTS_INITIALLY_EMPTY;\n<line61>if( pBt->nPage==0 ) pBt->btsFlags |= BTS_INITIALLY_EMPTY;\n<line62>do {\n<line63>sqlite3PagerWalDb(pPager, p->db);\n<line64>#ifdef SQLITE_ENABLE_SETLK_TIMEOUT\n<line65>/* If transitioning from no transaction directly to a write transaction,\n<line66>** block for the WRITER lock first if possible. */\n<line67>if( pBt->pPage1==0 && wrflag ){\n<line68>assert( pBt->inTransaction==TRANS_NONE );\n<line69>rc = sqlite3PagerWalWriteLock(pPager, 1);\n<line70>if( rc!=SQLITE_BUSY && rc!=SQLITE_OK ) break;\n<line71>}\n<line72>#endif\n<line73>/* Call lockBtree() until either pBt->pPage1 is populated or\n<line74>** lockBtree() returns something other than SQLITE_OK. lockBtree()\n<line75>** may return SQLITE_OK but leave pBt->pPage1 set to 0 if after\n<line76>** reading page 1 it discovers that the page-size of the database\n<line77>** file is not pBt->pageSize. In this case lockBtree() will update\n<line78>** pBt->pageSize to the page-size of the file on disk.\n<line79>*/\n<line80>while( pBt->pPage1==0 && SQLITE_OK==(rc = lockBtree(pBt)) );\n<line81>if( rc==SQLITE_OK && wrflag ){\n<line82>if( (pBt->btsFlags & BTS_READ_ONLY)!=0 ){\n<line83>rc = SQLITE_READONLY;\n<line84>}else{\n<line85>rc = sqlite3PagerBegin(pPager, wrflag>1, sqlite3TempInMemory(p->db));\n<line86>if( rc==SQLITE_OK ){\n<line87>rc = newDatabase(pBt);\n<line88>}else if( rc==SQLITE_BUSY_SNAPSHOT && pBt->inTransaction==TRANS_NONE ){\n<line89>/* if there was no transaction opened when this function was\n<line90>** called and SQLITE_BUSY_SNAPSHOT is returned, change the error\n<line91>** code to SQLITE_BUSY. */\n<line92>rc = SQLITE_BUSY;\n<line93>}\n<line94>}\n<line95>}\n<line96>if( rc!=SQLITE_OK ){\n<line97>(void)sqlite3PagerWalWriteLock(pPager, 0);\n<line98>unlockBtreeIfUnused(pBt);\n<line99>}\n<line100>#if defined(SQLITE_ENABLE_SETLK_TIMEOUT)\n<line101>if( rc==SQLITE_BUSY_TIMEOUT ){\n<line102>/* If a blocking lock timed out, break out of the loop here so that\n<line103>** the busy-handler is not invoked.  */\n<line104>break;\n<line105>}\n<line106>#endif\n<line107>}while( (rc&0xFF)==SQLITE_BUSY && pBt->inTransaction==TRANS_NONE &&\n<line108>btreeInvokeBusyHandler(pBt) );\n<line109>sqlite3PagerWalDb(pPager, 0);\n<line110>#ifdef SQLITE_ENABLE_SETLK_TIMEOUT\n<line111>if( rc==SQLITE_BUSY_TIMEOUT ) rc = SQLITE_BUSY;\n<line112>#endif\n<line113>if( rc==SQLITE_OK ){\n<line114>if( p->inTrans==TRANS_NONE ){\n<line115>pBt->nTransaction++;\n<line116>#ifndef SQLITE_OMIT_SHARED_CACHE\n<line117>if( p->sharable ){\n<line118>assert( p->lock.pBtree==p && p->lock.iTable==1 );\n<line119>p->lock.eLock = READ_LOCK;\n<line120>p->lock.pNext = pBt->pLock;\n<line121>pBt->pLock = &p->lock;\n<line122>}\n<line123>#endif\n<line124>}\n<line125>p->inTrans = (wrflag?TRANS_WRITE:TRANS_READ);\n<line126>if( p->inTrans>pBt->inTransaction ){\n<line127>pBt->inTransaction = p->inTrans;\n<line128>}\n<line129>if( wrflag ){\n<line130>MemPage *pPage1 = pBt->pPage1;\n<line131>#ifndef SQLITE_OMIT_SHARED_CACHE\n<line132>assert( !pBt->pWriter );\n<line133>pBt->pWriter = p;\n<line134>pBt->btsFlags &= ~BTS_EXCLUSIVE;\n<line135>if( wrflag>1 ) pBt->btsFlags |= BTS_EXCLUSIVE;\n<line136>#endif\n<line137>/* If the db-size header field is incorrect (as it may be if an old\n<line138>** client has been writing the database file), update it now. Doing\n<line139>** this sooner rather than later means the database size can safely\n<line140>** re-read the database size from page 1 if a savepoint or transaction\n<line141>** rollback occurs within the transaction.\n<line142>*/\n<line143>if( pBt->nPage!=get4byte(&pPage1->aData[28]) ){\n<line144>rc = sqlite3PagerWrite(pPage1->pDbPage);\n<line145>if( rc==SQLITE_OK ){\n<line146>put4byte(&pPage1->aData[28], pBt->nPage);\n<line147>}\n<line148>}\n<line149>}\n<line150>}\n<line151>trans_begun:\n<line152>if( rc==SQLITE_OK ){\n<line153>if( pSchemaVersion ){\n<line154>*pSchemaVersion = get4byte(&pBt->pPage1->aData[40]);\n<line155>}\n<line156>if( wrflag ){\n<line157>/* This call makes sure that the pager has the correct number of\n<line158>** open savepoints. If the second parameter is greater than 0 and\n<line159>** the sub-journal is not already open, then it will be opened here.\n<line160>*/\n<line161>rc = sqlite3PagerOpenSavepoint(pPager, p->db->nSavepoint);\n<line162>}\n<line163>}\n<line164>btreeIntegrity(p);\n<line165>sqlite3BtreeLeave(p);\n<line166>return rc;\n<line167>}
----------------------------------------
Function: setChildPtrmaps
Content: <line0>static int setChildPtrmaps(MemPage *pPage){\n<line1>int i;                             /* Counter variable */\n<line2>int nCell;                         /* Number of cells in page pPage */\n<line3>int rc;                            /* Return code */\n<line4>BtShared *pBt = pPage->pBt;\n<line5>Pgno pgno = pPage->pgno;\n<line6>assert( sqlite3_mutex_held(pPage->pBt->mutex) );\n<line7>rc = pPage->isInit ? SQLITE_OK : btreeInitPage(pPage);\n<line8>if( rc!=SQLITE_OK ) return rc;\n<line9>nCell = pPage->nCell;\n<line10>for(i=0; i<nCell; i++){\n<line11>u8 *pCell = findCell(pPage, i);\n<line12>ptrmapPutOvflPtr(pPage, pPage, pCell, &rc);\n<line13>if( !pPage->leaf ){\n<line14>Pgno childPgno = get4byte(pCell);\n<line15>ptrmapPut(pBt, childPgno, PTRMAP_BTREE, pgno, &rc);\n<line16>}\n<line17>}\n<line18>if( !pPage->leaf ){\n<line19>Pgno childPgno = get4byte(&pPage->aData[pPage->hdrOffset+8]);\n<line20>ptrmapPut(pBt, childPgno, PTRMAP_BTREE, pgno, &rc);\n<line21>}\n<line22>return rc;\n<line23>}
----------------------------------------
Function: modifyPagePointer
Content: <line0>static int modifyPagePointer(MemPage *pPage, Pgno iFrom, Pgno iTo, u8 eType){\n<line1>assert( sqlite3_mutex_held(pPage->pBt->mutex) );\n<line2>assert( sqlite3PagerIswriteable(pPage->pDbPage) );\n<line3>if( eType==PTRMAP_OVERFLOW2 ){\n<line4>/* The pointer is always the first 4 bytes of the page in this case.  */\n<line5>if( get4byte(pPage->aData)!=iFrom ){\n<line6>return SQLITE_CORRUPT_PAGE(pPage);\n<line7>}\n<line8>put4byte(pPage->aData, iTo);\n<line9>}else{\n<line10>int i;\n<line11>int nCell;\n<line12>int rc;\n<line13>rc = pPage->isInit ? SQLITE_OK : btreeInitPage(pPage);\n<line14>if( rc ) return rc;\n<line15>nCell = pPage->nCell;\n<line16>for(i=0; i<nCell; i++){\n<line17>u8 *pCell = findCell(pPage, i);\n<line18>if( eType==PTRMAP_OVERFLOW1 ){\n<line19>CellInfo info;\n<line20>pPage->xParseCell(pPage, pCell, &info);\n<line21>if( info.nLocal<info.nPayload ){\n<line22>if( pCell+info.nSize > pPage->aData+pPage->pBt->usableSize ){\n<line23>return SQLITE_CORRUPT_PAGE(pPage);\n<line24>}\n<line25>if( iFrom==get4byte(pCell+info.nSize-4) ){\n<line26>put4byte(pCell+info.nSize-4, iTo);\n<line27>break;\n<line28>}\n<line29>}\n<line30>}else{\n<line31>if( pCell+4 > pPage->aData+pPage->pBt->usableSize ){\n<line32>return SQLITE_CORRUPT_PAGE(pPage);\n<line33>}\n<line34>if( get4byte(pCell)==iFrom ){\n<line35>put4byte(pCell, iTo);\n<line36>break;\n<line37>}\n<line38>}\n<line39>}\n<line40>if( i==nCell ){\n<line41>if( eType!=PTRMAP_BTREE ||\n<line42>get4byte(&pPage->aData[pPage->hdrOffset+8])!=iFrom ){\n<line43>return SQLITE_CORRUPT_PAGE(pPage);\n<line44>}\n<line45>put4byte(&pPage->aData[pPage->hdrOffset+8], iTo);\n<line46>}\n<line47>}\n<line48>return SQLITE_OK;\n<line49>}
----------------------------------------
Function: relocatePage
Content: <line0>static int relocatePage(\n<line1>BtShared *pBt,           /* Btree */\n<line2>MemPage *pDbPage,        /* Open page to move */\n<line3>u8 eType,                /* Pointer map 'type' entry for pDbPage */\n<line4>Pgno iPtrPage,           /* Pointer map 'page-no' entry for pDbPage */\n<line5>Pgno iFreePage,          /* The location to move pDbPage to */\n<line6>int isCommit             /* isCommit flag passed to sqlite3PagerMovepage */\n<line7>){\n<line8>MemPage *pPtrPage;   /* The page that contains a pointer to pDbPage */\n<line9>Pgno iDbPage = pDbPage->pgno;\n<line10>Pager *pPager = pBt->pPager;\n<line11>int rc;\n<line12>assert( eType==PTRMAP_OVERFLOW2 || eType==PTRMAP_OVERFLOW1 ||\n<line13>eType==PTRMAP_BTREE || eType==PTRMAP_ROOTPAGE );\n<line14>assert( sqlite3_mutex_held(pBt->mutex) );\n<line15>assert( pDbPage->pBt==pBt );\n<line16>if( iDbPage<3 ) return SQLITE_CORRUPT_BKPT;\n<line17>/* Move page iDbPage from its current location to page number iFreePage */\n<line18>TRACE(("AUTOVACUUM: Moving %u to free page %u (ptr page %u type %u)\n",\n<line19>iDbPage, iFreePage, iPtrPage, eType));\n<line20>rc = sqlite3PagerMovepage(pPager, pDbPage->pDbPage, iFreePage, isCommit);\n<line21>if( rc!=SQLITE_OK ){\n<line22>return rc;\n<line23>}\n<line24>pDbPage->pgno = iFreePage;\n<line25>/* If pDbPage was a btree-page, then it may have child pages and/or cells\n<line26>** that point to overflow pages. The pointer map entries for all these\n<line27>** pages need to be changed.\n<line28>**\n<line29>** If pDbPage is an overflow page, then the first 4 bytes may store a\n<line30>** pointer to a subsequent overflow page. If this is the case, then\n<line31>** the pointer map needs to be updated for the subsequent overflow page.\n<line32>*/\n<line33>if( eType==PTRMAP_BTREE || eType==PTRMAP_ROOTPAGE ){\n<line34>rc = setChildPtrmaps(pDbPage);\n<line35>if( rc!=SQLITE_OK ){\n<line36>return rc;\n<line37>}\n<line38>}else{\n<line39>Pgno nextOvfl = get4byte(pDbPage->aData);\n<line40>if( nextOvfl!=0 ){\n<line41>ptrmapPut(pBt, nextOvfl, PTRMAP_OVERFLOW2, iFreePage, &rc);\n<line42>if( rc!=SQLITE_OK ){\n<line43>return rc;\n<line44>}\n<line45>}\n<line46>}\n<line47>/* Fix the database pointer on page iPtrPage that pointed at iDbPage so\n<line48>** that it points at iFreePage. Also fix the pointer map entry for\n<line49>** iPtrPage.\n<line50>*/\n<line51>if( eType!=PTRMAP_ROOTPAGE ){\n<line52>rc = btreeGetPage(pBt, iPtrPage, &pPtrPage, 0);\n<line53>if( rc!=SQLITE_OK ){\n<line54>return rc;\n<line55>}\n<line56>rc = sqlite3PagerWrite(pPtrPage->pDbPage);\n<line57>if( rc!=SQLITE_OK ){\n<line58>releasePage(pPtrPage);\n<line59>return rc;\n<line60>}\n<line61>rc = modifyPagePointer(pPtrPage, iDbPage, iFreePage, eType);\n<line62>releasePage(pPtrPage);\n<line63>if( rc==SQLITE_OK ){\n<line64>ptrmapPut(pBt, iFreePage, eType, iPtrPage, &rc);\n<line65>}\n<line66>}\n<line67>return rc;\n<line68>}
----------------------------------------
Function: incrVacuumStep
Content: <line0>static int incrVacuumStep(BtShared *pBt, Pgno nFin, Pgno iLastPg, int bCommit){\n<line1>Pgno nFreeList;           /* Number of pages still on the free-list */\n<line2>int rc;\n<line3>assert( sqlite3_mutex_held(pBt->mutex) );\n<line4>assert( iLastPg>nFin );\n<line5>if( !PTRMAP_ISPAGE(pBt, iLastPg) && iLastPg!=PENDING_BYTE_PAGE(pBt) ){\n<line6>u8 eType;\n<line7>Pgno iPtrPage;\n<line8>nFreeList = get4byte(&pBt->pPage1->aData[36]);\n<line9>if( nFreeList==0 ){\n<line10>return SQLITE_DONE;\n<line11>}\n<line12>rc = ptrmapGet(pBt, iLastPg, &eType, &iPtrPage);\n<line13>if( rc!=SQLITE_OK ){\n<line14>return rc;\n<line15>}\n<line16>if( eType==PTRMAP_ROOTPAGE ){\n<line17>return SQLITE_CORRUPT_BKPT;\n<line18>}\n<line19>if( eType==PTRMAP_FREEPAGE ){\n<line20>if( bCommit==0 ){\n<line21>/* Remove the page from the files free-list. This is not required\n<line22>** if bCommit is non-zero. In that case, the free-list will be\n<line23>** truncated to zero after this function returns, so it doesn't\n<line24>** matter if it still contains some garbage entries.\n<line25>*/\n<line26>Pgno iFreePg;\n<line27>MemPage *pFreePg;\n<line28>rc = allocateBtreePage(pBt, &pFreePg, &iFreePg, iLastPg, BTALLOC_EXACT);\n<line29>if( rc!=SQLITE_OK ){\n<line30>return rc;\n<line31>}\n<line32>assert( iFreePg==iLastPg );\n<line33>releasePage(pFreePg);\n<line34>}\n<line35>} else {\n<line36>Pgno iFreePg;             /* Index of free page to move pLastPg to */\n<line37>MemPage *pLastPg;\n<line38>u8 eMode = BTALLOC_ANY;   /* Mode parameter for allocateBtreePage() */\n<line39>Pgno iNear = 0;           /* nearby parameter for allocateBtreePage() */\n<line40>rc = btreeGetPage(pBt, iLastPg, &pLastPg, 0);\n<line41>if( rc!=SQLITE_OK ){\n<line42>return rc;\n<line43>}\n<line44>/* If bCommit is zero, this loop runs exactly once and page pLastPg\n<line45>** is swapped with the first free page pulled off the free list.\n<line46>**\n<line47>** On the other hand, if bCommit is greater than zero, then keep\n<line48>** looping until a free-page located within the first nFin pages\n<line49>** of the file is found.\n<line50>*/\n<line51>if( bCommit==0 ){\n<line52>eMode = BTALLOC_LE;\n<line53>iNear = nFin;\n<line54>}\n<line55>do {\n<line56>MemPage *pFreePg;\n<line57>Pgno dbSize = btreePagecount(pBt);\n<line58>rc = allocateBtreePage(pBt, &pFreePg, &iFreePg, iNear, eMode);\n<line59>if( rc!=SQLITE_OK ){\n<line60>releasePage(pLastPg);\n<line61>return rc;\n<line62>}\n<line63>releasePage(pFreePg);\n<line64>if( iFreePg>dbSize ){\n<line65>releasePage(pLastPg);\n<line66>return SQLITE_CORRUPT_BKPT;\n<line67>}\n<line68>}while( bCommit && iFreePg>nFin );\n<line69>assert( iFreePg<iLastPg );\n<line70>rc = relocatePage(pBt, pLastPg, eType, iPtrPage, iFreePg, bCommit);\n<line71>releasePage(pLastPg);\n<line72>if( rc!=SQLITE_OK ){\n<line73>return rc;\n<line74>}\n<line75>}\n<line76>}\n<line77>if( bCommit==0 ){\n<line78>do {\n<line79>iLastPg--;\n<line80>}while( iLastPg==PENDING_BYTE_PAGE(pBt) || PTRMAP_ISPAGE(pBt, iLastPg) );\n<line81>pBt->bDoTruncate = 1;\n<line82>pBt->nPage = iLastPg;\n<line83>}\n<line84>return SQLITE_OK;\n<line85>}
----------------------------------------
Function: finalDbSize
Content: <line0>static Pgno finalDbSize(BtShared *pBt, Pgno nOrig, Pgno nFree){\n<line1>int nEntry;                     /* Number of entries on one ptrmap page */\n<line2>Pgno nPtrmap;                   /* Number of PtrMap pages to be freed */\n<line3>Pgno nFin;                      /* Return value */\n<line4>nEntry = pBt->usableSize/5;\n<line5>nPtrmap = (nFree-nOrig+PTRMAP_PAGENO(pBt, nOrig)+nEntry)/nEntry;\n<line6>nFin = nOrig - nFree - nPtrmap;\n<line7>if( nOrig>PENDING_BYTE_PAGE(pBt) && nFin<PENDING_BYTE_PAGE(pBt) ){\n<line8>nFin--;\n<line9>}\n<line10>while( PTRMAP_ISPAGE(pBt, nFin) || nFin==PENDING_BYTE_PAGE(pBt) ){\n<line11>nFin--;\n<line12>}\n<line13>return nFin;\n<line14>}
----------------------------------------
Function: autoVacuumCommit
Content: <line0>static int autoVacuumCommit(Btree *p){\n<line1>int rc = SQLITE_OK;\n<line2>Pager *pPager;\n<line3>BtShared *pBt;\n<line4>sqlite3 *db;\n<line5>VVA_ONLY( int nRef );\n<line6>assert( p!=0 );\n<line7>pBt = p->pBt;\n<line8>pPager = pBt->pPager;\n<line9>VVA_ONLY( nRef = sqlite3PagerRefcount(pPager); )\n<line10>assert( sqlite3_mutex_held(pBt->mutex) );\n<line11>invalidateAllOverflowCache(pBt);\n<line12>assert(pBt->autoVacuum);\n<line13>if( !pBt->incrVacuum ){\n<line14>Pgno nFin;         /* Number of pages in database after autovacuuming */\n<line15>Pgno nFree;        /* Number of pages on the freelist initially */\n<line16>Pgno nVac;         /* Number of pages to vacuum */\n<line17>Pgno iFree;        /* The next page to be freed */\n<line18>Pgno nOrig;        /* Database size before freeing */\n<line19>nOrig = btreePagecount(pBt);\n<line20>if( PTRMAP_ISPAGE(pBt, nOrig) || nOrig==PENDING_BYTE_PAGE(pBt) ){\n<line21>/* It is not possible to create a database for which the final page\n<line22>** is either a pointer-map page or the pending-byte page. If one\n<line23>** is encountered, this indicates corruption.\n<line24>*/\n<line25>return SQLITE_CORRUPT_BKPT;\n<line26>}\n<line27>nFree = get4byte(&pBt->pPage1->aData[36]);\n<line28>db = p->db;\n<line29>if( db->xAutovacPages ){\n<line30>int iDb;\n<line31>for(iDb=0; ALWAYS(iDb<db->nDb); iDb++){\n<line32>if( db->aDb[iDb].pBt==p ) break;\n<line33>}\n<line34>nVac = db->xAutovacPages(\n<line35>db->pAutovacPagesArg,\n<line36>db->aDb[iDb].zDbSName,\n<line37>nOrig,\n<line38>nFree,\n<line39>pBt->pageSize\n<line40>);\n<line41>if( nVac>nFree ){\n<line42>nVac = nFree;\n<line43>}\n<line44>if( nVac==0 ){\n<line45>return SQLITE_OK;\n<line46>}\n<line47>}else{\n<line48>nVac = nFree;\n<line49>}\n<line50>nFin = finalDbSize(pBt, nOrig, nVac);\n<line51>if( nFin>nOrig ) return SQLITE_CORRUPT_BKPT;\n<line52>if( nFin<nOrig ){\n<line53>rc = saveAllCursors(pBt, 0, 0);\n<line54>}\n<line55>for(iFree=nOrig; iFree>nFin && rc==SQLITE_OK; iFree--){\n<line56>rc = incrVacuumStep(pBt, nFin, iFree, nVac==nFree);\n<line57>}\n<line58>if( (rc==SQLITE_DONE || rc==SQLITE_OK) && nFree>0 ){\n<line59>rc = sqlite3PagerWrite(pBt->pPage1->pDbPage);\n<line60>if( nVac==nFree ){\n<line61>put4byte(&pBt->pPage1->aData[32], 0);\n<line62>put4byte(&pBt->pPage1->aData[36], 0);\n<line63>}\n<line64>put4byte(&pBt->pPage1->aData[28], nFin);\n<line65>pBt->bDoTruncate = 1;\n<line66>pBt->nPage = nFin;\n<line67>}\n<line68>if( rc!=SQLITE_OK ){\n<line69>sqlite3PagerRollback(pPager);\n<line70>}\n<line71>}\n<line72>assert( nRef>=sqlite3PagerRefcount(pPager) );\n<line73>return rc;\n<line74>}
----------------------------------------
Function: btreeEndTransaction
Content: <line0>static void btreeEndTransaction(Btree *p){\n<line1>BtShared *pBt = p->pBt;\n<line2>sqlite3 *db = p->db;\n<line3>assert( sqlite3BtreeHoldsMutex(p) );\n<line4>#ifndef SQLITE_OMIT_AUTOVACUUM\n<line5>pBt->bDoTruncate = 0;\n<line6>#endif\n<line7>if( p->inTrans>TRANS_NONE && db->nVdbeRead>1 ){\n<line8>/* If there are other active statements that belong to this database\n<line9>** handle, downgrade to a read-only transaction. The other statements\n<line10>** may still be reading from the database.  */\n<line11>downgradeAllSharedCacheTableLocks(p);\n<line12>p->inTrans = TRANS_READ;\n<line13>}else{\n<line14>/* If the handle had any kind of transaction open, decrement the\n<line15>** transaction count of the shared btree. If the transaction count\n<line16>** reaches 0, set the shared state to TRANS_NONE. The unlockBtreeIfUnused()\n<line17>** call below will unlock the pager.  */\n<line18>if( p->inTrans!=TRANS_NONE ){\n<line19>clearAllSharedCacheTableLocks(p);\n<line20>pBt->nTransaction--;\n<line21>if( 0==pBt->nTransaction ){\n<line22>pBt->inTransaction = TRANS_NONE;\n<line23>}\n<line24>}\n<line25>/* Set the current transaction state to TRANS_NONE and unlock the\n<line26>** pager if this call closed the only read or write transaction.  */\n<line27>p->inTrans = TRANS_NONE;\n<line28>unlockBtreeIfUnused(pBt);\n<line29>}\n<line30>btreeIntegrity(p);\n<line31>}
----------------------------------------
Function: btreeSetNPage
Content: <line0>static void btreeSetNPage(BtShared *pBt, MemPage *pPage1){\n<line1>int nPage = get4byte(&pPage1->aData[28]);\n<line2>testcase( nPage==0 );\n<line3>if( nPage==0 ) sqlite3PagerPagecount(pBt->pPager, &nPage);\n<line4>testcase( pBt->nPage!=(u32)nPage );\n<line5>pBt->nPage = nPage;\n<line6>}
----------------------------------------
Function: btreeCursor
Content: <line0>static int btreeCursor(\n<line1>Btree *p,                              /* The btree */\n<line2>Pgno iTable,                           /* Root page of table to open */\n<line3>int wrFlag,                            /* 1 to write. 0 read-only */\n<line4>struct KeyInfo *pKeyInfo,              /* First arg to comparison function */\n<line5>BtCursor *pCur                         /* Space for new cursor */\n<line6>){\n<line7>BtShared *pBt = p->pBt;                /* Shared b-tree handle */\n<line8>BtCursor *pX;                          /* Looping over other all cursors */\n<line9>assert( sqlite3BtreeHoldsMutex(p) );\n<line10>assert( wrFlag==0\n<line11>|| wrFlag==BTREE_WRCSR\n<line12>|| wrFlag==(BTREE_WRCSR|BTREE_FORDELETE)\n<line13>);\n<line14>/* The following assert statements verify that if this is a sharable\n<line15>** b-tree database, the connection is holding the required table locks,\n<line16>** and that no other connection has any open cursor that conflicts with\n<line17>** this lock.  The iTable<1 term disables the check for corrupt schemas. */\n<line18>assert( hasSharedCacheTableLock(p, iTable, pKeyInfo!=0, (wrFlag?2:1))\n<line19>|| iTable<1 );\n<line20>assert( wrFlag==0 || !hasReadConflicts(p, iTable) );\n<line21>/* Assert that the caller has opened the required transaction. */\n<line22>assert( p->inTrans>TRANS_NONE );\n<line23>assert( wrFlag==0 || p->inTrans==TRANS_WRITE );\n<line24>assert( pBt->pPage1 && pBt->pPage1->aData );\n<line25>assert( wrFlag==0 || (pBt->btsFlags & BTS_READ_ONLY)==0 );\n<line26>if( iTable<=1 ){\n<line27>if( iTable<1 ){\n<line28>return SQLITE_CORRUPT_BKPT;\n<line29>}else if( btreePagecount(pBt)==0 ){\n<line30>assert( wrFlag==0 );\n<line31>iTable = 0;\n<line32>}\n<line33>}\n<line34>/* Now that no other errors can occur, finish filling in the BtCursor\n<line35>** variables and link the cursor into the BtShared list.  */\n<line36>pCur->pgnoRoot = iTable;\n<line37>pCur->iPage = -1;\n<line38>pCur->pKeyInfo = pKeyInfo;\n<line39>pCur->pBtree = p;\n<line40>pCur->pBt = pBt;\n<line41>pCur->curFlags = 0;\n<line42>/* If there are two or more cursors on the same btree, then all such\n<line43>** cursors *must* have the BTCF_Multiple flag set. */\n<line44>for(pX=pBt->pCursor; pX; pX=pX->pNext){\n<line45>if( pX->pgnoRoot==iTable ){\n<line46>pX->curFlags |= BTCF_Multiple;\n<line47>pCur->curFlags = BTCF_Multiple;\n<line48>}\n<line49>}\n<line50>pCur->eState = CURSOR_INVALID;\n<line51>pCur->pNext = pBt->pCursor;\n<line52>pBt->pCursor = pCur;\n<line53>if( wrFlag ){\n<line54>pCur->curFlags |= BTCF_WriteFlag;\n<line55>pCur->curPagerFlags = 0;\n<line56>if( pBt->pTmpSpace==0 ) return allocateTempSpace(pBt);\n<line57>}else{\n<line58>pCur->curPagerFlags = PAGER_GET_READONLY;\n<line59>}\n<line60>return SQLITE_OK;\n<line61>}
----------------------------------------
Function: btreeCursorWithLock
Content: <line0>static int btreeCursorWithLock(\n<line1>Btree *p,                              /* The btree */\n<line2>Pgno iTable,                           /* Root page of table to open */\n<line3>int wrFlag,                            /* 1 to write. 0 read-only */\n<line4>struct KeyInfo *pKeyInfo,              /* First arg to comparison function */\n<line5>BtCursor *pCur                         /* Space for new cursor */\n<line6>){\n<line7>int rc;\n<line8>sqlite3BtreeEnter(p);\n<line9>rc = btreeCursor(p, iTable, wrFlag, pKeyInfo, pCur);\n<line10>sqlite3BtreeLeave(p);\n<line11>return rc;\n<line12>}
----------------------------------------
Function: getCellInfo
Content: <line0>static SQLITE_NOINLINE void getCellInfo(BtCursor *pCur){\n<line1>if( pCur->info.nSize==0 ){\n<line2>pCur->curFlags |= BTCF_ValidNKey;\n<line3>btreeParseCell(pCur->pPage,pCur->ix,&pCur->info);\n<line4>}else{\n<line5>assertCellInfo(pCur);\n<line6>}\n<line7>}
----------------------------------------
Function: getOverflowPage
Content: <line0>static int getOverflowPage(\n<line1>BtShared *pBt,               /* The database file */\n<line2>Pgno ovfl,                   /* Current overflow page number */\n<line3>MemPage **ppPage,            /* OUT: MemPage handle (may be NULL) */\n<line4>Pgno *pPgnoNext              /* OUT: Next overflow page number */\n<line5>){\n<line6>Pgno next = 0;\n<line7>MemPage *pPage = 0;\n<line8>int rc = SQLITE_OK;\n<line9>assert( sqlite3_mutex_held(pBt->mutex) );\n<line10>assert(pPgnoNext);\n<line11>#ifndef SQLITE_OMIT_AUTOVACUUM\n<line12>/* Try to find the next page in the overflow list using the\n<line13>** autovacuum pointer-map pages. Guess that the next page in\n<line14>** the overflow list is page number (ovfl+1). If that guess turns\n<line15>** out to be wrong, fall back to loading the data of page\n<line16>** number ovfl to determine the next page number.\n<line17>*/\n<line18>if( pBt->autoVacuum ){\n<line19>Pgno pgno;\n<line20>Pgno iGuess = ovfl+1;\n<line21>u8 eType;\n<line22>while( PTRMAP_ISPAGE(pBt, iGuess) || iGuess==PENDING_BYTE_PAGE(pBt) ){\n<line23>iGuess++;\n<line24>}\n<line25>if( iGuess<=btreePagecount(pBt) ){\n<line26>rc = ptrmapGet(pBt, iGuess, &eType, &pgno);\n<line27>if( rc==SQLITE_OK && eType==PTRMAP_OVERFLOW2 && pgno==ovfl ){\n<line28>next = iGuess;\n<line29>rc = SQLITE_DONE;\n<line30>}\n<line31>}\n<line32>}\n<line33>#endif\n<line34>assert( next==0 || rc==SQLITE_DONE );\n<line35>if( rc==SQLITE_OK ){\n<line36>rc = btreeGetPage(pBt, ovfl, &pPage, (ppPage==0) ? PAGER_GET_READONLY : 0);\n<line37>assert( rc==SQLITE_OK || pPage==0 );\n<line38>if( rc==SQLITE_OK ){\n<line39>next = get4byte(pPage->aData);\n<line40>}\n<line41>}\n<line42>*pPgnoNext = next;\n<line43>if( ppPage ){\n<line44>*ppPage = pPage;\n<line45>}else{\n<line46>releasePage(pPage);\n<line47>}\n<line48>return (rc==SQLITE_DONE ? SQLITE_OK : rc);\n<line49>}
----------------------------------------
Function: copyPayload
Content: <line0>static int copyPayload(\n<line1>void *pPayload,           /* Pointer to page data */\n<line2>void *pBuf,               /* Pointer to buffer */\n<line3>int nByte,                /* Number of bytes to copy */\n<line4>int eOp,                  /* 0 -> copy from page, 1 -> copy to page */\n<line5>DbPage *pDbPage           /* Page containing pPayload */\n<line6>){\n<line7>if( eOp ){\n<line8>/* Copy data from buffer to page (a write operation) */\n<line9>int rc = sqlite3PagerWrite(pDbPage);\n<line10>if( rc!=SQLITE_OK ){\n<line11>return rc;\n<line12>}\n<line13>memcpy(pPayload, pBuf, nByte);\n<line14>}else{\n<line15>/* Copy data from page to buffer (a read operation) */\n<line16>memcpy(pBuf, pPayload, nByte);\n<line17>}\n<line18>return SQLITE_OK;\n<line19>}
----------------------------------------
Function: accessPayload
Content: <line0>static int accessPayload(\n<line1>BtCursor *pCur,      /* Cursor pointing to entry to read from */\n<line2>u32 offset,          /* Begin reading this far into payload */\n<line3>u32 amt,             /* Read this many bytes */\n<line4>unsigned char *pBuf, /* Write the bytes into this buffer */\n<line5>int eOp              /* zero to read. non-zero to write. */\n<line6>){\n<line7>unsigned char *aPayload;\n<line8>int rc = SQLITE_OK;\n<line9>int iIdx = 0;\n<line10>MemPage *pPage = pCur->pPage;               /* Btree page of current entry */\n<line11>BtShared *pBt = pCur->pBt;                  /* Btree this cursor belongs to */\n<line12>#ifdef SQLITE_DIRECT_OVERFLOW_READ\n<line13>unsigned char * const pBufStart = pBuf;     /* Start of original out buffer */\n<line14>#endif\n<line15>assert( pPage );\n<line16>assert( eOp==0 || eOp==1 );\n<line17>assert( pCur->eState==CURSOR_VALID );\n<line18>if( pCur->ix>=pPage->nCell ){\n<line19>return SQLITE_CORRUPT_PAGE(pPage);\n<line20>}\n<line21>assert( cursorHoldsMutex(pCur) );\n<line22>getCellInfo(pCur);\n<line23>aPayload = pCur->info.pPayload;\n<line24>assert( offset+amt <= pCur->info.nPayload );\n<line25>assert( aPayload > pPage->aData );\n<line26>if( (uptr)(aPayload - pPage->aData) > (pBt->usableSize - pCur->info.nLocal) ){\n<line27>/* Trying to read or write past the end of the data is an error.  The\n<line28>** conditional above is really:\n<line29>**    &aPayload[pCur->info.nLocal] > &pPage->aData[pBt->usableSize]\n<line30>** but is recast into its current form to avoid integer overflow problems\n<line31>*/\n<line32>return SQLITE_CORRUPT_PAGE(pPage);\n<line33>}\n<line34>/* Check if data must be read/written to/from the btree page itself. */\n<line35>if( offset<pCur->info.nLocal ){\n<line36>int a = amt;\n<line37>if( a+offset>pCur->info.nLocal ){\n<line38>a = pCur->info.nLocal - offset;\n<line39>}\n<line40>rc = copyPayload(&aPayload[offset], pBuf, a, eOp, pPage->pDbPage);\n<line41>offset = 0;\n<line42>pBuf += a;\n<line43>amt -= a;\n<line44>}else{\n<line45>offset -= pCur->info.nLocal;\n<line46>}\n<line47>if( rc==SQLITE_OK && amt>0 ){\n<line48>const u32 ovflSize = pBt->usableSize - 4;  /* Bytes content per ovfl page */\n<line49>Pgno nextPage;\n<line50>nextPage = get4byte(&aPayload[pCur->info.nLocal]);\n<line51>/* If the BtCursor.aOverflow[] has not been allocated, allocate it now.\n<line52>**\n<line53>** The aOverflow[] array is sized at one entry for each overflow page\n<line54>** in the overflow chain. The page number of the first overflow page is\n<line55>** stored in aOverflow[0], etc. A value of 0 in the aOverflow[] array\n<line56>** means "not yet known" (the cache is lazily populated).\n<line57>*/\n<line58>if( (pCur->curFlags & BTCF_ValidOvfl)==0 ){\n<line59>int nOvfl = (pCur->info.nPayload-pCur->info.nLocal+ovflSize-1)/ovflSize;\n<line60>if( pCur->aOverflow==0\n<line61>|| nOvfl*(int)sizeof(Pgno) > sqlite3MallocSize(pCur->aOverflow)\n<line62>){\n<line63>Pgno *aNew;\n<line64>if( sqlite3FaultSim(413) ){\n<line65>aNew = 0;\n<line66>}else{\n<line67>aNew = (Pgno*)sqlite3Realloc(pCur->aOverflow, nOvfl*2*sizeof(Pgno));\n<line68>}\n<line69>if( aNew==0 ){\n<line70>return SQLITE_NOMEM_BKPT;\n<line71>}else{\n<line72>pCur->aOverflow = aNew;\n<line73>}\n<line74>}\n<line75>memset(pCur->aOverflow, 0, nOvfl*sizeof(Pgno));\n<line76>pCur->curFlags |= BTCF_ValidOvfl;\n<line77>}else{\n<line78>/* Sanity check the validity of the overflow page cache */\n<line79>assert( pCur->aOverflow[0]==nextPage\n<line80>|| pCur->aOverflow[0]==0\n<line81>|| CORRUPT_DB );\n<line82>assert( pCur->aOverflow[0]!=0 || pCur->aOverflow[offset/ovflSize]==0 );\n<line83>/* If the overflow page-list cache has been allocated and the\n<line84>** entry for the first required overflow page is valid, skip\n<line85>** directly to it.\n<line86>*/\n<line87>if( pCur->aOverflow[offset/ovflSize] ){\n<line88>iIdx = (offset/ovflSize);\n<line89>nextPage = pCur->aOverflow[iIdx];\n<line90>offset = (offset%ovflSize);\n<line91>}\n<line92>}\n<line93>assert( rc==SQLITE_OK && amt>0 );\n<line94>while( nextPage ){\n<line95>/* If required, populate the overflow page-list cache. */\n<line96>if( nextPage > pBt->nPage ) return SQLITE_CORRUPT_BKPT;\n<line97>assert( pCur->aOverflow[iIdx]==0\n<line98>|| pCur->aOverflow[iIdx]==nextPage\n<line99>|| CORRUPT_DB );\n<line100>pCur->aOverflow[iIdx] = nextPage;\n<line101>if( offset>=ovflSize ){\n<line102>/* The only reason to read this page is to obtain the page\n<line103>** number for the next page in the overflow chain. The page\n<line104>** data is not required. So first try to lookup the overflow\n<line105>** page-list cache, if any, then fall back to the getOverflowPage()\n<line106>** function.\n<line107>*/\n<line108>assert( pCur->curFlags & BTCF_ValidOvfl );\n<line109>assert( pCur->pBtree->db==pBt->db );\n<line110>if( pCur->aOverflow[iIdx+1] ){\n<line111>nextPage = pCur->aOverflow[iIdx+1];\n<line112>}else{\n<line113>rc = getOverflowPage(pBt, nextPage, 0, &nextPage);\n<line114>}\n<line115>offset -= ovflSize;\n<line116>}else{\n<line117>/* Need to read this page properly. It contains some of the\n<line118>** range of data that is being read (eOp==0) or written (eOp!=0).\n<line119>*/\n<line120>int a = amt;\n<line121>if( a + offset > ovflSize ){\n<line122>a = ovflSize - offset;\n<line123>}\n<line124>#ifdef SQLITE_DIRECT_OVERFLOW_READ\n<line125>/* If all the following are true:\n<line126>**\n<line127>**   1) this is a read operation, and\n<line128>**   2) data is required from the start of this overflow page, and\n<line129>**   3) there are no dirty pages in the page-cache\n<line130>**   4) the database is file-backed, and\n<line131>**   5) the page is not in the WAL file\n<line132>**   6) at least 4 bytes have already been read into the output buffer\n<line133>**\n<line134>** then data can be read directly from the database file into the\n<line135>** output buffer, bypassing the page-cache altogether. This speeds\n<line136>** up loading large records that span many overflow pages.\n<line137>*/\n<line138>if( eOp==0                                             /* (1) */\n<line139>&& offset==0                                          /* (2) */\n<line140>&& sqlite3PagerDirectReadOk(pBt->pPager, nextPage)    /* (3,4,5) */\n<line141>&& &pBuf[-4]>=pBufStart                               /* (6) */\n<line142>){\n<line143>sqlite3_file *fd = sqlite3PagerFile(pBt->pPager);\n<line144>u8 aSave[4];\n<line145>u8 *aWrite = &pBuf[-4];\n<line146>assert( aWrite>=pBufStart );                         /* due to (6) */\n<line147>memcpy(aSave, aWrite, 4);\n<line148>rc = sqlite3OsRead(fd, aWrite, a+4, (i64)pBt->pageSize*(nextPage-1));\n<line149>nextPage = get4byte(aWrite);\n<line150>memcpy(aWrite, aSave, 4);\n<line151>}else\n<line152>#endif\n<line153>{\n<line154>DbPage *pDbPage;\n<line155>rc = sqlite3PagerGet(pBt->pPager, nextPage, &pDbPage,\n<line156>(eOp==0 ? PAGER_GET_READONLY : 0)\n<line157>);\n<line158>if( rc==SQLITE_OK ){\n<line159>aPayload = sqlite3PagerGetData(pDbPage);\n<line160>nextPage = get4byte(aPayload);\n<line161>rc = copyPayload(&aPayload[offset+4], pBuf, a, eOp, pDbPage);\n<line162>sqlite3PagerUnref(pDbPage);\n<line163>offset = 0;\n<line164>}\n<line165>}\n<line166>amt -= a;\n<line167>if( amt==0 ) return rc;\n<line168>pBuf += a;\n<line169>}\n<line170>if( rc ) break;\n<line171>iIdx++;\n<line172>}\n<line173>}\n<line174>if( rc==SQLITE_OK && amt>0 ){\n<line175>/* Overflow chain ends prematurely */\n<line176>return SQLITE_CORRUPT_PAGE(pPage);\n<line177>}\n<line178>return rc;\n<line179>}
----------------------------------------
Function: accessPayloadChecked
Content: <line0>static SQLITE_NOINLINE int accessPayloadChecked(\n<line1>BtCursor *pCur,\n<line2>u32 offset,\n<line3>u32 amt,\n<line4>void *pBuf\n<line5>){\n<line6>int rc;\n<line7>if ( pCur->eState==CURSOR_INVALID ){\n<line8>return SQLITE_ABORT;\n<line9>}\n<line10>assert( cursorOwnsBtShared(pCur) );\n<line11>rc = btreeRestoreCursorPosition(pCur);\n<line12>return rc ? rc : accessPayload(pCur, offset, amt, pBuf, 0);\n<line13>}
----------------------------------------
Function: fetchPayload
Content: <line0>static const void *fetchPayload(\n<line1>BtCursor *pCur,      /* Cursor pointing to entry to read from */\n<line2>u32 *pAmt            /* Write the number of available bytes here */\n<line3>){\n<line4>int amt;\n<line5>assert( pCur!=0 && pCur->iPage>=0 && pCur->pPage);\n<line6>assert( pCur->eState==CURSOR_VALID );\n<line7>assert( sqlite3_mutex_held(pCur->pBtree->db->mutex) );\n<line8>assert( cursorOwnsBtShared(pCur) );\n<line9>assert( pCur->ix<pCur->pPage->nCell || CORRUPT_DB );\n<line10>assert( pCur->info.nSize>0 );\n<line11>assert( pCur->info.pPayload>pCur->pPage->aData || CORRUPT_DB );\n<line12>assert( pCur->info.pPayload<pCur->pPage->aDataEnd ||CORRUPT_DB);\n<line13>amt = pCur->info.nLocal;\n<line14>if( amt>(int)(pCur->pPage->aDataEnd - pCur->info.pPayload) ){\n<line15>/* There is too little space on the page for the expected amount\n<line16>** of local content. Database must be corrupt. */\n<line17>assert( CORRUPT_DB );\n<line18>amt = MAX(0, (int)(pCur->pPage->aDataEnd - pCur->info.pPayload));\n<line19>}\n<line20>*pAmt = (u32)amt;\n<line21>return (void*)pCur->info.pPayload;\n<line22>}
----------------------------------------
Function: moveToChild
Content: <line0>static int moveToChild(BtCursor *pCur, u32 newPgno){\n<line1>int rc;\n<line2>assert( cursorOwnsBtShared(pCur) );\n<line3>assert( pCur->eState==CURSOR_VALID );\n<line4>assert( pCur->iPage<BTCURSOR_MAX_DEPTH );\n<line5>assert( pCur->iPage>=0 );\n<line6>if( pCur->iPage>=(BTCURSOR_MAX_DEPTH-1) ){\n<line7>return SQLITE_CORRUPT_BKPT;\n<line8>}\n<line9>pCur->info.nSize = 0;\n<line10>pCur->curFlags &= ~(BTCF_ValidNKey|BTCF_ValidOvfl);\n<line11>pCur->aiIdx[pCur->iPage] = pCur->ix;\n<line12>pCur->apPage[pCur->iPage] = pCur->pPage;\n<line13>pCur->ix = 0;\n<line14>pCur->iPage++;\n<line15>rc = getAndInitPage(pCur->pBt, newPgno, &pCur->pPage, pCur->curPagerFlags);\n<line16>assert( pCur->pPage!=0 || rc!=SQLITE_OK );\n<line17>if( rc==SQLITE_OK\n<line18>&& (pCur->pPage->nCell<1 || pCur->pPage->intKey!=pCur->curIntKey)\n<line19>){\n<line20>releasePage(pCur->pPage);\n<line21>rc = SQLITE_CORRUPT_PGNO(newPgno);\n<line22>}\n<line23>if( rc ){\n<line24>pCur->pPage = pCur->apPage[--pCur->iPage];\n<line25>}\n<line26>return rc;\n<line27>}
----------------------------------------
Function: moveToParent
Content: <line0>static void moveToParent(BtCursor *pCur){\n<line1>MemPage *pLeaf;\n<line2>assert( cursorOwnsBtShared(pCur) );\n<line3>assert( pCur->eState==CURSOR_VALID );\n<line4>assert( pCur->iPage>0 );\n<line5>assert( pCur->pPage );\n<line6>assertParentIndex(\n<line7>pCur->apPage[pCur->iPage-1],\n<line8>pCur->aiIdx[pCur->iPage-1],\n<line9>pCur->pPage->pgno\n<line10>);\n<line11>testcase( pCur->aiIdx[pCur->iPage-1] > pCur->apPage[pCur->iPage-1]->nCell );\n<line12>pCur->info.nSize = 0;\n<line13>pCur->curFlags &= ~(BTCF_ValidNKey|BTCF_ValidOvfl);\n<line14>pCur->ix = pCur->aiIdx[pCur->iPage-1];\n<line15>pLeaf = pCur->pPage;\n<line16>pCur->pPage = pCur->apPage[--pCur->iPage];\n<line17>releasePageNotNull(pLeaf);\n<line18>}
----------------------------------------
Function: moveToRoot
Content: <line0>static int moveToRoot(BtCursor *pCur){\n<line1>MemPage *pRoot;\n<line2>int rc = SQLITE_OK;\n<line3>assert( cursorOwnsBtShared(pCur) );\n<line4>assert( CURSOR_INVALID < CURSOR_REQUIRESEEK );\n<line5>assert( CURSOR_VALID   < CURSOR_REQUIRESEEK );\n<line6>assert( CURSOR_FAULT   > CURSOR_REQUIRESEEK );\n<line7>assert( pCur->eState < CURSOR_REQUIRESEEK || pCur->iPage<0 );\n<line8>assert( pCur->pgnoRoot>0 || pCur->iPage<0 );\n<line9>if( pCur->iPage>=0 ){\n<line10>if( pCur->iPage ){\n<line11>releasePageNotNull(pCur->pPage);\n<line12>while( --pCur->iPage ){\n<line13>releasePageNotNull(pCur->apPage[pCur->iPage]);\n<line14>}\n<line15>pRoot = pCur->pPage = pCur->apPage[0];\n<line16>goto skip_init;\n<line17>}\n<line18>}else if( pCur->pgnoRoot==0 ){\n<line19>pCur->eState = CURSOR_INVALID;\n<line20>return SQLITE_EMPTY;\n<line21>}else{\n<line22>assert( pCur->iPage==(-1) );\n<line23>if( pCur->eState>=CURSOR_REQUIRESEEK ){\n<line24>if( pCur->eState==CURSOR_FAULT ){\n<line25>assert( pCur->skipNext!=SQLITE_OK );\n<line26>return pCur->skipNext;\n<line27>}\n<line28>sqlite3BtreeClearCursor(pCur);\n<line29>}\n<line30>rc = getAndInitPage(pCur->pBt, pCur->pgnoRoot, &pCur->pPage,\n<line31>pCur->curPagerFlags);\n<line32>if( rc!=SQLITE_OK ){\n<line33>pCur->eState = CURSOR_INVALID;\n<line34>return rc;\n<line35>}\n<line36>pCur->iPage = 0;\n<line37>pCur->curIntKey = pCur->pPage->intKey;\n<line38>}\n<line39>pRoot = pCur->pPage;\n<line40>assert( pRoot->pgno==pCur->pgnoRoot || CORRUPT_DB );\n<line41>/* If pCur->pKeyInfo is not NULL, then the caller that opened this cursor\n<line42>** expected to open it on an index b-tree. Otherwise, if pKeyInfo is\n<line43>** NULL, the caller expects a table b-tree. If this is not the case,\n<line44>** return an SQLITE_CORRUPT error.\n<line45>**\n<line46>** Earlier versions of SQLite assumed that this test could not fail\n<line47>** if the root page was already loaded when this function was called (i.e.\n<line48>** if pCur->iPage>=0). But this is not so if the database is corrupted\n<line49>** in such a way that page pRoot is linked into a second b-tree table\n<line50>** (or the freelist).  */\n<line51>assert( pRoot->intKey==1 || pRoot->intKey==0 );\n<line52>if( pRoot->isInit==0 || (pCur->pKeyInfo==0)!=pRoot->intKey ){\n<line53>return SQLITE_CORRUPT_PAGE(pCur->pPage);\n<line54>}\n<line55>skip_init:\n<line56>pCur->ix = 0;\n<line57>pCur->info.nSize = 0;\n<line58>pCur->curFlags &= ~(BTCF_AtLast|BTCF_ValidNKey|BTCF_ValidOvfl);\n<line59>if( pRoot->nCell>0 ){\n<line60>pCur->eState = CURSOR_VALID;\n<line61>}else if( !pRoot->leaf ){\n<line62>Pgno subpage;\n<line63>if( pRoot->pgno!=1 ) return SQLITE_CORRUPT_BKPT;\n<line64>subpage = get4byte(&pRoot->aData[pRoot->hdrOffset+8]);\n<line65>pCur->eState = CURSOR_VALID;\n<line66>rc = moveToChild(pCur, subpage);\n<line67>}else{\n<line68>pCur->eState = CURSOR_INVALID;\n<line69>rc = SQLITE_EMPTY;\n<line70>}\n<line71>return rc;\n<line72>}
----------------------------------------
Function: moveToLeftmost
Content: <line0>static int moveToLeftmost(BtCursor *pCur){\n<line1>Pgno pgno;\n<line2>int rc = SQLITE_OK;\n<line3>MemPage *pPage;\n<line4>assert( cursorOwnsBtShared(pCur) );\n<line5>assert( pCur->eState==CURSOR_VALID );\n<line6>while( rc==SQLITE_OK && !(pPage = pCur->pPage)->leaf ){\n<line7>assert( pCur->ix<pPage->nCell );\n<line8>pgno = get4byte(findCell(pPage, pCur->ix));\n<line9>rc = moveToChild(pCur, pgno);\n<line10>}\n<line11>return rc;\n<line12>}
----------------------------------------
Function: moveToRightmost
Content: <line0>static int moveToRightmost(BtCursor *pCur){\n<line1>Pgno pgno;\n<line2>int rc = SQLITE_OK;\n<line3>MemPage *pPage = 0;\n<line4>assert( cursorOwnsBtShared(pCur) );\n<line5>assert( pCur->eState==CURSOR_VALID );\n<line6>while( !(pPage = pCur->pPage)->leaf ){\n<line7>pgno = get4byte(&pPage->aData[pPage->hdrOffset+8]);\n<line8>pCur->ix = pPage->nCell;\n<line9>rc = moveToChild(pCur, pgno);\n<line10>if( rc ) return rc;\n<line11>}\n<line12>pCur->ix = pPage->nCell-1;\n<line13>assert( pCur->info.nSize==0 );\n<line14>assert( (pCur->curFlags & BTCF_ValidNKey)==0 );\n<line15>return SQLITE_OK;\n<line16>}
----------------------------------------
Function: btreeLast
Content: <line0>static SQLITE_NOINLINE int btreeLast(BtCursor *pCur, int *pRes){\n<line1>int rc = moveToRoot(pCur);\n<line2>if( rc==SQLITE_OK ){\n<line3>assert( pCur->eState==CURSOR_VALID );\n<line4>*pRes = 0;\n<line5>rc = moveToRightmost(pCur);\n<line6>if( rc==SQLITE_OK ){\n<line7>pCur->curFlags |= BTCF_AtLast;\n<line8>}else{\n<line9>pCur->curFlags &= ~BTCF_AtLast;\n<line10>}\n<line11>}else if( rc==SQLITE_EMPTY ){\n<line12>assert( pCur->pgnoRoot==0 || pCur->pPage->nCell==0 );\n<line13>*pRes = 1;\n<line14>rc = SQLITE_OK;\n<line15>}\n<line16>return rc;\n<line17>}
----------------------------------------
Function: indexCellCompare
Content: <line0>static int indexCellCompare(\n<line1>MemPage *pPage,\n<line2>int idx,\n<line3>UnpackedRecord *pIdxKey,\n<line4>RecordCompare xRecordCompare\n<line5>){\n<line6>int c;\n<line7>int nCell;  /* Size of the pCell cell in bytes */\n<line8>u8 *pCell = findCellPastPtr(pPage, idx);\n<line9>nCell = pCell[0];\n<line10>if( nCell<=pPage->max1bytePayload ){\n<line11>/* This branch runs if the record-size field of the cell is a\n<line12>** single byte varint and the record fits entirely on the main\n<line13>** b-tree page.  */\n<line14>testcase( pCell+nCell+1==pPage->aDataEnd );\n<line15>c = xRecordCompare(nCell, (void*)&pCell[1], pIdxKey);\n<line16>}else if( !(pCell[1] & 0x80)\n<line17>&& (nCell = ((nCell&0x7f)<<7) + pCell[1])<=pPage->maxLocal\n<line18>){\n<line19>/* The record-size field is a 2 byte varint and the record\n<line20>** fits entirely on the main b-tree page.  */\n<line21>testcase( pCell+nCell+2==pPage->aDataEnd );\n<line22>c = xRecordCompare(nCell, (void*)&pCell[2], pIdxKey);\n<line23>}else{\n<line24>/* If the record extends into overflow pages, do not attempt\n<line25>** the optimization. */\n<line26>c = 99;\n<line27>}\n<line28>return c;\n<line29>}
----------------------------------------
Function: cursorOnLastPage
Content: <line0>static int cursorOnLastPage(BtCursor *pCur){\n<line1>int i;\n<line2>assert( pCur->eState==CURSOR_VALID );\n<line3>for(i=0; i<pCur->iPage; i++){\n<line4>MemPage *pPage = pCur->apPage[i];\n<line5>if( pCur->aiIdx[i]<pPage->nCell ) return 0;\n<line6>}\n<line7>return 1;\n<line8>}
----------------------------------------
Function: btreeNext
Content: <line0>static SQLITE_NOINLINE int btreeNext(BtCursor *pCur){\n<line1>int rc;\n<line2>int idx;\n<line3>MemPage *pPage;\n<line4>assert( cursorOwnsBtShared(pCur) );\n<line5>if( pCur->eState!=CURSOR_VALID ){\n<line6>assert( (pCur->curFlags & BTCF_ValidOvfl)==0 );\n<line7>rc = restoreCursorPosition(pCur);\n<line8>if( rc!=SQLITE_OK ){\n<line9>return rc;\n<line10>}\n<line11>if( CURSOR_INVALID==pCur->eState ){\n<line12>return SQLITE_DONE;\n<line13>}\n<line14>if( pCur->eState==CURSOR_SKIPNEXT ){\n<line15>pCur->eState = CURSOR_VALID;\n<line16>if( pCur->skipNext>0 ) return SQLITE_OK;\n<line17>}\n<line18>}\n<line19>pPage = pCur->pPage;\n<line20>idx = ++pCur->ix;\n<line21>if( sqlite3FaultSim(412) ) pPage->isInit = 0;\n<line22>if( !pPage->isInit ){\n<line23>return SQLITE_CORRUPT_BKPT;\n<line24>}\n<line25>if( idx>=pPage->nCell ){\n<line26>if( !pPage->leaf ){\n<line27>rc = moveToChild(pCur, get4byte(&pPage->aData[pPage->hdrOffset+8]));\n<line28>if( rc ) return rc;\n<line29>return moveToLeftmost(pCur);\n<line30>}\n<line31>do{\n<line32>if( pCur->iPage==0 ){\n<line33>pCur->eState = CURSOR_INVALID;\n<line34>return SQLITE_DONE;\n<line35>}\n<line36>moveToParent(pCur);\n<line37>pPage = pCur->pPage;\n<line38>}while( pCur->ix>=pPage->nCell );\n<line39>if( pPage->intKey ){\n<line40>return sqlite3BtreeNext(pCur, 0);\n<line41>}else{\n<line42>return SQLITE_OK;\n<line43>}\n<line44>}\n<line45>if( pPage->leaf ){\n<line46>return SQLITE_OK;\n<line47>}else{\n<line48>return moveToLeftmost(pCur);\n<line49>}\n<line50>}
----------------------------------------
Function: btreePrevious
Content: <line0>static SQLITE_NOINLINE int btreePrevious(BtCursor *pCur){\n<line1>int rc;\n<line2>MemPage *pPage;\n<line3>assert( cursorOwnsBtShared(pCur) );\n<line4>assert( (pCur->curFlags & (BTCF_AtLast|BTCF_ValidOvfl|BTCF_ValidNKey))==0 );\n<line5>assert( pCur->info.nSize==0 );\n<line6>if( pCur->eState!=CURSOR_VALID ){\n<line7>rc = restoreCursorPosition(pCur);\n<line8>if( rc!=SQLITE_OK ){\n<line9>return rc;\n<line10>}\n<line11>if( CURSOR_INVALID==pCur->eState ){\n<line12>return SQLITE_DONE;\n<line13>}\n<line14>if( CURSOR_SKIPNEXT==pCur->eState ){\n<line15>pCur->eState = CURSOR_VALID;\n<line16>if( pCur->skipNext<0 ) return SQLITE_OK;\n<line17>}\n<line18>}\n<line19>pPage = pCur->pPage;\n<line20>if( sqlite3FaultSim(412) ) pPage->isInit = 0;\n<line21>if( !pPage->isInit ){\n<line22>return SQLITE_CORRUPT_BKPT;\n<line23>}\n<line24>if( !pPage->leaf ){\n<line25>int idx = pCur->ix;\n<line26>rc = moveToChild(pCur, get4byte(findCell(pPage, idx)));\n<line27>if( rc ) return rc;\n<line28>rc = moveToRightmost(pCur);\n<line29>}else{\n<line30>while( pCur->ix==0 ){\n<line31>if( pCur->iPage==0 ){\n<line32>pCur->eState = CURSOR_INVALID;\n<line33>return SQLITE_DONE;\n<line34>}\n<line35>moveToParent(pCur);\n<line36>}\n<line37>assert( pCur->info.nSize==0 );\n<line38>assert( (pCur->curFlags & (BTCF_ValidOvfl))==0 );\n<line39>pCur->ix--;\n<line40>pPage = pCur->pPage;\n<line41>if( pPage->intKey && !pPage->leaf ){\n<line42>rc = sqlite3BtreePrevious(pCur, 0);\n<line43>}else{\n<line44>rc = SQLITE_OK;\n<line45>}\n<line46>}\n<line47>return rc;\n<line48>}
----------------------------------------
Function: allocateBtreePage
Content: <line0>static int allocateBtreePage(\n<line1>BtShared *pBt,         /* The btree */\n<line2>MemPage **ppPage,      /* Store pointer to the allocated page here */\n<line3>Pgno *pPgno,           /* Store the page number here */\n<line4>Pgno nearby,           /* Search for a page near this one */\n<line5>u8 eMode               /* BTALLOC_EXACT, BTALLOC_LT, or BTALLOC_ANY */\n<line6>){\n<line7>MemPage *pPage1;\n<line8>int rc;\n<line9>u32 n;     /* Number of pages on the freelist */\n<line10>u32 k;     /* Number of leaves on the trunk of the freelist */\n<line11>MemPage *pTrunk = 0;\n<line12>MemPage *pPrevTrunk = 0;\n<line13>Pgno mxPage;     /* Total size of the database file */\n<line14>assert( sqlite3_mutex_held(pBt->mutex) );\n<line15>assert( eMode==BTALLOC_ANY || (nearby>0 && IfNotOmitAV(pBt->autoVacuum)) );\n<line16>pPage1 = pBt->pPage1;\n<line17>mxPage = btreePagecount(pBt);\n<line18>/* EVIDENCE-OF: R-21003-45125 The 4-byte big-endian integer at offset 36\n<line19>** stores the total number of pages on the freelist. */\n<line20>n = get4byte(&pPage1->aData[36]);\n<line21>testcase( n==mxPage-1 );\n<line22>if( n>=mxPage ){\n<line23>return SQLITE_CORRUPT_BKPT;\n<line24>}\n<line25>if( n>0 ){\n<line26>/* There are pages on the freelist.  Reuse one of those pages. */\n<line27>Pgno iTrunk;\n<line28>u8 searchList = 0; /* If the free-list must be searched for 'nearby' */\n<line29>u32 nSearch = 0;   /* Count of the number of search attempts */\n<line30>/* If eMode==BTALLOC_EXACT and a query of the pointer-map\n<line31>** shows that the page 'nearby' is somewhere on the free-list, then\n<line32>** the entire-list will be searched for that page.\n<line33>*/\n<line34>#ifndef SQLITE_OMIT_AUTOVACUUM\n<line35>if( eMode==BTALLOC_EXACT ){\n<line36>if( nearby<=mxPage ){\n<line37>u8 eType;\n<line38>assert( nearby>0 );\n<line39>assert( pBt->autoVacuum );\n<line40>rc = ptrmapGet(pBt, nearby, &eType, 0);\n<line41>if( rc ) return rc;\n<line42>if( eType==PTRMAP_FREEPAGE ){\n<line43>searchList = 1;\n<line44>}\n<line45>}\n<line46>}else if( eMode==BTALLOC_LE ){\n<line47>searchList = 1;\n<line48>}\n<line49>#endif\n<line50>/* Decrement the free-list count by 1. Set iTrunk to the index of the\n<line51>** first free-list trunk page. iPrevTrunk is initially 1.\n<line52>*/\n<line53>rc = sqlite3PagerWrite(pPage1->pDbPage);\n<line54>if( rc ) return rc;\n<line55>put4byte(&pPage1->aData[36], n-1);\n<line56>/* The code within this loop is run only once if the 'searchList' variable\n<line57>** is not true. Otherwise, it runs once for each trunk-page on the\n<line58>** free-list until the page 'nearby' is located (eMode==BTALLOC_EXACT)\n<line59>** or until a page less than 'nearby' is located (eMode==BTALLOC_LT)\n<line60>*/\n<line61>do {\n<line62>pPrevTrunk = pTrunk;\n<line63>if( pPrevTrunk ){\n<line64>/* EVIDENCE-OF: R-01506-11053 The first integer on a freelist trunk page\n<line65>** is the page number of the next freelist trunk page in the list or\n<line66>** zero if this is the last freelist trunk page. */\n<line67>iTrunk = get4byte(&pPrevTrunk->aData[0]);\n<line68>}else{\n<line69>/* EVIDENCE-OF: R-59841-13798 The 4-byte big-endian integer at offset 32\n<line70>** stores the page number of the first page of the freelist, or zero if\n<line71>** the freelist is empty. */\n<line72>iTrunk = get4byte(&pPage1->aData[32]);\n<line73>}\n<line74>testcase( iTrunk==mxPage );\n<line75>if( iTrunk>mxPage || nSearch++ > n ){\n<line76>rc = SQLITE_CORRUPT_PGNO(pPrevTrunk ? pPrevTrunk->pgno : 1);\n<line77>}else{\n<line78>rc = btreeGetUnusedPage(pBt, iTrunk, &pTrunk, 0);\n<line79>}\n<line80>if( rc ){\n<line81>pTrunk = 0;\n<line82>goto end_allocate_page;\n<line83>}\n<line84>assert( pTrunk!=0 );\n<line85>assert( pTrunk->aData!=0 );\n<line86>/* EVIDENCE-OF: R-13523-04394 The second integer on a freelist trunk page\n<line87>** is the number of leaf page pointers to follow. */\n<line88>k = get4byte(&pTrunk->aData[4]);\n<line89>if( k==0 && !searchList ){\n<line90>/* The trunk has no leaves and the list is not being searched.\n<line91>** So extract the trunk page itself and use it as the newly\n<line92>** allocated page */\n<line93>assert( pPrevTrunk==0 );\n<line94>rc = sqlite3PagerWrite(pTrunk->pDbPage);\n<line95>if( rc ){\n<line96>goto end_allocate_page;\n<line97>}\n<line98>*pPgno = iTrunk;\n<line99>memcpy(&pPage1->aData[32], &pTrunk->aData[0], 4);\n<line100>*ppPage = pTrunk;\n<line101>pTrunk = 0;\n<line102>TRACE(("ALLOCATE: %u trunk - %u free pages left\n", *pPgno, n-1));\n<line103>}else if( k>(u32)(pBt->usableSize/4 - 2) ){\n<line104>/* Value of k is out of range.  Database corruption */\n<line105>rc = SQLITE_CORRUPT_PGNO(iTrunk);\n<line106>goto end_allocate_page;\n<line107>#ifndef SQLITE_OMIT_AUTOVACUUM\n<line108>}else if( searchList\n<line109>&& (nearby==iTrunk || (iTrunk<nearby && eMode==BTALLOC_LE))\n<line110>){\n<line111>/* The list is being searched and this trunk page is the page\n<line112>** to allocate, regardless of whether it has leaves.\n<line113>*/\n<line114>*pPgno = iTrunk;\n<line115>*ppPage = pTrunk;\n<line116>searchList = 0;\n<line117>rc = sqlite3PagerWrite(pTrunk->pDbPage);\n<line118>if( rc ){\n<line119>goto end_allocate_page;\n<line120>}\n<line121>if( k==0 ){\n<line122>if( !pPrevTrunk ){\n<line123>memcpy(&pPage1->aData[32], &pTrunk->aData[0], 4);\n<line124>}else{\n<line125>rc = sqlite3PagerWrite(pPrevTrunk->pDbPage);\n<line126>if( rc!=SQLITE_OK ){\n<line127>goto end_allocate_page;\n<line128>}\n<line129>memcpy(&pPrevTrunk->aData[0], &pTrunk->aData[0], 4);\n<line130>}\n<line131>}else{\n<line132>/* The trunk page is required by the caller but it contains\n<line133>** pointers to free-list leaves. The first leaf becomes a trunk\n<line134>** page in this case.\n<line135>*/\n<line136>MemPage *pNewTrunk;\n<line137>Pgno iNewTrunk = get4byte(&pTrunk->aData[8]);\n<line138>if( iNewTrunk>mxPage ){\n<line139>rc = SQLITE_CORRUPT_PGNO(iTrunk);\n<line140>goto end_allocate_page;\n<line141>}\n<line142>testcase( iNewTrunk==mxPage );\n<line143>rc = btreeGetUnusedPage(pBt, iNewTrunk, &pNewTrunk, 0);\n<line144>if( rc!=SQLITE_OK ){\n<line145>goto end_allocate_page;\n<line146>}\n<line147>rc = sqlite3PagerWrite(pNewTrunk->pDbPage);\n<line148>if( rc!=SQLITE_OK ){\n<line149>releasePage(pNewTrunk);\n<line150>goto end_allocate_page;\n<line151>}\n<line152>memcpy(&pNewTrunk->aData[0], &pTrunk->aData[0], 4);\n<line153>put4byte(&pNewTrunk->aData[4], k-1);\n<line154>memcpy(&pNewTrunk->aData[8], &pTrunk->aData[12], (k-1)*4);\n<line155>releasePage(pNewTrunk);\n<line156>if( !pPrevTrunk ){\n<line157>assert( sqlite3PagerIswriteable(pPage1->pDbPage) );\n<line158>put4byte(&pPage1->aData[32], iNewTrunk);\n<line159>}else{\n<line160>rc = sqlite3PagerWrite(pPrevTrunk->pDbPage);\n<line161>if( rc ){\n<line162>goto end_allocate_page;\n<line163>}\n<line164>put4byte(&pPrevTrunk->aData[0], iNewTrunk);\n<line165>}\n<line166>}\n<line167>pTrunk = 0;\n<line168>TRACE(("ALLOCATE: %u trunk - %u free pages left\n", *pPgno, n-1));\n<line169>#endif\n<line170>}else if( k>0 ){\n<line171>/* Extract a leaf from the trunk */\n<line172>u32 closest;\n<line173>Pgno iPage;\n<line174>unsigned char *aData = pTrunk->aData;\n<line175>if( nearby>0 ){\n<line176>u32 i;\n<line177>closest = 0;\n<line178>if( eMode==BTALLOC_LE ){\n<line179>for(i=0; i<k; i++){\n<line180>iPage = get4byte(&aData[8+i*4]);\n<line181>if( iPage<=nearby ){\n<line182>closest = i;\n<line183>break;\n<line184>}\n<line185>}\n<line186>}else{\n<line187>int dist;\n<line188>dist = sqlite3AbsInt32(get4byte(&aData[8]) - nearby);\n<line189>for(i=1; i<k; i++){\n<line190>int d2 = sqlite3AbsInt32(get4byte(&aData[8+i*4]) - nearby);\n<line191>if( d2<dist ){\n<line192>closest = i;\n<line193>dist = d2;\n<line194>}\n<line195>}\n<line196>}\n<line197>}else{\n<line198>closest = 0;\n<line199>}\n<line200>iPage = get4byte(&aData[8+closest*4]);\n<line201>testcase( iPage==mxPage );\n<line202>if( iPage>mxPage || iPage<2 ){\n<line203>rc = SQLITE_CORRUPT_PGNO(iTrunk);\n<line204>goto end_allocate_page;\n<line205>}\n<line206>testcase( iPage==mxPage );\n<line207>if( !searchList\n<line208>|| (iPage==nearby || (iPage<nearby && eMode==BTALLOC_LE))\n<line209>){\n<line210>int noContent;\n<line211>*pPgno = iPage;\n<line212>TRACE(("ALLOCATE: %u was leaf %u of %u on trunk %u"\n<line213>": %u more free pages\n",\n<line214>*pPgno, closest+1, k, pTrunk->pgno, n-1));\n<line215>rc = sqlite3PagerWrite(pTrunk->pDbPage);\n<line216>if( rc ) goto end_allocate_page;\n<line217>if( closest<k-1 ){\n<line218>memcpy(&aData[8+closest*4], &aData[4+k*4], 4);\n<line219>}\n<line220>put4byte(&aData[4], k-1);\n<line221>noContent = !btreeGetHasContent(pBt, *pPgno)? PAGER_GET_NOCONTENT : 0;\n<line222>rc = btreeGetUnusedPage(pBt, *pPgno, ppPage, noContent);\n<line223>if( rc==SQLITE_OK ){\n<line224>rc = sqlite3PagerWrite((*ppPage)->pDbPage);\n<line225>if( rc!=SQLITE_OK ){\n<line226>releasePage(*ppPage);\n<line227>*ppPage = 0;\n<line228>}\n<line229>}\n<line230>searchList = 0;\n<line231>}\n<line232>}\n<line233>releasePage(pPrevTrunk);\n<line234>pPrevTrunk = 0;\n<line235>}while( searchList );\n<line236>}else{\n<line237>/* There are no pages on the freelist, so append a new page to the\n<line238>** database image.\n<line239>**\n<line240>** Normally, new pages allocated by this block can be requested from the\n<line241>** pager layer with the 'no-content' flag set. This prevents the pager\n<line242>** from trying to read the pages content from disk. However, if the\n<line243>** current transaction has already run one or more incremental-vacuum\n<line244>** steps, then the page we are about to allocate may contain content\n<line245>** that is required in the event of a rollback. In this case, do\n<line246>** not set the no-content flag. This causes the pager to load and journal\n<line247>** the current page content before overwriting it.\n<line248>**\n<line249>** Note that the pager will not actually attempt to load or journal\n<line250>** content for any page that really does lie past the end of the database\n<line251>** file on disk. So the effects of disabling the no-content optimization\n<line252>** here are confined to those pages that lie between the end of the\n<line253>** database image and the end of the database file.\n<line254>*/\n<line255>int bNoContent = (0==IfNotOmitAV(pBt->bDoTruncate))? PAGER_GET_NOCONTENT:0;\n<line256>rc = sqlite3PagerWrite(pBt->pPage1->pDbPage);\n<line257>if( rc ) return rc;\n<line258>pBt->nPage++;\n<line259>if( pBt->nPage==PENDING_BYTE_PAGE(pBt) ) pBt->nPage++;\n<line260>#ifndef SQLITE_OMIT_AUTOVACUUM\n<line261>if( pBt->autoVacuum && PTRMAP_ISPAGE(pBt, pBt->nPage) ){\n<line262>/* If *pPgno refers to a pointer-map page, allocate two new pages\n<line263>** at the end of the file instead of one. The first allocated page\n<line264>** becomes a new pointer-map page, the second is used by the caller.\n<line265>*/\n<line266>MemPage *pPg = 0;\n<line267>TRACE(("ALLOCATE: %u from end of file (pointer-map page)\n", pBt->nPage));\n<line268>assert( pBt->nPage!=PENDING_BYTE_PAGE(pBt) );\n<line269>rc = btreeGetUnusedPage(pBt, pBt->nPage, &pPg, bNoContent);\n<line270>if( rc==SQLITE_OK ){\n<line271>rc = sqlite3PagerWrite(pPg->pDbPage);\n<line272>releasePage(pPg);\n<line273>}\n<line274>if( rc ) return rc;\n<line275>pBt->nPage++;\n<line276>if( pBt->nPage==PENDING_BYTE_PAGE(pBt) ){ pBt->nPage++; }\n<line277>}\n<line278>#endif\n<line279>put4byte(28 + (u8*)pBt->pPage1->aData, pBt->nPage);\n<line280>*pPgno = pBt->nPage;\n<line281>assert( *pPgno!=PENDING_BYTE_PAGE(pBt) );\n<line282>rc = btreeGetUnusedPage(pBt, *pPgno, ppPage, bNoContent);\n<line283>if( rc ) return rc;\n<line284>rc = sqlite3PagerWrite((*ppPage)->pDbPage);\n<line285>if( rc!=SQLITE_OK ){\n<line286>releasePage(*ppPage);\n<line287>*ppPage = 0;\n<line288>}\n<line289>TRACE(("ALLOCATE: %u from end of file\n", *pPgno));\n<line290>}\n<line291>assert( CORRUPT_DB || *pPgno!=PENDING_BYTE_PAGE(pBt) );\n<line292>end_allocate_page:\n<line293>releasePage(pTrunk);\n<line294>releasePage(pPrevTrunk);\n<line295>assert( rc!=SQLITE_OK || sqlite3PagerPageRefcount((*ppPage)->pDbPage)<=1 );\n<line296>assert( rc!=SQLITE_OK || (*ppPage)->isInit==0 );\n<line297>return rc;\n<line298>}
----------------------------------------
Function: freePage2
Content: <line0>static int freePage2(BtShared *pBt, MemPage *pMemPage, Pgno iPage){\n<line1>MemPage *pTrunk = 0;                /* Free-list trunk page */\n<line2>Pgno iTrunk = 0;                    /* Page number of free-list trunk page */\n<line3>MemPage *pPage1 = pBt->pPage1;      /* Local reference to page 1 */\n<line4>MemPage *pPage;                     /* Page being freed. May be NULL. */\n<line5>int rc;                             /* Return Code */\n<line6>u32 nFree;                          /* Initial number of pages on free-list */\n<line7>assert( sqlite3_mutex_held(pBt->mutex) );\n<line8>assert( CORRUPT_DB || iPage>1 );\n<line9>assert( !pMemPage || pMemPage->pgno==iPage );\n<line10>if( iPage<2 || iPage>pBt->nPage ){\n<line11>return SQLITE_CORRUPT_BKPT;\n<line12>}\n<line13>if( pMemPage ){\n<line14>pPage = pMemPage;\n<line15>sqlite3PagerRef(pPage->pDbPage);\n<line16>}else{\n<line17>pPage = btreePageLookup(pBt, iPage);\n<line18>}\n<line19>/* Increment the free page count on pPage1 */\n<line20>rc = sqlite3PagerWrite(pPage1->pDbPage);\n<line21>if( rc ) goto freepage_out;\n<line22>nFree = get4byte(&pPage1->aData[36]);\n<line23>put4byte(&pPage1->aData[36], nFree+1);\n<line24>if( pBt->btsFlags & BTS_SECURE_DELETE ){\n<line25>/* If the secure_delete option is enabled, then\n<line26>** always fully overwrite deleted information with zeros.\n<line27>*/\n<line28>if( (!pPage && ((rc = btreeGetPage(pBt, iPage, &pPage, 0))!=0) )\n<line29>||            ((rc = sqlite3PagerWrite(pPage->pDbPage))!=0)\n<line30>){\n<line31>goto freepage_out;\n<line32>}\n<line33>memset(pPage->aData, 0, pPage->pBt->pageSize);\n<line34>}\n<line35>/* If the database supports auto-vacuum, write an entry in the pointer-map\n<line36>** to indicate that the page is free.\n<line37>*/\n<line38>if( ISAUTOVACUUM(pBt) ){\n<line39>ptrmapPut(pBt, iPage, PTRMAP_FREEPAGE, 0, &rc);\n<line40>if( rc ) goto freepage_out;\n<line41>}\n<line42>/* Now manipulate the actual database free-list structure. There are two\n<line43>** possibilities. If the free-list is currently empty, or if the first\n<line44>** trunk page in the free-list is full, then this page will become a\n<line45>** new free-list trunk page. Otherwise, it will become a leaf of the\n<line46>** first trunk page in the current free-list. This block tests if it\n<line47>** is possible to add the page as a new free-list leaf.\n<line48>*/\n<line49>if( nFree!=0 ){\n<line50>u32 nLeaf;                /* Initial number of leaf cells on trunk page */\n<line51>iTrunk = get4byte(&pPage1->aData[32]);\n<line52>if( iTrunk>btreePagecount(pBt) ){\n<line53>rc = SQLITE_CORRUPT_BKPT;\n<line54>goto freepage_out;\n<line55>}\n<line56>rc = btreeGetPage(pBt, iTrunk, &pTrunk, 0);\n<line57>if( rc!=SQLITE_OK ){\n<line58>goto freepage_out;\n<line59>}\n<line60>nLeaf = get4byte(&pTrunk->aData[4]);\n<line61>assert( pBt->usableSize>32 );\n<line62>if( nLeaf > (u32)pBt->usableSize/4 - 2 ){\n<line63>rc = SQLITE_CORRUPT_BKPT;\n<line64>goto freepage_out;\n<line65>}\n<line66>if( nLeaf < (u32)pBt->usableSize/4 - 8 ){\n<line67>/* In this case there is room on the trunk page to insert the page\n<line68>** being freed as a new leaf.\n<line69>**\n<line70>** Note that the trunk page is not really full until it contains\n<line71>** usableSize/4 - 2 entries, not usableSize/4 - 8 entries as we have\n<line72>** coded.  But due to a coding error in versions of SQLite prior to\n<line73>** 3.6.0, databases with freelist trunk pages holding more than\n<line74>** usableSize/4 - 8 entries will be reported as corrupt.  In order\n<line75>** to maintain backwards compatibility with older versions of SQLite,\n<line76>** we will continue to restrict the number of entries to usableSize/4 - 8\n<line77>** for now.  At some point in the future (once everyone has upgraded\n<line78>** to 3.6.0 or later) we should consider fixing the conditional above\n<line79>** to read "usableSize/4-2" instead of "usableSize/4-8".\n<line80>**\n<line81>** EVIDENCE-OF: R-19920-11576 However, newer versions of SQLite still\n<line82>** avoid using the last six entries in the freelist trunk page array in\n<line83>** order that database files created by newer versions of SQLite can be\n<line84>** read by older versions of SQLite.\n<line85>*/\n<line86>rc = sqlite3PagerWrite(pTrunk->pDbPage);\n<line87>if( rc==SQLITE_OK ){\n<line88>put4byte(&pTrunk->aData[4], nLeaf+1);\n<line89>put4byte(&pTrunk->aData[8+nLeaf*4], iPage);\n<line90>if( pPage && (pBt->btsFlags & BTS_SECURE_DELETE)==0 ){\n<line91>sqlite3PagerDontWrite(pPage->pDbPage);\n<line92>}\n<line93>rc = btreeSetHasContent(pBt, iPage);\n<line94>}\n<line95>TRACE(("FREE-PAGE: %u leaf on trunk page %u\n",pPage->pgno,pTrunk->pgno));\n<line96>goto freepage_out;\n<line97>}\n<line98>}\n<line99>/* If control flows to this point, then it was not possible to add the\n<line100>** the page being freed as a leaf page of the first trunk in the free-list.\n<line101>** Possibly because the free-list is empty, or possibly because the\n<line102>** first trunk in the free-list is full. Either way, the page being freed\n<line103>** will become the new first trunk page in the free-list.\n<line104>*/\n<line105>if( pPage==0 && SQLITE_OK!=(rc = btreeGetPage(pBt, iPage, &pPage, 0)) ){\n<line106>goto freepage_out;\n<line107>}\n<line108>rc = sqlite3PagerWrite(pPage->pDbPage);\n<line109>if( rc!=SQLITE_OK ){\n<line110>goto freepage_out;\n<line111>}\n<line112>put4byte(pPage->aData, iTrunk);\n<line113>put4byte(&pPage->aData[4], 0);\n<line114>put4byte(&pPage1->aData[32], iPage);\n<line115>TRACE(("FREE-PAGE: %u new trunk page replacing %u\n", pPage->pgno, iTrunk));\n<line116>freepage_out:\n<line117>if( pPage ){\n<line118>pPage->isInit = 0;\n<line119>}\n<line120>releasePage(pPage);\n<line121>releasePage(pTrunk);\n<line122>return rc;\n<line123>}
----------------------------------------
Function: freePage
Content: <line0>static void freePage(MemPage *pPage, int *pRC){\n<line1>if( (*pRC)==SQLITE_OK ){\n<line2>*pRC = freePage2(pPage->pBt, pPage, pPage->pgno);\n<line3>}\n<line4>}
----------------------------------------
Function: clearCellOverflow
Content: <line0>static SQLITE_NOINLINE int clearCellOverflow(\n<line1>MemPage *pPage,          /* The page that contains the Cell */\n<line2>unsigned char *pCell,    /* First byte of the Cell */\n<line3>CellInfo *pInfo          /* Size information about the cell */\n<line4>){\n<line5>BtShared *pBt;\n<line6>Pgno ovflPgno;\n<line7>int rc;\n<line8>int nOvfl;\n<line9>u32 ovflPageSize;\n<line10>assert( sqlite3_mutex_held(pPage->pBt->mutex) );\n<line11>assert( pInfo->nLocal!=pInfo->nPayload );\n<line12>testcase( pCell + pInfo->nSize == pPage->aDataEnd );\n<line13>testcase( pCell + (pInfo->nSize-1) == pPage->aDataEnd );\n<line14>if( pCell + pInfo->nSize > pPage->aDataEnd ){\n<line15>/* Cell extends past end of page */\n<line16>return SQLITE_CORRUPT_PAGE(pPage);\n<line17>}\n<line18>ovflPgno = get4byte(pCell + pInfo->nSize - 4);\n<line19>pBt = pPage->pBt;\n<line20>assert( pBt->usableSize > 4 );\n<line21>ovflPageSize = pBt->usableSize - 4;\n<line22>nOvfl = (pInfo->nPayload - pInfo->nLocal + ovflPageSize - 1)/ovflPageSize;\n<line23>assert( nOvfl>0 ||\n<line24>(CORRUPT_DB && (pInfo->nPayload + ovflPageSize)<ovflPageSize)\n<line25>);\n<line26>while( nOvfl-- ){\n<line27>Pgno iNext = 0;\n<line28>MemPage *pOvfl = 0;\n<line29>if( ovflPgno<2 || ovflPgno>btreePagecount(pBt) ){\n<line30>/* 0 is not a legal page number and page 1 cannot be an\n<line31>** overflow page. Therefore if ovflPgno<2 or past the end of the\n<line32>** file the database must be corrupt. */\n<line33>return SQLITE_CORRUPT_BKPT;\n<line34>}\n<line35>if( nOvfl ){\n<line36>rc = getOverflowPage(pBt, ovflPgno, &pOvfl, &iNext);\n<line37>if( rc ) return rc;\n<line38>}\n<line39>if( ( pOvfl || ((pOvfl = btreePageLookup(pBt, ovflPgno))!=0) )\n<line40>&& sqlite3PagerPageRefcount(pOvfl->pDbPage)!=1\n<line41>){\n<line42>/* There is no reason any cursor should have an outstanding reference\n<line43>** to an overflow page belonging to a cell that is being deleted/updated.\n<line44>** So if there exists more than one reference to this page, then it\n<line45>** must not really be an overflow page and the database must be corrupt.\n<line46>** It is helpful to detect this before calling freePage2(), as\n<line47>** freePage2() may zero the page contents if secure-delete mode is\n<line48>** enabled. If this 'overflow' page happens to be a page that the\n<line49>** caller is iterating through or using in some other way, this\n<line50>** can be problematic.\n<line51>*/\n<line52>rc = SQLITE_CORRUPT_BKPT;\n<line53>}else{\n<line54>rc = freePage2(pBt, pOvfl, ovflPgno);\n<line55>}\n<line56>if( pOvfl ){\n<line57>sqlite3PagerUnref(pOvfl->pDbPage);\n<line58>}\n<line59>if( rc ) return rc;\n<line60>ovflPgno = iNext;\n<line61>}\n<line62>return SQLITE_OK;\n<line63>}
----------------------------------------
Function: fillInCell
Content: <line0>static int fillInCell(\n<line1>MemPage *pPage,                /* The page that contains the cell */\n<line2>unsigned char *pCell,          /* Complete text of the cell */\n<line3>const BtreePayload *pX,        /* Payload with which to construct the cell */\n<line4>int *pnSize                    /* Write cell size here */\n<line5>){\n<line6>int nPayload;\n<line7>const u8 *pSrc;\n<line8>int nSrc, n, rc, mn;\n<line9>int spaceLeft;\n<line10>MemPage *pToRelease;\n<line11>unsigned char *pPrior;\n<line12>unsigned char *pPayload;\n<line13>BtShared *pBt;\n<line14>Pgno pgnoOvfl;\n<line15>int nHeader;\n<line16>assert( sqlite3_mutex_held(pPage->pBt->mutex) );\n<line17>/* pPage is not necessarily writeable since pCell might be auxiliary\n<line18>** buffer space that is separate from the pPage buffer area */\n<line19>assert( pCell<pPage->aData || pCell>=&pPage->aData[pPage->pBt->pageSize]\n<line20>|| sqlite3PagerIswriteable(pPage->pDbPage) );\n<line21>/* Fill in the header. */\n<line22>nHeader = pPage->childPtrSize;\n<line23>if( pPage->intKey ){\n<line24>nPayload = pX->nData + pX->nZero;\n<line25>pSrc = pX->pData;\n<line26>nSrc = pX->nData;\n<line27>assert( pPage->intKeyLeaf ); /* fillInCell() only called for leaves */\n<line28>nHeader += putVarint32(&pCell[nHeader], nPayload);\n<line29>nHeader += putVarint(&pCell[nHeader], *(u64*)&pX->nKey);\n<line30>}else{\n<line31>assert( pX->nKey<=0x7fffffff && pX->pKey!=0 );\n<line32>nSrc = nPayload = (int)pX->nKey;\n<line33>pSrc = pX->pKey;\n<line34>nHeader += putVarint32(&pCell[nHeader], nPayload);\n<line35>}\n<line36>/* Fill in the payload */\n<line37>pPayload = &pCell[nHeader];\n<line38>if( nPayload<=pPage->maxLocal ){\n<line39>/* This is the common case where everything fits on the btree page\n<line40>** and no overflow pages are required. */\n<line41>n = nHeader + nPayload;\n<line42>testcase( n==3 );\n<line43>testcase( n==4 );\n<line44>if( n<4 ){\n<line45>n = 4;\n<line46>pPayload[nPayload] = 0;\n<line47>}\n<line48>*pnSize = n;\n<line49>assert( nSrc<=nPayload );\n<line50>testcase( nSrc<nPayload );\n<line51>memcpy(pPayload, pSrc, nSrc);\n<line52>memset(pPayload+nSrc, 0, nPayload-nSrc);\n<line53>return SQLITE_OK;\n<line54>}\n<line55>/* If we reach this point, it means that some of the content will need\n<line56>** to spill onto overflow pages.\n<line57>*/\n<line58>mn = pPage->minLocal;\n<line59>n = mn + (nPayload - mn) % (pPage->pBt->usableSize - 4);\n<line60>testcase( n==pPage->maxLocal );\n<line61>testcase( n==pPage->maxLocal+1 );\n<line62>if( n > pPage->maxLocal ) n = mn;\n<line63>spaceLeft = n;\n<line64>*pnSize = n + nHeader + 4;\n<line65>pPrior = &pCell[nHeader+n];\n<line66>pToRelease = 0;\n<line67>pgnoOvfl = 0;\n<line68>pBt = pPage->pBt;\n<line69>/* At this point variables should be set as follows:\n<line70>**\n<line71>**   nPayload           Total payload size in bytes\n<line72>**   pPayload           Begin writing payload here\n<line73>**   spaceLeft          Space available at pPayload.  If nPayload>spaceLeft,\n<line74>**                      that means content must spill into overflow pages.\n<line75>**   *pnSize            Size of the local cell (not counting overflow pages)\n<line76>**   pPrior             Where to write the pgno of the first overflow page\n<line77>**\n<line78>** Use a call to btreeParseCellPtr() to verify that the values above\n<line79>** were computed correctly.\n<line80>*/\n<line81>#ifdef SQLITE_DEBUG\n<line82>{\n<line83>CellInfo info;\n<line84>pPage->xParseCell(pPage, pCell, &info);\n<line85>assert( nHeader==(int)(info.pPayload - pCell) );\n<line86>assert( info.nKey==pX->nKey );\n<line87>assert( *pnSize == info.nSize );\n<line88>assert( spaceLeft == info.nLocal );\n<line89>}\n<line90>#endif\n<line91>/* Write the payload into the local Cell and any extra into overflow pages */\n<line92>while( 1 ){\n<line93>n = nPayload;\n<line94>if( n>spaceLeft ) n = spaceLeft;\n<line95>/* If pToRelease is not zero than pPayload points into the data area\n<line96>** of pToRelease.  Make sure pToRelease is still writeable. */\n<line97>assert( pToRelease==0 || sqlite3PagerIswriteable(pToRelease->pDbPage) );\n<line98>/* If pPayload is part of the data area of pPage, then make sure pPage\n<line99>** is still writeable */\n<line100>assert( pPayload<pPage->aData || pPayload>=&pPage->aData[pBt->pageSize]\n<line101>|| sqlite3PagerIswriteable(pPage->pDbPage) );\n<line102>if( nSrc>=n ){\n<line103>memcpy(pPayload, pSrc, n);\n<line104>}else if( nSrc>0 ){\n<line105>n = nSrc;\n<line106>memcpy(pPayload, pSrc, n);\n<line107>}else{\n<line108>memset(pPayload, 0, n);\n<line109>}\n<line110>nPayload -= n;\n<line111>if( nPayload<=0 ) break;\n<line112>pPayload += n;\n<line113>pSrc += n;\n<line114>nSrc -= n;\n<line115>spaceLeft -= n;\n<line116>if( spaceLeft==0 ){\n<line117>MemPage *pOvfl = 0;\n<line118>#ifndef SQLITE_OMIT_AUTOVACUUM\n<line119>Pgno pgnoPtrmap = pgnoOvfl; /* Overflow page pointer-map entry page */\n<line120>if( pBt->autoVacuum ){\n<line121>do{\n<line122>pgnoOvfl++;\n<line123>} while(\n<line124>PTRMAP_ISPAGE(pBt, pgnoOvfl) || pgnoOvfl==PENDING_BYTE_PAGE(pBt)\n<line125>);\n<line126>}\n<line127>#endif\n<line128>rc = allocateBtreePage(pBt, &pOvfl, &pgnoOvfl, pgnoOvfl, 0);\n<line129>#ifndef SQLITE_OMIT_AUTOVACUUM\n<line130>/* If the database supports auto-vacuum, and the second or subsequent\n<line131>** overflow page is being allocated, add an entry to the pointer-map\n<line132>** for that page now.\n<line133>**\n<line134>** If this is the first overflow page, then write a partial entry\n<line135>** to the pointer-map. If we write nothing to this pointer-map slot,\n<line136>** then the optimistic overflow chain processing in clearCell()\n<line137>** may misinterpret the uninitialized values and delete the\n<line138>** wrong pages from the database.\n<line139>*/\n<line140>if( pBt->autoVacuum && rc==SQLITE_OK ){\n<line141>u8 eType = (pgnoPtrmap?PTRMAP_OVERFLOW2:PTRMAP_OVERFLOW1);\n<line142>ptrmapPut(pBt, pgnoOvfl, eType, pgnoPtrmap, &rc);\n<line143>if( rc ){\n<line144>releasePage(pOvfl);\n<line145>}\n<line146>}\n<line147>#endif\n<line148>if( rc ){\n<line149>releasePage(pToRelease);\n<line150>return rc;\n<line151>}\n<line152>/* If pToRelease is not zero than pPrior points into the data area\n<line153>** of pToRelease.  Make sure pToRelease is still writeable. */\n<line154>assert( pToRelease==0 || sqlite3PagerIswriteable(pToRelease->pDbPage) );\n<line155>/* If pPrior is part of the data area of pPage, then make sure pPage\n<line156>** is still writeable */\n<line157>assert( pPrior<pPage->aData || pPrior>=&pPage->aData[pBt->pageSize]\n<line158>|| sqlite3PagerIswriteable(pPage->pDbPage) );\n<line159>put4byte(pPrior, pgnoOvfl);\n<line160>releasePage(pToRelease);\n<line161>pToRelease = pOvfl;\n<line162>pPrior = pOvfl->aData;\n<line163>put4byte(pPrior, 0);\n<line164>pPayload = &pOvfl->aData[4];\n<line165>spaceLeft = pBt->usableSize - 4;\n<line166>}\n<line167>}\n<line168>releasePage(pToRelease);\n<line169>return SQLITE_OK;\n<line170>}
----------------------------------------
Function: dropCell
Content: <line0>static void dropCell(MemPage *pPage, int idx, int sz, int *pRC){\n<line1>u32 pc;         /* Offset to cell content of cell being deleted */\n<line2>u8 *data;       /* pPage->aData */\n<line3>u8 *ptr;        /* Used to move bytes around within data[] */\n<line4>int rc;         /* The return code */\n<line5>int hdr;        /* Beginning of the header.  0 most pages.  100 page 1 */\n<line6>if( *pRC ) return;\n<line7>assert( idx>=0 );\n<line8>assert( idx<pPage->nCell );\n<line9>assert( CORRUPT_DB || sz==cellSize(pPage, idx) );\n<line10>assert( sqlite3PagerIswriteable(pPage->pDbPage) );\n<line11>assert( sqlite3_mutex_held(pPage->pBt->mutex) );\n<line12>assert( pPage->nFree>=0 );\n<line13>data = pPage->aData;\n<line14>ptr = &pPage->aCellIdx[2*idx];\n<line15>assert( pPage->pBt->usableSize > (u32)(ptr-data) );\n<line16>pc = get2byte(ptr);\n<line17>hdr = pPage->hdrOffset;\n<line18>testcase( pc==(u32)get2byte(&data[hdr+5]) );\n<line19>testcase( pc+sz==pPage->pBt->usableSize );\n<line20>if( pc+sz > pPage->pBt->usableSize ){\n<line21>*pRC = SQLITE_CORRUPT_BKPT;\n<line22>return;\n<line23>}\n<line24>rc = freeSpace(pPage, pc, sz);\n<line25>if( rc ){\n<line26>*pRC = rc;\n<line27>return;\n<line28>}\n<line29>pPage->nCell--;\n<line30>if( pPage->nCell==0 ){\n<line31>memset(&data[hdr+1], 0, 4);\n<line32>data[hdr+7] = 0;\n<line33>put2byte(&data[hdr+5], pPage->pBt->usableSize);\n<line34>pPage->nFree = pPage->pBt->usableSize - pPage->hdrOffset\n<line35>- pPage->childPtrSize - 8;\n<line36>}else{\n<line37>memmove(ptr, ptr+2, 2*(pPage->nCell - idx));\n<line38>put2byte(&data[hdr+3], pPage->nCell);\n<line39>pPage->nFree += 2;\n<line40>}\n<line41>}
----------------------------------------
Function: insertCell
Content: <line0>static int insertCell(\n<line1>MemPage *pPage,   /* Page into which we are copying */\n<line2>int i,            /* New cell becomes the i-th cell of the page */\n<line3>u8 *pCell,        /* Content of the new cell */\n<line4>int sz,           /* Bytes of content in pCell */\n<line5>u8 *pTemp,        /* Temp storage space for pCell, if needed */\n<line6>Pgno iChild       /* If non-zero, replace first 4 bytes with this value */\n<line7>){\n<line8>int idx = 0;      /* Where to write new cell content in data[] */\n<line9>int j;            /* Loop counter */\n<line10>u8 *data;         /* The content of the whole page */\n<line11>u8 *pIns;         /* The point in pPage->aCellIdx[] where no cell inserted */\n<line12>assert( i>=0 && i<=pPage->nCell+pPage->nOverflow );\n<line13>assert( MX_CELL(pPage->pBt)<=10921 );\n<line14>assert( pPage->nCell<=MX_CELL(pPage->pBt) || CORRUPT_DB );\n<line15>assert( pPage->nOverflow<=ArraySize(pPage->apOvfl) );\n<line16>assert( ArraySize(pPage->apOvfl)==ArraySize(pPage->aiOvfl) );\n<line17>assert( sqlite3_mutex_held(pPage->pBt->mutex) );\n<line18>assert( sz==pPage->xCellSize(pPage, pCell) || CORRUPT_DB );\n<line19>assert( pPage->nFree>=0 );\n<line20>assert( iChild>0 );\n<line21>if( pPage->nOverflow || sz+2>pPage->nFree ){\n<line22>if( pTemp ){\n<line23>memcpy(pTemp, pCell, sz);\n<line24>pCell = pTemp;\n<line25>}\n<line26>put4byte(pCell, iChild);\n<line27>j = pPage->nOverflow++;\n<line28>/* Comparison against ArraySize-1 since we hold back one extra slot\n<line29>** as a contingency.  In other words, never need more than 3 overflow\n<line30>** slots but 4 are allocated, just to be safe. */\n<line31>assert( j < ArraySize(pPage->apOvfl)-1 );\n<line32>pPage->apOvfl[j] = pCell;\n<line33>pPage->aiOvfl[j] = (u16)i;\n<line34>/* When multiple overflows occur, they are always sequential and in\n<line35>** sorted order.  This invariants arise because multiple overflows can\n<line36>** only occur when inserting divider cells into the parent page during\n<line37>** balancing, and the dividers are adjacent and sorted.\n<line38>*/\n<line39>assert( j==0 || pPage->aiOvfl[j-1]<(u16)i ); /* Overflows in sorted order */\n<line40>assert( j==0 || i==pPage->aiOvfl[j-1]+1 );   /* Overflows are sequential */\n<line41>}else{\n<line42>int rc = sqlite3PagerWrite(pPage->pDbPage);\n<line43>if( NEVER(rc!=SQLITE_OK) ){\n<line44>return rc;\n<line45>}\n<line46>assert( sqlite3PagerIswriteable(pPage->pDbPage) );\n<line47>data = pPage->aData;\n<line48>assert( &data[pPage->cellOffset]==pPage->aCellIdx );\n<line49>rc = allocateSpace(pPage, sz, &idx);\n<line50>if( rc ){ return rc; }\n<line51>/* The allocateSpace() routine guarantees the following properties\n<line52>** if it returns successfully */\n<line53>assert( idx >= 0 );\n<line54>assert( idx >= pPage->cellOffset+2*pPage->nCell+2 || CORRUPT_DB );\n<line55>assert( idx+sz <= (int)pPage->pBt->usableSize );\n<line56>pPage->nFree -= (u16)(2 + sz);\n<line57>/* In a corrupt database where an entry in the cell index section of\n<line58>** a btree page has a value of 3 or less, the pCell value might point\n<line59>** as many as 4 bytes in front of the start of the aData buffer for\n<line60>** the source page.  Make sure this does not cause problems by not\n<line61>** reading the first 4 bytes */\n<line62>memcpy(&data[idx+4], pCell+4, sz-4);\n<line63>put4byte(&data[idx], iChild);\n<line64>pIns = pPage->aCellIdx + i*2;\n<line65>memmove(pIns+2, pIns, 2*(pPage->nCell - i));\n<line66>put2byte(pIns, idx);\n<line67>pPage->nCell++;\n<line68>/* increment the cell count */\n<line69>if( (++data[pPage->hdrOffset+4])==0 ) data[pPage->hdrOffset+3]++;\n<line70>assert( get2byte(&data[pPage->hdrOffset+3])==pPage->nCell || CORRUPT_DB );\n<line71>#ifndef SQLITE_OMIT_AUTOVACUUM\n<line72>if( pPage->pBt->autoVacuum ){\n<line73>int rc2 = SQLITE_OK;\n<line74>/* The cell may contain a pointer to an overflow page. If so, write\n<line75>** the entry for the overflow page into the pointer map.\n<line76>*/\n<line77>ptrmapPutOvflPtr(pPage, pPage, pCell, &rc2);\n<line78>if( rc2 ) return rc2;\n<line79>}\n<line80>#endif\n<line81>}\n<line82>return SQLITE_OK;\n<line83>}
----------------------------------------
Function: insertCellFast
Content: <line0>static int insertCellFast(\n<line1>MemPage *pPage,   /* Page into which we are copying */\n<line2>int i,            /* New cell becomes the i-th cell of the page */\n<line3>u8 *pCell,        /* Content of the new cell */\n<line4>int sz            /* Bytes of content in pCell */\n<line5>){\n<line6>int idx = 0;      /* Where to write new cell content in data[] */\n<line7>int j;            /* Loop counter */\n<line8>u8 *data;         /* The content of the whole page */\n<line9>u8 *pIns;         /* The point in pPage->aCellIdx[] where no cell inserted */\n<line10>assert( i>=0 && i<=pPage->nCell+pPage->nOverflow );\n<line11>assert( MX_CELL(pPage->pBt)<=10921 );\n<line12>assert( pPage->nCell<=MX_CELL(pPage->pBt) || CORRUPT_DB );\n<line13>assert( pPage->nOverflow<=ArraySize(pPage->apOvfl) );\n<line14>assert( ArraySize(pPage->apOvfl)==ArraySize(pPage->aiOvfl) );\n<line15>assert( sqlite3_mutex_held(pPage->pBt->mutex) );\n<line16>assert( sz==pPage->xCellSize(pPage, pCell) || CORRUPT_DB );\n<line17>assert( pPage->nFree>=0 );\n<line18>assert( pPage->nOverflow==0 );\n<line19>if( sz+2>pPage->nFree ){\n<line20>j = pPage->nOverflow++;\n<line21>/* Comparison against ArraySize-1 since we hold back one extra slot\n<line22>** as a contingency.  In other words, never need more than 3 overflow\n<line23>** slots but 4 are allocated, just to be safe. */\n<line24>assert( j < ArraySize(pPage->apOvfl)-1 );\n<line25>pPage->apOvfl[j] = pCell;\n<line26>pPage->aiOvfl[j] = (u16)i;\n<line27>/* When multiple overflows occur, they are always sequential and in\n<line28>** sorted order.  This invariants arise because multiple overflows can\n<line29>** only occur when inserting divider cells into the parent page during\n<line30>** balancing, and the dividers are adjacent and sorted.\n<line31>*/\n<line32>assert( j==0 || pPage->aiOvfl[j-1]<(u16)i ); /* Overflows in sorted order */\n<line33>assert( j==0 || i==pPage->aiOvfl[j-1]+1 );   /* Overflows are sequential */\n<line34>}else{\n<line35>int rc = sqlite3PagerWrite(pPage->pDbPage);\n<line36>if( rc!=SQLITE_OK ){\n<line37>return rc;\n<line38>}\n<line39>assert( sqlite3PagerIswriteable(pPage->pDbPage) );\n<line40>data = pPage->aData;\n<line41>assert( &data[pPage->cellOffset]==pPage->aCellIdx );\n<line42>rc = allocateSpace(pPage, sz, &idx);\n<line43>if( rc ){ return rc; }\n<line44>/* The allocateSpace() routine guarantees the following properties\n<line45>** if it returns successfully */\n<line46>assert( idx >= 0 );\n<line47>assert( idx >= pPage->cellOffset+2*pPage->nCell+2 || CORRUPT_DB );\n<line48>assert( idx+sz <= (int)pPage->pBt->usableSize );\n<line49>pPage->nFree -= (u16)(2 + sz);\n<line50>memcpy(&data[idx], pCell, sz);\n<line51>pIns = pPage->aCellIdx + i*2;\n<line52>memmove(pIns+2, pIns, 2*(pPage->nCell - i));\n<line53>put2byte(pIns, idx);\n<line54>pPage->nCell++;\n<line55>/* increment the cell count */\n<line56>if( (++data[pPage->hdrOffset+4])==0 ) data[pPage->hdrOffset+3]++;\n<line57>assert( get2byte(&data[pPage->hdrOffset+3])==pPage->nCell || CORRUPT_DB );\n<line58>#ifndef SQLITE_OMIT_AUTOVACUUM\n<line59>if( pPage->pBt->autoVacuum ){\n<line60>int rc2 = SQLITE_OK;\n<line61>/* The cell may contain a pointer to an overflow page. If so, write\n<line62>** the entry for the overflow page into the pointer map.\n<line63>*/\n<line64>ptrmapPutOvflPtr(pPage, pPage, pCell, &rc2);\n<line65>if( rc2 ) return rc2;\n<line66>}\n<line67>#endif\n<line68>}\n<line69>return SQLITE_OK;\n<line70>}
----------------------------------------
Function: populateCellCache
Content: <line0>static void populateCellCache(CellArray *p, int idx, int N){\n<line1>MemPage *pRef = p->pRef;\n<line2>u16 *szCell = p->szCell;\n<line3>assert( idx>=0 && idx+N<=p->nCell );\n<line4>while( N>0 ){\n<line5>assert( p->apCell[idx]!=0 );\n<line6>if( szCell[idx]==0 ){\n<line7>szCell[idx] = pRef->xCellSize(pRef, p->apCell[idx]);\n<line8>}else{\n<line9>assert( CORRUPT_DB ||\n<line10>szCell[idx]==pRef->xCellSize(pRef, p->apCell[idx]) );\n<line11>}\n<line12>idx++;\n<line13>N--;\n<line14>}\n<line15>}
----------------------------------------
Function: computeCellSize
Content: <line0>static SQLITE_NOINLINE u16 computeCellSize(CellArray *p, int N){\n<line1>assert( N>=0 && N<p->nCell );\n<line2>assert( p->szCell[N]==0 );\n<line3>p->szCell[N] = p->pRef->xCellSize(p->pRef, p->apCell[N]);\n<line4>return p->szCell[N];\n<line5>}
----------------------------------------
Function: cachedCellSize
Content: <line0>static u16 cachedCellSize(CellArray *p, int N){\n<line1>assert( N>=0 && N<p->nCell );\n<line2>if( p->szCell[N] ) return p->szCell[N];\n<line3>return computeCellSize(p, N);\n<line4>}
----------------------------------------
Function: rebuildPage
Content: <line0>static int rebuildPage(\n<line1>CellArray *pCArray,             /* Content to be added to page pPg */\n<line2>int iFirst,                     /* First cell in pCArray to use */\n<line3>int nCell,                      /* Final number of cells on page */\n<line4>MemPage *pPg                    /* The page to be reconstructed */\n<line5>){\n<line6>const int hdr = pPg->hdrOffset;          /* Offset of header on pPg */\n<line7>u8 * const aData = pPg->aData;           /* Pointer to data for pPg */\n<line8>const int usableSize = pPg->pBt->usableSize;\n<line9>u8 * const pEnd = &aData[usableSize];\n<line10>int i = iFirst;                 /* Which cell to copy from pCArray*/\n<line11>u32 j;                          /* Start of cell content area */\n<line12>int iEnd = i+nCell;             /* Loop terminator */\n<line13>u8 *pCellptr = pPg->aCellIdx;\n<line14>u8 *pTmp = sqlite3PagerTempSpace(pPg->pBt->pPager);\n<line15>u8 *pData;\n<line16>int k;                          /* Current slot in pCArray->apEnd[] */\n<line17>u8 *pSrcEnd;                    /* Current pCArray->apEnd[k] value */\n<line18>assert( nCell>0 );\n<line19>assert( i<iEnd );\n<line20>j = get2byte(&aData[hdr+5]);\n<line21>if( j>(u32)usableSize ){ j = 0; }\n<line22>memcpy(&pTmp[j], &aData[j], usableSize - j);\n<line23>assert( pCArray->ixNx[NB*2-1]>i );\n<line24>for(k=0; pCArray->ixNx[k]<=i; k++){}\n<line25>pSrcEnd = pCArray->apEnd[k];\n<line26>pData = pEnd;\n<line27>while( 1/*exit by break*/ ){\n<line28>u8 *pCell = pCArray->apCell[i];\n<line29>u16 sz = pCArray->szCell[i];\n<line30>assert( sz>0 );\n<line31>if( SQLITE_WITHIN(pCell,aData+j,pEnd) ){\n<line32>if( ((uptr)(pCell+sz))>(uptr)pEnd ) return SQLITE_CORRUPT_BKPT;\n<line33>pCell = &pTmp[pCell - aData];\n<line34>}else if( (uptr)(pCell+sz)>(uptr)pSrcEnd\n<line35>&& (uptr)(pCell)<(uptr)pSrcEnd\n<line36>){\n<line37>return SQLITE_CORRUPT_BKPT;\n<line38>}\n<line39>pData -= sz;\n<line40>put2byte(pCellptr, (pData - aData));\n<line41>pCellptr += 2;\n<line42>if( pData < pCellptr ) return SQLITE_CORRUPT_BKPT;\n<line43>memmove(pData, pCell, sz);\n<line44>assert( sz==pPg->xCellSize(pPg, pCell) || CORRUPT_DB );\n<line45>i++;\n<line46>if( i>=iEnd ) break;\n<line47>if( pCArray->ixNx[k]<=i ){\n<line48>k++;\n<line49>pSrcEnd = pCArray->apEnd[k];\n<line50>}\n<line51>}\n<line52>/* The pPg->nFree field is now set incorrectly. The caller will fix it. */\n<line53>assert( nCell < 10922 );\n<line54>pPg->nCell = (u16)nCell;\n<line55>pPg->nOverflow = 0;\n<line56>put2byte(&aData[hdr+1], 0);\n<line57>put2byte(&aData[hdr+3], pPg->nCell);\n<line58>put2byte(&aData[hdr+5], pData - aData);\n<line59>aData[hdr+7] = 0x00;\n<line60>return SQLITE_OK;\n<line61>}
----------------------------------------
Function: pageInsertArray
Content: <line0>static int pageInsertArray(\n<line1>MemPage *pPg,                   /* Page to add cells to */\n<line2>u8 *pBegin,                     /* End of cell-pointer array */\n<line3>u8 **ppData,                    /* IN/OUT: Page content-area pointer */\n<line4>u8 *pCellptr,                   /* Pointer to cell-pointer area */\n<line5>int iFirst,                     /* Index of first cell to add */\n<line6>int nCell,                      /* Number of cells to add to pPg */\n<line7>CellArray *pCArray              /* Array of cells */\n<line8>){\n<line9>int i = iFirst;                 /* Loop counter - cell index to insert */\n<line10>u8 *aData = pPg->aData;         /* Complete page */\n<line11>u8 *pData = *ppData;            /* Content area.  A subset of aData[] */\n<line12>int iEnd = iFirst + nCell;      /* End of loop. One past last cell to ins */\n<line13>int k;                          /* Current slot in pCArray->apEnd[] */\n<line14>u8 *pEnd;                       /* Maximum extent of cell data */\n<line15>assert( CORRUPT_DB || pPg->hdrOffset==0 );    /* Never called on page 1 */\n<line16>if( iEnd<=iFirst ) return 0;\n<line17>assert( pCArray->ixNx[NB*2-1]>i );\n<line18>for(k=0; pCArray->ixNx[k]<=i ; k++){}\n<line19>pEnd = pCArray->apEnd[k];\n<line20>while( 1 /*Exit by break*/ ){\n<line21>int sz, rc;\n<line22>u8 *pSlot;\n<line23>assert( pCArray->szCell[i]!=0 );\n<line24>sz = pCArray->szCell[i];\n<line25>if( (aData[1]==0 && aData[2]==0) || (pSlot = pageFindSlot(pPg,sz,&rc))==0 ){\n<line26>if( (pData - pBegin)<sz ) return 1;\n<line27>pData -= sz;\n<line28>pSlot = pData;\n<line29>}\n<line30>/* pSlot and pCArray->apCell[i] will never overlap on a well-formed\n<line31>** database.  But they might for a corrupt database.  Hence use memmove()\n<line32>** since memcpy() sends SIGABORT with overlapping buffers on OpenBSD */\n<line33>assert( (pSlot+sz)<=pCArray->apCell[i]\n<line34>|| pSlot>=(pCArray->apCell[i]+sz)\n<line35>|| CORRUPT_DB );\n<line36>if( (uptr)(pCArray->apCell[i]+sz)>(uptr)pEnd\n<line37>&& (uptr)(pCArray->apCell[i])<(uptr)pEnd\n<line38>){\n<line39>assert( CORRUPT_DB );\n<line40>(void)SQLITE_CORRUPT_BKPT;\n<line41>return 1;\n<line42>}\n<line43>memmove(pSlot, pCArray->apCell[i], sz);\n<line44>put2byte(pCellptr, (pSlot - aData));\n<line45>pCellptr += 2;\n<line46>i++;\n<line47>if( i>=iEnd ) break;\n<line48>if( pCArray->ixNx[k]<=i ){\n<line49>k++;\n<line50>pEnd = pCArray->apEnd[k];\n<line51>}\n<line52>}\n<line53>*ppData = pData;\n<line54>return 0;\n<line55>}
----------------------------------------
Function: pageFreeArray
Content: <line0>static int pageFreeArray(\n<line1>MemPage *pPg,                   /* Page to edit */\n<line2>int iFirst,                     /* First cell to delete */\n<line3>int nCell,                      /* Cells to delete */\n<line4>CellArray *pCArray              /* Array of cells */\n<line5>){\n<line6>u8 * const aData = pPg->aData;\n<line7>u8 * const pEnd = &aData[pPg->pBt->usableSize];\n<line8>u8 * const pStart = &aData[pPg->hdrOffset + 8 + pPg->childPtrSize];\n<line9>int nRet = 0;\n<line10>int i, j;\n<line11>int iEnd = iFirst + nCell;\n<line12>int nFree = 0;\n<line13>int aOfst[10];\n<line14>int aAfter[10];\n<line15>for(i=iFirst; i<iEnd; i++){\n<line16>u8 *pCell = pCArray->apCell[i];\n<line17>if( SQLITE_WITHIN(pCell, pStart, pEnd) ){\n<line18>int sz;\n<line19>int iAfter;\n<line20>int iOfst;\n<line21>/* No need to use cachedCellSize() here.  The sizes of all cells that\n<line22>** are to be freed have already been computing while deciding which\n<line23>** cells need freeing */\n<line24>sz = pCArray->szCell[i];  assert( sz>0 );\n<line25>iOfst = (u16)(pCell - aData);\n<line26>iAfter = iOfst+sz;\n<line27>for(j=0; j<nFree; j++){\n<line28>if( aOfst[j]==iAfter ){\n<line29>aOfst[j] = iOfst;\n<line30>break;\n<line31>}else if( aAfter[j]==iOfst ){\n<line32>aAfter[j] = iAfter;\n<line33>break;\n<line34>}\n<line35>}\n<line36>if( j>=nFree ){\n<line37>if( nFree>=(int)(sizeof(aOfst)/sizeof(aOfst[0])) ){\n<line38>for(j=0; j<nFree; j++){\n<line39>freeSpace(pPg, aOfst[j], aAfter[j]-aOfst[j]);\n<line40>}\n<line41>nFree = 0;\n<line42>}\n<line43>aOfst[nFree] = iOfst;\n<line44>aAfter[nFree] = iAfter;\n<line45>if( &aData[iAfter]>pEnd ) return 0;\n<line46>nFree++;\n<line47>}\n<line48>nRet++;\n<line49>}\n<line50>}\n<line51>for(j=0; j<nFree; j++){\n<line52>freeSpace(pPg, aOfst[j], aAfter[j]-aOfst[j]);\n<line53>}\n<line54>return nRet;\n<line55>}
----------------------------------------
Function: editPage
Content: <line0>static int editPage(\n<line1>MemPage *pPg,                   /* Edit this page */\n<line2>int iOld,                       /* Index of first cell currently on page */\n<line3>int iNew,                       /* Index of new first cell on page */\n<line4>int nNew,                       /* Final number of cells on page */\n<line5>CellArray *pCArray              /* Array of cells and sizes */\n<line6>){\n<line7>u8 * const aData = pPg->aData;\n<line8>const int hdr = pPg->hdrOffset;\n<line9>u8 *pBegin = &pPg->aCellIdx[nNew * 2];\n<line10>int nCell = pPg->nCell;       /* Cells stored on pPg */\n<line11>u8 *pData;\n<line12>u8 *pCellptr;\n<line13>int i;\n<line14>int iOldEnd = iOld + pPg->nCell + pPg->nOverflow;\n<line15>int iNewEnd = iNew + nNew;\n<line16>#ifdef SQLITE_DEBUG\n<line17>u8 *pTmp = sqlite3PagerTempSpace(pPg->pBt->pPager);\n<line18>memcpy(pTmp, aData, pPg->pBt->usableSize);\n<line19>#endif\n<line20>/* Remove cells from the start and end of the page */\n<line21>assert( nCell>=0 );\n<line22>if( iOld<iNew ){\n<line23>int nShift = pageFreeArray(pPg, iOld, iNew-iOld, pCArray);\n<line24>if( NEVER(nShift>nCell) ) return SQLITE_CORRUPT_BKPT;\n<line25>memmove(pPg->aCellIdx, &pPg->aCellIdx[nShift*2], nCell*2);\n<line26>nCell -= nShift;\n<line27>}\n<line28>if( iNewEnd < iOldEnd ){\n<line29>int nTail = pageFreeArray(pPg, iNewEnd, iOldEnd - iNewEnd, pCArray);\n<line30>assert( nCell>=nTail );\n<line31>nCell -= nTail;\n<line32>}\n<line33>pData = &aData[get2byte(&aData[hdr+5])];\n<line34>if( pData<pBegin ) goto editpage_fail;\n<line35>if( NEVER(pData>pPg->aDataEnd) ) goto editpage_fail;\n<line36>/* Add cells to the start of the page */\n<line37>if( iNew<iOld ){\n<line38>int nAdd = MIN(nNew,iOld-iNew);\n<line39>assert( (iOld-iNew)<nNew || nCell==0 || CORRUPT_DB );\n<line40>assert( nAdd>=0 );\n<line41>pCellptr = pPg->aCellIdx;\n<line42>memmove(&pCellptr[nAdd*2], pCellptr, nCell*2);\n<line43>if( pageInsertArray(\n<line44>pPg, pBegin, &pData, pCellptr,\n<line45>iNew, nAdd, pCArray\n<line46>) ) goto editpage_fail;\n<line47>nCell += nAdd;\n<line48>}\n<line49>/* Add any overflow cells */\n<line50>for(i=0; i<pPg->nOverflow; i++){\n<line51>int iCell = (iOld + pPg->aiOvfl[i]) - iNew;\n<line52>if( iCell>=0 && iCell<nNew ){\n<line53>pCellptr = &pPg->aCellIdx[iCell * 2];\n<line54>if( nCell>iCell ){\n<line55>memmove(&pCellptr[2], pCellptr, (nCell - iCell) * 2);\n<line56>}\n<line57>nCell++;\n<line58>cachedCellSize(pCArray, iCell+iNew);\n<line59>if( pageInsertArray(\n<line60>pPg, pBegin, &pData, pCellptr,\n<line61>iCell+iNew, 1, pCArray\n<line62>) ) goto editpage_fail;\n<line63>}\n<line64>}\n<line65>/* Append cells to the end of the page */\n<line66>assert( nCell>=0 );\n<line67>pCellptr = &pPg->aCellIdx[nCell*2];\n<line68>if( pageInsertArray(\n<line69>pPg, pBegin, &pData, pCellptr,\n<line70>iNew+nCell, nNew-nCell, pCArray\n<line71>)\n<line72>){\n<line73>goto editpage_fail;\n<line74>}\n<line75>assert( nNew < 10922 );\n<line76>pPg->nCell = (u16)nNew;\n<line77>pPg->nOverflow = 0;\n<line78>put2byte(&aData[hdr+3], pPg->nCell);\n<line79>put2byte(&aData[hdr+5], pData - aData);\n<line80>#ifdef SQLITE_DEBUG\n<line81>for(i=0; i<nNew && !CORRUPT_DB; i++){\n<line82>u8 *pCell = pCArray->apCell[i+iNew];\n<line83>int iOff = get2byteAligned(&pPg->aCellIdx[i*2]);\n<line84>if( SQLITE_WITHIN(pCell, aData, &aData[pPg->pBt->usableSize]) ){\n<line85>pCell = &pTmp[pCell - aData];\n<line86>}\n<line87>assert( 0==memcmp(pCell, &aData[iOff],\n<line88>pCArray->pRef->xCellSize(pCArray->pRef, pCArray->apCell[i+iNew])) );\n<line89>}\n<line90>#endif\n<line91>return SQLITE_OK;\n<line92>editpage_fail:\n<line93>/* Unable to edit this page. Rebuild it from scratch instead. */\n<line94>if( nNew<1 ) return SQLITE_CORRUPT_BKPT;\n<line95>populateCellCache(pCArray, iNew, nNew);\n<line96>return rebuildPage(pCArray, iNew, nNew, pPg);\n<line97>}
----------------------------------------
Function: balance_quick
Content: <line0>static int balance_quick(MemPage *pParent, MemPage *pPage, u8 *pSpace){\n<line1>BtShared *const pBt = pPage->pBt;    /* B-Tree Database */\n<line2>MemPage *pNew;                       /* Newly allocated page */\n<line3>int rc;                              /* Return Code */\n<line4>Pgno pgnoNew;                        /* Page number of pNew */\n<line5>assert( sqlite3_mutex_held(pPage->pBt->mutex) );\n<line6>assert( sqlite3PagerIswriteable(pParent->pDbPage) );\n<line7>assert( pPage->nOverflow==1 );\n<line8>if( pPage->nCell==0 ) return SQLITE_CORRUPT_BKPT;  /* dbfuzz001.test */\n<line9>assert( pPage->nFree>=0 );\n<line10>assert( pParent->nFree>=0 );\n<line11>/* Allocate a new page. This page will become the right-sibling of\n<line12>** pPage. Make the parent page writable, so that the new divider cell\n<line13>** may be inserted. If both these operations are successful, proceed.\n<line14>*/\n<line15>rc = allocateBtreePage(pBt, &pNew, &pgnoNew, 0, 0);\n<line16>if( rc==SQLITE_OK ){\n<line17>u8 *pOut = &pSpace[4];\n<line18>u8 *pCell = pPage->apOvfl[0];\n<line19>u16 szCell = pPage->xCellSize(pPage, pCell);\n<line20>u8 *pStop;\n<line21>CellArray b;\n<line22>assert( sqlite3PagerIswriteable(pNew->pDbPage) );\n<line23>assert( CORRUPT_DB || pPage->aData[0]==(PTF_INTKEY|PTF_LEAFDATA|PTF_LEAF) );\n<line24>zeroPage(pNew, PTF_INTKEY|PTF_LEAFDATA|PTF_LEAF);\n<line25>b.nCell = 1;\n<line26>b.pRef = pPage;\n<line27>b.apCell = &pCell;\n<line28>b.szCell = &szCell;\n<line29>b.apEnd[0] = pPage->aDataEnd;\n<line30>b.ixNx[0] = 2;\n<line31>b.ixNx[NB*2-1] = 0x7fffffff;\n<line32>rc = rebuildPage(&b, 0, 1, pNew);\n<line33>if( NEVER(rc) ){\n<line34>releasePage(pNew);\n<line35>return rc;\n<line36>}\n<line37>pNew->nFree = pBt->usableSize - pNew->cellOffset - 2 - szCell;\n<line38>/* If this is an auto-vacuum database, update the pointer map\n<line39>** with entries for the new page, and any pointer from the\n<line40>** cell on the page to an overflow page. If either of these\n<line41>** operations fails, the return code is set, but the contents\n<line42>** of the parent page are still manipulated by the code below.\n<line43>** That is Ok, at this point the parent page is guaranteed to\n<line44>** be marked as dirty. Returning an error code will cause a\n<line45>** rollback, undoing any changes made to the parent page.\n<line46>*/\n<line47>if( ISAUTOVACUUM(pBt) ){\n<line48>ptrmapPut(pBt, pgnoNew, PTRMAP_BTREE, pParent->pgno, &rc);\n<line49>if( szCell>pNew->minLocal ){\n<line50>ptrmapPutOvflPtr(pNew, pNew, pCell, &rc);\n<line51>}\n<line52>}\n<line53>/* Create a divider cell to insert into pParent. The divider cell\n<line54>** consists of a 4-byte page number (the page number of pPage) and\n<line55>** a variable length key value (which must be the same value as the\n<line56>** largest key on pPage).\n<line57>**\n<line58>** To find the largest key value on pPage, first find the right-most\n<line59>** cell on pPage. The first two fields of this cell are the\n<line60>** record-length (a variable length integer at most 32-bits in size)\n<line61>** and the key value (a variable length integer, may have any value).\n<line62>** The first of the while(...) loops below skips over the record-length\n<line63>** field. The second while(...) loop copies the key value from the\n<line64>** cell on pPage into the pSpace buffer.\n<line65>*/\n<line66>pCell = findCell(pPage, pPage->nCell-1);\n<line67>pStop = &pCell[9];\n<line68>while( (*(pCell++)&0x80) && pCell<pStop );\n<line69>pStop = &pCell[9];\n<line70>while( ((*(pOut++) = *(pCell++))&0x80) && pCell<pStop );\n<line71>/* Insert the new divider cell into pParent. */\n<line72>if( rc==SQLITE_OK ){\n<line73>rc = insertCell(pParent, pParent->nCell, pSpace, (int)(pOut-pSpace),\n<line74>0, pPage->pgno);\n<line75>}\n<line76>/* Set the right-child pointer of pParent to point to the new page. */\n<line77>put4byte(&pParent->aData[pParent->hdrOffset+8], pgnoNew);\n<line78>/* Release the reference to the new page. */\n<line79>releasePage(pNew);\n<line80>}\n<line81>return rc;\n<line82>}
----------------------------------------
Function: copyNodeContent
Content: <line0>static void copyNodeContent(MemPage *pFrom, MemPage *pTo, int *pRC){\n<line1>if( (*pRC)==SQLITE_OK ){\n<line2>BtShared * const pBt = pFrom->pBt;\n<line3>u8 * const aFrom = pFrom->aData;\n<line4>u8 * const aTo = pTo->aData;\n<line5>int const iFromHdr = pFrom->hdrOffset;\n<line6>int const iToHdr = ((pTo->pgno==1) ? 100 : 0);\n<line7>int rc;\n<line8>int iData;\n<line9>assert( pFrom->isInit );\n<line10>assert( pFrom->nFree>=iToHdr );\n<line11>assert( get2byte(&aFrom[iFromHdr+5]) <= (int)pBt->usableSize );\n<line12>/* Copy the b-tree node content from page pFrom to page pTo. */\n<line13>iData = get2byte(&aFrom[iFromHdr+5]);\n<line14>memcpy(&aTo[iData], &aFrom[iData], pBt->usableSize-iData);\n<line15>memcpy(&aTo[iToHdr], &aFrom[iFromHdr], pFrom->cellOffset + 2*pFrom->nCell);\n<line16>/* Reinitialize page pTo so that the contents of the MemPage structure\n<line17>** match the new data. The initialization of pTo can actually fail under\n<line18>** fairly obscure circumstances, even though it is a copy of initialized\n<line19>** page pFrom.\n<line20>*/\n<line21>pTo->isInit = 0;\n<line22>rc = btreeInitPage(pTo);\n<line23>if( rc==SQLITE_OK ) rc = btreeComputeFreeSpace(pTo);\n<line24>if( rc!=SQLITE_OK ){\n<line25>*pRC = rc;\n<line26>return;\n<line27>}\n<line28>/* If this is an auto-vacuum database, update the pointer-map entries\n<line29>** for any b-tree or overflow pages that pTo now contains the pointers to.\n<line30>*/\n<line31>if( ISAUTOVACUUM(pBt) ){\n<line32>*pRC = setChildPtrmaps(pTo);\n<line33>}\n<line34>}\n<line35>}
----------------------------------------
Function: balance_nonroot
Content: <line0>static int balance_nonroot(\n<line1>MemPage *pParent,               /* Parent page of siblings being balanced */\n<line2>int iParentIdx,                 /* Index of "the page" in pParent */\n<line3>u8 *aOvflSpace,                 /* page-size bytes of space for parent ovfl */\n<line4>int isRoot,                     /* True if pParent is a root-page */\n<line5>int bBulk                       /* True if this call is part of a bulk load */\n<line6>){\n<line7>BtShared *pBt;               /* The whole database */\n<line8>int nMaxCells = 0;           /* Allocated size of apCell, szCell, aFrom. */\n<line9>int nNew = 0;                /* Number of pages in apNew[] */\n<line10>int nOld;                    /* Number of pages in apOld[] */\n<line11>int i, j, k;                 /* Loop counters */\n<line12>int nxDiv;                   /* Next divider slot in pParent->aCell[] */\n<line13>int rc = SQLITE_OK;          /* The return code */\n<line14>u16 leafCorrection;          /* 4 if pPage is a leaf.  0 if not */\n<line15>int leafData;                /* True if pPage is a leaf of a LEAFDATA tree */\n<line16>int usableSpace;             /* Bytes in pPage beyond the header */\n<line17>int pageFlags;               /* Value of pPage->aData[0] */\n<line18>int iSpace1 = 0;             /* First unused byte of aSpace1[] */\n<line19>int iOvflSpace = 0;          /* First unused byte of aOvflSpace[] */\n<line20>u64 szScratch;               /* Size of scratch memory requested */\n<line21>MemPage *apOld[NB];          /* pPage and up to two siblings */\n<line22>MemPage *apNew[NB+2];        /* pPage and up to NB siblings after balancing */\n<line23>u8 *pRight;                  /* Location in parent of right-sibling pointer */\n<line24>u8 *apDiv[NB-1];             /* Divider cells in pParent */\n<line25>int cntNew[NB+2];            /* Index in b.paCell[] of cell after i-th page */\n<line26>int cntOld[NB+2];            /* Old index in b.apCell[] */\n<line27>int szNew[NB+2];             /* Combined size of cells placed on i-th page */\n<line28>u8 *aSpace1;                 /* Space for copies of dividers cells */\n<line29>Pgno pgno;                   /* Temp var to store a page number in */\n<line30>u8 abDone[NB+2];             /* True after i'th new page is populated */\n<line31>Pgno aPgno[NB+2];            /* Page numbers of new pages before shuffling */\n<line32>CellArray b;                 /* Parsed information on cells being balanced */\n<line33>memset(abDone, 0, sizeof(abDone));\n<line34>assert( sizeof(b) - sizeof(b.ixNx) == offsetof(CellArray,ixNx) );\n<line35>memset(&b, 0, sizeof(b)-sizeof(b.ixNx[0]));\n<line36>b.ixNx[NB*2-1] = 0x7fffffff;\n<line37>pBt = pParent->pBt;\n<line38>assert( sqlite3_mutex_held(pBt->mutex) );\n<line39>assert( sqlite3PagerIswriteable(pParent->pDbPage) );\n<line40>/* At this point pParent may have at most one overflow cell. And if\n<line41>** this overflow cell is present, it must be the cell with\n<line42>** index iParentIdx. This scenario comes about when this function\n<line43>** is called (indirectly) from sqlite3BtreeDelete().\n<line44>*/\n<line45>assert( pParent->nOverflow==0 || pParent->nOverflow==1 );\n<line46>assert( pParent->nOverflow==0 || pParent->aiOvfl[0]==iParentIdx );\n<line47>if( !aOvflSpace ){\n<line48>return SQLITE_NOMEM_BKPT;\n<line49>}\n<line50>assert( pParent->nFree>=0 );\n<line51>/* Find the sibling pages to balance. Also locate the cells in pParent\n<line52>** that divide the siblings. An attempt is made to find NN siblings on\n<line53>** either side of pPage. More siblings are taken from one side, however,\n<line54>** if there are fewer than NN siblings on the other side. If pParent\n<line55>** has NB or fewer children then all children of pParent are taken.\n<line56>**\n<line57>** This loop also drops the divider cells from the parent page. This\n<line58>** way, the remainder of the function does not have to deal with any\n<line59>** overflow cells in the parent page, since if any existed they will\n<line60>** have already been removed.\n<line61>*/\n<line62>i = pParent->nOverflow + pParent->nCell;\n<line63>if( i<2 ){\n<line64>nxDiv = 0;\n<line65>}else{\n<line66>assert( bBulk==0 || bBulk==1 );\n<line67>if( iParentIdx==0 ){\n<line68>nxDiv = 0;\n<line69>}else if( iParentIdx==i ){\n<line70>nxDiv = i-2+bBulk;\n<line71>}else{\n<line72>nxDiv = iParentIdx-1;\n<line73>}\n<line74>i = 2-bBulk;\n<line75>}\n<line76>nOld = i+1;\n<line77>if( (i+nxDiv-pParent->nOverflow)==pParent->nCell ){\n<line78>pRight = &pParent->aData[pParent->hdrOffset+8];\n<line79>}else{\n<line80>pRight = findCell(pParent, i+nxDiv-pParent->nOverflow);\n<line81>}\n<line82>pgno = get4byte(pRight);\n<line83>while( 1 ){\n<line84>if( rc==SQLITE_OK ){\n<line85>rc = getAndInitPage(pBt, pgno, &apOld[i], 0);\n<line86>}\n<line87>if( rc ){\n<line88>memset(apOld, 0, (i+1)*sizeof(MemPage*));\n<line89>goto balance_cleanup;\n<line90>}\n<line91>if( apOld[i]->nFree<0 ){\n<line92>rc = btreeComputeFreeSpace(apOld[i]);\n<line93>if( rc ){\n<line94>memset(apOld, 0, (i)*sizeof(MemPage*));\n<line95>goto balance_cleanup;\n<line96>}\n<line97>}\n<line98>nMaxCells += apOld[i]->nCell + ArraySize(pParent->apOvfl);\n<line99>if( (i--)==0 ) break;\n<line100>if( pParent->nOverflow && i+nxDiv==pParent->aiOvfl[0] ){\n<line101>apDiv[i] = pParent->apOvfl[0];\n<line102>pgno = get4byte(apDiv[i]);\n<line103>szNew[i] = pParent->xCellSize(pParent, apDiv[i]);\n<line104>pParent->nOverflow = 0;\n<line105>}else{\n<line106>apDiv[i] = findCell(pParent, i+nxDiv-pParent->nOverflow);\n<line107>pgno = get4byte(apDiv[i]);\n<line108>szNew[i] = pParent->xCellSize(pParent, apDiv[i]);\n<line109>/* Drop the cell from the parent page. apDiv[i] still points to\n<line110>** the cell within the parent, even though it has been dropped.\n<line111>** This is safe because dropping a cell only overwrites the first\n<line112>** four bytes of it, and this function does not need the first\n<line113>** four bytes of the divider cell. So the pointer is safe to use\n<line114>** later on.\n<line115>**\n<line116>** But not if we are in secure-delete mode. In secure-delete mode,\n<line117>** the dropCell() routine will overwrite the entire cell with zeroes.\n<line118>** In this case, temporarily copy the cell into the aOvflSpace[]\n<line119>** buffer. It will be copied out again as soon as the aSpace[] buffer\n<line120>** is allocated.  */\n<line121>if( pBt->btsFlags & BTS_FAST_SECURE ){\n<line122>int iOff;\n<line123>/* If the following if() condition is not true, the db is corrupted.\n<line124>** The call to dropCell() below will detect this.  */\n<line125>iOff = SQLITE_PTR_TO_INT(apDiv[i]) - SQLITE_PTR_TO_INT(pParent->aData);\n<line126>if( (iOff+szNew[i])<=(int)pBt->usableSize ){\n<line127>memcpy(&aOvflSpace[iOff], apDiv[i], szNew[i]);\n<line128>apDiv[i] = &aOvflSpace[apDiv[i]-pParent->aData];\n<line129>}\n<line130>}\n<line131>dropCell(pParent, i+nxDiv-pParent->nOverflow, szNew[i], &rc);\n<line132>}\n<line133>}\n<line134>/* Make nMaxCells a multiple of 4 in order to preserve 8-byte\n<line135>** alignment */\n<line136>nMaxCells = (nMaxCells + 3)&~3;\n<line137>/*\n<line138>** Allocate space for memory structures\n<line139>*/\n<line140>szScratch =\n<line141>nMaxCells*sizeof(u8*)                       /* b.apCell */\n<line142>+ nMaxCells*sizeof(u16)                       /* b.szCell */\n<line143>+ pBt->pageSize;                              /* aSpace1 */\n<line144>assert( szScratch<=7*(int)pBt->pageSize );\n<line145>b.apCell = sqlite3StackAllocRaw(0, szScratch );\n<line146>if( b.apCell==0 ){\n<line147>rc = SQLITE_NOMEM_BKPT;\n<line148>goto balance_cleanup;\n<line149>}\n<line150>b.szCell = (u16*)&b.apCell[nMaxCells];\n<line151>aSpace1 = (u8*)&b.szCell[nMaxCells];\n<line152>assert( EIGHT_BYTE_ALIGNMENT(aSpace1) );\n<line153>/*\n<line154>** Load pointers to all cells on sibling pages and the divider cells\n<line155>** into the local b.apCell[] array.  Make copies of the divider cells\n<line156>** into space obtained from aSpace1[]. The divider cells have already\n<line157>** been removed from pParent.\n<line158>**\n<line159>** If the siblings are on leaf pages, then the child pointers of the\n<line160>** divider cells are stripped from the cells before they are copied\n<line161>** into aSpace1[].  In this way, all cells in b.apCell[] are without\n<line162>** child pointers.  If siblings are not leaves, then all cell in\n<line163>** b.apCell[] include child pointers.  Either way, all cells in b.apCell[]\n<line164>** are alike.\n<line165>**\n<line166>** leafCorrection:  4 if pPage is a leaf.  0 if pPage is not a leaf.\n<line167>**       leafData:  1 if pPage holds key+data and pParent holds only keys.\n<line168>*/\n<line169>b.pRef = apOld[0];\n<line170>leafCorrection = b.pRef->leaf*4;\n<line171>leafData = b.pRef->intKeyLeaf;\n<line172>for(i=0; i<nOld; i++){\n<line173>MemPage *pOld = apOld[i];\n<line174>int limit = pOld->nCell;\n<line175>u8 *aData = pOld->aData;\n<line176>u16 maskPage = pOld->maskPage;\n<line177>u8 *piCell = aData + pOld->cellOffset;\n<line178>u8 *piEnd;\n<line179>VVA_ONLY( int nCellAtStart = b.nCell; )\n<line180>/* Verify that all sibling pages are of the same "type" (table-leaf,\n<line181>** table-interior, index-leaf, or index-interior).\n<line182>*/\n<line183>if( pOld->aData[0]!=apOld[0]->aData[0] ){\n<line184>rc = SQLITE_CORRUPT_PAGE(pOld);\n<line185>goto balance_cleanup;\n<line186>}\n<line187>/* Load b.apCell[] with pointers to all cells in pOld.  If pOld\n<line188>** contains overflow cells, include them in the b.apCell[] array\n<line189>** in the correct spot.\n<line190>**\n<line191>** Note that when there are multiple overflow cells, it is always the\n<line192>** case that they are sequential and adjacent.  This invariant arises\n<line193>** because multiple overflows can only occurs when inserting divider\n<line194>** cells into a parent on a prior balance, and divider cells are always\n<line195>** adjacent and are inserted in order.  There is an assert() tagged\n<line196>** with "NOTE 1" in the overflow cell insertion loop to prove this\n<line197>** invariant.\n<line198>**\n<line199>** This must be done in advance.  Once the balance starts, the cell\n<line200>** offset section of the btree page will be overwritten and we will no\n<line201>** long be able to find the cells if a pointer to each cell is not saved\n<line202>** first.\n<line203>*/\n<line204>memset(&b.szCell[b.nCell], 0, sizeof(b.szCell[0])*(limit+pOld->nOverflow));\n<line205>if( pOld->nOverflow>0 ){\n<line206>if( NEVER(limit<pOld->aiOvfl[0]) ){\n<line207>rc = SQLITE_CORRUPT_PAGE(pOld);\n<line208>goto balance_cleanup;\n<line209>}\n<line210>limit = pOld->aiOvfl[0];\n<line211>for(j=0; j<limit; j++){\n<line212>b.apCell[b.nCell] = aData + (maskPage & get2byteAligned(piCell));\n<line213>piCell += 2;\n<line214>b.nCell++;\n<line215>}\n<line216>for(k=0; k<pOld->nOverflow; k++){\n<line217>assert( k==0 || pOld->aiOvfl[k-1]+1==pOld->aiOvfl[k] );/* NOTE 1 */\n<line218>b.apCell[b.nCell] = pOld->apOvfl[k];\n<line219>b.nCell++;\n<line220>}\n<line221>}\n<line222>piEnd = aData + pOld->cellOffset + 2*pOld->nCell;\n<line223>while( piCell<piEnd ){\n<line224>assert( b.nCell<nMaxCells );\n<line225>b.apCell[b.nCell] = aData + (maskPage & get2byteAligned(piCell));\n<line226>piCell += 2;\n<line227>b.nCell++;\n<line228>}\n<line229>assert( (b.nCell-nCellAtStart)==(pOld->nCell+pOld->nOverflow) );\n<line230>cntOld[i] = b.nCell;\n<line231>if( i<nOld-1 && !leafData){\n<line232>u16 sz = (u16)szNew[i];\n<line233>u8 *pTemp;\n<line234>assert( b.nCell<nMaxCells );\n<line235>b.szCell[b.nCell] = sz;\n<line236>pTemp = &aSpace1[iSpace1];\n<line237>iSpace1 += sz;\n<line238>assert( sz<=pBt->maxLocal+23 );\n<line239>assert( iSpace1 <= (int)pBt->pageSize );\n<line240>memcpy(pTemp, apDiv[i], sz);\n<line241>b.apCell[b.nCell] = pTemp+leafCorrection;\n<line242>assert( leafCorrection==0 || leafCorrection==4 );\n<line243>b.szCell[b.nCell] = b.szCell[b.nCell] - leafCorrection;\n<line244>if( !pOld->leaf ){\n<line245>assert( leafCorrection==0 );\n<line246>assert( pOld->hdrOffset==0 || CORRUPT_DB );\n<line247>/* The right pointer of the child page pOld becomes the left\n<line248>** pointer of the divider cell */\n<line249>memcpy(b.apCell[b.nCell], &pOld->aData[8], 4);\n<line250>}else{\n<line251>assert( leafCorrection==4 );\n<line252>while( b.szCell[b.nCell]<4 ){\n<line253>/* Do not allow any cells smaller than 4 bytes. If a smaller cell\n<line254>** does exist, pad it with 0x00 bytes. */\n<line255>assert( b.szCell[b.nCell]==3 || CORRUPT_DB );\n<line256>assert( b.apCell[b.nCell]==&aSpace1[iSpace1-3] || CORRUPT_DB );\n<line257>aSpace1[iSpace1++] = 0x00;\n<line258>b.szCell[b.nCell]++;\n<line259>}\n<line260>}\n<line261>b.nCell++;\n<line262>}\n<line263>}\n<line264>/*\n<line265>** Figure out the number of pages needed to hold all b.nCell cells.\n<line266>** Store this number in "k".  Also compute szNew[] which is the total\n<line267>** size of all cells on the i-th page and cntNew[] which is the index\n<line268>** in b.apCell[] of the cell that divides page i from page i+1.\n<line269>** cntNew[k] should equal b.nCell.\n<line270>**\n<line271>** Values computed by this block:\n<line272>**\n<line273>**           k: The total number of sibling pages\n<line274>**    szNew[i]: Spaced used on the i-th sibling page.\n<line275>**   cntNew[i]: Index in b.apCell[] and b.szCell[] for the first cell to\n<line276>**              the right of the i-th sibling page.\n<line277>** usableSpace: Number of bytes of space available on each sibling.\n<line278>**\n<line279>*/\n<line280>usableSpace = pBt->usableSize - 12 + leafCorrection;\n<line281>for(i=k=0; i<nOld; i++, k++){\n<line282>MemPage *p = apOld[i];\n<line283>b.apEnd[k] = p->aDataEnd;\n<line284>b.ixNx[k] = cntOld[i];\n<line285>if( k && b.ixNx[k]==b.ixNx[k-1] ){\n<line286>k--;  /* Omit b.ixNx[] entry for child pages with no cells */\n<line287>}\n<line288>if( !leafData ){\n<line289>k++;\n<line290>b.apEnd[k] = pParent->aDataEnd;\n<line291>b.ixNx[k] = cntOld[i]+1;\n<line292>}\n<line293>assert( p->nFree>=0 );\n<line294>szNew[i] = usableSpace - p->nFree;\n<line295>for(j=0; j<p->nOverflow; j++){\n<line296>szNew[i] += 2 + p->xCellSize(p, p->apOvfl[j]);\n<line297>}\n<line298>cntNew[i] = cntOld[i];\n<line299>}\n<line300>k = nOld;\n<line301>for(i=0; i<k; i++){\n<line302>int sz;\n<line303>while( szNew[i]>usableSpace ){\n<line304>if( i+1>=k ){\n<line305>k = i+2;\n<line306>if( k>NB+2 ){ rc = SQLITE_CORRUPT_BKPT; goto balance_cleanup; }\n<line307>szNew[k-1] = 0;\n<line308>cntNew[k-1] = b.nCell;\n<line309>}\n<line310>sz = 2 + cachedCellSize(&b, cntNew[i]-1);\n<line311>szNew[i] -= sz;\n<line312>if( !leafData ){\n<line313>if( cntNew[i]<b.nCell ){\n<line314>sz = 2 + cachedCellSize(&b, cntNew[i]);\n<line315>}else{\n<line316>sz = 0;\n<line317>}\n<line318>}\n<line319>szNew[i+1] += sz;\n<line320>cntNew[i]--;\n<line321>}\n<line322>while( cntNew[i]<b.nCell ){\n<line323>sz = 2 + cachedCellSize(&b, cntNew[i]);\n<line324>if( szNew[i]+sz>usableSpace ) break;\n<line325>szNew[i] += sz;\n<line326>cntNew[i]++;\n<line327>if( !leafData ){\n<line328>if( cntNew[i]<b.nCell ){\n<line329>sz = 2 + cachedCellSize(&b, cntNew[i]);\n<line330>}else{\n<line331>sz = 0;\n<line332>}\n<line333>}\n<line334>szNew[i+1] -= sz;\n<line335>}\n<line336>if( cntNew[i]>=b.nCell ){\n<line337>k = i+1;\n<line338>}else if( cntNew[i] <= (i>0 ? cntNew[i-1] : 0) ){\n<line339>rc = SQLITE_CORRUPT_BKPT;\n<line340>goto balance_cleanup;\n<line341>}\n<line342>}\n<line343>/*\n<line344>** The packing computed by the previous block is biased toward the siblings\n<line345>** on the left side (siblings with smaller keys). The left siblings are\n<line346>** always nearly full, while the right-most sibling might be nearly empty.\n<line347>** The next block of code attempts to adjust the packing of siblings to\n<line348>** get a better balance.\n<line349>**\n<line350>** This adjustment is more than an optimization.  The packing above might\n<line351>** be so out of balance as to be illegal.  For example, the right-most\n<line352>** sibling might be completely empty.  This adjustment is not optional.\n<line353>*/\n<line354>for(i=k-1; i>0; i--){\n<line355>int szRight = szNew[i];  /* Size of sibling on the right */\n<line356>int szLeft = szNew[i-1]; /* Size of sibling on the left */\n<line357>int r;              /* Index of right-most cell in left sibling */\n<line358>int d;              /* Index of first cell to the left of right sibling */\n<line359>r = cntNew[i-1] - 1;\n<line360>d = r + 1 - leafData;\n<line361>(void)cachedCellSize(&b, d);\n<line362>do{\n<line363>int szR, szD;\n<line364>assert( d<nMaxCells );\n<line365>assert( r<nMaxCells );\n<line366>szR = cachedCellSize(&b, r);\n<line367>szD = b.szCell[d];\n<line368>if( szRight!=0\n<line369>&& (bBulk || szRight+szD+2 > szLeft-(szR+(i==k-1?0:2)))){\n<line370>break;\n<line371>}\n<line372>szRight += szD + 2;\n<line373>szLeft -= szR + 2;\n<line374>cntNew[i-1] = r;\n<line375>r--;\n<line376>d--;\n<line377>}while( r>=0 );\n<line378>szNew[i] = szRight;\n<line379>szNew[i-1] = szLeft;\n<line380>if( cntNew[i-1] <= (i>1 ? cntNew[i-2] : 0) ){\n<line381>rc = SQLITE_CORRUPT_BKPT;\n<line382>goto balance_cleanup;\n<line383>}\n<line384>}\n<line385>/* Sanity check:  For a non-corrupt database file one of the following\n<line386>** must be true:\n<line387>**    (1) We found one or more cells (cntNew[0])>0), or\n<line388>**    (2) pPage is a virtual root page.  A virtual root page is when\n<line389>**        the real root page is page 1 and we are the only child of\n<line390>**        that page.\n<line391>*/\n<line392>assert( cntNew[0]>0 || (pParent->pgno==1 && pParent->nCell==0) || CORRUPT_DB);\n<line393>TRACE(("BALANCE: old: %u(nc=%u) %u(nc=%u) %u(nc=%u)\n",\n<line394>apOld[0]->pgno, apOld[0]->nCell,\n<line395>nOld>=2 ? apOld[1]->pgno : 0, nOld>=2 ? apOld[1]->nCell : 0,\n<line396>nOld>=3 ? apOld[2]->pgno : 0, nOld>=3 ? apOld[2]->nCell : 0\n<line397>));\n<line398>/*\n<line399>** Allocate k new pages.  Reuse old pages where possible.\n<line400>*/\n<line401>pageFlags = apOld[0]->aData[0];\n<line402>for(i=0; i<k; i++){\n<line403>MemPage *pNew;\n<line404>if( i<nOld ){\n<line405>pNew = apNew[i] = apOld[i];\n<line406>apOld[i] = 0;\n<line407>rc = sqlite3PagerWrite(pNew->pDbPage);\n<line408>nNew++;\n<line409>if( sqlite3PagerPageRefcount(pNew->pDbPage)!=1+(i==(iParentIdx-nxDiv))\n<line410>&& rc==SQLITE_OK\n<line411>){\n<line412>rc = SQLITE_CORRUPT_BKPT;\n<line413>}\n<line414>if( rc ) goto balance_cleanup;\n<line415>}else{\n<line416>assert( i>0 );\n<line417>rc = allocateBtreePage(pBt, &pNew, &pgno, (bBulk ? 1 : pgno), 0);\n<line418>if( rc ) goto balance_cleanup;\n<line419>zeroPage(pNew, pageFlags);\n<line420>apNew[i] = pNew;\n<line421>nNew++;\n<line422>cntOld[i] = b.nCell;\n<line423>/* Set the pointer-map entry for the new sibling page. */\n<line424>if( ISAUTOVACUUM(pBt) ){\n<line425>ptrmapPut(pBt, pNew->pgno, PTRMAP_BTREE, pParent->pgno, &rc);\n<line426>if( rc!=SQLITE_OK ){\n<line427>goto balance_cleanup;\n<line428>}\n<line429>}\n<line430>}\n<line431>}\n<line432>/*\n<line433>** Reassign page numbers so that the new pages are in ascending order.\n<line434>** This helps to keep entries in the disk file in order so that a scan\n<line435>** of the table is closer to a linear scan through the file. That in turn\n<line436>** helps the operating system to deliver pages from the disk more rapidly.\n<line437>**\n<line438>** An O(N*N) sort algorithm is used, but since N is never more than NB+2\n<line439>** (5), that is not a performance concern.\n<line440>**\n<line441>** When NB==3, this one optimization makes the database about 25% faster\n<line442>** for large insertions and deletions.\n<line443>*/\n<line444>for(i=0; i<nNew; i++){\n<line445>aPgno[i] = apNew[i]->pgno;\n<line446>assert( apNew[i]->pDbPage->flags & PGHDR_WRITEABLE );\n<line447>assert( apNew[i]->pDbPage->flags & PGHDR_DIRTY );\n<line448>}\n<line449>for(i=0; i<nNew-1; i++){\n<line450>int iB = i;\n<line451>for(j=i+1; j<nNew; j++){\n<line452>if( apNew[j]->pgno < apNew[iB]->pgno ) iB = j;\n<line453>}\n<line454>/* If apNew[i] has a page number that is bigger than any of the\n<line455>** subsequence apNew[i] entries, then swap apNew[i] with the subsequent\n<line456>** entry that has the smallest page number (which we know to be\n<line457>** entry apNew[iB]).\n<line458>*/\n<line459>if( iB!=i ){\n<line460>Pgno pgnoA = apNew[i]->pgno;\n<line461>Pgno pgnoB = apNew[iB]->pgno;\n<line462>Pgno pgnoTemp = (PENDING_BYTE/pBt->pageSize)+1;\n<line463>u16 fgA = apNew[i]->pDbPage->flags;\n<line464>u16 fgB = apNew[iB]->pDbPage->flags;\n<line465>sqlite3PagerRekey(apNew[i]->pDbPage, pgnoTemp, fgB);\n<line466>sqlite3PagerRekey(apNew[iB]->pDbPage, pgnoA, fgA);\n<line467>sqlite3PagerRekey(apNew[i]->pDbPage, pgnoB, fgB);\n<line468>apNew[i]->pgno = pgnoB;\n<line469>apNew[iB]->pgno = pgnoA;\n<line470>}\n<line471>}\n<line472>TRACE(("BALANCE: new: %u(%u nc=%u) %u(%u nc=%u) %u(%u nc=%u) "\n<line473>"%u(%u nc=%u) %u(%u nc=%u)\n",\n<line474>apNew[0]->pgno, szNew[0], cntNew[0],\n<line475>nNew>=2 ? apNew[1]->pgno : 0, nNew>=2 ? szNew[1] : 0,\n<line476>nNew>=2 ? cntNew[1] - cntNew[0] - !leafData : 0,\n<line477>nNew>=3 ? apNew[2]->pgno : 0, nNew>=3 ? szNew[2] : 0,\n<line478>nNew>=3 ? cntNew[2] - cntNew[1] - !leafData : 0,\n<line479>nNew>=4 ? apNew[3]->pgno : 0, nNew>=4 ? szNew[3] : 0,\n<line480>nNew>=4 ? cntNew[3] - cntNew[2] - !leafData : 0,\n<line481>nNew>=5 ? apNew[4]->pgno : 0, nNew>=5 ? szNew[4] : 0,\n<line482>nNew>=5 ? cntNew[4] - cntNew[3] - !leafData : 0\n<line483>));\n<line484>assert( sqlite3PagerIswriteable(pParent->pDbPage) );\n<line485>assert( nNew>=1 && nNew<=ArraySize(apNew) );\n<line486>assert( apNew[nNew-1]!=0 );\n<line487>put4byte(pRight, apNew[nNew-1]->pgno);\n<line488>/* If the sibling pages are not leaves, ensure that the right-child pointer\n<line489>** of the right-most new sibling page is set to the value that was\n<line490>** originally in the same field of the right-most old sibling page. */\n<line491>if( (pageFlags & PTF_LEAF)==0 && nOld!=nNew ){\n<line492>MemPage *pOld;\n<line493>if( nNew>nOld ){\n<line494>pOld = apNew[nOld-1];\n<line495>}else{\n<line496>pOld = apOld[nOld-1];\n<line497>}\n<line498>memcpy(&apNew[nNew-1]->aData[8], &pOld->aData[8], 4);\n<line499>}\n<line500>/* Make any required updates to pointer map entries associated with\n<line501>** cells stored on sibling pages following the balance operation. Pointer\n<line502>** map entries associated with divider cells are set by the insertCell()\n<line503>** routine. The associated pointer map entries are:\n<line504>**\n<line505>**   a) if the cell contains a reference to an overflow chain, the\n<line506>**      entry associated with the first page in the overflow chain, and\n<line507>**\n<line508>**   b) if the sibling pages are not leaves, the child page associated\n<line509>**      with the cell.\n<line510>**\n<line511>** If the sibling pages are not leaves, then the pointer map entry\n<line512>** associated with the right-child of each sibling may also need to be\n<line513>** updated. This happens below, after the sibling pages have been\n<line514>** populated, not here.\n<line515>*/\n<line516>if( ISAUTOVACUUM(pBt) ){\n<line517>MemPage *pOld;\n<line518>MemPage *pNew = pOld = apNew[0];\n<line519>int cntOldNext = pNew->nCell + pNew->nOverflow;\n<line520>int iNew = 0;\n<line521>int iOld = 0;\n<line522>for(i=0; i<b.nCell; i++){\n<line523>u8 *pCell = b.apCell[i];\n<line524>while( i==cntOldNext ){\n<line525>iOld++;\n<line526>assert( iOld<nNew || iOld<nOld );\n<line527>assert( iOld>=0 && iOld<NB );\n<line528>pOld = iOld<nNew ? apNew[iOld] : apOld[iOld];\n<line529>cntOldNext += pOld->nCell + pOld->nOverflow + !leafData;\n<line530>}\n<line531>if( i==cntNew[iNew] ){\n<line532>pNew = apNew[++iNew];\n<line533>if( !leafData ) continue;\n<line534>}\n<line535>/* Cell pCell is destined for new sibling page pNew. Originally, it\n<line536>** was either part of sibling page iOld (possibly an overflow cell),\n<line537>** or else the divider cell to the left of sibling page iOld. So,\n<line538>** if sibling page iOld had the same page number as pNew, and if\n<line539>** pCell really was a part of sibling page iOld (not a divider or\n<line540>** overflow cell), we can skip updating the pointer map entries.  */\n<line541>if( iOld>=nNew\n<line542>|| pNew->pgno!=aPgno[iOld]\n<line543>|| !SQLITE_WITHIN(pCell,pOld->aData,pOld->aDataEnd)\n<line544>){\n<line545>if( !leafCorrection ){\n<line546>ptrmapPut(pBt, get4byte(pCell), PTRMAP_BTREE, pNew->pgno, &rc);\n<line547>}\n<line548>if( cachedCellSize(&b,i)>pNew->minLocal ){\n<line549>ptrmapPutOvflPtr(pNew, pOld, pCell, &rc);\n<line550>}\n<line551>if( rc ) goto balance_cleanup;\n<line552>}\n<line553>}\n<line554>}\n<line555>/* Insert new divider cells into pParent. */\n<line556>for(i=0; i<nNew-1; i++){\n<line557>u8 *pCell;\n<line558>u8 *pTemp;\n<line559>int sz;\n<line560>u8 *pSrcEnd;\n<line561>MemPage *pNew = apNew[i];\n<line562>j = cntNew[i];\n<line563>assert( j<nMaxCells );\n<line564>assert( b.apCell[j]!=0 );\n<line565>pCell = b.apCell[j];\n<line566>sz = b.szCell[j] + leafCorrection;\n<line567>pTemp = &aOvflSpace[iOvflSpace];\n<line568>if( !pNew->leaf ){\n<line569>memcpy(&pNew->aData[8], pCell, 4);\n<line570>}else if( leafData ){\n<line571>/* If the tree is a leaf-data tree, and the siblings are leaves,\n<line572>** then there is no divider cell in b.apCell[]. Instead, the divider\n<line573>** cell consists of the integer key for the right-most cell of\n<line574>** the sibling-page assembled above only.\n<line575>*/\n<line576>CellInfo info;\n<line577>j--;\n<line578>pNew->xParseCell(pNew, b.apCell[j], &info);\n<line579>pCell = pTemp;\n<line580>sz = 4 + putVarint(&pCell[4], info.nKey);\n<line581>pTemp = 0;\n<line582>}else{\n<line583>pCell -= 4;\n<line584>/* Obscure case for non-leaf-data trees: If the cell at pCell was\n<line585>** previously stored on a leaf node, and its reported size was 4\n<line586>** bytes, then it may actually be smaller than this\n<line587>** (see btreeParseCellPtr(), 4 bytes is the minimum size of\n<line588>** any cell). But it is important to pass the correct size to\n<line589>** insertCell(), so reparse the cell now.\n<line590>**\n<line591>** This can only happen for b-trees used to evaluate "IN (SELECT ...)"\n<line592>** and WITHOUT ROWID tables with exactly one column which is the\n<line593>** primary key.\n<line594>*/\n<line595>if( b.szCell[j]==4 ){\n<line596>assert(leafCorrection==4);\n<line597>sz = pParent->xCellSize(pParent, pCell);\n<line598>}\n<line599>}\n<line600>iOvflSpace += sz;\n<line601>assert( sz<=pBt->maxLocal+23 );\n<line602>assert( iOvflSpace <= (int)pBt->pageSize );\n<line603>assert( b.ixNx[NB*2-1]>j );\n<line604>for(k=0; b.ixNx[k]<=j; k++){}\n<line605>pSrcEnd = b.apEnd[k];\n<line606>if( SQLITE_OVERFLOW(pSrcEnd, pCell, pCell+sz) ){\n<line607>rc = SQLITE_CORRUPT_BKPT;\n<line608>goto balance_cleanup;\n<line609>}\n<line610>rc = insertCell(pParent, nxDiv+i, pCell, sz, pTemp, pNew->pgno);\n<line611>if( rc!=SQLITE_OK ) goto balance_cleanup;\n<line612>assert( sqlite3PagerIswriteable(pParent->pDbPage) );\n<line613>}\n<line614>/* Now update the actual sibling pages. The order in which they are updated\n<line615>** is important, as this code needs to avoid disrupting any page from which\n<line616>** cells may still to be read. In practice, this means:\n<line617>**\n<line618>**  (1) If cells are moving left (from apNew[iPg] to apNew[iPg-1])\n<line619>**      then it is not safe to update page apNew[iPg] until after\n<line620>**      the left-hand sibling apNew[iPg-1] has been updated.\n<line621>**\n<line622>**  (2) If cells are moving right (from apNew[iPg] to apNew[iPg+1])\n<line623>**      then it is not safe to update page apNew[iPg] until after\n<line624>**      the right-hand sibling apNew[iPg+1] has been updated.\n<line625>**\n<line626>** If neither of the above apply, the page is safe to update.\n<line627>**\n<line628>** The iPg value in the following loop starts at nNew-1 goes down\n<line629>** to 0, then back up to nNew-1 again, thus making two passes over\n<line630>** the pages.  On the initial downward pass, only condition (1) above\n<line631>** needs to be tested because (2) will always be true from the previous\n<line632>** step.  On the upward pass, both conditions are always true, so the\n<line633>** upwards pass simply processes pages that were missed on the downward\n<line634>** pass.\n<line635>*/\n<line636>for(i=1-nNew; i<nNew; i++){\n<line637>int iPg = i<0 ? -i : i;\n<line638>assert( iPg>=0 && iPg<nNew );\n<line639>assert( iPg>=1 || i>=0 );\n<line640>assert( iPg<ArraySize(cntOld) );\n<line641>if( abDone[iPg] ) continue;         /* Skip pages already processed */\n<line642>if( i>=0                            /* On the upwards pass, or... */\n<line643>|| cntOld[iPg-1]>=cntNew[iPg-1]    /* Condition (1) is true */\n<line644>){\n<line645>int iNew;\n<line646>int iOld;\n<line647>int nNewCell;\n<line648>/* Verify condition (1):  If cells are moving left, update iPg\n<line649>** only after iPg-1 has already been updated. */\n<line650>assert( iPg==0 || cntOld[iPg-1]>=cntNew[iPg-1] || abDone[iPg-1] );\n<line651>/* Verify condition (2):  If cells are moving right, update iPg\n<line652>** only after iPg+1 has already been updated. */\n<line653>assert( cntNew[iPg]>=cntOld[iPg] || abDone[iPg+1] );\n<line654>if( iPg==0 ){\n<line655>iNew = iOld = 0;\n<line656>nNewCell = cntNew[0];\n<line657>}else{\n<line658>iOld = iPg<nOld ? (cntOld[iPg-1] + !leafData) : b.nCell;\n<line659>iNew = cntNew[iPg-1] + !leafData;\n<line660>nNewCell = cntNew[iPg] - iNew;\n<line661>}\n<line662>rc = editPage(apNew[iPg], iOld, iNew, nNewCell, &b);\n<line663>if( rc ) goto balance_cleanup;\n<line664>abDone[iPg]++;\n<line665>apNew[iPg]->nFree = usableSpace-szNew[iPg];\n<line666>assert( apNew[iPg]->nOverflow==0 );\n<line667>assert( apNew[iPg]->nCell==nNewCell );\n<line668>}\n<line669>}\n<line670>/* All pages have been processed exactly once */\n<line671>assert( memcmp(abDone, "\01\01\01\01\01", nNew)==0 );\n<line672>assert( nOld>0 );\n<line673>assert( nNew>0 );\n<line674>if( isRoot && pParent->nCell==0 && pParent->hdrOffset<=apNew[0]->nFree ){\n<line675>/* The root page of the b-tree now contains no cells. The only sibling\n<line676>** page is the right-child of the parent. Copy the contents of the\n<line677>** child page into the parent, decreasing the overall height of the\n<line678>** b-tree structure by one. This is described as the "balance-shallower"\n<line679>** sub-algorithm in some documentation.\n<line680>**\n<line681>** If this is an auto-vacuum database, the call to copyNodeContent()\n<line682>** sets all pointer-map entries corresponding to database image pages\n<line683>** for which the pointer is stored within the content being copied.\n<line684>**\n<line685>** It is critical that the child page be defragmented before being\n<line686>** copied into the parent, because if the parent is page 1 then it will\n<line687>** by smaller than the child due to the database header, and so all the\n<line688>** free space needs to be up front.\n<line689>*/\n<line690>assert( nNew==1 || CORRUPT_DB );\n<line691>rc = defragmentPage(apNew[0], -1);\n<line692>testcase( rc!=SQLITE_OK );\n<line693>assert( apNew[0]->nFree ==\n<line694>(get2byteNotZero(&apNew[0]->aData[5]) - apNew[0]->cellOffset\n<line695>- apNew[0]->nCell*2)\n<line696>|| rc!=SQLITE_OK\n<line697>);\n<line698>copyNodeContent(apNew[0], pParent, &rc);\n<line699>freePage(apNew[0], &rc);\n<line700>}else if( ISAUTOVACUUM(pBt) && !leafCorrection ){\n<line701>/* Fix the pointer map entries associated with the right-child of each\n<line702>** sibling page. All other pointer map entries have already been taken\n<line703>** care of.  */\n<line704>for(i=0; i<nNew; i++){\n<line705>u32 key = get4byte(&apNew[i]->aData[8]);\n<line706>ptrmapPut(pBt, key, PTRMAP_BTREE, apNew[i]->pgno, &rc);\n<line707>}\n<line708>}\n<line709>assert( pParent->isInit );\n<line710>TRACE(("BALANCE: finished: old=%u new=%u cells=%u\n",\n<line711>nOld, nNew, b.nCell));\n<line712>/* Free any old pages that were not reused as new pages.\n<line713>*/\n<line714>for(i=nNew; i<nOld; i++){\n<line715>freePage(apOld[i], &rc);\n<line716>}\n<line717>#if 0\n<line718>if( ISAUTOVACUUM(pBt) && rc==SQLITE_OK && apNew[0]->isInit ){\n<line719>/* The ptrmapCheckPages() contains assert() statements that verify that\n<line720>** all pointer map pages are set correctly. This is helpful while\n<line721>** debugging. This is usually disabled because a corrupt database may\n<line722>** cause an assert() statement to fail.  */\n<line723>ptrmapCheckPages(apNew, nNew);\n<line724>ptrmapCheckPages(&pParent, 1);\n<line725>}\n<line726>#endif\n<line727>/*\n<line728>** Cleanup before returning.\n<line729>*/\n<line730>balance_cleanup:\n<line731>sqlite3StackFree(0, b.apCell);\n<line732>for(i=0; i<nOld; i++){\n<line733>releasePage(apOld[i]);\n<line734>}\n<line735>for(i=0; i<nNew; i++){\n<line736>releasePage(apNew[i]);\n<line737>}\n<line738>return rc;\n<line739>}
----------------------------------------
Function: balance_deeper
Content: <line0>static int balance_deeper(MemPage *pRoot, MemPage **ppChild){\n<line1>int rc;                        /* Return value from subprocedures */\n<line2>MemPage *pChild = 0;           /* Pointer to a new child page */\n<line3>Pgno pgnoChild = 0;            /* Page number of the new child page */\n<line4>BtShared *pBt = pRoot->pBt;    /* The BTree */\n<line5>assert( pRoot->nOverflow>0 );\n<line6>assert( sqlite3_mutex_held(pBt->mutex) );\n<line7>/* Make pRoot, the root page of the b-tree, writable. Allocate a new\n<line8>** page that will become the new right-child of pPage. Copy the contents\n<line9>** of the node stored on pRoot into the new child page.\n<line10>*/\n<line11>rc = sqlite3PagerWrite(pRoot->pDbPage);\n<line12>if( rc==SQLITE_OK ){\n<line13>rc = allocateBtreePage(pBt,&pChild,&pgnoChild,pRoot->pgno,0);\n<line14>copyNodeContent(pRoot, pChild, &rc);\n<line15>if( ISAUTOVACUUM(pBt) ){\n<line16>ptrmapPut(pBt, pgnoChild, PTRMAP_BTREE, pRoot->pgno, &rc);\n<line17>}\n<line18>}\n<line19>if( rc ){\n<line20>*ppChild = 0;\n<line21>releasePage(pChild);\n<line22>return rc;\n<line23>}\n<line24>assert( sqlite3PagerIswriteable(pChild->pDbPage) );\n<line25>assert( sqlite3PagerIswriteable(pRoot->pDbPage) );\n<line26>assert( pChild->nCell==pRoot->nCell || CORRUPT_DB );\n<line27>TRACE(("BALANCE: copy root %u into %u\n", pRoot->pgno, pChild->pgno));\n<line28>/* Copy the overflow cells from pRoot to pChild */\n<line29>memcpy(pChild->aiOvfl, pRoot->aiOvfl,\n<line30>pRoot->nOverflow*sizeof(pRoot->aiOvfl[0]));\n<line31>memcpy(pChild->apOvfl, pRoot->apOvfl,\n<line32>pRoot->nOverflow*sizeof(pRoot->apOvfl[0]));\n<line33>pChild->nOverflow = pRoot->nOverflow;\n<line34>/* Zero the contents of pRoot. Then install pChild as the right-child. */\n<line35>zeroPage(pRoot, pChild->aData[0] & ~PTF_LEAF);\n<line36>put4byte(&pRoot->aData[pRoot->hdrOffset+8], pgnoChild);\n<line37>*ppChild = pChild;\n<line38>return SQLITE_OK;\n<line39>}
----------------------------------------
Function: anotherValidCursor
Content: <line0>static int anotherValidCursor(BtCursor *pCur){\n<line1>BtCursor *pOther;\n<line2>for(pOther=pCur->pBt->pCursor; pOther; pOther=pOther->pNext){\n<line3>if( pOther!=pCur\n<line4>&& pOther->eState==CURSOR_VALID\n<line5>&& pOther->pPage==pCur->pPage\n<line6>){\n<line7>return SQLITE_CORRUPT_PAGE(pCur->pPage);\n<line8>}\n<line9>}\n<line10>return SQLITE_OK;\n<line11>}
----------------------------------------
Function: balance
Content: <line0>static int balance(BtCursor *pCur){\n<line1>int rc = SQLITE_OK;\n<line2>u8 aBalanceQuickSpace[13];\n<line3>u8 *pFree = 0;\n<line4>VVA_ONLY( int balance_quick_called = 0 );\n<line5>VVA_ONLY( int balance_deeper_called = 0 );\n<line6>do {\n<line7>int iPage;\n<line8>MemPage *pPage = pCur->pPage;\n<line9>if( NEVER(pPage->nFree<0) && btreeComputeFreeSpace(pPage) ) break;\n<line10>if( pPage->nOverflow==0 && pPage->nFree*3<=(int)pCur->pBt->usableSize*2 ){\n<line11>/* No rebalance required as long as:\n<line12>**   (1) There are no overflow cells\n<line13>**   (2) The amount of free space on the page is less than 2/3rds of\n<line14>**       the total usable space on the page. */\n<line15>break;\n<line16>}else if( (iPage = pCur->iPage)==0 ){\n<line17>if( pPage->nOverflow && (rc = anotherValidCursor(pCur))==SQLITE_OK ){\n<line18>/* The root page of the b-tree is overfull. In this case call the\n<line19>** balance_deeper() function to create a new child for the root-page\n<line20>** and copy the current contents of the root-page to it. The\n<line21>** next iteration of the do-loop will balance the child page.\n<line22>*/\n<line23>assert( balance_deeper_called==0 );\n<line24>VVA_ONLY( balance_deeper_called++ );\n<line25>rc = balance_deeper(pPage, &pCur->apPage[1]);\n<line26>if( rc==SQLITE_OK ){\n<line27>pCur->iPage = 1;\n<line28>pCur->ix = 0;\n<line29>pCur->aiIdx[0] = 0;\n<line30>pCur->apPage[0] = pPage;\n<line31>pCur->pPage = pCur->apPage[1];\n<line32>assert( pCur->pPage->nOverflow );\n<line33>}\n<line34>}else{\n<line35>break;\n<line36>}\n<line37>}else if( sqlite3PagerPageRefcount(pPage->pDbPage)>1 ){\n<line38>/* The page being written is not a root page, and there is currently\n<line39>** more than one reference to it. This only happens if the page is one\n<line40>** of its own ancestor pages. Corruption. */\n<line41>rc = SQLITE_CORRUPT_PAGE(pPage);\n<line42>}else{\n<line43>MemPage * const pParent = pCur->apPage[iPage-1];\n<line44>int const iIdx = pCur->aiIdx[iPage-1];\n<line45>rc = sqlite3PagerWrite(pParent->pDbPage);\n<line46>if( rc==SQLITE_OK && pParent->nFree<0 ){\n<line47>rc = btreeComputeFreeSpace(pParent);\n<line48>}\n<line49>if( rc==SQLITE_OK ){\n<line50>#ifndef SQLITE_OMIT_QUICKBALANCE\n<line51>if( pPage->intKeyLeaf\n<line52>&& pPage->nOverflow==1\n<line53>&& pPage->aiOvfl[0]==pPage->nCell\n<line54>&& pParent->pgno!=1\n<line55>&& pParent->nCell==iIdx\n<line56>){\n<line57>/* Call balance_quick() to create a new sibling of pPage on which\n<line58>** to store the overflow cell. balance_quick() inserts a new cell\n<line59>** into pParent, which may cause pParent overflow. If this\n<line60>** happens, the next iteration of the do-loop will balance pParent\n<line61>** use either balance_nonroot() or balance_deeper(). Until this\n<line62>** happens, the overflow cell is stored in the aBalanceQuickSpace[]\n<line63>** buffer.\n<line64>**\n<line65>** The purpose of the following assert() is to check that only a\n<line66>** single call to balance_quick() is made for each call to this\n<line67>** function. If this were not verified, a subtle bug involving reuse\n<line68>** of the aBalanceQuickSpace[] might sneak in.\n<line69>*/\n<line70>assert( balance_quick_called==0 );\n<line71>VVA_ONLY( balance_quick_called++ );\n<line72>rc = balance_quick(pParent, pPage, aBalanceQuickSpace);\n<line73>}else\n<line74>#endif\n<line75>{\n<line76>/* In this case, call balance_nonroot() to redistribute cells\n<line77>** between pPage and up to 2 of its sibling pages. This involves\n<line78>** modifying the contents of pParent, which may cause pParent to\n<line79>** become overfull or underfull. The next iteration of the do-loop\n<line80>** will balance the parent page to correct this.\n<line81>**\n<line82>** If the parent page becomes overfull, the overflow cell or cells\n<line83>** are stored in the pSpace buffer allocated immediately below.\n<line84>** A subsequent iteration of the do-loop will deal with this by\n<line85>** calling balance_nonroot() (balance_deeper() may be called first,\n<line86>** but it doesn't deal with overflow cells - just moves them to a\n<line87>** different page). Once this subsequent call to balance_nonroot()\n<line88>** has completed, it is safe to release the pSpace buffer used by\n<line89>** the previous call, as the overflow cell data will have been\n<line90>** copied either into the body of a database page or into the new\n<line91>** pSpace buffer passed to the latter call to balance_nonroot().\n<line92>*/\n<line93>u8 *pSpace = sqlite3PageMalloc(pCur->pBt->pageSize);\n<line94>rc = balance_nonroot(pParent, iIdx, pSpace, iPage==1,\n<line95>pCur->hints&BTREE_BULKLOAD);\n<line96>if( pFree ){\n<line97>/* If pFree is not NULL, it points to the pSpace buffer used\n<line98>** by a previous call to balance_nonroot(). Its contents are\n<line99>** now stored either on real database pages or within the\n<line100>** new pSpace buffer, so it may be safely freed here. */\n<line101>sqlite3PageFree(pFree);\n<line102>}\n<line103>/* The pSpace buffer will be freed after the next call to\n<line104>** balance_nonroot(), or just before this function returns, whichever\n<line105>** comes first. */\n<line106>pFree = pSpace;\n<line107>}\n<line108>}\n<line109>pPage->nOverflow = 0;\n<line110>/* The next iteration of the do-loop balances the parent page. */\n<line111>releasePage(pPage);\n<line112>pCur->iPage--;\n<line113>assert( pCur->iPage>=0 );\n<line114>pCur->pPage = pCur->apPage[pCur->iPage];\n<line115>}\n<line116>}while( rc==SQLITE_OK );\n<line117>if( pFree ){\n<line118>sqlite3PageFree(pFree);\n<line119>}\n<line120>return rc;\n<line121>}
----------------------------------------
Function: btreeOverwriteContent
Content: <line0>static int btreeOverwriteContent(\n<line1>MemPage *pPage,           /* MemPage on which writing will occur */\n<line2>u8 *pDest,                /* Pointer to the place to start writing */\n<line3>const BtreePayload *pX,   /* Source of data to write */\n<line4>int iOffset,              /* Offset of first byte to write */\n<line5>int iAmt                  /* Number of bytes to be written */\n<line6>){\n<line7>int nData = pX->nData - iOffset;\n<line8>if( nData<=0 ){\n<line9>/* Overwriting with zeros */\n<line10>int i;\n<line11>for(i=0; i<iAmt && pDest[i]==0; i++){}\n<line12>if( i<iAmt ){\n<line13>int rc = sqlite3PagerWrite(pPage->pDbPage);\n<line14>if( rc ) return rc;\n<line15>memset(pDest + i, 0, iAmt - i);\n<line16>}\n<line17>}else{\n<line18>if( nData<iAmt ){\n<line19>/* Mixed read data and zeros at the end.  Make a recursive call\n<line20>** to write the zeros then fall through to write the real data */\n<line21>int rc = btreeOverwriteContent(pPage, pDest+nData, pX, iOffset+nData,\n<line22>iAmt-nData);\n<line23>if( rc ) return rc;\n<line24>iAmt = nData;\n<line25>}\n<line26>if( memcmp(pDest, ((u8*)pX->pData) + iOffset, iAmt)!=0 ){\n<line27>int rc = sqlite3PagerWrite(pPage->pDbPage);\n<line28>if( rc ) return rc;\n<line29>/* In a corrupt database, it is possible for the source and destination\n<line30>** buffers to overlap.  This is harmless since the database is already\n<line31>** corrupt but it does cause valgrind and ASAN warnings.  So use\n<line32>** memmove(). */\n<line33>memmove(pDest, ((u8*)pX->pData) + iOffset, iAmt);\n<line34>}\n<line35>}\n<line36>return SQLITE_OK;\n<line37>}
----------------------------------------
Function: btreeOverwriteOverflowCell
Content: <line0>static SQLITE_NOINLINE int btreeOverwriteOverflowCell(\n<line1>BtCursor *pCur,                     /* Cursor pointing to cell to overwrite */\n<line2>const BtreePayload *pX              /* Content to write into the cell */\n<line3>){\n<line4>int iOffset;                        /* Next byte of pX->pData to write */\n<line5>int nTotal = pX->nData + pX->nZero; /* Total bytes of to write */\n<line6>int rc;                             /* Return code */\n<line7>MemPage *pPage = pCur->pPage;       /* Page being written */\n<line8>BtShared *pBt;                      /* Btree */\n<line9>Pgno ovflPgno;                      /* Next overflow page to write */\n<line10>u32 ovflPageSize;                   /* Size to write on overflow page */\n<line11>assert( pCur->info.nLocal<nTotal );  /* pCur is an overflow cell */\n<line12>/* Overwrite the local portion first */\n<line13>rc = btreeOverwriteContent(pPage, pCur->info.pPayload, pX,\n<line14>0, pCur->info.nLocal);\n<line15>if( rc ) return rc;\n<line16>/* Now overwrite the overflow pages */\n<line17>iOffset = pCur->info.nLocal;\n<line18>assert( nTotal>=0 );\n<line19>assert( iOffset>=0 );\n<line20>ovflPgno = get4byte(pCur->info.pPayload + iOffset);\n<line21>pBt = pPage->pBt;\n<line22>ovflPageSize = pBt->usableSize - 4;\n<line23>do{\n<line24>rc = btreeGetPage(pBt, ovflPgno, &pPage, 0);\n<line25>if( rc ) return rc;\n<line26>if( sqlite3PagerPageRefcount(pPage->pDbPage)!=1 || pPage->isInit ){\n<line27>rc = SQLITE_CORRUPT_PAGE(pPage);\n<line28>}else{\n<line29>if( iOffset+ovflPageSize<(u32)nTotal ){\n<line30>ovflPgno = get4byte(pPage->aData);\n<line31>}else{\n<line32>ovflPageSize = nTotal - iOffset;\n<line33>}\n<line34>rc = btreeOverwriteContent(pPage, pPage->aData+4, pX,\n<line35>iOffset, ovflPageSize);\n<line36>}\n<line37>sqlite3PagerUnref(pPage->pDbPage);\n<line38>if( rc ) return rc;\n<line39>iOffset += ovflPageSize;\n<line40>}while( iOffset<nTotal );\n<line41>return SQLITE_OK;\n<line42>}
----------------------------------------
Function: btreeOverwriteCell
Content: <line0>static int btreeOverwriteCell(BtCursor *pCur, const BtreePayload *pX){\n<line1>int nTotal = pX->nData + pX->nZero; /* Total bytes of to write */\n<line2>MemPage *pPage = pCur->pPage;       /* Page being written */\n<line3>if( pCur->info.pPayload + pCur->info.nLocal > pPage->aDataEnd\n<line4>|| pCur->info.pPayload < pPage->aData + pPage->cellOffset\n<line5>){\n<line6>return SQLITE_CORRUPT_PAGE(pPage);\n<line7>}\n<line8>if( pCur->info.nLocal==nTotal ){\n<line9>/* The entire cell is local */\n<line10>return btreeOverwriteContent(pPage, pCur->info.pPayload, pX,\n<line11>0, pCur->info.nLocal);\n<line12>}else{\n<line13>/* The cell contains overflow content */\n<line14>return btreeOverwriteOverflowCell(pCur, pX);\n<line15>}\n<line16>}
----------------------------------------
Function: btreeCreateTable
Content: <line0>static int btreeCreateTable(Btree *p, Pgno *piTable, int createTabFlags){\n<line1>BtShared *pBt = p->pBt;\n<line2>MemPage *pRoot;\n<line3>Pgno pgnoRoot;\n<line4>int rc;\n<line5>int ptfFlags;          /* Page-type flags for the root page of new table */\n<line6>assert( sqlite3BtreeHoldsMutex(p) );\n<line7>assert( pBt->inTransaction==TRANS_WRITE );\n<line8>assert( (pBt->btsFlags & BTS_READ_ONLY)==0 );\n<line9>#ifdef SQLITE_OMIT_AUTOVACUUM\n<line10>rc = allocateBtreePage(pBt, &pRoot, &pgnoRoot, 1, 0);\n<line11>if( rc ){\n<line12>return rc;\n<line13>}\n<line14>#else\n<line15>if( pBt->autoVacuum ){\n<line16>Pgno pgnoMove;      /* Move a page here to make room for the root-page */\n<line17>MemPage *pPageMove; /* The page to move to. */\n<line18>/* Creating a new table may probably require moving an existing database\n<line19>** to make room for the new tables root page. In case this page turns\n<line20>** out to be an overflow page, delete all overflow page-map caches\n<line21>** held by open cursors.\n<line22>*/\n<line23>invalidateAllOverflowCache(pBt);\n<line24>/* Read the value of meta[3] from the database to determine where the\n<line25>** root page of the new table should go. meta[3] is the largest root-page\n<line26>** created so far, so the new root-page is (meta[3]+1).\n<line27>*/\n<line28>sqlite3BtreeGetMeta(p, BTREE_LARGEST_ROOT_PAGE, &pgnoRoot);\n<line29>if( pgnoRoot>btreePagecount(pBt) ){\n<line30>return SQLITE_CORRUPT_PGNO(pgnoRoot);\n<line31>}\n<line32>pgnoRoot++;\n<line33>/* The new root-page may not be allocated on a pointer-map page, or the\n<line34>** PENDING_BYTE page.\n<line35>*/\n<line36>while( pgnoRoot==PTRMAP_PAGENO(pBt, pgnoRoot) ||\n<line37>pgnoRoot==PENDING_BYTE_PAGE(pBt) ){\n<line38>pgnoRoot++;\n<line39>}\n<line40>assert( pgnoRoot>=3 );\n<line41>/* Allocate a page. The page that currently resides at pgnoRoot will\n<line42>** be moved to the allocated page (unless the allocated page happens\n<line43>** to reside at pgnoRoot).\n<line44>*/\n<line45>rc = allocateBtreePage(pBt, &pPageMove, &pgnoMove, pgnoRoot, BTALLOC_EXACT);\n<line46>if( rc!=SQLITE_OK ){\n<line47>return rc;\n<line48>}\n<line49>if( pgnoMove!=pgnoRoot ){\n<line50>/* pgnoRoot is the page that will be used for the root-page of\n<line51>** the new table (assuming an error did not occur). But we were\n<line52>** allocated pgnoMove. If required (i.e. if it was not allocated\n<line53>** by extending the file), the current page at position pgnoMove\n<line54>** is already journaled.\n<line55>*/\n<line56>u8 eType = 0;\n<line57>Pgno iPtrPage = 0;\n<line58>/* Save the positions of any open cursors. This is required in\n<line59>** case they are holding a reference to an xFetch reference\n<line60>** corresponding to page pgnoRoot.  */\n<line61>rc = saveAllCursors(pBt, 0, 0);\n<line62>releasePage(pPageMove);\n<line63>if( rc!=SQLITE_OK ){\n<line64>return rc;\n<line65>}\n<line66>/* Move the page currently at pgnoRoot to pgnoMove. */\n<line67>rc = btreeGetPage(pBt, pgnoRoot, &pRoot, 0);\n<line68>if( rc!=SQLITE_OK ){\n<line69>return rc;\n<line70>}\n<line71>rc = ptrmapGet(pBt, pgnoRoot, &eType, &iPtrPage);\n<line72>if( eType==PTRMAP_ROOTPAGE || eType==PTRMAP_FREEPAGE ){\n<line73>rc = SQLITE_CORRUPT_PGNO(pgnoRoot);\n<line74>}\n<line75>if( rc!=SQLITE_OK ){\n<line76>releasePage(pRoot);\n<line77>return rc;\n<line78>}\n<line79>assert( eType!=PTRMAP_ROOTPAGE );\n<line80>assert( eType!=PTRMAP_FREEPAGE );\n<line81>rc = relocatePage(pBt, pRoot, eType, iPtrPage, pgnoMove, 0);\n<line82>releasePage(pRoot);\n<line83>/* Obtain the page at pgnoRoot */\n<line84>if( rc!=SQLITE_OK ){\n<line85>return rc;\n<line86>}\n<line87>rc = btreeGetPage(pBt, pgnoRoot, &pRoot, 0);\n<line88>if( rc!=SQLITE_OK ){\n<line89>return rc;\n<line90>}\n<line91>rc = sqlite3PagerWrite(pRoot->pDbPage);\n<line92>if( rc!=SQLITE_OK ){\n<line93>releasePage(pRoot);\n<line94>return rc;\n<line95>}\n<line96>}else{\n<line97>pRoot = pPageMove;\n<line98>}\n<line99>/* Update the pointer-map and meta-data with the new root-page number. */\n<line100>ptrmapPut(pBt, pgnoRoot, PTRMAP_ROOTPAGE, 0, &rc);\n<line101>if( rc ){\n<line102>releasePage(pRoot);\n<line103>return rc;\n<line104>}\n<line105>/* When the new root page was allocated, page 1 was made writable in\n<line106>** order either to increase the database filesize, or to decrement the\n<line107>** freelist count.  Hence, the sqlite3BtreeUpdateMeta() call cannot fail.\n<line108>*/\n<line109>assert( sqlite3PagerIswriteable(pBt->pPage1->pDbPage) );\n<line110>rc = sqlite3BtreeUpdateMeta(p, 4, pgnoRoot);\n<line111>if( NEVER(rc) ){\n<line112>releasePage(pRoot);\n<line113>return rc;\n<line114>}\n<line115>}else{\n<line116>rc = allocateBtreePage(pBt, &pRoot, &pgnoRoot, 1, 0);\n<line117>if( rc ) return rc;\n<line118>}\n<line119>#endif\n<line120>assert( sqlite3PagerIswriteable(pRoot->pDbPage) );\n<line121>if( createTabFlags & BTREE_INTKEY ){\n<line122>ptfFlags = PTF_INTKEY | PTF_LEAFDATA | PTF_LEAF;\n<line123>}else{\n<line124>ptfFlags = PTF_ZERODATA | PTF_LEAF;\n<line125>}\n<line126>zeroPage(pRoot, ptfFlags);\n<line127>sqlite3PagerUnref(pRoot->pDbPage);\n<line128>assert( (pBt->openFlags & BTREE_SINGLE)==0 || pgnoRoot==2 );\n<line129>*piTable = pgnoRoot;\n<line130>return SQLITE_OK;\n<line131>}
----------------------------------------
Function: clearDatabasePage
Content: <line0>static int clearDatabasePage(\n<line1>BtShared *pBt,           /* The BTree that contains the table */\n<line2>Pgno pgno,               /* Page number to clear */\n<line3>int freePageFlag,        /* Deallocate page if true */\n<line4>i64 *pnChange            /* Add number of Cells freed to this counter */\n<line5>){\n<line6>MemPage *pPage;\n<line7>int rc;\n<line8>unsigned char *pCell;\n<line9>int i;\n<line10>int hdr;\n<line11>CellInfo info;\n<line12>assert( sqlite3_mutex_held(pBt->mutex) );\n<line13>if( pgno>btreePagecount(pBt) ){\n<line14>return SQLITE_CORRUPT_PGNO(pgno);\n<line15>}\n<line16>rc = getAndInitPage(pBt, pgno, &pPage, 0);\n<line17>if( rc ) return rc;\n<line18>if( (pBt->openFlags & BTREE_SINGLE)==0\n<line19>&& sqlite3PagerPageRefcount(pPage->pDbPage) != (1 + (pgno==1))\n<line20>){\n<line21>rc = SQLITE_CORRUPT_PAGE(pPage);\n<line22>goto cleardatabasepage_out;\n<line23>}\n<line24>hdr = pPage->hdrOffset;\n<line25>for(i=0; i<pPage->nCell; i++){\n<line26>pCell = findCell(pPage, i);\n<line27>if( !pPage->leaf ){\n<line28>rc = clearDatabasePage(pBt, get4byte(pCell), 1, pnChange);\n<line29>if( rc ) goto cleardatabasepage_out;\n<line30>}\n<line31>BTREE_CLEAR_CELL(rc, pPage, pCell, info);\n<line32>if( rc ) goto cleardatabasepage_out;\n<line33>}\n<line34>if( !pPage->leaf ){\n<line35>rc = clearDatabasePage(pBt, get4byte(&pPage->aData[hdr+8]), 1, pnChange);\n<line36>if( rc ) goto cleardatabasepage_out;\n<line37>if( pPage->intKey ) pnChange = 0;\n<line38>}\n<line39>if( pnChange ){\n<line40>testcase( !pPage->intKey );\n<line41>*pnChange += pPage->nCell;\n<line42>}\n<line43>if( freePageFlag ){\n<line44>freePage(pPage, &rc);\n<line45>}else if( (rc = sqlite3PagerWrite(pPage->pDbPage))==0 ){\n<line46>zeroPage(pPage, pPage->aData[hdr] | PTF_LEAF);\n<line47>}\n<line48>cleardatabasepage_out:\n<line49>releasePage(pPage);\n<line50>return rc;\n<line51>}
----------------------------------------
Function: btreeDropTable
Content: <line0>static int btreeDropTable(Btree *p, Pgno iTable, int *piMoved){\n<line1>int rc;\n<line2>MemPage *pPage = 0;\n<line3>BtShared *pBt = p->pBt;\n<line4>assert( sqlite3BtreeHoldsMutex(p) );\n<line5>assert( p->inTrans==TRANS_WRITE );\n<line6>assert( iTable>=2 );\n<line7>if( iTable>btreePagecount(pBt) ){\n<line8>return SQLITE_CORRUPT_PGNO(iTable);\n<line9>}\n<line10>rc = sqlite3BtreeClearTable(p, iTable, 0);\n<line11>if( rc ) return rc;\n<line12>rc = btreeGetPage(pBt, (Pgno)iTable, &pPage, 0);\n<line13>if( NEVER(rc) ){\n<line14>releasePage(pPage);\n<line15>return rc;\n<line16>}\n<line17>*piMoved = 0;\n<line18>#ifdef SQLITE_OMIT_AUTOVACUUM\n<line19>freePage(pPage, &rc);\n<line20>releasePage(pPage);\n<line21>#else\n<line22>if( pBt->autoVacuum ){\n<line23>Pgno maxRootPgno;\n<line24>sqlite3BtreeGetMeta(p, BTREE_LARGEST_ROOT_PAGE, &maxRootPgno);\n<line25>if( iTable==maxRootPgno ){\n<line26>/* If the table being dropped is the table with the largest root-page\n<line27>** number in the database, put the root page on the free list.\n<line28>*/\n<line29>freePage(pPage, &rc);\n<line30>releasePage(pPage);\n<line31>if( rc!=SQLITE_OK ){\n<line32>return rc;\n<line33>}\n<line34>}else{\n<line35>/* The table being dropped does not have the largest root-page\n<line36>** number in the database. So move the page that does into the\n<line37>** gap left by the deleted root-page.\n<line38>*/\n<line39>MemPage *pMove;\n<line40>releasePage(pPage);\n<line41>rc = btreeGetPage(pBt, maxRootPgno, &pMove, 0);\n<line42>if( rc!=SQLITE_OK ){\n<line43>return rc;\n<line44>}\n<line45>rc = relocatePage(pBt, pMove, PTRMAP_ROOTPAGE, 0, iTable, 0);\n<line46>releasePage(pMove);\n<line47>if( rc!=SQLITE_OK ){\n<line48>return rc;\n<line49>}\n<line50>pMove = 0;\n<line51>rc = btreeGetPage(pBt, maxRootPgno, &pMove, 0);\n<line52>freePage(pMove, &rc);\n<line53>releasePage(pMove);\n<line54>if( rc!=SQLITE_OK ){\n<line55>return rc;\n<line56>}\n<line57>*piMoved = maxRootPgno;\n<line58>}\n<line59>/* Set the new 'max-root-page' value in the database header. This\n<line60>** is the old value less one, less one more if that happens to\n<line61>** be a root-page number, less one again if that is the\n<line62>** PENDING_BYTE_PAGE.\n<line63>*/\n<line64>maxRootPgno--;\n<line65>while( maxRootPgno==PENDING_BYTE_PAGE(pBt)\n<line66>|| PTRMAP_ISPAGE(pBt, maxRootPgno) ){\n<line67>maxRootPgno--;\n<line68>}\n<line69>assert( maxRootPgno!=PENDING_BYTE_PAGE(pBt) );\n<line70>rc = sqlite3BtreeUpdateMeta(p, 4, maxRootPgno);\n<line71>}else{\n<line72>freePage(pPage, &rc);\n<line73>releasePage(pPage);\n<line74>}\n<line75>#endif\n<line76>return rc;\n<line77>}
----------------------------------------
Function: checkOom
Content: <line0>static void checkOom(IntegrityCk *pCheck){\n<line1>pCheck->rc = SQLITE_NOMEM;\n<line2>pCheck->mxErr = 0;  /* Causes integrity_check processing to stop */\n<line3>if( pCheck->nErr==0 ) pCheck->nErr++;\n<line4>}
----------------------------------------
Function: checkProgress
Content: <line0>static void checkProgress(IntegrityCk *pCheck){\n<line1>sqlite3 *db = pCheck->db;\n<line2>if( AtomicLoad(&db->u1.isInterrupted) ){\n<line3>pCheck->rc = SQLITE_INTERRUPT;\n<line4>pCheck->nErr++;\n<line5>pCheck->mxErr = 0;\n<line6>}\n<line7>#ifndef SQLITE_OMIT_PROGRESS_CALLBACK\n<line8>if( db->xProgress ){\n<line9>assert( db->nProgressOps>0 );\n<line10>pCheck->nStep++;\n<line11>if( (pCheck->nStep % db->nProgressOps)==0\n<line12>&& db->xProgress(db->pProgressArg)\n<line13>){\n<line14>pCheck->rc = SQLITE_INTERRUPT;\n<line15>pCheck->nErr++;\n<line16>pCheck->mxErr = 0;\n<line17>}\n<line18>}\n<line19>#endif\n<line20>}
----------------------------------------
Function: checkAppendMsg
Content: <line0>static void checkAppendMsg(\n<line1>IntegrityCk *pCheck,\n<line2>const char *zFormat,\n<line3>...\n<line4>){\n<line5>va_list ap;\n<line6>checkProgress(pCheck);\n<line7>if( !pCheck->mxErr ) return;\n<line8>pCheck->mxErr--;\n<line9>pCheck->nErr++;\n<line10>va_start(ap, zFormat);\n<line11>if( pCheck->errMsg.nChar ){\n<line12>sqlite3_str_append(&pCheck->errMsg, "\n", 1);\n<line13>}\n<line14>if( pCheck->zPfx ){\n<line15>sqlite3_str_appendf(&pCheck->errMsg, pCheck->zPfx,\n<line16>pCheck->v0, pCheck->v1, pCheck->v2);\n<line17>}\n<line18>sqlite3_str_vappendf(&pCheck->errMsg, zFormat, ap);\n<line19>va_end(ap);\n<line20>if( pCheck->errMsg.accError==SQLITE_NOMEM ){\n<line21>checkOom(pCheck);\n<line22>}\n<line23>}
----------------------------------------
Function: getPageReferenced
Content: <line0>static int getPageReferenced(IntegrityCk *pCheck, Pgno iPg){\n<line1>assert( pCheck->aPgRef!=0 );\n<line2>assert( iPg<=pCheck->nCkPage && sizeof(pCheck->aPgRef[0])==1 );\n<line3>return (pCheck->aPgRef[iPg/8] & (1 << (iPg & 0x07)));\n<line4>}
----------------------------------------
Function: setPageReferenced
Content: <line0>static void setPageReferenced(IntegrityCk *pCheck, Pgno iPg){\n<line1>assert( pCheck->aPgRef!=0 );\n<line2>assert( iPg<=pCheck->nCkPage && sizeof(pCheck->aPgRef[0])==1 );\n<line3>pCheck->aPgRef[iPg/8] |= (1 << (iPg & 0x07));\n<line4>}
----------------------------------------
Function: checkRef
Content: <line0>static int checkRef(IntegrityCk *pCheck, Pgno iPage){\n<line1>if( iPage>pCheck->nCkPage || iPage==0 ){\n<line2>checkAppendMsg(pCheck, "invalid page number %u", iPage);\n<line3>return 1;\n<line4>}\n<line5>if( getPageReferenced(pCheck, iPage) ){\n<line6>checkAppendMsg(pCheck, "2nd reference to page %u", iPage);\n<line7>return 1;\n<line8>}\n<line9>setPageReferenced(pCheck, iPage);\n<line10>return 0;\n<line11>}
----------------------------------------
Function: checkPtrmap
Content: <line0>static void checkPtrmap(\n<line1>IntegrityCk *pCheck,   /* Integrity check context */\n<line2>Pgno iChild,           /* Child page number */\n<line3>u8 eType,              /* Expected pointer map type */\n<line4>Pgno iParent           /* Expected pointer map parent page number */\n<line5>){\n<line6>int rc;\n<line7>u8 ePtrmapType;\n<line8>Pgno iPtrmapParent;\n<line9>rc = ptrmapGet(pCheck->pBt, iChild, &ePtrmapType, &iPtrmapParent);\n<line10>if( rc!=SQLITE_OK ){\n<line11>if( rc==SQLITE_NOMEM || rc==SQLITE_IOERR_NOMEM ) checkOom(pCheck);\n<line12>checkAppendMsg(pCheck, "Failed to read ptrmap key=%u", iChild);\n<line13>return;\n<line14>}\n<line15>if( ePtrmapType!=eType || iPtrmapParent!=iParent ){\n<line16>checkAppendMsg(pCheck,\n<line17>"Bad ptr map entry key=%u expected=(%u,%u) got=(%u,%u)",\n<line18>iChild, eType, iParent, ePtrmapType, iPtrmapParent);\n<line19>}\n<line20>}
----------------------------------------
Function: checkList
Content: <line0>static void checkList(\n<line1>IntegrityCk *pCheck,  /* Integrity checking context */\n<line2>int isFreeList,       /* True for a freelist.  False for overflow page list */\n<line3>Pgno iPage,           /* Page number for first page in the list */\n<line4>u32 N                 /* Expected number of pages in the list */\n<line5>){\n<line6>int i;\n<line7>u32 expected = N;\n<line8>int nErrAtStart = pCheck->nErr;\n<line9>while( iPage!=0 && pCheck->mxErr ){\n<line10>DbPage *pOvflPage;\n<line11>unsigned char *pOvflData;\n<line12>if( checkRef(pCheck, iPage) ) break;\n<line13>N--;\n<line14>if( sqlite3PagerGet(pCheck->pPager, (Pgno)iPage, &pOvflPage, 0) ){\n<line15>checkAppendMsg(pCheck, "failed to get page %u", iPage);\n<line16>break;\n<line17>}\n<line18>pOvflData = (unsigned char *)sqlite3PagerGetData(pOvflPage);\n<line19>if( isFreeList ){\n<line20>u32 n = (u32)get4byte(&pOvflData[4]);\n<line21>#ifndef SQLITE_OMIT_AUTOVACUUM\n<line22>if( pCheck->pBt->autoVacuum ){\n<line23>checkPtrmap(pCheck, iPage, PTRMAP_FREEPAGE, 0);\n<line24>}\n<line25>#endif\n<line26>if( n>pCheck->pBt->usableSize/4-2 ){\n<line27>checkAppendMsg(pCheck,\n<line28>"freelist leaf count too big on page %u", iPage);\n<line29>N--;\n<line30>}else{\n<line31>for(i=0; i<(int)n; i++){\n<line32>Pgno iFreePage = get4byte(&pOvflData[8+i*4]);\n<line33>#ifndef SQLITE_OMIT_AUTOVACUUM\n<line34>if( pCheck->pBt->autoVacuum ){\n<line35>checkPtrmap(pCheck, iFreePage, PTRMAP_FREEPAGE, 0);\n<line36>}\n<line37>#endif\n<line38>checkRef(pCheck, iFreePage);\n<line39>}\n<line40>N -= n;\n<line41>}\n<line42>}\n<line43>#ifndef SQLITE_OMIT_AUTOVACUUM\n<line44>else{\n<line45>/* If this database supports auto-vacuum and iPage is not the last\n<line46>** page in this overflow list, check that the pointer-map entry for\n<line47>** the following page matches iPage.\n<line48>*/\n<line49>if( pCheck->pBt->autoVacuum && N>0 ){\n<line50>i = get4byte(pOvflData);\n<line51>checkPtrmap(pCheck, i, PTRMAP_OVERFLOW2, iPage);\n<line52>}\n<line53>}\n<line54>#endif\n<line55>iPage = get4byte(pOvflData);\n<line56>sqlite3PagerUnref(pOvflPage);\n<line57>}\n<line58>if( N && nErrAtStart==pCheck->nErr ){\n<line59>checkAppendMsg(pCheck,\n<line60>"%s is %u but should be %u",\n<line61>isFreeList ? "size" : "overflow list length",\n<line62>expected-N, expected);\n<line63>}\n<line64>}
----------------------------------------
Function: btreeHeapInsert
Content: <line0>static void btreeHeapInsert(u32 *aHeap, u32 x){\n<line1>u32 j, i;\n<line2>assert( aHeap!=0 );\n<line3>i = ++aHeap[0];\n<line4>aHeap[i] = x;\n<line5>while( (j = i/2)>0 && aHeap[j]>aHeap[i] ){\n<line6>x = aHeap[j];\n<line7>aHeap[j] = aHeap[i];\n<line8>aHeap[i] = x;\n<line9>i = j;\n<line10>}\n<line11>}
----------------------------------------
Function: btreeHeapPull
Content: <line0>static int btreeHeapPull(u32 *aHeap, u32 *pOut){\n<line1>u32 j, i, x;\n<line2>if( (x = aHeap[0])==0 ) return 0;\n<line3>*pOut = aHeap[1];\n<line4>aHeap[1] = aHeap[x];\n<line5>aHeap[x] = 0xffffffff;\n<line6>aHeap[0]--;\n<line7>i = 1;\n<line8>while( (j = i*2)<=aHeap[0] ){\n<line9>if( aHeap[j]>aHeap[j+1] ) j++;\n<line10>if( aHeap[i]<aHeap[j] ) break;\n<line11>x = aHeap[i];\n<line12>aHeap[i] = aHeap[j];\n<line13>aHeap[j] = x;\n<line14>i = j;\n<line15>}\n<line16>return 1;\n<line17>}
----------------------------------------
Function: checkTreePage
Content: <line0>static int checkTreePage(\n<line1>IntegrityCk *pCheck,  /* Context for the sanity check */\n<line2>Pgno iPage,           /* Page number of the page to check */\n<line3>i64 *piMinKey,        /* Write minimum integer primary key here */\n<line4>i64 maxKey            /* Error if integer primary key greater than this */\n<line5>){\n<line6>MemPage *pPage = 0;      /* The page being analyzed */\n<line7>int i;                   /* Loop counter */\n<line8>int rc;                  /* Result code from subroutine call */\n<line9>int depth = -1, d2;      /* Depth of a subtree */\n<line10>int pgno;                /* Page number */\n<line11>int nFrag;               /* Number of fragmented bytes on the page */\n<line12>int hdr;                 /* Offset to the page header */\n<line13>int cellStart;           /* Offset to the start of the cell pointer array */\n<line14>int nCell;               /* Number of cells */\n<line15>int doCoverageCheck = 1; /* True if cell coverage checking should be done */\n<line16>int keyCanBeEqual = 1;   /* True if IPK can be equal to maxKey\n<line17>** False if IPK must be strictly less than maxKey */\n<line18>u8 *data;                /* Page content */\n<line19>u8 *pCell;               /* Cell content */\n<line20>u8 *pCellIdx;            /* Next element of the cell pointer array */\n<line21>BtShared *pBt;           /* The BtShared object that owns pPage */\n<line22>u32 pc;                  /* Address of a cell */\n<line23>u32 usableSize;          /* Usable size of the page */\n<line24>u32 contentOffset;       /* Offset to the start of the cell content area */\n<line25>u32 *heap = 0;           /* Min-heap used for checking cell coverage */\n<line26>u32 x, prev = 0;         /* Next and previous entry on the min-heap */\n<line27>const char *saved_zPfx = pCheck->zPfx;\n<line28>int saved_v1 = pCheck->v1;\n<line29>int saved_v2 = pCheck->v2;\n<line30>u8 savedIsInit = 0;\n<line31>/* Check that the page exists\n<line32>*/\n<line33>checkProgress(pCheck);\n<line34>if( pCheck->mxErr==0 ) goto end_of_check;\n<line35>pBt = pCheck->pBt;\n<line36>usableSize = pBt->usableSize;\n<line37>if( iPage==0 ) return 0;\n<line38>if( checkRef(pCheck, iPage) ) return 0;\n<line39>pCheck->zPfx = "Tree %u page %u: ";\n<line40>pCheck->v1 = iPage;\n<line41>if( (rc = btreeGetPage(pBt, iPage, &pPage, 0))!=0 ){\n<line42>checkAppendMsg(pCheck,\n<line43>"unable to get the page. error code=%d", rc);\n<line44>if( rc==SQLITE_IOERR_NOMEM ) pCheck->rc = SQLITE_NOMEM;\n<line45>goto end_of_check;\n<line46>}\n<line47>/* Clear MemPage.isInit to make sure the corruption detection code in\n<line48>** btreeInitPage() is executed.  */\n<line49>savedIsInit = pPage->isInit;\n<line50>pPage->isInit = 0;\n<line51>if( (rc = btreeInitPage(pPage))!=0 ){\n<line52>assert( rc==SQLITE_CORRUPT );  /* The only possible error from InitPage */\n<line53>checkAppendMsg(pCheck,\n<line54>"btreeInitPage() returns error code %d", rc);\n<line55>goto end_of_check;\n<line56>}\n<line57>if( (rc = btreeComputeFreeSpace(pPage))!=0 ){\n<line58>assert( rc==SQLITE_CORRUPT );\n<line59>checkAppendMsg(pCheck, "free space corruption", rc);\n<line60>goto end_of_check;\n<line61>}\n<line62>data = pPage->aData;\n<line63>hdr = pPage->hdrOffset;\n<line64>/* Set up for cell analysis */\n<line65>pCheck->zPfx = "Tree %u page %u cell %u: ";\n<line66>contentOffset = get2byteNotZero(&data[hdr+5]);\n<line67>assert( contentOffset<=usableSize );  /* Enforced by btreeInitPage() */\n<line68>/* EVIDENCE-OF: R-37002-32774 The two-byte integer at offset 3 gives the\n<line69>** number of cells on the page. */\n<line70>nCell = get2byte(&data[hdr+3]);\n<line71>assert( pPage->nCell==nCell );\n<line72>if( pPage->leaf || pPage->intKey==0 ){\n<line73>pCheck->nRow += nCell;\n<line74>}\n<line75>/* EVIDENCE-OF: R-23882-45353 The cell pointer array of a b-tree page\n<line76>** immediately follows the b-tree page header. */\n<line77>cellStart = hdr + 12 - 4*pPage->leaf;\n<line78>assert( pPage->aCellIdx==&data[cellStart] );\n<line79>pCellIdx = &data[cellStart + 2*(nCell-1)];\n<line80>if( !pPage->leaf ){\n<line81>/* Analyze the right-child page of internal pages */\n<line82>pgno = get4byte(&data[hdr+8]);\n<line83>#ifndef SQLITE_OMIT_AUTOVACUUM\n<line84>if( pBt->autoVacuum ){\n<line85>pCheck->zPfx = "Tree %u page %u right child: ";\n<line86>checkPtrmap(pCheck, pgno, PTRMAP_BTREE, iPage);\n<line87>}\n<line88>#endif\n<line89>depth = checkTreePage(pCheck, pgno, &maxKey, maxKey);\n<line90>keyCanBeEqual = 0;\n<line91>}else{\n<line92>/* For leaf pages, the coverage check will occur in the same loop\n<line93>** as the other cell checks, so initialize the heap.  */\n<line94>heap = pCheck->heap;\n<line95>heap[0] = 0;\n<line96>}\n<line97>/* EVIDENCE-OF: R-02776-14802 The cell pointer array consists of K 2-byte\n<line98>** integer offsets to the cell contents. */\n<line99>for(i=nCell-1; i>=0 && pCheck->mxErr; i--){\n<line100>CellInfo info;\n<line101>/* Check cell size */\n<line102>pCheck->v2 = i;\n<line103>assert( pCellIdx==&data[cellStart + i*2] );\n<line104>pc = get2byteAligned(pCellIdx);\n<line105>pCellIdx -= 2;\n<line106>if( pc<contentOffset || pc>usableSize-4 ){\n<line107>checkAppendMsg(pCheck, "Offset %u out of range %u..%u",\n<line108>pc, contentOffset, usableSize-4);\n<line109>doCoverageCheck = 0;\n<line110>continue;\n<line111>}\n<line112>pCell = &data[pc];\n<line113>pPage->xParseCell(pPage, pCell, &info);\n<line114>if( pc+info.nSize>usableSize ){\n<line115>checkAppendMsg(pCheck, "Extends off end of page");\n<line116>doCoverageCheck = 0;\n<line117>continue;\n<line118>}\n<line119>/* Check for integer primary key out of range */\n<line120>if( pPage->intKey ){\n<line121>if( keyCanBeEqual ? (info.nKey > maxKey) : (info.nKey >= maxKey) ){\n<line122>checkAppendMsg(pCheck, "Rowid %lld out of order", info.nKey);\n<line123>}\n<line124>maxKey = info.nKey;\n<line125>keyCanBeEqual = 0;     /* Only the first key on the page may ==maxKey */\n<line126>}\n<line127>/* Check the content overflow list */\n<line128>if( info.nPayload>info.nLocal ){\n<line129>u32 nPage;       /* Number of pages on the overflow chain */\n<line130>Pgno pgnoOvfl;   /* First page of the overflow chain */\n<line131>assert( pc + info.nSize - 4 <= usableSize );\n<line132>nPage = (info.nPayload - info.nLocal + usableSize - 5)/(usableSize - 4);\n<line133>pgnoOvfl = get4byte(&pCell[info.nSize - 4]);\n<line134>#ifndef SQLITE_OMIT_AUTOVACUUM\n<line135>if( pBt->autoVacuum ){\n<line136>checkPtrmap(pCheck, pgnoOvfl, PTRMAP_OVERFLOW1, iPage);\n<line137>}\n<line138>#endif\n<line139>checkList(pCheck, 0, pgnoOvfl, nPage);\n<line140>}\n<line141>if( !pPage->leaf ){\n<line142>/* Check sanity of left child page for internal pages */\n<line143>pgno = get4byte(pCell);\n<line144>#ifndef SQLITE_OMIT_AUTOVACUUM\n<line145>if( pBt->autoVacuum ){\n<line146>checkPtrmap(pCheck, pgno, PTRMAP_BTREE, iPage);\n<line147>}\n<line148>#endif\n<line149>d2 = checkTreePage(pCheck, pgno, &maxKey, maxKey);\n<line150>keyCanBeEqual = 0;\n<line151>if( d2!=depth ){\n<line152>checkAppendMsg(pCheck, "Child page depth differs");\n<line153>depth = d2;\n<line154>}\n<line155>}else{\n<line156>/* Populate the coverage-checking heap for leaf pages */\n<line157>btreeHeapInsert(heap, (pc<<16)|(pc+info.nSize-1));\n<line158>}\n<line159>}\n<line160>*piMinKey = maxKey;\n<line161>/* Check for complete coverage of the page\n<line162>*/\n<line163>pCheck->zPfx = 0;\n<line164>if( doCoverageCheck && pCheck->mxErr>0 ){\n<line165>/* For leaf pages, the min-heap has already been initialized and the\n<line166>** cells have already been inserted.  But for internal pages, that has\n<line167>** not yet been done, so do it now */\n<line168>if( !pPage->leaf ){\n<line169>heap = pCheck->heap;\n<line170>heap[0] = 0;\n<line171>for(i=nCell-1; i>=0; i--){\n<line172>u32 size;\n<line173>pc = get2byteAligned(&data[cellStart+i*2]);\n<line174>size = pPage->xCellSize(pPage, &data[pc]);\n<line175>btreeHeapInsert(heap, (pc<<16)|(pc+size-1));\n<line176>}\n<line177>}\n<line178>assert( heap!=0 );\n<line179>/* Add the freeblocks to the min-heap\n<line180>**\n<line181>** EVIDENCE-OF: R-20690-50594 The second field of the b-tree page header\n<line182>** is the offset of the first freeblock, or zero if there are no\n<line183>** freeblocks on the page.\n<line184>*/\n<line185>i = get2byte(&data[hdr+1]);\n<line186>while( i>0 ){\n<line187>int size, j;\n<line188>assert( (u32)i<=usableSize-4 ); /* Enforced by btreeComputeFreeSpace() */\n<line189>size = get2byte(&data[i+2]);\n<line190>assert( (u32)(i+size)<=usableSize ); /* due to btreeComputeFreeSpace() */\n<line191>btreeHeapInsert(heap, (((u32)i)<<16)|(i+size-1));\n<line192>/* EVIDENCE-OF: R-58208-19414 The first 2 bytes of a freeblock are a\n<line193>** big-endian integer which is the offset in the b-tree page of the next\n<line194>** freeblock in the chain, or zero if the freeblock is the last on the\n<line195>** chain. */\n<line196>j = get2byte(&data[i]);\n<line197>/* EVIDENCE-OF: R-06866-39125 Freeblocks are always connected in order of\n<line198>** increasing offset. */\n<line199>assert( j==0 || j>i+size );     /* Enforced by btreeComputeFreeSpace() */\n<line200>assert( (u32)j<=usableSize-4 ); /* Enforced by btreeComputeFreeSpace() */\n<line201>i = j;\n<line202>}\n<line203>/* Analyze the min-heap looking for overlap between cells and/or\n<line204>** freeblocks, and counting the number of untracked bytes in nFrag.\n<line205>**\n<line206>** Each min-heap entry is of the form:    (start_address<<16)|end_address.\n<line207>** There is an implied first entry the covers the page header, the cell\n<line208>** pointer index, and the gap between the cell pointer index and the start\n<line209>** of cell content.\n<line210>**\n<line211>** The loop below pulls entries from the min-heap in order and compares\n<line212>** the start_address against the previous end_address.  If there is an\n<line213>** overlap, that means bytes are used multiple times.  If there is a gap,\n<line214>** that gap is added to the fragmentation count.\n<line215>*/\n<line216>nFrag = 0;\n<line217>prev = contentOffset - 1;   /* Implied first min-heap entry */\n<line218>while( btreeHeapPull(heap,&x) ){\n<line219>if( (prev&0xffff)>=(x>>16) ){\n<line220>checkAppendMsg(pCheck,\n<line221>"Multiple uses for byte %u of page %u", x>>16, iPage);\n<line222>break;\n<line223>}else{\n<line224>nFrag += (x>>16) - (prev&0xffff) - 1;\n<line225>prev = x;\n<line226>}\n<line227>}\n<line228>nFrag += usableSize - (prev&0xffff) - 1;\n<line229>/* EVIDENCE-OF: R-43263-13491 The total number of bytes in all fragments\n<line230>** is stored in the fifth field of the b-tree page header.\n<line231>** EVIDENCE-OF: R-07161-27322 The one-byte integer at offset 7 gives the\n<line232>** number of fragmented free bytes within the cell content area.\n<line233>*/\n<line234>if( heap[0]==0 && nFrag!=data[hdr+7] ){\n<line235>checkAppendMsg(pCheck,\n<line236>"Fragmentation of %u bytes reported as %u on page %u",\n<line237>nFrag, data[hdr+7], iPage);\n<line238>}\n<line239>}\n<line240>end_of_check:\n<line241>if( !doCoverageCheck ) pPage->isInit = savedIsInit;\n<line242>releasePage(pPage);\n<line243>pCheck->zPfx = saved_zPfx;\n<line244>pCheck->v1 = saved_v1;\n<line245>pCheck->v2 = saved_v2;\n<line246>return depth+1;\n<line247>}
----------------------------------------
Function: findBtree
Content: <line0>static Btree *findBtree(sqlite3 *pErrorDb, sqlite3 *pDb, const char *zDb){\n<line1>int i = sqlite3FindDbName(pDb, zDb);\n<line2>if( i==1 ){\n<line3>Parse sParse;\n<line4>int rc = 0;\n<line5>sqlite3ParseObjectInit(&sParse,pDb);\n<line6>if( sqlite3OpenTempDatabase(&sParse) ){\n<line7>sqlite3ErrorWithMsg(pErrorDb, sParse.rc, "%s", sParse.zErrMsg);\n<line8>rc = SQLITE_ERROR;\n<line9>}\n<line10>sqlite3DbFree(pErrorDb, sParse.zErrMsg);\n<line11>sqlite3ParseObjectReset(&sParse);\n<line12>if( rc ){\n<line13>return 0;\n<line14>}\n<line15>}\n<line16>if( i<0 ){\n<line17>sqlite3ErrorWithMsg(pErrorDb, SQLITE_ERROR, "unknown database %s", zDb);\n<line18>return 0;\n<line19>}\n<line20>return pDb->aDb[i].pBt;\n<line21>}
----------------------------------------
Function: setDestPgsz
Content: <line0>static int setDestPgsz(sqlite3_backup *p){\n<line1>int rc;\n<line2>rc = sqlite3BtreeSetPageSize(p->pDest,sqlite3BtreeGetPageSize(p->pSrc),0,0);\n<line3>return rc;\n<line4>}
----------------------------------------
Function: checkReadTransaction
Content: <line0>static int checkReadTransaction(sqlite3 *db, Btree *p){\n<line1>if( sqlite3BtreeTxnState(p)!=SQLITE_TXN_NONE ){\n<line2>sqlite3ErrorWithMsg(db, SQLITE_ERROR, "destination database is in use");\n<line3>return SQLITE_ERROR;\n<line4>}\n<line5>return SQLITE_OK;\n<line6>}
----------------------------------------
Function: sqlite3_backup_init
Content: <line0>SQLITE_API sqlite3_backup *sqlite3_backup_init(\n<line1>sqlite3* pDestDb,                     /* Database to write to */\n<line2>const char *zDestDb,                  /* Name of database within pDestDb */\n<line3>sqlite3* pSrcDb,                      /* Database connection to read from */\n<line4>const char *zSrcDb                    /* Name of database within pSrcDb */\n<line5>){\n<line6>sqlite3_backup *p;                    /* Value to return */\n<line7>#ifdef SQLITE_ENABLE_API_ARMOR\n<line8>if( !sqlite3SafetyCheckOk(pSrcDb)||!sqlite3SafetyCheckOk(pDestDb) ){\n<line9>(void)SQLITE_MISUSE_BKPT;\n<line10>return 0;\n<line11>}\n<line12>#endif\n<line13>/* Lock the source database handle. The destination database\n<line14>** handle is not locked in this routine, but it is locked in\n<line15>** sqlite3_backup_step(). The user is required to ensure that no\n<line16>** other thread accesses the destination handle for the duration\n<line17>** of the backup operation.  Any attempt to use the destination\n<line18>** database connection while a backup is in progress may cause\n<line19>** a malfunction or a deadlock.\n<line20>*/\n<line21>sqlite3_mutex_enter(pSrcDb->mutex);\n<line22>sqlite3_mutex_enter(pDestDb->mutex);\n<line23>if( pSrcDb==pDestDb ){\n<line24>sqlite3ErrorWithMsg(\n<line25>pDestDb, SQLITE_ERROR, "source and destination must be distinct"\n<line26>);\n<line27>p = 0;\n<line28>}else {\n<line29>/* Allocate space for a new sqlite3_backup object...\n<line30>** EVIDENCE-OF: R-64852-21591 The sqlite3_backup object is created by a\n<line31>** call to sqlite3_backup_init() and is destroyed by a call to\n<line32>** sqlite3_backup_finish(). */\n<line33>p = (sqlite3_backup *)sqlite3MallocZero(sizeof(sqlite3_backup));\n<line34>if( !p ){\n<line35>sqlite3Error(pDestDb, SQLITE_NOMEM_BKPT);\n<line36>}\n<line37>}\n<line38>/* If the allocation succeeded, populate the new object. */\n<line39>if( p ){\n<line40>p->pSrc = findBtree(pDestDb, pSrcDb, zSrcDb);\n<line41>p->pDest = findBtree(pDestDb, pDestDb, zDestDb);\n<line42>p->pDestDb = pDestDb;\n<line43>p->pSrcDb = pSrcDb;\n<line44>p->iNext = 1;\n<line45>p->isAttached = 0;\n<line46>if( 0==p->pSrc || 0==p->pDest\n<line47>|| checkReadTransaction(pDestDb, p->pDest)!=SQLITE_OK\n<line48>){\n<line49>/* One (or both) of the named databases did not exist or an OOM\n<line50>** error was hit. Or there is a transaction open on the destination\n<line51>** database. The error has already been written into the pDestDb\n<line52>** handle. All that is left to do here is free the sqlite3_backup\n<line53>** structure.  */\n<line54>sqlite3_free(p);\n<line55>p = 0;\n<line56>}\n<line57>}\n<line58>if( p ){\n<line59>p->pSrc->nBackup++;\n<line60>}\n<line61>sqlite3_mutex_leave(pDestDb->mutex);\n<line62>sqlite3_mutex_leave(pSrcDb->mutex);\n<line63>return p;\n<line64>}
----------------------------------------
Function: isFatalError
Content: <line0>static int isFatalError(int rc){\n<line1>return (rc!=SQLITE_OK && rc!=SQLITE_BUSY && ALWAYS(rc!=SQLITE_LOCKED));\n<line2>}
----------------------------------------
Function: backupOnePage
Content: <line0>static int backupOnePage(\n<line1>sqlite3_backup *p,              /* Backup handle */\n<line2>Pgno iSrcPg,                    /* Source database page to backup */\n<line3>const u8 *zSrcData,             /* Source database page data */\n<line4>int bUpdate                     /* True for an update, false otherwise */\n<line5>){\n<line6>Pager * const pDestPager = sqlite3BtreePager(p->pDest);\n<line7>const int nSrcPgsz = sqlite3BtreeGetPageSize(p->pSrc);\n<line8>int nDestPgsz = sqlite3BtreeGetPageSize(p->pDest);\n<line9>const int nCopy = MIN(nSrcPgsz, nDestPgsz);\n<line10>const i64 iEnd = (i64)iSrcPg*(i64)nSrcPgsz;\n<line11>int rc = SQLITE_OK;\n<line12>i64 iOff;\n<line13>assert( sqlite3BtreeGetReserveNoMutex(p->pSrc)>=0 );\n<line14>assert( p->bDestLocked );\n<line15>assert( !isFatalError(p->rc) );\n<line16>assert( iSrcPg!=PENDING_BYTE_PAGE(p->pSrc->pBt) );\n<line17>assert( zSrcData );\n<line18>assert( nSrcPgsz==nDestPgsz || sqlite3PagerIsMemdb(pDestPager)==0 );\n<line19>/* This loop runs once for each destination page spanned by the source\n<line20>** page. For each iteration, variable iOff is set to the byte offset\n<line21>** of the destination page.\n<line22>*/\n<line23>for(iOff=iEnd-(i64)nSrcPgsz; rc==SQLITE_OK && iOff<iEnd; iOff+=nDestPgsz){\n<line24>DbPage *pDestPg = 0;\n<line25>Pgno iDest = (Pgno)(iOff/nDestPgsz)+1;\n<line26>if( iDest==PENDING_BYTE_PAGE(p->pDest->pBt) ) continue;\n<line27>if( SQLITE_OK==(rc = sqlite3PagerGet(pDestPager, iDest, &pDestPg, 0))\n<line28>&& SQLITE_OK==(rc = sqlite3PagerWrite(pDestPg))\n<line29>){\n<line30>const u8 *zIn = &zSrcData[iOff%nSrcPgsz];\n<line31>u8 *zDestData = sqlite3PagerGetData(pDestPg);\n<line32>u8 *zOut = &zDestData[iOff%nDestPgsz];\n<line33>/* Copy the data from the source page into the destination page.\n<line34>** Then clear the Btree layer MemPage.isInit flag. Both this module\n<line35>** and the pager code use this trick (clearing the first byte\n<line36>** of the page 'extra' space to invalidate the Btree layers\n<line37>** cached parse of the page). MemPage.isInit is marked\n<line38>** "MUST BE FIRST" for this purpose.\n<line39>*/\n<line40>memcpy(zOut, zIn, nCopy);\n<line41>((u8 *)sqlite3PagerGetExtra(pDestPg))[0] = 0;\n<line42>if( iOff==0 && bUpdate==0 ){\n<line43>sqlite3Put4byte(&zOut[28], sqlite3BtreeLastPage(p->pSrc));\n<line44>}\n<line45>}\n<line46>sqlite3PagerUnref(pDestPg);\n<line47>}\n<line48>return rc;\n<line49>}
----------------------------------------
Function: backupTruncateFile
Content: <line0>static int backupTruncateFile(sqlite3_file *pFile, i64 iSize){\n<line1>i64 iCurrent;\n<line2>int rc = sqlite3OsFileSize(pFile, &iCurrent);\n<line3>if( rc==SQLITE_OK && iCurrent>iSize ){\n<line4>rc = sqlite3OsTruncate(pFile, iSize);\n<line5>}\n<line6>return rc;\n<line7>}
----------------------------------------
Function: attachBackupObject
Content: <line0>static void attachBackupObject(sqlite3_backup *p){\n<line1>sqlite3_backup **pp;\n<line2>assert( sqlite3BtreeHoldsMutex(p->pSrc) );\n<line3>pp = sqlite3PagerBackupPtr(sqlite3BtreePager(p->pSrc));\n<line4>p->pNext = *pp;\n<line5>*pp = p;\n<line6>p->isAttached = 1;\n<line7>}
----------------------------------------
Function: sqlite3_backup_step
Content: <line0>SQLITE_API int sqlite3_backup_step(sqlite3_backup *p, int nPage){\n<line1>int rc;\n<line2>int destMode;       /* Destination journal mode */\n<line3>int pgszSrc = 0;    /* Source page size */\n<line4>int pgszDest = 0;   /* Destination page size */\n<line5>#ifdef SQLITE_ENABLE_API_ARMOR\n<line6>if( p==0 ) return SQLITE_MISUSE_BKPT;\n<line7>#endif\n<line8>sqlite3_mutex_enter(p->pSrcDb->mutex);\n<line9>sqlite3BtreeEnter(p->pSrc);\n<line10>if( p->pDestDb ){\n<line11>sqlite3_mutex_enter(p->pDestDb->mutex);\n<line12>}\n<line13>rc = p->rc;\n<line14>if( !isFatalError(rc) ){\n<line15>Pager * const pSrcPager = sqlite3BtreePager(p->pSrc);     /* Source pager */\n<line16>Pager * const pDestPager = sqlite3BtreePager(p->pDest);   /* Dest pager */\n<line17>int ii;                            /* Iterator variable */\n<line18>int nSrcPage = -1;                 /* Size of source db in pages */\n<line19>int bCloseTrans = 0;               /* True if src db requires unlocking */\n<line20>/* If the source pager is currently in a write-transaction, return\n<line21>** SQLITE_BUSY immediately.\n<line22>*/\n<line23>if( p->pDestDb && p->pSrc->pBt->inTransaction==TRANS_WRITE ){\n<line24>rc = SQLITE_BUSY;\n<line25>}else{\n<line26>rc = SQLITE_OK;\n<line27>}\n<line28>/* If there is no open read-transaction on the source database, open\n<line29>** one now. If a transaction is opened here, then it will be closed\n<line30>** before this function exits.\n<line31>*/\n<line32>if( rc==SQLITE_OK && SQLITE_TXN_NONE==sqlite3BtreeTxnState(p->pSrc) ){\n<line33>rc = sqlite3BtreeBeginTrans(p->pSrc, 0, 0);\n<line34>bCloseTrans = 1;\n<line35>}\n<line36>/* If the destination database has not yet been locked (i.e. if this\n<line37>** is the first call to backup_step() for the current backup operation),\n<line38>** try to set its page size to the same as the source database. This\n<line39>** is especially important on ZipVFS systems, as in that case it is\n<line40>** not possible to create a database file that uses one page size by\n<line41>** writing to it with another.  */\n<line42>if( p->bDestLocked==0 && rc==SQLITE_OK && setDestPgsz(p)==SQLITE_NOMEM ){\n<line43>rc = SQLITE_NOMEM;\n<line44>}\n<line45>/* Lock the destination database, if it is not locked already. */\n<line46>if( SQLITE_OK==rc && p->bDestLocked==0\n<line47>&& SQLITE_OK==(rc = sqlite3BtreeBeginTrans(p->pDest, 2,\n<line48>(int*)&p->iDestSchema))\n<line49>){\n<line50>p->bDestLocked = 1;\n<line51>}\n<line52>/* Do not allow backup if the destination database is in WAL mode\n<line53>** and the page sizes are different between source and destination */\n<line54>pgszSrc = sqlite3BtreeGetPageSize(p->pSrc);\n<line55>pgszDest = sqlite3BtreeGetPageSize(p->pDest);\n<line56>destMode = sqlite3PagerGetJournalMode(sqlite3BtreePager(p->pDest));\n<line57>if( SQLITE_OK==rc\n<line58>&& (destMode==PAGER_JOURNALMODE_WAL || sqlite3PagerIsMemdb(pDestPager))\n<line59>&& pgszSrc!=pgszDest\n<line60>){\n<line61>rc = SQLITE_READONLY;\n<line62>}\n<line63>/* Now that there is a read-lock on the source database, query the\n<line64>** source pager for the number of pages in the database.\n<line65>*/\n<line66>nSrcPage = (int)sqlite3BtreeLastPage(p->pSrc);\n<line67>assert( nSrcPage>=0 );\n<line68>for(ii=0; (nPage<0 || ii<nPage) && p->iNext<=(Pgno)nSrcPage && !rc; ii++){\n<line69>const Pgno iSrcPg = p->iNext;                 /* Source page number */\n<line70>if( iSrcPg!=PENDING_BYTE_PAGE(p->pSrc->pBt) ){\n<line71>DbPage *pSrcPg;                             /* Source page object */\n<line72>rc = sqlite3PagerGet(pSrcPager, iSrcPg, &pSrcPg,PAGER_GET_READONLY);\n<line73>if( rc==SQLITE_OK ){\n<line74>rc = backupOnePage(p, iSrcPg, sqlite3PagerGetData(pSrcPg), 0);\n<line75>sqlite3PagerUnref(pSrcPg);\n<line76>}\n<line77>}\n<line78>p->iNext++;\n<line79>}\n<line80>if( rc==SQLITE_OK ){\n<line81>p->nPagecount = nSrcPage;\n<line82>p->nRemaining = nSrcPage+1-p->iNext;\n<line83>if( p->iNext>(Pgno)nSrcPage ){\n<line84>rc = SQLITE_DONE;\n<line85>}else if( !p->isAttached ){\n<line86>attachBackupObject(p);\n<line87>}\n<line88>}\n<line89>/* Update the schema version field in the destination database. This\n<line90>** is to make sure that the schema-version really does change in\n<line91>** the case where the source and destination databases have the\n<line92>** same schema version.\n<line93>*/\n<line94>if( rc==SQLITE_DONE ){\n<line95>if( nSrcPage==0 ){\n<line96>rc = sqlite3BtreeNewDb(p->pDest);\n<line97>nSrcPage = 1;\n<line98>}\n<line99>if( rc==SQLITE_OK || rc==SQLITE_DONE ){\n<line100>rc = sqlite3BtreeUpdateMeta(p->pDest,1,p->iDestSchema+1);\n<line101>}\n<line102>if( rc==SQLITE_OK ){\n<line103>if( p->pDestDb ){\n<line104>sqlite3ResetAllSchemasOfConnection(p->pDestDb);\n<line105>}\n<line106>if( destMode==PAGER_JOURNALMODE_WAL ){\n<line107>rc = sqlite3BtreeSetVersion(p->pDest, 2);\n<line108>}\n<line109>}\n<line110>if( rc==SQLITE_OK ){\n<line111>int nDestTruncate;\n<line112>/* Set nDestTruncate to the final number of pages in the destination\n<line113>** database. The complication here is that the destination page\n<line114>** size may be different to the source page size.\n<line115>**\n<line116>** If the source page size is smaller than the destination page size,\n<line117>** round up. In this case the call to sqlite3OsTruncate() below will\n<line118>** fix the size of the file. However it is important to call\n<line119>** sqlite3PagerTruncateImage() here so that any pages in the\n<line120>** destination file that lie beyond the nDestTruncate page mark are\n<line121>** journalled by PagerCommitPhaseOne() before they are destroyed\n<line122>** by the file truncation.\n<line123>*/\n<line124>assert( pgszSrc==sqlite3BtreeGetPageSize(p->pSrc) );\n<line125>assert( pgszDest==sqlite3BtreeGetPageSize(p->pDest) );\n<line126>if( pgszSrc<pgszDest ){\n<line127>int ratio = pgszDest/pgszSrc;\n<line128>nDestTruncate = (nSrcPage+ratio-1)/ratio;\n<line129>if( nDestTruncate==(int)PENDING_BYTE_PAGE(p->pDest->pBt) ){\n<line130>nDestTruncate--;\n<line131>}\n<line132>}else{\n<line133>nDestTruncate = nSrcPage * (pgszSrc/pgszDest);\n<line134>}\n<line135>assert( nDestTruncate>0 );\n<line136>if( pgszSrc<pgszDest ){\n<line137>/* If the source page-size is smaller than the destination page-size,\n<line138>** two extra things may need to happen:\n<line139>**\n<line140>**   * The destination may need to be truncated, and\n<line141>**\n<line142>**   * Data stored on the pages immediately following the\n<line143>**     pending-byte page in the source database may need to be\n<line144>**     copied into the destination database.\n<line145>*/\n<line146>const i64 iSize = (i64)pgszSrc * (i64)nSrcPage;\n<line147>sqlite3_file * const pFile = sqlite3PagerFile(pDestPager);\n<line148>Pgno iPg;\n<line149>int nDstPage;\n<line150>i64 iOff;\n<line151>i64 iEnd;\n<line152>assert( pFile );\n<line153>assert( nDestTruncate==0\n<line154>|| (i64)nDestTruncate*(i64)pgszDest >= iSize || (\n<line155>nDestTruncate==(int)(PENDING_BYTE_PAGE(p->pDest->pBt)-1)\n<line156>&& iSize>=PENDING_BYTE && iSize<=PENDING_BYTE+pgszDest\n<line157>));\n<line158>/* This block ensures that all data required to recreate the original\n<line159>** database has been stored in the journal for pDestPager and the\n<line160>** journal synced to disk. So at this point we may safely modify\n<line161>** the database file in any way, knowing that if a power failure\n<line162>** occurs, the original database will be reconstructed from the\n<line163>** journal file.  */\n<line164>sqlite3PagerPagecount(pDestPager, &nDstPage);\n<line165>for(iPg=nDestTruncate; rc==SQLITE_OK && iPg<=(Pgno)nDstPage; iPg++){\n<line166>if( iPg!=PENDING_BYTE_PAGE(p->pDest->pBt) ){\n<line167>DbPage *pPg;\n<line168>rc = sqlite3PagerGet(pDestPager, iPg, &pPg, 0);\n<line169>if( rc==SQLITE_OK ){\n<line170>rc = sqlite3PagerWrite(pPg);\n<line171>sqlite3PagerUnref(pPg);\n<line172>}\n<line173>}\n<line174>}\n<line175>if( rc==SQLITE_OK ){\n<line176>rc = sqlite3PagerCommitPhaseOne(pDestPager, 0, 1);\n<line177>}\n<line178>/* Write the extra pages and truncate the database file as required */\n<line179>iEnd = MIN(PENDING_BYTE + pgszDest, iSize);\n<line180>for(\n<line181>iOff=PENDING_BYTE+pgszSrc;\n<line182>rc==SQLITE_OK && iOff<iEnd;\n<line183>iOff+=pgszSrc\n<line184>){\n<line185>PgHdr *pSrcPg = 0;\n<line186>const Pgno iSrcPg = (Pgno)((iOff/pgszSrc)+1);\n<line187>rc = sqlite3PagerGet(pSrcPager, iSrcPg, &pSrcPg, 0);\n<line188>if( rc==SQLITE_OK ){\n<line189>u8 *zData = sqlite3PagerGetData(pSrcPg);\n<line190>rc = sqlite3OsWrite(pFile, zData, pgszSrc, iOff);\n<line191>}\n<line192>sqlite3PagerUnref(pSrcPg);\n<line193>}\n<line194>if( rc==SQLITE_OK ){\n<line195>rc = backupTruncateFile(pFile, iSize);\n<line196>}\n<line197>/* Sync the database file to disk. */\n<line198>if( rc==SQLITE_OK ){\n<line199>rc = sqlite3PagerSync(pDestPager, 0);\n<line200>}\n<line201>}else{\n<line202>sqlite3PagerTruncateImage(pDestPager, nDestTruncate);\n<line203>rc = sqlite3PagerCommitPhaseOne(pDestPager, 0, 0);\n<line204>}\n<line205>/* Finish committing the transaction to the destination database. */\n<line206>if( SQLITE_OK==rc\n<line207>&& SQLITE_OK==(rc = sqlite3BtreeCommitPhaseTwo(p->pDest, 0))\n<line208>){\n<line209>rc = SQLITE_DONE;\n<line210>}\n<line211>}\n<line212>}\n<line213>/* If bCloseTrans is true, then this function opened a read transaction\n<line214>** on the source database. Close the read transaction here. There is\n<line215>** no need to check the return values of the btree methods here, as\n<line216>** "committing" a read-only transaction cannot fail.\n<line217>*/\n<line218>if( bCloseTrans ){\n<line219>TESTONLY( int rc2 );\n<line220>TESTONLY( rc2  = ) sqlite3BtreeCommitPhaseOne(p->pSrc, 0);\n<line221>TESTONLY( rc2 |= ) sqlite3BtreeCommitPhaseTwo(p->pSrc, 0);\n<line222>assert( rc2==SQLITE_OK );\n<line223>}\n<line224>if( rc==SQLITE_IOERR_NOMEM ){\n<line225>rc = SQLITE_NOMEM_BKPT;\n<line226>}\n<line227>p->rc = rc;\n<line228>}\n<line229>if( p->pDestDb ){\n<line230>sqlite3_mutex_leave(p->pDestDb->mutex);\n<line231>}\n<line232>sqlite3BtreeLeave(p->pSrc);\n<line233>sqlite3_mutex_leave(p->pSrcDb->mutex);\n<line234>return rc;\n<line235>}
----------------------------------------
Function: sqlite3_backup_finish
Content: <line0>SQLITE_API int sqlite3_backup_finish(sqlite3_backup *p){\n<line1>sqlite3_backup **pp;                 /* Ptr to head of pagers backup list */\n<line2>sqlite3 *pSrcDb;                     /* Source database connection */\n<line3>int rc;                              /* Value to return */\n<line4>/* Enter the mutexes */\n<line5>if( p==0 ) return SQLITE_OK;\n<line6>pSrcDb = p->pSrcDb;\n<line7>sqlite3_mutex_enter(pSrcDb->mutex);\n<line8>sqlite3BtreeEnter(p->pSrc);\n<line9>if( p->pDestDb ){\n<line10>sqlite3_mutex_enter(p->pDestDb->mutex);\n<line11>}\n<line12>/* Detach this backup from the source pager. */\n<line13>if( p->pDestDb ){\n<line14>p->pSrc->nBackup--;\n<line15>}\n<line16>if( p->isAttached ){\n<line17>pp = sqlite3PagerBackupPtr(sqlite3BtreePager(p->pSrc));\n<line18>assert( pp!=0 );\n<line19>while( *pp!=p ){\n<line20>pp = &(*pp)->pNext;\n<line21>assert( pp!=0 );\n<line22>}\n<line23>*pp = p->pNext;\n<line24>}\n<line25>/* If a transaction is still open on the Btree, roll it back. */\n<line26>sqlite3BtreeRollback(p->pDest, SQLITE_OK, 0);\n<line27>/* Set the error code of the destination database handle. */\n<line28>rc = (p->rc==SQLITE_DONE) ? SQLITE_OK : p->rc;\n<line29>if( p->pDestDb ){\n<line30>sqlite3Error(p->pDestDb, rc);\n<line31>/* Exit the mutexes and free the backup context structure. */\n<line32>sqlite3LeaveMutexAndCloseZombie(p->pDestDb);\n<line33>}\n<line34>sqlite3BtreeLeave(p->pSrc);\n<line35>if( p->pDestDb ){\n<line36>/* EVIDENCE-OF: R-64852-21591 The sqlite3_backup object is created by a\n<line37>** call to sqlite3_backup_init() and is destroyed by a call to\n<line38>** sqlite3_backup_finish(). */\n<line39>sqlite3_free(p);\n<line40>}\n<line41>sqlite3LeaveMutexAndCloseZombie(pSrcDb);\n<line42>return rc;\n<line43>}
----------------------------------------
Function: sqlite3_backup_remaining
Content: <line0>SQLITE_API int sqlite3_backup_remaining(sqlite3_backup *p){\n<line1>#ifdef SQLITE_ENABLE_API_ARMOR\n<line2>if( p==0 ){\n<line3>(void)SQLITE_MISUSE_BKPT;\n<line4>return 0;\n<line5>}\n<line6>#endif\n<line7>return p->nRemaining;\n<line8>}
----------------------------------------
Function: sqlite3_backup_pagecount
Content: <line0>SQLITE_API int sqlite3_backup_pagecount(sqlite3_backup *p){\n<line1>#ifdef SQLITE_ENABLE_API_ARMOR\n<line2>if( p==0 ){\n<line3>(void)SQLITE_MISUSE_BKPT;\n<line4>return 0;\n<line5>}\n<line6>#endif\n<line7>return p->nPagecount;\n<line8>}
----------------------------------------
Function: backupUpdate
Content: <line0>static SQLITE_NOINLINE void backupUpdate(\n<line1>sqlite3_backup *p,\n<line2>Pgno iPage,\n<line3>const u8 *aData\n<line4>){\n<line5>assert( p!=0 );\n<line6>do{\n<line7>assert( sqlite3_mutex_held(p->pSrc->pBt->mutex) );\n<line8>if( !isFatalError(p->rc) && iPage<p->iNext ){\n<line9>/* The backup process p has already copied page iPage. But now it\n<line10>** has been modified by a transaction on the source pager. Copy\n<line11>** the new data into the backup.\n<line12>*/\n<line13>int rc;\n<line14>assert( p->pDestDb );\n<line15>sqlite3_mutex_enter(p->pDestDb->mutex);\n<line16>rc = backupOnePage(p, iPage, aData, 1);\n<line17>sqlite3_mutex_leave(p->pDestDb->mutex);\n<line18>assert( rc!=SQLITE_BUSY && rc!=SQLITE_LOCKED );\n<line19>if( rc!=SQLITE_OK ){\n<line20>p->rc = rc;\n<line21>}\n<line22>}\n<line23>}while( (p = p->pNext)!=0 );\n<line24>}
----------------------------------------
Function: vdbeMemRenderNum
Content: <line0>static void vdbeMemRenderNum(int sz, char *zBuf, Mem *p){\n<line1>StrAccum acc;\n<line2>assert( p->flags & (MEM_Int|MEM_Real|MEM_IntReal) );\n<line3>assert( sz>22 );\n<line4>if( p->flags & MEM_Int ){\n<line5>#if GCC_VERSION>=7000000\n<line6>/* Work-around for GCC bug\n<line7>** https://gcc.gnu.org/bugzilla/show_bug.cgi?id=96270 */\n<line8>i64 x;\n<line9>assert( (p->flags&MEM_Int)*2==sizeof(x) );\n<line10>memcpy(&x, (char*)&p->u, (p->flags&MEM_Int)*2);\n<line11>p->n = sqlite3Int64ToText(x, zBuf);\n<line12>#else\n<line13>p->n = sqlite3Int64ToText(p->u.i, zBuf);\n<line14>#endif\n<line15>}else{\n<line16>sqlite3StrAccumInit(&acc, 0, zBuf, sz, 0);\n<line17>sqlite3_str_appendf(&acc, "%!.15g",\n<line18>(p->flags & MEM_IntReal)!=0 ? (double)p->u.i : p->u.r);\n<line19>assert( acc.zText==zBuf && acc.mxAlloc<=0 );\n<line20>zBuf[acc.nChar] = 0; /* Fast version of sqlite3StrAccumFinish(&acc) */\n<line21>p->n = acc.nChar;\n<line22>}\n<line23>}
----------------------------------------
Function: vdbeMemAddTerminator
Content: <line0>static SQLITE_NOINLINE int vdbeMemAddTerminator(Mem *pMem){\n<line1>if( sqlite3VdbeMemGrow(pMem, pMem->n+3, 1) ){\n<line2>return SQLITE_NOMEM_BKPT;\n<line3>}\n<line4>pMem->z[pMem->n] = 0;\n<line5>pMem->z[pMem->n+1] = 0;\n<line6>pMem->z[pMem->n+2] = 0;\n<line7>pMem->flags |= MEM_Term;\n<line8>return SQLITE_OK;\n<line9>}
----------------------------------------
Function: vdbeMemClearExternAndSetNull
Content: <line0>static SQLITE_NOINLINE void vdbeMemClearExternAndSetNull(Mem *p){\n<line1>assert( p->db==0 || sqlite3_mutex_held(p->db->mutex) );\n<line2>assert( VdbeMemDynamic(p) );\n<line3>if( p->flags&MEM_Agg ){\n<line4>sqlite3VdbeMemFinalize(p, p->u.pDef);\n<line5>assert( (p->flags & MEM_Agg)==0 );\n<line6>testcase( p->flags & MEM_Dyn );\n<line7>}\n<line8>if( p->flags&MEM_Dyn ){\n<line9>assert( p->xDel!=SQLITE_DYNAMIC && p->xDel!=0 );\n<line10>p->xDel((void *)p->z);\n<line11>}\n<line12>p->flags = MEM_Null;\n<line13>}
----------------------------------------
Function: vdbeMemClear
Content: <line0>static SQLITE_NOINLINE void vdbeMemClear(Mem *p){\n<line1>if( VdbeMemDynamic(p) ){\n<line2>vdbeMemClearExternAndSetNull(p);\n<line3>}\n<line4>if( p->szMalloc ){\n<line5>sqlite3DbFreeNN(p->db, p->zMalloc);\n<line6>p->szMalloc = 0;\n<line7>}\n<line8>p->z = 0;\n<line9>}
----------------------------------------
Function: memIntValue
Content: <line0>static SQLITE_NOINLINE i64 memIntValue(const Mem *pMem){\n<line1>i64 value = 0;\n<line2>sqlite3Atoi64(pMem->z, &value, pMem->n, pMem->enc);\n<line3>return value;\n<line4>}
----------------------------------------
Function: memRealValue
Content: <line0>static SQLITE_NOINLINE double memRealValue(Mem *pMem){\n<line1>/* (double)0 In case of SQLITE_OMIT_FLOATING_POINT... */\n<line2>double val = (double)0;\n<line3>sqlite3AtoF(pMem->z, &val, pMem->n, pMem->enc);\n<line4>return val;\n<line5>}
----------------------------------------
Function: vdbeReleaseAndSetInt64
Content: <line0>static SQLITE_NOINLINE void vdbeReleaseAndSetInt64(Mem *pMem, i64 val){\n<line1>sqlite3VdbeMemSetNull(pMem);\n<line2>pMem->u.i = val;\n<line3>pMem->flags = MEM_Int;\n<line4>}
----------------------------------------
Function: vdbeClrCopy
Content: <line0>static SQLITE_NOINLINE void vdbeClrCopy(Mem *pTo, const Mem *pFrom, int eType){\n<line1>vdbeMemClearExternAndSetNull(pTo);\n<line2>assert( !VdbeMemDynamic(pTo) );\n<line3>sqlite3VdbeMemShallowCopy(pTo, pFrom, eType);\n<line4>}
----------------------------------------
Function: valueToText
Content: <line0>static SQLITE_NOINLINE const void *valueToText(sqlite3_value* pVal, u8 enc){\n<line1>assert( pVal!=0 );\n<line2>assert( pVal->db==0 || sqlite3_mutex_held(pVal->db->mutex) );\n<line3>assert( (enc&3)==(enc&~SQLITE_UTF16_ALIGNED) );\n<line4>assert( !sqlite3VdbeMemIsRowSet(pVal) );\n<line5>assert( (pVal->flags & (MEM_Null))==0 );\n<line6>if( pVal->flags & (MEM_Blob|MEM_Str) ){\n<line7>if( ExpandBlob(pVal) ) return 0;\n<line8>pVal->flags |= MEM_Str;\n<line9>if( pVal->enc != (enc & ~SQLITE_UTF16_ALIGNED) ){\n<line10>sqlite3VdbeChangeEncoding(pVal, enc & ~SQLITE_UTF16_ALIGNED);\n<line11>}\n<line12>if( (enc & SQLITE_UTF16_ALIGNED)!=0 && 1==(1&SQLITE_PTR_TO_INT(pVal->z)) ){\n<line13>assert( (pVal->flags & (MEM_Ephem|MEM_Static))!=0 );\n<line14>if( sqlite3VdbeMemMakeWriteable(pVal)!=SQLITE_OK ){\n<line15>return 0;\n<line16>}\n<line17>}\n<line18>sqlite3VdbeMemNulTerminate(pVal); /* IMP: R-31275-44060 */\n<line19>}else{\n<line20>sqlite3VdbeMemStringify(pVal, enc, 0);\n<line21>assert( 0==(1&SQLITE_PTR_TO_INT(pVal->z)) );\n<line22>}\n<line23>assert(pVal->enc==(enc & ~SQLITE_UTF16_ALIGNED) || pVal->db==0\n<line24>|| pVal->db->mallocFailed );\n<line25>if( pVal->enc==(enc & ~SQLITE_UTF16_ALIGNED) ){\n<line26>assert( sqlite3VdbeMemValidStrRep(pVal) );\n<line27>return pVal->z;\n<line28>}else{\n<line29>return 0;\n<line30>}\n<line31>}
----------------------------------------
Function: valueNew
Content: <line0>static sqlite3_value *valueNew(sqlite3 *db, struct ValueNewStat4Ctx *p){\n<line1>#ifdef SQLITE_ENABLE_STAT4\n<line2>if( p ){\n<line3>UnpackedRecord *pRec = p->ppRec[0];\n<line4>if( pRec==0 ){\n<line5>Index *pIdx = p->pIdx;      /* Index being probed */\n<line6>i64 nByte;                  /* Bytes of space to allocate */\n<line7>int i;                      /* Counter variable */\n<line8>int nCol = pIdx->nColumn;   /* Number of index columns including rowid */\n<line9>nByte = sizeof(Mem) * nCol + ROUND8(sizeof(UnpackedRecord));\n<line10>pRec = (UnpackedRecord*)sqlite3DbMallocZero(db, nByte);\n<line11>if( pRec ){\n<line12>pRec->pKeyInfo = sqlite3KeyInfoOfIndex(p->pParse, pIdx);\n<line13>if( pRec->pKeyInfo ){\n<line14>assert( pRec->pKeyInfo->nAllField==nCol );\n<line15>assert( pRec->pKeyInfo->enc==ENC(db) );\n<line16>pRec->aMem = (Mem *)((u8*)pRec + ROUND8(sizeof(UnpackedRecord)));\n<line17>for(i=0; i<nCol; i++){\n<line18>pRec->aMem[i].flags = MEM_Null;\n<line19>pRec->aMem[i].db = db;\n<line20>}\n<line21>}else{\n<line22>sqlite3DbFreeNN(db, pRec);\n<line23>pRec = 0;\n<line24>}\n<line25>}\n<line26>if( pRec==0 ) return 0;\n<line27>p->ppRec[0] = pRec;\n<line28>}\n<line29>pRec->nField = p->iVal+1;\n<line30>sqlite3VdbeMemSetNull(&pRec->aMem[p->iVal]);\n<line31>return &pRec->aMem[p->iVal];\n<line32>}\n<line33>#else\n<line34>UNUSED_PARAMETER(p);\n<line35>#endif /* defined(SQLITE_ENABLE_STAT4) */\n<line36>return sqlite3ValueNew(db);\n<line37>}
----------------------------------------
Function: valueFromExpr
Content: <line0>static int valueFromExpr(\n<line1>sqlite3 *db,                    /* The database connection */\n<line2>const Expr *pExpr,              /* The expression to evaluate */\n<line3>u8 enc,                         /* Encoding to use */\n<line4>u8 affinity,                    /* Affinity to use */\n<line5>sqlite3_value **ppVal,          /* Write the new value here */\n<line6>struct ValueNewStat4Ctx *pCtx   /* Second argument for valueNew() */\n<line7>){\n<line8>int op;\n<line9>char *zVal = 0;\n<line10>sqlite3_value *pVal = 0;\n<line11>int negInt = 1;\n<line12>const char *zNeg = "";\n<line13>int rc = SQLITE_OK;\n<line14>assert( pExpr!=0 );\n<line15>while( (op = pExpr->op)==TK_UPLUS || op==TK_SPAN ) pExpr = pExpr->pLeft;\n<line16>if( op==TK_REGISTER ) op = pExpr->op2;\n<line17>/* Compressed expressions only appear when parsing the DEFAULT clause\n<line18>** on a table column definition, and hence only when pCtx==0.  This\n<line19>** check ensures that an EP_TokenOnly expression is never passed down\n<line20>** into valueFromFunction(). */\n<line21>assert( (pExpr->flags & EP_TokenOnly)==0 || pCtx==0 );\n<line22>if( op==TK_CAST ){\n<line23>u8 aff;\n<line24>assert( !ExprHasProperty(pExpr, EP_IntValue) );\n<line25>aff = sqlite3AffinityType(pExpr->u.zToken,0);\n<line26>rc = valueFromExpr(db, pExpr->pLeft, enc, aff, ppVal, pCtx);\n<line27>testcase( rc!=SQLITE_OK );\n<line28>if( *ppVal ){\n<line29>#ifdef SQLITE_ENABLE_STAT4\n<line30>rc = ExpandBlob(*ppVal);\n<line31>#else\n<line32>/* zero-blobs only come from functions, not literal values.  And\n<line33>** functions are only processed under STAT4 */\n<line34>assert( (ppVal[0][0].flags & MEM_Zero)==0 );\n<line35>#endif\n<line36>sqlite3VdbeMemCast(*ppVal, aff, enc);\n<line37>sqlite3ValueApplyAffinity(*ppVal, affinity, enc);\n<line38>}\n<line39>return rc;\n<line40>}\n<line41>/* Handle negative integers in a single step.  This is needed in the\n<line42>** case when the value is -9223372036854775808. Except - do not do this\n<line43>** for hexadecimal literals.  */\n<line44>if( op==TK_UMINUS ){\n<line45>Expr *pLeft = pExpr->pLeft;\n<line46>if( (pLeft->op==TK_INTEGER || pLeft->op==TK_FLOAT) ){\n<line47>if( ExprHasProperty(pLeft, EP_IntValue)\n<line48>|| pLeft->u.zToken[0]!='0' || (pLeft->u.zToken[1] & ~0x20)!='X'\n<line49>){\n<line50>pExpr = pLeft;\n<line51>op = pExpr->op;\n<line52>negInt = -1;\n<line53>zNeg = "-";\n<line54>}\n<line55>}\n<line56>}\n<line57>if( op==TK_STRING || op==TK_FLOAT || op==TK_INTEGER ){\n<line58>pVal = valueNew(db, pCtx);\n<line59>if( pVal==0 ) goto no_mem;\n<line60>if( ExprHasProperty(pExpr, EP_IntValue) ){\n<line61>sqlite3VdbeMemSetInt64(pVal, (i64)pExpr->u.iValue*negInt);\n<line62>}else{\n<line63>i64 iVal;\n<line64>if( op==TK_INTEGER && 0==sqlite3DecOrHexToI64(pExpr->u.zToken, &iVal) ){\n<line65>sqlite3VdbeMemSetInt64(pVal, iVal*negInt);\n<line66>}else{\n<line67>zVal = sqlite3MPrintf(db, "%s%s", zNeg, pExpr->u.zToken);\n<line68>if( zVal==0 ) goto no_mem;\n<line69>sqlite3ValueSetStr(pVal, -1, zVal, SQLITE_UTF8, SQLITE_DYNAMIC);\n<line70>}\n<line71>}\n<line72>if( affinity==SQLITE_AFF_BLOB ){\n<line73>if( op==TK_FLOAT ){\n<line74>assert( pVal && pVal->z && pVal->flags==(MEM_Str|MEM_Term) );\n<line75>sqlite3AtoF(pVal->z, &pVal->u.r, pVal->n, SQLITE_UTF8);\n<line76>pVal->flags = MEM_Real;\n<line77>}else if( op==TK_INTEGER ){\n<line78>/* This case is required by -9223372036854775808 and other strings\n<line79>** that look like integers but cannot be handled by the\n<line80>** sqlite3DecOrHexToI64() call above.  */\n<line81>sqlite3ValueApplyAffinity(pVal, SQLITE_AFF_NUMERIC, SQLITE_UTF8);\n<line82>}\n<line83>}else{\n<line84>sqlite3ValueApplyAffinity(pVal, affinity, SQLITE_UTF8);\n<line85>}\n<line86>assert( (pVal->flags & MEM_IntReal)==0 );\n<line87>if( pVal->flags & (MEM_Int|MEM_IntReal|MEM_Real) ){\n<line88>testcase( pVal->flags & MEM_Int );\n<line89>testcase( pVal->flags & MEM_Real );\n<line90>pVal->flags &= ~MEM_Str;\n<line91>}\n<line92>if( enc!=SQLITE_UTF8 ){\n<line93>rc = sqlite3VdbeChangeEncoding(pVal, enc);\n<line94>}\n<line95>}else if( op==TK_UMINUS ) {\n<line96>/* This branch happens for multiple negative signs.  Ex: -(-5) */\n<line97>if( SQLITE_OK==valueFromExpr(db,pExpr->pLeft,enc,affinity,&pVal,pCtx)\n<line98>&& pVal!=0\n<line99>){\n<line100>sqlite3VdbeMemNumerify(pVal);\n<line101>if( pVal->flags & MEM_Real ){\n<line102>pVal->u.r = -pVal->u.r;\n<line103>}else if( pVal->u.i==SMALLEST_INT64 ){\n<line104>#ifndef SQLITE_OMIT_FLOATING_POINT\n<line105>pVal->u.r = -(double)SMALLEST_INT64;\n<line106>#else\n<line107>pVal->u.r = LARGEST_INT64;\n<line108>#endif\n<line109>MemSetTypeFlag(pVal, MEM_Real);\n<line110>}else{\n<line111>pVal->u.i = -pVal->u.i;\n<line112>}\n<line113>sqlite3ValueApplyAffinity(pVal, affinity, enc);\n<line114>}\n<line115>}else if( op==TK_NULL ){\n<line116>pVal = valueNew(db, pCtx);\n<line117>if( pVal==0 ) goto no_mem;\n<line118>sqlite3VdbeMemSetNull(pVal);\n<line119>}\n<line120>#ifndef SQLITE_OMIT_BLOB_LITERAL\n<line121>else if( op==TK_BLOB ){\n<line122>int nVal;\n<line123>assert( !ExprHasProperty(pExpr, EP_IntValue) );\n<line124>assert( pExpr->u.zToken[0]=='x' || pExpr->u.zToken[0]=='X' );\n<line125>assert( pExpr->u.zToken[1]=='\'' );\n<line126>pVal = valueNew(db, pCtx);\n<line127>if( !pVal ) goto no_mem;\n<line128>zVal = &pExpr->u.zToken[2];\n<line129>nVal = sqlite3Strlen30(zVal)-1;\n<line130>assert( zVal[nVal]=='\'' );\n<line131>sqlite3VdbeMemSetStr(pVal, sqlite3HexToBlob(db, zVal, nVal), nVal/2,\n<line132>0, SQLITE_DYNAMIC);\n<line133>}\n<line134>#endif\n<line135>#ifdef SQLITE_ENABLE_STAT4\n<line136>else if( op==TK_FUNCTION && pCtx!=0 ){\n<line137>rc = valueFromFunction(db, pExpr, enc, affinity, &pVal, pCtx);\n<line138>}\n<line139>#endif\n<line140>else if( op==TK_TRUEFALSE ){\n<line141>assert( !ExprHasProperty(pExpr, EP_IntValue) );\n<line142>pVal = valueNew(db, pCtx);\n<line143>if( pVal ){\n<line144>pVal->flags = MEM_Int;\n<line145>pVal->u.i = pExpr->u.zToken[4]==0;\n<line146>sqlite3ValueApplyAffinity(pVal, affinity, enc);\n<line147>}\n<line148>}\n<line149>*ppVal = pVal;\n<line150>return rc;\n<line151>no_mem:\n<line152>#ifdef SQLITE_ENABLE_STAT4\n<line153>if( pCtx==0 || NEVER(pCtx->pParse->nErr==0) )\n<line154>#endif\n<line155>sqlite3OomFault(db);\n<line156>sqlite3DbFree(db, zVal);\n<line157>assert( *ppVal==0 );\n<line158>#ifdef SQLITE_ENABLE_STAT4\n<line159>if( pCtx==0 ) sqlite3ValueFree(pVal);\n<line160>#else\n<line161>assert( pCtx==0 ); sqlite3ValueFree(pVal);\n<line162>#endif\n<line163>return SQLITE_NOMEM_BKPT;\n<line164>}
----------------------------------------
Function: valueBytes
Content: <line0>static SQLITE_NOINLINE int valueBytes(sqlite3_value *pVal, u8 enc){\n<line1>return valueToText(pVal, enc)!=0 ? pVal->n : 0;\n<line2>}
----------------------------------------
Function: growOpArray
Content: <line0>static int growOpArray(Vdbe *v, int nOp){\n<line1>VdbeOp *pNew;\n<line2>Parse *p = v->pParse;\n<line3>/* The SQLITE_TEST_REALLOC_STRESS compile-time option is designed to force\n<line4>** more frequent reallocs and hence provide more opportunities for\n<line5>** simulated OOM faults.  SQLITE_TEST_REALLOC_STRESS is generally used\n<line6>** during testing only.  With SQLITE_TEST_REALLOC_STRESS grow the op array\n<line7>** by the minimum* amount required until the size reaches 512.  Normal\n<line8>** operation (without SQLITE_TEST_REALLOC_STRESS) is to double the current\n<line9>** size of the op array or add 1KB of space, whichever is smaller. */\n<line10>#ifdef SQLITE_TEST_REALLOC_STRESS\n<line11>sqlite3_int64 nNew = (v->nOpAlloc>=512 ? 2*(sqlite3_int64)v->nOpAlloc\n<line12>: (sqlite3_int64)v->nOpAlloc+nOp);\n<line13>#else\n<line14>sqlite3_int64 nNew = (v->nOpAlloc ? 2*(sqlite3_int64)v->nOpAlloc\n<line15>: (sqlite3_int64)(1024/sizeof(Op)));\n<line16>UNUSED_PARAMETER(nOp);\n<line17>#endif\n<line18>/* Ensure that the size of a VDBE does not grow too large */\n<line19>if( nNew > p->db->aLimit[SQLITE_LIMIT_VDBE_OP] ){\n<line20>sqlite3OomFault(p->db);\n<line21>return SQLITE_NOMEM;\n<line22>}\n<line23>assert( nOp<=(int)(1024/sizeof(Op)) );\n<line24>assert( nNew>=(v->nOpAlloc+nOp) );\n<line25>pNew = sqlite3DbRealloc(p->db, v->aOp, nNew*sizeof(Op));\n<line26>if( pNew ){\n<line27>p->szOpAlloc = sqlite3DbMallocSize(p->db, pNew);\n<line28>v->nOpAlloc = p->szOpAlloc/sizeof(Op);\n<line29>v->aOp = pNew;\n<line30>}\n<line31>return (pNew ? SQLITE_OK : SQLITE_NOMEM_BKPT);\n<line32>}
----------------------------------------
Function: growOp3
Content: <line0>static SQLITE_NOINLINE int growOp3(Vdbe *p, int op, int p1, int p2, int p3){\n<line1>assert( p->nOpAlloc<=p->nOp );\n<line2>if( growOpArray(p, 1) ) return 1;\n<line3>assert( p->nOpAlloc>p->nOp );\n<line4>return sqlite3VdbeAddOp3(p, op, p1, p2, p3);\n<line5>}
----------------------------------------
Function: addOp4IntSlow
Content: <line0>static SQLITE_NOINLINE int addOp4IntSlow(\n<line1>Vdbe *p,            /* Add the opcode to this VM */\n<line2>int op,             /* The new opcode */\n<line3>int p1,             /* The P1 operand */\n<line4>int p2,             /* The P2 operand */\n<line5>int p3,             /* The P3 operand */\n<line6>int p4              /* The P4 operand as an integer */\n<line7>){\n<line8>int addr = sqlite3VdbeAddOp3(p, op, p1, p2, p3);\n<line9>if( p->db->mallocFailed==0 ){\n<line10>VdbeOp *pOp = &p->aOp[addr];\n<line11>pOp->p4type = P4_INT32;\n<line12>pOp->p4.i = p4;\n<line13>}\n<line14>return addr;\n<line15>}
----------------------------------------
Function: resizeResolveLabel
Content: <line0>static SQLITE_NOINLINE void resizeResolveLabel(Parse *p, Vdbe *v, int j){\n<line1>int nNewSize = 10 - p->nLabel;\n<line2>p->aLabel = sqlite3DbReallocOrFree(p->db, p->aLabel,\n<line3>nNewSize*sizeof(p->aLabel[0]));\n<line4>if( p->aLabel==0 ){\n<line5>p->nLabelAlloc = 0;\n<line6>}else{\n<line7>#ifdef SQLITE_DEBUG\n<line8>int i;\n<line9>for(i=p->nLabelAlloc; i<nNewSize; i++) p->aLabel[i] = -1;\n<line10>#endif\n<line11>if( nNewSize>=100 && (nNewSize/100)>(p->nLabelAlloc/100) ){\n<line12>sqlite3ProgressCheck(p);\n<line13>}\n<line14>p->nLabelAlloc = nNewSize;\n<line15>p->aLabel[j] = v->nOp;\n<line16>}\n<line17>}
----------------------------------------
Function: resolveP2Values
Content: <line0>static void resolveP2Values(Vdbe *p, int *pMaxVtabArgs){\n<line1>int nMaxVtabArgs = *pMaxVtabArgs;\n<line2>Op *pOp;\n<line3>Parse *pParse = p->pParse;\n<line4>int *aLabel = pParse->aLabel;\n<line5>assert( pParse->db->mallocFailed==0 ); /* tag-20230419-1 */\n<line6>p->readOnly = 1;\n<line7>p->bIsReader = 0;\n<line8>pOp = &p->aOp[p->nOp-1];\n<line9>assert( p->aOp[0].opcode==OP_Init );\n<line10>while( 1 /* Loop terminates when it reaches the OP_Init opcode */ ){\n<line11>/* Only JUMP opcodes and the short list of special opcodes in the switch\n<line12>** below need to be considered.  The mkopcodeh.tcl generator script groups\n<line13>** all these opcodes together near the front of the opcode list.  Skip\n<line14>** any opcode that does not need processing by virtual of the fact that\n<line15>** it is larger than SQLITE_MX_JUMP_OPCODE, as a performance optimization.\n<line16>*/\n<line17>if( pOp->opcode<=SQLITE_MX_JUMP_OPCODE ){\n<line18>/* NOTE: Be sure to update mkopcodeh.tcl when adding or removing\n<line19>** cases from this switch! */\n<line20>switch( pOp->opcode ){\n<line21>case OP_Transaction: {\n<line22>if( pOp->p2!=0 ) p->readOnly = 0;\n<line23>/* no break */ deliberate_fall_through\n<line24>}\n<line25>case OP_AutoCommit:\n<line26>case OP_Savepoint: {\n<line27>p->bIsReader = 1;\n<line28>break;\n<line29>}\n<line30>#ifndef SQLITE_OMIT_WAL\n<line31>case OP_Checkpoint:\n<line32>#endif\n<line33>case OP_Vacuum:\n<line34>case OP_JournalMode: {\n<line35>p->readOnly = 0;\n<line36>p->bIsReader = 1;\n<line37>break;\n<line38>}\n<line39>case OP_Init: {\n<line40>assert( pOp->p2>=0 );\n<line41>goto resolve_p2_values_loop_exit;\n<line42>}\n<line43>#ifndef SQLITE_OMIT_VIRTUALTABLE\n<line44>case OP_VUpdate: {\n<line45>if( pOp->p2>nMaxVtabArgs ) nMaxVtabArgs = pOp->p2;\n<line46>break;\n<line47>}\n<line48>case OP_VFilter: {\n<line49>int n;\n<line50>/* The instruction immediately prior to VFilter will be an\n<line51>** OP_Integer that sets the "argc" value for the VFilter.  See\n<line52>** the code where OP_VFilter is generated at tag-20250207a. */\n<line53>assert( (pOp - p->aOp) >= 3 );\n<line54>assert( pOp[-1].opcode==OP_Integer );\n<line55>assert( pOp[-1].p2==pOp->p3+1 );\n<line56>n = pOp[-1].p1;\n<line57>if( n>nMaxVtabArgs ) nMaxVtabArgs = n;\n<line58>/* Fall through into the default case */\n<line59>/* no break */ deliberate_fall_through\n<line60>}\n<line61>#endif\n<line62>default: {\n<line63>if( pOp->p2<0 ){\n<line64>/* The mkopcodeh.tcl script has so arranged things that the only\n<line65>** non-jump opcodes less than SQLITE_MX_JUMP_CODE are guaranteed to\n<line66>** have non-negative values for P2. */\n<line67>assert( (sqlite3OpcodeProperty[pOp->opcode] & OPFLG_JUMP)!=0 );\n<line68>assert( ADDR(pOp->p2)<-pParse->nLabel );\n<line69>assert( aLabel!=0 );  /* True because of tag-20230419-1 */\n<line70>pOp->p2 = aLabel[ADDR(pOp->p2)];\n<line71>}\n<line72>/* OPFLG_JUMP opcodes never have P2==0, though OPFLG_JUMP0 opcodes\n<line73>** might */\n<line74>assert( pOp->p2>0\n<line75>|| (sqlite3OpcodeProperty[pOp->opcode] & OPFLG_JUMP0)!=0 );\n<line76>/* Jumps never go off the end of the bytecode array */\n<line77>assert( pOp->p2<p->nOp\n<line78>|| (sqlite3OpcodeProperty[pOp->opcode] & OPFLG_JUMP)==0 );\n<line79>break;\n<line80>}\n<line81>}\n<line82>/* The mkopcodeh.tcl script has so arranged things that the only\n<line83>** non-jump opcodes less than SQLITE_MX_JUMP_CODE are guaranteed to\n<line84>** have non-negative values for P2. */\n<line85>assert( (sqlite3OpcodeProperty[pOp->opcode]&OPFLG_JUMP)==0 || pOp->p2>=0);\n<line86>}\n<line87>assert( pOp>p->aOp );\n<line88>pOp--;\n<line89>}\n<line90>resolve_p2_values_loop_exit:\n<line91>if( aLabel ){\n<line92>sqlite3DbNNFreeNN(p->db, pParse->aLabel);\n<line93>pParse->aLabel = 0;\n<line94>}\n<line95>pParse->nLabel = 0;\n<line96>*pMaxVtabArgs = nMaxVtabArgs;\n<line97>assert( p->bIsReader!=0 || DbMaskAllZero(p->btreeMask) );\n<line98>}
----------------------------------------
Function: freeEphemeralFunction
Content: <line0>static void freeEphemeralFunction(sqlite3 *db, FuncDef *pDef){\n<line1>assert( db!=0 );\n<line2>if( (pDef->funcFlags & SQLITE_FUNC_EPHEM)!=0 ){\n<line3>sqlite3DbNNFreeNN(db, pDef);\n<line4>}\n<line5>}
----------------------------------------
Function: freeP4Mem
Content: <line0>static SQLITE_NOINLINE void freeP4Mem(sqlite3 *db, Mem *p){\n<line1>if( p->szMalloc ) sqlite3DbFree(db, p->zMalloc);\n<line2>sqlite3DbNNFreeNN(db, p);\n<line3>}
----------------------------------------
Function: freeP4FuncCtx
Content: <line0>static SQLITE_NOINLINE void freeP4FuncCtx(sqlite3 *db, sqlite3_context *p){\n<line1>assert( db!=0 );\n<line2>freeEphemeralFunction(db, p->pFunc);\n<line3>sqlite3DbNNFreeNN(db, p);\n<line4>}
----------------------------------------
Function: freeP4
Content: <line0>static void freeP4(sqlite3 *db, int p4type, void *p4){\n<line1>assert( db );\n<line2>switch( p4type ){\n<line3>case P4_FUNCCTX: {\n<line4>freeP4FuncCtx(db, (sqlite3_context*)p4);\n<line5>break;\n<line6>}\n<line7>case P4_REAL:\n<line8>case P4_INT64:\n<line9>case P4_DYNAMIC:\n<line10>case P4_INTARRAY: {\n<line11>if( p4 ) sqlite3DbNNFreeNN(db, p4);\n<line12>break;\n<line13>}\n<line14>case P4_KEYINFO: {\n<line15>if( db->pnBytesFreed==0 ) sqlite3KeyInfoUnref((KeyInfo*)p4);\n<line16>break;\n<line17>}\n<line18>#ifdef SQLITE_ENABLE_CURSOR_HINTS\n<line19>case P4_EXPR: {\n<line20>sqlite3ExprDelete(db, (Expr*)p4);\n<line21>break;\n<line22>}\n<line23>#endif\n<line24>case P4_FUNCDEF: {\n<line25>freeEphemeralFunction(db, (FuncDef*)p4);\n<line26>break;\n<line27>}\n<line28>case P4_MEM: {\n<line29>if( db->pnBytesFreed==0 ){\n<line30>sqlite3ValueFree((sqlite3_value*)p4);\n<line31>}else{\n<line32>freeP4Mem(db, (Mem*)p4);\n<line33>}\n<line34>break;\n<line35>}\n<line36>case P4_VTAB : {\n<line37>if( db->pnBytesFreed==0 ) sqlite3VtabUnlock((VTable *)p4);\n<line38>break;\n<line39>}\n<line40>case P4_TABLEREF: {\n<line41>if( db->pnBytesFreed==0 ) sqlite3DeleteTable(db, (Table*)p4);\n<line42>break;\n<line43>}\n<line44>case P4_SUBRTNSIG: {\n<line45>SubrtnSig *pSig = (SubrtnSig*)p4;\n<line46>sqlite3DbFree(db, pSig->zAff);\n<line47>sqlite3DbFree(db, pSig);\n<line48>break;\n<line49>}\n<line50>}\n<line51>}
----------------------------------------
Function: vdbeFreeOpArray
Content: <line0>static void vdbeFreeOpArray(sqlite3 *db, Op *aOp, int nOp){\n<line1>assert( nOp>=0 );\n<line2>assert( db!=0 );\n<line3>if( aOp ){\n<line4>Op *pOp = &aOp[nOp-1];\n<line5>while(1){  /* Exit via break */\n<line6>if( pOp->p4type <= P4_FREE_IF_LE ) freeP4(db, pOp->p4type, pOp->p4.p);\n<line7>#ifdef SQLITE_ENABLE_EXPLAIN_COMMENTS\n<line8>sqlite3DbFree(db, pOp->zComment);\n<line9>#endif\n<line10>if( pOp==aOp ) break;\n<line11>pOp--;\n<line12>}\n<line13>sqlite3DbNNFreeNN(db, aOp);\n<line14>}\n<line15>}
----------------------------------------
Function: vdbeChangeP4Full
Content: <line0>static void SQLITE_NOINLINE vdbeChangeP4Full(\n<line1>Vdbe *p,\n<line2>Op *pOp,\n<line3>const char *zP4,\n<line4>int n\n<line5>){\n<line6>if( pOp->p4type ){\n<line7>assert( pOp->p4type > P4_FREE_IF_LE );\n<line8>pOp->p4type = 0;\n<line9>pOp->p4.p = 0;\n<line10>}\n<line11>if( n<0 ){\n<line12>sqlite3VdbeChangeP4(p, (int)(pOp - p->aOp), zP4, n);\n<line13>}else{\n<line14>if( n==0 ) n = sqlite3Strlen30(zP4);\n<line15>pOp->p4.z = sqlite3DbStrNDup(p->db, zP4, n);\n<line16>pOp->p4type = P4_DYNAMIC;\n<line17>}\n<line18>}
----------------------------------------
Function: vdbeLeave
Content: <line0>static SQLITE_NOINLINE void vdbeLeave(Vdbe *p){\n<line1>int i;\n<line2>sqlite3 *db;\n<line3>Db *aDb;\n<line4>int nDb;\n<line5>db = p->db;\n<line6>aDb = db->aDb;\n<line7>nDb = db->nDb;\n<line8>for(i=0; i<nDb; i++){\n<line9>if( i!=1 && DbMaskTest(p->lockMask,i) && ALWAYS(aDb[i].pBt!=0) ){\n<line10>sqlite3BtreeLeave(aDb[i].pBt);\n<line11>}\n<line12>}\n<line13>}
----------------------------------------
Function: initMemArray
Content: <line0>static void initMemArray(Mem *p, int N, sqlite3 *db, u16 flags){\n<line1>assert( db!=0 );\n<line2>if( N>0 ){\n<line3>do{\n<line4>p->flags = flags;\n<line5>p->db = db;\n<line6>p->szMalloc = 0;\n<line7>#ifdef SQLITE_DEBUG\n<line8>p->pScopyFrom = 0;\n<line9>p->bScopy = 0;\n<line10>#endif\n<line11>p++;\n<line12>}while( (--N)>0 );\n<line13>}\n<line14>}
----------------------------------------
Function: releaseMemArray
Content: <line0>static void releaseMemArray(Mem *p, int N){\n<line1>if( p && N ){\n<line2>Mem *pEnd = &p[N];\n<line3>sqlite3 *db = p->db;\n<line4>assert( db!=0 );\n<line5>if( db->pnBytesFreed ){\n<line6>do{\n<line7>if( p->szMalloc ) sqlite3DbFree(db, p->zMalloc);\n<line8>}while( (++p)<pEnd );\n<line9>return;\n<line10>}\n<line11>do{\n<line12>assert( (&p[1])==pEnd || p[0].db==p[1].db );\n<line13>assert( sqlite3VdbeCheckMemInvariants(p) );\n<line14>/* This block is really an inlined version of sqlite3VdbeMemRelease()\n<line15>** that takes advantage of the fact that the memory cell value is\n<line16>** being set to NULL after releasing any dynamic resources.\n<line17>**\n<line18>** The justification for duplicating code is that according to\n<line19>** callgrind, this causes a certain test case to hit the CPU 4.7\n<line20>** percent less (x86 linux, gcc version 4.1.2, -O6) than if\n<line21>** sqlite3MemRelease() were called from here. With -O2, this jumps\n<line22>** to 6.6 percent. The test case is inserting 1000 rows into a table\n<line23>** with no indexes using a single prepared INSERT statement, bind()\n<line24>** and reset(). Inserts are grouped into a transaction.\n<line25>*/\n<line26>testcase( p->flags & MEM_Agg );\n<line27>testcase( p->flags & MEM_Dyn );\n<line28>if( p->flags&(MEM_Agg|MEM_Dyn) ){\n<line29>testcase( (p->flags & MEM_Dyn)!=0 && p->xDel==sqlite3VdbeFrameMemDel );\n<line30>sqlite3VdbeMemRelease(p);\n<line31>p->flags = MEM_Undefined;\n<line32>}else if( p->szMalloc ){\n<line33>sqlite3DbNNFreeNN(db, p->zMalloc);\n<line34>p->szMalloc = 0;\n<line35>p->flags = MEM_Undefined;\n<line36>}\n<line37>#ifdef SQLITE_DEBUG\n<line38>else{\n<line39>p->flags = MEM_Undefined;\n<line40>}\n<line41>#endif\n<line42>}while( (++p)<pEnd );\n<line43>}\n<line44>}
----------------------------------------
Function: allocSpace
Content: <line0>static void *allocSpace(\n<line1>struct ReusableSpace *p,  /* Bulk memory available for allocation */\n<line2>void *pBuf,               /* Pointer to a prior allocation */\n<line3>sqlite3_int64 nByte       /* Bytes of memory needed. */\n<line4>){\n<line5>assert( EIGHT_BYTE_ALIGNMENT(p->pSpace) );\n<line6>if( pBuf==0 ){\n<line7>nByte = ROUND8P(nByte);\n<line8>if( nByte <= p->nFree ){\n<line9>p->nFree -= nByte;\n<line10>pBuf = &p->pSpace[p->nFree];\n<line11>}else{\n<line12>p->nNeeded += nByte;\n<line13>}\n<line14>}\n<line15>assert( EIGHT_BYTE_ALIGNMENT(pBuf) );\n<line16>return pBuf;\n<line17>}
----------------------------------------
Function: freeCursorWithCache
Content: <line0>static SQLITE_NOINLINE void freeCursorWithCache(Vdbe *p, VdbeCursor *pCx){\n<line1>VdbeTxtBlbCache *pCache = pCx->pCache;\n<line2>assert( pCx->colCache );\n<line3>pCx->colCache = 0;\n<line4>pCx->pCache = 0;\n<line5>if( pCache->pCValue ){\n<line6>sqlite3RCStrUnref(pCache->pCValue);\n<line7>pCache->pCValue = 0;\n<line8>}\n<line9>sqlite3DbFree(p->db, pCache);\n<line10>sqlite3VdbeFreeCursorNN(p, pCx);\n<line11>}
----------------------------------------
Function: closeCursorsInFrame
Content: <line0>static void closeCursorsInFrame(Vdbe *p){\n<line1>int i;\n<line2>for(i=0; i<p->nCursor; i++){\n<line3>VdbeCursor *pC = p->apCsr[i];\n<line4>if( pC ){\n<line5>sqlite3VdbeFreeCursorNN(p, pC);\n<line6>p->apCsr[i] = 0;\n<line7>}\n<line8>}\n<line9>}
----------------------------------------
Function: closeAllCursors
Content: <line0>static void closeAllCursors(Vdbe *p){\n<line1>if( p->pFrame ){\n<line2>VdbeFrame *pFrame;\n<line3>for(pFrame=p->pFrame; pFrame->pParent; pFrame=pFrame->pParent);\n<line4>sqlite3VdbeFrameRestore(pFrame);\n<line5>p->pFrame = 0;\n<line6>p->nFrame = 0;\n<line7>}\n<line8>assert( p->nFrame==0 );\n<line9>closeCursorsInFrame(p);\n<line10>releaseMemArray(p->aMem, p->nMem);\n<line11>while( p->pDelFrame ){\n<line12>VdbeFrame *pDel = p->pDelFrame;\n<line13>p->pDelFrame = pDel->pParent;\n<line14>sqlite3VdbeFrameDelete(pDel);\n<line15>}\n<line16>/* Delete any auxdata allocations made by the VM */\n<line17>if( p->pAuxData ) sqlite3VdbeDeleteAuxData(p->db, &p->pAuxData, -1, 0);\n<line18>assert( p->pAuxData==0 );\n<line19>}
----------------------------------------
Function: vdbeCommit
Content: <line0>static int vdbeCommit(sqlite3 *db, Vdbe *p){\n<line1>int i;\n<line2>int nTrans = 0;  /* Number of databases with an active write-transaction\n<line3>** that are candidates for a two-phase commit using a\n<line4>** super-journal */\n<line5>int rc = SQLITE_OK;\n<line6>int needXcommit = 0;\n<line7>#ifdef SQLITE_OMIT_VIRTUALTABLE\n<line8>/* With this option, sqlite3VtabSync() is defined to be simply\n<line9>** SQLITE_OK so p is not used.\n<line10>*/\n<line11>UNUSED_PARAMETER(p);\n<line12>#endif\n<line13>/* Before doing anything else, call the xSync() callback for any\n<line14>** virtual module tables written in this transaction. This has to\n<line15>** be done before determining whether a super-journal file is\n<line16>** required, as an xSync() callback may add an attached database\n<line17>** to the transaction.\n<line18>*/\n<line19>rc = sqlite3VtabSync(db, p);\n<line20>/* This loop determines (a) if the commit hook should be invoked and\n<line21>** (b) how many database files have open write transactions, not\n<line22>** including the temp database. (b) is important because if more than\n<line23>** one database file has an open write transaction, a super-journal\n<line24>** file is required for an atomic commit.\n<line25>*/\n<line26>for(i=0; rc==SQLITE_OK && i<db->nDb; i++){\n<line27>Btree *pBt = db->aDb[i].pBt;\n<line28>if( sqlite3BtreeTxnState(pBt)==SQLITE_TXN_WRITE ){\n<line29>/* Whether or not a database might need a super-journal depends upon\n<line30>** its journal mode (among other things).  This matrix determines which\n<line31>** journal modes use a super-journal and which do not */\n<line32>static const u8 aMJNeeded[] = {\n<line33>/* DELETE   */  1,\n<line34>/* PERSIST   */ 1,\n<line35>/* OFF       */ 0,\n<line36>/* TRUNCATE  */ 1,\n<line37>/* MEMORY    */ 0,\n<line38>/* WAL       */ 0\n<line39>};\n<line40>Pager *pPager;   /* Pager associated with pBt */\n<line41>needXcommit = 1;\n<line42>sqlite3BtreeEnter(pBt);\n<line43>pPager = sqlite3BtreePager(pBt);\n<line44>if( db->aDb[i].safety_level!=PAGER_SYNCHRONOUS_OFF\n<line45>&& aMJNeeded[sqlite3PagerGetJournalMode(pPager)]\n<line46>&& sqlite3PagerIsMemdb(pPager)==0\n<line47>){\n<line48>assert( i!=1 );\n<line49>nTrans++;\n<line50>}\n<line51>rc = sqlite3PagerExclusiveLock(pPager);\n<line52>sqlite3BtreeLeave(pBt);\n<line53>}\n<line54>}\n<line55>if( rc!=SQLITE_OK ){\n<line56>return rc;\n<line57>}\n<line58>/* If there are any write-transactions at all, invoke the commit hook */\n<line59>if( needXcommit && db->xCommitCallback ){\n<line60>rc = db->xCommitCallback(db->pCommitArg);\n<line61>if( rc ){\n<line62>return SQLITE_CONSTRAINT_COMMITHOOK;\n<line63>}\n<line64>}\n<line65>/* The simple case - no more than one database file (not counting the\n<line66>** TEMP database) has a transaction active.   There is no need for the\n<line67>** super-journal.\n<line68>**\n<line69>** If the return value of sqlite3BtreeGetFilename() is a zero length\n<line70>** string, it means the main database is :memory: or a temp file.  In\n<line71>** that case we do not support atomic multi-file commits, so use the\n<line72>** simple case then too.\n<line73>*/\n<line74>if( 0==sqlite3Strlen30(sqlite3BtreeGetFilename(db->aDb[0].pBt))\n<line75>|| nTrans<=1\n<line76>){\n<line77>if( needXcommit ){\n<line78>for(i=0; rc==SQLITE_OK && i<db->nDb; i++){\n<line79>Btree *pBt = db->aDb[i].pBt;\n<line80>if( sqlite3BtreeTxnState(pBt)>=SQLITE_TXN_WRITE ){\n<line81>rc = sqlite3BtreeCommitPhaseOne(pBt, 0);\n<line82>}\n<line83>}\n<line84>}\n<line85>/* Do the commit only if all databases successfully complete phase 1.\n<line86>** If one of the BtreeCommitPhaseOne() calls fails, this indicates an\n<line87>** IO error while deleting or truncating a journal file. It is unlikely,\n<line88>** but could happen. In this case abandon processing and return the error.\n<line89>*/\n<line90>for(i=0; rc==SQLITE_OK && i<db->nDb; i++){\n<line91>Btree *pBt = db->aDb[i].pBt;\n<line92>int txn = sqlite3BtreeTxnState(pBt);\n<line93>if( txn!=SQLITE_TXN_NONE ){\n<line94>assert( needXcommit || txn==SQLITE_TXN_READ );\n<line95>rc = sqlite3BtreeCommitPhaseTwo(pBt, 0);\n<line96>}\n<line97>}\n<line98>if( rc==SQLITE_OK ){\n<line99>sqlite3VtabCommit(db);\n<line100>}\n<line101>}\n<line102>/* The complex case - There is a multi-file write-transaction active.\n<line103>** This requires a super-journal file to ensure the transaction is\n<line104>** committed atomically.\n<line105>*/\n<line106>#ifndef SQLITE_OMIT_DISKIO\n<line107>else{\n<line108>sqlite3_vfs *pVfs = db->pVfs;\n<line109>char *zSuper = 0;   /* File-name for the super-journal */\n<line110>char const *zMainFile = sqlite3BtreeGetFilename(db->aDb[0].pBt);\n<line111>sqlite3_file *pSuperJrnl = 0;\n<line112>i64 offset = 0;\n<line113>int res;\n<line114>int retryCount = 0;\n<line115>int nMainFile;\n<line116>/* Select a super-journal file name */\n<line117>nMainFile = sqlite3Strlen30(zMainFile);\n<line118>zSuper = sqlite3MPrintf(db, "%.4c%s%.16c", 0,zMainFile,0);\n<line119>if( zSuper==0 ) return SQLITE_NOMEM_BKPT;\n<line120>zSuper += 4;\n<line121>do {\n<line122>u32 iRandom;\n<line123>if( retryCount ){\n<line124>if( retryCount>100 ){\n<line125>sqlite3_log(SQLITE_FULL, "MJ delete: %s", zSuper);\n<line126>sqlite3OsDelete(pVfs, zSuper, 0);\n<line127>break;\n<line128>}else if( retryCount==1 ){\n<line129>sqlite3_log(SQLITE_FULL, "MJ collide: %s", zSuper);\n<line130>}\n<line131>}\n<line132>retryCount++;\n<line133>sqlite3_randomness(sizeof(iRandom), &iRandom);\n<line134>sqlite3_snprintf(13, &zSuper[nMainFile], "-mj%06X9%02X",\n<line135>(iRandom>>8)&0xffffff, iRandom&0xff);\n<line136>/* The antipenultimate character of the super-journal name must\n<line137>** be "9" to avoid name collisions when using 8+3 filenames. */\n<line138>assert( zSuper[sqlite3Strlen30(zSuper)-3]=='9' );\n<line139>sqlite3FileSuffix3(zMainFile, zSuper);\n<line140>rc = sqlite3OsAccess(pVfs, zSuper, SQLITE_ACCESS_EXISTS, &res);\n<line141>}while( rc==SQLITE_OK && res );\n<line142>if( rc==SQLITE_OK ){\n<line143>/* Open the super-journal. */\n<line144>rc = sqlite3OsOpenMalloc(pVfs, zSuper, &pSuperJrnl,\n<line145>SQLITE_OPEN_READWRITE|SQLITE_OPEN_CREATE|\n<line146>SQLITE_OPEN_EXCLUSIVE|SQLITE_OPEN_SUPER_JOURNAL, 0\n<line147>);\n<line148>}\n<line149>if( rc!=SQLITE_OK ){\n<line150>sqlite3DbFree(db, zSuper-4);\n<line151>return rc;\n<line152>}\n<line153>/* Write the name of each database file in the transaction into the new\n<line154>** super-journal file. If an error occurs at this point close\n<line155>** and delete the super-journal file. All the individual journal files\n<line156>** still have 'null' as the super-journal pointer, so they will roll\n<line157>** back independently if a failure occurs.\n<line158>*/\n<line159>for(i=0; i<db->nDb; i++){\n<line160>Btree *pBt = db->aDb[i].pBt;\n<line161>if( sqlite3BtreeTxnState(pBt)==SQLITE_TXN_WRITE ){\n<line162>char const *zFile = sqlite3BtreeGetJournalname(pBt);\n<line163>if( zFile==0 ){\n<line164>continue;  /* Ignore TEMP and :memory: databases */\n<line165>}\n<line166>assert( zFile[0]!=0 );\n<line167>rc = sqlite3OsWrite(pSuperJrnl, zFile, sqlite3Strlen30(zFile)+1,offset);\n<line168>offset += sqlite3Strlen30(zFile)+1;\n<line169>if( rc!=SQLITE_OK ){\n<line170>sqlite3OsCloseFree(pSuperJrnl);\n<line171>sqlite3OsDelete(pVfs, zSuper, 0);\n<line172>sqlite3DbFree(db, zSuper-4);\n<line173>return rc;\n<line174>}\n<line175>}\n<line176>}\n<line177>/* Sync the super-journal file. If the IOCAP_SEQUENTIAL device\n<line178>** flag is set this is not required.\n<line179>*/\n<line180>if( 0==(sqlite3OsDeviceCharacteristics(pSuperJrnl)&SQLITE_IOCAP_SEQUENTIAL)\n<line181>&& SQLITE_OK!=(rc = sqlite3OsSync(pSuperJrnl, SQLITE_SYNC_NORMAL))\n<line182>){\n<line183>sqlite3OsCloseFree(pSuperJrnl);\n<line184>sqlite3OsDelete(pVfs, zSuper, 0);\n<line185>sqlite3DbFree(db, zSuper-4);\n<line186>return rc;\n<line187>}\n<line188>/* Sync all the db files involved in the transaction. The same call\n<line189>** sets the super-journal pointer in each individual journal. If\n<line190>** an error occurs here, do not delete the super-journal file.\n<line191>**\n<line192>** If the error occurs during the first call to\n<line193>** sqlite3BtreeCommitPhaseOne(), then there is a chance that the\n<line194>** super-journal file will be orphaned. But we cannot delete it,\n<line195>** in case the super-journal file name was written into the journal\n<line196>** file before the failure occurred.\n<line197>*/\n<line198>for(i=0; rc==SQLITE_OK && i<db->nDb; i++){\n<line199>Btree *pBt = db->aDb[i].pBt;\n<line200>if( pBt ){\n<line201>rc = sqlite3BtreeCommitPhaseOne(pBt, zSuper);\n<line202>}\n<line203>}\n<line204>sqlite3OsCloseFree(pSuperJrnl);\n<line205>assert( rc!=SQLITE_BUSY );\n<line206>if( rc!=SQLITE_OK ){\n<line207>sqlite3DbFree(db, zSuper-4);\n<line208>return rc;\n<line209>}\n<line210>/* Delete the super-journal file. This commits the transaction. After\n<line211>** doing this the directory is synced again before any individual\n<line212>** transaction files are deleted.\n<line213>*/\n<line214>rc = sqlite3OsDelete(pVfs, zSuper, 1);\n<line215>sqlite3DbFree(db, zSuper-4);\n<line216>zSuper = 0;\n<line217>if( rc ){\n<line218>return rc;\n<line219>}\n<line220>/* All files and directories have already been synced, so the following\n<line221>** calls to sqlite3BtreeCommitPhaseTwo() are only closing files and\n<line222>** deleting or truncating journals. If something goes wrong while\n<line223>** this is happening we don't really care. The integrity of the\n<line224>** transaction is already guaranteed, but some stray 'cold' journals\n<line225>** may be lying around. Returning an error code won't help matters.\n<line226>*/\n<line227>disable_simulated_io_errors();\n<line228>sqlite3BeginBenignMalloc();\n<line229>for(i=0; i<db->nDb; i++){\n<line230>Btree *pBt = db->aDb[i].pBt;\n<line231>if( pBt ){\n<line232>sqlite3BtreeCommitPhaseTwo(pBt, 1);\n<line233>}\n<line234>}\n<line235>sqlite3EndBenignMalloc();\n<line236>enable_simulated_io_errors();\n<line237>sqlite3VtabCommit(db);\n<line238>}\n<line239>#endif\n<line240>return rc;\n<line241>}
----------------------------------------
Function: vdbeCloseStatement
Content: <line0>static SQLITE_NOINLINE int vdbeCloseStatement(Vdbe *p, int eOp){\n<line1>sqlite3 *const db = p->db;\n<line2>int rc = SQLITE_OK;\n<line3>int i;\n<line4>const int iSavepoint = p->iStatement-1;\n<line5>assert( eOp==SAVEPOINT_ROLLBACK || eOp==SAVEPOINT_RELEASE);\n<line6>assert( db->nStatement>0 );\n<line7>assert( p->iStatement==(db->nStatement+db->nSavepoint) );\n<line8>for(i=0; i<db->nDb; i++){\n<line9>int rc2 = SQLITE_OK;\n<line10>Btree *pBt = db->aDb[i].pBt;\n<line11>if( pBt ){\n<line12>if( eOp==SAVEPOINT_ROLLBACK ){\n<line13>rc2 = sqlite3BtreeSavepoint(pBt, SAVEPOINT_ROLLBACK, iSavepoint);\n<line14>}\n<line15>if( rc2==SQLITE_OK ){\n<line16>rc2 = sqlite3BtreeSavepoint(pBt, SAVEPOINT_RELEASE, iSavepoint);\n<line17>}\n<line18>if( rc==SQLITE_OK ){\n<line19>rc = rc2;\n<line20>}\n<line21>}\n<line22>}\n<line23>db->nStatement--;\n<line24>p->iStatement = 0;\n<line25>if( rc==SQLITE_OK ){\n<line26>if( eOp==SAVEPOINT_ROLLBACK ){\n<line27>rc = sqlite3VtabSavepoint(db, SAVEPOINT_ROLLBACK, iSavepoint);\n<line28>}\n<line29>if( rc==SQLITE_OK ){\n<line30>rc = sqlite3VtabSavepoint(db, SAVEPOINT_RELEASE, iSavepoint);\n<line31>}\n<line32>}\n<line33>/* If the statement transaction is being rolled back, also restore the\n<line34>** database handles deferred constraint counter to the value it had when\n<line35>** the statement transaction was opened.  */\n<line36>if( eOp==SAVEPOINT_ROLLBACK ){\n<line37>db->nDeferredCons = p->nStmtDefCons;\n<line38>db->nDeferredImmCons = p->nStmtDefImmCons;\n<line39>}\n<line40>return rc;\n<line41>}
----------------------------------------
Function: vdbeFkError
Content: <line0>static SQLITE_NOINLINE int vdbeFkError(Vdbe *p){\n<line1>p->rc = SQLITE_CONSTRAINT_FOREIGNKEY;\n<line2>p->errorAction = OE_Abort;\n<line3>sqlite3VdbeError(p, "FOREIGN KEY constraint failed");\n<line4>if( (p->prepFlags & SQLITE_PREPARE_SAVESQL)==0 ) return SQLITE_ERROR;\n<line5>return SQLITE_CONSTRAINT_FOREIGNKEY;\n<line6>}
----------------------------------------
Function: sqlite3VdbeClearObject
Content: <line0>static void sqlite3VdbeClearObject(sqlite3 *db, Vdbe *p){\n<line1>SubProgram *pSub, *pNext;\n<line2>assert( db!=0 );\n<line3>assert( p->db==0 || p->db==db );\n<line4>if( p->aColName ){\n<line5>releaseMemArray(p->aColName, p->nResAlloc*COLNAME_N);\n<line6>sqlite3DbNNFreeNN(db, p->aColName);\n<line7>}\n<line8>for(pSub=p->pProgram; pSub; pSub=pNext){\n<line9>pNext = pSub->pNext;\n<line10>vdbeFreeOpArray(db, pSub->aOp, pSub->nOp);\n<line11>sqlite3DbFree(db, pSub);\n<line12>}\n<line13>if( p->eVdbeState!=VDBE_INIT_STATE ){\n<line14>releaseMemArray(p->aVar, p->nVar);\n<line15>if( p->pVList ) sqlite3DbNNFreeNN(db, p->pVList);\n<line16>if( p->pFree ) sqlite3DbNNFreeNN(db, p->pFree);\n<line17>}\n<line18>vdbeFreeOpArray(db, p->aOp, p->nOp);\n<line19>if( p->zSql ) sqlite3DbNNFreeNN(db, p->zSql);\n<line20>#ifdef SQLITE_ENABLE_NORMALIZE\n<line21>sqlite3DbFree(db, p->zNormSql);\n<line22>{\n<line23>DblquoteStr *pThis, *pNxt;\n<line24>for(pThis=p->pDblStr; pThis; pThis=pNxt){\n<line25>pNxt = pThis->pNextStr;\n<line26>sqlite3DbFree(db, pThis);\n<line27>}\n<line28>}\n<line29>#endif\n<line30>#ifdef SQLITE_ENABLE_STMT_SCANSTATUS\n<line31>{\n<line32>int i;\n<line33>for(i=0; i<p->nScan; i++){\n<line34>sqlite3DbFree(db, p->aScan[i].zName);\n<line35>}\n<line36>sqlite3DbFree(db, p->aScan);\n<line37>}\n<line38>#endif\n<line39>}
----------------------------------------
Function: serialGet
Content: <line0>static void serialGet(\n<line1>const unsigned char *buf,     /* Buffer to deserialize from */\n<line2>u32 serial_type,              /* Serial type to deserialize */\n<line3>Mem *pMem                     /* Memory cell to write value into */\n<line4>){\n<line5>u64 x = FOUR_BYTE_UINT(buf);\n<line6>u32 y = FOUR_BYTE_UINT(buf+4);\n<line7>x = (x<<32) + y;\n<line8>if( serial_type==6 ){\n<line9>/* EVIDENCE-OF: R-29851-52272 Value is a big-endian 64-bit\n<line10>** twos-complement integer. */\n<line11>pMem->u.i = *(i64*)&x;\n<line12>pMem->flags = MEM_Int;\n<line13>testcase( pMem->u.i<0 );\n<line14>}else{\n<line15>/* EVIDENCE-OF: R-57343-49114 Value is a big-endian IEEE 754-2008 64-bit\n<line16>** floating point number. */\n<line17>#if !defined(NDEBUG) && !defined(SQLITE_OMIT_FLOATING_POINT)\n<line18>/* Verify that integers and floating point values use the same\n<line19>** byte order.  Or, that if SQLITE_MIXED_ENDIAN_64BIT_FLOAT is\n<line20>** defined that 64-bit floating point values really are mixed\n<line21>** endian.\n<line22>*/\n<line23>static const u64 t1 = ((u64)0x3ff00000)<<32;\n<line24>static const double r1 = 1.0;\n<line25>u64 t2 = t1;\n<line26>swapMixedEndianFloat(t2);\n<line27>assert( sizeof(r1)==sizeof(t2) && memcmp(&r1, &t2, sizeof(r1))==0 );\n<line28>#endif\n<line29>assert( sizeof(x)==8 && sizeof(pMem->u.r)==8 );\n<line30>swapMixedEndianFloat(x);\n<line31>memcpy(&pMem->u.r, &x, sizeof(x));\n<line32>pMem->flags = IsNaN(x) ? MEM_Null : MEM_Real;\n<line33>}\n<line34>}
----------------------------------------
Function: serialGet7
Content: <line0>static int serialGet7(\n<line1>const unsigned char *buf,     /* Buffer to deserialize from */\n<line2>Mem *pMem                     /* Memory cell to write value into */\n<line3>){\n<line4>u64 x = FOUR_BYTE_UINT(buf);\n<line5>u32 y = FOUR_BYTE_UINT(buf+4);\n<line6>x = (x<<32) + y;\n<line7>assert( sizeof(x)==8 && sizeof(pMem->u.r)==8 );\n<line8>swapMixedEndianFloat(x);\n<line9>memcpy(&pMem->u.r, &x, sizeof(x));\n<line10>if( IsNaN(x) ){\n<line11>pMem->flags = MEM_Null;\n<line12>return 1;\n<line13>}\n<line14>pMem->flags = MEM_Real;\n<line15>return 0;\n<line16>}
----------------------------------------
Function: vdbeCompareMemStringWithEncodingChange
Content: <line0>static SQLITE_NOINLINE int vdbeCompareMemStringWithEncodingChange(\n<line1>const Mem *pMem1,\n<line2>const Mem *pMem2,\n<line3>const CollSeq *pColl,\n<line4>u8 *prcErr                      /* If an OOM occurs, set to SQLITE_NOMEM */\n<line5>){\n<line6>int rc;\n<line7>const void *v1, *v2;\n<line8>Mem c1;\n<line9>Mem c2;\n<line10>sqlite3VdbeMemInit(&c1, pMem1->db, MEM_Null);\n<line11>sqlite3VdbeMemInit(&c2, pMem1->db, MEM_Null);\n<line12>sqlite3VdbeMemShallowCopy(&c1, pMem1, MEM_Ephem);\n<line13>sqlite3VdbeMemShallowCopy(&c2, pMem2, MEM_Ephem);\n<line14>v1 = sqlite3ValueText((sqlite3_value*)&c1, pColl->enc);\n<line15>v2 = sqlite3ValueText((sqlite3_value*)&c2, pColl->enc);\n<line16>if( (v1==0 || v2==0) ){\n<line17>if( prcErr ) *prcErr = SQLITE_NOMEM_BKPT;\n<line18>rc = 0;\n<line19>}else{\n<line20>rc = pColl->xCmp(pColl->pUser, c1.n, v1, c2.n, v2);\n<line21>}\n<line22>sqlite3VdbeMemReleaseMalloc(&c1);\n<line23>sqlite3VdbeMemReleaseMalloc(&c2);\n<line24>return rc;\n<line25>}
----------------------------------------
Function: vdbeCompareMemString
Content: <line0>static int vdbeCompareMemString(\n<line1>const Mem *pMem1,\n<line2>const Mem *pMem2,\n<line3>const CollSeq *pColl,\n<line4>u8 *prcErr                      /* If an OOM occurs, set to SQLITE_NOMEM */\n<line5>){\n<line6>if( pMem1->enc==pColl->enc ){\n<line7>/* The strings are already in the correct encoding.  Call the\n<line8>** comparison function directly */\n<line9>return pColl->xCmp(pColl->pUser,pMem1->n,pMem1->z,pMem2->n,pMem2->z);\n<line10>}else{\n<line11>return vdbeCompareMemStringWithEncodingChange(pMem1,pMem2,pColl,prcErr);\n<line12>}\n<line13>}
----------------------------------------
Function: isAllZero
Content: <line0>static int isAllZero(const char *z, int n){\n<line1>int i;\n<line2>for(i=0; i<n; i++){\n<line3>if( z[i] ) return 0;\n<line4>}\n<line5>return 1;\n<line6>}
----------------------------------------
Function: vdbeRecordDecodeInt
Content: <line0>static i64 vdbeRecordDecodeInt(u32 serial_type, const u8 *aKey){\n<line1>u32 y;\n<line2>assert( CORRUPT_DB || (serial_type>=1 && serial_type<=9 && serial_type!=7) );\n<line3>switch( serial_type ){\n<line4>case 0:\n<line5>case 1:\n<line6>testcase( aKey[0]&0x80 );\n<line7>return ONE_BYTE_INT(aKey);\n<line8>case 2:\n<line9>testcase( aKey[0]&0x80 );\n<line10>return TWO_BYTE_INT(aKey);\n<line11>case 3:\n<line12>testcase( aKey[0]&0x80 );\n<line13>return THREE_BYTE_INT(aKey);\n<line14>case 4: {\n<line15>testcase( aKey[0]&0x80 );\n<line16>y = FOUR_BYTE_UINT(aKey);\n<line17>return (i64)*(int*)&y;\n<line18>}\n<line19>case 5: {\n<line20>testcase( aKey[0]&0x80 );\n<line21>return FOUR_BYTE_UINT(aKey+2) + (((i64)1)<<32)*TWO_BYTE_INT(aKey);\n<line22>}\n<line23>case 6: {\n<line24>u64 x = FOUR_BYTE_UINT(aKey);\n<line25>testcase( aKey[0]&0x80 );\n<line26>x = (x<<32) | FOUR_BYTE_UINT(aKey+4);\n<line27>return (i64)*(i64*)&x;\n<line28>}\n<line29>}\n<line30>return (serial_type - 8);\n<line31>}
----------------------------------------
Function: vdbeRecordCompareInt
Content: <line0>static int vdbeRecordCompareInt(\n<line1>int nKey1, const void *pKey1, /* Left key */\n<line2>UnpackedRecord *pPKey2        /* Right key */\n<line3>){\n<line4>const u8 *aKey = &((const u8*)pKey1)[*(const u8*)pKey1 & 0x3F];\n<line5>int serial_type = ((const u8*)pKey1)[1];\n<line6>int res;\n<line7>u32 y;\n<line8>u64 x;\n<line9>i64 v;\n<line10>i64 lhs;\n<line11>vdbeAssertFieldCountWithinLimits(nKey1, pKey1, pPKey2->pKeyInfo);\n<line12>assert( (*(u8*)pKey1)<=0x3F || CORRUPT_DB );\n<line13>switch( serial_type ){\n<line14>case 1: { /* 1-byte signed integer */\n<line15>lhs = ONE_BYTE_INT(aKey);\n<line16>testcase( lhs<0 );\n<line17>break;\n<line18>}\n<line19>case 2: { /* 2-byte signed integer */\n<line20>lhs = TWO_BYTE_INT(aKey);\n<line21>testcase( lhs<0 );\n<line22>break;\n<line23>}\n<line24>case 3: { /* 3-byte signed integer */\n<line25>lhs = THREE_BYTE_INT(aKey);\n<line26>testcase( lhs<0 );\n<line27>break;\n<line28>}\n<line29>case 4: { /* 4-byte signed integer */\n<line30>y = FOUR_BYTE_UINT(aKey);\n<line31>lhs = (i64)*(int*)&y;\n<line32>testcase( lhs<0 );\n<line33>break;\n<line34>}\n<line35>case 5: { /* 6-byte signed integer */\n<line36>lhs = FOUR_BYTE_UINT(aKey+2) + (((i64)1)<<32)*TWO_BYTE_INT(aKey);\n<line37>testcase( lhs<0 );\n<line38>break;\n<line39>}\n<line40>case 6: { /* 8-byte signed integer */\n<line41>x = FOUR_BYTE_UINT(aKey);\n<line42>x = (x<<32) | FOUR_BYTE_UINT(aKey+4);\n<line43>lhs = *(i64*)&x;\n<line44>testcase( lhs<0 );\n<line45>break;\n<line46>}\n<line47>case 8:\n<line48>lhs = 0;\n<line49>break;\n<line50>case 9:\n<line51>lhs = 1;\n<line52>break;\n<line53>/* This case could be removed without changing the results of running\n<line54>** this code. Including it causes gcc to generate a faster switch\n<line55>** statement (since the range of switch targets now starts at zero and\n<line56>** is contiguous) but does not cause any duplicate code to be generated\n<line57>** (as gcc is clever enough to combine the two like cases). Other\n<line58>** compilers might be similar.  */\n<line59>case 0: case 7:\n<line60>return sqlite3VdbeRecordCompare(nKey1, pKey1, pPKey2);\n<line61>default:\n<line62>return sqlite3VdbeRecordCompare(nKey1, pKey1, pPKey2);\n<line63>}\n<line64>assert( pPKey2->u.i == pPKey2->aMem[0].u.i );\n<line65>v = pPKey2->u.i;\n<line66>if( v>lhs ){\n<line67>res = pPKey2->r1;\n<line68>}else if( v<lhs ){\n<line69>res = pPKey2->r2;\n<line70>}else if( pPKey2->nField>1 ){\n<line71>/* The first fields of the two keys are equal. Compare the trailing\n<line72>** fields.  */\n<line73>res = sqlite3VdbeRecordCompareWithSkip(nKey1, pKey1, pPKey2, 1);\n<line74>}else{\n<line75>/* The first fields of the two keys are equal and there are no trailing\n<line76>** fields. Return pPKey2->default_rc in this case. */\n<line77>res = pPKey2->default_rc;\n<line78>pPKey2->eqSeen = 1;\n<line79>}\n<line80>assert( vdbeRecordCompareDebug(nKey1, pKey1, pPKey2, res) );\n<line81>return res;\n<line82>}
----------------------------------------
Function: vdbeRecordCompareString
Content: <line0>static int vdbeRecordCompareString(\n<line1>int nKey1, const void *pKey1, /* Left key */\n<line2>UnpackedRecord *pPKey2        /* Right key */\n<line3>){\n<line4>const u8 *aKey1 = (const u8*)pKey1;\n<line5>int serial_type;\n<line6>int res;\n<line7>assert( pPKey2->aMem[0].flags & MEM_Str );\n<line8>assert( pPKey2->aMem[0].n == pPKey2->n );\n<line9>assert( pPKey2->aMem[0].z == pPKey2->u.z );\n<line10>vdbeAssertFieldCountWithinLimits(nKey1, pKey1, pPKey2->pKeyInfo);\n<line11>serial_type = (signed char)(aKey1[1]);\n<line12>vrcs_restart:\n<line13>if( serial_type<12 ){\n<line14>if( serial_type<0 ){\n<line15>sqlite3GetVarint32(&aKey1[1], (u32*)&serial_type);\n<line16>if( serial_type>=12 ) goto vrcs_restart;\n<line17>assert( CORRUPT_DB );\n<line18>}\n<line19>res = pPKey2->r1;      /* (pKey1/nKey1) is a number or a null */\n<line20>}else if( !(serial_type & 0x01) ){\n<line21>res = pPKey2->r2;      /* (pKey1/nKey1) is a blob */\n<line22>}else{\n<line23>int nCmp;\n<line24>int nStr;\n<line25>int szHdr = aKey1[0];\n<line26>nStr = (serial_type-12) / 2;\n<line27>if( (szHdr + nStr) > nKey1 ){\n<line28>pPKey2->errCode = (u8)SQLITE_CORRUPT_BKPT;\n<line29>return 0;    /* Corruption */\n<line30>}\n<line31>nCmp = MIN( pPKey2->n, nStr );\n<line32>res = memcmp(&aKey1[szHdr], pPKey2->u.z, nCmp);\n<line33>if( res>0 ){\n<line34>res = pPKey2->r2;\n<line35>}else if( res<0 ){\n<line36>res = pPKey2->r1;\n<line37>}else{\n<line38>res = nStr - pPKey2->n;\n<line39>if( res==0 ){\n<line40>if( pPKey2->nField>1 ){\n<line41>res = sqlite3VdbeRecordCompareWithSkip(nKey1, pKey1, pPKey2, 1);\n<line42>}else{\n<line43>res = pPKey2->default_rc;\n<line44>pPKey2->eqSeen = 1;\n<line45>}\n<line46>}else if( res>0 ){\n<line47>res = pPKey2->r2;\n<line48>}else{\n<line49>res = pPKey2->r1;\n<line50>}\n<line51>}\n<line52>}\n<line53>assert( vdbeRecordCompareDebug(nKey1, pKey1, pPKey2, res)\n<line54>|| CORRUPT_DB\n<line55>|| pPKey2->pKeyInfo->db->mallocFailed\n<line56>);\n<line57>return res;\n<line58>}
----------------------------------------
Function: sqlite3_expired
Content: <line0>SQLITE_API int sqlite3_expired(sqlite3_stmt *pStmt){\n<line1>Vdbe *p = (Vdbe*)pStmt;\n<line2>return p==0 || p->expired;\n<line3>}
----------------------------------------
Function: vdbeSafety
Content: <line0>static int vdbeSafety(Vdbe *p){\n<line1>if( p->db==0 ){\n<line2>sqlite3_log(SQLITE_MISUSE, "API called with finalized prepared statement");\n<line3>return 1;\n<line4>}else{\n<line5>return 0;\n<line6>}\n<line7>}
----------------------------------------
Function: vdbeSafetyNotNull
Content: <line0>static int vdbeSafetyNotNull(Vdbe *p){\n<line1>if( p==0 ){\n<line2>sqlite3_log(SQLITE_MISUSE, "API called with NULL prepared statement");\n<line3>return 1;\n<line4>}else{\n<line5>return vdbeSafety(p);\n<line6>}\n<line7>}
----------------------------------------
Function: invokeProfileCallback
Content: <line0>static SQLITE_NOINLINE void invokeProfileCallback(sqlite3 *db, Vdbe *p){\n<line1>sqlite3_int64 iNow;\n<line2>sqlite3_int64 iElapse;\n<line3>assert( p->startTime>0 );\n<line4>assert( db->init.busy==0 );\n<line5>assert( p->zSql!=0 );\n<line6>sqlite3OsCurrentTimeInt64(db->pVfs, &iNow);\n<line7>iElapse = (iNow - p->startTime)*1000000;\n<line8>#ifndef SQLITE_OMIT_DEPRECATED\n<line9>if( db->xProfile ){\n<line10>db->xProfile(db->pProfileArg, p->zSql, iElapse);\n<line11>}\n<line12>#endif\n<line13>if( db->mTrace & SQLITE_TRACE_PROFILE ){\n<line14>db->trace.xV2(SQLITE_TRACE_PROFILE, db->pTraceArg, p, (void*)&iElapse);\n<line15>}\n<line16>p->startTime = 0;\n<line17>}
----------------------------------------
Function: sqlite3_finalize
Content: <line0>SQLITE_API int sqlite3_finalize(sqlite3_stmt *pStmt){\n<line1>int rc;\n<line2>if( pStmt==0 ){\n<line3>/* IMPLEMENTATION-OF: R-57228-12904 Invoking sqlite3_finalize() on a NULL\n<line4>** pointer is a harmless no-op. */\n<line5>rc = SQLITE_OK;\n<line6>}else{\n<line7>Vdbe *v = (Vdbe*)pStmt;\n<line8>sqlite3 *db = v->db;\n<line9>if( vdbeSafety(v) ) return SQLITE_MISUSE_BKPT;\n<line10>sqlite3_mutex_enter(db->mutex);\n<line11>checkProfileCallback(db, v);\n<line12>assert( v->eVdbeState>=VDBE_READY_STATE );\n<line13>rc = sqlite3VdbeReset(v);\n<line14>sqlite3VdbeDelete(v);\n<line15>rc = sqlite3ApiExit(db, rc);\n<line16>sqlite3LeaveMutexAndCloseZombie(db);\n<line17>}\n<line18>return rc;\n<line19>}
----------------------------------------
Function: sqlite3_reset
Content: <line0>SQLITE_API int sqlite3_reset(sqlite3_stmt *pStmt){\n<line1>int rc;\n<line2>if( pStmt==0 ){\n<line3>rc = SQLITE_OK;\n<line4>}else{\n<line5>Vdbe *v = (Vdbe*)pStmt;\n<line6>sqlite3 *db = v->db;\n<line7>sqlite3_mutex_enter(db->mutex);\n<line8>checkProfileCallback(db, v);\n<line9>rc = sqlite3VdbeReset(v);\n<line10>sqlite3VdbeRewind(v);\n<line11>assert( (rc & (db->errMask))==rc );\n<line12>rc = sqlite3ApiExit(db, rc);\n<line13>sqlite3_mutex_leave(db->mutex);\n<line14>}\n<line15>return rc;\n<line16>}
----------------------------------------
Function: sqlite3_clear_bindings
Content: <line0>SQLITE_API int sqlite3_clear_bindings(sqlite3_stmt *pStmt){\n<line1>int i;\n<line2>int rc = SQLITE_OK;\n<line3>Vdbe *p = (Vdbe*)pStmt;\n<line4>#if SQLITE_THREADSAFE\n<line5>sqlite3_mutex *mutex;\n<line6>#endif\n<line7>#ifdef SQLITE_ENABLE_API_ARMOR\n<line8>if( pStmt==0 ){\n<line9>return SQLITE_MISUSE_BKPT;\n<line10>}\n<line11>#endif\n<line12>#if SQLITE_THREADSAFE\n<line13>mutex = p->db->mutex;\n<line14>#endif\n<line15>sqlite3_mutex_enter(mutex);\n<line16>for(i=0; i<p->nVar; i++){\n<line17>sqlite3VdbeMemRelease(&p->aVar[i]);\n<line18>p->aVar[i].flags = MEM_Null;\n<line19>}\n<line20>assert( (p->prepFlags & SQLITE_PREPARE_SAVESQL)!=0 || p->expmask==0 );\n<line21>if( p->expmask ){\n<line22>p->expired = 1;\n<line23>}\n<line24>sqlite3_mutex_leave(mutex);\n<line25>return rc;\n<line26>}
----------------------------------------
Function: sqlite3_value_blob
Content: <line0>SQLITE_API const void *sqlite3_value_blob(sqlite3_value *pVal){\n<line1>Mem *p = (Mem*)pVal;\n<line2>if( p->flags & (MEM_Blob|MEM_Str) ){\n<line3>if( ExpandBlob(p)!=SQLITE_OK ){\n<line4>assert( p->flags==MEM_Null && p->z==0 );\n<line5>return 0;\n<line6>}\n<line7>p->flags |= MEM_Blob;\n<line8>return p->n ? p->z : 0;\n<line9>}else{\n<line10>return sqlite3_value_text(pVal);\n<line11>}\n<line12>}
----------------------------------------
Function: sqlite3_value_bytes
Content: <line0>SQLITE_API int sqlite3_value_bytes(sqlite3_value *pVal){\n<line1>return sqlite3ValueBytes(pVal, SQLITE_UTF8);\n<line2>}
----------------------------------------
Function: sqlite3_value_bytes16
Content: <line0>SQLITE_API int sqlite3_value_bytes16(sqlite3_value *pVal){\n<line1>return sqlite3ValueBytes(pVal, SQLITE_UTF16NATIVE);\n<line2>}
----------------------------------------
Function: sqlite3_value_double
Content: <line0>SQLITE_API double sqlite3_value_double(sqlite3_value *pVal){\n<line1>return sqlite3VdbeRealValue((Mem*)pVal);\n<line2>}
----------------------------------------
Function: sqlite3_value_int
Content: <line0>SQLITE_API int sqlite3_value_int(sqlite3_value *pVal){\n<line1>return (int)sqlite3VdbeIntValue((Mem*)pVal);\n<line2>}
----------------------------------------
Function: sqlite3_value_int64
Content: <line0>SQLITE_API sqlite_int64 sqlite3_value_int64(sqlite3_value *pVal){\n<line1>return sqlite3VdbeIntValue((Mem*)pVal);\n<line2>}
----------------------------------------
Function: sqlite3_value_subtype
Content: <line0>SQLITE_API unsigned int sqlite3_value_subtype(sqlite3_value *pVal){\n<line1>Mem *pMem = (Mem*)pVal;\n<line2>return ((pMem->flags & MEM_Subtype) ? pMem->eSubtype : 0);\n<line3>}
----------------------------------------
Function: sqlite3_value_pointer
Content: <line0>SQLITE_API void *sqlite3_value_pointer(sqlite3_value *pVal, const char *zPType){\n<line1>Mem *p = (Mem*)pVal;\n<line2>if( (p->flags&(MEM_TypeMask|MEM_Term|MEM_Subtype)) ==\n<line3>(MEM_Null|MEM_Term|MEM_Subtype)\n<line4>&& zPType!=0\n<line5>&& p->eSubtype=='p'\n<line6>&& strcmp(p->u.zPType, zPType)==0\n<line7>){\n<line8>return (void*)p->z;\n<line9>}else{\n<line10>return 0;\n<line11>}\n<line12>}
----------------------------------------
Function: sqlite3_value_text
Content: <line0>SQLITE_API const unsigned char *sqlite3_value_text(sqlite3_value *pVal){\n<line1>return (const unsigned char *)sqlite3ValueText(pVal, SQLITE_UTF8);\n<line2>}
----------------------------------------
Function: sqlite3_value_text16
Content: <line0>SQLITE_API const void *sqlite3_value_text16(sqlite3_value* pVal){\n<line1>return sqlite3ValueText(pVal, SQLITE_UTF16NATIVE);\n<line2>}
----------------------------------------
Function: sqlite3_value_text16be
Content: <line0>SQLITE_API const void *sqlite3_value_text16be(sqlite3_value *pVal){\n<line1>return sqlite3ValueText(pVal, SQLITE_UTF16BE);\n<line2>}
----------------------------------------
Function: sqlite3_value_text16le
Content: <line0>SQLITE_API const void *sqlite3_value_text16le(sqlite3_value *pVal){\n<line1>return sqlite3ValueText(pVal, SQLITE_UTF16LE);\n<line2>}
----------------------------------------
Function: sqlite3_value_type
Content: <line0>SQLITE_API int sqlite3_value_type(sqlite3_value* pVal){\n<line1>static const u8 aType[] = {\n<line2>SQLITE_BLOB,     /* 0x00 (not possible) */\n<line3>SQLITE_NULL,     /* 0x01 NULL */\n<line4>SQLITE_TEXT,     /* 0x02 TEXT */\n<line5>SQLITE_NULL,     /* 0x03 (not possible) */\n<line6>SQLITE_INTEGER,  /* 0x04 INTEGER */\n<line7>SQLITE_NULL,     /* 0x05 (not possible) */\n<line8>SQLITE_INTEGER,  /* 0x06 INTEGER + TEXT */\n<line9>SQLITE_NULL,     /* 0x07 (not possible) */\n<line10>SQLITE_FLOAT,    /* 0x08 FLOAT */\n<line11>SQLITE_NULL,     /* 0x09 (not possible) */\n<line12>SQLITE_FLOAT,    /* 0x0a FLOAT + TEXT */\n<line13>SQLITE_NULL,     /* 0x0b (not possible) */\n<line14>SQLITE_INTEGER,  /* 0x0c (not possible) */\n<line15>SQLITE_NULL,     /* 0x0d (not possible) */\n<line16>SQLITE_INTEGER,  /* 0x0e (not possible) */\n<line17>SQLITE_NULL,     /* 0x0f (not possible) */\n<line18>SQLITE_BLOB,     /* 0x10 BLOB */\n<line19>SQLITE_NULL,     /* 0x11 (not possible) */\n<line20>SQLITE_TEXT,     /* 0x12 (not possible) */\n<line21>SQLITE_NULL,     /* 0x13 (not possible) */\n<line22>SQLITE_INTEGER,  /* 0x14 INTEGER + BLOB */\n<line23>SQLITE_NULL,     /* 0x15 (not possible) */\n<line24>SQLITE_INTEGER,  /* 0x16 (not possible) */\n<line25>SQLITE_NULL,     /* 0x17 (not possible) */\n<line26>SQLITE_FLOAT,    /* 0x18 FLOAT + BLOB */\n<line27>SQLITE_NULL,     /* 0x19 (not possible) */\n<line28>SQLITE_FLOAT,    /* 0x1a (not possible) */\n<line29>SQLITE_NULL,     /* 0x1b (not possible) */\n<line30>SQLITE_INTEGER,  /* 0x1c (not possible) */\n<line31>SQLITE_NULL,     /* 0x1d (not possible) */\n<line32>SQLITE_INTEGER,  /* 0x1e (not possible) */\n<line33>SQLITE_NULL,     /* 0x1f (not possible) */\n<line34>SQLITE_FLOAT,    /* 0x20 INTREAL */\n<line35>SQLITE_NULL,     /* 0x21 (not possible) */\n<line36>SQLITE_FLOAT,    /* 0x22 INTREAL + TEXT */\n<line37>SQLITE_NULL,     /* 0x23 (not possible) */\n<line38>SQLITE_FLOAT,    /* 0x24 (not possible) */\n<line39>SQLITE_NULL,     /* 0x25 (not possible) */\n<line40>SQLITE_FLOAT,    /* 0x26 (not possible) */\n<line41>SQLITE_NULL,     /* 0x27 (not possible) */\n<line42>SQLITE_FLOAT,    /* 0x28 (not possible) */\n<line43>SQLITE_NULL,     /* 0x29 (not possible) */\n<line44>SQLITE_FLOAT,    /* 0x2a (not possible) */\n<line45>SQLITE_NULL,     /* 0x2b (not possible) */\n<line46>SQLITE_FLOAT,    /* 0x2c (not possible) */\n<line47>SQLITE_NULL,     /* 0x2d (not possible) */\n<line48>SQLITE_FLOAT,    /* 0x2e (not possible) */\n<line49>SQLITE_NULL,     /* 0x2f (not possible) */\n<line50>SQLITE_BLOB,     /* 0x30 (not possible) */\n<line51>SQLITE_NULL,     /* 0x31 (not possible) */\n<line52>SQLITE_TEXT,     /* 0x32 (not possible) */\n<line53>SQLITE_NULL,     /* 0x33 (not possible) */\n<line54>SQLITE_FLOAT,    /* 0x34 (not possible) */\n<line55>SQLITE_NULL,     /* 0x35 (not possible) */\n<line56>SQLITE_FLOAT,    /* 0x36 (not possible) */\n<line57>SQLITE_NULL,     /* 0x37 (not possible) */\n<line58>SQLITE_FLOAT,    /* 0x38 (not possible) */\n<line59>SQLITE_NULL,     /* 0x39 (not possible) */\n<line60>SQLITE_FLOAT,    /* 0x3a (not possible) */\n<line61>SQLITE_NULL,     /* 0x3b (not possible) */\n<line62>SQLITE_FLOAT,    /* 0x3c (not possible) */\n<line63>SQLITE_NULL,     /* 0x3d (not possible) */\n<line64>SQLITE_FLOAT,    /* 0x3e (not possible) */\n<line65>SQLITE_NULL,     /* 0x3f (not possible) */\n<line66>};\n<line67>#ifdef SQLITE_DEBUG\n<line68>{\n<line69>int eType = SQLITE_BLOB;\n<line70>if( pVal->flags & MEM_Null ){\n<line71>eType = SQLITE_NULL;\n<line72>}else if( pVal->flags & (MEM_Real|MEM_IntReal) ){\n<line73>eType = SQLITE_FLOAT;\n<line74>}else if( pVal->flags & MEM_Int ){\n<line75>eType = SQLITE_INTEGER;\n<line76>}else if( pVal->flags & MEM_Str ){\n<line77>eType = SQLITE_TEXT;\n<line78>}\n<line79>assert( eType == aType[pVal->flags&MEM_AffMask] );\n<line80>}\n<line81>#endif\n<line82>return aType[pVal->flags&MEM_AffMask];\n<line83>}
----------------------------------------
Function: sqlite3_value_encoding
Content: <line0>SQLITE_API int sqlite3_value_encoding(sqlite3_value *pVal){\n<line1>return pVal->enc;\n<line2>}
----------------------------------------
Function: sqlite3_value_nochange
Content: <line0>SQLITE_API int sqlite3_value_nochange(sqlite3_value *pVal){\n<line1>return (pVal->flags&(MEM_Null|MEM_Zero))==(MEM_Null|MEM_Zero);\n<line2>}
----------------------------------------
Function: sqlite3_value_frombind
Content: <line0>SQLITE_API int sqlite3_value_frombind(sqlite3_value *pVal){\n<line1>return (pVal->flags&MEM_FromBind)!=0;\n<line2>}
----------------------------------------
Function: sqlite3_value_dup
Content: <line0>SQLITE_API sqlite3_value *sqlite3_value_dup(const sqlite3_value *pOrig){\n<line1>sqlite3_value *pNew;\n<line2>if( pOrig==0 ) return 0;\n<line3>pNew = sqlite3_malloc( sizeof(*pNew) );\n<line4>if( pNew==0 ) return 0;\n<line5>memset(pNew, 0, sizeof(*pNew));\n<line6>memcpy(pNew, pOrig, MEMCELLSIZE);\n<line7>pNew->flags &= ~MEM_Dyn;\n<line8>pNew->db = 0;\n<line9>if( pNew->flags&(MEM_Str|MEM_Blob) ){\n<line10>pNew->flags &= ~(MEM_Static|MEM_Dyn);\n<line11>pNew->flags |= MEM_Ephem;\n<line12>if( sqlite3VdbeMemMakeWriteable(pNew)!=SQLITE_OK ){\n<line13>sqlite3ValueFree(pNew);\n<line14>pNew = 0;\n<line15>}\n<line16>}else if( pNew->flags & MEM_Null ){\n<line17>/* Do not duplicate pointer values */\n<line18>pNew->flags &= ~(MEM_Term|MEM_Subtype);\n<line19>}\n<line20>return pNew;\n<line21>}
----------------------------------------
Function: sqlite3_value_free
Content: <line0>SQLITE_API void sqlite3_value_free(sqlite3_value *pOld){\n<line1>sqlite3ValueFree(pOld);\n<line2>}
----------------------------------------
Function: setResultStrOrError
Content: <line0>static void setResultStrOrError(\n<line1>sqlite3_context *pCtx,  /* Function context */\n<line2>const char *z,          /* String pointer */\n<line3>int n,                  /* Bytes in string, or negative */\n<line4>u8 enc,                 /* Encoding of z.  0 for BLOBs */\n<line5>void (*xDel)(void*)     /* Destructor function */\n<line6>){\n<line7>Mem *pOut = pCtx->pOut;\n<line8>int rc = sqlite3VdbeMemSetStr(pOut, z, n, enc, xDel);\n<line9>if( rc ){\n<line10>if( rc==SQLITE_TOOBIG ){\n<line11>sqlite3_result_error_toobig(pCtx);\n<line12>}else{\n<line13>/* The only errors possible from sqlite3VdbeMemSetStr are\n<line14>** SQLITE_TOOBIG and SQLITE_NOMEM */\n<line15>assert( rc==SQLITE_NOMEM );\n<line16>sqlite3_result_error_nomem(pCtx);\n<line17>}\n<line18>return;\n<line19>}\n<line20>sqlite3VdbeChangeEncoding(pOut, pCtx->enc);\n<line21>if( sqlite3VdbeMemTooBig(pOut) ){\n<line22>sqlite3_result_error_toobig(pCtx);\n<line23>}\n<line24>}
----------------------------------------
Function: invokeValueDestructor
Content: <line0>static int invokeValueDestructor(\n<line1>const void *p,             /* Value to destroy */\n<line2>void (*xDel)(void*),       /* The destructor */\n<line3>sqlite3_context *pCtx      /* Set a SQLITE_TOOBIG error if not NULL */\n<line4>){\n<line5>assert( xDel!=SQLITE_DYNAMIC );\n<line6>if( xDel==0 ){\n<line7>/* noop */\n<line8>}else if( xDel==SQLITE_TRANSIENT ){\n<line9>/* noop */\n<line10>}else{\n<line11>xDel((void*)p);\n<line12>}\n<line13>#ifdef SQLITE_ENABLE_API_ARMOR\n<line14>if( pCtx!=0 ){\n<line15>sqlite3_result_error_toobig(pCtx);\n<line16>}\n<line17>#else\n<line18>assert( pCtx!=0 );\n<line19>sqlite3_result_error_toobig(pCtx);\n<line20>#endif\n<line21>return SQLITE_TOOBIG;\n<line22>}
----------------------------------------
Function: sqlite3_result_blob
Content: <line0>SQLITE_API void sqlite3_result_blob(\n<line1>sqlite3_context *pCtx,\n<line2>const void *z,\n<line3>int n,\n<line4>void (*xDel)(void *)\n<line5>){\n<line6>#ifdef SQLITE_ENABLE_API_ARMOR\n<line7>if( pCtx==0 || n<0 ){\n<line8>invokeValueDestructor(z, xDel, pCtx);\n<line9>return;\n<line10>}\n<line11>#endif\n<line12>assert( n>=0 );\n<line13>assert( sqlite3_mutex_held(pCtx->pOut->db->mutex) );\n<line14>setResultStrOrError(pCtx, z, n, 0, xDel);\n<line15>}
----------------------------------------
Function: sqlite3_result_blob64
Content: <line0>SQLITE_API void sqlite3_result_blob64(\n<line1>sqlite3_context *pCtx,\n<line2>const void *z,\n<line3>sqlite3_uint64 n,\n<line4>void (*xDel)(void *)\n<line5>){\n<line6>assert( xDel!=SQLITE_DYNAMIC );\n<line7>#ifdef SQLITE_ENABLE_API_ARMOR\n<line8>if( pCtx==0 ){\n<line9>invokeValueDestructor(z, xDel, 0);\n<line10>return;\n<line11>}\n<line12>#endif\n<line13>assert( sqlite3_mutex_held(pCtx->pOut->db->mutex) );\n<line14>if( n>0x7fffffff ){\n<line15>(void)invokeValueDestructor(z, xDel, pCtx);\n<line16>}else{\n<line17>setResultStrOrError(pCtx, z, (int)n, 0, xDel);\n<line18>}\n<line19>}
----------------------------------------
Function: sqlite3_result_double
Content: <line0>SQLITE_API void sqlite3_result_double(sqlite3_context *pCtx, double rVal){\n<line1>#ifdef SQLITE_ENABLE_API_ARMOR\n<line2>if( pCtx==0 ) return;\n<line3>#endif\n<line4>assert( sqlite3_mutex_held(pCtx->pOut->db->mutex) );\n<line5>sqlite3VdbeMemSetDouble(pCtx->pOut, rVal);\n<line6>}
----------------------------------------
Function: sqlite3_result_error
Content: <line0>SQLITE_API void sqlite3_result_error(sqlite3_context *pCtx, const char *z, int n){\n<line1>#ifdef SQLITE_ENABLE_API_ARMOR\n<line2>if( pCtx==0 ) return;\n<line3>#endif\n<line4>assert( sqlite3_mutex_held(pCtx->pOut->db->mutex) );\n<line5>pCtx->isError = SQLITE_ERROR;\n<line6>sqlite3VdbeMemSetStr(pCtx->pOut, z, n, SQLITE_UTF8, SQLITE_TRANSIENT);\n<line7>}
----------------------------------------
Function: sqlite3_result_error16
Content: <line0>SQLITE_API void sqlite3_result_error16(sqlite3_context *pCtx, const void *z, int n){\n<line1>#ifdef SQLITE_ENABLE_API_ARMOR\n<line2>if( pCtx==0 ) return;\n<line3>#endif\n<line4>assert( sqlite3_mutex_held(pCtx->pOut->db->mutex) );\n<line5>pCtx->isError = SQLITE_ERROR;\n<line6>sqlite3VdbeMemSetStr(pCtx->pOut, z, n, SQLITE_UTF16NATIVE, SQLITE_TRANSIENT);\n<line7>}
----------------------------------------
Function: sqlite3_result_int
Content: <line0>SQLITE_API void sqlite3_result_int(sqlite3_context *pCtx, int iVal){\n<line1>#ifdef SQLITE_ENABLE_API_ARMOR\n<line2>if( pCtx==0 ) return;\n<line3>#endif\n<line4>assert( sqlite3_mutex_held(pCtx->pOut->db->mutex) );\n<line5>sqlite3VdbeMemSetInt64(pCtx->pOut, (i64)iVal);\n<line6>}
----------------------------------------
Function: sqlite3_result_int64
Content: <line0>SQLITE_API void sqlite3_result_int64(sqlite3_context *pCtx, i64 iVal){\n<line1>#ifdef SQLITE_ENABLE_API_ARMOR\n<line2>if( pCtx==0 ) return;\n<line3>#endif\n<line4>assert( sqlite3_mutex_held(pCtx->pOut->db->mutex) );\n<line5>sqlite3VdbeMemSetInt64(pCtx->pOut, iVal);\n<line6>}
----------------------------------------
Function: sqlite3_result_null
Content: <line0>SQLITE_API void sqlite3_result_null(sqlite3_context *pCtx){\n<line1>#ifdef SQLITE_ENABLE_API_ARMOR\n<line2>if( pCtx==0 ) return;\n<line3>#endif\n<line4>assert( sqlite3_mutex_held(pCtx->pOut->db->mutex) );\n<line5>sqlite3VdbeMemSetNull(pCtx->pOut);\n<line6>}
----------------------------------------
Function: sqlite3_result_pointer
Content: <line0>SQLITE_API void sqlite3_result_pointer(\n<line1>sqlite3_context *pCtx,\n<line2>void *pPtr,\n<line3>const char *zPType,\n<line4>void (*xDestructor)(void*)\n<line5>){\n<line6>Mem *pOut;\n<line7>#ifdef SQLITE_ENABLE_API_ARMOR\n<line8>if( pCtx==0 ){\n<line9>invokeValueDestructor(pPtr, xDestructor, 0);\n<line10>return;\n<line11>}\n<line12>#endif\n<line13>pOut = pCtx->pOut;\n<line14>assert( sqlite3_mutex_held(pOut->db->mutex) );\n<line15>sqlite3VdbeMemRelease(pOut);\n<line16>pOut->flags = MEM_Null;\n<line17>sqlite3VdbeMemSetPointer(pOut, pPtr, zPType, xDestructor);\n<line18>}
----------------------------------------
Function: sqlite3_result_subtype
Content: <line0>SQLITE_API void sqlite3_result_subtype(sqlite3_context *pCtx, unsigned int eSubtype){\n<line1>Mem *pOut;\n<line2>#ifdef SQLITE_ENABLE_API_ARMOR\n<line3>if( pCtx==0 ) return;\n<line4>#endif\n<line5>#if defined(SQLITE_STRICT_SUBTYPE) && SQLITE_STRICT_SUBTYPE+0!=0\n<line6>if( pCtx->pFunc!=0\n<line7>&& (pCtx->pFunc->funcFlags & SQLITE_RESULT_SUBTYPE)==0\n<line8>){\n<line9>char zErr[200];\n<line10>sqlite3_snprintf(sizeof(zErr), zErr,\n<line11>"misuse of sqlite3_result_subtype() by %s()",\n<line12>pCtx->pFunc->zName);\n<line13>sqlite3_result_error(pCtx, zErr, -1);\n<line14>return;\n<line15>}\n<line16>#endif /* SQLITE_STRICT_SUBTYPE */\n<line17>pOut = pCtx->pOut;\n<line18>assert( sqlite3_mutex_held(pOut->db->mutex) );\n<line19>pOut->eSubtype = eSubtype & 0xff;\n<line20>pOut->flags |= MEM_Subtype;\n<line21>}
----------------------------------------
Function: sqlite3_result_text
Content: <line0>SQLITE_API void sqlite3_result_text(\n<line1>sqlite3_context *pCtx,\n<line2>const char *z,\n<line3>int n,\n<line4>void (*xDel)(void *)\n<line5>){\n<line6>#ifdef SQLITE_ENABLE_API_ARMOR\n<line7>if( pCtx==0 ){\n<line8>invokeValueDestructor(z, xDel, 0);\n<line9>return;\n<line10>}\n<line11>#endif\n<line12>assert( sqlite3_mutex_held(pCtx->pOut->db->mutex) );\n<line13>setResultStrOrError(pCtx, z, n, SQLITE_UTF8, xDel);\n<line14>}
----------------------------------------
Function: sqlite3_result_text64
Content: <line0>SQLITE_API void sqlite3_result_text64(\n<line1>sqlite3_context *pCtx,\n<line2>const char *z,\n<line3>sqlite3_uint64 n,\n<line4>void (*xDel)(void *),\n<line5>unsigned char enc\n<line6>){\n<line7>#ifdef SQLITE_ENABLE_API_ARMOR\n<line8>if( pCtx==0 ){\n<line9>invokeValueDestructor(z, xDel, 0);\n<line10>return;\n<line11>}\n<line12>#endif\n<line13>assert( sqlite3_mutex_held(pCtx->pOut->db->mutex) );\n<line14>assert( xDel!=SQLITE_DYNAMIC );\n<line15>if( enc!=SQLITE_UTF8 ){\n<line16>if( enc==SQLITE_UTF16 ) enc = SQLITE_UTF16NATIVE;\n<line17>n &= ~(u64)1;\n<line18>}\n<line19>if( n>0x7fffffff ){\n<line20>(void)invokeValueDestructor(z, xDel, pCtx);\n<line21>}else{\n<line22>setResultStrOrError(pCtx, z, (int)n, enc, xDel);\n<line23>sqlite3VdbeMemZeroTerminateIfAble(pCtx->pOut);\n<line24>}\n<line25>}
----------------------------------------
Function: sqlite3_result_text16
Content: <line0>SQLITE_API void sqlite3_result_text16(\n<line1>sqlite3_context *pCtx,\n<line2>const void *z,\n<line3>int n,\n<line4>void (*xDel)(void *)\n<line5>){\n<line6>assert( sqlite3_mutex_held(pCtx->pOut->db->mutex) );\n<line7>setResultStrOrError(pCtx, z, n & ~(u64)1, SQLITE_UTF16NATIVE, xDel);\n<line8>}
----------------------------------------
Function: sqlite3_result_text16be
Content: <line0>SQLITE_API void sqlite3_result_text16be(\n<line1>sqlite3_context *pCtx,\n<line2>const void *z,\n<line3>int n,\n<line4>void (*xDel)(void *)\n<line5>){\n<line6>assert( sqlite3_mutex_held(pCtx->pOut->db->mutex) );\n<line7>setResultStrOrError(pCtx, z, n & ~(u64)1, SQLITE_UTF16BE, xDel);\n<line8>}
----------------------------------------
Function: sqlite3_result_text16le
Content: <line0>SQLITE_API void sqlite3_result_text16le(\n<line1>sqlite3_context *pCtx,\n<line2>const void *z,\n<line3>int n,\n<line4>void (*xDel)(void *)\n<line5>){\n<line6>assert( sqlite3_mutex_held(pCtx->pOut->db->mutex) );\n<line7>setResultStrOrError(pCtx, z, n & ~(u64)1, SQLITE_UTF16LE, xDel);\n<line8>}
----------------------------------------
Function: sqlite3_result_value
Content: <line0>SQLITE_API void sqlite3_result_value(sqlite3_context *pCtx, sqlite3_value *pValue){\n<line1>Mem *pOut;\n<line2>#ifdef SQLITE_ENABLE_API_ARMOR\n<line3>if( pCtx==0 ) return;\n<line4>if( pValue==0 ){\n<line5>sqlite3_result_null(pCtx);\n<line6>return;\n<line7>}\n<line8>#endif\n<line9>pOut = pCtx->pOut;\n<line10>assert( sqlite3_mutex_held(pCtx->pOut->db->mutex) );\n<line11>sqlite3VdbeMemCopy(pOut, pValue);\n<line12>sqlite3VdbeChangeEncoding(pOut, pCtx->enc);\n<line13>if( sqlite3VdbeMemTooBig(pOut) ){\n<line14>sqlite3_result_error_toobig(pCtx);\n<line15>}\n<line16>}
----------------------------------------
Function: sqlite3_result_zeroblob
Content: <line0>SQLITE_API void sqlite3_result_zeroblob(sqlite3_context *pCtx, int n){\n<line1>sqlite3_result_zeroblob64(pCtx, n>0 ? n : 0);\n<line2>}
----------------------------------------
Function: sqlite3_result_zeroblob64
Content: <line0>SQLITE_API int sqlite3_result_zeroblob64(sqlite3_context *pCtx, u64 n){\n<line1>Mem *pOut;\n<line2>#ifdef SQLITE_ENABLE_API_ARMOR\n<line3>if( pCtx==0 ) return SQLITE_MISUSE_BKPT;\n<line4>#endif\n<line5>pOut = pCtx->pOut;\n<line6>assert( sqlite3_mutex_held(pOut->db->mutex) );\n<line7>if( n>(u64)pOut->db->aLimit[SQLITE_LIMIT_LENGTH] ){\n<line8>sqlite3_result_error_toobig(pCtx);\n<line9>return SQLITE_TOOBIG;\n<line10>}\n<line11>#ifndef SQLITE_OMIT_INCRBLOB\n<line12>sqlite3VdbeMemSetZeroBlob(pCtx->pOut, (int)n);\n<line13>return SQLITE_OK;\n<line14>#else\n<line15>return sqlite3VdbeMemSetZeroBlob(pCtx->pOut, (int)n);\n<line16>#endif\n<line17>}
----------------------------------------
Function: sqlite3_result_error_code
Content: <line0>SQLITE_API void sqlite3_result_error_code(sqlite3_context *pCtx, int errCode){\n<line1>#ifdef SQLITE_ENABLE_API_ARMOR\n<line2>if( pCtx==0 ) return;\n<line3>#endif\n<line4>pCtx->isError = errCode ? errCode : -1;\n<line5>#ifdef SQLITE_DEBUG\n<line6>if( pCtx->pVdbe ) pCtx->pVdbe->rcApp = errCode;\n<line7>#endif\n<line8>if( pCtx->pOut->flags & MEM_Null ){\n<line9>setResultStrOrError(pCtx, sqlite3ErrStr(errCode), -1, SQLITE_UTF8,\n<line10>SQLITE_STATIC);\n<line11>}\n<line12>}
----------------------------------------
Function: sqlite3_result_error_toobig
Content: <line0>SQLITE_API void sqlite3_result_error_toobig(sqlite3_context *pCtx){\n<line1>#ifdef SQLITE_ENABLE_API_ARMOR\n<line2>if( pCtx==0 ) return;\n<line3>#endif\n<line4>assert( sqlite3_mutex_held(pCtx->pOut->db->mutex) );\n<line5>pCtx->isError = SQLITE_TOOBIG;\n<line6>sqlite3VdbeMemSetStr(pCtx->pOut, "string or blob too big", -1,\n<line7>SQLITE_UTF8, SQLITE_STATIC);\n<line8>}
----------------------------------------
Function: sqlite3_result_error_nomem
Content: <line0>SQLITE_API void sqlite3_result_error_nomem(sqlite3_context *pCtx){\n<line1>#ifdef SQLITE_ENABLE_API_ARMOR\n<line2>if( pCtx==0 ) return;\n<line3>#endif\n<line4>assert( sqlite3_mutex_held(pCtx->pOut->db->mutex) );\n<line5>sqlite3VdbeMemSetNull(pCtx->pOut);\n<line6>pCtx->isError = SQLITE_NOMEM_BKPT;\n<line7>sqlite3OomFault(pCtx->pOut->db);\n<line8>}
----------------------------------------
Function: doWalCallbacks
Content: <line0>static int doWalCallbacks(sqlite3 *db){\n<line1>int rc = SQLITE_OK;\n<line2>#ifndef SQLITE_OMIT_WAL\n<line3>int i;\n<line4>for(i=0; i<db->nDb; i++){\n<line5>Btree *pBt = db->aDb[i].pBt;\n<line6>if( pBt ){\n<line7>int nEntry;\n<line8>sqlite3BtreeEnter(pBt);\n<line9>nEntry = sqlite3PagerWalCallback(sqlite3BtreePager(pBt));\n<line10>sqlite3BtreeLeave(pBt);\n<line11>if( nEntry>0 && db->xWalCallback && rc==SQLITE_OK ){\n<line12>rc = db->xWalCallback(db->pWalArg, db, db->aDb[i].zDbSName, nEntry);\n<line13>}\n<line14>}\n<line15>}\n<line16>#endif\n<line17>return rc;\n<line18>}
----------------------------------------
Function: sqlite3Step
Content: <line0>static int sqlite3Step(Vdbe *p){\n<line1>sqlite3 *db;\n<line2>int rc;\n<line3>assert(p);\n<line4>db = p->db;\n<line5>if( p->eVdbeState!=VDBE_RUN_STATE ){\n<line6>restart_step:\n<line7>if( p->eVdbeState==VDBE_READY_STATE ){\n<line8>if( p->expired ){\n<line9>p->rc = SQLITE_SCHEMA;\n<line10>rc = SQLITE_ERROR;\n<line11>if( (p->prepFlags & SQLITE_PREPARE_SAVESQL)!=0 ){\n<line12>/* If this statement was prepared using saved SQL and an\n<line13>** error has occurred, then return the error code in p->rc to the\n<line14>** caller. Set the error code in the database handle to the same\n<line15>** value.\n<line16>*/\n<line17>rc = sqlite3VdbeTransferError(p);\n<line18>}\n<line19>goto end_of_step;\n<line20>}\n<line21>/* If there are no other statements currently running, then\n<line22>** reset the interrupt flag.  This prevents a call to sqlite3_interrupt\n<line23>** from interrupting a statement that has not yet started.\n<line24>*/\n<line25>if( db->nVdbeActive==0 ){\n<line26>AtomicStore(&db->u1.isInterrupted, 0);\n<line27>}\n<line28>assert( db->nVdbeWrite>0 || db->autoCommit==0\n<line29>|| ((db->nDeferredCons + db->nDeferredImmCons)==0)\n<line30>);\n<line31>#ifndef SQLITE_OMIT_TRACE\n<line32>if( (db->mTrace & (SQLITE_TRACE_PROFILE|SQLITE_TRACE_XPROFILE))!=0\n<line33>&& !db->init.busy && p->zSql ){\n<line34>sqlite3OsCurrentTimeInt64(db->pVfs, &p->startTime);\n<line35>}else{\n<line36>assert( p->startTime==0 );\n<line37>}\n<line38>#endif\n<line39>db->nVdbeActive++;\n<line40>if( p->readOnly==0 ) db->nVdbeWrite++;\n<line41>if( p->bIsReader ) db->nVdbeRead++;\n<line42>p->pc = 0;\n<line43>p->eVdbeState = VDBE_RUN_STATE;\n<line44>}else\n<line45>if( ALWAYS(p->eVdbeState==VDBE_HALT_STATE) ){\n<line46>/* We used to require that sqlite3_reset() be called before retrying\n<line47>** sqlite3_step() after any error or after SQLITE_DONE.  But beginning\n<line48>** with version 3.7.0, we changed this so that sqlite3_reset() would\n<line49>** be called automatically instead of throwing the SQLITE_MISUSE error.\n<line50>** This "automatic-reset" change is not technically an incompatibility,\n<line51>** since any application that receives an SQLITE_MISUSE is broken by\n<line52>** definition.\n<line53>**\n<line54>** Nevertheless, some published applications that were originally written\n<line55>** for version 3.6.23 or earlier do in fact depend on SQLITE_MISUSE\n<line56>** returns, and those were broken by the automatic-reset change.  As a\n<line57>** a work-around, the SQLITE_OMIT_AUTORESET compile-time restores the\n<line58>** legacy behavior of returning SQLITE_MISUSE for cases where the\n<line59>** previous sqlite3_step() returned something other than a SQLITE_LOCKED\n<line60>** or SQLITE_BUSY error.\n<line61>*/\n<line62>#ifdef SQLITE_OMIT_AUTORESET\n<line63>if( (rc = p->rc&0xff)==SQLITE_BUSY || rc==SQLITE_LOCKED ){\n<line64>sqlite3_reset((sqlite3_stmt*)p);\n<line65>}else{\n<line66>return SQLITE_MISUSE_BKPT;\n<line67>}\n<line68>#else\n<line69>sqlite3_reset((sqlite3_stmt*)p);\n<line70>#endif\n<line71>assert( p->eVdbeState==VDBE_READY_STATE );\n<line72>goto restart_step;\n<line73>}\n<line74>}\n<line75>#ifdef SQLITE_DEBUG\n<line76>p->rcApp = SQLITE_OK;\n<line77>#endif\n<line78>#ifndef SQLITE_OMIT_EXPLAIN\n<line79>if( p->explain ){\n<line80>rc = sqlite3VdbeList(p);\n<line81>}else\n<line82>#endif /* SQLITE_OMIT_EXPLAIN */\n<line83>{\n<line84>db->nVdbeExec++;\n<line85>rc = sqlite3VdbeExec(p);\n<line86>db->nVdbeExec--;\n<line87>}\n<line88>if( rc==SQLITE_ROW ){\n<line89>assert( p->rc==SQLITE_OK );\n<line90>assert( db->mallocFailed==0 );\n<line91>db->errCode = SQLITE_ROW;\n<line92>return SQLITE_ROW;\n<line93>}else{\n<line94>#ifndef SQLITE_OMIT_TRACE\n<line95>/* If the statement completed successfully, invoke the profile callback */\n<line96>checkProfileCallback(db, p);\n<line97>#endif\n<line98>p->pResultRow = 0;\n<line99>if( rc==SQLITE_DONE && db->autoCommit ){\n<line100>assert( p->rc==SQLITE_OK );\n<line101>p->rc = doWalCallbacks(db);\n<line102>if( p->rc!=SQLITE_OK ){\n<line103>rc = SQLITE_ERROR;\n<line104>}\n<line105>}else if( rc!=SQLITE_DONE && (p->prepFlags & SQLITE_PREPARE_SAVESQL)!=0 ){\n<line106>/* If this statement was prepared using saved SQL and an\n<line107>** error has occurred, then return the error code in p->rc to the\n<line108>** caller. Set the error code in the database handle to the same value.\n<line109>*/\n<line110>rc = sqlite3VdbeTransferError(p);\n<line111>}\n<line112>}\n<line113>db->errCode = rc;\n<line114>if( SQLITE_NOMEM==sqlite3ApiExit(p->db, p->rc) ){\n<line115>p->rc = SQLITE_NOMEM_BKPT;\n<line116>if( (p->prepFlags & SQLITE_PREPARE_SAVESQL)!=0 ) rc = p->rc;\n<line117>}\n<line118>end_of_step:\n<line119>/* There are only a limited number of result codes allowed from the\n<line120>** statements prepared using the legacy sqlite3_prepare() interface */\n<line121>assert( (p->prepFlags & SQLITE_PREPARE_SAVESQL)!=0\n<line122>|| rc==SQLITE_ROW  || rc==SQLITE_DONE   || rc==SQLITE_ERROR\n<line123>|| (rc&0xff)==SQLITE_BUSY || rc==SQLITE_MISUSE\n<line124>);\n<line125>return (rc&db->errMask);\n<line126>}
----------------------------------------
Function: sqlite3_step
Content: <line0>SQLITE_API int sqlite3_step(sqlite3_stmt *pStmt){\n<line1>int rc = SQLITE_OK;      /* Result from sqlite3Step() */\n<line2>Vdbe *v = (Vdbe*)pStmt;  /* the prepared statement */\n<line3>int cnt = 0;             /* Counter to prevent infinite loop of reprepares */\n<line4>sqlite3 *db;             /* The database connection */\n<line5>if( vdbeSafetyNotNull(v) ){\n<line6>return SQLITE_MISUSE_BKPT;\n<line7>}\n<line8>db = v->db;\n<line9>sqlite3_mutex_enter(db->mutex);\n<line10>while( (rc = sqlite3Step(v))==SQLITE_SCHEMA\n<line11>&& cnt++ < SQLITE_MAX_SCHEMA_RETRY ){\n<line12>int savedPc = v->pc;\n<line13>rc = sqlite3Reprepare(v);\n<line14>if( rc!=SQLITE_OK ){\n<line15>/* This case occurs after failing to recompile an sql statement.\n<line16>** The error message from the SQL compiler has already been loaded\n<line17>** into the database handle. This block copies the error message\n<line18>** from the database handle into the statement and sets the statement\n<line19>** program counter to 0 to ensure that when the statement is\n<line20>** finalized or reset the parser error message is available via\n<line21>** sqlite3_errmsg() and sqlite3_errcode().\n<line22>*/\n<line23>const char *zErr = (const char *)sqlite3_value_text(db->pErr);\n<line24>sqlite3DbFree(db, v->zErrMsg);\n<line25>if( !db->mallocFailed ){\n<line26>v->zErrMsg = sqlite3DbStrDup(db, zErr);\n<line27>v->rc = rc = sqlite3ApiExit(db, rc);\n<line28>} else {\n<line29>v->zErrMsg = 0;\n<line30>v->rc = rc = SQLITE_NOMEM_BKPT;\n<line31>}\n<line32>break;\n<line33>}\n<line34>sqlite3_reset(pStmt);\n<line35>if( savedPc>=0 ){\n<line36>/* Setting minWriteFileFormat to 254 is a signal to the OP_Init and\n<line37>** OP_Trace opcodes to *not* perform SQLITE_TRACE_STMT because it has\n<line38>** already been done once on a prior invocation that failed due to\n<line39>** SQLITE_SCHEMA.   tag-20220401a  */\n<line40>v->minWriteFileFormat = 254;\n<line41>}\n<line42>assert( v->expired==0 );\n<line43>}\n<line44>sqlite3_mutex_leave(db->mutex);\n<line45>return rc;\n<line46>}
----------------------------------------
Function: sqlite3_user_data
Content: <line0>SQLITE_API void *sqlite3_user_data(sqlite3_context *p){\n<line1>#ifdef SQLITE_ENABLE_API_ARMOR\n<line2>if( p==0 ) return 0;\n<line3>#endif\n<line4>assert( p && p->pFunc );\n<line5>return p->pFunc->pUserData;\n<line6>}
----------------------------------------
Function: sqlite3_context_db_handle
Content: <line0>SQLITE_API sqlite3 *sqlite3_context_db_handle(sqlite3_context *p){\n<line1>#ifdef SQLITE_ENABLE_API_ARMOR\n<line2>if( p==0 ) return 0;\n<line3>#else\n<line4>assert( p && p->pOut );\n<line5>#endif\n<line6>return p->pOut->db;\n<line7>}
----------------------------------------
Function: sqlite3_vtab_nochange
Content: <line0>SQLITE_API int sqlite3_vtab_nochange(sqlite3_context *p){\n<line1>#ifdef SQLITE_ENABLE_API_ARMOR\n<line2>if( p==0 ) return 0;\n<line3>#else\n<line4>assert( p );\n<line5>#endif\n<line6>return sqlite3_value_nochange(p->pOut);\n<line7>}
----------------------------------------
Function: valueFromValueList
Content: <line0>static int valueFromValueList(\n<line1>sqlite3_value *pVal,        /* Pointer to the ValueList object */\n<line2>sqlite3_value **ppOut,      /* Store the next value from the list here */\n<line3>int bNext                   /* 1 for _next(). 0 for _first() */\n<line4>){\n<line5>int rc;\n<line6>ValueList *pRhs;\n<line7>*ppOut = 0;\n<line8>if( pVal==0 ) return SQLITE_MISUSE_BKPT;\n<line9>if( (pVal->flags & MEM_Dyn)==0 || pVal->xDel!=sqlite3VdbeValueListFree ){\n<line10>return SQLITE_ERROR;\n<line11>}else{\n<line12>assert( (pVal->flags&(MEM_TypeMask|MEM_Term|MEM_Subtype)) ==\n<line13>(MEM_Null|MEM_Term|MEM_Subtype) );\n<line14>assert( pVal->eSubtype=='p' );\n<line15>assert( pVal->u.zPType!=0 && strcmp(pVal->u.zPType,"ValueList")==0 );\n<line16>pRhs = (ValueList*)pVal->z;\n<line17>}\n<line18>if( bNext ){\n<line19>rc = sqlite3BtreeNext(pRhs->pCsr, 0);\n<line20>}else{\n<line21>int dummy = 0;\n<line22>rc = sqlite3BtreeFirst(pRhs->pCsr, &dummy);\n<line23>assert( rc==SQLITE_OK || sqlite3BtreeEof(pRhs->pCsr) );\n<line24>if( sqlite3BtreeEof(pRhs->pCsr) ) rc = SQLITE_DONE;\n<line25>}\n<line26>if( rc==SQLITE_OK ){\n<line27>u32 sz;       /* Size of current row in bytes */\n<line28>Mem sMem;     /* Raw content of current row */\n<line29>memset(&sMem, 0, sizeof(sMem));\n<line30>sz = sqlite3BtreePayloadSize(pRhs->pCsr);\n<line31>rc = sqlite3VdbeMemFromBtreeZeroOffset(pRhs->pCsr,(int)sz,&sMem);\n<line32>if( rc==SQLITE_OK ){\n<line33>u8 *zBuf = (u8*)sMem.z;\n<line34>u32 iSerial;\n<line35>sqlite3_value *pOut = pRhs->pOut;\n<line36>int iOff = 1 + getVarint32(&zBuf[1], iSerial);\n<line37>sqlite3VdbeSerialGet(&zBuf[iOff], iSerial, pOut);\n<line38>pOut->enc = ENC(pOut->db);\n<line39>if( (pOut->flags & MEM_Ephem)!=0 && sqlite3VdbeMemMakeWriteable(pOut) ){\n<line40>rc = SQLITE_NOMEM;\n<line41>}else{\n<line42>*ppOut = pOut;\n<line43>}\n<line44>}\n<line45>sqlite3VdbeMemRelease(&sMem);\n<line46>}\n<line47>return rc;\n<line48>}
----------------------------------------
Function: sqlite3_vtab_in_first
Content: <line0>SQLITE_API int sqlite3_vtab_in_first(sqlite3_value *pVal, sqlite3_value **ppOut){\n<line1>return valueFromValueList(pVal, ppOut, 0);\n<line2>}
----------------------------------------
Function: sqlite3_vtab_in_next
Content: <line0>SQLITE_API int sqlite3_vtab_in_next(sqlite3_value *pVal, sqlite3_value **ppOut){\n<line1>return valueFromValueList(pVal, ppOut, 1);\n<line2>}
----------------------------------------
Function: createAggContext
Content: <line0>static SQLITE_NOINLINE void *createAggContext(sqlite3_context *p, int nByte){\n<line1>Mem *pMem = p->pMem;\n<line2>assert( (pMem->flags & MEM_Agg)==0 );\n<line3>if( nByte<=0 ){\n<line4>sqlite3VdbeMemSetNull(pMem);\n<line5>pMem->z = 0;\n<line6>}else{\n<line7>sqlite3VdbeMemClearAndResize(pMem, nByte);\n<line8>pMem->flags = MEM_Agg;\n<line9>pMem->u.pDef = p->pFunc;\n<line10>if( pMem->z ){\n<line11>memset(pMem->z, 0, nByte);\n<line12>}\n<line13>}\n<line14>return (void*)pMem->z;\n<line15>}
----------------------------------------
Function: sqlite3_aggregate_context
Content: <line0>SQLITE_API void *sqlite3_aggregate_context(sqlite3_context *p, int nByte){\n<line1>assert( p && p->pFunc && p->pFunc->xFinalize );\n<line2>assert( sqlite3_mutex_held(p->pOut->db->mutex) );\n<line3>testcase( nByte<0 );\n<line4>if( (p->pMem->flags & MEM_Agg)==0 ){\n<line5>return createAggContext(p, nByte);\n<line6>}else{\n<line7>return (void*)p->pMem->z;\n<line8>}\n<line9>}
----------------------------------------
Function: sqlite3_get_auxdata
Content: <line0>SQLITE_API void *sqlite3_get_auxdata(sqlite3_context *pCtx, int iArg){\n<line1>AuxData *pAuxData;\n<line2>#ifdef SQLITE_ENABLE_API_ARMOR\n<line3>if( pCtx==0 ) return 0;\n<line4>#endif\n<line5>assert( sqlite3_mutex_held(pCtx->pOut->db->mutex) );\n<line6>#if SQLITE_ENABLE_STAT4\n<line7>if( pCtx->pVdbe==0 ) return 0;\n<line8>#else\n<line9>assert( pCtx->pVdbe!=0 );\n<line10>#endif\n<line11>for(pAuxData=pCtx->pVdbe->pAuxData; pAuxData; pAuxData=pAuxData->pNextAux){\n<line12>if(  pAuxData->iAuxArg==iArg && (pAuxData->iAuxOp==pCtx->iOp || iArg<0) ){\n<line13>return pAuxData->pAux;\n<line14>}\n<line15>}\n<line16>return 0;\n<line17>}
----------------------------------------
Function: sqlite3_set_auxdata
Content: <line0>SQLITE_API void sqlite3_set_auxdata(\n<line1>sqlite3_context *pCtx,\n<line2>int iArg,\n<line3>void *pAux,\n<line4>void (*xDelete)(void*)\n<line5>){\n<line6>AuxData *pAuxData;\n<line7>Vdbe *pVdbe;\n<line8>#ifdef SQLITE_ENABLE_API_ARMOR\n<line9>if( pCtx==0 ) return;\n<line10>#endif\n<line11>pVdbe= pCtx->pVdbe;\n<line12>assert( sqlite3_mutex_held(pCtx->pOut->db->mutex) );\n<line13>#ifdef SQLITE_ENABLE_STAT4\n<line14>if( pVdbe==0 ) goto failed;\n<line15>#else\n<line16>assert( pVdbe!=0 );\n<line17>#endif\n<line18>for(pAuxData=pVdbe->pAuxData; pAuxData; pAuxData=pAuxData->pNextAux){\n<line19>if( pAuxData->iAuxArg==iArg && (pAuxData->iAuxOp==pCtx->iOp || iArg<0) ){\n<line20>break;\n<line21>}\n<line22>}\n<line23>if( pAuxData==0 ){\n<line24>pAuxData = sqlite3DbMallocZero(pVdbe->db, sizeof(AuxData));\n<line25>if( !pAuxData ) goto failed;\n<line26>pAuxData->iAuxOp = pCtx->iOp;\n<line27>pAuxData->iAuxArg = iArg;\n<line28>pAuxData->pNextAux = pVdbe->pAuxData;\n<line29>pVdbe->pAuxData = pAuxData;\n<line30>if( pCtx->isError==0 ) pCtx->isError = -1;\n<line31>}else if( pAuxData->xDeleteAux ){\n<line32>pAuxData->xDeleteAux(pAuxData->pAux);\n<line33>}\n<line34>pAuxData->pAux = pAux;\n<line35>pAuxData->xDeleteAux = xDelete;\n<line36>return;\n<line37>failed:\n<line38>if( xDelete ){\n<line39>xDelete(pAux);\n<line40>}\n<line41>}
----------------------------------------
Function: sqlite3_aggregate_count
Content: <line0>SQLITE_API int sqlite3_aggregate_count(sqlite3_context *p){\n<line1>assert( p && p->pMem && p->pFunc && p->pFunc->xFinalize );\n<line2>return p->pMem->n;\n<line3>}
----------------------------------------
Function: sqlite3_column_count
Content: <line0>SQLITE_API int sqlite3_column_count(sqlite3_stmt *pStmt){\n<line1>Vdbe *pVm = (Vdbe *)pStmt;\n<line2>if( pVm==0 ) return 0;\n<line3>return pVm->nResColumn;\n<line4>}
----------------------------------------
Function: sqlite3_data_count
Content: <line0>SQLITE_API int sqlite3_data_count(sqlite3_stmt *pStmt){\n<line1>Vdbe *pVm = (Vdbe *)pStmt;\n<line2>if( pVm==0 || pVm->pResultRow==0 ) return 0;\n<line3>return pVm->nResColumn;\n<line4>}
----------------------------------------
Function: columnNullValue
Content: <line0>static const Mem *columnNullValue(void){\n<line1>/* Even though the Mem structure contains an element\n<line2>** of type i64, on certain architectures (x86) with certain compiler\n<line3>** switches (-Os), gcc may align this Mem object on a 4-byte boundary\n<line4>** instead of an 8-byte one. This all works fine, except that when\n<line5>** running with SQLITE_DEBUG defined the SQLite code sometimes assert()s\n<line6>** that a Mem structure is located on an 8-byte boundary. To prevent\n<line7>** these assert()s from failing, when building with SQLITE_DEBUG defined\n<line8>** using gcc, we force nullMem to be 8-byte aligned using the magical\n<line9>** __attribute__((aligned(8))) macro.  */\n<line10>static const Mem nullMem\n<line11>#if defined(SQLITE_DEBUG) && defined(__GNUC__)\n<line12>__attribute__((aligned(8)))\n<line13>#endif\n<line14>= {\n<line15>/* .u          = */ {0},\n<line16>/* .z          = */ (char*)0,\n<line17>/* .n          = */ (int)0,\n<line18>/* .flags      = */ (u16)MEM_Null,\n<line19>/* .enc        = */ (u8)0,\n<line20>/* .eSubtype   = */ (u8)0,\n<line21>/* .db         = */ (sqlite3*)0,\n<line22>/* .szMalloc   = */ (int)0,\n<line23>/* .uTemp      = */ (u32)0,\n<line24>/* .zMalloc    = */ (char*)0,\n<line25>/* .xDel       = */ (void(*)(void*))0,\n<line26>#ifdef SQLITE_DEBUG\n<line27>/* .pScopyFrom = */ (Mem*)0,\n<line28>/* .mScopyFlags= */ 0,\n<line29>/* .bScopy     = */ 0,\n<line30>#endif\n<line31>};\n<line32>return &nullMem;\n<line33>}
----------------------------------------
Function: columnMem
Content: <line0>static Mem *columnMem(sqlite3_stmt *pStmt, int i){\n<line1>Vdbe *pVm;\n<line2>Mem *pOut;\n<line3>pVm = (Vdbe *)pStmt;\n<line4>if( pVm==0 ) return (Mem*)columnNullValue();\n<line5>assert( pVm->db );\n<line6>sqlite3_mutex_enter(pVm->db->mutex);\n<line7>if( pVm->pResultRow!=0 && i<pVm->nResColumn && i>=0 ){\n<line8>pOut = &pVm->pResultRow[i];\n<line9>}else{\n<line10>sqlite3Error(pVm->db, SQLITE_RANGE);\n<line11>pOut = (Mem*)columnNullValue();\n<line12>}\n<line13>return pOut;\n<line14>}
----------------------------------------
Function: columnMallocFailure
Content: <line0>static void columnMallocFailure(sqlite3_stmt *pStmt)\n<line1>{\n<line2>/* If malloc() failed during an encoding conversion within an\n<line3>** sqlite3_column_XXX API, then set the return code of the statement to\n<line4>** SQLITE_NOMEM. The next call to _step() (if any) will return SQLITE_ERROR\n<line5>** and _finalize() will return NOMEM.\n<line6>*/\n<line7>Vdbe *p = (Vdbe *)pStmt;\n<line8>if( p ){\n<line9>assert( p->db!=0 );\n<line10>assert( sqlite3_mutex_held(p->db->mutex) );\n<line11>p->rc = sqlite3ApiExit(p->db, p->rc);\n<line12>sqlite3_mutex_leave(p->db->mutex);\n<line13>}\n<line14>}
----------------------------------------
Function: sqlite3_column_blob
Content: <line0>SQLITE_API const void *sqlite3_column_blob(sqlite3_stmt *pStmt, int i){\n<line1>const void *val;\n<line2>val = sqlite3_value_blob( columnMem(pStmt,i) );\n<line3>/* Even though there is no encoding conversion, value_blob() might\n<line4>** need to call malloc() to expand the result of a zeroblob()\n<line5>** expression.\n<line6>*/\n<line7>columnMallocFailure(pStmt);\n<line8>return val;\n<line9>}
----------------------------------------
Function: sqlite3_column_bytes
Content: <line0>SQLITE_API int sqlite3_column_bytes(sqlite3_stmt *pStmt, int i){\n<line1>int val = sqlite3_value_bytes( columnMem(pStmt,i) );\n<line2>columnMallocFailure(pStmt);\n<line3>return val;\n<line4>}
----------------------------------------
Function: sqlite3_column_bytes16
Content: <line0>SQLITE_API int sqlite3_column_bytes16(sqlite3_stmt *pStmt, int i){\n<line1>int val = sqlite3_value_bytes16( columnMem(pStmt,i) );\n<line2>columnMallocFailure(pStmt);\n<line3>return val;\n<line4>}
----------------------------------------
Function: sqlite3_column_double
Content: <line0>SQLITE_API double sqlite3_column_double(sqlite3_stmt *pStmt, int i){\n<line1>double val = sqlite3_value_double( columnMem(pStmt,i) );\n<line2>columnMallocFailure(pStmt);\n<line3>return val;\n<line4>}
----------------------------------------
Function: sqlite3_column_int
Content: <line0>SQLITE_API int sqlite3_column_int(sqlite3_stmt *pStmt, int i){\n<line1>int val = sqlite3_value_int( columnMem(pStmt,i) );\n<line2>columnMallocFailure(pStmt);\n<line3>return val;\n<line4>}
----------------------------------------
Function: sqlite3_column_int64
Content: <line0>SQLITE_API sqlite_int64 sqlite3_column_int64(sqlite3_stmt *pStmt, int i){\n<line1>sqlite_int64 val = sqlite3_value_int64( columnMem(pStmt,i) );\n<line2>columnMallocFailure(pStmt);\n<line3>return val;\n<line4>}
----------------------------------------
Function: sqlite3_column_text
Content: <line0>SQLITE_API const unsigned char *sqlite3_column_text(sqlite3_stmt *pStmt, int i){\n<line1>const unsigned char *val = sqlite3_value_text( columnMem(pStmt,i) );\n<line2>columnMallocFailure(pStmt);\n<line3>return val;\n<line4>}
----------------------------------------
Function: sqlite3_column_value
Content: <line0>SQLITE_API sqlite3_value *sqlite3_column_value(sqlite3_stmt *pStmt, int i){\n<line1>Mem *pOut = columnMem(pStmt, i);\n<line2>if( pOut->flags&MEM_Static ){\n<line3>pOut->flags &= ~MEM_Static;\n<line4>pOut->flags |= MEM_Ephem;\n<line5>}\n<line6>columnMallocFailure(pStmt);\n<line7>return (sqlite3_value *)pOut;\n<line8>}
----------------------------------------
Function: sqlite3_column_text16
Content: <line0>SQLITE_API const void *sqlite3_column_text16(sqlite3_stmt *pStmt, int i){\n<line1>const void *val = sqlite3_value_text16( columnMem(pStmt,i) );\n<line2>columnMallocFailure(pStmt);\n<line3>return val;\n<line4>}
----------------------------------------
Function: sqlite3_column_type
Content: <line0>SQLITE_API int sqlite3_column_type(sqlite3_stmt *pStmt, int i){\n<line1>int iType = sqlite3_value_type( columnMem(pStmt,i) );\n<line2>columnMallocFailure(pStmt);\n<line3>return iType;\n<line4>}
----------------------------------------
Function: columnName
Content: <line0>static const void *columnName(\n<line1>sqlite3_stmt *pStmt,     /* The statement */\n<line2>int N,                   /* Which column to get the name for */\n<line3>int useUtf16,            /* True to return the name as UTF16 */\n<line4>int useType              /* What type of name */\n<line5>){\n<line6>const void *ret;\n<line7>Vdbe *p;\n<line8>int n;\n<line9>sqlite3 *db;\n<line10>#ifdef SQLITE_ENABLE_API_ARMOR\n<line11>if( pStmt==0 ){\n<line12>(void)SQLITE_MISUSE_BKPT;\n<line13>return 0;\n<line14>}\n<line15>#endif\n<line16>if( N<0 ) return 0;\n<line17>ret = 0;\n<line18>p = (Vdbe *)pStmt;\n<line19>db = p->db;\n<line20>assert( db!=0 );\n<line21>sqlite3_mutex_enter(db->mutex);\n<line22>if( p->explain ){\n<line23>if( useType>0 ) goto columnName_end;\n<line24>n = p->explain==1 ? 8 : 4;\n<line25>if( N>=n ) goto columnName_end;\n<line26>if( useUtf16 ){\n<line27>int i = iExplainColNames16[N + 8*p->explain - 8];\n<line28>ret = (void*)&azExplainColNames16data[i];\n<line29>}else{\n<line30>ret = (void*)azExplainColNames8[N + 8*p->explain - 8];\n<line31>}\n<line32>goto columnName_end;\n<line33>}\n<line34>n = p->nResColumn;\n<line35>if( N<n ){\n<line36>u8 prior_mallocFailed = db->mallocFailed;\n<line37>N += useType*n;\n<line38>#ifndef SQLITE_OMIT_UTF16\n<line39>if( useUtf16 ){\n<line40>ret = sqlite3_value_text16((sqlite3_value*)&p->aColName[N]);\n<line41>}else\n<line42>#endif\n<line43>{\n<line44>ret = sqlite3_value_text((sqlite3_value*)&p->aColName[N]);\n<line45>}\n<line46>/* A malloc may have failed inside of the _text() call. If this\n<line47>** is the case, clear the mallocFailed flag and return NULL.\n<line48>*/\n<line49>assert( db->mallocFailed==0 || db->mallocFailed==1 );\n<line50>if( db->mallocFailed > prior_mallocFailed ){\n<line51>sqlite3OomClear(db);\n<line52>ret = 0;\n<line53>}\n<line54>}\n<line55>columnName_end:\n<line56>sqlite3_mutex_leave(db->mutex);\n<line57>return ret;\n<line58>}
----------------------------------------
Function: sqlite3_column_name
Content: <line0>SQLITE_API const char *sqlite3_column_name(sqlite3_stmt *pStmt, int N){\n<line1>return columnName(pStmt, N, 0, COLNAME_NAME);\n<line2>}
----------------------------------------
Function: sqlite3_column_name16
Content: <line0>SQLITE_API const void *sqlite3_column_name16(sqlite3_stmt *pStmt, int N){\n<line1>return columnName(pStmt, N, 1, COLNAME_NAME);\n<line2>}
----------------------------------------
Function: sqlite3_column_decltype
Content: <line0>SQLITE_API const char *sqlite3_column_decltype(sqlite3_stmt *pStmt, int N){\n<line1>return columnName(pStmt, N, 0, COLNAME_DECLTYPE);\n<line2>}
----------------------------------------
Function: sqlite3_column_decltype16
Content: <line0>SQLITE_API const void *sqlite3_column_decltype16(sqlite3_stmt *pStmt, int N){\n<line1>return columnName(pStmt, N, 1, COLNAME_DECLTYPE);\n<line2>}
----------------------------------------
Function: vdbeUnbind
Content: <line0>static int vdbeUnbind(Vdbe *p, unsigned int i){\n<line1>Mem *pVar;\n<line2>if( vdbeSafetyNotNull(p) ){\n<line3>return SQLITE_MISUSE_BKPT;\n<line4>}\n<line5>sqlite3_mutex_enter(p->db->mutex);\n<line6>if( p->eVdbeState!=VDBE_READY_STATE ){\n<line7>sqlite3Error(p->db, SQLITE_MISUSE_BKPT);\n<line8>sqlite3_mutex_leave(p->db->mutex);\n<line9>sqlite3_log(SQLITE_MISUSE,\n<line10>"bind on a busy prepared statement: [%s]", p->zSql);\n<line11>return SQLITE_MISUSE_BKPT;\n<line12>}\n<line13>if( i>=(unsigned int)p->nVar ){\n<line14>sqlite3Error(p->db, SQLITE_RANGE);\n<line15>sqlite3_mutex_leave(p->db->mutex);\n<line16>return SQLITE_RANGE;\n<line17>}\n<line18>pVar = &p->aVar[i];\n<line19>sqlite3VdbeMemRelease(pVar);\n<line20>pVar->flags = MEM_Null;\n<line21>p->db->errCode = SQLITE_OK;\n<line22>/* If the bit corresponding to this variable in Vdbe.expmask is set, then\n<line23>** binding a new value to this variable invalidates the current query plan.\n<line24>**\n<line25>** IMPLEMENTATION-OF: R-57496-20354 If the specific value bound to a host\n<line26>** parameter in the WHERE clause might influence the choice of query plan\n<line27>** for a statement, then the statement will be automatically recompiled,\n<line28>** as if there had been a schema change, on the first sqlite3_step() call\n<line29>** following any change to the bindings of that parameter.\n<line30>*/\n<line31>assert( (p->prepFlags & SQLITE_PREPARE_SAVESQL)!=0 || p->expmask==0 );\n<line32>if( p->expmask!=0 && (p->expmask & (i>=31 ? 0x80000000 : (u32)1<<i))!=0 ){\n<line33>p->expired = 1;\n<line34>}\n<line35>return SQLITE_OK;\n<line36>}
----------------------------------------
Function: bindText
Content: <line0>static int bindText(\n<line1>sqlite3_stmt *pStmt,   /* The statement to bind against */\n<line2>int i,                 /* Index of the parameter to bind */\n<line3>const void *zData,     /* Pointer to the data to be bound */\n<line4>i64 nData,             /* Number of bytes of data to be bound */\n<line5>void (*xDel)(void*),   /* Destructor for the data */\n<line6>u8 encoding            /* Encoding for the data */\n<line7>){\n<line8>Vdbe *p = (Vdbe *)pStmt;\n<line9>Mem *pVar;\n<line10>int rc;\n<line11>rc = vdbeUnbind(p, (u32)(i-1));\n<line12>if( rc==SQLITE_OK ){\n<line13>assert( p!=0 && p->aVar!=0 && i>0 && i<=p->nVar ); /* tag-20240917-01 */\n<line14>if( zData!=0 ){\n<line15>pVar = &p->aVar[i-1];\n<line16>rc = sqlite3VdbeMemSetStr(pVar, zData, nData, encoding, xDel);\n<line17>if( rc==SQLITE_OK ){\n<line18>if( encoding==0 ){\n<line19>pVar->enc = ENC(p->db);\n<line20>}else{\n<line21>rc = sqlite3VdbeChangeEncoding(pVar, ENC(p->db));\n<line22>}\n<line23>}\n<line24>if( rc ){\n<line25>sqlite3Error(p->db, rc);\n<line26>rc = sqlite3ApiExit(p->db, rc);\n<line27>}\n<line28>}\n<line29>sqlite3_mutex_leave(p->db->mutex);\n<line30>}else if( xDel!=SQLITE_STATIC && xDel!=SQLITE_TRANSIENT ){\n<line31>xDel((void*)zData);\n<line32>}\n<line33>return rc;\n<line34>}
----------------------------------------
Function: sqlite3_bind_blob
Content: <line0>SQLITE_API int sqlite3_bind_blob(\n<line1>sqlite3_stmt *pStmt,\n<line2>int i,\n<line3>const void *zData,\n<line4>int nData,\n<line5>void (*xDel)(void*)\n<line6>){\n<line7>#ifdef SQLITE_ENABLE_API_ARMOR\n<line8>if( nData<0 ) return SQLITE_MISUSE_BKPT;\n<line9>#endif\n<line10>return bindText(pStmt, i, zData, nData, xDel, 0);\n<line11>}
----------------------------------------
Function: sqlite3_bind_blob64
Content: <line0>SQLITE_API int sqlite3_bind_blob64(\n<line1>sqlite3_stmt *pStmt,\n<line2>int i,\n<line3>const void *zData,\n<line4>sqlite3_uint64 nData,\n<line5>void (*xDel)(void*)\n<line6>){\n<line7>assert( xDel!=SQLITE_DYNAMIC );\n<line8>return bindText(pStmt, i, zData, nData, xDel, 0);\n<line9>}
----------------------------------------
Function: sqlite3_bind_double
Content: <line0>SQLITE_API int sqlite3_bind_double(sqlite3_stmt *pStmt, int i, double rValue){\n<line1>int rc;\n<line2>Vdbe *p = (Vdbe *)pStmt;\n<line3>rc = vdbeUnbind(p, (u32)(i-1));\n<line4>if( rc==SQLITE_OK ){\n<line5>assert( p!=0 && p->aVar!=0 && i>0 && i<=p->nVar ); /* tag-20240917-01 */\n<line6>sqlite3VdbeMemSetDouble(&p->aVar[i-1], rValue);\n<line7>sqlite3_mutex_leave(p->db->mutex);\n<line8>}\n<line9>return rc;\n<line10>}
----------------------------------------
Function: sqlite3_bind_int
Content: <line0>SQLITE_API int sqlite3_bind_int(sqlite3_stmt *p, int i, int iValue){\n<line1>return sqlite3_bind_int64(p, i, (i64)iValue);\n<line2>}
----------------------------------------
Function: sqlite3_bind_int64
Content: <line0>SQLITE_API int sqlite3_bind_int64(sqlite3_stmt *pStmt, int i, sqlite_int64 iValue){\n<line1>int rc;\n<line2>Vdbe *p = (Vdbe *)pStmt;\n<line3>rc = vdbeUnbind(p, (u32)(i-1));\n<line4>if( rc==SQLITE_OK ){\n<line5>assert( p!=0 && p->aVar!=0 && i>0 && i<=p->nVar ); /* tag-20240917-01 */\n<line6>sqlite3VdbeMemSetInt64(&p->aVar[i-1], iValue);\n<line7>sqlite3_mutex_leave(p->db->mutex);\n<line8>}\n<line9>return rc;\n<line10>}
----------------------------------------
Function: sqlite3_bind_null
Content: <line0>SQLITE_API int sqlite3_bind_null(sqlite3_stmt *pStmt, int i){\n<line1>int rc;\n<line2>Vdbe *p = (Vdbe*)pStmt;\n<line3>rc = vdbeUnbind(p, (u32)(i-1));\n<line4>if( rc==SQLITE_OK ){\n<line5>assert( p!=0 && p->aVar!=0 && i>0 && i<=p->nVar ); /* tag-20240917-01 */\n<line6>sqlite3_mutex_leave(p->db->mutex);\n<line7>}\n<line8>return rc;\n<line9>}
----------------------------------------
Function: sqlite3_bind_pointer
Content: <line0>SQLITE_API int sqlite3_bind_pointer(\n<line1>sqlite3_stmt *pStmt,\n<line2>int i,\n<line3>void *pPtr,\n<line4>const char *zPTtype,\n<line5>void (*xDestructor)(void*)\n<line6>){\n<line7>int rc;\n<line8>Vdbe *p = (Vdbe*)pStmt;\n<line9>rc = vdbeUnbind(p, (u32)(i-1));\n<line10>if( rc==SQLITE_OK ){\n<line11>assert( p!=0 && p->aVar!=0 && i>0 && i<=p->nVar ); /* tag-20240917-01 */\n<line12>sqlite3VdbeMemSetPointer(&p->aVar[i-1], pPtr, zPTtype, xDestructor);\n<line13>sqlite3_mutex_leave(p->db->mutex);\n<line14>}else if( xDestructor ){\n<line15>xDestructor(pPtr);\n<line16>}\n<line17>return rc;\n<line18>}
----------------------------------------
Function: sqlite3_bind_text
Content: <line0>SQLITE_API int sqlite3_bind_text(\n<line1>sqlite3_stmt *pStmt,\n<line2>int i,\n<line3>const char *zData,\n<line4>int nData,\n<line5>void (*xDel)(void*)\n<line6>){\n<line7>return bindText(pStmt, i, zData, nData, xDel, SQLITE_UTF8);\n<line8>}
----------------------------------------
Function: sqlite3_bind_text64
Content: <line0>SQLITE_API int sqlite3_bind_text64(\n<line1>sqlite3_stmt *pStmt,\n<line2>int i,\n<line3>const char *zData,\n<line4>sqlite3_uint64 nData,\n<line5>void (*xDel)(void*),\n<line6>unsigned char enc\n<line7>){\n<line8>assert( xDel!=SQLITE_DYNAMIC );\n<line9>if( enc!=SQLITE_UTF8 ){\n<line10>if( enc==SQLITE_UTF16 ) enc = SQLITE_UTF16NATIVE;\n<line11>nData &= ~(u64)1;\n<line12>}\n<line13>return bindText(pStmt, i, zData, nData, xDel, enc);\n<line14>}
----------------------------------------
Function: sqlite3_bind_text16
Content: <line0>SQLITE_API int sqlite3_bind_text16(\n<line1>sqlite3_stmt *pStmt,\n<line2>int i,\n<line3>const void *zData,\n<line4>int n,\n<line5>void (*xDel)(void*)\n<line6>){\n<line7>return bindText(pStmt, i, zData, n & ~(u64)1, xDel, SQLITE_UTF16NATIVE);\n<line8>}
----------------------------------------
Function: sqlite3_bind_value
Content: <line0>SQLITE_API int sqlite3_bind_value(sqlite3_stmt *pStmt, int i, const sqlite3_value *pValue){\n<line1>int rc;\n<line2>switch( sqlite3_value_type((sqlite3_value*)pValue) ){\n<line3>case SQLITE_INTEGER: {\n<line4>rc = sqlite3_bind_int64(pStmt, i, pValue->u.i);\n<line5>break;\n<line6>}\n<line7>case SQLITE_FLOAT: {\n<line8>assert( pValue->flags & (MEM_Real|MEM_IntReal) );\n<line9>rc = sqlite3_bind_double(pStmt, i,\n<line10>(pValue->flags & MEM_Real) ? pValue->u.r : (double)pValue->u.i\n<line11>);\n<line12>break;\n<line13>}\n<line14>case SQLITE_BLOB: {\n<line15>if( pValue->flags & MEM_Zero ){\n<line16>rc = sqlite3_bind_zeroblob(pStmt, i, pValue->u.nZero);\n<line17>}else{\n<line18>rc = sqlite3_bind_blob(pStmt, i, pValue->z, pValue->n,SQLITE_TRANSIENT);\n<line19>}\n<line20>break;\n<line21>}\n<line22>case SQLITE_TEXT: {\n<line23>rc = bindText(pStmt,i,  pValue->z, pValue->n, SQLITE_TRANSIENT,\n<line24>pValue->enc);\n<line25>break;\n<line26>}\n<line27>default: {\n<line28>rc = sqlite3_bind_null(pStmt, i);\n<line29>break;\n<line30>}\n<line31>}\n<line32>return rc;\n<line33>}
----------------------------------------
Function: sqlite3_bind_zeroblob
Content: <line0>SQLITE_API int sqlite3_bind_zeroblob(sqlite3_stmt *pStmt, int i, int n){\n<line1>int rc;\n<line2>Vdbe *p = (Vdbe *)pStmt;\n<line3>rc = vdbeUnbind(p, (u32)(i-1));\n<line4>if( rc==SQLITE_OK ){\n<line5>assert( p!=0 && p->aVar!=0 && i>0 && i<=p->nVar ); /* tag-20240917-01 */\n<line6>#ifndef SQLITE_OMIT_INCRBLOB\n<line7>sqlite3VdbeMemSetZeroBlob(&p->aVar[i-1], n);\n<line8>#else\n<line9>rc = sqlite3VdbeMemSetZeroBlob(&p->aVar[i-1], n);\n<line10>#endif\n<line11>sqlite3_mutex_leave(p->db->mutex);\n<line12>}\n<line13>return rc;\n<line14>}
----------------------------------------
Function: sqlite3_bind_zeroblob64
Content: <line0>SQLITE_API int sqlite3_bind_zeroblob64(sqlite3_stmt *pStmt, int i, sqlite3_uint64 n){\n<line1>int rc;\n<line2>Vdbe *p = (Vdbe *)pStmt;\n<line3>#ifdef SQLITE_ENABLE_API_ARMOR\n<line4>if( p==0 ) return SQLITE_MISUSE_BKPT;\n<line5>#endif\n<line6>sqlite3_mutex_enter(p->db->mutex);\n<line7>if( n>(u64)p->db->aLimit[SQLITE_LIMIT_LENGTH] ){\n<line8>rc = SQLITE_TOOBIG;\n<line9>}else{\n<line10>assert( (n & 0x7FFFFFFF)==n );\n<line11>rc = sqlite3_bind_zeroblob(pStmt, i, n);\n<line12>}\n<line13>rc = sqlite3ApiExit(p->db, rc);\n<line14>sqlite3_mutex_leave(p->db->mutex);\n<line15>return rc;\n<line16>}
----------------------------------------
Function: sqlite3_bind_parameter_count
Content: <line0>SQLITE_API int sqlite3_bind_parameter_count(sqlite3_stmt *pStmt){\n<line1>Vdbe *p = (Vdbe*)pStmt;\n<line2>return p ? p->nVar : 0;\n<line3>}
----------------------------------------
Function: sqlite3_bind_parameter_name
Content: <line0>SQLITE_API const char *sqlite3_bind_parameter_name(sqlite3_stmt *pStmt, int i){\n<line1>Vdbe *p = (Vdbe*)pStmt;\n<line2>if( p==0 ) return 0;\n<line3>return sqlite3VListNumToName(p->pVList, i);\n<line4>}
----------------------------------------
Function: sqlite3_bind_parameter_index
Content: <line0>SQLITE_API int sqlite3_bind_parameter_index(sqlite3_stmt *pStmt, const char *zName){\n<line1>return sqlite3VdbeParameterIndex((Vdbe*)pStmt, zName, sqlite3Strlen30(zName));\n<line2>}
----------------------------------------
Function: sqlite3_transfer_bindings
Content: <line0>SQLITE_API int sqlite3_transfer_bindings(sqlite3_stmt *pFromStmt, sqlite3_stmt *pToStmt){\n<line1>Vdbe *pFrom = (Vdbe*)pFromStmt;\n<line2>Vdbe *pTo = (Vdbe*)pToStmt;\n<line3>if( pFrom->nVar!=pTo->nVar ){\n<line4>return SQLITE_ERROR;\n<line5>}\n<line6>assert( (pTo->prepFlags & SQLITE_PREPARE_SAVESQL)!=0 || pTo->expmask==0 );\n<line7>if( pTo->expmask ){\n<line8>pTo->expired = 1;\n<line9>}\n<line10>assert( (pFrom->prepFlags & SQLITE_PREPARE_SAVESQL)!=0 || pFrom->expmask==0 );\n<line11>if( pFrom->expmask ){\n<line12>pFrom->expired = 1;\n<line13>}\n<line14>return sqlite3TransferBindings(pFromStmt, pToStmt);\n<line15>}
----------------------------------------
Function: sqlite3_db_handle
Content: <line0>SQLITE_API sqlite3 *sqlite3_db_handle(sqlite3_stmt *pStmt){\n<line1>return pStmt ? ((Vdbe*)pStmt)->db : 0;\n<line2>}
----------------------------------------
Function: sqlite3_stmt_readonly
Content: <line0>SQLITE_API int sqlite3_stmt_readonly(sqlite3_stmt *pStmt){\n<line1>return pStmt ? ((Vdbe*)pStmt)->readOnly : 1;\n<line2>}
----------------------------------------
Function: sqlite3_stmt_isexplain
Content: <line0>SQLITE_API int sqlite3_stmt_isexplain(sqlite3_stmt *pStmt){\n<line1>return pStmt ? ((Vdbe*)pStmt)->explain : 0;\n<line2>}
----------------------------------------
Function: sqlite3_stmt_explain
Content: <line0>SQLITE_API int sqlite3_stmt_explain(sqlite3_stmt *pStmt, int eMode){\n<line1>Vdbe *v = (Vdbe*)pStmt;\n<line2>int rc;\n<line3>#ifdef SQLITE_ENABLE_API_ARMOR\n<line4>if( pStmt==0 ) return SQLITE_MISUSE_BKPT;\n<line5>#endif\n<line6>sqlite3_mutex_enter(v->db->mutex);\n<line7>if( ((int)v->explain)==eMode ){\n<line8>rc = SQLITE_OK;\n<line9>}else if( eMode<0 || eMode>2 ){\n<line10>rc = SQLITE_ERROR;\n<line11>}else if( (v->prepFlags & SQLITE_PREPARE_SAVESQL)==0 ){\n<line12>rc = SQLITE_ERROR;\n<line13>}else if( v->eVdbeState!=VDBE_READY_STATE ){\n<line14>rc = SQLITE_BUSY;\n<line15>}else if( v->nMem>=10 && (eMode!=2 || v->haveEqpOps) ){\n<line16>/* No reprepare necessary */\n<line17>v->explain = eMode;\n<line18>rc = SQLITE_OK;\n<line19>}else{\n<line20>v->explain = eMode;\n<line21>rc = sqlite3Reprepare(v);\n<line22>v->haveEqpOps = eMode==2;\n<line23>}\n<line24>if( v->explain ){\n<line25>v->nResColumn = 12 - 4*v->explain;\n<line26>}else{\n<line27>v->nResColumn = v->nResAlloc;\n<line28>}\n<line29>sqlite3_mutex_leave(v->db->mutex);\n<line30>return rc;\n<line31>}
----------------------------------------
Function: sqlite3_stmt_busy
Content: <line0>SQLITE_API int sqlite3_stmt_busy(sqlite3_stmt *pStmt){\n<line1>Vdbe *v = (Vdbe*)pStmt;\n<line2>return v!=0 && v->eVdbeState==VDBE_RUN_STATE;\n<line3>}
----------------------------------------
Function: sqlite3_next_stmt
Content: <line0>SQLITE_API sqlite3_stmt *sqlite3_next_stmt(sqlite3 *pDb, sqlite3_stmt *pStmt){\n<line1>sqlite3_stmt *pNext;\n<line2>#ifdef SQLITE_ENABLE_API_ARMOR\n<line3>if( !sqlite3SafetyCheckOk(pDb) ){\n<line4>(void)SQLITE_MISUSE_BKPT;\n<line5>return 0;\n<line6>}\n<line7>#endif\n<line8>sqlite3_mutex_enter(pDb->mutex);\n<line9>if( pStmt==0 ){\n<line10>pNext = (sqlite3_stmt*)pDb->pVdbe;\n<line11>}else{\n<line12>pNext = (sqlite3_stmt*)((Vdbe*)pStmt)->pVNext;\n<line13>}\n<line14>sqlite3_mutex_leave(pDb->mutex);\n<line15>return pNext;\n<line16>}
----------------------------------------
Function: sqlite3_stmt_status
Content: <line0>SQLITE_API int sqlite3_stmt_status(sqlite3_stmt *pStmt, int op, int resetFlag){\n<line1>Vdbe *pVdbe = (Vdbe*)pStmt;\n<line2>u32 v;\n<line3>#ifdef SQLITE_ENABLE_API_ARMOR\n<line4>if( !pStmt\n<line5>|| (op!=SQLITE_STMTSTATUS_MEMUSED && (op<0||op>=ArraySize(pVdbe->aCounter)))\n<line6>){\n<line7>(void)SQLITE_MISUSE_BKPT;\n<line8>return 0;\n<line9>}\n<line10>#endif\n<line11>if( op==SQLITE_STMTSTATUS_MEMUSED ){\n<line12>sqlite3 *db = pVdbe->db;\n<line13>sqlite3_mutex_enter(db->mutex);\n<line14>v = 0;\n<line15>db->pnBytesFreed = (int*)&v;\n<line16>assert( db->lookaside.pEnd==db->lookaside.pTrueEnd );\n<line17>db->lookaside.pEnd = db->lookaside.pStart;\n<line18>sqlite3VdbeDelete(pVdbe);\n<line19>db->pnBytesFreed = 0;\n<line20>db->lookaside.pEnd = db->lookaside.pTrueEnd;\n<line21>sqlite3_mutex_leave(db->mutex);\n<line22>}else{\n<line23>v = pVdbe->aCounter[op];\n<line24>if( resetFlag ) pVdbe->aCounter[op] = 0;\n<line25>}\n<line26>return (int)v;\n<line27>}
----------------------------------------
Function: sqlite3_sql
Content: <line0>SQLITE_API const char *sqlite3_sql(sqlite3_stmt *pStmt){\n<line1>Vdbe *p = (Vdbe *)pStmt;\n<line2>return p ? p->zSql : 0;\n<line3>}
----------------------------------------
Function: sqlite3_expanded_sql
Content: <line0>SQLITE_API char *sqlite3_expanded_sql(sqlite3_stmt *pStmt){\n<line1>#ifdef SQLITE_OMIT_TRACE\n<line2>return 0;\n<line3>#else\n<line4>char *z = 0;\n<line5>const char *zSql = sqlite3_sql(pStmt);\n<line6>if( zSql ){\n<line7>Vdbe *p = (Vdbe *)pStmt;\n<line8>sqlite3_mutex_enter(p->db->mutex);\n<line9>z = sqlite3VdbeExpandSql(p, zSql);\n<line10>sqlite3_mutex_leave(p->db->mutex);\n<line11>}\n<line12>return z;\n<line13>#endif\n<line14>}
----------------------------------------
Function: findNextHostParameter
Content: <line0>static i64 findNextHostParameter(const char *zSql, i64 *pnToken){\n<line1>int tokenType;\n<line2>i64 nTotal = 0;\n<line3>i64 n;\n<line4>*pnToken = 0;\n<line5>while( zSql[0] ){\n<line6>n = sqlite3GetToken((u8*)zSql, &tokenType);\n<line7>assert( n>0 && tokenType!=TK_ILLEGAL );\n<line8>if( tokenType==TK_VARIABLE ){\n<line9>*pnToken = n;\n<line10>break;\n<line11>}\n<line12>nTotal += n;\n<line13>zSql += n;\n<line14>}\n<line15>return nTotal;\n<line16>}
----------------------------------------
Function: allocateCursor
Content: <line0>static VdbeCursor *allocateCursor(\n<line1>Vdbe *p,              /* The virtual machine */\n<line2>int iCur,             /* Index of the new VdbeCursor */\n<line3>int nField,           /* Number of fields in the table or index */\n<line4>u8 eCurType           /* Type of the new cursor */\n<line5>){\n<line6>/* Find the memory cell that will be used to store the blob of memory\n<line7>** required for this VdbeCursor structure. It is convenient to use a\n<line8>** vdbe memory cell to manage the memory allocation required for a\n<line9>** VdbeCursor structure for the following reasons:\n<line10>**\n<line11>**   * Sometimes cursor numbers are used for a couple of different\n<line12>**     purposes in a vdbe program. The different uses might require\n<line13>**     different sized allocations. Memory cells provide growable\n<line14>**     allocations.\n<line15>**\n<line16>**   * When using ENABLE_MEMORY_MANAGEMENT, memory cell buffers can\n<line17>**     be freed lazily via the sqlite3_release_memory() API. This\n<line18>**     minimizes the number of malloc calls made by the system.\n<line19>**\n<line20>** The memory cell for cursor 0 is aMem[0]. The rest are allocated from\n<line21>** the top of the register space.  Cursor 1 is at Mem[p->nMem-1].\n<line22>** Cursor 2 is at Mem[p->nMem-2]. And so forth.\n<line23>*/\n<line24>Mem *pMem = iCur>0 ? &p->aMem[p->nMem-iCur] : p->aMem;\n<line25>i64 nByte;\n<line26>VdbeCursor *pCx = 0;\n<line27>nByte = SZ_VDBECURSOR(nField);\n<line28>assert( ROUND8(nByte)==nByte );\n<line29>if( eCurType==CURTYPE_BTREE ) nByte += sqlite3BtreeCursorSize();\n<line30>assert( iCur>=0 && iCur<p->nCursor );\n<line31>if( p->apCsr[iCur] ){ /*OPTIMIZATION-IF-FALSE*/\n<line32>sqlite3VdbeFreeCursorNN(p, p->apCsr[iCur]);\n<line33>p->apCsr[iCur] = 0;\n<line34>}\n<line35>/* There used to be a call to sqlite3VdbeMemClearAndResize() to make sure\n<line36>** the pMem used to hold space for the cursor has enough storage available\n<line37>** in pMem->zMalloc.  But for the special case of the aMem[] entries used\n<line38>** to hold cursors, it is faster to in-line the logic. */\n<line39>assert( pMem->flags==MEM_Undefined );\n<line40>assert( (pMem->flags & MEM_Dyn)==0 );\n<line41>assert( pMem->szMalloc==0 || pMem->z==pMem->zMalloc );\n<line42>if( pMem->szMalloc<nByte ){\n<line43>if( pMem->szMalloc>0 ){\n<line44>sqlite3DbFreeNN(pMem->db, pMem->zMalloc);\n<line45>}\n<line46>pMem->z = pMem->zMalloc = sqlite3DbMallocRaw(pMem->db, nByte);\n<line47>if( pMem->zMalloc==0 ){\n<line48>pMem->szMalloc = 0;\n<line49>return 0;\n<line50>}\n<line51>pMem->szMalloc = (int)nByte;\n<line52>}\n<line53>p->apCsr[iCur] = pCx = (VdbeCursor*)pMem->zMalloc;\n<line54>memset(pCx, 0, offsetof(VdbeCursor,pAltCursor));\n<line55>pCx->eCurType = eCurType;\n<line56>pCx->nField = nField;\n<line57>pCx->aOffset = &pCx->aType[nField];\n<line58>if( eCurType==CURTYPE_BTREE ){\n<line59>assert( ROUND8(SZ_VDBECURSOR(nField))==SZ_VDBECURSOR(nField) );\n<line60>pCx->uc.pCursor = (BtCursor*)&pMem->z[SZ_VDBECURSOR(nField)];\n<line61>sqlite3BtreeCursorZero(pCx->uc.pCursor);\n<line62>}\n<line63>return pCx;\n<line64>}
----------------------------------------
Function: alsoAnInt
Content: <line0>static int alsoAnInt(Mem *pRec, double rValue, i64 *piValue){\n<line1>i64 iValue;\n<line2>iValue = sqlite3RealToI64(rValue);\n<line3>if( sqlite3RealSameAsInt(rValue,iValue) ){\n<line4>*piValue = iValue;\n<line5>return 1;\n<line6>}\n<line7>return 0==sqlite3Atoi64(pRec->z, piValue, pRec->n, pRec->enc);\n<line8>}
----------------------------------------
Function: applyNumericAffinity
Content: <line0>static void applyNumericAffinity(Mem *pRec, int bTryForInt){\n<line1>double rValue;\n<line2>u8 enc = pRec->enc;\n<line3>int rc;\n<line4>assert( (pRec->flags & (MEM_Str|MEM_Int|MEM_Real|MEM_IntReal))==MEM_Str );\n<line5>rc = sqlite3AtoF(pRec->z, &rValue, pRec->n, enc);\n<line6>if( rc<=0 ) return;\n<line7>if( rc==1 && alsoAnInt(pRec, rValue, &pRec->u.i) ){\n<line8>pRec->flags |= MEM_Int;\n<line9>}else{\n<line10>pRec->u.r = rValue;\n<line11>pRec->flags |= MEM_Real;\n<line12>if( bTryForInt ) sqlite3VdbeIntegerAffinity(pRec);\n<line13>}\n<line14>/* TEXT->NUMERIC is many->one.  Hence, it is important to invalidate the\n<line15>** string representation after computing a numeric equivalent, because the\n<line16>** string representation might not be the canonical representation for the\n<line17>** numeric value.  Ticket [343634942dd54ab57b7024] 2018-01-31. */\n<line18>pRec->flags &= ~MEM_Str;\n<line19>}
----------------------------------------
Function: applyAffinity
Content: <line0>static void applyAffinity(\n<line1>Mem *pRec,          /* The value to apply affinity to */\n<line2>char affinity,      /* The affinity to be applied */\n<line3>u8 enc              /* Use this text encoding */\n<line4>){\n<line5>if( affinity>=SQLITE_AFF_NUMERIC ){\n<line6>assert( affinity==SQLITE_AFF_INTEGER || affinity==SQLITE_AFF_REAL\n<line7>|| affinity==SQLITE_AFF_NUMERIC || affinity==SQLITE_AFF_FLEXNUM );\n<line8>if( (pRec->flags & MEM_Int)==0 ){ /*OPTIMIZATION-IF-FALSE*/\n<line9>if( (pRec->flags & (MEM_Real|MEM_IntReal))==0 ){\n<line10>if( pRec->flags & MEM_Str ) applyNumericAffinity(pRec,1);\n<line11>}else if( affinity<=SQLITE_AFF_REAL ){\n<line12>sqlite3VdbeIntegerAffinity(pRec);\n<line13>}\n<line14>}\n<line15>}else if( affinity==SQLITE_AFF_TEXT ){\n<line16>/* Only attempt the conversion to TEXT if there is an integer or real\n<line17>** representation (blob and NULL do not get converted) but no string\n<line18>** representation.  It would be harmless to repeat the conversion if\n<line19>** there is already a string rep, but it is pointless to waste those\n<line20>** CPU cycles. */\n<line21>if( 0==(pRec->flags&MEM_Str) ){ /*OPTIMIZATION-IF-FALSE*/\n<line22>if( (pRec->flags&(MEM_Real|MEM_Int|MEM_IntReal)) ){\n<line23>testcase( pRec->flags & MEM_Int );\n<line24>testcase( pRec->flags & MEM_Real );\n<line25>testcase( pRec->flags & MEM_IntReal );\n<line26>sqlite3VdbeMemStringify(pRec, enc, 1);\n<line27>}\n<line28>}\n<line29>pRec->flags &= ~(MEM_Real|MEM_Int|MEM_IntReal);\n<line30>}\n<line31>}
----------------------------------------
Function: sqlite3_value_numeric_type
Content: <line0>SQLITE_API int sqlite3_value_numeric_type(sqlite3_value *pVal){\n<line1>int eType = sqlite3_value_type(pVal);\n<line2>if( eType==SQLITE_TEXT ){\n<line3>Mem *pMem = (Mem*)pVal;\n<line4>applyNumericAffinity(pMem, 0);\n<line5>eType = sqlite3_value_type(pVal);\n<line6>}\n<line7>return eType;\n<line8>}
----------------------------------------
Function: computeNumericType
Content: <line0>static u16 SQLITE_NOINLINE computeNumericType(Mem *pMem){\n<line1>int rc;\n<line2>sqlite3_int64 ix;\n<line3>assert( (pMem->flags & (MEM_Int|MEM_Real|MEM_IntReal))==0 );\n<line4>assert( (pMem->flags & (MEM_Str|MEM_Blob))!=0 );\n<line5>if( ExpandBlob(pMem) ){\n<line6>pMem->u.i = 0;\n<line7>return MEM_Int;\n<line8>}\n<line9>rc = sqlite3AtoF(pMem->z, &pMem->u.r, pMem->n, pMem->enc);\n<line10>if( rc<=0 ){\n<line11>if( rc==0 && sqlite3Atoi64(pMem->z, &ix, pMem->n, pMem->enc)<=1 ){\n<line12>pMem->u.i = ix;\n<line13>return MEM_Int;\n<line14>}else{\n<line15>return MEM_Real;\n<line16>}\n<line17>}else if( rc==1 && sqlite3Atoi64(pMem->z, &ix, pMem->n, pMem->enc)==0 ){\n<line18>pMem->u.i = ix;\n<line19>return MEM_Int;\n<line20>}\n<line21>return MEM_Real;\n<line22>}
----------------------------------------
Function: numericType
Content: <line0>static u16 numericType(Mem *pMem){\n<line1>assert( (pMem->flags & MEM_Null)==0\n<line2>|| pMem->db==0 || pMem->db->mallocFailed );\n<line3>if( pMem->flags & (MEM_Int|MEM_Real|MEM_IntReal|MEM_Null) ){\n<line4>testcase( pMem->flags & MEM_Int );\n<line5>testcase( pMem->flags & MEM_Real );\n<line6>testcase( pMem->flags & MEM_IntReal );\n<line7>return pMem->flags & (MEM_Int|MEM_Real|MEM_IntReal|MEM_Null);\n<line8>}\n<line9>assert( pMem->flags & (MEM_Str|MEM_Blob) );\n<line10>testcase( pMem->flags & MEM_Str );\n<line11>testcase( pMem->flags & MEM_Blob );\n<line12>return computeNumericType(pMem);\n<line13>return 0;\n<line14>}
----------------------------------------
Function: out2PrereleaseWithClear
Content: <line0>static SQLITE_NOINLINE Mem *out2PrereleaseWithClear(Mem *pOut){\n<line1>sqlite3VdbeMemSetNull(pOut);\n<line2>pOut->flags = MEM_Int;\n<line3>return pOut;\n<line4>}
----------------------------------------
Function: out2Prerelease
Content: <line0>static Mem *out2Prerelease(Vdbe *p, VdbeOp *pOp){\n<line1>Mem *pOut;\n<line2>assert( pOp->p2>0 );\n<line3>assert( pOp->p2<=(p->nMem+1 - p->nCursor) );\n<line4>pOut = &p->aMem[pOp->p2];\n<line5>memAboutToChange(p, pOut);\n<line6>if( VdbeMemDynamic(pOut) ){ /*OPTIMIZATION-IF-FALSE*/\n<line7>return out2PrereleaseWithClear(pOut);\n<line8>}else{\n<line9>pOut->flags = MEM_Int;\n<line10>return pOut;\n<line11>}\n<line12>}
----------------------------------------
Function: filterHash
Content: <line0>static u64 filterHash(const Mem *aMem, const Op *pOp){\n<line1>int i, mx;\n<line2>u64 h = 0;\n<line3>assert( pOp->p4type==P4_INT32 );\n<line4>for(i=pOp->p3, mx=i+pOp->p4.i; i<mx; i++){\n<line5>const Mem *p = &aMem[i];\n<line6>if( p->flags & (MEM_Int|MEM_IntReal) ){\n<line7>h += p->u.i;\n<line8>}else if( p->flags & MEM_Real ){\n<line9>h += sqlite3VdbeIntValue(p);\n<line10>}else if( p->flags & (MEM_Str|MEM_Blob) ){\n<line11>/* All strings have the same hash and all blobs have the same hash,\n<line12>** though, at least, those hashes are different from each other and\n<line13>** from NULL. */\n<line14>h += 4093 + (p->flags & (MEM_Str|MEM_Blob));\n<line15>}\n<line16>}\n<line17>return h;\n<line18>}
----------------------------------------
Function: vdbeColumnFromOverflow
Content: <line0>static SQLITE_NOINLINE int vdbeColumnFromOverflow(\n<line1>VdbeCursor *pC,       /* The BTree cursor from which we are reading */\n<line2>int iCol,             /* The column to read */\n<line3>u32 t,                /* The serial-type code for the column value */\n<line4>i64 iOffset,          /* Offset to the start of the content value */\n<line5>u32 cacheStatus,      /* Current Vdbe.cacheCtr value */\n<line6>u32 colCacheCtr,      /* Current value of the column cache counter */\n<line7>Mem *pDest            /* Store the value into this register. */\n<line8>){\n<line9>int rc;\n<line10>sqlite3 *db = pDest->db;\n<line11>int encoding = pDest->enc;\n<line12>int len = sqlite3VdbeSerialTypeLen(t);\n<line13>assert( pC->eCurType==CURTYPE_BTREE );\n<line14>if( len>db->aLimit[SQLITE_LIMIT_LENGTH] ) return SQLITE_TOOBIG;\n<line15>if( len > 4000 && pC->pKeyInfo==0 ){\n<line16>/* Cache large column values that are on overflow pages using\n<line17>** an RCStr (reference counted string) so that if they are reloaded,\n<line18>** that do not have to be copied a second time.  The overhead of\n<line19>** creating and managing the cache is such that this is only\n<line20>** profitable for larger TEXT and BLOB values.\n<line21>**\n<line22>** Only do this on table-btrees so that writes to index-btrees do not\n<line23>** need to clear the cache.  This buys performance in the common case\n<line24>** in exchange for generality.\n<line25>*/\n<line26>VdbeTxtBlbCache *pCache;\n<line27>char *pBuf;\n<line28>if( pC->colCache==0 ){\n<line29>pC->pCache = sqlite3DbMallocZero(db, sizeof(VdbeTxtBlbCache) );\n<line30>if( pC->pCache==0 ) return SQLITE_NOMEM;\n<line31>pC->colCache = 1;\n<line32>}\n<line33>pCache = pC->pCache;\n<line34>if( pCache->pCValue==0\n<line35>|| pCache->iCol!=iCol\n<line36>|| pCache->cacheStatus!=cacheStatus\n<line37>|| pCache->colCacheCtr!=colCacheCtr\n<line38>|| pCache->iOffset!=sqlite3BtreeOffset(pC->uc.pCursor)\n<line39>){\n<line40>if( pCache->pCValue ) sqlite3RCStrUnref(pCache->pCValue);\n<line41>pBuf = pCache->pCValue = sqlite3RCStrNew( len+3 );\n<line42>if( pBuf==0 ) return SQLITE_NOMEM;\n<line43>rc = sqlite3BtreePayload(pC->uc.pCursor, iOffset, len, pBuf);\n<line44>if( rc ) return rc;\n<line45>pBuf[len] = 0;\n<line46>pBuf[len+1] = 0;\n<line47>pBuf[len+2] = 0;\n<line48>pCache->iCol = iCol;\n<line49>pCache->cacheStatus = cacheStatus;\n<line50>pCache->colCacheCtr = colCacheCtr;\n<line51>pCache->iOffset = sqlite3BtreeOffset(pC->uc.pCursor);\n<line52>}else{\n<line53>pBuf = pCache->pCValue;\n<line54>}\n<line55>assert( t>=12 );\n<line56>sqlite3RCStrRef(pBuf);\n<line57>if( t&1 ){\n<line58>rc = sqlite3VdbeMemSetStr(pDest, pBuf, len, encoding,\n<line59>sqlite3RCStrUnref);\n<line60>pDest->flags |= MEM_Term;\n<line61>}else{\n<line62>rc = sqlite3VdbeMemSetStr(pDest, pBuf, len, 0,\n<line63>sqlite3RCStrUnref);\n<line64>}\n<line65>}else{\n<line66>rc = sqlite3VdbeMemFromBtree(pC->uc.pCursor, iOffset, len, pDest);\n<line67>if( rc ) return rc;\n<line68>sqlite3VdbeSerialGet((const u8*)pDest->z, t, pDest);\n<line69>if( (t&1)!=0 && encoding==SQLITE_UTF8 ){\n<line70>pDest->z[len] = 0;\n<line71>pDest->flags |= MEM_Term;\n<line72>}\n<line73>}\n<line74>pDest->flags &= ~MEM_Ephem;\n<line75>return rc;\n<line76>}
----------------------------------------
Function: sqlite3VdbeLogAbort
Content: <line0>static SQLITE_NOINLINE void sqlite3VdbeLogAbort(\n<line1>Vdbe *p,     /* The statement that is running at the time of failure */\n<line2>int rc,      /* Error code */\n<line3>Op *pOp,     /* Opcode that filed */\n<line4>Op *aOp      /* All opcodes */\n<line5>){\n<line6>const char *zSql = p->zSql;   /* Original SQL text */\n<line7>const char *zPrefix = "";     /* Prefix added to SQL text */\n<line8>int pc;                       /* Opcode address */\n<line9>char zXtra[100];              /* Buffer space to store zPrefix */\n<line10>if( p->pFrame ){\n<line11>assert( aOp[0].opcode==OP_Init );\n<line12>if( aOp[0].p4.z!=0 ){\n<line13>assert( aOp[0].p4.z[0]=='-'\n<line14>&& aOp[0].p4.z[1]=='-'\n<line15>&& aOp[0].p4.z[2]==' ' );\n<line16>sqlite3_snprintf(sizeof(zXtra), zXtra,"/* %s */ ",aOp[0].p4.z+3);\n<line17>zPrefix = zXtra;\n<line18>}else{\n<line19>zPrefix = "/* unknown trigger */ ";\n<line20>}\n<line21>}\n<line22>pc = (int)(pOp - aOp);\n<line23>sqlite3_log(rc, "statement aborts at %d: %s; [%s%s]",\n<line24>pc, p->zErrMsg, zPrefix, zSql);\n<line25>}
----------------------------------------
Function: vdbeMemTypeName
Content: <line0>static const char *vdbeMemTypeName(Mem *pMem){\n<line1>static const char *azTypes[] = {\n<line2>/* SQLITE_INTEGER */ "INT",\n<line3>/* SQLITE_FLOAT   */ "REAL",\n<line4>/* SQLITE_TEXT    */ "TEXT",\n<line5>/* SQLITE_BLOB    */ "BLOB",\n<line6>/* SQLITE_NULL    */ "NULL"\n<line7>};\n<line8>return azTypes[sqlite3_value_type(pMem)-1];\n<line9>}
----------------------------------------
Function: blobSeekToRow
Content: <line0>static int blobSeekToRow(Incrblob *p, sqlite3_int64 iRow, char **pzErr){\n<line1>int rc;                         /* Error code */\n<line2>char *zErr = 0;                 /* Error message */\n<line3>Vdbe *v = (Vdbe *)p->pStmt;\n<line4>/* Set the value of register r[1] in the SQL statement to integer iRow.\n<line5>** This is done directly as a performance optimization\n<line6>*/\n<line7>sqlite3VdbeMemSetInt64(&v->aMem[1], iRow);\n<line8>/* If the statement has been run before (and is paused at the OP_ResultRow)\n<line9>** then back it up to the point where it does the OP_NotExists.  This could\n<line10>** have been down with an extra OP_Goto, but simply setting the program\n<line11>** counter is faster. */\n<line12>if( v->pc>4 ){\n<line13>v->pc = 4;\n<line14>assert( v->aOp[v->pc].opcode==OP_NotExists );\n<line15>rc = sqlite3VdbeExec(v);\n<line16>}else{\n<line17>rc = sqlite3_step(p->pStmt);\n<line18>}\n<line19>if( rc==SQLITE_ROW ){\n<line20>VdbeCursor *pC = v->apCsr[0];\n<line21>u32 type;\n<line22>assert( pC!=0 );\n<line23>assert( pC->eCurType==CURTYPE_BTREE );\n<line24>type = pC->nHdrParsed>p->iCol ? pC->aType[p->iCol] : 0;\n<line25>testcase( pC->nHdrParsed==p->iCol );\n<line26>testcase( pC->nHdrParsed==p->iCol+1 );\n<line27>if( type<12 ){\n<line28>zErr = sqlite3MPrintf(p->db, "cannot open value of type %s",\n<line29>type==0?"null": type==7?"real": "integer"\n<line30>);\n<line31>rc = SQLITE_ERROR;\n<line32>sqlite3_finalize(p->pStmt);\n<line33>p->pStmt = 0;\n<line34>}else{\n<line35>p->iOffset = pC->aType[p->iCol + pC->nField];\n<line36>p->nByte = sqlite3VdbeSerialTypeLen(type);\n<line37>p->pCsr =  pC->uc.pCursor;\n<line38>sqlite3BtreeIncrblobCursor(p->pCsr);\n<line39>}\n<line40>}\n<line41>if( rc==SQLITE_ROW ){\n<line42>rc = SQLITE_OK;\n<line43>}else if( p->pStmt ){\n<line44>rc = sqlite3_finalize(p->pStmt);\n<line45>p->pStmt = 0;\n<line46>if( rc==SQLITE_OK ){\n<line47>zErr = sqlite3MPrintf(p->db, "no such rowid: %lld", iRow);\n<line48>rc = SQLITE_ERROR;\n<line49>}else{\n<line50>zErr = sqlite3MPrintf(p->db, "%s", sqlite3_errmsg(p->db));\n<line51>}\n<line52>}\n<line53>assert( rc!=SQLITE_OK || zErr==0 );\n<line54>assert( rc!=SQLITE_ROW && rc!=SQLITE_DONE );\n<line55>*pzErr = zErr;\n<line56>return rc;\n<line57>}
----------------------------------------
Function: sqlite3_blob_open
Content: <line0>SQLITE_API int sqlite3_blob_open(\n<line1>sqlite3* db,            /* The database connection */\n<line2>const char *zDb,        /* The attached database containing the blob */\n<line3>const char *zTable,     /* The table containing the blob */\n<line4>const char *zColumn,    /* The column containing the blob */\n<line5>sqlite_int64 iRow,      /* The row containing the glob */\n<line6>int wrFlag,             /* True -> read/write access, false -> read-only */\n<line7>sqlite3_blob **ppBlob   /* Handle for accessing the blob returned here */\n<line8>){\n<line9>int nAttempt = 0;\n<line10>int iCol;               /* Index of zColumn in row-record */\n<line11>int rc = SQLITE_OK;\n<line12>char *zErr = 0;\n<line13>Table *pTab;\n<line14>Incrblob *pBlob = 0;\n<line15>int iDb;\n<line16>Parse sParse;\n<line17>#ifdef SQLITE_ENABLE_API_ARMOR\n<line18>if( ppBlob==0 ){\n<line19>return SQLITE_MISUSE_BKPT;\n<line20>}\n<line21>#endif\n<line22>*ppBlob = 0;\n<line23>#ifdef SQLITE_ENABLE_API_ARMOR\n<line24>if( !sqlite3SafetyCheckOk(db) || zTable==0 || zColumn==0 ){\n<line25>return SQLITE_MISUSE_BKPT;\n<line26>}\n<line27>#endif\n<line28>wrFlag = !!wrFlag;                /* wrFlag = (wrFlag ? 1 : 0); */\n<line29>sqlite3_mutex_enter(db->mutex);\n<line30>pBlob = (Incrblob *)sqlite3DbMallocZero(db, sizeof(Incrblob));\n<line31>while(1){\n<line32>sqlite3ParseObjectInit(&sParse,db);\n<line33>if( !pBlob ) goto blob_open_out;\n<line34>sqlite3DbFree(db, zErr);\n<line35>zErr = 0;\n<line36>sqlite3BtreeEnterAll(db);\n<line37>pTab = sqlite3LocateTable(&sParse, 0, zTable, zDb);\n<line38>if( pTab && IsVirtual(pTab) ){\n<line39>pTab = 0;\n<line40>sqlite3ErrorMsg(&sParse, "cannot open virtual table: %s", zTable);\n<line41>}\n<line42>if( pTab && !HasRowid(pTab) ){\n<line43>pTab = 0;\n<line44>sqlite3ErrorMsg(&sParse, "cannot open table without rowid: %s", zTable);\n<line45>}\n<line46>if( pTab && (pTab->tabFlags&TF_HasGenerated)!=0 ){\n<line47>pTab = 0;\n<line48>sqlite3ErrorMsg(&sParse, "cannot open table with generated columns: %s",\n<line49>zTable);\n<line50>}\n<line51>#ifndef SQLITE_OMIT_VIEW\n<line52>if( pTab && IsView(pTab) ){\n<line53>pTab = 0;\n<line54>sqlite3ErrorMsg(&sParse, "cannot open view: %s", zTable);\n<line55>}\n<line56>#endif\n<line57>if( pTab==0\n<line58>|| ((iDb = sqlite3SchemaToIndex(db, pTab->pSchema))==1 &&\n<line59>sqlite3OpenTempDatabase(&sParse))\n<line60>){\n<line61>if( sParse.zErrMsg ){\n<line62>sqlite3DbFree(db, zErr);\n<line63>zErr = sParse.zErrMsg;\n<line64>sParse.zErrMsg = 0;\n<line65>}\n<line66>rc = SQLITE_ERROR;\n<line67>sqlite3BtreeLeaveAll(db);\n<line68>goto blob_open_out;\n<line69>}\n<line70>pBlob->pTab = pTab;\n<line71>pBlob->zDb = db->aDb[iDb].zDbSName;\n<line72>/* Now search pTab for the exact column. */\n<line73>iCol = sqlite3ColumnIndex(pTab, zColumn);\n<line74>if( iCol<0 ){\n<line75>sqlite3DbFree(db, zErr);\n<line76>zErr = sqlite3MPrintf(db, "no such column: \"%s\"", zColumn);\n<line77>rc = SQLITE_ERROR;\n<line78>sqlite3BtreeLeaveAll(db);\n<line79>goto blob_open_out;\n<line80>}\n<line81>/* If the value is being opened for writing, check that the\n<line82>** column is not indexed, and that it is not part of a foreign key.\n<line83>*/\n<line84>if( wrFlag ){\n<line85>const char *zFault = 0;\n<line86>Index *pIdx;\n<line87>#ifndef SQLITE_OMIT_FOREIGN_KEY\n<line88>if( db->flags&SQLITE_ForeignKeys ){\n<line89>/* Check that the column is not part of an FK child key definition. It\n<line90>** is not necessary to check if it is part of a parent key, as parent\n<line91>** key columns must be indexed. The check below will pick up this\n<line92>** case.  */\n<line93>FKey *pFKey;\n<line94>assert( IsOrdinaryTable(pTab) );\n<line95>for(pFKey=pTab->u.tab.pFKey; pFKey; pFKey=pFKey->pNextFrom){\n<line96>int j;\n<line97>for(j=0; j<pFKey->nCol; j++){\n<line98>if( pFKey->aCol[j].iFrom==iCol ){\n<line99>zFault = "foreign key";\n<line100>}\n<line101>}\n<line102>}\n<line103>}\n<line104>#endif\n<line105>for(pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext){\n<line106>int j;\n<line107>for(j=0; j<pIdx->nKeyCol; j++){\n<line108>/* FIXME: Be smarter about indexes that use expressions */\n<line109>if( pIdx->aiColumn[j]==iCol || pIdx->aiColumn[j]==XN_EXPR ){\n<line110>zFault = "indexed";\n<line111>}\n<line112>}\n<line113>}\n<line114>if( zFault ){\n<line115>sqlite3DbFree(db, zErr);\n<line116>zErr = sqlite3MPrintf(db, "cannot open %s column for writing", zFault);\n<line117>rc = SQLITE_ERROR;\n<line118>sqlite3BtreeLeaveAll(db);\n<line119>goto blob_open_out;\n<line120>}\n<line121>}\n<line122>pBlob->pStmt = (sqlite3_stmt *)sqlite3VdbeCreate(&sParse);\n<line123>assert( pBlob->pStmt || db->mallocFailed );\n<line124>if( pBlob->pStmt ){\n<line125>/* This VDBE program seeks a btree cursor to the identified\n<line126>** db/table/row entry. The reason for using a vdbe program instead\n<line127>** of writing code to use the b-tree layer directly is that the\n<line128>** vdbe program will take advantage of the various transaction,\n<line129>** locking and error handling infrastructure built into the vdbe.\n<line130>**\n<line131>** After seeking the cursor, the vdbe executes an OP_ResultRow.\n<line132>** Code external to the Vdbe then "borrows" the b-tree cursor and\n<line133>** uses it to implement the blob_read(), blob_write() and\n<line134>** blob_bytes() functions.\n<line135>**\n<line136>** The sqlite3_blob_close() function finalizes the vdbe program,\n<line137>** which closes the b-tree cursor and (possibly) commits the\n<line138>** transaction.\n<line139>*/\n<line140>static const int iLn = VDBE_OFFSET_LINENO(2);\n<line141>static const VdbeOpList openBlob[] = {\n<line142>{OP_TableLock,      0, 0, 0},  /* 0: Acquire a read or write lock */\n<line143>{OP_OpenRead,       0, 0, 0},  /* 1: Open a cursor */\n<line144>/* blobSeekToRow() will initialize r[1] to the desired rowid */\n<line145>{OP_NotExists,      0, 5, 1},  /* 2: Seek the cursor to rowid=r[1] */\n<line146>{OP_Column,         0, 0, 1},  /* 3  */\n<line147>{OP_ResultRow,      1, 0, 0},  /* 4  */\n<line148>{OP_Halt,           0, 0, 0},  /* 5  */\n<line149>};\n<line150>Vdbe *v = (Vdbe *)pBlob->pStmt;\n<line151>VdbeOp *aOp;\n<line152>sqlite3VdbeAddOp4Int(v, OP_Transaction, iDb, wrFlag,\n<line153>pTab->pSchema->schema_cookie,\n<line154>pTab->pSchema->iGeneration);\n<line155>sqlite3VdbeChangeP5(v, 1);\n<line156>assert( sqlite3VdbeCurrentAddr(v)==2 || db->mallocFailed );\n<line157>aOp = sqlite3VdbeAddOpList(v, ArraySize(openBlob), openBlob, iLn);\n<line158>/* Make sure a mutex is held on the table to be accessed */\n<line159>sqlite3VdbeUsesBtree(v, iDb);\n<line160>if( db->mallocFailed==0 ){\n<line161>assert( aOp!=0 );\n<line162>/* Configure the OP_TableLock instruction */\n<line163>#ifdef SQLITE_OMIT_SHARED_CACHE\n<line164>aOp[0].opcode = OP_Noop;\n<line165>#else\n<line166>aOp[0].p1 = iDb;\n<line167>aOp[0].p2 = pTab->tnum;\n<line168>aOp[0].p3 = wrFlag;\n<line169>sqlite3VdbeChangeP4(v, 2, pTab->zName, P4_TRANSIENT);\n<line170>}\n<line171>if( db->mallocFailed==0 ){\n<line172>#endif\n<line173>/* Remove either the OP_OpenWrite or OpenRead. Set the P2\n<line174>** parameter of the other to pTab->tnum.  */\n<line175>if( wrFlag ) aOp[1].opcode = OP_OpenWrite;\n<line176>aOp[1].p2 = pTab->tnum;\n<line177>aOp[1].p3 = iDb;\n<line178>/* Configure the number of columns. Configure the cursor to\n<line179>** think that the table has one more column than it really\n<line180>** does. An OP_Column to retrieve this imaginary column will\n<line181>** always return an SQL NULL. This is useful because it means\n<line182>** we can invoke OP_Column to fill in the vdbe cursors type\n<line183>** and offset cache without causing any IO.\n<line184>*/\n<line185>aOp[1].p4type = P4_INT32;\n<line186>aOp[1].p4.i = pTab->nCol+1;\n<line187>aOp[3].p2 = pTab->nCol;\n<line188>sParse.nVar = 0;\n<line189>sParse.nMem = 1;\n<line190>sParse.nTab = 1;\n<line191>sqlite3VdbeMakeReady(v, &sParse);\n<line192>}\n<line193>}\n<line194>pBlob->iCol = iCol;\n<line195>pBlob->db = db;\n<line196>sqlite3BtreeLeaveAll(db);\n<line197>if( db->mallocFailed ){\n<line198>goto blob_open_out;\n<line199>}\n<line200>rc = blobSeekToRow(pBlob, iRow, &zErr);\n<line201>if( (++nAttempt)>=SQLITE_MAX_SCHEMA_RETRY || rc!=SQLITE_SCHEMA ) break;\n<line202>sqlite3ParseObjectReset(&sParse);\n<line203>}\n<line204>blob_open_out:\n<line205>if( rc==SQLITE_OK && db->mallocFailed==0 ){\n<line206>*ppBlob = (sqlite3_blob *)pBlob;\n<line207>}else{\n<line208>if( pBlob && pBlob->pStmt ) sqlite3VdbeFinalize((Vdbe *)pBlob->pStmt);\n<line209>sqlite3DbFree(db, pBlob);\n<line210>}\n<line211>sqlite3ErrorWithMsg(db, rc, (zErr ? "%s" : (char*)0), zErr);\n<line212>sqlite3DbFree(db, zErr);\n<line213>sqlite3ParseObjectReset(&sParse);\n<line214>rc = sqlite3ApiExit(db, rc);\n<line215>sqlite3_mutex_leave(db->mutex);\n<line216>return rc;\n<line217>}
----------------------------------------
Function: sqlite3_blob_close
Content: <line0>SQLITE_API int sqlite3_blob_close(sqlite3_blob *pBlob){\n<line1>Incrblob *p = (Incrblob *)pBlob;\n<line2>int rc;\n<line3>sqlite3 *db;\n<line4>if( p ){\n<line5>sqlite3_stmt *pStmt = p->pStmt;\n<line6>db = p->db;\n<line7>sqlite3_mutex_enter(db->mutex);\n<line8>sqlite3DbFree(db, p);\n<line9>sqlite3_mutex_leave(db->mutex);\n<line10>rc = sqlite3_finalize(pStmt);\n<line11>}else{\n<line12>rc = SQLITE_OK;\n<line13>}\n<line14>return rc;\n<line15>}
----------------------------------------
Function: blobReadWrite
Content: <line0>static int blobReadWrite(\n<line1>sqlite3_blob *pBlob,\n<line2>void *z,\n<line3>int n,\n<line4>int iOffset,\n<line5>int (*xCall)(BtCursor*, u32, u32, void*)\n<line6>){\n<line7>int rc = SQLITE_OK;\n<line8>Incrblob *p = (Incrblob *)pBlob;\n<line9>Vdbe *v;\n<line10>sqlite3 *db;\n<line11>if( p==0 ) return SQLITE_MISUSE_BKPT;\n<line12>db = p->db;\n<line13>sqlite3_mutex_enter(db->mutex);\n<line14>v = (Vdbe*)p->pStmt;\n<line15>if( n<0 || iOffset<0 || ((sqlite3_int64)iOffset+n)>p->nByte ){\n<line16>/* Request is out of range. Return a transient error. */\n<line17>rc = SQLITE_ERROR;\n<line18>}else if( v==0 ){\n<line19>/* If there is no statement handle, then the blob-handle has\n<line20>** already been invalidated. Return SQLITE_ABORT in this case.\n<line21>*/\n<line22>rc = SQLITE_ABORT;\n<line23>}else{\n<line24>/* Call either BtreeData() or BtreePutData(). If SQLITE_ABORT is\n<line25>** returned, clean-up the statement handle.\n<line26>*/\n<line27>assert( db == v->db );\n<line28>sqlite3BtreeEnterCursor(p->pCsr);\n<line29>#ifdef SQLITE_ENABLE_PREUPDATE_HOOK\n<line30>if( xCall==sqlite3BtreePutData && db->xPreUpdateCallback ){\n<line31>/* If a pre-update hook is registered and this is a write cursor,\n<line32>** invoke it here.\n<line33>**\n<line34>** TODO: The preupdate-hook is passed SQLITE_DELETE, even though this\n<line35>** operation should really be an SQLITE_UPDATE. This is probably\n<line36>** incorrect, but is convenient because at this point the new.* values\n<line37>** are not easily obtainable. And for the sessions module, an\n<line38>** SQLITE_UPDATE where the PK columns do not change is handled in the\n<line39>** same way as an SQLITE_DELETE (the SQLITE_DELETE code is actually\n<line40>** slightly more efficient). Since you cannot write to a PK column\n<line41>** using the incremental-blob API, this works. For the sessions module\n<line42>** anyhow.\n<line43>*/\n<line44>if( sqlite3BtreeCursorIsValidNN(p->pCsr)==0 ){\n<line45>/* If the cursor is not currently valid, try to reseek it. This\n<line46>** always either fails or finds the correct row - the cursor will\n<line47>** have been marked permanently CURSOR_INVALID if the open row has\n<line48>** been deleted.  */\n<line49>int bDiff = 0;\n<line50>rc = sqlite3BtreeCursorRestore(p->pCsr, &bDiff);\n<line51>assert( bDiff==0 || sqlite3BtreeCursorIsValidNN(p->pCsr)==0 );\n<line52>}\n<line53>if( sqlite3BtreeCursorIsValidNN(p->pCsr) ){\n<line54>sqlite3_int64 iKey;\n<line55>iKey = sqlite3BtreeIntegerKey(p->pCsr);\n<line56>assert( v->apCsr[0]!=0 );\n<line57>assert( v->apCsr[0]->eCurType==CURTYPE_BTREE );\n<line58>sqlite3VdbePreUpdateHook(\n<line59>v, v->apCsr[0], SQLITE_DELETE, p->zDb, p->pTab, iKey, -1, p->iCol\n<line60>);\n<line61>}\n<line62>}\n<line63>if( rc==SQLITE_OK ){\n<line64>rc = xCall(p->pCsr, iOffset+p->iOffset, n, z);\n<line65>}\n<line66>#else\n<line67>rc = xCall(p->pCsr, iOffset+p->iOffset, n, z);\n<line68>#endif\n<line69>sqlite3BtreeLeaveCursor(p->pCsr);\n<line70>if( rc==SQLITE_ABORT ){\n<line71>sqlite3VdbeFinalize(v);\n<line72>p->pStmt = 0;\n<line73>}else{\n<line74>v->rc = rc;\n<line75>}\n<line76>}\n<line77>sqlite3Error(db, rc);\n<line78>rc = sqlite3ApiExit(db, rc);\n<line79>sqlite3_mutex_leave(db->mutex);\n<line80>return rc;\n<line81>}
----------------------------------------
Function: sqlite3_blob_read
Content: <line0>SQLITE_API int sqlite3_blob_read(sqlite3_blob *pBlob, void *z, int n, int iOffset){\n<line1>return blobReadWrite(pBlob, z, n, iOffset, sqlite3BtreePayloadChecked);\n<line2>}
----------------------------------------
Function: sqlite3_blob_write
Content: <line0>SQLITE_API int sqlite3_blob_write(sqlite3_blob *pBlob, const void *z, int n, int iOffset){\n<line1>return blobReadWrite(pBlob, (void *)z, n, iOffset, sqlite3BtreePutData);\n<line2>}
----------------------------------------
Function: sqlite3_blob_bytes
Content: <line0>SQLITE_API int sqlite3_blob_bytes(sqlite3_blob *pBlob){\n<line1>Incrblob *p = (Incrblob *)pBlob;\n<line2>return (p && p->pStmt) ? p->nByte : 0;\n<line3>}
----------------------------------------
Function: sqlite3_blob_reopen
Content: <line0>SQLITE_API int sqlite3_blob_reopen(sqlite3_blob *pBlob, sqlite3_int64 iRow){\n<line1>int rc;\n<line2>Incrblob *p = (Incrblob *)pBlob;\n<line3>sqlite3 *db;\n<line4>if( p==0 ) return SQLITE_MISUSE_BKPT;\n<line5>db = p->db;\n<line6>sqlite3_mutex_enter(db->mutex);\n<line7>if( p->pStmt==0 ){\n<line8>/* If there is no statement handle, then the blob-handle has\n<line9>** already been invalidated. Return SQLITE_ABORT in this case.\n<line10>*/\n<line11>rc = SQLITE_ABORT;\n<line12>}else{\n<line13>char *zErr;\n<line14>((Vdbe*)p->pStmt)->rc = SQLITE_OK;\n<line15>rc = blobSeekToRow(p, iRow, &zErr);\n<line16>if( rc!=SQLITE_OK ){\n<line17>sqlite3ErrorWithMsg(db, rc, (zErr ? "%s" : (char*)0), zErr);\n<line18>sqlite3DbFree(db, zErr);\n<line19>}\n<line20>assert( rc!=SQLITE_SCHEMA );\n<line21>}\n<line22>rc = sqlite3ApiExit(db, rc);\n<line23>assert( rc==SQLITE_OK || p->pStmt==0 );\n<line24>sqlite3_mutex_leave(db->mutex);\n<line25>return rc;\n<line26>}
----------------------------------------
Function: vdbePmaReaderClear
Content: <line0>static void vdbePmaReaderClear(PmaReader *pReadr){\n<line1>sqlite3_free(pReadr->aAlloc);\n<line2>sqlite3_free(pReadr->aBuffer);\n<line3>if( pReadr->aMap ) sqlite3OsUnfetch(pReadr->pFd, 0, pReadr->aMap);\n<line4>vdbeIncrFree(pReadr->pIncr);\n<line5>memset(pReadr, 0, sizeof(PmaReader));\n<line6>}
----------------------------------------
Function: vdbePmaReadBlob
Content: <line0>static int vdbePmaReadBlob(\n<line1>PmaReader *p,                   /* PmaReader from which to take the blob */\n<line2>int nByte,                      /* Bytes of data to read */\n<line3>u8 **ppOut                      /* OUT: Pointer to buffer containing data */\n<line4>){\n<line5>int iBuf;                       /* Offset within buffer to read from */\n<line6>int nAvail;                     /* Bytes of data available in buffer */\n<line7>if( p->aMap ){\n<line8>*ppOut = &p->aMap[p->iReadOff];\n<line9>p->iReadOff += nByte;\n<line10>return SQLITE_OK;\n<line11>}\n<line12>assert( p->aBuffer );\n<line13>/* If there is no more data to be read from the buffer, read the next\n<line14>** p->nBuffer bytes of data from the file into it. Or, if there are less\n<line15>** than p->nBuffer bytes remaining in the PMA, read all remaining data.  */\n<line16>iBuf = p->iReadOff % p->nBuffer;\n<line17>if( iBuf==0 ){\n<line18>int nRead;                    /* Bytes to read from disk */\n<line19>int rc;                       /* sqlite3OsRead() return code */\n<line20>/* Determine how many bytes of data to read. */\n<line21>if( (p->iEof - p->iReadOff) > (i64)p->nBuffer ){\n<line22>nRead = p->nBuffer;\n<line23>}else{\n<line24>nRead = (int)(p->iEof - p->iReadOff);\n<line25>}\n<line26>assert( nRead>0 );\n<line27>/* Readr data from the file. Return early if an error occurs. */\n<line28>rc = sqlite3OsRead(p->pFd, p->aBuffer, nRead, p->iReadOff);\n<line29>assert( rc!=SQLITE_IOERR_SHORT_READ );\n<line30>if( rc!=SQLITE_OK ) return rc;\n<line31>}\n<line32>nAvail = p->nBuffer - iBuf;\n<line33>if( nByte<=nAvail ){\n<line34>/* The requested data is available in the in-memory buffer. In this\n<line35>** case there is no need to make a copy of the data, just return a\n<line36>** pointer into the buffer to the caller.  */\n<line37>*ppOut = &p->aBuffer[iBuf];\n<line38>p->iReadOff += nByte;\n<line39>}else{\n<line40>/* The requested data is not all available in the in-memory buffer.\n<line41>** In this case, allocate space at p->aAlloc[] to copy the requested\n<line42>** range into. Then return a copy of pointer p->aAlloc to the caller.  */\n<line43>int nRem;                     /* Bytes remaining to copy */\n<line44>/* Extend the p->aAlloc[] allocation if required. */\n<line45>if( p->nAlloc<nByte ){\n<line46>u8 *aNew;\n<line47>sqlite3_int64 nNew = MAX(128, 2*(sqlite3_int64)p->nAlloc);\n<line48>while( nByte>nNew ) nNew = nNew*2;\n<line49>aNew = sqlite3Realloc(p->aAlloc, nNew);\n<line50>if( !aNew ) return SQLITE_NOMEM_BKPT;\n<line51>p->nAlloc = nNew;\n<line52>p->aAlloc = aNew;\n<line53>}\n<line54>/* Copy as much data as is available in the buffer into the start of\n<line55>** p->aAlloc[].  */\n<line56>memcpy(p->aAlloc, &p->aBuffer[iBuf], nAvail);\n<line57>p->iReadOff += nAvail;\n<line58>nRem = nByte - nAvail;\n<line59>/* The following loop copies up to p->nBuffer bytes per iteration into\n<line60>** the p->aAlloc[] buffer.  */\n<line61>while( nRem>0 ){\n<line62>int rc;                     /* vdbePmaReadBlob() return code */\n<line63>int nCopy;                  /* Number of bytes to copy */\n<line64>u8 *aNext = 0;              /* Pointer to buffer to copy data from */\n<line65>nCopy = nRem;\n<line66>if( nRem>p->nBuffer ) nCopy = p->nBuffer;\n<line67>rc = vdbePmaReadBlob(p, nCopy, &aNext);\n<line68>if( rc!=SQLITE_OK ) return rc;\n<line69>assert( aNext!=p->aAlloc );\n<line70>assert( aNext!=0 );\n<line71>memcpy(&p->aAlloc[nByte - nRem], aNext, nCopy);\n<line72>nRem -= nCopy;\n<line73>}\n<line74>*ppOut = p->aAlloc;\n<line75>}\n<line76>return SQLITE_OK;\n<line77>}
----------------------------------------
Function: vdbePmaReadVarint
Content: <line0>static int vdbePmaReadVarint(PmaReader *p, u64 *pnOut){\n<line1>int iBuf;\n<line2>if( p->aMap ){\n<line3>p->iReadOff += sqlite3GetVarint(&p->aMap[p->iReadOff], pnOut);\n<line4>}else{\n<line5>iBuf = p->iReadOff % p->nBuffer;\n<line6>if( iBuf && (p->nBuffer-iBuf)>=9 ){\n<line7>p->iReadOff += sqlite3GetVarint(&p->aBuffer[iBuf], pnOut);\n<line8>}else{\n<line9>u8 aVarint[16], *a;\n<line10>int i = 0, rc;\n<line11>do{\n<line12>rc = vdbePmaReadBlob(p, 1, &a);\n<line13>if( rc ) return rc;\n<line14>aVarint[(i++)&0xf] = a[0];\n<line15>}while( (a[0]&0x80)!=0 );\n<line16>sqlite3GetVarint(aVarint, pnOut);\n<line17>}\n<line18>}\n<line19>return SQLITE_OK;\n<line20>}
----------------------------------------
Function: vdbeSorterMapFile
Content: <line0>static int vdbeSorterMapFile(SortSubtask *pTask, SorterFile *pFile, u8 **pp){\n<line1>int rc = SQLITE_OK;\n<line2>if( pFile->iEof<=(i64)(pTask->pSorter->db->nMaxSorterMmap) ){\n<line3>sqlite3_file *pFd = pFile->pFd;\n<line4>if( pFd->pMethods->iVersion>=3 ){\n<line5>rc = sqlite3OsFetch(pFd, 0, (int)pFile->iEof, (void**)pp);\n<line6>testcase( rc!=SQLITE_OK );\n<line7>}\n<line8>}\n<line9>return rc;\n<line10>}
----------------------------------------
Function: vdbePmaReaderSeek
Content: <line0>static int vdbePmaReaderSeek(\n<line1>SortSubtask *pTask,             /* Task context */\n<line2>PmaReader *pReadr,              /* Reader whose cursor is to be moved */\n<line3>SorterFile *pFile,              /* Sorter file to read from */\n<line4>i64 iOff                        /* Offset in pFile */\n<line5>){\n<line6>int rc = SQLITE_OK;\n<line7>assert( pReadr->pIncr==0 || pReadr->pIncr->bEof==0 );\n<line8>if( sqlite3FaultSim(201) ) return SQLITE_IOERR_READ;\n<line9>if( pReadr->aMap ){\n<line10>sqlite3OsUnfetch(pReadr->pFd, 0, pReadr->aMap);\n<line11>pReadr->aMap = 0;\n<line12>}\n<line13>pReadr->iReadOff = iOff;\n<line14>pReadr->iEof = pFile->iEof;\n<line15>pReadr->pFd = pFile->pFd;\n<line16>rc = vdbeSorterMapFile(pTask, pFile, &pReadr->aMap);\n<line17>if( rc==SQLITE_OK && pReadr->aMap==0 ){\n<line18>int pgsz = pTask->pSorter->pgsz;\n<line19>int iBuf = pReadr->iReadOff % pgsz;\n<line20>if( pReadr->aBuffer==0 ){\n<line21>pReadr->aBuffer = (u8*)sqlite3Malloc(pgsz);\n<line22>if( pReadr->aBuffer==0 ) rc = SQLITE_NOMEM_BKPT;\n<line23>pReadr->nBuffer = pgsz;\n<line24>}\n<line25>if( rc==SQLITE_OK && iBuf ){\n<line26>int nRead = pgsz - iBuf;\n<line27>if( (pReadr->iReadOff + nRead) > pReadr->iEof ){\n<line28>nRead = (int)(pReadr->iEof - pReadr->iReadOff);\n<line29>}\n<line30>rc = sqlite3OsRead(\n<line31>pReadr->pFd, &pReadr->aBuffer[iBuf], nRead, pReadr->iReadOff\n<line32>);\n<line33>testcase( rc!=SQLITE_OK );\n<line34>}\n<line35>}\n<line36>return rc;\n<line37>}
----------------------------------------
Function: vdbePmaReaderNext
Content: <line0>static int vdbePmaReaderNext(PmaReader *pReadr){\n<line1>int rc = SQLITE_OK;             /* Return Code */\n<line2>u64 nRec = 0;                   /* Size of record in bytes */\n<line3>if( pReadr->iReadOff>=pReadr->iEof ){\n<line4>IncrMerger *pIncr = pReadr->pIncr;\n<line5>int bEof = 1;\n<line6>if( pIncr ){\n<line7>rc = vdbeIncrSwap(pIncr);\n<line8>if( rc==SQLITE_OK && pIncr->bEof==0 ){\n<line9>rc = vdbePmaReaderSeek(\n<line10>pIncr->pTask, pReadr, &pIncr->aFile[0], pIncr->iStartOff\n<line11>);\n<line12>bEof = 0;\n<line13>}\n<line14>}\n<line15>if( bEof ){\n<line16>/* This is an EOF condition */\n<line17>vdbePmaReaderClear(pReadr);\n<line18>testcase( rc!=SQLITE_OK );\n<line19>return rc;\n<line20>}\n<line21>}\n<line22>if( rc==SQLITE_OK ){\n<line23>rc = vdbePmaReadVarint(pReadr, &nRec);\n<line24>}\n<line25>if( rc==SQLITE_OK ){\n<line26>pReadr->nKey = (int)nRec;\n<line27>rc = vdbePmaReadBlob(pReadr, (int)nRec, &pReadr->aKey);\n<line28>testcase( rc!=SQLITE_OK );\n<line29>}\n<line30>return rc;\n<line31>}
----------------------------------------
Function: vdbePmaReaderInit
Content: <line0>static int vdbePmaReaderInit(\n<line1>SortSubtask *pTask,             /* Task context */\n<line2>SorterFile *pFile,              /* Sorter file to read from */\n<line3>i64 iStart,                     /* Start offset in pFile */\n<line4>PmaReader *pReadr,              /* PmaReader to populate */\n<line5>i64 *pnByte                     /* IN/OUT: Increment this value by PMA size */\n<line6>){\n<line7>int rc;\n<line8>assert( pFile->iEof>iStart );\n<line9>assert( pReadr->aAlloc==0 && pReadr->nAlloc==0 );\n<line10>assert( pReadr->aBuffer==0 );\n<line11>assert( pReadr->aMap==0 );\n<line12>rc = vdbePmaReaderSeek(pTask, pReadr, pFile, iStart);\n<line13>if( rc==SQLITE_OK ){\n<line14>u64 nByte = 0;                 /* Size of PMA in bytes */\n<line15>rc = vdbePmaReadVarint(pReadr, &nByte);\n<line16>pReadr->iEof = pReadr->iReadOff + nByte;\n<line17>*pnByte += nByte;\n<line18>}\n<line19>if( rc==SQLITE_OK ){\n<line20>rc = vdbePmaReaderNext(pReadr);\n<line21>}\n<line22>return rc;\n<line23>}
----------------------------------------
Function: vdbeSorterCompareTail
Content: <line0>static int vdbeSorterCompareTail(\n<line1>SortSubtask *pTask,             /* Subtask context (for pKeyInfo) */\n<line2>int *pbKey2Cached,              /* True if pTask->pUnpacked is pKey2 */\n<line3>const void *pKey1, int nKey1,   /* Left side of comparison */\n<line4>const void *pKey2, int nKey2    /* Right side of comparison */\n<line5>){\n<line6>UnpackedRecord *r2 = pTask->pUnpacked;\n<line7>if( *pbKey2Cached==0 ){\n<line8>sqlite3VdbeRecordUnpack(nKey2, pKey2, r2);\n<line9>*pbKey2Cached = 1;\n<line10>}\n<line11>return sqlite3VdbeRecordCompareWithSkip(nKey1, pKey1, r2, 1);\n<line12>}
----------------------------------------
Function: vdbeSorterCompare
Content: <line0>static int vdbeSorterCompare(\n<line1>SortSubtask *pTask,             /* Subtask context (for pKeyInfo) */\n<line2>int *pbKey2Cached,              /* True if pTask->pUnpacked is pKey2 */\n<line3>const void *pKey1, int nKey1,   /* Left side of comparison */\n<line4>const void *pKey2, int nKey2    /* Right side of comparison */\n<line5>){\n<line6>UnpackedRecord *r2 = pTask->pUnpacked;\n<line7>if( !*pbKey2Cached ){\n<line8>sqlite3VdbeRecordUnpack(nKey2, pKey2, r2);\n<line9>*pbKey2Cached = 1;\n<line10>}\n<line11>return sqlite3VdbeRecordCompare(nKey1, pKey1, r2);\n<line12>}
----------------------------------------
Function: vdbeSorterCompareText
Content: <line0>static int vdbeSorterCompareText(\n<line1>SortSubtask *pTask,             /* Subtask context (for pKeyInfo) */\n<line2>int *pbKey2Cached,              /* True if pTask->pUnpacked is pKey2 */\n<line3>const void *pKey1, int nKey1,   /* Left side of comparison */\n<line4>const void *pKey2, int nKey2    /* Right side of comparison */\n<line5>){\n<line6>const u8 * const p1 = (const u8 * const)pKey1;\n<line7>const u8 * const p2 = (const u8 * const)pKey2;\n<line8>const u8 * const v1 = &p1[ p1[0] ];   /* Pointer to value 1 */\n<line9>const u8 * const v2 = &p2[ p2[0] ];   /* Pointer to value 2 */\n<line10>int n1;\n<line11>int n2;\n<line12>int res;\n<line13>getVarint32NR(&p1[1], n1);\n<line14>getVarint32NR(&p2[1], n2);\n<line15>res = memcmp(v1, v2, (MIN(n1, n2) - 13)/2);\n<line16>if( res==0 ){\n<line17>res = n1 - n2;\n<line18>}\n<line19>if( res==0 ){\n<line20>if( pTask->pSorter->pKeyInfo->nKeyField>1 ){\n<line21>res = vdbeSorterCompareTail(\n<line22>pTask, pbKey2Cached, pKey1, nKey1, pKey2, nKey2\n<line23>);\n<line24>}\n<line25>}else{\n<line26>assert( pTask->pSorter->pKeyInfo->aSortFlags!=0 );\n<line27>assert( !(pTask->pSorter->pKeyInfo->aSortFlags[0]&KEYINFO_ORDER_BIGNULL) );\n<line28>if( pTask->pSorter->pKeyInfo->aSortFlags[0] ){\n<line29>res = res * -1;\n<line30>}\n<line31>}\n<line32>return res;\n<line33>}
----------------------------------------
Function: vdbeSorterCompareInt
Content: <line0>static int vdbeSorterCompareInt(\n<line1>SortSubtask *pTask,             /* Subtask context (for pKeyInfo) */\n<line2>int *pbKey2Cached,              /* True if pTask->pUnpacked is pKey2 */\n<line3>const void *pKey1, int nKey1,   /* Left side of comparison */\n<line4>const void *pKey2, int nKey2    /* Right side of comparison */\n<line5>){\n<line6>const u8 * const p1 = (const u8 * const)pKey1;\n<line7>const u8 * const p2 = (const u8 * const)pKey2;\n<line8>const int s1 = p1[1];                 /* Left hand serial type */\n<line9>const int s2 = p2[1];                 /* Right hand serial type */\n<line10>const u8 * const v1 = &p1[ p1[0] ];   /* Pointer to value 1 */\n<line11>const u8 * const v2 = &p2[ p2[0] ];   /* Pointer to value 2 */\n<line12>int res;                              /* Return value */\n<line13>assert( (s1>0 && s1<7) || s1==8 || s1==9 );\n<line14>assert( (s2>0 && s2<7) || s2==8 || s2==9 );\n<line15>if( s1==s2 ){\n<line16>/* The two values have the same sign. Compare using memcmp(). */\n<line17>static const u8 aLen[] = {0, 1, 2, 3, 4, 6, 8, 0, 0, 0 };\n<line18>const u8 n = aLen[s1];\n<line19>int i;\n<line20>res = 0;\n<line21>for(i=0; i<n; i++){\n<line22>if( (res = v1[i] - v2[i])!=0 ){\n<line23>if( ((v1[0] ^ v2[0]) & 0x80)!=0 ){\n<line24>res = v1[0] & 0x80 ? -1 : +1;\n<line25>}\n<line26>break;\n<line27>}\n<line28>}\n<line29>}else if( s1>7 && s2>7 ){\n<line30>res = s1 - s2;\n<line31>}else{\n<line32>if( s2>7 ){\n<line33>res = +1;\n<line34>}else if( s1>7 ){\n<line35>res = -1;\n<line36>}else{\n<line37>res = s1 - s2;\n<line38>}\n<line39>assert( res!=0 );\n<line40>if( res>0 ){\n<line41>if( *v1 & 0x80 ) res = -1;\n<line42>}else{\n<line43>if( *v2 & 0x80 ) res = +1;\n<line44>}\n<line45>}\n<line46>assert( pTask->pSorter->pKeyInfo->aSortFlags!=0 );\n<line47>if( res==0 ){\n<line48>if( pTask->pSorter->pKeyInfo->nKeyField>1 ){\n<line49>res = vdbeSorterCompareTail(\n<line50>pTask, pbKey2Cached, pKey1, nKey1, pKey2, nKey2\n<line51>);\n<line52>}\n<line53>}else if( pTask->pSorter->pKeyInfo->aSortFlags[0] ){\n<line54>assert( !(pTask->pSorter->pKeyInfo->aSortFlags[0]&KEYINFO_ORDER_BIGNULL) );\n<line55>res = res * -1;\n<line56>}\n<line57>return res;\n<line58>}
----------------------------------------
Function: vdbeSorterRecordFree
Content: <line0>static void vdbeSorterRecordFree(sqlite3 *db, SorterRecord *pRecord){\n<line1>SorterRecord *p;\n<line2>SorterRecord *pNext;\n<line3>for(p=pRecord; p; p=pNext){\n<line4>pNext = p->u.pNext;\n<line5>sqlite3DbFree(db, p);\n<line6>}\n<line7>}
----------------------------------------
Function: vdbeSortSubtaskCleanup
Content: <line0>static void vdbeSortSubtaskCleanup(sqlite3 *db, SortSubtask *pTask){\n<line1>sqlite3DbFree(db, pTask->pUnpacked);\n<line2>#if SQLITE_MAX_WORKER_THREADS>0\n<line3>/* pTask->list.aMemory can only be non-zero if it was handed memory\n<line4>** from the main thread.  That only occurs SQLITE_MAX_WORKER_THREADS>0 */\n<line5>if( pTask->list.aMemory ){\n<line6>sqlite3_free(pTask->list.aMemory);\n<line7>}else\n<line8>#endif\n<line9>{\n<line10>assert( pTask->list.aMemory==0 );\n<line11>vdbeSorterRecordFree(0, pTask->list.pList);\n<line12>}\n<line13>if( pTask->file.pFd ){\n<line14>sqlite3OsCloseFree(pTask->file.pFd);\n<line15>}\n<line16>if( pTask->file2.pFd ){\n<line17>sqlite3OsCloseFree(pTask->file2.pFd);\n<line18>}\n<line19>memset(pTask, 0, sizeof(SortSubtask));\n<line20>}
----------------------------------------
Function: vdbeSorterJoinThread
Content: <line0>static int vdbeSorterJoinThread(SortSubtask *pTask){\n<line1>int rc = SQLITE_OK;\n<line2>if( pTask->pThread ){\n<line3>#ifdef SQLITE_DEBUG_SORTER_THREADS\n<line4>int bDone = pTask->bDone;\n<line5>#endif\n<line6>void *pRet = SQLITE_INT_TO_PTR(SQLITE_ERROR);\n<line7>vdbeSorterBlockDebug(pTask, !bDone, "enter");\n<line8>(void)sqlite3ThreadJoin(pTask->pThread, &pRet);\n<line9>vdbeSorterBlockDebug(pTask, !bDone, "exit");\n<line10>rc = SQLITE_PTR_TO_INT(pRet);\n<line11>assert( pTask->bDone==1 );\n<line12>pTask->bDone = 0;\n<line13>pTask->pThread = 0;\n<line14>}\n<line15>return rc;\n<line16>}
----------------------------------------
Function: vdbeSorterCreateThread
Content: <line0>static int vdbeSorterCreateThread(\n<line1>SortSubtask *pTask,             /* Thread will use this task object */\n<line2>void *(*xTask)(void*),          /* Routine to run in a separate thread */\n<line3>void *pIn                       /* Argument passed into xTask() */\n<line4>){\n<line5>assert( pTask->pThread==0 && pTask->bDone==0 );\n<line6>return sqlite3ThreadCreate(&pTask->pThread, xTask, pIn);\n<line7>}
----------------------------------------
Function: vdbeSorterJoinAll
Content: <line0>static int vdbeSorterJoinAll(VdbeSorter *pSorter, int rcin){\n<line1>int rc = rcin;\n<line2>int i;\n<line3>/* This function is always called by the main user thread.\n<line4>**\n<line5>** If this function is being called after SorterRewind() has been called,\n<line6>** it is possible that thread pSorter->aTask[pSorter->nTask-1].pThread\n<line7>** is currently attempt to join one of the other threads. To avoid a race\n<line8>** condition where this thread also attempts to join the same object, join\n<line9>** thread pSorter->aTask[pSorter->nTask-1].pThread first. */\n<line10>for(i=pSorter->nTask-1; i>=0; i--){\n<line11>SortSubtask *pTask = &pSorter->aTask[i];\n<line12>int rc2 = vdbeSorterJoinThread(pTask);\n<line13>if( rc==SQLITE_OK ) rc = rc2;\n<line14>}\n<line15>return rc;\n<line16>}
----------------------------------------
Function: vdbeMergeEngineNew
Content: <line0>static MergeEngine *vdbeMergeEngineNew(int nReader){\n<line1>int N = 2;                      /* Smallest power of two >= nReader */\n<line2>i64 nByte;                      /* Total bytes of space to allocate */\n<line3>MergeEngine *pNew;              /* Pointer to allocated object to return */\n<line4>assert( nReader<=SORTER_MAX_MERGE_COUNT );\n<line5>while( N<nReader ) N += N;\n<line6>nByte = sizeof(MergeEngine) + N * (sizeof(int) + sizeof(PmaReader));\n<line7>pNew = sqlite3FaultSim(100) ? 0 : (MergeEngine*)sqlite3MallocZero(nByte);\n<line8>if( pNew ){\n<line9>pNew->nTree = N;\n<line10>pNew->pTask = 0;\n<line11>pNew->aReadr = (PmaReader*)&pNew[1];\n<line12>pNew->aTree = (int*)&pNew->aReadr[N];\n<line13>}\n<line14>return pNew;\n<line15>}
----------------------------------------
Function: vdbeMergeEngineFree
Content: <line0>static void vdbeMergeEngineFree(MergeEngine *pMerger){\n<line1>int i;\n<line2>if( pMerger ){\n<line3>for(i=0; i<pMerger->nTree; i++){\n<line4>vdbePmaReaderClear(&pMerger->aReadr[i]);\n<line5>}\n<line6>}\n<line7>sqlite3_free(pMerger);\n<line8>}
----------------------------------------
Function: vdbeIncrFree
Content: <line0>static void vdbeIncrFree(IncrMerger *pIncr){\n<line1>if( pIncr ){\n<line2>#if SQLITE_MAX_WORKER_THREADS>0\n<line3>if( pIncr->bUseThread ){\n<line4>vdbeSorterJoinThread(pIncr->pTask);\n<line5>if( pIncr->aFile[0].pFd ) sqlite3OsCloseFree(pIncr->aFile[0].pFd);\n<line6>if( pIncr->aFile[1].pFd ) sqlite3OsCloseFree(pIncr->aFile[1].pFd);\n<line7>}\n<line8>#endif\n<line9>vdbeMergeEngineFree(pIncr->pMerger);\n<line10>sqlite3_free(pIncr);\n<line11>}\n<line12>}
----------------------------------------
Function: vdbeSorterExtendFile
Content: <line0>static void vdbeSorterExtendFile(sqlite3 *db, sqlite3_file *pFd, i64 nByte){\n<line1>if( nByte<=(i64)(db->nMaxSorterMmap) && pFd->pMethods->iVersion>=3 ){\n<line2>void *p = 0;\n<line3>int chunksize = 4*1024;\n<line4>sqlite3OsFileControlHint(pFd, SQLITE_FCNTL_CHUNK_SIZE, &chunksize);\n<line5>sqlite3OsFileControlHint(pFd, SQLITE_FCNTL_SIZE_HINT, &nByte);\n<line6>sqlite3OsFetch(pFd, 0, (int)nByte, &p);\n<line7>if( p ) sqlite3OsUnfetch(pFd, 0, p);\n<line8>}\n<line9>}
----------------------------------------
Function: vdbeSorterOpenTempFile
Content: <line0>static int vdbeSorterOpenTempFile(\n<line1>sqlite3 *db,                    /* Database handle doing sort */\n<line2>i64 nExtend,                    /* Attempt to extend file to this size */\n<line3>sqlite3_file **ppFd\n<line4>){\n<line5>int rc;\n<line6>if( sqlite3FaultSim(202) ) return SQLITE_IOERR_ACCESS;\n<line7>rc = sqlite3OsOpenMalloc(db->pVfs, 0, ppFd,\n<line8>SQLITE_OPEN_TEMP_JOURNAL |\n<line9>SQLITE_OPEN_READWRITE    | SQLITE_OPEN_CREATE |\n<line10>SQLITE_OPEN_EXCLUSIVE    | SQLITE_OPEN_DELETEONCLOSE, &rc\n<line11>);\n<line12>if( rc==SQLITE_OK ){\n<line13>i64 max = SQLITE_MAX_MMAP_SIZE;\n<line14>sqlite3OsFileControlHint(*ppFd, SQLITE_FCNTL_MMAP_SIZE, (void*)&max);\n<line15>if( nExtend>0 ){\n<line16>vdbeSorterExtendFile(db, *ppFd, nExtend);\n<line17>}\n<line18>}\n<line19>return rc;\n<line20>}
----------------------------------------
Function: vdbeSortAllocUnpacked
Content: <line0>static int vdbeSortAllocUnpacked(SortSubtask *pTask){\n<line1>if( pTask->pUnpacked==0 ){\n<line2>pTask->pUnpacked = sqlite3VdbeAllocUnpackedRecord(pTask->pSorter->pKeyInfo);\n<line3>if( pTask->pUnpacked==0 ) return SQLITE_NOMEM_BKPT;\n<line4>pTask->pUnpacked->nField = pTask->pSorter->pKeyInfo->nKeyField;\n<line5>pTask->pUnpacked->errCode = 0;\n<line6>}\n<line7>return SQLITE_OK;\n<line8>}
----------------------------------------
Function: vdbeSorterMerge
Content: <line0>static SorterRecord *vdbeSorterMerge(\n<line1>SortSubtask *pTask,             /* Calling thread context */\n<line2>SorterRecord *p1,               /* First list to merge */\n<line3>SorterRecord *p2                /* Second list to merge */\n<line4>){\n<line5>SorterRecord *pFinal = 0;\n<line6>SorterRecord **pp = &pFinal;\n<line7>int bCached = 0;\n<line8>assert( p1!=0 && p2!=0 );\n<line9>for(;;){\n<line10>int res;\n<line11>res = pTask->xCompare(\n<line12>pTask, &bCached, SRVAL(p1), p1->nVal, SRVAL(p2), p2->nVal\n<line13>);\n<line14>if( res<=0 ){\n<line15>*pp = p1;\n<line16>pp = &p1->u.pNext;\n<line17>p1 = p1->u.pNext;\n<line18>if( p1==0 ){\n<line19>*pp = p2;\n<line20>break;\n<line21>}\n<line22>}else{\n<line23>*pp = p2;\n<line24>pp = &p2->u.pNext;\n<line25>p2 = p2->u.pNext;\n<line26>bCached = 0;\n<line27>if( p2==0 ){\n<line28>*pp = p1;\n<line29>break;\n<line30>}\n<line31>}\n<line32>}\n<line33>return pFinal;\n<line34>}
----------------------------------------
Function: vdbeSorterGetCompare
Content: <line0>static SorterCompare vdbeSorterGetCompare(VdbeSorter *p){\n<line1>if( p->typeMask==SORTER_TYPE_INTEGER ){\n<line2>return vdbeSorterCompareInt;\n<line3>}else if( p->typeMask==SORTER_TYPE_TEXT ){\n<line4>return vdbeSorterCompareText;\n<line5>}\n<line6>return vdbeSorterCompare;\n<line7>}
----------------------------------------
Function: vdbeSorterSort
Content: <line0>static int vdbeSorterSort(SortSubtask *pTask, SorterList *pList){\n<line1>int i;\n<line2>SorterRecord *p;\n<line3>int rc;\n<line4>SorterRecord *aSlot[64];\n<line5>rc = vdbeSortAllocUnpacked(pTask);\n<line6>if( rc!=SQLITE_OK ) return rc;\n<line7>p = pList->pList;\n<line8>pTask->xCompare = vdbeSorterGetCompare(pTask->pSorter);\n<line9>memset(aSlot, 0, sizeof(aSlot));\n<line10>while( p ){\n<line11>SorterRecord *pNext;\n<line12>if( pList->aMemory ){\n<line13>if( (u8*)p==pList->aMemory ){\n<line14>pNext = 0;\n<line15>}else{\n<line16>assert( p->u.iNext<sqlite3MallocSize(pList->aMemory) );\n<line17>pNext = (SorterRecord*)&pList->aMemory[p->u.iNext];\n<line18>}\n<line19>}else{\n<line20>pNext = p->u.pNext;\n<line21>}\n<line22>p->u.pNext = 0;\n<line23>for(i=0; aSlot[i]; i++){\n<line24>p = vdbeSorterMerge(pTask, p, aSlot[i]);\n<line25>/* ,--Each aSlot[] holds twice as much as the previous. So we cannot use\n<line26>** |  up all 64 aSlots[] with only a 64-bit address space.\n<line27>** v                                                                */\n<line28>assert( i<ArraySize(aSlot) );\n<line29>aSlot[i] = 0;\n<line30>}\n<line31>aSlot[i] = p;\n<line32>p = pNext;\n<line33>}\n<line34>p = 0;\n<line35>for(i=0; i<ArraySize(aSlot); i++){\n<line36>if( aSlot[i]==0 ) continue;\n<line37>p = p ? vdbeSorterMerge(pTask, p, aSlot[i]) : aSlot[i];\n<line38>}\n<line39>pList->pList = p;\n<line40>assert( pTask->pUnpacked->errCode==SQLITE_OK\n<line41>|| pTask->pUnpacked->errCode==SQLITE_NOMEM\n<line42>);\n<line43>return pTask->pUnpacked->errCode;\n<line44>}
----------------------------------------
Function: vdbePmaWriterInit
Content: <line0>static void vdbePmaWriterInit(\n<line1>sqlite3_file *pFd,              /* File handle to write to */\n<line2>PmaWriter *p,                   /* Object to populate */\n<line3>int nBuf,                       /* Buffer size */\n<line4>i64 iStart                      /* Offset of pFd to begin writing at */\n<line5>){\n<line6>memset(p, 0, sizeof(PmaWriter));\n<line7>p->aBuffer = (u8*)sqlite3Malloc(nBuf);\n<line8>if( !p->aBuffer ){\n<line9>p->eFWErr = SQLITE_NOMEM_BKPT;\n<line10>}else{\n<line11>p->iBufEnd = p->iBufStart = (iStart % nBuf);\n<line12>p->iWriteOff = iStart - p->iBufStart;\n<line13>p->nBuffer = nBuf;\n<line14>p->pFd = pFd;\n<line15>}\n<line16>}
----------------------------------------
Function: vdbePmaWriteBlob
Content: <line0>static void vdbePmaWriteBlob(PmaWriter *p, u8 *pData, int nData){\n<line1>int nRem = nData;\n<line2>while( nRem>0 && p->eFWErr==0 ){\n<line3>int nCopy = nRem;\n<line4>if( nCopy>(p->nBuffer - p->iBufEnd) ){\n<line5>nCopy = p->nBuffer - p->iBufEnd;\n<line6>}\n<line7>memcpy(&p->aBuffer[p->iBufEnd], &pData[nData-nRem], nCopy);\n<line8>p->iBufEnd += nCopy;\n<line9>if( p->iBufEnd==p->nBuffer ){\n<line10>p->eFWErr = sqlite3OsWrite(p->pFd,\n<line11>&p->aBuffer[p->iBufStart], p->iBufEnd - p->iBufStart,\n<line12>p->iWriteOff + p->iBufStart\n<line13>);\n<line14>p->nPmaSpill += (p->iBufEnd - p->iBufStart);\n<line15>p->iBufStart = p->iBufEnd = 0;\n<line16>p->iWriteOff += p->nBuffer;\n<line17>}\n<line18>assert( p->iBufEnd<p->nBuffer );\n<line19>nRem -= nCopy;\n<line20>}\n<line21>}
----------------------------------------
Function: vdbePmaWriterFinish
Content: <line0>static int vdbePmaWriterFinish(PmaWriter *p, i64 *piEof, u64 *pnSpill){\n<line1>int rc;\n<line2>if( p->eFWErr==0 && ALWAYS(p->aBuffer) && p->iBufEnd>p->iBufStart ){\n<line3>p->eFWErr = sqlite3OsWrite(p->pFd,\n<line4>&p->aBuffer[p->iBufStart], p->iBufEnd - p->iBufStart,\n<line5>p->iWriteOff + p->iBufStart\n<line6>);\n<line7>p->nPmaSpill += (p->iBufEnd - p->iBufStart);\n<line8>}\n<line9>*piEof = (p->iWriteOff + p->iBufEnd);\n<line10>*pnSpill += p->nPmaSpill;\n<line11>sqlite3_free(p->aBuffer);\n<line12>rc = p->eFWErr;\n<line13>memset(p, 0, sizeof(PmaWriter));\n<line14>return rc;\n<line15>}
----------------------------------------
Function: vdbePmaWriteVarint
Content: <line0>static void vdbePmaWriteVarint(PmaWriter *p, u64 iVal){\n<line1>int nByte;\n<line2>u8 aByte[10];\n<line3>nByte = sqlite3PutVarint(aByte, iVal);\n<line4>vdbePmaWriteBlob(p, aByte, nByte);\n<line5>}
----------------------------------------
Function: vdbeSorterListToPMA
Content: <line0>static int vdbeSorterListToPMA(SortSubtask *pTask, SorterList *pList){\n<line1>sqlite3 *db = pTask->pSorter->db;\n<line2>int rc = SQLITE_OK;             /* Return code */\n<line3>PmaWriter writer;               /* Object used to write to the file */\n<line4>#ifdef SQLITE_DEBUG\n<line5>/* Set iSz to the expected size of file pTask->file after writing the PMA.\n<line6>** This is used by an assert() statement at the end of this function.  */\n<line7>i64 iSz = pList->szPMA + sqlite3VarintLen(pList->szPMA) + pTask->file.iEof;\n<line8>#endif\n<line9>vdbeSorterWorkDebug(pTask, "enter");\n<line10>memset(&writer, 0, sizeof(PmaWriter));\n<line11>assert( pList->szPMA>0 );\n<line12>/* If the first temporary PMA file has not been opened, open it now. */\n<line13>if( pTask->file.pFd==0 ){\n<line14>rc = vdbeSorterOpenTempFile(db, 0, &pTask->file.pFd);\n<line15>assert( rc!=SQLITE_OK || pTask->file.pFd );\n<line16>assert( pTask->file.iEof==0 );\n<line17>assert( pTask->nPMA==0 );\n<line18>}\n<line19>/* Try to get the file to memory map */\n<line20>if( rc==SQLITE_OK ){\n<line21>vdbeSorterExtendFile(db, pTask->file.pFd, pTask->file.iEof+pList->szPMA+9);\n<line22>}\n<line23>/* Sort the list */\n<line24>if( rc==SQLITE_OK ){\n<line25>rc = vdbeSorterSort(pTask, pList);\n<line26>}\n<line27>if( rc==SQLITE_OK ){\n<line28>SorterRecord *p;\n<line29>SorterRecord *pNext = 0;\n<line30>vdbePmaWriterInit(pTask->file.pFd, &writer, pTask->pSorter->pgsz,\n<line31>pTask->file.iEof);\n<line32>pTask->nPMA++;\n<line33>vdbePmaWriteVarint(&writer, pList->szPMA);\n<line34>for(p=pList->pList; p; p=pNext){\n<line35>pNext = p->u.pNext;\n<line36>vdbePmaWriteVarint(&writer, p->nVal);\n<line37>vdbePmaWriteBlob(&writer, SRVAL(p), p->nVal);\n<line38>if( pList->aMemory==0 ) sqlite3_free(p);\n<line39>}\n<line40>pList->pList = p;\n<line41>rc = vdbePmaWriterFinish(&writer, &pTask->file.iEof, &pTask->nSpill);\n<line42>}\n<line43>vdbeSorterWorkDebug(pTask, "exit");\n<line44>assert( rc!=SQLITE_OK || pList->pList==0 );\n<line45>assert( rc!=SQLITE_OK || pTask->file.iEof==iSz );\n<line46>return rc;\n<line47>}
----------------------------------------
Function: vdbeMergeEngineStep
Content: <line0>static int vdbeMergeEngineStep(\n<line1>MergeEngine *pMerger,      /* The merge engine to advance to the next row */\n<line2>int *pbEof                 /* Set TRUE at EOF.  Set false for more content */\n<line3>){\n<line4>int rc;\n<line5>int iPrev = pMerger->aTree[1];/* Index of PmaReader to advance */\n<line6>SortSubtask *pTask = pMerger->pTask;\n<line7>/* Advance the current PmaReader */\n<line8>rc = vdbePmaReaderNext(&pMerger->aReadr[iPrev]);\n<line9>/* Update contents of aTree[] */\n<line10>if( rc==SQLITE_OK ){\n<line11>int i;                      /* Index of aTree[] to recalculate */\n<line12>PmaReader *pReadr1;         /* First PmaReader to compare */\n<line13>PmaReader *pReadr2;         /* Second PmaReader to compare */\n<line14>int bCached = 0;\n<line15>/* Find the first two PmaReaders to compare. The one that was just\n<line16>** advanced (iPrev) and the one next to it in the array.  */\n<line17>pReadr1 = &pMerger->aReadr[(iPrev & 0xFFFE)];\n<line18>pReadr2 = &pMerger->aReadr[(iPrev | 0x0001)];\n<line19>for(i=(pMerger->nTree+iPrev)/2; i>0; i=i/2){\n<line20>/* Compare pReadr1 and pReadr2. Store the result in variable iRes. */\n<line21>int iRes;\n<line22>if( pReadr1->pFd==0 ){\n<line23>iRes = +1;\n<line24>}else if( pReadr2->pFd==0 ){\n<line25>iRes = -1;\n<line26>}else{\n<line27>iRes = pTask->xCompare(pTask, &bCached,\n<line28>pReadr1->aKey, pReadr1->nKey, pReadr2->aKey, pReadr2->nKey\n<line29>);\n<line30>}\n<line31>/* If pReadr1 contained the smaller value, set aTree[i] to its index.\n<line32>** Then set pReadr2 to the next PmaReader to compare to pReadr1. In this\n<line33>** case there is no cache of pReadr2 in pTask->pUnpacked, so set\n<line34>** pKey2 to point to the record belonging to pReadr2.\n<line35>**\n<line36>** Alternatively, if pReadr2 contains the smaller of the two values,\n<line37>** set aTree[i] to its index and update pReadr1. If vdbeSorterCompare()\n<line38>** was actually called above, then pTask->pUnpacked now contains\n<line39>** a value equivalent to pReadr2. So set pKey2 to NULL to prevent\n<line40>** vdbeSorterCompare() from decoding pReadr2 again.\n<line41>**\n<line42>** If the two values were equal, then the value from the oldest\n<line43>** PMA should be considered smaller. The VdbeSorter.aReadr[] array\n<line44>** is sorted from oldest to newest, so pReadr1 contains older values\n<line45>** than pReadr2 iff (pReadr1<pReadr2).  */\n<line46>if( iRes<0 || (iRes==0 && pReadr1<pReadr2) ){\n<line47>pMerger->aTree[i] = (int)(pReadr1 - pMerger->aReadr);\n<line48>pReadr2 = &pMerger->aReadr[ pMerger->aTree[i ^ 0x0001] ];\n<line49>bCached = 0;\n<line50>}else{\n<line51>if( pReadr1->pFd ) bCached = 0;\n<line52>pMerger->aTree[i] = (int)(pReadr2 - pMerger->aReadr);\n<line53>pReadr1 = &pMerger->aReadr[ pMerger->aTree[i ^ 0x0001] ];\n<line54>}\n<line55>}\n<line56>*pbEof = (pMerger->aReadr[pMerger->aTree[1]].pFd==0);\n<line57>}\n<line58>return (rc==SQLITE_OK ? pTask->pUnpacked->errCode : rc);\n<line59>}
----------------------------------------
Function: vdbeSorterFlushThread
Content: <line0>static void *vdbeSorterFlushThread(void *pCtx){\n<line1>SortSubtask *pTask = (SortSubtask*)pCtx;\n<line2>int rc;                         /* Return code */\n<line3>assert( pTask->bDone==0 );\n<line4>rc = vdbeSorterListToPMA(pTask, &pTask->list);\n<line5>pTask->bDone = 1;\n<line6>return SQLITE_INT_TO_PTR(rc);\n<line7>}
----------------------------------------
Function: vdbeSorterFlushPMA
Content: <line0>static int vdbeSorterFlushPMA(VdbeSorter *pSorter){\n<line1>#if SQLITE_MAX_WORKER_THREADS==0\n<line2>pSorter->bUsePMA = 1;\n<line3>return vdbeSorterListToPMA(&pSorter->aTask[0], &pSorter->list);\n<line4>#else\n<line5>int rc = SQLITE_OK;\n<line6>int i;\n<line7>SortSubtask *pTask = 0;    /* Thread context used to create new PMA */\n<line8>int nWorker = (pSorter->nTask-1);\n<line9>/* Set the flag to indicate that at least one PMA has been written.\n<line10>** Or will be, anyhow.  */\n<line11>pSorter->bUsePMA = 1;\n<line12>/* Select a sub-task to sort and flush the current list of in-memory\n<line13>** records to disk. If the sorter is running in multi-threaded mode,\n<line14>** round-robin between the first (pSorter->nTask-1) tasks. Except, if\n<line15>** the background thread from a sub-tasks previous turn is still running,\n<line16>** skip it. If the first (pSorter->nTask-1) sub-tasks are all still busy,\n<line17>** fall back to using the final sub-task. The first (pSorter->nTask-1)\n<line18>** sub-tasks are preferred as they use background threads - the final\n<line19>** sub-task uses the main thread. */\n<line20>for(i=0; i<nWorker; i++){\n<line21>int iTest = (pSorter->iPrev + i + 1) % nWorker;\n<line22>pTask = &pSorter->aTask[iTest];\n<line23>if( pTask->bDone ){\n<line24>rc = vdbeSorterJoinThread(pTask);\n<line25>}\n<line26>if( rc!=SQLITE_OK || pTask->pThread==0 ) break;\n<line27>}\n<line28>if( rc==SQLITE_OK ){\n<line29>if( i==nWorker ){\n<line30>/* Use the foreground thread for this operation */\n<line31>rc = vdbeSorterListToPMA(&pSorter->aTask[nWorker], &pSorter->list);\n<line32>}else{\n<line33>/* Launch a background thread for this operation */\n<line34>u8 *aMem;\n<line35>void *pCtx;\n<line36>assert( pTask!=0 );\n<line37>assert( pTask->pThread==0 && pTask->bDone==0 );\n<line38>assert( pTask->list.pList==0 );\n<line39>assert( pTask->list.aMemory==0 || pSorter->list.aMemory!=0 );\n<line40>aMem = pTask->list.aMemory;\n<line41>pCtx = (void*)pTask;\n<line42>pSorter->iPrev = (u8)(pTask - pSorter->aTask);\n<line43>pTask->list = pSorter->list;\n<line44>pSorter->list.pList = 0;\n<line45>pSorter->list.szPMA = 0;\n<line46>if( aMem ){\n<line47>pSorter->list.aMemory = aMem;\n<line48>pSorter->nMemory = sqlite3MallocSize(aMem);\n<line49>}else if( pSorter->list.aMemory ){\n<line50>pSorter->list.aMemory = sqlite3Malloc(pSorter->nMemory);\n<line51>if( !pSorter->list.aMemory ) return SQLITE_NOMEM_BKPT;\n<line52>}\n<line53>rc = vdbeSorterCreateThread(pTask, vdbeSorterFlushThread, pCtx);\n<line54>}\n<line55>}\n<line56>return rc;\n<line57>#endif /* SQLITE_MAX_WORKER_THREADS!=0 */\n<line58>}
----------------------------------------
Function: vdbeIncrPopulate
Content: <line0>static int vdbeIncrPopulate(IncrMerger *pIncr){\n<line1>int rc = SQLITE_OK;\n<line2>int rc2;\n<line3>i64 iStart = pIncr->iStartOff;\n<line4>SorterFile *pOut = &pIncr->aFile[1];\n<line5>SortSubtask *pTask = pIncr->pTask;\n<line6>MergeEngine *pMerger = pIncr->pMerger;\n<line7>PmaWriter writer;\n<line8>assert( pIncr->bEof==0 );\n<line9>vdbeSorterPopulateDebug(pTask, "enter");\n<line10>vdbePmaWriterInit(pOut->pFd, &writer, pTask->pSorter->pgsz, iStart);\n<line11>while( rc==SQLITE_OK ){\n<line12>int dummy;\n<line13>PmaReader *pReader = &pMerger->aReadr[ pMerger->aTree[1] ];\n<line14>int nKey = pReader->nKey;\n<line15>i64 iEof = writer.iWriteOff + writer.iBufEnd;\n<line16>/* Check if the output file is full or if the input has been exhausted.\n<line17>** In either case exit the loop. */\n<line18>if( pReader->pFd==0 ) break;\n<line19>if( (iEof + nKey + sqlite3VarintLen(nKey))>(iStart + pIncr->mxSz) ) break;\n<line20>/* Write the next key to the output. */\n<line21>vdbePmaWriteVarint(&writer, nKey);\n<line22>vdbePmaWriteBlob(&writer, pReader->aKey, nKey);\n<line23>assert( pIncr->pMerger->pTask==pTask );\n<line24>rc = vdbeMergeEngineStep(pIncr->pMerger, &dummy);\n<line25>}\n<line26>rc2 = vdbePmaWriterFinish(&writer, &pOut->iEof, &pTask->nSpill);\n<line27>if( rc==SQLITE_OK ) rc = rc2;\n<line28>vdbeSorterPopulateDebug(pTask, "exit");\n<line29>return rc;\n<line30>}
----------------------------------------
Function: vdbeIncrPopulateThread
Content: <line0>static void *vdbeIncrPopulateThread(void *pCtx){\n<line1>IncrMerger *pIncr = (IncrMerger*)pCtx;\n<line2>void *pRet = SQLITE_INT_TO_PTR( vdbeIncrPopulate(pIncr) );\n<line3>pIncr->pTask->bDone = 1;\n<line4>return pRet;\n<line5>}
----------------------------------------
Function: vdbeIncrBgPopulate
Content: <line0>static int vdbeIncrBgPopulate(IncrMerger *pIncr){\n<line1>void *p = (void*)pIncr;\n<line2>assert( pIncr->bUseThread );\n<line3>return vdbeSorterCreateThread(pIncr->pTask, vdbeIncrPopulateThread, p);\n<line4>}
----------------------------------------
Function: vdbeIncrSwap
Content: <line0>static int vdbeIncrSwap(IncrMerger *pIncr){\n<line1>int rc = SQLITE_OK;\n<line2>#if SQLITE_MAX_WORKER_THREADS>0\n<line3>if( pIncr->bUseThread ){\n<line4>rc = vdbeSorterJoinThread(pIncr->pTask);\n<line5>if( rc==SQLITE_OK ){\n<line6>SorterFile f0 = pIncr->aFile[0];\n<line7>pIncr->aFile[0] = pIncr->aFile[1];\n<line8>pIncr->aFile[1] = f0;\n<line9>}\n<line10>if( rc==SQLITE_OK ){\n<line11>if( pIncr->aFile[0].iEof==pIncr->iStartOff ){\n<line12>pIncr->bEof = 1;\n<line13>}else{\n<line14>rc = vdbeIncrBgPopulate(pIncr);\n<line15>}\n<line16>}\n<line17>}else\n<line18>#endif\n<line19>{\n<line20>rc = vdbeIncrPopulate(pIncr);\n<line21>pIncr->aFile[0] = pIncr->aFile[1];\n<line22>if( pIncr->aFile[0].iEof==pIncr->iStartOff ){\n<line23>pIncr->bEof = 1;\n<line24>}\n<line25>}\n<line26>return rc;\n<line27>}
----------------------------------------
Function: vdbeIncrMergerNew
Content: <line0>static int vdbeIncrMergerNew(\n<line1>SortSubtask *pTask,     /* The thread that will be using the new IncrMerger */\n<line2>MergeEngine *pMerger,   /* The MergeEngine that the IncrMerger will control */\n<line3>IncrMerger **ppOut      /* Write the new IncrMerger here */\n<line4>){\n<line5>int rc = SQLITE_OK;\n<line6>IncrMerger *pIncr = *ppOut = (IncrMerger*)\n<line7>(sqlite3FaultSim(100) ? 0 : sqlite3MallocZero(sizeof(*pIncr)));\n<line8>if( pIncr ){\n<line9>pIncr->pMerger = pMerger;\n<line10>pIncr->pTask = pTask;\n<line11>pIncr->mxSz = MAX(pTask->pSorter->mxKeysize+9,pTask->pSorter->mxPmaSize/2);\n<line12>pTask->file2.iEof += pIncr->mxSz;\n<line13>}else{\n<line14>vdbeMergeEngineFree(pMerger);\n<line15>rc = SQLITE_NOMEM_BKPT;\n<line16>}\n<line17>assert( *ppOut!=0 || rc!=SQLITE_OK );\n<line18>return rc;\n<line19>}
----------------------------------------
Function: vdbeIncrMergerSetThreads
Content: <line0>static void vdbeIncrMergerSetThreads(IncrMerger *pIncr){\n<line1>pIncr->bUseThread = 1;\n<line2>pIncr->pTask->file2.iEof -= pIncr->mxSz;\n<line3>}
----------------------------------------
Function: vdbeMergeEngineCompare
Content: <line0>static void vdbeMergeEngineCompare(\n<line1>MergeEngine *pMerger,  /* Merge engine containing PmaReaders to compare */\n<line2>int iOut               /* Store the result in pMerger->aTree[iOut] */\n<line3>){\n<line4>int i1;\n<line5>int i2;\n<line6>int iRes;\n<line7>PmaReader *p1;\n<line8>PmaReader *p2;\n<line9>assert( iOut<pMerger->nTree && iOut>0 );\n<line10>if( iOut>=(pMerger->nTree/2) ){\n<line11>i1 = (iOut - pMerger->nTree/2) * 2;\n<line12>i2 = i1 + 1;\n<line13>}else{\n<line14>i1 = pMerger->aTree[iOut*2];\n<line15>i2 = pMerger->aTree[iOut*2+1];\n<line16>}\n<line17>p1 = &pMerger->aReadr[i1];\n<line18>p2 = &pMerger->aReadr[i2];\n<line19>if( p1->pFd==0 ){\n<line20>iRes = i2;\n<line21>}else if( p2->pFd==0 ){\n<line22>iRes = i1;\n<line23>}else{\n<line24>SortSubtask *pTask = pMerger->pTask;\n<line25>int bCached = 0;\n<line26>int res;\n<line27>assert( pTask->pUnpacked!=0 );  /* from vdbeSortSubtaskMain() */\n<line28>res = pTask->xCompare(\n<line29>pTask, &bCached, p1->aKey, p1->nKey, p2->aKey, p2->nKey\n<line30>);\n<line31>if( res<=0 ){\n<line32>iRes = i1;\n<line33>}else{\n<line34>iRes = i2;\n<line35>}\n<line36>}\n<line37>pMerger->aTree[iOut] = iRes;\n<line38>}
----------------------------------------
Function: vdbeMergeEngineInit
Content: <line0>static int vdbeMergeEngineInit(\n<line1>SortSubtask *pTask,             /* Thread that will run pMerger */\n<line2>MergeEngine *pMerger,           /* MergeEngine to initialize */\n<line3>int eMode                       /* One of the INCRINIT_XXX constants */\n<line4>){\n<line5>int rc = SQLITE_OK;             /* Return code */\n<line6>int i;                          /* For looping over PmaReader objects */\n<line7>int nTree;                      /* Number of subtrees to merge */\n<line8>/* Failure to allocate the merge would have been detected prior to\n<line9>** invoking this routine */\n<line10>assert( pMerger!=0 );\n<line11>/* eMode is always INCRINIT_NORMAL in single-threaded mode */\n<line12>assert( SQLITE_MAX_WORKER_THREADS>0 || eMode==INCRINIT_NORMAL );\n<line13>/* Verify that the MergeEngine is assigned to a single thread */\n<line14>assert( pMerger->pTask==0 );\n<line15>pMerger->pTask = pTask;\n<line16>nTree = pMerger->nTree;\n<line17>for(i=0; i<nTree; i++){\n<line18>if( SQLITE_MAX_WORKER_THREADS>0 && eMode==INCRINIT_ROOT ){\n<line19>/* PmaReaders should be normally initialized in order, as if they are\n<line20>** reading from the same temp file this makes for more linear file IO.\n<line21>** However, in the INCRINIT_ROOT case, if PmaReader aReadr[nTask-1] is\n<line22>** in use it will block the vdbePmaReaderNext() call while it uses\n<line23>** the main thread to fill its buffer. So calling PmaReaderNext()\n<line24>** on this PmaReader before any of the multi-threaded PmaReaders takes\n<line25>** better advantage of multi-processor hardware. */\n<line26>rc = vdbePmaReaderNext(&pMerger->aReadr[nTree-i-1]);\n<line27>}else{\n<line28>rc = vdbePmaReaderIncrInit(&pMerger->aReadr[i], INCRINIT_NORMAL);\n<line29>}\n<line30>if( rc!=SQLITE_OK ) return rc;\n<line31>}\n<line32>for(i=pMerger->nTree-1; i>0; i--){\n<line33>vdbeMergeEngineCompare(pMerger, i);\n<line34>}\n<line35>return pTask->pUnpacked->errCode;\n<line36>}
----------------------------------------
Function: vdbePmaReaderIncrMergeInit
Content: <line0>static int vdbePmaReaderIncrMergeInit(PmaReader *pReadr, int eMode){\n<line1>int rc = SQLITE_OK;\n<line2>IncrMerger *pIncr = pReadr->pIncr;\n<line3>SortSubtask *pTask = pIncr->pTask;\n<line4>sqlite3 *db = pTask->pSorter->db;\n<line5>/* eMode is always INCRINIT_NORMAL in single-threaded mode */\n<line6>assert( SQLITE_MAX_WORKER_THREADS>0 || eMode==INCRINIT_NORMAL );\n<line7>rc = vdbeMergeEngineInit(pTask, pIncr->pMerger, eMode);\n<line8>/* Set up the required files for pIncr. A multi-threaded IncrMerge object\n<line9>** requires two temp files to itself, whereas a single-threaded object\n<line10>** only requires a region of pTask->file2. */\n<line11>if( rc==SQLITE_OK ){\n<line12>int mxSz = pIncr->mxSz;\n<line13>#if SQLITE_MAX_WORKER_THREADS>0\n<line14>if( pIncr->bUseThread ){\n<line15>rc = vdbeSorterOpenTempFile(db, mxSz, &pIncr->aFile[0].pFd);\n<line16>if( rc==SQLITE_OK ){\n<line17>rc = vdbeSorterOpenTempFile(db, mxSz, &pIncr->aFile[1].pFd);\n<line18>}\n<line19>}else\n<line20>#endif\n<line21>/*if( !pIncr->bUseThread )*/{\n<line22>if( pTask->file2.pFd==0 ){\n<line23>assert( pTask->file2.iEof>0 );\n<line24>rc = vdbeSorterOpenTempFile(db, pTask->file2.iEof, &pTask->file2.pFd);\n<line25>pTask->file2.iEof = 0;\n<line26>}\n<line27>if( rc==SQLITE_OK ){\n<line28>pIncr->aFile[1].pFd = pTask->file2.pFd;\n<line29>pIncr->iStartOff = pTask->file2.iEof;\n<line30>pTask->file2.iEof += mxSz;\n<line31>}\n<line32>}\n<line33>}\n<line34>#if SQLITE_MAX_WORKER_THREADS>0\n<line35>if( rc==SQLITE_OK && pIncr->bUseThread ){\n<line36>/* Use the current thread to populate aFile[1], even though this\n<line37>** PmaReader is multi-threaded. If this is an INCRINIT_TASK object,\n<line38>** then this function is already running in background thread\n<line39>** pIncr->pTask->thread.\n<line40>**\n<line41>** If this is the INCRINIT_ROOT object, then it is running in the\n<line42>** main VDBE thread. But that is Ok, as that thread cannot return\n<line43>** control to the VDBE or proceed with anything useful until the\n<line44>** first results are ready from this merger object anyway.\n<line45>*/\n<line46>assert( eMode==INCRINIT_ROOT || eMode==INCRINIT_TASK );\n<line47>rc = vdbeIncrPopulate(pIncr);\n<line48>}\n<line49>#endif\n<line50>if( rc==SQLITE_OK && (SQLITE_MAX_WORKER_THREADS==0 || eMode!=INCRINIT_TASK) ){\n<line51>rc = vdbePmaReaderNext(pReadr);\n<line52>}\n<line53>return rc;\n<line54>}
----------------------------------------
Function: vdbePmaReaderBgIncrInit
Content: <line0>static void *vdbePmaReaderBgIncrInit(void *pCtx){\n<line1>PmaReader *pReader = (PmaReader*)pCtx;\n<line2>void *pRet = SQLITE_INT_TO_PTR(\n<line3>vdbePmaReaderIncrMergeInit(pReader,INCRINIT_TASK)\n<line4>);\n<line5>pReader->pIncr->pTask->bDone = 1;\n<line6>return pRet;\n<line7>}
----------------------------------------
Function: vdbePmaReaderIncrInit
Content: <line0>static int vdbePmaReaderIncrInit(PmaReader *pReadr, int eMode){\n<line1>IncrMerger *pIncr = pReadr->pIncr;   /* Incremental merger */\n<line2>int rc = SQLITE_OK;                  /* Return code */\n<line3>if( pIncr ){\n<line4>#if SQLITE_MAX_WORKER_THREADS>0\n<line5>assert( pIncr->bUseThread==0 || eMode==INCRINIT_TASK );\n<line6>if( pIncr->bUseThread ){\n<line7>void *pCtx = (void*)pReadr;\n<line8>rc = vdbeSorterCreateThread(pIncr->pTask, vdbePmaReaderBgIncrInit, pCtx);\n<line9>}else\n<line10>#endif\n<line11>{\n<line12>rc = vdbePmaReaderIncrMergeInit(pReadr, eMode);\n<line13>}\n<line14>}\n<line15>return rc;\n<line16>}
----------------------------------------
Function: vdbeMergeEngineLevel0
Content: <line0>static int vdbeMergeEngineLevel0(\n<line1>SortSubtask *pTask,             /* Sorter task to read from */\n<line2>int nPMA,                       /* Number of PMAs to read */\n<line3>i64 *piOffset,                  /* IN/OUT: Readr offset in pTask->file */\n<line4>MergeEngine **ppOut             /* OUT: New merge-engine */\n<line5>){\n<line6>MergeEngine *pNew;              /* Merge engine to return */\n<line7>i64 iOff = *piOffset;\n<line8>int i;\n<line9>int rc = SQLITE_OK;\n<line10>*ppOut = pNew = vdbeMergeEngineNew(nPMA);\n<line11>if( pNew==0 ) rc = SQLITE_NOMEM_BKPT;\n<line12>for(i=0; i<nPMA && rc==SQLITE_OK; i++){\n<line13>i64 nDummy = 0;\n<line14>PmaReader *pReadr = &pNew->aReadr[i];\n<line15>rc = vdbePmaReaderInit(pTask, &pTask->file, iOff, pReadr, &nDummy);\n<line16>iOff = pReadr->iEof;\n<line17>}\n<line18>if( rc!=SQLITE_OK ){\n<line19>vdbeMergeEngineFree(pNew);\n<line20>*ppOut = 0;\n<line21>}\n<line22>*piOffset = iOff;\n<line23>return rc;\n<line24>}
----------------------------------------
Function: vdbeSorterTreeDepth
Content: <line0>static int vdbeSorterTreeDepth(int nPMA){\n<line1>int nDepth = 0;\n<line2>i64 nDiv = SORTER_MAX_MERGE_COUNT;\n<line3>while( nDiv < (i64)nPMA ){\n<line4>nDiv = nDiv * SORTER_MAX_MERGE_COUNT;\n<line5>nDepth++;\n<line6>}\n<line7>return nDepth;\n<line8>}
----------------------------------------
Function: vdbeSorterAddToTree
Content: <line0>static int vdbeSorterAddToTree(\n<line1>SortSubtask *pTask,             /* Task context */\n<line2>int nDepth,                     /* Depth of tree according to TreeDepth() */\n<line3>int iSeq,                       /* Sequence number of leaf within tree */\n<line4>MergeEngine *pRoot,             /* Root of tree */\n<line5>MergeEngine *pLeaf              /* Leaf to add to tree */\n<line6>){\n<line7>int rc = SQLITE_OK;\n<line8>int nDiv = 1;\n<line9>int i;\n<line10>MergeEngine *p = pRoot;\n<line11>IncrMerger *pIncr;\n<line12>rc = vdbeIncrMergerNew(pTask, pLeaf, &pIncr);\n<line13>for(i=1; i<nDepth; i++){\n<line14>nDiv = nDiv * SORTER_MAX_MERGE_COUNT;\n<line15>}\n<line16>for(i=1; i<nDepth && rc==SQLITE_OK; i++){\n<line17>int iIter = (iSeq / nDiv) % SORTER_MAX_MERGE_COUNT;\n<line18>PmaReader *pReadr = &p->aReadr[iIter];\n<line19>if( pReadr->pIncr==0 ){\n<line20>MergeEngine *pNew = vdbeMergeEngineNew(SORTER_MAX_MERGE_COUNT);\n<line21>if( pNew==0 ){\n<line22>rc = SQLITE_NOMEM_BKPT;\n<line23>}else{\n<line24>rc = vdbeIncrMergerNew(pTask, pNew, &pReadr->pIncr);\n<line25>}\n<line26>}\n<line27>if( rc==SQLITE_OK ){\n<line28>p = pReadr->pIncr->pMerger;\n<line29>nDiv = nDiv / SORTER_MAX_MERGE_COUNT;\n<line30>}\n<line31>}\n<line32>if( rc==SQLITE_OK ){\n<line33>p->aReadr[iSeq % SORTER_MAX_MERGE_COUNT].pIncr = pIncr;\n<line34>}else{\n<line35>vdbeIncrFree(pIncr);\n<line36>}\n<line37>return rc;\n<line38>}
----------------------------------------
Function: vdbeSorterMergeTreeBuild
Content: <line0>static int vdbeSorterMergeTreeBuild(\n<line1>VdbeSorter *pSorter,       /* The VDBE cursor that implements the sort */\n<line2>MergeEngine **ppOut        /* Write the MergeEngine here */\n<line3>){\n<line4>MergeEngine *pMain = 0;\n<line5>int rc = SQLITE_OK;\n<line6>int iTask;\n<line7>#if SQLITE_MAX_WORKER_THREADS>0\n<line8>/* If the sorter uses more than one task, then create the top-level\n<line9>** MergeEngine here. This MergeEngine will read data from exactly\n<line10>** one PmaReader per sub-task.  */\n<line11>assert( pSorter->bUseThreads || pSorter->nTask==1 );\n<line12>if( pSorter->nTask>1 ){\n<line13>pMain = vdbeMergeEngineNew(pSorter->nTask);\n<line14>if( pMain==0 ) rc = SQLITE_NOMEM_BKPT;\n<line15>}\n<line16>#endif\n<line17>for(iTask=0; rc==SQLITE_OK && iTask<pSorter->nTask; iTask++){\n<line18>SortSubtask *pTask = &pSorter->aTask[iTask];\n<line19>assert( pTask->nPMA>0 || SQLITE_MAX_WORKER_THREADS>0 );\n<line20>if( SQLITE_MAX_WORKER_THREADS==0 || pTask->nPMA ){\n<line21>MergeEngine *pRoot = 0;     /* Root node of tree for this task */\n<line22>int nDepth = vdbeSorterTreeDepth(pTask->nPMA);\n<line23>i64 iReadOff = 0;\n<line24>if( pTask->nPMA<=SORTER_MAX_MERGE_COUNT ){\n<line25>rc = vdbeMergeEngineLevel0(pTask, pTask->nPMA, &iReadOff, &pRoot);\n<line26>}else{\n<line27>int i;\n<line28>int iSeq = 0;\n<line29>pRoot = vdbeMergeEngineNew(SORTER_MAX_MERGE_COUNT);\n<line30>if( pRoot==0 ) rc = SQLITE_NOMEM_BKPT;\n<line31>for(i=0; i<pTask->nPMA && rc==SQLITE_OK; i += SORTER_MAX_MERGE_COUNT){\n<line32>MergeEngine *pMerger = 0; /* New level-0 PMA merger */\n<line33>int nReader;              /* Number of level-0 PMAs to merge */\n<line34>nReader = MIN(pTask->nPMA - i, SORTER_MAX_MERGE_COUNT);\n<line35>rc = vdbeMergeEngineLevel0(pTask, nReader, &iReadOff, &pMerger);\n<line36>if( rc==SQLITE_OK ){\n<line37>rc = vdbeSorterAddToTree(pTask, nDepth, iSeq++, pRoot, pMerger);\n<line38>}\n<line39>}\n<line40>}\n<line41>if( rc==SQLITE_OK ){\n<line42>#if SQLITE_MAX_WORKER_THREADS>0\n<line43>if( pMain!=0 ){\n<line44>rc = vdbeIncrMergerNew(pTask, pRoot, &pMain->aReadr[iTask].pIncr);\n<line45>}else\n<line46>#endif\n<line47>{\n<line48>assert( pMain==0 );\n<line49>pMain = pRoot;\n<line50>}\n<line51>}else{\n<line52>vdbeMergeEngineFree(pRoot);\n<line53>}\n<line54>}\n<line55>}\n<line56>if( rc!=SQLITE_OK ){\n<line57>vdbeMergeEngineFree(pMain);\n<line58>pMain = 0;\n<line59>}\n<line60>*ppOut = pMain;\n<line61>return rc;\n<line62>}
----------------------------------------
Function: vdbeSorterSetupMerge
Content: <line0>static int vdbeSorterSetupMerge(VdbeSorter *pSorter){\n<line1>int rc;                         /* Return code */\n<line2>SortSubtask *pTask0 = &pSorter->aTask[0];\n<line3>MergeEngine *pMain = 0;\n<line4>#if SQLITE_MAX_WORKER_THREADS\n<line5>sqlite3 *db = pTask0->pSorter->db;\n<line6>int i;\n<line7>SorterCompare xCompare = vdbeSorterGetCompare(pSorter);\n<line8>for(i=0; i<pSorter->nTask; i++){\n<line9>pSorter->aTask[i].xCompare = xCompare;\n<line10>}\n<line11>#endif\n<line12>rc = vdbeSorterMergeTreeBuild(pSorter, &pMain);\n<line13>if( rc==SQLITE_OK ){\n<line14>#if SQLITE_MAX_WORKER_THREADS\n<line15>assert( pSorter->bUseThreads==0 || pSorter->nTask>1 );\n<line16>if( pSorter->bUseThreads ){\n<line17>int iTask;\n<line18>PmaReader *pReadr = 0;\n<line19>SortSubtask *pLast = &pSorter->aTask[pSorter->nTask-1];\n<line20>rc = vdbeSortAllocUnpacked(pLast);\n<line21>if( rc==SQLITE_OK ){\n<line22>pReadr = (PmaReader*)sqlite3DbMallocZero(db, sizeof(PmaReader));\n<line23>pSorter->pReader = pReadr;\n<line24>if( pReadr==0 ) rc = SQLITE_NOMEM_BKPT;\n<line25>}\n<line26>if( rc==SQLITE_OK ){\n<line27>rc = vdbeIncrMergerNew(pLast, pMain, &pReadr->pIncr);\n<line28>if( rc==SQLITE_OK ){\n<line29>vdbeIncrMergerSetThreads(pReadr->pIncr);\n<line30>for(iTask=0; iTask<(pSorter->nTask-1); iTask++){\n<line31>IncrMerger *pIncr;\n<line32>if( (pIncr = pMain->aReadr[iTask].pIncr) ){\n<line33>vdbeIncrMergerSetThreads(pIncr);\n<line34>assert( pIncr->pTask!=pLast );\n<line35>}\n<line36>}\n<line37>for(iTask=0; rc==SQLITE_OK && iTask<pSorter->nTask; iTask++){\n<line38>/* Check that:\n<line39>**\n<line40>**   a) The incremental merge object is configured to use the\n<line41>**      right task, and\n<line42>**   b) If it is using task (nTask-1), it is configured to run\n<line43>**      in single-threaded mode. This is important, as the\n<line44>**      root merge (INCRINIT_ROOT) will be using the same task\n<line45>**      object.\n<line46>*/\n<line47>PmaReader *p = &pMain->aReadr[iTask];\n<line48>assert( p->pIncr==0 || (\n<line49>(p->pIncr->pTask==&pSorter->aTask[iTask])             /* a */\n<line50>&& (iTask!=pSorter->nTask-1 || p->pIncr->bUseThread==0)  /* b */\n<line51>));\n<line52>rc = vdbePmaReaderIncrInit(p, INCRINIT_TASK);\n<line53>}\n<line54>}\n<line55>pMain = 0;\n<line56>}\n<line57>if( rc==SQLITE_OK ){\n<line58>rc = vdbePmaReaderIncrMergeInit(pReadr, INCRINIT_ROOT);\n<line59>}\n<line60>}else\n<line61>#endif\n<line62>{\n<line63>rc = vdbeMergeEngineInit(pTask0, pMain, INCRINIT_NORMAL);\n<line64>pSorter->pMerger = pMain;\n<line65>pMain = 0;\n<line66>}\n<line67>}\n<line68>if( rc!=SQLITE_OK ){\n<line69>vdbeMergeEngineFree(pMain);\n<line70>}\n<line71>return rc;\n<line72>}
----------------------------------------
Function: vdbeSorterRowkey
Content: <line0>static void *vdbeSorterRowkey(\n<line1>const VdbeSorter *pSorter,      /* Sorter object */\n<line2>int *pnKey                      /* OUT: Size of current key in bytes */\n<line3>){\n<line4>void *pKey;\n<line5>if( pSorter->bUsePMA ){\n<line6>PmaReader *pReader;\n<line7>#if SQLITE_MAX_WORKER_THREADS>0\n<line8>if( pSorter->bUseThreads ){\n<line9>pReader = pSorter->pReader;\n<line10>}else\n<line11>#endif\n<line12>/*if( !pSorter->bUseThreads )*/{\n<line13>pReader = &pSorter->pMerger->aReadr[pSorter->pMerger->aTree[1]];\n<line14>}\n<line15>*pnKey = pReader->nKey;\n<line16>pKey = pReader->aKey;\n<line17>}else{\n<line18>*pnKey = pSorter->list.pList->nVal;\n<line19>pKey = SRVAL(pSorter->list.pList);\n<line20>}\n<line21>return pKey;\n<line22>}
----------------------------------------
Function: memjrnlRead
Content: <line0>static int memjrnlRead(\n<line1>sqlite3_file *pJfd,    /* The journal file from which to read */\n<line2>void *zBuf,            /* Put the results here */\n<line3>int iAmt,              /* Number of bytes to read */\n<line4>sqlite_int64 iOfst     /* Begin reading at this offset */\n<line5>){\n<line6>MemJournal *p = (MemJournal *)pJfd;\n<line7>u8 *zOut = zBuf;\n<line8>int nRead = iAmt;\n<line9>int iChunkOffset;\n<line10>FileChunk *pChunk;\n<line11>if( (iAmt+iOfst)>p->endpoint.iOffset ){\n<line12>return SQLITE_IOERR_SHORT_READ;\n<line13>}\n<line14>assert( p->readpoint.iOffset==0 || p->readpoint.pChunk!=0 );\n<line15>if( p->readpoint.iOffset!=iOfst || iOfst==0 ){\n<line16>sqlite3_int64 iOff = 0;\n<line17>for(pChunk=p->pFirst;\n<line18>ALWAYS(pChunk) && (iOff+p->nChunkSize)<=iOfst;\n<line19>pChunk=pChunk->pNext\n<line20>){\n<line21>iOff += p->nChunkSize;\n<line22>}\n<line23>}else{\n<line24>pChunk = p->readpoint.pChunk;\n<line25>assert( pChunk!=0 );\n<line26>}\n<line27>iChunkOffset = (int)(iOfst%p->nChunkSize);\n<line28>do {\n<line29>int iSpace = p->nChunkSize - iChunkOffset;\n<line30>int nCopy = MIN(nRead, (p->nChunkSize - iChunkOffset));\n<line31>memcpy(zOut, (u8*)pChunk->zChunk + iChunkOffset, nCopy);\n<line32>zOut += nCopy;\n<line33>nRead -= iSpace;\n<line34>iChunkOffset = 0;\n<line35>} while( nRead>=0 && (pChunk=pChunk->pNext)!=0 && nRead>0 );\n<line36>p->readpoint.iOffset = pChunk ? iOfst+iAmt : 0;\n<line37>p->readpoint.pChunk = pChunk;\n<line38>return SQLITE_OK;\n<line39>}
----------------------------------------
Function: memjrnlFreeChunks
Content: <line0>static void memjrnlFreeChunks(FileChunk *pFirst){\n<line1>FileChunk *pIter;\n<line2>FileChunk *pNext;\n<line3>for(pIter=pFirst; pIter; pIter=pNext){\n<line4>pNext = pIter->pNext;\n<line5>sqlite3_free(pIter);\n<line6>}\n<line7>}
----------------------------------------
Function: memjrnlCreateFile
Content: <line0>static int memjrnlCreateFile(MemJournal *p){\n<line1>int rc;\n<line2>sqlite3_file *pReal = (sqlite3_file*)p;\n<line3>MemJournal copy = *p;\n<line4>memset(p, 0, sizeof(MemJournal));\n<line5>rc = sqlite3OsOpen(copy.pVfs, copy.zJournal, pReal, copy.flags, 0);\n<line6>if( rc==SQLITE_OK ){\n<line7>int nChunk = copy.nChunkSize;\n<line8>i64 iOff = 0;\n<line9>FileChunk *pIter;\n<line10>for(pIter=copy.pFirst; pIter; pIter=pIter->pNext){\n<line11>if( iOff + nChunk > copy.endpoint.iOffset ){\n<line12>nChunk = copy.endpoint.iOffset - iOff;\n<line13>}\n<line14>rc = sqlite3OsWrite(pReal, (u8*)pIter->zChunk, nChunk, iOff);\n<line15>if( rc ) break;\n<line16>iOff += nChunk;\n<line17>}\n<line18>if( rc==SQLITE_OK ){\n<line19>/* No error has occurred. Free the in-memory buffers. */\n<line20>memjrnlFreeChunks(copy.pFirst);\n<line21>}\n<line22>}\n<line23>if( rc!=SQLITE_OK ){\n<line24>/* If an error occurred while creating or writing to the file, restore\n<line25>** the original before returning. This way, SQLite uses the in-memory\n<line26>** journal data to roll back changes made to the internal page-cache\n<line27>** before this function was called.  */\n<line28>sqlite3OsClose(pReal);\n<line29>*p = copy;\n<line30>}\n<line31>return rc;\n<line32>}
----------------------------------------
Function: memjrnlWrite
Content: <line0>static int memjrnlWrite(\n<line1>sqlite3_file *pJfd,    /* The journal file into which to write */\n<line2>const void *zBuf,      /* Take data to be written from here */\n<line3>int iAmt,              /* Number of bytes to write */\n<line4>sqlite_int64 iOfst     /* Begin writing at this offset into the file */\n<line5>){\n<line6>MemJournal *p = (MemJournal *)pJfd;\n<line7>int nWrite = iAmt;\n<line8>u8 *zWrite = (u8 *)zBuf;\n<line9>/* If the file should be created now, create it and write the new data\n<line10>** into the file on disk. */\n<line11>if( p->nSpill>0 && (iAmt+iOfst)>p->nSpill ){\n<line12>int rc = memjrnlCreateFile(p);\n<line13>if( rc==SQLITE_OK ){\n<line14>rc = sqlite3OsWrite(pJfd, zBuf, iAmt, iOfst);\n<line15>}\n<line16>return rc;\n<line17>}\n<line18>/* If the contents of this write should be stored in memory */\n<line19>else{\n<line20>/* An in-memory journal file should only ever be appended to. Random\n<line21>** access writes are not required. The only exception to this is when\n<line22>** the in-memory journal is being used by a connection using the\n<line23>** atomic-write optimization. In this case the first 28 bytes of the\n<line24>** journal file may be written as part of committing the transaction. */\n<line25>assert( iOfst<=p->endpoint.iOffset );\n<line26>if( iOfst>0 && iOfst!=p->endpoint.iOffset ){\n<line27>memjrnlTruncate(pJfd, iOfst);\n<line28>}\n<line29>if( iOfst==0 && p->pFirst ){\n<line30>assert( p->nChunkSize>iAmt );\n<line31>memcpy((u8*)p->pFirst->zChunk, zBuf, iAmt);\n<line32>}else{\n<line33>while( nWrite>0 ){\n<line34>FileChunk *pChunk = p->endpoint.pChunk;\n<line35>int iChunkOffset = (int)(p->endpoint.iOffset%p->nChunkSize);\n<line36>int iSpace = MIN(nWrite, p->nChunkSize - iChunkOffset);\n<line37>assert( pChunk!=0 || iChunkOffset==0 );\n<line38>if( iChunkOffset==0 ){\n<line39>/* New chunk is required to extend the file. */\n<line40>FileChunk *pNew = sqlite3_malloc(fileChunkSize(p->nChunkSize));\n<line41>if( !pNew ){\n<line42>return SQLITE_IOERR_NOMEM_BKPT;\n<line43>}\n<line44>pNew->pNext = 0;\n<line45>if( pChunk ){\n<line46>assert( p->pFirst );\n<line47>pChunk->pNext = pNew;\n<line48>}else{\n<line49>assert( !p->pFirst );\n<line50>p->pFirst = pNew;\n<line51>}\n<line52>pChunk = p->endpoint.pChunk = pNew;\n<line53>}\n<line54>assert( pChunk!=0 );\n<line55>memcpy((u8*)pChunk->zChunk + iChunkOffset, zWrite, iSpace);\n<line56>zWrite += iSpace;\n<line57>nWrite -= iSpace;\n<line58>p->endpoint.iOffset += iSpace;\n<line59>}\n<line60>}\n<line61>}\n<line62>return SQLITE_OK;\n<line63>}
----------------------------------------
Function: memjrnlTruncate
Content: <line0>static int memjrnlTruncate(sqlite3_file *pJfd, sqlite_int64 size){\n<line1>MemJournal *p = (MemJournal *)pJfd;\n<line2>assert( p->endpoint.pChunk==0 || p->endpoint.pChunk->pNext==0 );\n<line3>if( size<p->endpoint.iOffset ){\n<line4>FileChunk *pIter = 0;\n<line5>if( size==0 ){\n<line6>memjrnlFreeChunks(p->pFirst);\n<line7>p->pFirst = 0;\n<line8>}else{\n<line9>i64 iOff = p->nChunkSize;\n<line10>for(pIter=p->pFirst; ALWAYS(pIter) && iOff<size; pIter=pIter->pNext){\n<line11>iOff += p->nChunkSize;\n<line12>}\n<line13>if( ALWAYS(pIter) ){\n<line14>memjrnlFreeChunks(pIter->pNext);\n<line15>pIter->pNext = 0;\n<line16>}\n<line17>}\n<line18>p->endpoint.pChunk = pIter;\n<line19>p->endpoint.iOffset = size;\n<line20>p->readpoint.pChunk = 0;\n<line21>p->readpoint.iOffset = 0;\n<line22>}\n<line23>return SQLITE_OK;\n<line24>}
----------------------------------------
Function: memjrnlClose
Content: <line0>static int memjrnlClose(sqlite3_file *pJfd){\n<line1>MemJournal *p = (MemJournal *)pJfd;\n<line2>memjrnlFreeChunks(p->pFirst);\n<line3>return SQLITE_OK;\n<line4>}
----------------------------------------
Function: memjrnlSync
Content: <line0>static int memjrnlSync(sqlite3_file *pJfd, int flags){\n<line1>UNUSED_PARAMETER2(pJfd, flags);\n<line2>return SQLITE_OK;\n<line3>}
----------------------------------------
Function: memjrnlFileSize
Content: <line0>static int memjrnlFileSize(sqlite3_file *pJfd, sqlite_int64 *pSize){\n<line1>MemJournal *p = (MemJournal *)pJfd;\n<line2>*pSize = (sqlite_int64) p->endpoint.iOffset;\n<line3>return SQLITE_OK;\n<line4>}
----------------------------------------
Function: walkWindowList
Content: <line0>static int walkWindowList(Walker *pWalker, Window *pList, int bOneOnly){\n<line1>Window *pWin;\n<line2>for(pWin=pList; pWin; pWin=pWin->pNextWin){\n<line3>int rc;\n<line4>rc = sqlite3WalkExprList(pWalker, pWin->pOrderBy);\n<line5>if( rc ) return WRC_Abort;\n<line6>rc = sqlite3WalkExprList(pWalker, pWin->pPartition);\n<line7>if( rc ) return WRC_Abort;\n<line8>rc = sqlite3WalkExpr(pWalker, pWin->pFilter);\n<line9>if( rc ) return WRC_Abort;\n<line10>rc = sqlite3WalkExpr(pWalker, pWin->pStart);\n<line11>if( rc ) return WRC_Abort;\n<line12>rc = sqlite3WalkExpr(pWalker, pWin->pEnd);\n<line13>if( rc ) return WRC_Abort;\n<line14>if( bOneOnly ) break;\n<line15>}\n<line16>return WRC_Continue;\n<line17>}
----------------------------------------
Function: incrAggDepth
Content: <line0>static int incrAggDepth(Walker *pWalker, Expr *pExpr){\n<line1>if( pExpr->op==TK_AGG_FUNCTION ) pExpr->op2 += pWalker->u.n;\n<line2>return WRC_Continue;\n<line3>}
----------------------------------------
Function: incrAggFunctionDepth
Content: <line0>static void incrAggFunctionDepth(Expr *pExpr, int N){\n<line1>if( N>0 ){\n<line2>Walker w;\n<line3>memset(&w, 0, sizeof(w));\n<line4>w.xExprCallback = incrAggDepth;\n<line5>w.u.n = N;\n<line6>sqlite3WalkExpr(&w, pExpr);\n<line7>}\n<line8>}
----------------------------------------
Function: resolveAlias
Content: <line0>static void resolveAlias(\n<line1>Parse *pParse,         /* Parsing context */\n<line2>ExprList *pEList,      /* A result set */\n<line3>int iCol,              /* A column in the result set.  0..pEList->nExpr-1 */\n<line4>Expr *pExpr,           /* Transform this into an alias to the result set */\n<line5>int nSubquery          /* Number of subqueries that the label is moving */\n<line6>){\n<line7>Expr *pOrig;           /* The iCol-th column of the result set */\n<line8>Expr *pDup;            /* Copy of pOrig */\n<line9>sqlite3 *db;           /* The database connection */\n<line10>assert( iCol>=0 && iCol<pEList->nExpr );\n<line11>pOrig = pEList->a[iCol].pExpr;\n<line12>assert( pOrig!=0 );\n<line13>assert( !ExprHasProperty(pExpr, EP_Reduced|EP_TokenOnly) );\n<line14>if( pExpr->pAggInfo ) return;\n<line15>db = pParse->db;\n<line16>pDup = sqlite3ExprDup(db, pOrig, 0);\n<line17>if( db->mallocFailed ){\n<line18>sqlite3ExprDelete(db, pDup);\n<line19>pDup = 0;\n<line20>}else{\n<line21>Expr temp;\n<line22>incrAggFunctionDepth(pDup, nSubquery);\n<line23>if( pExpr->op==TK_COLLATE ){\n<line24>assert( !ExprHasProperty(pExpr, EP_IntValue) );\n<line25>pDup = sqlite3ExprAddCollateString(pParse, pDup, pExpr->u.zToken);\n<line26>}\n<line27>memcpy(&temp, pDup, sizeof(Expr));\n<line28>memcpy(pDup, pExpr, sizeof(Expr));\n<line29>memcpy(pExpr, &temp, sizeof(Expr));\n<line30>if( ExprHasProperty(pExpr, EP_WinFunc) ){\n<line31>if( ALWAYS(pExpr->y.pWin!=0) ){\n<line32>pExpr->y.pWin->pOwner = pExpr;\n<line33>}\n<line34>}\n<line35>sqlite3ExprDeferredDelete(pParse, pDup);\n<line36>}\n<line37>}
----------------------------------------
Function: areDoubleQuotedStringsEnabled
Content: <line0>static int areDoubleQuotedStringsEnabled(sqlite3 *db, NameContext *pTopNC){\n<line1>if( db->init.busy ) return 1;  /* Always support for legacy schemas */\n<line2>if( pTopNC->ncFlags & NC_IsDDL ){\n<line3>/* Currently parsing a DDL statement */\n<line4>if( sqlite3WritableSchema(db) && (db->flags & SQLITE_DqsDML)!=0 ){\n<line5>return 1;\n<line6>}\n<line7>return (db->flags & SQLITE_DqsDDL)!=0;\n<line8>}else{\n<line9>/* Currently parsing a DML statement */\n<line10>return (db->flags & SQLITE_DqsDML)!=0;\n<line11>}\n<line12>}
----------------------------------------
Function: extendFJMatch
Content: <line0>static void extendFJMatch(\n<line1>Parse *pParse,          /* Parsing context */\n<line2>ExprList **ppList,      /* ExprList to extend */\n<line3>SrcItem *pMatch,        /* Source table containing the column */\n<line4>i16 iColumn             /* The column number */\n<line5>){\n<line6>Expr *pNew = sqlite3ExprAlloc(pParse->db, TK_COLUMN, 0, 0);\n<line7>if( pNew ){\n<line8>pNew->iTable = pMatch->iCursor;\n<line9>pNew->iColumn = iColumn;\n<line10>pNew->y.pTab = pMatch->pSTab;\n<line11>assert( (pMatch->fg.jointype & (JT_LEFT|JT_LTORJ))!=0 );\n<line12>ExprSetProperty(pNew, EP_CanBeNull);\n<line13>*ppList = sqlite3ExprListAppend(pParse, *ppList, pNew);\n<line14>}\n<line15>}
----------------------------------------
Function: isValidSchemaTableName
Content: <line0>static SQLITE_NOINLINE int isValidSchemaTableName(\n<line1>const char *zTab,         /* Name as it appears in the SQL */\n<line2>Table *pTab,              /* The schema table we are trying to match */\n<line3>const char *zDb           /* non-NULL if a database qualifier is present */\n<line4>){\n<line5>const char *zLegacy;\n<line6>assert( pTab!=0 );\n<line7>assert( pTab->tnum==1 );\n<line8>if( sqlite3StrNICmp(zTab, "sqlite_", 7)!=0 ) return 0;\n<line9>zLegacy = pTab->zName;\n<line10>if( strcmp(zLegacy+7, &LEGACY_TEMP_SCHEMA_TABLE[7])==0 ){\n<line11>if( sqlite3StrICmp(zTab+7, &PREFERRED_TEMP_SCHEMA_TABLE[7])==0 ){\n<line12>return 1;\n<line13>}\n<line14>if( zDb==0 ) return 0;\n<line15>if( sqlite3StrICmp(zTab+7, &LEGACY_SCHEMA_TABLE[7])==0 ) return 1;\n<line16>if( sqlite3StrICmp(zTab+7, &PREFERRED_SCHEMA_TABLE[7])==0 ) return 1;\n<line17>}else{\n<line18>if( sqlite3StrICmp(zTab+7, &PREFERRED_SCHEMA_TABLE[7])==0 ) return 1;\n<line19>}\n<line20>return 0;\n<line21>}
----------------------------------------
Function: lookupName
Content: <line0>static int lookupName(\n<line1>Parse *pParse,       /* The parsing context */\n<line2>const char *zDb,     /* Name of the database containing table, or NULL */\n<line3>const char *zTab,    /* Name of table containing column, or NULL */\n<line4>const Expr *pRight,  /* Name of the column. */\n<line5>NameContext *pNC,    /* The name context used to resolve the name */\n<line6>Expr *pExpr          /* Make this EXPR node point to the selected column */\n<line7>){\n<line8>int i, j;                         /* Loop counters */\n<line9>int cnt = 0;                      /* Number of matching column names */\n<line10>int cntTab = 0;                   /* Number of potential "rowid" matches */\n<line11>int nSubquery = 0;                /* How many levels of subquery */\n<line12>sqlite3 *db = pParse->db;         /* The database connection */\n<line13>SrcItem *pItem;                   /* Use for looping over pSrcList items */\n<line14>SrcItem *pMatch = 0;              /* The matching pSrcList item */\n<line15>NameContext *pTopNC = pNC;        /* First namecontext in the list */\n<line16>Schema *pSchema = 0;              /* Schema of the expression */\n<line17>int eNewExprOp = TK_COLUMN;       /* New value for pExpr->op on success */\n<line18>Table *pTab = 0;                  /* Table holding the row */\n<line19>ExprList *pFJMatch = 0;           /* Matches for FULL JOIN .. USING */\n<line20>const char *zCol = pRight->u.zToken;\n<line21>assert( pNC );     /* the name context cannot be NULL. */\n<line22>assert( zCol );    /* The Z in X.Y.Z cannot be NULL */\n<line23>assert( zDb==0 || zTab!=0 );\n<line24>assert( !ExprHasProperty(pExpr, EP_TokenOnly|EP_Reduced) );\n<line25>/* Initialize the node to no-match */\n<line26>pExpr->iTable = -1;\n<line27>ExprSetVVAProperty(pExpr, EP_NoReduce);\n<line28>/* Translate the schema name in zDb into a pointer to the corresponding\n<line29>** schema.  If not found, pSchema will remain NULL and nothing will match\n<line30>** resulting in an appropriate error message toward the end of this routine\n<line31>*/\n<line32>if( zDb ){\n<line33>testcase( pNC->ncFlags & NC_PartIdx );\n<line34>testcase( pNC->ncFlags & NC_IsCheck );\n<line35>if( (pNC->ncFlags & (NC_PartIdx|NC_IsCheck))!=0 ){\n<line36>/* Silently ignore database qualifiers inside CHECK constraints and\n<line37>** partial indices.  Do not raise errors because that might break\n<line38>** legacy and because it does not hurt anything to just ignore the\n<line39>** database name. */\n<line40>zDb = 0;\n<line41>}else{\n<line42>for(i=0; i<db->nDb; i++){\n<line43>assert( db->aDb[i].zDbSName );\n<line44>if( sqlite3StrICmp(db->aDb[i].zDbSName,zDb)==0 ){\n<line45>pSchema = db->aDb[i].pSchema;\n<line46>break;\n<line47>}\n<line48>}\n<line49>if( i==db->nDb && sqlite3StrICmp("main", zDb)==0 ){\n<line50>/* This branch is taken when the main database has been renamed\n<line51>** using SQLITE_DBCONFIG_MAINDBNAME. */\n<line52>pSchema = db->aDb[0].pSchema;\n<line53>zDb = db->aDb[0].zDbSName;\n<line54>}\n<line55>}\n<line56>}\n<line57>/* Start at the inner-most context and move outward until a match is found */\n<line58>assert( pNC && cnt==0 );\n<line59>do{\n<line60>ExprList *pEList;\n<line61>SrcList *pSrcList = pNC->pSrcList;\n<line62>if( pSrcList ){\n<line63>for(i=0, pItem=pSrcList->a; i<pSrcList->nSrc; i++, pItem++){\n<line64>pTab = pItem->pSTab;\n<line65>assert( pTab!=0 && pTab->zName!=0 );\n<line66>assert( pTab->nCol>0 || pParse->nErr );\n<line67>assert( (int)pItem->fg.isNestedFrom == IsNestedFrom(pItem));\n<line68>if( pItem->fg.isNestedFrom ){\n<line69>/* In this case, pItem is a subquery that has been formed from a\n<line70>** parenthesized subset of the FROM clause terms.  Example:\n<line71>**   .... FROM t1 LEFT JOIN (t2 RIGHT JOIN t3 USING(x)) USING(y) ...\n<line72>**                          \_________________________/\n<line73>**             This pItem -------------^\n<line74>*/\n<line75>int hit = 0;\n<line76>Select *pSel;\n<line77>assert( pItem->fg.isSubquery );\n<line78>assert( pItem->u4.pSubq!=0 );\n<line79>pSel = pItem->u4.pSubq->pSelect;\n<line80>assert( pSel!=0 );\n<line81>pEList = pSel->pEList;\n<line82>assert( pEList!=0 );\n<line83>assert( pEList->nExpr==pTab->nCol );\n<line84>for(j=0; j<pEList->nExpr; j++){\n<line85>int bRowid = 0;       /* True if possible rowid match */\n<line86>if( !sqlite3MatchEName(&pEList->a[j], zCol, zTab, zDb, &bRowid) ){\n<line87>continue;\n<line88>}\n<line89>if( bRowid==0 ){\n<line90>if( cnt>0 ){\n<line91>if( pItem->fg.isUsing==0\n<line92>|| sqlite3IdListIndex(pItem->u3.pUsing, zCol)<0\n<line93>|| pMatch==pItem\n<line94>){\n<line95>/* Two or more tables have the same column name which is\n<line96>** not joined by USING. Or, a single table has two columns\n<line97>** that match a USING term (if pMatch==pItem). These are both\n<line98>** "ambiguous column name" errors. Signal as much by clearing\n<line99>** pFJMatch and letting cnt go above 1. */\n<line100>sqlite3ExprListDelete(db, pFJMatch);\n<line101>pFJMatch = 0;\n<line102>}else\n<line103>if( (pItem->fg.jointype & JT_RIGHT)==0 ){\n<line104>/* An INNER or LEFT JOIN.  Use the left-most table */\n<line105>continue;\n<line106>}else\n<line107>if( (pItem->fg.jointype & JT_LEFT)==0 ){\n<line108>/* A RIGHT JOIN.  Use the right-most table */\n<line109>cnt = 0;\n<line110>sqlite3ExprListDelete(db, pFJMatch);\n<line111>pFJMatch = 0;\n<line112>}else{\n<line113>/* For a FULL JOIN, we must construct a coalesce() func */\n<line114>extendFJMatch(pParse, &pFJMatch, pMatch, pExpr->iColumn);\n<line115>}\n<line116>}\n<line117>cnt++;\n<line118>hit = 1;\n<line119>}else if( cnt>0 ){\n<line120>/* This is a potential rowid match, but there has already been\n<line121>** a real match found. So this can be ignored.  */\n<line122>continue;\n<line123>}\n<line124>cntTab++;\n<line125>pMatch = pItem;\n<line126>pExpr->iColumn = j;\n<line127>pEList->a[j].fg.bUsed = 1;\n<line128>/* rowid cannot be part of a USING clause - assert() this. */\n<line129>assert( bRowid==0 || pEList->a[j].fg.bUsingTerm==0 );\n<line130>if( pEList->a[j].fg.bUsingTerm ) break;\n<line131>}\n<line132>if( hit || zTab==0 ) continue;\n<line133>}\n<line134>assert( zDb==0 || zTab!=0 );\n<line135>if( zTab ){\n<line136>if( zDb ){\n<line137>if( pTab->pSchema!=pSchema ) continue;\n<line138>if( pSchema==0 && strcmp(zDb,"*")!=0 ) continue;\n<line139>}\n<line140>if( pItem->zAlias!=0 ){\n<line141>if( sqlite3StrICmp(zTab, pItem->zAlias)!=0 ){\n<line142>continue;\n<line143>}\n<line144>}else if( sqlite3StrICmp(zTab, pTab->zName)!=0 ){\n<line145>if( pTab->tnum!=1 ) continue;\n<line146>if( !isValidSchemaTableName(zTab, pTab, zDb) ) continue;\n<line147>}\n<line148>assert( ExprUseYTab(pExpr) );\n<line149>if( IN_RENAME_OBJECT && pItem->zAlias ){\n<line150>sqlite3RenameTokenRemap(pParse, 0, (void*)&pExpr->y.pTab);\n<line151>}\n<line152>}\n<line153>j = sqlite3ColumnIndex(pTab, zCol);\n<line154>if( j>=0 ){\n<line155>if( cnt>0 ){\n<line156>if( pItem->fg.isUsing==0\n<line157>|| sqlite3IdListIndex(pItem->u3.pUsing, zCol)<0\n<line158>){\n<line159>/* Two or more tables have the same column name which is\n<line160>** not joined by USING.  This is an error.  Signal as much\n<line161>** by clearing pFJMatch and letting cnt go above 1. */\n<line162>sqlite3ExprListDelete(db, pFJMatch);\n<line163>pFJMatch = 0;\n<line164>}else\n<line165>if( (pItem->fg.jointype & JT_RIGHT)==0 ){\n<line166>/* An INNER or LEFT JOIN.  Use the left-most table */\n<line167>continue;\n<line168>}else\n<line169>if( (pItem->fg.jointype & JT_LEFT)==0 ){\n<line170>/* A RIGHT JOIN.  Use the right-most table */\n<line171>cnt = 0;\n<line172>sqlite3ExprListDelete(db, pFJMatch);\n<line173>pFJMatch = 0;\n<line174>}else{\n<line175>/* For a FULL JOIN, we must construct a coalesce() func */\n<line176>extendFJMatch(pParse, &pFJMatch, pMatch, pExpr->iColumn);\n<line177>}\n<line178>}\n<line179>cnt++;\n<line180>pMatch = pItem;\n<line181>/* Substitute the rowid (column -1) for the INTEGER PRIMARY KEY */\n<line182>pExpr->iColumn = j==pTab->iPKey ? -1 : (i16)j;\n<line183>if( pItem->fg.isNestedFrom ){\n<line184>sqlite3SrcItemColumnUsed(pItem, j);\n<line185>}\n<line186>}\n<line187>if( 0==cnt && VisibleRowid(pTab) ){\n<line188>/* pTab is a potential ROWID match.  Keep track of it and match\n<line189>** the ROWID later if that seems appropriate.  (Search for "cntTab"\n<line190>** to find related code.)  Only allow a ROWID match if there is\n<line191>** a single ROWID match candidate.\n<line192>*/\n<line193>#ifdef SQLITE_ALLOW_ROWID_IN_VIEW\n<line194>/* In SQLITE_ALLOW_ROWID_IN_VIEW mode, allow a ROWID match\n<line195>** if there is a single VIEW candidate or if there is a single\n<line196>** non-VIEW candidate plus multiple VIEW candidates.  In other\n<line197>** words non-VIEW candidate terms take precedence over VIEWs.\n<line198>*/\n<line199>if( cntTab==0\n<line200>|| (cntTab==1\n<line201>&& pMatch!=0\n<line202>&& ALWAYS(pMatch->pSTab!=0)\n<line203>&& (pMatch->pSTab->tabFlags & TF_Ephemeral)!=0\n<line204>&& (pTab->tabFlags & TF_Ephemeral)==0)\n<line205>){\n<line206>cntTab = 1;\n<line207>pMatch = pItem;\n<line208>}else{\n<line209>cntTab++;\n<line210>}\n<line211>#else\n<line212>/* The (much more common) non-SQLITE_ALLOW_ROWID_IN_VIEW case is\n<line213>** simpler since we require exactly one candidate, which will\n<line214>** always be a non-VIEW\n<line215>*/\n<line216>cntTab++;\n<line217>pMatch = pItem;\n<line218>#endif\n<line219>}\n<line220>}\n<line221>if( pMatch ){\n<line222>pExpr->iTable = pMatch->iCursor;\n<line223>assert( ExprUseYTab(pExpr) );\n<line224>pExpr->y.pTab = pMatch->pSTab;\n<line225>if( (pMatch->fg.jointype & (JT_LEFT|JT_LTORJ))!=0 ){\n<line226>ExprSetProperty(pExpr, EP_CanBeNull);\n<line227>}\n<line228>pSchema = pExpr->y.pTab->pSchema;\n<line229>}\n<line230>} /* if( pSrcList ) */\n<line231>#if !defined(SQLITE_OMIT_TRIGGER) || !defined(SQLITE_OMIT_UPSERT)\n<line232>/* If we have not already resolved the name, then maybe\n<line233>** it is a new.* or old.* trigger argument reference.  Or\n<line234>** maybe it is an excluded.* from an upsert.  Or maybe it is\n<line235>** a reference in the RETURNING clause to a table being modified.\n<line236>*/\n<line237>if( cnt==0 && zDb==0 ){\n<line238>pTab = 0;\n<line239>#ifndef SQLITE_OMIT_TRIGGER\n<line240>if( pParse->pTriggerTab!=0 ){\n<line241>int op = pParse->eTriggerOp;\n<line242>assert( op==TK_DELETE || op==TK_UPDATE || op==TK_INSERT );\n<line243>if( pParse->bReturning ){\n<line244>if( (pNC->ncFlags & NC_UBaseReg)!=0\n<line245>&& ALWAYS(zTab==0\n<line246>|| sqlite3StrICmp(zTab,pParse->pTriggerTab->zName)==0\n<line247>|| isValidSchemaTableName(zTab, pParse->pTriggerTab, 0))\n<line248>){\n<line249>pExpr->iTable = op!=TK_DELETE;\n<line250>pTab = pParse->pTriggerTab;\n<line251>}\n<line252>}else if( op!=TK_DELETE && zTab && sqlite3StrICmp("new",zTab) == 0 ){\n<line253>pExpr->iTable = 1;\n<line254>pTab = pParse->pTriggerTab;\n<line255>}else if( op!=TK_INSERT && zTab && sqlite3StrICmp("old",zTab)==0 ){\n<line256>pExpr->iTable = 0;\n<line257>pTab = pParse->pTriggerTab;\n<line258>}\n<line259>}\n<line260>#endif /* SQLITE_OMIT_TRIGGER */\n<line261>#ifndef SQLITE_OMIT_UPSERT\n<line262>if( (pNC->ncFlags & NC_UUpsert)!=0 && zTab!=0 ){\n<line263>Upsert *pUpsert = pNC->uNC.pUpsert;\n<line264>if( pUpsert && sqlite3StrICmp("excluded",zTab)==0 ){\n<line265>pTab = pUpsert->pUpsertSrc->a[0].pSTab;\n<line266>pExpr->iTable = EXCLUDED_TABLE_NUMBER;\n<line267>}\n<line268>}\n<line269>#endif /* SQLITE_OMIT_UPSERT */\n<line270>if( pTab ){\n<line271>int iCol;\n<line272>pSchema = pTab->pSchema;\n<line273>cntTab++;\n<line274>iCol = sqlite3ColumnIndex(pTab, zCol);\n<line275>if( iCol>=0 ){\n<line276>if( pTab->iPKey==iCol ) iCol = -1;\n<line277>}else{\n<line278>if( sqlite3IsRowid(zCol) && VisibleRowid(pTab) ){\n<line279>iCol = -1;\n<line280>}else{\n<line281>iCol = pTab->nCol;\n<line282>}\n<line283>}\n<line284>if( iCol<pTab->nCol ){\n<line285>cnt++;\n<line286>pMatch = 0;\n<line287>#ifndef SQLITE_OMIT_UPSERT\n<line288>if( pExpr->iTable==EXCLUDED_TABLE_NUMBER ){\n<line289>testcase( iCol==(-1) );\n<line290>assert( ExprUseYTab(pExpr) );\n<line291>if( IN_RENAME_OBJECT ){\n<line292>pExpr->iColumn = iCol;\n<line293>pExpr->y.pTab = pTab;\n<line294>eNewExprOp = TK_COLUMN;\n<line295>}else{\n<line296>pExpr->iTable = pNC->uNC.pUpsert->regData +\n<line297>sqlite3TableColumnToStorage(pTab, iCol);\n<line298>eNewExprOp = TK_REGISTER;\n<line299>}\n<line300>}else\n<line301>#endif /* SQLITE_OMIT_UPSERT */\n<line302>{\n<line303>assert( ExprUseYTab(pExpr) );\n<line304>pExpr->y.pTab = pTab;\n<line305>if( pParse->bReturning ){\n<line306>eNewExprOp = TK_REGISTER;\n<line307>pExpr->op2 = TK_COLUMN;\n<line308>pExpr->iColumn = iCol;\n<line309>pExpr->iTable = pNC->uNC.iBaseReg + (pTab->nCol+1)*pExpr->iTable +\n<line310>sqlite3TableColumnToStorage(pTab, iCol) + 1;\n<line311>}else{\n<line312>pExpr->iColumn = (i16)iCol;\n<line313>eNewExprOp = TK_TRIGGER;\n<line314>#ifndef SQLITE_OMIT_TRIGGER\n<line315>if( iCol<0 ){\n<line316>pExpr->affExpr = SQLITE_AFF_INTEGER;\n<line317>}else if( pExpr->iTable==0 ){\n<line318>testcase( iCol==31 );\n<line319>testcase( iCol==32 );\n<line320>pParse->oldmask |= (iCol>=32 ? 0xffffffff : (((u32)1)<<iCol));\n<line321>}else{\n<line322>testcase( iCol==31 );\n<line323>testcase( iCol==32 );\n<line324>pParse->newmask |= (iCol>=32 ? 0xffffffff : (((u32)1)<<iCol));\n<line325>}\n<line326>#endif /* SQLITE_OMIT_TRIGGER */\n<line327>}\n<line328>}\n<line329>}\n<line330>}\n<line331>}\n<line332>#endif /* !defined(SQLITE_OMIT_TRIGGER) || !defined(SQLITE_OMIT_UPSERT) */\n<line333>/*\n<line334>** Perhaps the name is a reference to the ROWID\n<line335>*/\n<line336>if( cnt==0\n<line337>&& cntTab>=1\n<line338>&& pMatch\n<line339>&& (pNC->ncFlags & (NC_IdxExpr|NC_GenCol))==0\n<line340>&& sqlite3IsRowid(zCol)\n<line341>&& ALWAYS(VisibleRowid(pMatch->pSTab) || pMatch->fg.isNestedFrom)\n<line342>){\n<line343>cnt = cntTab;\n<line344>#if SQLITE_ALLOW_ROWID_IN_VIEW+0==2\n<line345>if( pMatch->pSTab!=0 && IsView(pMatch->pSTab) ){\n<line346>eNewExprOp = TK_NULL;\n<line347>}\n<line348>#endif\n<line349>if( pMatch->fg.isNestedFrom==0 ) pExpr->iColumn = -1;\n<line350>pExpr->affExpr = SQLITE_AFF_INTEGER;\n<line351>}\n<line352>/*\n<line353>** If the input is of the form Z (not Y.Z or X.Y.Z) then the name Z\n<line354>** might refer to an result-set alias.  This happens, for example, when\n<line355>** we are resolving names in the WHERE clause of the following command:\n<line356>**\n<line357>**     SELECT a+b AS x FROM table WHERE x<10;\n<line358>**\n<line359>** In cases like this, replace pExpr with a copy of the expression that\n<line360>** forms the result set entry ("a+b" in the example) and return immediately.\n<line361>** Note that the expression in the result set should have already been\n<line362>** resolved by the time the WHERE clause is resolved.\n<line363>**\n<line364>** The ability to use an output result-set column in the WHERE, GROUP BY,\n<line365>** or HAVING clauses, or as part of a larger expression in the ORDER BY\n<line366>** clause is not standard SQL.  This is a (goofy) SQLite extension, that\n<line367>** is supported for backwards compatibility only. Hence, we issue a warning\n<line368>** on sqlite3_log() whenever the capability is used.\n<line369>*/\n<line370>if( cnt==0\n<line371>&& (pNC->ncFlags & NC_UEList)!=0\n<line372>&& zTab==0\n<line373>){\n<line374>pEList = pNC->uNC.pEList;\n<line375>assert( pEList!=0 );\n<line376>for(j=0; j<pEList->nExpr; j++){\n<line377>char *zAs = pEList->a[j].zEName;\n<line378>if( pEList->a[j].fg.eEName==ENAME_NAME\n<line379>&& sqlite3_stricmp(zAs, zCol)==0\n<line380>){\n<line381>Expr *pOrig;\n<line382>assert( pExpr->pLeft==0 && pExpr->pRight==0 );\n<line383>assert( ExprUseXList(pExpr)==0 || pExpr->x.pList==0 );\n<line384>assert( ExprUseXSelect(pExpr)==0 || pExpr->x.pSelect==0 );\n<line385>pOrig = pEList->a[j].pExpr;\n<line386>if( (pNC->ncFlags&NC_AllowAgg)==0 && ExprHasProperty(pOrig, EP_Agg) ){\n<line387>sqlite3ErrorMsg(pParse, "misuse of aliased aggregate %s", zAs);\n<line388>return WRC_Abort;\n<line389>}\n<line390>if( ExprHasProperty(pOrig, EP_Win)\n<line391>&& ((pNC->ncFlags&NC_AllowWin)==0 || pNC!=pTopNC )\n<line392>){\n<line393>sqlite3ErrorMsg(pParse, "misuse of aliased window function %s",zAs);\n<line394>return WRC_Abort;\n<line395>}\n<line396>if( sqlite3ExprVectorSize(pOrig)!=1 ){\n<line397>sqlite3ErrorMsg(pParse, "row value misused");\n<line398>return WRC_Abort;\n<line399>}\n<line400>resolveAlias(pParse, pEList, j, pExpr, nSubquery);\n<line401>cnt = 1;\n<line402>pMatch = 0;\n<line403>assert( zTab==0 && zDb==0 );\n<line404>if( IN_RENAME_OBJECT ){\n<line405>sqlite3RenameTokenRemap(pParse, 0, (void*)pExpr);\n<line406>}\n<line407>goto lookupname_end;\n<line408>}\n<line409>}\n<line410>}\n<line411>/* Advance to the next name context.  The loop will exit when either\n<line412>** we have a match (cnt>0) or when we run out of name contexts.\n<line413>*/\n<line414>if( cnt ) break;\n<line415>pNC = pNC->pNext;\n<line416>nSubquery++;\n<line417>}while( pNC );\n<line418>/*\n<line419>** If X and Y are NULL (in other words if only the column name Z is\n<line420>** supplied) and the value of Z is enclosed in double-quotes, then\n<line421>** Z is a string literal if it doesn't match any column names.  In that\n<line422>** case, we need to return right away and not make any changes to\n<line423>** pExpr.\n<line424>**\n<line425>** Because no reference was made to outer contexts, the pNC->nRef\n<line426>** fields are not changed in any context.\n<line427>*/\n<line428>if( cnt==0 && zTab==0 ){\n<line429>assert( pExpr->op==TK_ID );\n<line430>if( ExprHasProperty(pExpr,EP_DblQuoted)\n<line431>&& areDoubleQuotedStringsEnabled(db, pTopNC)\n<line432>){\n<line433>/* If a double-quoted identifier does not match any known column name,\n<line434>** then treat it as a string.\n<line435>**\n<line436>** This hack was added in the early days of SQLite in a misguided attempt\n<line437>** to be compatible with MySQL 3.x, which used double-quotes for strings.\n<line438>** I now sorely regret putting in this hack. The effect of this hack is\n<line439>** that misspelled identifier names are silently converted into strings\n<line440>** rather than causing an error, to the frustration of countless\n<line441>** programmers. To all those frustrated programmers, my apologies.\n<line442>**\n<line443>** Someday, I hope to get rid of this hack. Unfortunately there is\n<line444>** a huge amount of legacy SQL that uses it. So for now, we just\n<line445>** issue a warning.\n<line446>*/\n<line447>sqlite3_log(SQLITE_WARNING,\n<line448>"double-quoted string literal: \"%w\"", zCol);\n<line449>#ifdef SQLITE_ENABLE_NORMALIZE\n<line450>sqlite3VdbeAddDblquoteStr(db, pParse->pVdbe, zCol);\n<line451>#endif\n<line452>pExpr->op = TK_STRING;\n<line453>memset(&pExpr->y, 0, sizeof(pExpr->y));\n<line454>return WRC_Prune;\n<line455>}\n<line456>if( sqlite3ExprIdToTrueFalse(pExpr) ){\n<line457>return WRC_Prune;\n<line458>}\n<line459>}\n<line460>/*\n<line461>** cnt==0 means there was not match.\n<line462>** cnt>1 means there were two or more matches.\n<line463>**\n<line464>** cnt==0 is always an error.  cnt>1 is often an error, but might\n<line465>** be multiple matches for a NATURAL LEFT JOIN or a LEFT JOIN USING.\n<line466>*/\n<line467>assert( pFJMatch==0 || cnt>0 );\n<line468>assert( !ExprHasProperty(pExpr, EP_xIsSelect|EP_IntValue) );\n<line469>if( cnt!=1 ){\n<line470>const char *zErr;\n<line471>if( pFJMatch ){\n<line472>if( pFJMatch->nExpr==cnt-1 ){\n<line473>if( ExprHasProperty(pExpr,EP_Leaf) ){\n<line474>ExprClearProperty(pExpr,EP_Leaf);\n<line475>}else{\n<line476>sqlite3ExprDelete(db, pExpr->pLeft);\n<line477>pExpr->pLeft = 0;\n<line478>sqlite3ExprDelete(db, pExpr->pRight);\n<line479>pExpr->pRight = 0;\n<line480>}\n<line481>extendFJMatch(pParse, &pFJMatch, pMatch, pExpr->iColumn);\n<line482>pExpr->op = TK_FUNCTION;\n<line483>pExpr->u.zToken = "coalesce";\n<line484>pExpr->x.pList = pFJMatch;\n<line485>cnt = 1;\n<line486>goto lookupname_end;\n<line487>}else{\n<line488>sqlite3ExprListDelete(db, pFJMatch);\n<line489>pFJMatch = 0;\n<line490>}\n<line491>}\n<line492>zErr = cnt==0 ? "no such column" : "ambiguous column name";\n<line493>if( zDb ){\n<line494>sqlite3ErrorMsg(pParse, "%s: %s.%s.%s", zErr, zDb, zTab, zCol);\n<line495>}else if( zTab ){\n<line496>sqlite3ErrorMsg(pParse, "%s: %s.%s", zErr, zTab, zCol);\n<line497>}else if( cnt==0 && ExprHasProperty(pRight,EP_DblQuoted) ){\n<line498>sqlite3ErrorMsg(pParse, "%s: \"%s\" - should this be a"\n<line499>" string literal in single-quotes?",\n<line500>zErr, zCol);\n<line501>}else{\n<line502>sqlite3ErrorMsg(pParse, "%s: %s", zErr, zCol);\n<line503>}\n<line504>sqlite3RecordErrorOffsetOfExpr(pParse->db, pExpr);\n<line505>pParse->checkSchema = 1;\n<line506>pTopNC->nNcErr++;\n<line507>eNewExprOp = TK_NULL;\n<line508>}\n<line509>assert( pFJMatch==0 );\n<line510>/* Remove all substructure from pExpr */\n<line511>if( !ExprHasProperty(pExpr,(EP_TokenOnly|EP_Leaf)) ){\n<line512>sqlite3ExprDelete(db, pExpr->pLeft);\n<line513>pExpr->pLeft = 0;\n<line514>sqlite3ExprDelete(db, pExpr->pRight);\n<line515>pExpr->pRight = 0;\n<line516>ExprSetProperty(pExpr, EP_Leaf);\n<line517>}\n<line518>/* If a column from a table in pSrcList is referenced, then record\n<line519>** this fact in the pSrcList.a[].colUsed bitmask.  Column 0 causes\n<line520>** bit 0 to be set.  Column 1 sets bit 1.  And so forth.  Bit 63 is\n<line521>** set if the 63rd or any subsequent column is used.\n<line522>**\n<line523>** The colUsed mask is an optimization used to help determine if an\n<line524>** index is a covering index.  The correct answer is still obtained\n<line525>** if the mask contains extra set bits.  However, it is important to\n<line526>** avoid setting bits beyond the maximum column number of the table.\n<line527>** (See ticket [b92e5e8ec2cdbaa1]).\n<line528>**\n<line529>** If a generated column is referenced, set bits for every column\n<line530>** of the table.\n<line531>*/\n<line532>if( pMatch ){\n<line533>if( pExpr->iColumn>=0 ){\n<line534>pMatch->colUsed |= sqlite3ExprColUsed(pExpr);\n<line535>}else{\n<line536>pMatch->fg.rowidUsed = 1;\n<line537>}\n<line538>}\n<line539>pExpr->op = eNewExprOp;\n<line540>lookupname_end:\n<line541>if( cnt==1 ){\n<line542>assert( pNC!=0 );\n<line543>#ifndef SQLITE_OMIT_AUTHORIZATION\n<line544>if( pParse->db->xAuth\n<line545>&& (pExpr->op==TK_COLUMN || pExpr->op==TK_TRIGGER)\n<line546>){\n<line547>sqlite3AuthRead(pParse, pExpr, pSchema, pNC->pSrcList);\n<line548>}\n<line549>#endif\n<line550>/* Increment the nRef value on all name contexts from TopNC up to\n<line551>** the point where the name matched. */\n<line552>for(;;){\n<line553>assert( pTopNC!=0 );\n<line554>pTopNC->nRef++;\n<line555>if( pTopNC==pNC ) break;\n<line556>pTopNC = pTopNC->pNext;\n<line557>}\n<line558>return WRC_Prune;\n<line559>} else {\n<line560>return WRC_Abort;\n<line561>}\n<line562>}
----------------------------------------
Function: notValidImpl
Content: <line0>static void notValidImpl(\n<line1>Parse *pParse,       /* Leave error message here */\n<line2>NameContext *pNC,    /* The name context */\n<line3>const char *zMsg,    /* Type of error */\n<line4>Expr *pExpr,         /* Invalidate this expression on error */\n<line5>Expr *pError         /* Associate error with this expression */\n<line6>){\n<line7>const char *zIn = "partial index WHERE clauses";\n<line8>if( pNC->ncFlags & NC_IdxExpr )      zIn = "index expressions";\n<line9>#ifndef SQLITE_OMIT_CHECK\n<line10>else if( pNC->ncFlags & NC_IsCheck ) zIn = "CHECK constraints";\n<line11>#endif\n<line12>#ifndef SQLITE_OMIT_GENERATED_COLUMNS\n<line13>else if( pNC->ncFlags & NC_GenCol ) zIn = "generated columns";\n<line14>#endif\n<line15>sqlite3ErrorMsg(pParse, "%s prohibited in %s", zMsg, zIn);\n<line16>if( pExpr ) pExpr->op = TK_NULL;\n<line17>sqlite3RecordErrorOffsetOfExpr(pParse->db, pError);\n<line18>}
----------------------------------------
Function: exprProbability
Content: <line0>static int exprProbability(Expr *p){\n<line1>double r = -1.0;\n<line2>if( p->op!=TK_FLOAT ) return -1;\n<line3>assert( !ExprHasProperty(p, EP_IntValue) );\n<line4>sqlite3AtoF(p->u.zToken, &r, sqlite3Strlen30(p->u.zToken), SQLITE_UTF8);\n<line5>assert( r>=0.0 );\n<line6>if( r>1.0 ) return -1;\n<line7>return (int)(r*134217728.0);\n<line8>}
----------------------------------------
Function: resolveExprStep
Content: <line0>static int resolveExprStep(Walker *pWalker, Expr *pExpr){\n<line1>NameContext *pNC;\n<line2>Parse *pParse;\n<line3>pNC = pWalker->u.pNC;\n<line4>assert( pNC!=0 );\n<line5>pParse = pNC->pParse;\n<line6>assert( pParse==pWalker->pParse );\n<line7>#ifndef NDEBUG\n<line8>if( pNC->pSrcList && pNC->pSrcList->nAlloc>0 ){\n<line9>SrcList *pSrcList = pNC->pSrcList;\n<line10>int i;\n<line11>for(i=0; i<pNC->pSrcList->nSrc; i++){\n<line12>assert( pSrcList->a[i].iCursor>=0 && pSrcList->a[i].iCursor<pParse->nTab);\n<line13>}\n<line14>}\n<line15>#endif\n<line16>switch( pExpr->op ){\n<line17>/* The special operator TK_ROW means use the rowid for the first\n<line18>** column in the FROM clause.  This is used by the LIMIT and ORDER BY\n<line19>** clause processing on UPDATE and DELETE statements, and by\n<line20>** UPDATE ... FROM statement processing.\n<line21>*/\n<line22>case TK_ROW: {\n<line23>SrcList *pSrcList = pNC->pSrcList;\n<line24>SrcItem *pItem;\n<line25>assert( pSrcList && pSrcList->nSrc>=1 );\n<line26>pItem = pSrcList->a;\n<line27>pExpr->op = TK_COLUMN;\n<line28>assert( ExprUseYTab(pExpr) );\n<line29>pExpr->y.pTab = pItem->pSTab;\n<line30>pExpr->iTable = pItem->iCursor;\n<line31>pExpr->iColumn--;\n<line32>pExpr->affExpr = SQLITE_AFF_INTEGER;\n<line33>break;\n<line34>}\n<line35>/* An optimization:  Attempt to convert\n<line36>**\n<line37>**      "expr IS NOT NULL"  -->  "TRUE"\n<line38>**      "expr IS NULL"      -->  "FALSE"\n<line39>**\n<line40>** if we can prove that "expr" is never NULL.  Call this the\n<line41>** "NOT NULL strength reduction optimization".\n<line42>**\n<line43>** If this optimization occurs, also restore the NameContext ref-counts\n<line44>** to the state they where in before the "column" LHS expression was\n<line45>** resolved.  This prevents "column" from being counted as having been\n<line46>** referenced, which might prevent a SELECT from being erroneously\n<line47>** marked as correlated.\n<line48>**\n<line49>** 2024-03-28: Beware of aggregates.  A bare column of aggregated table\n<line50>** can still evaluate to NULL even though it is marked as NOT NULL.\n<line51>** Example:\n<line52>**\n<line53>**       CREATE TABLE t1(a INT NOT NULL);\n<line54>**       SELECT a, a IS NULL, a IS NOT NULL, count(*) FROM t1;\n<line55>**\n<line56>** The "a IS NULL" and "a IS NOT NULL" expressions cannot be optimized\n<line57>** here because at the time this case is hit, we do not yet know whether\n<line58>** or not t1 is being aggregated.  We have to assume the worst and omit\n<line59>** the optimization.  The only time it is safe to apply this optimization\n<line60>** is within the WHERE clause.\n<line61>*/\n<line62>case TK_NOTNULL:\n<line63>case TK_ISNULL: {\n<line64>int anRef[8];\n<line65>NameContext *p;\n<line66>int i;\n<line67>for(i=0, p=pNC; p && i<ArraySize(anRef); p=p->pNext, i++){\n<line68>anRef[i] = p->nRef;\n<line69>}\n<line70>sqlite3WalkExpr(pWalker, pExpr->pLeft);\n<line71>if( IN_RENAME_OBJECT ) return WRC_Prune;\n<line72>if( sqlite3ExprCanBeNull(pExpr->pLeft) ){\n<line73>/* The expression can be NULL.  So the optimization does not apply */\n<line74>return WRC_Prune;\n<line75>}\n<line76>for(i=0, p=pNC; p; p=p->pNext, i++){\n<line77>if( (p->ncFlags & NC_Where)==0 ){\n<line78>return WRC_Prune;  /* Not in a WHERE clause.  Unsafe to optimize. */\n<line79>}\n<line80>}\n<line81>testcase( ExprHasProperty(pExpr, EP_OuterON) );\n<line82>assert( !ExprHasProperty(pExpr, EP_IntValue) );\n<line83>#if TREETRACE_ENABLED\n<line84>if( sqlite3TreeTrace & 0x80000 ){\n<line85>sqlite3DebugPrintf(\n<line86>"NOT NULL strength reduction converts the following to %d:\n",\n<line87>pExpr->op==TK_NOTNULL\n<line88>);\n<line89>sqlite3ShowExpr(pExpr);\n<line90>}\n<line91>#endif /* TREETRACE_ENABLED */\n<line92>pExpr->u.iValue = (pExpr->op==TK_NOTNULL);\n<line93>pExpr->flags |= EP_IntValue;\n<line94>pExpr->op = TK_INTEGER;\n<line95>for(i=0, p=pNC; p && i<ArraySize(anRef); p=p->pNext, i++){\n<line96>p->nRef = anRef[i];\n<line97>}\n<line98>sqlite3ExprDelete(pParse->db, pExpr->pLeft);\n<line99>pExpr->pLeft = 0;\n<line100>return WRC_Prune;\n<line101>}\n<line102>/* A column name:                    ID\n<line103>** Or table name and column name:    ID.ID\n<line104>** Or a database, table and column:  ID.ID.ID\n<line105>**\n<line106>** The TK_ID and TK_OUT cases are combined so that there will only\n<line107>** be one call to lookupName().  Then the compiler will in-line\n<line108>** lookupName() for a size reduction and performance increase.\n<line109>*/\n<line110>case TK_ID:\n<line111>case TK_DOT: {\n<line112>const char *zTable;\n<line113>const char *zDb;\n<line114>Expr *pRight;\n<line115>if( pExpr->op==TK_ID ){\n<line116>zDb = 0;\n<line117>zTable = 0;\n<line118>assert( !ExprHasProperty(pExpr, EP_IntValue) );\n<line119>pRight = pExpr;\n<line120>}else{\n<line121>Expr *pLeft = pExpr->pLeft;\n<line122>testcase( pNC->ncFlags & NC_IdxExpr );\n<line123>testcase( pNC->ncFlags & NC_GenCol );\n<line124>sqlite3ResolveNotValid(pParse, pNC, "the \".\" operator",\n<line125>NC_IdxExpr|NC_GenCol, 0, pExpr);\n<line126>pRight = pExpr->pRight;\n<line127>if( pRight->op==TK_ID ){\n<line128>zDb = 0;\n<line129>}else{\n<line130>assert( pRight->op==TK_DOT );\n<line131>assert( !ExprHasProperty(pRight, EP_IntValue) );\n<line132>zDb = pLeft->u.zToken;\n<line133>pLeft = pRight->pLeft;\n<line134>pRight = pRight->pRight;\n<line135>}\n<line136>assert( ExprUseUToken(pLeft) && ExprUseUToken(pRight) );\n<line137>zTable = pLeft->u.zToken;\n<line138>assert( ExprUseYTab(pExpr) );\n<line139>if( IN_RENAME_OBJECT ){\n<line140>sqlite3RenameTokenRemap(pParse, (void*)pExpr, (void*)pRight);\n<line141>sqlite3RenameTokenRemap(pParse, (void*)&pExpr->y.pTab, (void*)pLeft);\n<line142>}\n<line143>}\n<line144>return lookupName(pParse, zDb, zTable, pRight, pNC, pExpr);\n<line145>}\n<line146>/* Resolve function names\n<line147>*/\n<line148>case TK_FUNCTION: {\n<line149>ExprList *pList;            /* The argument list */\n<line150>int n;                      /* Number of arguments */\n<line151>int no_such_func = 0;       /* True if no such function exists */\n<line152>int wrong_num_args = 0;     /* True if wrong number of arguments */\n<line153>int is_agg = 0;             /* True if is an aggregate function */\n<line154>const char *zId;            /* The function name. */\n<line155>FuncDef *pDef;              /* Information about the function */\n<line156>u8 enc = ENC(pParse->db);   /* The database encoding */\n<line157>int savedAllowFlags = (pNC->ncFlags & (NC_AllowAgg | NC_AllowWin));\n<line158>#ifndef SQLITE_OMIT_WINDOWFUNC\n<line159>Window *pWin = (IsWindowFunc(pExpr) ? pExpr->y.pWin : 0);\n<line160>#endif\n<line161>assert( !ExprHasProperty(pExpr, EP_xIsSelect|EP_IntValue) );\n<line162>assert( pExpr->pLeft==0 || pExpr->pLeft->op==TK_ORDER );\n<line163>pList = pExpr->x.pList;\n<line164>n = pList ? pList->nExpr : 0;\n<line165>zId = pExpr->u.zToken;\n<line166>pDef = sqlite3FindFunction(pParse->db, zId, n, enc, 0);\n<line167>if( pDef==0 ){\n<line168>pDef = sqlite3FindFunction(pParse->db, zId, -2, enc, 0);\n<line169>if( pDef==0 ){\n<line170>no_such_func = 1;\n<line171>}else{\n<line172>wrong_num_args = 1;\n<line173>}\n<line174>}else{\n<line175>is_agg = pDef->xFinalize!=0;\n<line176>if( pDef->funcFlags & SQLITE_FUNC_UNLIKELY ){\n<line177>ExprSetProperty(pExpr, EP_Unlikely);\n<line178>if( n==2 ){\n<line179>pExpr->iTable = exprProbability(pList->a[1].pExpr);\n<line180>if( pExpr->iTable<0 ){\n<line181>sqlite3ErrorMsg(pParse,\n<line182>"second argument to %#T() must be a "\n<line183>"constant between 0.0 and 1.0", pExpr);\n<line184>pNC->nNcErr++;\n<line185>}\n<line186>}else{\n<line187>/* EVIDENCE-OF: R-61304-29449 The unlikely(X) function is\n<line188>** equivalent to likelihood(X, 0.0625).\n<line189>** EVIDENCE-OF: R-01283-11636 The unlikely(X) function is\n<line190>** short-hand for likelihood(X,0.0625).\n<line191>** EVIDENCE-OF: R-36850-34127 The likely(X) function is short-hand\n<line192>** for likelihood(X,0.9375).\n<line193>** EVIDENCE-OF: R-53436-40973 The likely(X) function is equivalent\n<line194>** to likelihood(X,0.9375). */\n<line195>/* TUNING: unlikely() probability is 0.0625.  likely() is 0.9375 */\n<line196>pExpr->iTable = pDef->zName[0]=='u' ? 8388608 : 125829120;\n<line197>}\n<line198>}\n<line199>#ifndef SQLITE_OMIT_AUTHORIZATION\n<line200>{\n<line201>int auth = sqlite3AuthCheck(pParse, SQLITE_FUNCTION, 0,pDef->zName,0);\n<line202>if( auth!=SQLITE_OK ){\n<line203>if( auth==SQLITE_DENY ){\n<line204>sqlite3ErrorMsg(pParse, "not authorized to use function: %#T",\n<line205>pExpr);\n<line206>pNC->nNcErr++;\n<line207>}\n<line208>pExpr->op = TK_NULL;\n<line209>return WRC_Prune;\n<line210>}\n<line211>}\n<line212>#endif\n<line213>/* If the function may call sqlite3_value_subtype(), then set the\n<line214>** EP_SubtArg flag on all of its argument expressions. This prevents\n<line215>** where.c from replacing the expression with a value read from an\n<line216>** index on the same expression, which will not have the correct\n<line217>** subtype. Also set the flag if the function expression itself is\n<line218>** an EP_SubtArg expression. In this case subtypes are required as\n<line219>** the function may return a value with a subtype back to its\n<line220>** caller using sqlite3_result_value().  */\n<line221>if( (pDef->funcFlags & SQLITE_SUBTYPE)\n<line222>|| ExprHasProperty(pExpr, EP_SubtArg)\n<line223>){\n<line224>int ii;\n<line225>for(ii=0; ii<n; ii++){\n<line226>ExprSetProperty(pList->a[ii].pExpr, EP_SubtArg);\n<line227>}\n<line228>}\n<line229>if( pDef->funcFlags & (SQLITE_FUNC_CONSTANT|SQLITE_FUNC_SLOCHNG) ){\n<line230>/* For the purposes of the EP_ConstFunc flag, date and time\n<line231>** functions and other functions that change slowly are considered\n<line232>** constant because they are constant for the duration of one query.\n<line233>** This allows them to be factored out of inner loops. */\n<line234>ExprSetProperty(pExpr,EP_ConstFunc);\n<line235>}\n<line236>if( (pDef->funcFlags & SQLITE_FUNC_CONSTANT)==0 ){\n<line237>/* Clearly non-deterministic functions like random(), but also\n<line238>** date/time functions that use 'now', and other functions like\n<line239>** sqlite_version() that might change over time cannot be used\n<line240>** in an index or generated column.  Curiously, they can be used\n<line241>** in a CHECK constraint.  SQLServer, MySQL, and PostgreSQL all\n<line242>** allow this. */\n<line243>sqlite3ResolveNotValid(pParse, pNC, "non-deterministic functions",\n<line244>NC_IdxExpr|NC_PartIdx|NC_GenCol, 0, pExpr);\n<line245>}else{\n<line246>assert( (NC_SelfRef & 0xff)==NC_SelfRef ); /* Must fit in 8 bits */\n<line247>pExpr->op2 = pNC->ncFlags & NC_SelfRef;\n<line248>}\n<line249>if( (pDef->funcFlags & SQLITE_FUNC_INTERNAL)!=0\n<line250>&& pParse->nested==0\n<line251>&& (pParse->db->mDbFlags & DBFLAG_InternalFunc)==0\n<line252>){\n<line253>/* Internal-use-only functions are disallowed unless the\n<line254>** SQL is being compiled using sqlite3NestedParse() or\n<line255>** the SQLITE_TESTCTRL_INTERNAL_FUNCTIONS test-control has be\n<line256>** used to activate internal functions for testing purposes */\n<line257>no_such_func = 1;\n<line258>pDef = 0;\n<line259>}else\n<line260>if( (pDef->funcFlags & (SQLITE_FUNC_DIRECT|SQLITE_FUNC_UNSAFE))!=0\n<line261>&& !IN_RENAME_OBJECT\n<line262>){\n<line263>if( pNC->ncFlags & NC_FromDDL ) ExprSetProperty(pExpr, EP_FromDDL);\n<line264>sqlite3ExprFunctionUsable(pParse, pExpr, pDef);\n<line265>}\n<line266>}\n<line267>if( 0==IN_RENAME_OBJECT ){\n<line268>#ifndef SQLITE_OMIT_WINDOWFUNC\n<line269>assert( is_agg==0 || (pDef->funcFlags & SQLITE_FUNC_MINMAX)\n<line270>|| (pDef->xValue==0 && pDef->xInverse==0)\n<line271>|| (pDef->xValue && pDef->xInverse && pDef->xSFunc && pDef->xFinalize)\n<line272>);\n<line273>if( pDef && pDef->xValue==0 && pWin ){\n<line274>sqlite3ErrorMsg(pParse,\n<line275>"%#T() may not be used as a window function", pExpr\n<line276>);\n<line277>pNC->nNcErr++;\n<line278>}else if(\n<line279>(is_agg && (pNC->ncFlags & NC_AllowAgg)==0)\n<line280>|| (is_agg && (pDef->funcFlags&SQLITE_FUNC_WINDOW) && !pWin)\n<line281>|| (is_agg && pWin && (pNC->ncFlags & NC_AllowWin)==0)\n<line282>){\n<line283>const char *zType;\n<line284>if( (pDef->funcFlags & SQLITE_FUNC_WINDOW) || pWin ){\n<line285>zType = "window";\n<line286>}else{\n<line287>zType = "aggregate";\n<line288>}\n<line289>sqlite3ErrorMsg(pParse, "misuse of %s function %#T()",zType,pExpr);\n<line290>pNC->nNcErr++;\n<line291>is_agg = 0;\n<line292>}\n<line293>#else\n<line294>if( (is_agg && (pNC->ncFlags & NC_AllowAgg)==0) ){\n<line295>sqlite3ErrorMsg(pParse,"misuse of aggregate function %#T()",pExpr);\n<line296>pNC->nNcErr++;\n<line297>is_agg = 0;\n<line298>}\n<line299>#endif\n<line300>else if( no_such_func && pParse->db->init.busy==0\n<line301>#ifdef SQLITE_ENABLE_UNKNOWN_SQL_FUNCTION\n<line302>&& pParse->explain==0\n<line303>#endif\n<line304>){\n<line305>sqlite3ErrorMsg(pParse, "no such function: %#T", pExpr);\n<line306>pNC->nNcErr++;\n<line307>}else if( wrong_num_args ){\n<line308>sqlite3ErrorMsg(pParse,"wrong number of arguments to function %#T()",\n<line309>pExpr);\n<line310>pNC->nNcErr++;\n<line311>}\n<line312>#ifndef SQLITE_OMIT_WINDOWFUNC\n<line313>else if( is_agg==0 && ExprHasProperty(pExpr, EP_WinFunc) ){\n<line314>sqlite3ErrorMsg(pParse,\n<line315>"FILTER may not be used with non-aggregate %#T()",\n<line316>pExpr\n<line317>);\n<line318>pNC->nNcErr++;\n<line319>}\n<line320>#endif\n<line321>else if( is_agg==0 && pExpr->pLeft ){\n<line322>sqlite3ExprOrderByAggregateError(pParse, pExpr);\n<line323>pNC->nNcErr++;\n<line324>}\n<line325>if( is_agg ){\n<line326>/* Window functions may not be arguments of aggregate functions.\n<line327>** Or arguments of other window functions. But aggregate functions\n<line328>** may be arguments for window functions.  */\n<line329>#ifndef SQLITE_OMIT_WINDOWFUNC\n<line330>pNC->ncFlags &= ~(NC_AllowWin | (!pWin ? NC_AllowAgg : 0));\n<line331>#else\n<line332>pNC->ncFlags &= ~NC_AllowAgg;\n<line333>#endif\n<line334>}\n<line335>}\n<line336>else if( ExprHasProperty(pExpr, EP_WinFunc) || pExpr->pLeft ){\n<line337>is_agg = 1;\n<line338>}\n<line339>sqlite3WalkExprList(pWalker, pList);\n<line340>if( is_agg ){\n<line341>if( pExpr->pLeft ){\n<line342>assert( pExpr->pLeft->op==TK_ORDER );\n<line343>assert( ExprUseXList(pExpr->pLeft) );\n<line344>sqlite3WalkExprList(pWalker, pExpr->pLeft->x.pList);\n<line345>}\n<line346>#ifndef SQLITE_OMIT_WINDOWFUNC\n<line347>if( pWin && pParse->nErr==0 ){\n<line348>Select *pSel = pNC->pWinSelect;\n<line349>assert( ExprUseYWin(pExpr) && pWin==pExpr->y.pWin );\n<line350>if( IN_RENAME_OBJECT==0 ){\n<line351>sqlite3WindowUpdate(pParse, pSel ? pSel->pWinDefn : 0, pWin, pDef);\n<line352>if( pParse->db->mallocFailed ) break;\n<line353>}\n<line354>sqlite3WalkExprList(pWalker, pWin->pPartition);\n<line355>sqlite3WalkExprList(pWalker, pWin->pOrderBy);\n<line356>sqlite3WalkExpr(pWalker, pWin->pFilter);\n<line357>sqlite3WindowLink(pSel, pWin);\n<line358>pNC->ncFlags |= NC_HasWin;\n<line359>}else\n<line360>#endif /* SQLITE_OMIT_WINDOWFUNC */\n<line361>{\n<line362>NameContext *pNC2;          /* For looping up thru outer contexts */\n<line363>pExpr->op = TK_AGG_FUNCTION;\n<line364>pExpr->op2 = 0;\n<line365>#ifndef SQLITE_OMIT_WINDOWFUNC\n<line366>if( ExprHasProperty(pExpr, EP_WinFunc) ){\n<line367>sqlite3WalkExpr(pWalker, pExpr->y.pWin->pFilter);\n<line368>}\n<line369>#endif\n<line370>pNC2 = pNC;\n<line371>while( pNC2\n<line372>&& sqlite3ReferencesSrcList(pParse, pExpr, pNC2->pSrcList)==0\n<line373>){\n<line374>pExpr->op2 += (1 + pNC2->nNestedSelect);\n<line375>pNC2 = pNC2->pNext;\n<line376>}\n<line377>assert( pDef!=0 || IN_RENAME_OBJECT );\n<line378>if( pNC2 && pDef ){\n<line379>pExpr->op2 += pNC2->nNestedSelect;\n<line380>assert( SQLITE_FUNC_MINMAX==NC_MinMaxAgg );\n<line381>assert( SQLITE_FUNC_ANYORDER==NC_OrderAgg );\n<line382>testcase( (pDef->funcFlags & SQLITE_FUNC_MINMAX)!=0 );\n<line383>testcase( (pDef->funcFlags & SQLITE_FUNC_ANYORDER)!=0 );\n<line384>pNC2->ncFlags |= NC_HasAgg\n<line385>| ((pDef->funcFlags^SQLITE_FUNC_ANYORDER)\n<line386>& (SQLITE_FUNC_MINMAX|SQLITE_FUNC_ANYORDER));\n<line387>}\n<line388>}\n<line389>pNC->ncFlags |= savedAllowFlags;\n<line390>}\n<line391>/* FIX ME:  Compute pExpr->affinity based on the expected return\n<line392>** type of the function\n<line393>*/\n<line394>return WRC_Prune;\n<line395>}\n<line396>#ifndef SQLITE_OMIT_SUBQUERY\n<line397>case TK_EXISTS:\n<line398>case TK_SELECT:\n<line399>#endif\n<line400>case TK_IN: {\n<line401>testcase( pExpr->op==TK_IN );\n<line402>testcase( pExpr->op==TK_EXISTS );\n<line403>testcase( pExpr->op==TK_SELECT );\n<line404>if( ExprUseXSelect(pExpr) ){\n<line405>int nRef = pNC->nRef;\n<line406>testcase( pNC->ncFlags & NC_IsCheck );\n<line407>testcase( pNC->ncFlags & NC_PartIdx );\n<line408>testcase( pNC->ncFlags & NC_IdxExpr );\n<line409>testcase( pNC->ncFlags & NC_GenCol );\n<line410>assert( pExpr->x.pSelect );\n<line411>if( pExpr->op==TK_EXISTS )  pParse->bHasExists = 1;\n<line412>if( pNC->ncFlags & NC_SelfRef ){\n<line413>notValidImpl(pParse, pNC, "subqueries", pExpr, pExpr);\n<line414>}else{\n<line415>sqlite3WalkSelect(pWalker, pExpr->x.pSelect);\n<line416>}\n<line417>assert( pNC->nRef>=nRef );\n<line418>if( nRef!=pNC->nRef ){\n<line419>ExprSetProperty(pExpr, EP_VarSelect);\n<line420>pExpr->x.pSelect->selFlags |= SF_Correlated;\n<line421>}\n<line422>pNC->ncFlags |= NC_Subquery;\n<line423>}\n<line424>break;\n<line425>}\n<line426>case TK_VARIABLE: {\n<line427>testcase( pNC->ncFlags & NC_IsCheck );\n<line428>testcase( pNC->ncFlags & NC_PartIdx );\n<line429>testcase( pNC->ncFlags & NC_IdxExpr );\n<line430>testcase( pNC->ncFlags & NC_GenCol );\n<line431>sqlite3ResolveNotValid(pParse, pNC, "parameters",\n<line432>NC_IsCheck|NC_PartIdx|NC_IdxExpr|NC_GenCol, pExpr, pExpr);\n<line433>break;\n<line434>}\n<line435>case TK_IS:\n<line436>case TK_ISNOT: {\n<line437>Expr *pRight = sqlite3ExprSkipCollateAndLikely(pExpr->pRight);\n<line438>assert( !ExprHasProperty(pExpr, EP_Reduced) );\n<line439>/* Handle special cases of "x IS TRUE", "x IS FALSE", "x IS NOT TRUE",\n<line440>** and "x IS NOT FALSE". */\n<line441>if( ALWAYS(pRight) && (pRight->op==TK_ID || pRight->op==TK_TRUEFALSE) ){\n<line442>int rc = resolveExprStep(pWalker, pRight);\n<line443>if( rc==WRC_Abort ) return WRC_Abort;\n<line444>if( pRight->op==TK_TRUEFALSE ){\n<line445>pExpr->op2 = pExpr->op;\n<line446>pExpr->op = TK_TRUTH;\n<line447>return WRC_Continue;\n<line448>}\n<line449>}\n<line450>/* no break */ deliberate_fall_through\n<line451>}\n<line452>case TK_BETWEEN:\n<line453>case TK_EQ:\n<line454>case TK_NE:\n<line455>case TK_LT:\n<line456>case TK_LE:\n<line457>case TK_GT:\n<line458>case TK_GE: {\n<line459>int nLeft, nRight;\n<line460>if( pParse->db->mallocFailed ) break;\n<line461>assert( pExpr->pLeft!=0 );\n<line462>nLeft = sqlite3ExprVectorSize(pExpr->pLeft);\n<line463>if( pExpr->op==TK_BETWEEN ){\n<line464>assert( ExprUseXList(pExpr) );\n<line465>nRight = sqlite3ExprVectorSize(pExpr->x.pList->a[0].pExpr);\n<line466>if( nRight==nLeft ){\n<line467>nRight = sqlite3ExprVectorSize(pExpr->x.pList->a[1].pExpr);\n<line468>}\n<line469>}else{\n<line470>assert( pExpr->pRight!=0 );\n<line471>nRight = sqlite3ExprVectorSize(pExpr->pRight);\n<line472>}\n<line473>if( nLeft!=nRight ){\n<line474>testcase( pExpr->op==TK_EQ );\n<line475>testcase( pExpr->op==TK_NE );\n<line476>testcase( pExpr->op==TK_LT );\n<line477>testcase( pExpr->op==TK_LE );\n<line478>testcase( pExpr->op==TK_GT );\n<line479>testcase( pExpr->op==TK_GE );\n<line480>testcase( pExpr->op==TK_IS );\n<line481>testcase( pExpr->op==TK_ISNOT );\n<line482>testcase( pExpr->op==TK_BETWEEN );\n<line483>sqlite3ErrorMsg(pParse, "row value misused");\n<line484>sqlite3RecordErrorOffsetOfExpr(pParse->db, pExpr);\n<line485>}\n<line486>break;\n<line487>}\n<line488>}\n<line489>assert( pParse->db->mallocFailed==0 || pParse->nErr!=0 );\n<line490>return pParse->nErr ? WRC_Abort : WRC_Continue;\n<line491>}
----------------------------------------
Function: resolveAsName
Content: <line0>static int resolveAsName(\n<line1>Parse *pParse,     /* Parsing context for error messages */\n<line2>ExprList *pEList,  /* List of expressions to scan */\n<line3>Expr *pE           /* Expression we are trying to match */\n<line4>){\n<line5>int i;             /* Loop counter */\n<line6>UNUSED_PARAMETER(pParse);\n<line7>if( pE->op==TK_ID ){\n<line8>const char *zCol;\n<line9>assert( !ExprHasProperty(pE, EP_IntValue) );\n<line10>zCol = pE->u.zToken;\n<line11>for(i=0; i<pEList->nExpr; i++){\n<line12>if( pEList->a[i].fg.eEName==ENAME_NAME\n<line13>&& sqlite3_stricmp(pEList->a[i].zEName, zCol)==0\n<line14>){\n<line15>return i+1;\n<line16>}\n<line17>}\n<line18>}\n<line19>return 0;\n<line20>}
----------------------------------------
Function: resolveOrderByTermToExprList
Content: <line0>static int resolveOrderByTermToExprList(\n<line1>Parse *pParse,     /* Parsing context for error messages */\n<line2>Select *pSelect,   /* The SELECT statement with the ORDER BY clause */\n<line3>Expr *pE           /* The specific ORDER BY term */\n<line4>){\n<line5>int i;             /* Loop counter */\n<line6>ExprList *pEList;  /* The columns of the result set */\n<line7>NameContext nc;    /* Name context for resolving pE */\n<line8>sqlite3 *db;       /* Database connection */\n<line9>int rc;            /* Return code from subprocedures */\n<line10>u8 savedSuppErr;   /* Saved value of db->suppressErr */\n<line11>assert( sqlite3ExprIsInteger(pE, &i, 0)==0 );\n<line12>pEList = pSelect->pEList;\n<line13>/* Resolve all names in the ORDER BY term expression\n<line14>*/\n<line15>memset(&nc, 0, sizeof(nc));\n<line16>nc.pParse = pParse;\n<line17>nc.pSrcList = pSelect->pSrc;\n<line18>nc.uNC.pEList = pEList;\n<line19>nc.ncFlags = NC_AllowAgg|NC_UEList|NC_NoSelect;\n<line20>nc.nNcErr = 0;\n<line21>db = pParse->db;\n<line22>savedSuppErr = db->suppressErr;\n<line23>db->suppressErr = 1;\n<line24>rc = sqlite3ResolveExprNames(&nc, pE);\n<line25>db->suppressErr = savedSuppErr;\n<line26>if( rc ) return 0;\n<line27>/* Try to match the ORDER BY expression against an expression\n<line28>** in the result set.  Return an 1-based index of the matching\n<line29>** result-set entry.\n<line30>*/\n<line31>for(i=0; i<pEList->nExpr; i++){\n<line32>if( sqlite3ExprCompare(0, pEList->a[i].pExpr, pE, -1)<2 ){\n<line33>return i+1;\n<line34>}\n<line35>}\n<line36>/* If no match, return 0. */\n<line37>return 0;\n<line38>}
----------------------------------------
Function: resolveOutOfRangeError
Content: <line0>static void resolveOutOfRangeError(\n<line1>Parse *pParse,         /* The error context into which to write the error */\n<line2>const char *zType,     /* "ORDER" or "GROUP" */\n<line3>int i,                 /* The index (1-based) of the term out of range */\n<line4>int mx,                /* Largest permissible value of i */\n<line5>Expr *pError           /* Associate the error with the expression */\n<line6>){\n<line7>sqlite3ErrorMsg(pParse,\n<line8>"%r %s BY term out of range - should be "\n<line9>"between 1 and %d", i, zType, mx);\n<line10>sqlite3RecordErrorOffsetOfExpr(pParse->db, pError);\n<line11>}
----------------------------------------
Function: resolveCompoundOrderBy
Content: <line0>static int resolveCompoundOrderBy(\n<line1>Parse *pParse,        /* Parsing context.  Leave error messages here */\n<line2>Select *pSelect       /* The SELECT statement containing the ORDER BY */\n<line3>){\n<line4>int i;\n<line5>ExprList *pOrderBy;\n<line6>ExprList *pEList;\n<line7>sqlite3 *db;\n<line8>int moreToDo = 1;\n<line9>pOrderBy = pSelect->pOrderBy;\n<line10>if( pOrderBy==0 ) return 0;\n<line11>db = pParse->db;\n<line12>if( pOrderBy->nExpr>db->aLimit[SQLITE_LIMIT_COLUMN] ){\n<line13>sqlite3ErrorMsg(pParse, "too many terms in ORDER BY clause");\n<line14>return 1;\n<line15>}\n<line16>for(i=0; i<pOrderBy->nExpr; i++){\n<line17>pOrderBy->a[i].fg.done = 0;\n<line18>}\n<line19>pSelect->pNext = 0;\n<line20>while( pSelect->pPrior ){\n<line21>pSelect->pPrior->pNext = pSelect;\n<line22>pSelect = pSelect->pPrior;\n<line23>}\n<line24>while( pSelect && moreToDo ){\n<line25>struct ExprList_item *pItem;\n<line26>moreToDo = 0;\n<line27>pEList = pSelect->pEList;\n<line28>assert( pEList!=0 );\n<line29>for(i=0, pItem=pOrderBy->a; i<pOrderBy->nExpr; i++, pItem++){\n<line30>int iCol = -1;\n<line31>Expr *pE, *pDup;\n<line32>if( pItem->fg.done ) continue;\n<line33>pE = sqlite3ExprSkipCollateAndLikely(pItem->pExpr);\n<line34>if( NEVER(pE==0) ) continue;\n<line35>if( sqlite3ExprIsInteger(pE, &iCol, 0) ){\n<line36>if( iCol<=0 || iCol>pEList->nExpr ){\n<line37>resolveOutOfRangeError(pParse, "ORDER", i+1, pEList->nExpr, pE);\n<line38>return 1;\n<line39>}\n<line40>}else{\n<line41>iCol = resolveAsName(pParse, pEList, pE);\n<line42>if( iCol==0 ){\n<line43>/* Now test if expression pE matches one of the values returned\n<line44>** by pSelect. In the usual case this is done by duplicating the\n<line45>** expression, resolving any symbols in it, and then comparing\n<line46>** it against each expression returned by the SELECT statement.\n<line47>** Once the comparisons are finished, the duplicate expression\n<line48>** is deleted.\n<line49>**\n<line50>** If this is running as part of an ALTER TABLE operation and\n<line51>** the symbols resolve successfully, also resolve the symbols in the\n<line52>** actual expression. This allows the code in alter.c to modify\n<line53>** column references within the ORDER BY expression as required.  */\n<line54>pDup = sqlite3ExprDup(db, pE, 0);\n<line55>if( !db->mallocFailed ){\n<line56>assert(pDup);\n<line57>iCol = resolveOrderByTermToExprList(pParse, pSelect, pDup);\n<line58>if( IN_RENAME_OBJECT && iCol>0 ){\n<line59>resolveOrderByTermToExprList(pParse, pSelect, pE);\n<line60>}\n<line61>}\n<line62>sqlite3ExprDelete(db, pDup);\n<line63>}\n<line64>}\n<line65>if( iCol>0 ){\n<line66>/* Convert the ORDER BY term into an integer column number iCol,\n<line67>** taking care to preserve the COLLATE clause if it exists. */\n<line68>if( !IN_RENAME_OBJECT ){\n<line69>Expr *pNew = sqlite3Expr(db, TK_INTEGER, 0);\n<line70>if( pNew==0 ) return 1;\n<line71>pNew->flags |= EP_IntValue;\n<line72>pNew->u.iValue = iCol;\n<line73>if( pItem->pExpr==pE ){\n<line74>pItem->pExpr = pNew;\n<line75>}else{\n<line76>Expr *pParent = pItem->pExpr;\n<line77>assert( pParent->op==TK_COLLATE );\n<line78>while( pParent->pLeft->op==TK_COLLATE ) pParent = pParent->pLeft;\n<line79>assert( pParent->pLeft==pE );\n<line80>pParent->pLeft = pNew;\n<line81>}\n<line82>sqlite3ExprDelete(db, pE);\n<line83>pItem->u.x.iOrderByCol = (u16)iCol;\n<line84>}\n<line85>pItem->fg.done = 1;\n<line86>}else{\n<line87>moreToDo = 1;\n<line88>}\n<line89>}\n<line90>pSelect = pSelect->pNext;\n<line91>}\n<line92>for(i=0; i<pOrderBy->nExpr; i++){\n<line93>if( pOrderBy->a[i].fg.done==0 ){\n<line94>sqlite3ErrorMsg(pParse, "%r ORDER BY term does not match any "\n<line95>"column in the result set", i+1);\n<line96>return 1;\n<line97>}\n<line98>}\n<line99>return 0;\n<line100>}
----------------------------------------
Function: resolveRemoveWindowsCb
Content: <line0>static int resolveRemoveWindowsCb(Walker *pWalker, Expr *pExpr){\n<line1>UNUSED_PARAMETER(pWalker);\n<line2>if( ExprHasProperty(pExpr, EP_WinFunc) ){\n<line3>Window *pWin = pExpr->y.pWin;\n<line4>sqlite3WindowUnlinkFromSelect(pWin);\n<line5>}\n<line6>return WRC_Continue;\n<line7>}
----------------------------------------
Function: windowRemoveExprFromSelect
Content: <line0>static void windowRemoveExprFromSelect(Select *pSelect, Expr *pExpr){\n<line1>if( pSelect->pWin ){\n<line2>Walker sWalker;\n<line3>memset(&sWalker, 0, sizeof(Walker));\n<line4>sWalker.xExprCallback = resolveRemoveWindowsCb;\n<line5>sWalker.u.pSelect = pSelect;\n<line6>sqlite3WalkExpr(&sWalker, pExpr);\n<line7>}\n<line8>}
----------------------------------------
Function: resolveOrderGroupBy
Content: <line0>static int resolveOrderGroupBy(\n<line1>NameContext *pNC,     /* The name context of the SELECT statement */\n<line2>Select *pSelect,      /* The SELECT statement holding pOrderBy */\n<line3>ExprList *pOrderBy,   /* An ORDER BY or GROUP BY clause to resolve */\n<line4>const char *zType     /* Either "ORDER" or "GROUP", as appropriate */\n<line5>){\n<line6>int i, j;                      /* Loop counters */\n<line7>int iCol;                      /* Column number */\n<line8>struct ExprList_item *pItem;   /* A term of the ORDER BY clause */\n<line9>Parse *pParse;                 /* Parsing context */\n<line10>int nResult;                   /* Number of terms in the result set */\n<line11>assert( pOrderBy!=0 );\n<line12>nResult = pSelect->pEList->nExpr;\n<line13>pParse = pNC->pParse;\n<line14>for(i=0, pItem=pOrderBy->a; i<pOrderBy->nExpr; i++, pItem++){\n<line15>Expr *pE = pItem->pExpr;\n<line16>Expr *pE2 = sqlite3ExprSkipCollateAndLikely(pE);\n<line17>if( NEVER(pE2==0) ) continue;\n<line18>if( zType[0]!='G' ){\n<line19>iCol = resolveAsName(pParse, pSelect->pEList, pE2);\n<line20>if( iCol>0 ){\n<line21>/* If an AS-name match is found, mark this ORDER BY column as being\n<line22>** a copy of the iCol-th result-set column.  The subsequent call to\n<line23>** sqlite3ResolveOrderGroupBy() will convert the expression to a\n<line24>** copy of the iCol-th result-set expression. */\n<line25>pItem->u.x.iOrderByCol = (u16)iCol;\n<line26>continue;\n<line27>}\n<line28>}\n<line29>if( sqlite3ExprIsInteger(pE2, &iCol, 0) ){\n<line30>/* The ORDER BY term is an integer constant.  Again, set the column\n<line31>** number so that sqlite3ResolveOrderGroupBy() will convert the\n<line32>** order-by term to a copy of the result-set expression */\n<line33>if( iCol<1 || iCol>0xffff ){\n<line34>resolveOutOfRangeError(pParse, zType, i+1, nResult, pE2);\n<line35>return 1;\n<line36>}\n<line37>pItem->u.x.iOrderByCol = (u16)iCol;\n<line38>continue;\n<line39>}\n<line40>/* Otherwise, treat the ORDER BY term as an ordinary expression */\n<line41>pItem->u.x.iOrderByCol = 0;\n<line42>if( sqlite3ResolveExprNames(pNC, pE) ){\n<line43>return 1;\n<line44>}\n<line45>for(j=0; j<pSelect->pEList->nExpr; j++){\n<line46>if( sqlite3ExprCompare(0, pE, pSelect->pEList->a[j].pExpr, -1)==0 ){\n<line47>/* Since this expression is being changed into a reference\n<line48>** to an identical expression in the result set, remove all Window\n<line49>** objects belonging to the expression from the Select.pWin list. */\n<line50>windowRemoveExprFromSelect(pSelect, pE);\n<line51>pItem->u.x.iOrderByCol = j+1;\n<line52>}\n<line53>}\n<line54>}\n<line55>return sqlite3ResolveOrderGroupBy(pParse, pSelect, pOrderBy, zType);\n<line56>}
----------------------------------------
Function: resolveSelectStep
Content: <line0>static int resolveSelectStep(Walker *pWalker, Select *p){\n<line1>NameContext *pOuterNC;  /* Context that contains this SELECT */\n<line2>NameContext sNC;        /* Name context of this SELECT */\n<line3>int isCompound;         /* True if p is a compound select */\n<line4>int nCompound;          /* Number of compound terms processed so far */\n<line5>Parse *pParse;          /* Parsing context */\n<line6>int i;                  /* Loop counter */\n<line7>ExprList *pGroupBy;     /* The GROUP BY clause */\n<line8>Select *pLeftmost;      /* Left-most of SELECT of a compound */\n<line9>sqlite3 *db;            /* Database connection */\n<line10>assert( p!=0 );\n<line11>if( p->selFlags & SF_Resolved ){\n<line12>return WRC_Prune;\n<line13>}\n<line14>pOuterNC = pWalker->u.pNC;\n<line15>pParse = pWalker->pParse;\n<line16>db = pParse->db;\n<line17>/* Normally sqlite3SelectExpand() will be called first and will have\n<line18>** already expanded this SELECT.  However, if this is a subquery within\n<line19>** an expression, sqlite3ResolveExprNames() will be called without a\n<line20>** prior call to sqlite3SelectExpand().  When that happens, let\n<line21>** sqlite3SelectPrep() do all of the processing for this SELECT.\n<line22>** sqlite3SelectPrep() will invoke both sqlite3SelectExpand() and\n<line23>** this routine in the correct order.\n<line24>*/\n<line25>if( (p->selFlags & SF_Expanded)==0 ){\n<line26>sqlite3SelectPrep(pParse, p, pOuterNC);\n<line27>return pParse->nErr ? WRC_Abort : WRC_Prune;\n<line28>}\n<line29>isCompound = p->pPrior!=0;\n<line30>nCompound = 0;\n<line31>pLeftmost = p;\n<line32>while( p ){\n<line33>assert( (p->selFlags & SF_Expanded)!=0 );\n<line34>assert( (p->selFlags & SF_Resolved)==0 );\n<line35>p->selFlags |= SF_Resolved;\n<line36>/* Resolve the expressions in the LIMIT and OFFSET clauses. These\n<line37>** are not allowed to refer to any names, so pass an empty NameContext.\n<line38>*/\n<line39>memset(&sNC, 0, sizeof(sNC));\n<line40>sNC.pParse = pParse;\n<line41>sNC.pWinSelect = p;\n<line42>if( sqlite3ResolveExprNames(&sNC, p->pLimit) ){\n<line43>return WRC_Abort;\n<line44>}\n<line45>/* If the SF_Converted flags is set, then this Select object was\n<line46>** was created by the convertCompoundSelectToSubquery() function.\n<line47>** In this case the ORDER BY clause (p->pOrderBy) should be resolved\n<line48>** as if it were part of the sub-query, not the parent. This block\n<line49>** moves the pOrderBy down to the sub-query. It will be moved back\n<line50>** after the names have been resolved.  */\n<line51>if( p->selFlags & SF_Converted ){\n<line52>Select *pSub;\n<line53>assert( p->pSrc->a[0].fg.isSubquery );\n<line54>assert( p->pSrc->a[0].u4.pSubq!=0 );\n<line55>pSub = p->pSrc->a[0].u4.pSubq->pSelect;\n<line56>assert( pSub!=0 );\n<line57>assert( p->pSrc->nSrc==1 && p->pOrderBy );\n<line58>assert( pSub->pPrior && pSub->pOrderBy==0 );\n<line59>pSub->pOrderBy = p->pOrderBy;\n<line60>p->pOrderBy = 0;\n<line61>}\n<line62>/* Recursively resolve names in all subqueries in the FROM clause\n<line63>*/\n<line64>if( pOuterNC ) pOuterNC->nNestedSelect++;\n<line65>for(i=0; i<p->pSrc->nSrc; i++){\n<line66>SrcItem *pItem = &p->pSrc->a[i];\n<line67>assert( pItem->zName!=0\n<line68>|| pItem->fg.isSubquery );  /* Test of tag-20240424-1*/\n<line69>if( pItem->fg.isSubquery\n<line70>&& (pItem->u4.pSubq->pSelect->selFlags & SF_Resolved)==0\n<line71>){\n<line72>int nRef = pOuterNC ? pOuterNC->nRef : 0;\n<line73>const char *zSavedContext = pParse->zAuthContext;\n<line74>if( pItem->zName ) pParse->zAuthContext = pItem->zName;\n<line75>sqlite3ResolveSelectNames(pParse, pItem->u4.pSubq->pSelect, pOuterNC);\n<line76>pParse->zAuthContext = zSavedContext;\n<line77>if( pParse->nErr ) return WRC_Abort;\n<line78>assert( db->mallocFailed==0 );\n<line79>/* If the number of references to the outer context changed when\n<line80>** expressions in the sub-select were resolved, the sub-select\n<line81>** is correlated. It is not required to check the refcount on any\n<line82>** but the innermost outer context object, as lookupName() increments\n<line83>** the refcount on all contexts between the current one and the\n<line84>** context containing the column when it resolves a name. */\n<line85>if( pOuterNC ){\n<line86>assert( pItem->fg.isCorrelated==0 && pOuterNC->nRef>=nRef );\n<line87>pItem->fg.isCorrelated = (pOuterNC->nRef>nRef);\n<line88>}\n<line89>}\n<line90>}\n<line91>if( pOuterNC && ALWAYS(pOuterNC->nNestedSelect>0) ){\n<line92>pOuterNC->nNestedSelect--;\n<line93>}\n<line94>/* Set up the local name-context to pass to sqlite3ResolveExprNames() to\n<line95>** resolve the result-set expression list.\n<line96>*/\n<line97>sNC.ncFlags = NC_AllowAgg|NC_AllowWin;\n<line98>sNC.pSrcList = p->pSrc;\n<line99>sNC.pNext = pOuterNC;\n<line100>/* Resolve names in the result set. */\n<line101>if( sqlite3ResolveExprListNames(&sNC, p->pEList) ) return WRC_Abort;\n<line102>sNC.ncFlags &= ~NC_AllowWin;\n<line103>/* If there are no aggregate functions in the result-set, and no GROUP BY\n<line104>** expression, do not allow aggregates in any of the other expressions.\n<line105>*/\n<line106>assert( (p->selFlags & SF_Aggregate)==0 );\n<line107>pGroupBy = p->pGroupBy;\n<line108>if( pGroupBy || (sNC.ncFlags & NC_HasAgg)!=0 ){\n<line109>assert( NC_MinMaxAgg==SF_MinMaxAgg );\n<line110>assert( NC_OrderAgg==SF_OrderByReqd );\n<line111>p->selFlags |= SF_Aggregate | (sNC.ncFlags&(NC_MinMaxAgg|NC_OrderAgg));\n<line112>}else{\n<line113>sNC.ncFlags &= ~NC_AllowAgg;\n<line114>}\n<line115>/* Add the output column list to the name-context before parsing the\n<line116>** other expressions in the SELECT statement. This is so that\n<line117>** expressions in the WHERE clause (etc.) can refer to expressions by\n<line118>** aliases in the result set.\n<line119>**\n<line120>** Minor point: If this is the case, then the expression will be\n<line121>** re-evaluated for each reference to it.\n<line122>*/\n<line123>assert( (sNC.ncFlags & (NC_UAggInfo|NC_UUpsert|NC_UBaseReg))==0 );\n<line124>sNC.uNC.pEList = p->pEList;\n<line125>sNC.ncFlags |= NC_UEList;\n<line126>if( p->pHaving ){\n<line127>if( (p->selFlags & SF_Aggregate)==0 ){\n<line128>sqlite3ErrorMsg(pParse, "HAVING clause on a non-aggregate query");\n<line129>return WRC_Abort;\n<line130>}\n<line131>if( sqlite3ResolveExprNames(&sNC, p->pHaving) ) return WRC_Abort;\n<line132>}\n<line133>sNC.ncFlags |= NC_Where;\n<line134>if( sqlite3ResolveExprNames(&sNC, p->pWhere) ) return WRC_Abort;\n<line135>sNC.ncFlags &= ~NC_Where;\n<line136>/* Resolve names in table-valued-function arguments */\n<line137>for(i=0; i<p->pSrc->nSrc; i++){\n<line138>SrcItem *pItem = &p->pSrc->a[i];\n<line139>if( pItem->fg.isTabFunc\n<line140>&& sqlite3ResolveExprListNames(&sNC, pItem->u1.pFuncArg)\n<line141>){\n<line142>return WRC_Abort;\n<line143>}\n<line144>}\n<line145>#ifndef SQLITE_OMIT_WINDOWFUNC\n<line146>if( IN_RENAME_OBJECT ){\n<line147>Window *pWin;\n<line148>for(pWin=p->pWinDefn; pWin; pWin=pWin->pNextWin){\n<line149>if( sqlite3ResolveExprListNames(&sNC, pWin->pOrderBy)\n<line150>|| sqlite3ResolveExprListNames(&sNC, pWin->pPartition)\n<line151>){\n<line152>return WRC_Abort;\n<line153>}\n<line154>}\n<line155>}\n<line156>#endif\n<line157>/* The ORDER BY and GROUP BY clauses may not refer to terms in\n<line158>** outer queries\n<line159>*/\n<line160>sNC.pNext = 0;\n<line161>sNC.ncFlags |= NC_AllowAgg|NC_AllowWin;\n<line162>/* If this is a converted compound query, move the ORDER BY clause from\n<line163>** the sub-query back to the parent query. At this point each term\n<line164>** within the ORDER BY clause has been transformed to an integer value.\n<line165>** These integers will be replaced by copies of the corresponding result\n<line166>** set expressions by the call to resolveOrderGroupBy() below.  */\n<line167>if( p->selFlags & SF_Converted ){\n<line168>Select *pSub;\n<line169>assert( p->pSrc->a[0].fg.isSubquery );\n<line170>pSub = p->pSrc->a[0].u4.pSubq->pSelect;\n<line171>assert( pSub!=0 );\n<line172>p->pOrderBy = pSub->pOrderBy;\n<line173>pSub->pOrderBy = 0;\n<line174>}\n<line175>/* Process the ORDER BY clause for singleton SELECT statements.\n<line176>** The ORDER BY clause for compounds SELECT statements is handled\n<line177>** below, after all of the result-sets for all of the elements of\n<line178>** the compound have been resolved.\n<line179>**\n<line180>** If there is an ORDER BY clause on a term of a compound-select other\n<line181>** than the right-most term, then that is a syntax error.  But the error\n<line182>** is not detected until much later, and so we need to go ahead and\n<line183>** resolve those symbols on the incorrect ORDER BY for consistency.\n<line184>*/\n<line185>if( p->pOrderBy!=0\n<line186>&& isCompound<=nCompound  /* Defer right-most ORDER BY of a compound */\n<line187>&& resolveOrderGroupBy(&sNC, p, p->pOrderBy, "ORDER")\n<line188>){\n<line189>return WRC_Abort;\n<line190>}\n<line191>if( db->mallocFailed ){\n<line192>return WRC_Abort;\n<line193>}\n<line194>sNC.ncFlags &= ~NC_AllowWin;\n<line195>/* Resolve the GROUP BY clause.  At the same time, make sure\n<line196>** the GROUP BY clause does not contain aggregate functions.\n<line197>*/\n<line198>if( pGroupBy ){\n<line199>struct ExprList_item *pItem;\n<line200>if( resolveOrderGroupBy(&sNC, p, pGroupBy, "GROUP") || db->mallocFailed ){\n<line201>return WRC_Abort;\n<line202>}\n<line203>for(i=0, pItem=pGroupBy->a; i<pGroupBy->nExpr; i++, pItem++){\n<line204>if( ExprHasProperty(pItem->pExpr, EP_Agg) ){\n<line205>sqlite3ErrorMsg(pParse, "aggregate functions are not allowed in "\n<line206>"the GROUP BY clause");\n<line207>return WRC_Abort;\n<line208>}\n<line209>}\n<line210>}\n<line211>/* If this is part of a compound SELECT, check that it has the right\n<line212>** number of expressions in the select list. */\n<line213>if( p->pNext && p->pEList->nExpr!=p->pNext->pEList->nExpr ){\n<line214>sqlite3SelectWrongNumTermsError(pParse, p->pNext);\n<line215>return WRC_Abort;\n<line216>}\n<line217>/* Advance to the next term of the compound\n<line218>*/\n<line219>p = p->pPrior;\n<line220>nCompound++;\n<line221>}\n<line222>/* Resolve the ORDER BY on a compound SELECT after all terms of\n<line223>** the compound have been resolved.\n<line224>*/\n<line225>if( isCompound && resolveCompoundOrderBy(pParse, pLeftmost) ){\n<line226>return WRC_Abort;\n<line227>}\n<line228>return WRC_Prune;\n<line229>}
----------------------------------------
Function: comparisonAffinity
Content: <line0>static char comparisonAffinity(const Expr *pExpr){\n<line1>char aff;\n<line2>assert( pExpr->op==TK_EQ || pExpr->op==TK_IN || pExpr->op==TK_LT ||\n<line3>pExpr->op==TK_GT || pExpr->op==TK_GE || pExpr->op==TK_LE ||\n<line4>pExpr->op==TK_NE || pExpr->op==TK_IS || pExpr->op==TK_ISNOT );\n<line5>assert( pExpr->pLeft );\n<line6>aff = sqlite3ExprAffinity(pExpr->pLeft);\n<line7>if( pExpr->pRight ){\n<line8>aff = sqlite3CompareAffinity(pExpr->pRight, aff);\n<line9>}else if( ExprUseXSelect(pExpr) ){\n<line10>aff = sqlite3CompareAffinity(pExpr->x.pSelect->pEList->a[0].pExpr, aff);\n<line11>}else if( aff==0 ){\n<line12>aff = SQLITE_AFF_BLOB;\n<line13>}\n<line14>return aff;\n<line15>}
----------------------------------------
Function: binaryCompareP5
Content: <line0>static u8 binaryCompareP5(\n<line1>const Expr *pExpr1,   /* Left operand */\n<line2>const Expr *pExpr2,   /* Right operand */\n<line3>int jumpIfNull        /* Extra flags added to P5 */\n<line4>){\n<line5>u8 aff = (char)sqlite3ExprAffinity(pExpr2);\n<line6>aff = (u8)sqlite3CompareAffinity(pExpr1, aff) | (u8)jumpIfNull;\n<line7>return aff;\n<line8>}
----------------------------------------
Function: codeCompare
Content: <line0>static int codeCompare(\n<line1>Parse *pParse,    /* The parsing (and code generating) context */\n<line2>Expr *pLeft,      /* The left operand */\n<line3>Expr *pRight,     /* The right operand */\n<line4>int opcode,       /* The comparison opcode */\n<line5>int in1, int in2, /* Register holding operands */\n<line6>int dest,         /* Jump here if true.  */\n<line7>int jumpIfNull,   /* If true, jump if either operand is NULL */\n<line8>int isCommuted    /* The comparison has been commuted */\n<line9>){\n<line10>int p5;\n<line11>int addr;\n<line12>CollSeq *p4;\n<line13>if( pParse->nErr ) return 0;\n<line14>if( isCommuted ){\n<line15>p4 = sqlite3BinaryCompareCollSeq(pParse, pRight, pLeft);\n<line16>}else{\n<line17>p4 = sqlite3BinaryCompareCollSeq(pParse, pLeft, pRight);\n<line18>}\n<line19>p5 = binaryCompareP5(pLeft, pRight, jumpIfNull);\n<line20>addr = sqlite3VdbeAddOp4(pParse->pVdbe, opcode, in2, dest, in1,\n<line21>(void*)p4, P4_COLLSEQ);\n<line22>sqlite3VdbeChangeP5(pParse->pVdbe, (u16)p5);\n<line23>return addr;\n<line24>}
----------------------------------------
Function: exprCodeSubselect
Content: <line0>static int exprCodeSubselect(Parse *pParse, Expr *pExpr){\n<line1>int reg = 0;\n<line2>#ifndef SQLITE_OMIT_SUBQUERY\n<line3>if( pExpr->op==TK_SELECT ){\n<line4>reg = sqlite3CodeSubselect(pParse, pExpr);\n<line5>}\n<line6>#endif\n<line7>return reg;\n<line8>}
----------------------------------------
Function: exprVectorRegister
Content: <line0>static int exprVectorRegister(\n<line1>Parse *pParse,                  /* Parse context */\n<line2>Expr *pVector,                  /* Vector to extract element from */\n<line3>int iField,                     /* Field to extract from pVector */\n<line4>int regSelect,                  /* First in array of registers */\n<line5>Expr **ppExpr,                  /* OUT: Expression element */\n<line6>int *pRegFree                   /* OUT: Temp register to free */\n<line7>){\n<line8>u8 op = pVector->op;\n<line9>assert( op==TK_VECTOR || op==TK_REGISTER || op==TK_SELECT || op==TK_ERROR );\n<line10>if( op==TK_REGISTER ){\n<line11>*ppExpr = sqlite3VectorFieldSubexpr(pVector, iField);\n<line12>return pVector->iTable+iField;\n<line13>}\n<line14>if( op==TK_SELECT ){\n<line15>assert( ExprUseXSelect(pVector) );\n<line16>*ppExpr = pVector->x.pSelect->pEList->a[iField].pExpr;\n<line17>return regSelect+iField;\n<line18>}\n<line19>if( op==TK_VECTOR ){\n<line20>assert( ExprUseXList(pVector) );\n<line21>*ppExpr = pVector->x.pList->a[iField].pExpr;\n<line22>return sqlite3ExprCodeTemp(pParse, *ppExpr, pRegFree);\n<line23>}\n<line24>return 0;\n<line25>}
----------------------------------------
Function: codeVectorCompare
Content: <line0>static void codeVectorCompare(\n<line1>Parse *pParse,        /* Code generator context */\n<line2>Expr *pExpr,          /* The comparison operation */\n<line3>int dest,             /* Write results into this register */\n<line4>u8 op,                /* Comparison operator */\n<line5>u8 p5                 /* SQLITE_NULLEQ or zero */\n<line6>){\n<line7>Vdbe *v = pParse->pVdbe;\n<line8>Expr *pLeft = pExpr->pLeft;\n<line9>Expr *pRight = pExpr->pRight;\n<line10>int nLeft = sqlite3ExprVectorSize(pLeft);\n<line11>int i;\n<line12>int regLeft = 0;\n<line13>int regRight = 0;\n<line14>u8 opx = op;\n<line15>int addrCmp = 0;\n<line16>int addrDone = sqlite3VdbeMakeLabel(pParse);\n<line17>int isCommuted = ExprHasProperty(pExpr,EP_Commuted);\n<line18>assert( !ExprHasVVAProperty(pExpr,EP_Immutable) );\n<line19>if( pParse->nErr ) return;\n<line20>if( nLeft!=sqlite3ExprVectorSize(pRight) ){\n<line21>sqlite3ErrorMsg(pParse, "row value misused");\n<line22>return;\n<line23>}\n<line24>assert( pExpr->op==TK_EQ || pExpr->op==TK_NE\n<line25>|| pExpr->op==TK_IS || pExpr->op==TK_ISNOT\n<line26>|| pExpr->op==TK_LT || pExpr->op==TK_GT\n<line27>|| pExpr->op==TK_LE || pExpr->op==TK_GE\n<line28>);\n<line29>assert( pExpr->op==op || (pExpr->op==TK_IS && op==TK_EQ)\n<line30>|| (pExpr->op==TK_ISNOT && op==TK_NE) );\n<line31>assert( p5==0 || pExpr->op!=op );\n<line32>assert( p5==SQLITE_NULLEQ || pExpr->op==op );\n<line33>if( op==TK_LE ) opx = TK_LT;\n<line34>if( op==TK_GE ) opx = TK_GT;\n<line35>if( op==TK_NE ) opx = TK_EQ;\n<line36>regLeft = exprCodeSubselect(pParse, pLeft);\n<line37>regRight = exprCodeSubselect(pParse, pRight);\n<line38>sqlite3VdbeAddOp2(v, OP_Integer, 1, dest);\n<line39>for(i=0; 1 /*Loop exits by "break"*/; i++){\n<line40>int regFree1 = 0, regFree2 = 0;\n<line41>Expr *pL = 0, *pR = 0;\n<line42>int r1, r2;\n<line43>assert( i>=0 && i<nLeft );\n<line44>if( addrCmp ) sqlite3VdbeJumpHere(v, addrCmp);\n<line45>r1 = exprVectorRegister(pParse, pLeft, i, regLeft, &pL, &regFree1);\n<line46>r2 = exprVectorRegister(pParse, pRight, i, regRight, &pR, &regFree2);\n<line47>addrCmp = sqlite3VdbeCurrentAddr(v);\n<line48>codeCompare(pParse, pL, pR, opx, r1, r2, addrDone, p5, isCommuted);\n<line49>testcase(op==OP_Lt); VdbeCoverageIf(v,op==OP_Lt);\n<line50>testcase(op==OP_Le); VdbeCoverageIf(v,op==OP_Le);\n<line51>testcase(op==OP_Gt); VdbeCoverageIf(v,op==OP_Gt);\n<line52>testcase(op==OP_Ge); VdbeCoverageIf(v,op==OP_Ge);\n<line53>testcase(op==OP_Eq); VdbeCoverageIf(v,op==OP_Eq);\n<line54>testcase(op==OP_Ne); VdbeCoverageIf(v,op==OP_Ne);\n<line55>sqlite3ReleaseTempReg(pParse, regFree1);\n<line56>sqlite3ReleaseTempReg(pParse, regFree2);\n<line57>if( (opx==TK_LT || opx==TK_GT) && i<nLeft-1 ){\n<line58>addrCmp = sqlite3VdbeAddOp0(v, OP_ElseEq);\n<line59>testcase(opx==TK_LT); VdbeCoverageIf(v,opx==TK_LT);\n<line60>testcase(opx==TK_GT); VdbeCoverageIf(v,opx==TK_GT);\n<line61>}\n<line62>if( p5==SQLITE_NULLEQ ){\n<line63>sqlite3VdbeAddOp2(v, OP_Integer, 0, dest);\n<line64>}else{\n<line65>sqlite3VdbeAddOp3(v, OP_ZeroOrNull, r1, dest, r2);\n<line66>}\n<line67>if( i==nLeft-1 ){\n<line68>break;\n<line69>}\n<line70>if( opx==TK_EQ ){\n<line71>sqlite3VdbeAddOp2(v, OP_NotNull, dest, addrDone); VdbeCoverage(v);\n<line72>}else{\n<line73>assert( op==TK_LT || op==TK_GT || op==TK_LE || op==TK_GE );\n<line74>sqlite3VdbeAddOp2(v, OP_Goto, 0, addrDone);\n<line75>if( i==nLeft-2 ) opx = op;\n<line76>}\n<line77>}\n<line78>sqlite3VdbeJumpHere(v, addrCmp);\n<line79>sqlite3VdbeResolveLabel(v, addrDone);\n<line80>if( op==TK_NE ){\n<line81>sqlite3VdbeAddOp2(v, OP_Not, dest, dest);\n<line82>}\n<line83>}
----------------------------------------
Function: heightOfExpr
Content: <line0>static void heightOfExpr(const Expr *p, int *pnHeight){\n<line1>if( p ){\n<line2>if( p->nHeight>*pnHeight ){\n<line3>*pnHeight = p->nHeight;\n<line4>}\n<line5>}\n<line6>}
----------------------------------------
Function: heightOfExprList
Content: <line0>static void heightOfExprList(const ExprList *p, int *pnHeight){\n<line1>if( p ){\n<line2>int i;\n<line3>for(i=0; i<p->nExpr; i++){\n<line4>heightOfExpr(p->a[i].pExpr, pnHeight);\n<line5>}\n<line6>}\n<line7>}
----------------------------------------
Function: heightOfSelect
Content: <line0>static void heightOfSelect(const Select *pSelect, int *pnHeight){\n<line1>const Select *p;\n<line2>for(p=pSelect; p; p=p->pPrior){\n<line3>heightOfExpr(p->pWhere, pnHeight);\n<line4>heightOfExpr(p->pHaving, pnHeight);\n<line5>heightOfExpr(p->pLimit, pnHeight);\n<line6>heightOfExprList(p->pEList, pnHeight);\n<line7>heightOfExprList(p->pGroupBy, pnHeight);\n<line8>heightOfExprList(p->pOrderBy, pnHeight);\n<line9>}\n<line10>}
----------------------------------------
Function: exprSetHeight
Content: <line0>static void exprSetHeight(Expr *p){\n<line1>int nHeight = p->pLeft ? p->pLeft->nHeight : 0;\n<line2>if( NEVER(p->pRight) && p->pRight->nHeight>nHeight ){\n<line3>nHeight = p->pRight->nHeight;\n<line4>}\n<line5>if( ExprUseXSelect(p) ){\n<line6>heightOfSelect(p->x.pSelect, &nHeight);\n<line7>}else if( p->x.pList ){\n<line8>heightOfExprList(p->x.pList, &nHeight);\n<line9>p->flags |= EP_Propagate & sqlite3ExprListFlags(p->x.pList);\n<line10>}\n<line11>p->nHeight = nHeight + 1;\n<line12>}
----------------------------------------
Function: sqlite3ExprDeleteNN
Content: <line0>static SQLITE_NOINLINE void sqlite3ExprDeleteNN(sqlite3 *db, Expr *p){\n<line1>assert( p!=0 );\n<line2>assert( db!=0 );\n<line3>exprDeleteRestart:\n<line4>assert( !ExprUseUValue(p) || p->u.iValue>=0 );\n<line5>assert( !ExprUseYWin(p) || !ExprUseYSub(p) );\n<line6>assert( !ExprUseYWin(p) || p->y.pWin!=0 || db->mallocFailed );\n<line7>assert( p->op!=TK_FUNCTION || !ExprUseYSub(p) );\n<line8>#ifdef SQLITE_DEBUG\n<line9>if( ExprHasProperty(p, EP_Leaf) && !ExprHasProperty(p, EP_TokenOnly) ){\n<line10>assert( p->pLeft==0 );\n<line11>assert( p->pRight==0 );\n<line12>assert( !ExprUseXSelect(p) || p->x.pSelect==0 );\n<line13>assert( !ExprUseXList(p) || p->x.pList==0 );\n<line14>}\n<line15>#endif\n<line16>if( !ExprHasProperty(p, (EP_TokenOnly|EP_Leaf)) ){\n<line17>/* The Expr.x union is never used at the same time as Expr.pRight */\n<line18>assert( (ExprUseXList(p) && p->x.pList==0) || p->pRight==0 );\n<line19>if( p->pRight ){\n<line20>assert( !ExprHasProperty(p, EP_WinFunc) );\n<line21>sqlite3ExprDeleteNN(db, p->pRight);\n<line22>}else if( ExprUseXSelect(p) ){\n<line23>assert( !ExprHasProperty(p, EP_WinFunc) );\n<line24>sqlite3SelectDelete(db, p->x.pSelect);\n<line25>}else{\n<line26>sqlite3ExprListDelete(db, p->x.pList);\n<line27>#ifndef SQLITE_OMIT_WINDOWFUNC\n<line28>if( ExprHasProperty(p, EP_WinFunc) ){\n<line29>sqlite3WindowDelete(db, p->y.pWin);\n<line30>}\n<line31>#endif\n<line32>}\n<line33>if( p->pLeft && p->op!=TK_SELECT_COLUMN ){\n<line34>Expr *pLeft = p->pLeft;\n<line35>if( !ExprHasProperty(p, EP_Static)\n<line36>&& !ExprHasProperty(pLeft, EP_Static)\n<line37>){\n<line38>/* Avoid unnecessary recursion on unary operators */\n<line39>sqlite3DbNNFreeNN(db, p);\n<line40>p = pLeft;\n<line41>goto exprDeleteRestart;\n<line42>}else{\n<line43>sqlite3ExprDeleteNN(db, pLeft);\n<line44>}\n<line45>}\n<line46>}\n<line47>if( !ExprHasProperty(p, EP_Static) ){\n<line48>sqlite3DbNNFreeNN(db, p);\n<line49>}\n<line50>}
----------------------------------------
Function: exprStructSize
Content: <line0>static int exprStructSize(const Expr *p){\n<line1>if( ExprHasProperty(p, EP_TokenOnly) ) return EXPR_TOKENONLYSIZE;\n<line2>if( ExprHasProperty(p, EP_Reduced) ) return EXPR_REDUCEDSIZE;\n<line3>return EXPR_FULLSIZE;\n<line4>}
----------------------------------------
Function: dupedExprStructSize
Content: <line0>static int dupedExprStructSize(const Expr *p, int flags){\n<line1>int nSize;\n<line2>assert( flags==EXPRDUP_REDUCE || flags==0 ); /* Only one flag value allowed */\n<line3>assert( EXPR_FULLSIZE<=0xfff );\n<line4>assert( (0xfff & (EP_Reduced|EP_TokenOnly))==0 );\n<line5>if( 0==flags || ExprHasProperty(p, EP_FullSize) ){\n<line6>nSize = EXPR_FULLSIZE;\n<line7>}else{\n<line8>assert( !ExprHasProperty(p, EP_TokenOnly|EP_Reduced) );\n<line9>assert( !ExprHasProperty(p, EP_OuterON) );\n<line10>assert( !ExprHasVVAProperty(p, EP_NoReduce) );\n<line11>if( p->pLeft || p->x.pList ){\n<line12>nSize = EXPR_REDUCEDSIZE | EP_Reduced;\n<line13>}else{\n<line14>assert( p->pRight==0 );\n<line15>nSize = EXPR_TOKENONLYSIZE | EP_TokenOnly;\n<line16>}\n<line17>}\n<line18>return nSize;\n<line19>}
----------------------------------------
Function: dupedExprNodeSize
Content: <line0>static int dupedExprNodeSize(const Expr *p, int flags){\n<line1>int nByte = dupedExprStructSize(p, flags) & 0xfff;\n<line2>if( !ExprHasProperty(p, EP_IntValue) && p->u.zToken ){\n<line3>nByte += sqlite3Strlen30NN(p->u.zToken)+1;\n<line4>}\n<line5>return ROUND8(nByte);\n<line6>}
----------------------------------------
Function: dupedExprSize
Content: <line0>static int dupedExprSize(const Expr *p){\n<line1>int nByte;\n<line2>assert( p!=0 );\n<line3>nByte = dupedExprNodeSize(p, EXPRDUP_REDUCE);\n<line4>if( p->pLeft ) nByte += dupedExprSize(p->pLeft);\n<line5>if( p->pRight ) nByte += dupedExprSize(p->pRight);\n<line6>assert( nByte==ROUND8(nByte) );\n<line7>return nByte;\n<line8>}
----------------------------------------
Function: exprDup
Content: <line0>static Expr *exprDup(\n<line1>sqlite3 *db,          /* Database connection (for memory allocation) */\n<line2>const Expr *p,        /* Expr tree to be duplicated */\n<line3>int dupFlags,         /* EXPRDUP_REDUCE for compression.  0 if not */\n<line4>EdupBuf *pEdupBuf     /* Preallocated storage space, or NULL */\n<line5>){\n<line6>Expr *pNew;           /* Value to return */\n<line7>EdupBuf sEdupBuf;     /* Memory space from which to build Expr object */\n<line8>u32 staticFlag;       /* EP_Static if space not obtained from malloc */\n<line9>int nToken = -1;       /* Space needed for p->u.zToken.  -1 means unknown */\n<line10>assert( db!=0 );\n<line11>assert( p );\n<line12>assert( dupFlags==0 || dupFlags==EXPRDUP_REDUCE );\n<line13>assert( pEdupBuf==0 || dupFlags==EXPRDUP_REDUCE );\n<line14>/* Figure out where to write the new Expr structure. */\n<line15>if( pEdupBuf ){\n<line16>sEdupBuf.zAlloc = pEdupBuf->zAlloc;\n<line17>#ifdef SQLITE_DEBUG\n<line18>sEdupBuf.zEnd = pEdupBuf->zEnd;\n<line19>#endif\n<line20>staticFlag = EP_Static;\n<line21>assert( sEdupBuf.zAlloc!=0 );\n<line22>assert( dupFlags==EXPRDUP_REDUCE );\n<line23>}else{\n<line24>int nAlloc;\n<line25>if( dupFlags ){\n<line26>nAlloc = dupedExprSize(p);\n<line27>}else if( !ExprHasProperty(p, EP_IntValue) && p->u.zToken ){\n<line28>nToken = sqlite3Strlen30NN(p->u.zToken)+1;\n<line29>nAlloc = ROUND8(EXPR_FULLSIZE + nToken);\n<line30>}else{\n<line31>nToken = 0;\n<line32>nAlloc = ROUND8(EXPR_FULLSIZE);\n<line33>}\n<line34>assert( nAlloc==ROUND8(nAlloc) );\n<line35>sEdupBuf.zAlloc = sqlite3DbMallocRawNN(db, nAlloc);\n<line36>#ifdef SQLITE_DEBUG\n<line37>sEdupBuf.zEnd = sEdupBuf.zAlloc ? sEdupBuf.zAlloc+nAlloc : 0;\n<line38>#endif\n<line39>staticFlag = 0;\n<line40>}\n<line41>pNew = (Expr *)sEdupBuf.zAlloc;\n<line42>assert( EIGHT_BYTE_ALIGNMENT(pNew) );\n<line43>if( pNew ){\n<line44>/* Set nNewSize to the size allocated for the structure pointed to\n<line45>** by pNew. This is either EXPR_FULLSIZE, EXPR_REDUCEDSIZE or\n<line46>** EXPR_TOKENONLYSIZE. nToken is set to the number of bytes consumed\n<line47>** by the copy of the p->u.zToken string (if any).\n<line48>*/\n<line49>const unsigned nStructSize = dupedExprStructSize(p, dupFlags);\n<line50>int nNewSize = nStructSize & 0xfff;\n<line51>if( nToken<0 ){\n<line52>if( !ExprHasProperty(p, EP_IntValue) && p->u.zToken ){\n<line53>nToken = sqlite3Strlen30(p->u.zToken) + 1;\n<line54>}else{\n<line55>nToken = 0;\n<line56>}\n<line57>}\n<line58>if( dupFlags ){\n<line59>assert( (int)(sEdupBuf.zEnd - sEdupBuf.zAlloc) >= nNewSize+nToken );\n<line60>assert( ExprHasProperty(p, EP_Reduced)==0 );\n<line61>memcpy(sEdupBuf.zAlloc, p, nNewSize);\n<line62>}else{\n<line63>u32 nSize = (u32)exprStructSize(p);\n<line64>assert( (int)(sEdupBuf.zEnd - sEdupBuf.zAlloc) >=\n<line65>(int)EXPR_FULLSIZE+nToken );\n<line66>memcpy(sEdupBuf.zAlloc, p, nSize);\n<line67>if( nSize<EXPR_FULLSIZE ){\n<line68>memset(&sEdupBuf.zAlloc[nSize], 0, EXPR_FULLSIZE-nSize);\n<line69>}\n<line70>nNewSize = EXPR_FULLSIZE;\n<line71>}\n<line72>/* Set the EP_Reduced, EP_TokenOnly, and EP_Static flags appropriately. */\n<line73>pNew->flags &= ~(EP_Reduced|EP_TokenOnly|EP_Static);\n<line74>pNew->flags |= nStructSize & (EP_Reduced|EP_TokenOnly);\n<line75>pNew->flags |= staticFlag;\n<line76>ExprClearVVAProperties(pNew);\n<line77>if( dupFlags ){\n<line78>ExprSetVVAProperty(pNew, EP_Immutable);\n<line79>}\n<line80>/* Copy the p->u.zToken string, if any. */\n<line81>assert( nToken>=0 );\n<line82>if( nToken>0 ){\n<line83>char *zToken = pNew->u.zToken = (char*)&sEdupBuf.zAlloc[nNewSize];\n<line84>memcpy(zToken, p->u.zToken, nToken);\n<line85>nNewSize += nToken;\n<line86>}\n<line87>sEdupBuf.zAlloc += ROUND8(nNewSize);\n<line88>if( ((p->flags|pNew->flags)&(EP_TokenOnly|EP_Leaf))==0 ){\n<line89>/* Fill in the pNew->x.pSelect or pNew->x.pList member. */\n<line90>if( ExprUseXSelect(p) ){\n<line91>pNew->x.pSelect = sqlite3SelectDup(db, p->x.pSelect, dupFlags);\n<line92>}else{\n<line93>pNew->x.pList = sqlite3ExprListDup(db, p->x.pList,\n<line94>p->op!=TK_ORDER ? dupFlags : 0);\n<line95>}\n<line96>#ifndef SQLITE_OMIT_WINDOWFUNC\n<line97>if( ExprHasProperty(p, EP_WinFunc) ){\n<line98>pNew->y.pWin = sqlite3WindowDup(db, pNew, p->y.pWin);\n<line99>assert( ExprHasProperty(pNew, EP_WinFunc) );\n<line100>}\n<line101>#endif /* SQLITE_OMIT_WINDOWFUNC */\n<line102>/* Fill in pNew->pLeft and pNew->pRight. */\n<line103>if( dupFlags ){\n<line104>if( p->op==TK_SELECT_COLUMN ){\n<line105>pNew->pLeft = p->pLeft;\n<line106>assert( p->pRight==0\n<line107>|| p->pRight==p->pLeft\n<line108>|| ExprHasProperty(p->pLeft, EP_Subquery) );\n<line109>}else{\n<line110>pNew->pLeft = p->pLeft ?\n<line111>exprDup(db, p->pLeft, EXPRDUP_REDUCE, &sEdupBuf) : 0;\n<line112>}\n<line113>pNew->pRight = p->pRight ?\n<line114>exprDup(db, p->pRight, EXPRDUP_REDUCE, &sEdupBuf) : 0;\n<line115>}else{\n<line116>if( p->op==TK_SELECT_COLUMN ){\n<line117>pNew->pLeft = p->pLeft;\n<line118>assert( p->pRight==0\n<line119>|| p->pRight==p->pLeft\n<line120>|| ExprHasProperty(p->pLeft, EP_Subquery) );\n<line121>}else{\n<line122>pNew->pLeft = sqlite3ExprDup(db, p->pLeft, 0);\n<line123>}\n<line124>pNew->pRight = sqlite3ExprDup(db, p->pRight, 0);\n<line125>}\n<line126>}\n<line127>}\n<line128>if( pEdupBuf ) memcpy(pEdupBuf, &sEdupBuf, sizeof(sEdupBuf));\n<line129>assert( sEdupBuf.zAlloc <= sEdupBuf.zEnd );\n<line130>return pNew;\n<line131>}
----------------------------------------
Function: gatherSelectWindowsCallback
Content: <line0>static int gatherSelectWindowsCallback(Walker *pWalker, Expr *pExpr){\n<line1>if( pExpr->op==TK_FUNCTION && ExprHasProperty(pExpr, EP_WinFunc) ){\n<line2>Select *pSelect = pWalker->u.pSelect;\n<line3>Window *pWin = pExpr->y.pWin;\n<line4>assert( pWin );\n<line5>assert( IsWindowFunc(pExpr) );\n<line6>assert( pWin->ppThis==0 );\n<line7>sqlite3WindowLink(pSelect, pWin);\n<line8>}\n<line9>return WRC_Continue;\n<line10>}
----------------------------------------
Function: gatherSelectWindowsSelectCallback
Content: <line0>static int gatherSelectWindowsSelectCallback(Walker *pWalker, Select *p){\n<line1>return p==pWalker->u.pSelect ? WRC_Continue : WRC_Prune;\n<line2>}
----------------------------------------
Function: gatherSelectWindows
Content: <line0>static void gatherSelectWindows(Select *p){\n<line1>Walker w;\n<line2>w.xExprCallback = gatherSelectWindowsCallback;\n<line3>w.xSelectCallback = gatherSelectWindowsSelectCallback;\n<line4>w.xSelectCallback2 = 0;\n<line5>w.pParse = 0;\n<line6>w.u.pSelect = p;\n<line7>sqlite3WalkSelect(&w, p);\n<line8>}
----------------------------------------
Function: exprListDeleteNN
Content: <line0>static SQLITE_NOINLINE void exprListDeleteNN(sqlite3 *db, ExprList *pList){\n<line1>int i = pList->nExpr;\n<line2>struct ExprList_item *pItem =  pList->a;\n<line3>assert( pList->nExpr>0 );\n<line4>assert( db!=0 );\n<line5>do{\n<line6>sqlite3ExprDelete(db, pItem->pExpr);\n<line7>if( pItem->zEName ) sqlite3DbNNFreeNN(db, pItem->zEName);\n<line8>pItem++;\n<line9>}while( --i>0 );\n<line10>sqlite3DbNNFreeNN(db, pList);\n<line11>}
----------------------------------------
Function: exprEvalRhsFirst
Content: <line0>static int exprEvalRhsFirst(Expr *pExpr){\n<line1>if( ExprHasProperty(pExpr->pLeft, EP_Subquery)\n<line2>&& !ExprHasProperty(pExpr->pRight, EP_Subquery)\n<line3>){\n<line4>return 1;\n<line5>}else{\n<line6>return 0;\n<line7>}\n<line8>}
----------------------------------------
Function: exprComputeOperands
Content: <line0>static int exprComputeOperands(\n<line1>Parse *pParse,     /* Parsing context */\n<line2>Expr *pExpr,       /* The comparison expression */\n<line3>int *pR1,          /* OUT: Register holding the left operand */\n<line4>int *pR2,          /* OUT: Register holding the right operand */\n<line5>int *pFree1,       /* OUT: Temp register to free if not zero */\n<line6>int *pFree2        /* OUT: Another temp register to free if not zero */\n<line7>){\n<line8>int addrIsNull;\n<line9>int r1, r2;\n<line10>Vdbe *v = pParse->pVdbe;\n<line11>assert( v!=0 );\n<line12>/*\n<line13>** If the left operand contains a (possibly expensive) subquery and the\n<line14>** right operand does not and the right operation might be NULL,\n<line15>** then compute the right operand first and do an IsNull jump if the\n<line16>** right operand evalutes to NULL.\n<line17>*/\n<line18>if( exprEvalRhsFirst(pExpr) && sqlite3ExprCanBeNull(pExpr->pRight) ){\n<line19>r2 = sqlite3ExprCodeTemp(pParse, pExpr->pRight, pFree2);\n<line20>addrIsNull = sqlite3VdbeAddOp1(v, OP_IsNull, r2);\n<line21>VdbeComment((v, "skip left operand"));\n<line22>VdbeCoverage(v);\n<line23>}else{\n<line24>r2 = 0; /* Silence a false-positive uninit-var warning in MSVC */\n<line25>addrIsNull = 0;\n<line26>}\n<line27>r1 = sqlite3ExprCodeTemp(pParse, pExpr->pLeft, pFree1);\n<line28>if( addrIsNull==0 ){\n<line29>/*\n<line30>** If the right operand contains a subquery and the left operand does not\n<line31>** and the left operand might be NULL, then do an IsNull check\n<line32>** check on the left operand before computing the right operand.\n<line33>*/\n<line34>if( ExprHasProperty(pExpr->pRight, EP_Subquery)\n<line35>&& sqlite3ExprCanBeNull(pExpr->pLeft)\n<line36>){\n<line37>addrIsNull = sqlite3VdbeAddOp1(v, OP_IsNull, r1);\n<line38>VdbeComment((v, "skip right operand"));\n<line39>VdbeCoverage(v);\n<line40>}\n<line41>r2 = sqlite3ExprCodeTemp(pParse, pExpr->pRight, pFree2);\n<line42>}\n<line43>*pR1 = r1;\n<line44>*pR2 = r2;\n<line45>return addrIsNull;\n<line46>}
----------------------------------------
Function: exprNodeIsConstantFunction
Content: <line0>static SQLITE_NOINLINE int exprNodeIsConstantFunction(\n<line1>Walker *pWalker,\n<line2>Expr *pExpr\n<line3>){\n<line4>int n;             /* Number of arguments */\n<line5>ExprList *pList;   /* List of arguments */\n<line6>FuncDef *pDef;     /* The function */\n<line7>sqlite3 *db;       /* The database */\n<line8>assert( pExpr->op==TK_FUNCTION );\n<line9>if( ExprHasProperty(pExpr, EP_TokenOnly)\n<line10>|| (pList = pExpr->x.pList)==0\n<line11>){;\n<line12>n = 0;\n<line13>}else{\n<line14>n = pList->nExpr;\n<line15>sqlite3WalkExprList(pWalker, pList);\n<line16>if( pWalker->eCode==0 ) return WRC_Abort;\n<line17>}\n<line18>db = pWalker->pParse->db;\n<line19>pDef = sqlite3FindFunction(db, pExpr->u.zToken, n, ENC(db), 0);\n<line20>if( pDef==0\n<line21>|| pDef->xFinalize!=0\n<line22>|| (pDef->funcFlags & (SQLITE_FUNC_CONSTANT|SQLITE_FUNC_SLOCHNG))==0\n<line23>|| ExprHasProperty(pExpr, EP_WinFunc)\n<line24>){\n<line25>pWalker->eCode = 0;\n<line26>return WRC_Abort;\n<line27>}\n<line28>return WRC_Prune;\n<line29>}
----------------------------------------
Function: exprNodeIsConstant
Content: <line0>static int exprNodeIsConstant(Walker *pWalker, Expr *pExpr){\n<line1>assert( pWalker->eCode>0 );\n<line2>/* If pWalker->eCode is 2 then any term of the expression that comes from\n<line3>** the ON or USING clauses of an outer join disqualifies the expression\n<line4>** from being considered constant. */\n<line5>if( pWalker->eCode==2 && ExprHasProperty(pExpr, EP_OuterON) ){\n<line6>pWalker->eCode = 0;\n<line7>return WRC_Abort;\n<line8>}\n<line9>switch( pExpr->op ){\n<line10>/* Consider functions to be constant if all their arguments are constant\n<line11>** and either pWalker->eCode==4 or 5 or the function has the\n<line12>** SQLITE_FUNC_CONST flag. */\n<line13>case TK_FUNCTION:\n<line14>if( (pWalker->eCode>=4 || ExprHasProperty(pExpr,EP_ConstFunc))\n<line15>&& !ExprHasProperty(pExpr, EP_WinFunc)\n<line16>){\n<line17>if( pWalker->eCode==5 ) ExprSetProperty(pExpr, EP_FromDDL);\n<line18>return WRC_Continue;\n<line19>}else if( pWalker->pParse ){\n<line20>return exprNodeIsConstantFunction(pWalker, pExpr);\n<line21>}else{\n<line22>pWalker->eCode = 0;\n<line23>return WRC_Abort;\n<line24>}\n<line25>case TK_ID:\n<line26>/* Convert "true" or "false" in a DEFAULT clause into the\n<line27>** appropriate TK_TRUEFALSE operator */\n<line28>if( sqlite3ExprIdToTrueFalse(pExpr) ){\n<line29>return WRC_Prune;\n<line30>}\n<line31>/* no break */ deliberate_fall_through\n<line32>case TK_COLUMN:\n<line33>case TK_AGG_FUNCTION:\n<line34>case TK_AGG_COLUMN:\n<line35>testcase( pExpr->op==TK_ID );\n<line36>testcase( pExpr->op==TK_COLUMN );\n<line37>testcase( pExpr->op==TK_AGG_FUNCTION );\n<line38>testcase( pExpr->op==TK_AGG_COLUMN );\n<line39>if( ExprHasProperty(pExpr, EP_FixedCol) && pWalker->eCode!=2 ){\n<line40>return WRC_Continue;\n<line41>}\n<line42>if( pWalker->eCode==3 && pExpr->iTable==pWalker->u.iCur ){\n<line43>return WRC_Continue;\n<line44>}\n<line45>/* no break */ deliberate_fall_through\n<line46>case TK_IF_NULL_ROW:\n<line47>case TK_REGISTER:\n<line48>case TK_DOT:\n<line49>case TK_RAISE:\n<line50>testcase( pExpr->op==TK_REGISTER );\n<line51>testcase( pExpr->op==TK_IF_NULL_ROW );\n<line52>testcase( pExpr->op==TK_DOT );\n<line53>testcase( pExpr->op==TK_RAISE );\n<line54>pWalker->eCode = 0;\n<line55>return WRC_Abort;\n<line56>case TK_VARIABLE:\n<line57>if( pWalker->eCode==5 ){\n<line58>/* Silently convert bound parameters that appear inside of CREATE\n<line59>** statements into a NULL when parsing the CREATE statement text out\n<line60>** of the sqlite_schema table */\n<line61>pExpr->op = TK_NULL;\n<line62>}else if( pWalker->eCode==4 ){\n<line63>/* A bound parameter in a CREATE statement that originates from\n<line64>** sqlite3_prepare() causes an error */\n<line65>pWalker->eCode = 0;\n<line66>return WRC_Abort;\n<line67>}\n<line68>/* no break */ deliberate_fall_through\n<line69>default:\n<line70>testcase( pExpr->op==TK_SELECT ); /* sqlite3SelectWalkFail() disallows */\n<line71>testcase( pExpr->op==TK_EXISTS ); /* sqlite3SelectWalkFail() disallows */\n<line72>return WRC_Continue;\n<line73>}\n<line74>}
----------------------------------------
Function: exprIsConst
Content: <line0>static int exprIsConst(Parse *pParse, Expr *p, int initFlag){\n<line1>Walker w;\n<line2>w.eCode = initFlag;\n<line3>w.pParse = pParse;\n<line4>w.xExprCallback = exprNodeIsConstant;\n<line5>w.xSelectCallback = sqlite3SelectWalkFail;\n<line6>#ifdef SQLITE_DEBUG\n<line7>w.xSelectCallback2 = sqlite3SelectWalkAssert2;\n<line8>#endif\n<line9>sqlite3WalkExpr(&w, p);\n<line10>return w.eCode;\n<line11>}
----------------------------------------
Function: sqlite3ExprIsConstantNotJoin
Content: <line0>static int sqlite3ExprIsConstantNotJoin(Parse *pParse, Expr *p){\n<line1>return exprIsConst(pParse, p, 2);\n<line2>}
----------------------------------------
Function: exprSelectWalkTableConstant
Content: <line0>static int exprSelectWalkTableConstant(Walker *pWalker, Select *pSelect){\n<line1>assert( pSelect!=0 );\n<line2>assert( pWalker->eCode==3 || pWalker->eCode==0 );\n<line3>if( (pSelect->selFlags & SF_Correlated)!=0 ){\n<line4>pWalker->eCode = 0;\n<line5>return WRC_Abort;\n<line6>}\n<line7>return WRC_Prune;\n<line8>}
----------------------------------------
Function: sqlite3ExprIsTableConstant
Content: <line0>static int sqlite3ExprIsTableConstant(Expr *p, int iCur, int bAllowSubq){\n<line1>Walker w;\n<line2>w.eCode = 3;\n<line3>w.pParse = 0;\n<line4>w.xExprCallback = exprNodeIsConstant;\n<line5>if( bAllowSubq ){\n<line6>w.xSelectCallback = exprSelectWalkTableConstant;\n<line7>}else{\n<line8>w.xSelectCallback = sqlite3SelectWalkFail;\n<line9>#ifdef SQLITE_DEBUG\n<line10>w.xSelectCallback2 = sqlite3SelectWalkAssert2;\n<line11>#endif\n<line12>}\n<line13>w.u.iCur = iCur;\n<line14>sqlite3WalkExpr(&w, p);\n<line15>return w.eCode;\n<line16>}
----------------------------------------
Function: exprNodeIsConstantOrGroupBy
Content: <line0>static int exprNodeIsConstantOrGroupBy(Walker *pWalker, Expr *pExpr){\n<line1>ExprList *pGroupBy = pWalker->u.pGroupBy;\n<line2>int i;\n<line3>/* Check if pExpr is identical to any GROUP BY term. If so, consider\n<line4>** it constant.  */\n<line5>for(i=0; i<pGroupBy->nExpr; i++){\n<line6>Expr *p = pGroupBy->a[i].pExpr;\n<line7>if( sqlite3ExprCompare(0, pExpr, p, -1)<2 ){\n<line8>CollSeq *pColl = sqlite3ExprNNCollSeq(pWalker->pParse, p);\n<line9>if( sqlite3IsBinary(pColl) ){\n<line10>return WRC_Prune;\n<line11>}\n<line12>}\n<line13>}\n<line14>/* Check if pExpr is a sub-select. If so, consider it variable. */\n<line15>if( ExprUseXSelect(pExpr) ){\n<line16>pWalker->eCode = 0;\n<line17>return WRC_Abort;\n<line18>}\n<line19>return exprNodeIsConstant(pWalker, pExpr);\n<line20>}
----------------------------------------
Function: isCandidateForInOpt
Content: <line0>static Select *isCandidateForInOpt(const Expr *pX){\n<line1>Select *p;\n<line2>SrcList *pSrc;\n<line3>ExprList *pEList;\n<line4>Table *pTab;\n<line5>int i;\n<line6>if( !ExprUseXSelect(pX) ) return 0;                 /* Not a subquery */\n<line7>if( ExprHasProperty(pX, EP_VarSelect)  ) return 0;  /* Correlated subq */\n<line8>p = pX->x.pSelect;\n<line9>if( p->pPrior ) return 0;              /* Not a compound SELECT */\n<line10>if( p->selFlags & (SF_Distinct|SF_Aggregate) ){\n<line11>testcase( (p->selFlags & (SF_Distinct|SF_Aggregate))==SF_Distinct );\n<line12>testcase( (p->selFlags & (SF_Distinct|SF_Aggregate))==SF_Aggregate );\n<line13>return 0; /* No DISTINCT keyword and no aggregate functions */\n<line14>}\n<line15>assert( p->pGroupBy==0 );              /* Has no GROUP BY clause */\n<line16>if( p->pLimit ) return 0;              /* Has no LIMIT clause */\n<line17>if( p->pWhere ) return 0;              /* Has no WHERE clause */\n<line18>pSrc = p->pSrc;\n<line19>assert( pSrc!=0 );\n<line20>if( pSrc->nSrc!=1 ) return 0;          /* Single term in FROM clause */\n<line21>if( pSrc->a[0].fg.isSubquery) return 0;/* FROM is not a subquery or view */\n<line22>pTab = pSrc->a[0].pSTab;\n<line23>assert( pTab!=0 );\n<line24>assert( !IsView(pTab)  );              /* FROM clause is not a view */\n<line25>if( IsVirtual(pTab) ) return 0;        /* FROM clause not a virtual table */\n<line26>pEList = p->pEList;\n<line27>assert( pEList!=0 );\n<line28>/* All SELECT results must be columns. */\n<line29>for(i=0; i<pEList->nExpr; i++){\n<line30>Expr *pRes = pEList->a[i].pExpr;\n<line31>if( pRes->op!=TK_COLUMN ) return 0;\n<line32>assert( pRes->iTable==pSrc->a[0].iCursor );  /* Not a correlated subquery */\n<line33>}\n<line34>return p;\n<line35>}
----------------------------------------
Function: sqlite3SetHasNullFlag
Content: <line0>static void sqlite3SetHasNullFlag(Vdbe *v, int iCur, int regHasNull){\n<line1>int addr1;\n<line2>sqlite3VdbeAddOp2(v, OP_Integer, 0, regHasNull);\n<line3>addr1 = sqlite3VdbeAddOp1(v, OP_Rewind, iCur); VdbeCoverage(v);\n<line4>sqlite3VdbeAddOp3(v, OP_Column, iCur, 0, regHasNull);\n<line5>sqlite3VdbeChangeP5(v, OPFLAG_TYPEOFARG);\n<line6>VdbeComment((v, "first_entry_in(%d)", iCur));\n<line7>sqlite3VdbeJumpHere(v, addr1);\n<line8>}
----------------------------------------
Function: sqlite3InRhsIsConstant
Content: <line0>static int sqlite3InRhsIsConstant(Parse *pParse, Expr *pIn){\n<line1>Expr *pLHS;\n<line2>int res;\n<line3>assert( !ExprHasProperty(pIn, EP_xIsSelect) );\n<line4>pLHS = pIn->pLeft;\n<line5>pIn->pLeft = 0;\n<line6>res = sqlite3ExprIsConstant(pParse, pIn);\n<line7>pIn->pLeft = pLHS;\n<line8>return res;\n<line9>}
----------------------------------------
Function: exprINAffinity
Content: <line0>static char *exprINAffinity(Parse *pParse, const Expr *pExpr){\n<line1>Expr *pLeft = pExpr->pLeft;\n<line2>int nVal = sqlite3ExprVectorSize(pLeft);\n<line3>Select *pSelect = ExprUseXSelect(pExpr) ? pExpr->x.pSelect : 0;\n<line4>char *zRet;\n<line5>assert( pExpr->op==TK_IN );\n<line6>zRet = sqlite3DbMallocRaw(pParse->db, 1+(i64)nVal);\n<line7>if( zRet ){\n<line8>int i;\n<line9>for(i=0; i<nVal; i++){\n<line10>Expr *pA = sqlite3VectorFieldSubexpr(pLeft, i);\n<line11>char a = sqlite3ExprAffinity(pA);\n<line12>if( pSelect ){\n<line13>zRet[i] = sqlite3CompareAffinity(pSelect->pEList->a[i].pExpr, a);\n<line14>}else{\n<line15>zRet[i] = a;\n<line16>}\n<line17>}\n<line18>zRet[nVal] = '\0';\n<line19>}\n<line20>return zRet;\n<line21>}
----------------------------------------
Function: findCompatibleInRhsSubrtn
Content: <line0>static int findCompatibleInRhsSubrtn(\n<line1>Parse *pParse,          /* Parsing context */\n<line2>Expr *pExpr,            /* IN operator with RHS that we want to reuse */\n<line3>SubrtnSig *pNewSig      /* Signature for the IN operator */\n<line4>){\n<line5>VdbeOp *pOp, *pEnd;\n<line6>SubrtnSig *pSig;\n<line7>Vdbe *v;\n<line8>if( pNewSig==0 ) return 0;\n<line9>if( (pParse->mSubrtnSig & (1<<(pNewSig->selId&7)))==0 ) return 0;\n<line10>assert( pExpr->op==TK_IN );\n<line11>assert( !ExprUseYSub(pExpr) );\n<line12>assert( ExprUseXSelect(pExpr) );\n<line13>assert( pExpr->x.pSelect!=0 );\n<line14>assert( (pExpr->x.pSelect->selFlags & SF_All)==0 );\n<line15>v = pParse->pVdbe;\n<line16>assert( v!=0 );\n<line17>pOp = sqlite3VdbeGetOp(v, 1);\n<line18>pEnd = sqlite3VdbeGetLastOp(v);\n<line19>for(; pOp<pEnd; pOp++){\n<line20>if( pOp->p4type!=P4_SUBRTNSIG ) continue;\n<line21>assert( pOp->opcode==OP_BeginSubrtn );\n<line22>pSig = pOp->p4.pSubrtnSig;\n<line23>assert( pSig!=0 );\n<line24>if( !pSig->bComplete ) continue;\n<line25>if( pNewSig->selId!=pSig->selId ) continue;\n<line26>if( strcmp(pNewSig->zAff,pSig->zAff)!=0 ) continue;\n<line27>pExpr->y.sub.iAddr = pSig->iAddr;\n<line28>pExpr->y.sub.regReturn = pSig->regReturn;\n<line29>pExpr->iTable = pSig->iTable;\n<line30>ExprSetProperty(pExpr, EP_Subrtn);\n<line31>return 1;\n<line32>}\n<line33>return 0;\n<line34>}
----------------------------------------
Function: sqlite3ExprCodeIN
Content: <line0>static void sqlite3ExprCodeIN(\n<line1>Parse *pParse,        /* Parsing and code generating context */\n<line2>Expr *pExpr,          /* The IN expression */\n<line3>int destIfFalse,      /* Jump here if LHS is not contained in the RHS */\n<line4>int destIfNull        /* Jump here if the results are unknown due to NULLs */\n<line5>){\n<line6>int rRhsHasNull = 0;  /* Register that is true if RHS contains NULL values */\n<line7>int eType;            /* Type of the RHS */\n<line8>int rLhs;             /* Register(s) holding the LHS values */\n<line9>Vdbe *v;              /* Statement under construction */\n<line10>int *aiMap = 0;       /* Map from vector field to index column */\n<line11>char *zAff = 0;       /* Affinity string for comparisons */\n<line12>int nVector;          /* Size of vectors for this IN operator */\n<line13>int iDummy;           /* Dummy parameter to exprCodeVector() */\n<line14>Expr *pLeft;          /* The LHS of the IN operator */\n<line15>int i;                /* loop counter */\n<line16>int destStep2;        /* Where to jump when NULLs seen in step 2 */\n<line17>int destStep6 = 0;    /* Start of code for Step 6 */\n<line18>int addrTruthOp;      /* Address of opcode that determines the IN is true */\n<line19>int destNotNull;      /* Jump here if a comparison is not true in step 6 */\n<line20>int addrTop;          /* Top of the step-6 loop */\n<line21>int iTab = 0;         /* Index to use */\n<line22>u8 okConstFactor = pParse->okConstFactor;\n<line23>assert( !ExprHasVVAProperty(pExpr,EP_Immutable) );\n<line24>pLeft = pExpr->pLeft;\n<line25>if( sqlite3ExprCheckIN(pParse, pExpr) ) return;\n<line26>zAff = exprINAffinity(pParse, pExpr);\n<line27>nVector = sqlite3ExprVectorSize(pExpr->pLeft);\n<line28>aiMap = (int*)sqlite3DbMallocZero(pParse->db, nVector*sizeof(int));\n<line29>if( pParse->db->mallocFailed ) goto sqlite3ExprCodeIN_oom_error;\n<line30>/* Attempt to compute the RHS. After this step, if anything other than\n<line31>** IN_INDEX_NOOP is returned, the table opened with cursor iTab\n<line32>** contains the values that make up the RHS. If IN_INDEX_NOOP is returned,\n<line33>** the RHS has not yet been coded.  */\n<line34>v = pParse->pVdbe;\n<line35>assert( v!=0 );       /* OOM detected prior to this routine */\n<line36>VdbeNoopComment((v, "begin IN expr"));\n<line37>eType = sqlite3FindInIndex(pParse, pExpr,\n<line38>IN_INDEX_MEMBERSHIP | IN_INDEX_NOOP_OK,\n<line39>destIfFalse==destIfNull ? 0 : &rRhsHasNull,\n<line40>aiMap, &iTab);\n<line41>assert( pParse->nErr || nVector==1 || eType==IN_INDEX_EPH\n<line42>|| eType==IN_INDEX_INDEX_ASC || eType==IN_INDEX_INDEX_DESC\n<line43>);\n<line44>#ifdef SQLITE_DEBUG\n<line45>/* Confirm that aiMap[] contains nVector integer values between 0 and\n<line46>** nVector-1. */\n<line47>for(i=0; i<nVector; i++){\n<line48>int j, cnt;\n<line49>for(cnt=j=0; j<nVector; j++) if( aiMap[j]==i ) cnt++;\n<line50>assert( cnt==1 );\n<line51>}\n<line52>#endif\n<line53>/* Code the LHS, the <expr> from "<expr> IN (...)". If the LHS is a\n<line54>** vector, then it is stored in an array of nVector registers starting\n<line55>** at r1.\n<line56>**\n<line57>** sqlite3FindInIndex() might have reordered the fields of the LHS vector\n<line58>** so that the fields are in the same order as an existing index.   The\n<line59>** aiMap[] array contains a mapping from the original LHS field order to\n<line60>** the field order that matches the RHS index.\n<line61>**\n<line62>** Avoid factoring the LHS of the IN(...) expression out of the loop,\n<line63>** even if it is constant, as OP_Affinity may be used on the register\n<line64>** by code generated below.  */\n<line65>assert( pParse->okConstFactor==okConstFactor );\n<line66>pParse->okConstFactor = 0;\n<line67>rLhs = exprCodeVector(pParse, pLeft, &iDummy);\n<line68>pParse->okConstFactor = okConstFactor;\n<line69>/* If sqlite3FindInIndex() did not find or create an index that is\n<line70>** suitable for evaluating the IN operator, then evaluate using a\n<line71>** sequence of comparisons.\n<line72>**\n<line73>** This is step (1) in the in-operator.md optimized algorithm.\n<line74>*/\n<line75>if( eType==IN_INDEX_NOOP ){\n<line76>ExprList *pList;\n<line77>CollSeq *pColl;\n<line78>int labelOk = sqlite3VdbeMakeLabel(pParse);\n<line79>int r2, regToFree;\n<line80>int regCkNull = 0;\n<line81>int ii;\n<line82>assert( nVector==1 );\n<line83>assert( ExprUseXList(pExpr) );\n<line84>pList = pExpr->x.pList;\n<line85>pColl = sqlite3ExprCollSeq(pParse, pExpr->pLeft);\n<line86>if( destIfNull!=destIfFalse ){\n<line87>regCkNull = sqlite3GetTempReg(pParse);\n<line88>sqlite3VdbeAddOp3(v, OP_BitAnd, rLhs, rLhs, regCkNull);\n<line89>}\n<line90>for(ii=0; ii<pList->nExpr; ii++){\n<line91>r2 = sqlite3ExprCodeTemp(pParse, pList->a[ii].pExpr, &regToFree);\n<line92>if( regCkNull && sqlite3ExprCanBeNull(pList->a[ii].pExpr) ){\n<line93>sqlite3VdbeAddOp3(v, OP_BitAnd, regCkNull, r2, regCkNull);\n<line94>}\n<line95>sqlite3ReleaseTempReg(pParse, regToFree);\n<line96>if( ii<pList->nExpr-1 || destIfNull!=destIfFalse ){\n<line97>int op = rLhs!=r2 ? OP_Eq : OP_NotNull;\n<line98>sqlite3VdbeAddOp4(v, op, rLhs, labelOk, r2,\n<line99>(void*)pColl, P4_COLLSEQ);\n<line100>VdbeCoverageIf(v, ii<pList->nExpr-1 && op==OP_Eq);\n<line101>VdbeCoverageIf(v, ii==pList->nExpr-1 && op==OP_Eq);\n<line102>VdbeCoverageIf(v, ii<pList->nExpr-1 && op==OP_NotNull);\n<line103>VdbeCoverageIf(v, ii==pList->nExpr-1 && op==OP_NotNull);\n<line104>sqlite3VdbeChangeP5(v, zAff[0]);\n<line105>}else{\n<line106>int op = rLhs!=r2 ? OP_Ne : OP_IsNull;\n<line107>assert( destIfNull==destIfFalse );\n<line108>sqlite3VdbeAddOp4(v, op, rLhs, destIfFalse, r2,\n<line109>(void*)pColl, P4_COLLSEQ);\n<line110>VdbeCoverageIf(v, op==OP_Ne);\n<line111>VdbeCoverageIf(v, op==OP_IsNull);\n<line112>sqlite3VdbeChangeP5(v, zAff[0] | SQLITE_JUMPIFNULL);\n<line113>}\n<line114>}\n<line115>if( regCkNull ){\n<line116>sqlite3VdbeAddOp2(v, OP_IsNull, regCkNull, destIfNull); VdbeCoverage(v);\n<line117>sqlite3VdbeGoto(v, destIfFalse);\n<line118>}\n<line119>sqlite3VdbeResolveLabel(v, labelOk);\n<line120>sqlite3ReleaseTempReg(pParse, regCkNull);\n<line121>goto sqlite3ExprCodeIN_finished;\n<line122>}\n<line123>if( eType!=IN_INDEX_ROWID ){\n<line124>/* If this IN operator will use an index, then the order of columns in the\n<line125>** vector might be different from the order in the index.  In that case,\n<line126>** we need to reorder the LHS values to be in index order.  Run Affinity\n<line127>** before reordering the columns, so that the affinity is correct.\n<line128>*/\n<line129>sqlite3VdbeAddOp4(v, OP_Affinity, rLhs, nVector, 0, zAff, nVector);\n<line130>for(i=0; i<nVector && aiMap[i]==i; i++){} /* Are LHS fields reordered? */\n<line131>if( i!=nVector ){\n<line132>/* Need to reorder the LHS fields according to aiMap */\n<line133>int rLhsOrig = rLhs;\n<line134>rLhs = sqlite3GetTempRange(pParse, nVector);\n<line135>for(i=0; i<nVector; i++){\n<line136>sqlite3VdbeAddOp3(v, OP_Copy, rLhsOrig+i, rLhs+aiMap[i], 0);\n<line137>}\n<line138>sqlite3ReleaseTempReg(pParse, rLhsOrig);\n<line139>}\n<line140>}\n<line141>/* Step 2: Check to see if the LHS contains any NULL columns.  If the\n<line142>** LHS does contain NULLs then the result must be either FALSE or NULL.\n<line143>** We will then skip the binary search of the RHS.\n<line144>*/\n<line145>if( destIfNull==destIfFalse ){\n<line146>destStep2 = destIfFalse;\n<line147>}else{\n<line148>destStep2 = destStep6 = sqlite3VdbeMakeLabel(pParse);\n<line149>}\n<line150>for(i=0; i<nVector; i++){\n<line151>Expr *p = sqlite3VectorFieldSubexpr(pExpr->pLeft, i);\n<line152>if( pParse->nErr ) goto sqlite3ExprCodeIN_oom_error;\n<line153>if( sqlite3ExprCanBeNull(p) ){\n<line154>sqlite3VdbeAddOp2(v, OP_IsNull, rLhs+i, destStep2);\n<line155>VdbeCoverage(v);\n<line156>}\n<line157>}\n<line158>/* Step 3.  The LHS is now known to be non-NULL.  Do the binary search\n<line159>** of the RHS using the LHS as a probe.  If found, the result is\n<line160>** true.\n<line161>*/\n<line162>if( eType==IN_INDEX_ROWID ){\n<line163>/* In this case, the RHS is the ROWID of table b-tree and so we also\n<line164>** know that the RHS is non-NULL.  Hence, we combine steps 3 and 4\n<line165>** into a single opcode. */\n<line166>assert( nVector==1 );\n<line167>sqlite3VdbeAddOp3(v, OP_SeekRowid, iTab, destIfFalse, rLhs);\n<line168>VdbeCoverage(v);\n<line169>addrTruthOp = sqlite3VdbeAddOp0(v, OP_Goto);  /* Return True */\n<line170>}else{\n<line171>if( destIfFalse==destIfNull ){\n<line172>/* Combine Step 3 and Step 5 into a single opcode */\n<line173>if( ExprHasProperty(pExpr, EP_Subrtn) ){\n<line174>const VdbeOp *pOp = sqlite3VdbeGetOp(v, pExpr->y.sub.iAddr);\n<line175>assert( pOp->opcode==OP_Once || pParse->nErr );\n<line176>if( pOp->opcode==OP_Once && pOp->p3>0 ){  /* tag-202407032019 */\n<line177>assert( OptimizationEnabled(pParse->db, SQLITE_BloomFilter) );\n<line178>sqlite3VdbeAddOp4Int(v, OP_Filter, pOp->p3, destIfFalse,\n<line179>rLhs, nVector); VdbeCoverage(v);\n<line180>}\n<line181>}\n<line182>sqlite3VdbeAddOp4Int(v, OP_NotFound, iTab, destIfFalse,\n<line183>rLhs, nVector); VdbeCoverage(v);\n<line184>goto sqlite3ExprCodeIN_finished;\n<line185>}\n<line186>/* Ordinary Step 3, for the case where FALSE and NULL are distinct */\n<line187>addrTruthOp = sqlite3VdbeAddOp4Int(v, OP_Found, iTab, 0,\n<line188>rLhs, nVector); VdbeCoverage(v);\n<line189>}\n<line190>/* Step 4.  If the RHS is known to be non-NULL and we did not find\n<line191>** an match on the search above, then the result must be FALSE.\n<line192>*/\n<line193>if( rRhsHasNull && nVector==1 ){\n<line194>sqlite3VdbeAddOp2(v, OP_NotNull, rRhsHasNull, destIfFalse);\n<line195>VdbeCoverage(v);\n<line196>}\n<line197>/* Step 5.  If we do not care about the difference between NULL and\n<line198>** FALSE, then just return false.\n<line199>*/\n<line200>if( destIfFalse==destIfNull ) sqlite3VdbeGoto(v, destIfFalse);\n<line201>/* Step 6: Loop through rows of the RHS.  Compare each row to the LHS.\n<line202>** If any comparison is NULL, then the result is NULL.  If all\n<line203>** comparisons are FALSE then the final result is FALSE.\n<line204>**\n<line205>** For a scalar LHS, it is sufficient to check just the first row\n<line206>** of the RHS.\n<line207>*/\n<line208>if( destStep6 ) sqlite3VdbeResolveLabel(v, destStep6);\n<line209>addrTop = sqlite3VdbeAddOp2(v, OP_Rewind, iTab, destIfFalse);\n<line210>VdbeCoverage(v);\n<line211>if( nVector>1 ){\n<line212>destNotNull = sqlite3VdbeMakeLabel(pParse);\n<line213>}else{\n<line214>/* For nVector==1, combine steps 6 and 7 by immediately returning\n<line215>** FALSE if the first comparison is not NULL */\n<line216>destNotNull = destIfFalse;\n<line217>}\n<line218>for(i=0; i<nVector; i++){\n<line219>Expr *p;\n<line220>CollSeq *pColl;\n<line221>int r3 = sqlite3GetTempReg(pParse);\n<line222>p = sqlite3VectorFieldSubexpr(pLeft, i);\n<line223>pColl = sqlite3ExprCollSeq(pParse, p);\n<line224>sqlite3VdbeAddOp3(v, OP_Column, iTab, i, r3);\n<line225>sqlite3VdbeAddOp4(v, OP_Ne, rLhs+i, destNotNull, r3,\n<line226>(void*)pColl, P4_COLLSEQ);\n<line227>VdbeCoverage(v);\n<line228>sqlite3ReleaseTempReg(pParse, r3);\n<line229>}\n<line230>sqlite3VdbeAddOp2(v, OP_Goto, 0, destIfNull);\n<line231>if( nVector>1 ){\n<line232>sqlite3VdbeResolveLabel(v, destNotNull);\n<line233>sqlite3VdbeAddOp2(v, OP_Next, iTab, addrTop+1);\n<line234>VdbeCoverage(v);\n<line235>/* Step 7:  If we reach this point, we know that the result must\n<line236>** be false. */\n<line237>sqlite3VdbeAddOp2(v, OP_Goto, 0, destIfFalse);\n<line238>}\n<line239>/* Jumps here in order to return true. */\n<line240>sqlite3VdbeJumpHere(v, addrTruthOp);\n<line241>sqlite3ExprCodeIN_finished:\n<line242>VdbeComment((v, "end IN expr"));\n<line243>sqlite3ExprCodeIN_oom_error:\n<line244>sqlite3DbFree(pParse->db, aiMap);\n<line245>sqlite3DbFree(pParse->db, zAff);\n<line246>}
----------------------------------------
Function: codeReal
Content: <line0>static void codeReal(Vdbe *v, const char *z, int negateFlag, int iMem){\n<line1>if( ALWAYS(z!=0) ){\n<line2>double value;\n<line3>sqlite3AtoF(z, &value, sqlite3Strlen30(z), SQLITE_UTF8);\n<line4>assert( !sqlite3IsNaN(value) ); /* The new AtoF never returns NaN */\n<line5>if( negateFlag ) value = -value;\n<line6>sqlite3VdbeAddOp4Dup8(v, OP_Real, 0, iMem, 0, (u8*)&value, P4_REAL);\n<line7>}\n<line8>}
----------------------------------------
Function: codeInteger
Content: <line0>static void codeInteger(Parse *pParse, Expr *pExpr, int negFlag, int iMem){\n<line1>Vdbe *v = pParse->pVdbe;\n<line2>if( pExpr->flags & EP_IntValue ){\n<line3>int i = pExpr->u.iValue;\n<line4>assert( i>=0 );\n<line5>if( negFlag ) i = -i;\n<line6>sqlite3VdbeAddOp2(v, OP_Integer, i, iMem);\n<line7>}else{\n<line8>int c;\n<line9>i64 value;\n<line10>const char *z = pExpr->u.zToken;\n<line11>assert( z!=0 );\n<line12>c = sqlite3DecOrHexToI64(z, &value);\n<line13>if( (c==3 && !negFlag) || (c==2) || (negFlag && value==SMALLEST_INT64)){\n<line14>#ifdef SQLITE_OMIT_FLOATING_POINT\n<line15>sqlite3ErrorMsg(pParse, "oversized integer: %s%#T", negFlag?"-":"",pExpr);\n<line16>#else\n<line17>#ifndef SQLITE_OMIT_HEX_INTEGER\n<line18>if( sqlite3_strnicmp(z,"0x",2)==0 ){\n<line19>sqlite3ErrorMsg(pParse, "hex literal too big: %s%#T",\n<line20>negFlag?"-":"",pExpr);\n<line21>}else\n<line22>#endif\n<line23>{\n<line24>codeReal(v, z, negFlag, iMem);\n<line25>}\n<line26>#endif\n<line27>}else{\n<line28>if( negFlag ){ value = c==3 ? SMALLEST_INT64 : -value; }\n<line29>sqlite3VdbeAddOp4Dup8(v, OP_Int64, 0, iMem, 0, (u8*)&value, P4_INT64);\n<line30>}\n<line31>}\n<line32>}
----------------------------------------
Function: exprCodeVector
Content: <line0>static int exprCodeVector(Parse *pParse, Expr *p, int *piFreeable){\n<line1>int iResult;\n<line2>int nResult = sqlite3ExprVectorSize(p);\n<line3>if( nResult==1 ){\n<line4>iResult = sqlite3ExprCodeTemp(pParse, p, piFreeable);\n<line5>}else{\n<line6>*piFreeable = 0;\n<line7>if( p->op==TK_SELECT ){\n<line8>#if SQLITE_OMIT_SUBQUERY\n<line9>iResult = 0;\n<line10>#else\n<line11>iResult = sqlite3CodeSubselect(pParse, p);\n<line12>#endif\n<line13>}else{\n<line14>int i;\n<line15>iResult = pParse->nMem+1;\n<line16>pParse->nMem += nResult;\n<line17>assert( ExprUseXList(p) );\n<line18>for(i=0; i<nResult; i++){\n<line19>sqlite3ExprCodeFactorable(pParse, p->x.pList->a[i].pExpr, i+iResult);\n<line20>}\n<line21>}\n<line22>}\n<line23>return iResult;\n<line24>}
----------------------------------------
Function: setDoNotMergeFlagOnCopy
Content: <line0>static void setDoNotMergeFlagOnCopy(Vdbe *v){\n<line1>if( sqlite3VdbeGetLastOp(v)->opcode==OP_Copy ){\n<line2>sqlite3VdbeChangeP5(v, 1);  /* Tag trailing OP_Copy as not mergeable */\n<line3>}\n<line4>}
----------------------------------------
Function: exprCodeInlineFunction
Content: <line0>static int exprCodeInlineFunction(\n<line1>Parse *pParse,        /* Parsing context */\n<line2>ExprList *pFarg,      /* List of function arguments */\n<line3>int iFuncId,          /* Function ID.  One of the INTFUNC_... values */\n<line4>int target            /* Store function result in this register */\n<line5>){\n<line6>int nFarg;\n<line7>Vdbe *v = pParse->pVdbe;\n<line8>assert( v!=0 );\n<line9>assert( pFarg!=0 );\n<line10>nFarg = pFarg->nExpr;\n<line11>assert( nFarg>0 );  /* All in-line functions have at least one argument */\n<line12>switch( iFuncId ){\n<line13>case INLINEFUNC_coalesce: {\n<line14>/* Attempt a direct implementation of the built-in COALESCE() and\n<line15>** IFNULL() functions.  This avoids unnecessary evaluation of\n<line16>** arguments past the first non-NULL argument.\n<line17>*/\n<line18>int endCoalesce = sqlite3VdbeMakeLabel(pParse);\n<line19>int i;\n<line20>assert( nFarg>=2 );\n<line21>sqlite3ExprCode(pParse, pFarg->a[0].pExpr, target);\n<line22>for(i=1; i<nFarg; i++){\n<line23>sqlite3VdbeAddOp2(v, OP_NotNull, target, endCoalesce);\n<line24>VdbeCoverage(v);\n<line25>sqlite3ExprCode(pParse, pFarg->a[i].pExpr, target);\n<line26>}\n<line27>setDoNotMergeFlagOnCopy(v);\n<line28>sqlite3VdbeResolveLabel(v, endCoalesce);\n<line29>break;\n<line30>}\n<line31>case INLINEFUNC_iif: {\n<line32>Expr caseExpr;\n<line33>memset(&caseExpr, 0, sizeof(caseExpr));\n<line34>caseExpr.op = TK_CASE;\n<line35>caseExpr.x.pList = pFarg;\n<line36>return sqlite3ExprCodeTarget(pParse, &caseExpr, target);\n<line37>}\n<line38>#ifdef SQLITE_ENABLE_OFFSET_SQL_FUNC\n<line39>case INLINEFUNC_sqlite_offset: {\n<line40>Expr *pArg = pFarg->a[0].pExpr;\n<line41>if( pArg->op==TK_COLUMN && pArg->iTable>=0 ){\n<line42>sqlite3VdbeAddOp3(v, OP_Offset, pArg->iTable, pArg->iColumn, target);\n<line43>}else{\n<line44>sqlite3VdbeAddOp2(v, OP_Null, 0, target);\n<line45>}\n<line46>break;\n<line47>}\n<line48>#endif\n<line49>default: {\n<line50>/* The UNLIKELY() function is a no-op.  The result is the value\n<line51>** of the first argument.\n<line52>*/\n<line53>assert( nFarg==1 || nFarg==2 );\n<line54>target = sqlite3ExprCodeTarget(pParse, pFarg->a[0].pExpr, target);\n<line55>break;\n<line56>}\n<line57>/***********************************************************************\n<line58>** Test-only SQL functions that are only usable if enabled\n<line59>** via SQLITE_TESTCTRL_INTERNAL_FUNCTIONS\n<line60>*/\n<line61>#if !defined(SQLITE_UNTESTABLE)\n<line62>case INLINEFUNC_expr_compare: {\n<line63>/* Compare two expressions using sqlite3ExprCompare() */\n<line64>assert( nFarg==2 );\n<line65>sqlite3VdbeAddOp2(v, OP_Integer,\n<line66>sqlite3ExprCompare(0,pFarg->a[0].pExpr, pFarg->a[1].pExpr,-1),\n<line67>target);\n<line68>break;\n<line69>}\n<line70>case INLINEFUNC_expr_implies_expr: {\n<line71>/* Compare two expressions using sqlite3ExprImpliesExpr() */\n<line72>assert( nFarg==2 );\n<line73>sqlite3VdbeAddOp2(v, OP_Integer,\n<line74>sqlite3ExprImpliesExpr(pParse,pFarg->a[0].pExpr, pFarg->a[1].pExpr,-1),\n<line75>target);\n<line76>break;\n<line77>}\n<line78>case INLINEFUNC_implies_nonnull_row: {\n<line79>/* Result of sqlite3ExprImpliesNonNullRow() */\n<line80>Expr *pA1;\n<line81>assert( nFarg==2 );\n<line82>pA1 = pFarg->a[1].pExpr;\n<line83>if( pA1->op==TK_COLUMN ){\n<line84>sqlite3VdbeAddOp2(v, OP_Integer,\n<line85>sqlite3ExprImpliesNonNullRow(pFarg->a[0].pExpr,pA1->iTable,1),\n<line86>target);\n<line87>}else{\n<line88>sqlite3VdbeAddOp2(v, OP_Null, 0, target);\n<line89>}\n<line90>break;\n<line91>}\n<line92>case INLINEFUNC_affinity: {\n<line93>/* The AFFINITY() function evaluates to a string that describes\n<line94>** the type affinity of the argument.  This is used for testing of\n<line95>** the SQLite type logic.\n<line96>*/\n<line97>const char *azAff[] = { "blob", "text", "numeric", "integer",\n<line98>"real", "flexnum" };\n<line99>char aff;\n<line100>assert( nFarg==1 );\n<line101>aff = sqlite3ExprAffinity(pFarg->a[0].pExpr);\n<line102>assert( aff<=SQLITE_AFF_NONE\n<line103>|| (aff>=SQLITE_AFF_BLOB && aff<=SQLITE_AFF_FLEXNUM) );\n<line104>sqlite3VdbeLoadString(v, target,\n<line105>(aff<=SQLITE_AFF_NONE) ? "none" : azAff[aff-SQLITE_AFF_BLOB]);\n<line106>break;\n<line107>}\n<line108>#endif /* !defined(SQLITE_UNTESTABLE) */\n<line109>}\n<line110>return target;\n<line111>}
----------------------------------------
Function: exprNodeCanReturnSubtype
Content: <line0>static int exprNodeCanReturnSubtype(Walker *pWalker, Expr *pExpr){\n<line1>int n;\n<line2>FuncDef *pDef;\n<line3>sqlite3 *db;\n<line4>if( pExpr->op!=TK_FUNCTION ){\n<line5>return WRC_Prune;\n<line6>}\n<line7>assert( ExprUseXList(pExpr) );\n<line8>db = pWalker->pParse->db;\n<line9>n = ALWAYS(pExpr->x.pList) ? pExpr->x.pList->nExpr : 0;\n<line10>pDef = sqlite3FindFunction(db, pExpr->u.zToken, n, ENC(db), 0);\n<line11>if( NEVER(pDef==0) || (pDef->funcFlags & SQLITE_RESULT_SUBTYPE)!=0 ){\n<line12>pWalker->eCode = 1;\n<line13>return WRC_Prune;\n<line14>}\n<line15>return WRC_Continue;\n<line16>}
----------------------------------------
Function: sqlite3ExprCanReturnSubtype
Content: <line0>static int sqlite3ExprCanReturnSubtype(Parse *pParse, Expr *pExpr){\n<line1>Walker w;\n<line2>memset(&w, 0, sizeof(w));\n<line3>w.pParse = pParse;\n<line4>w.xExprCallback = exprNodeCanReturnSubtype;\n<line5>sqlite3WalkExpr(&w, pExpr);\n<line6>return w.eCode;\n<line7>}
----------------------------------------
Function: sqlite3IndexedExprLookup
Content: <line0>static SQLITE_NOINLINE int sqlite3IndexedExprLookup(\n<line1>Parse *pParse,   /* The parsing context */\n<line2>Expr *pExpr,     /* The expression to potentially bypass */\n<line3>int target       /* Where to store the result of the expression */\n<line4>){\n<line5>IndexedExpr *p;\n<line6>Vdbe *v;\n<line7>for(p=pParse->pIdxEpr; p; p=p->pIENext){\n<line8>u8 exprAff;\n<line9>int iDataCur = p->iDataCur;\n<line10>if( iDataCur<0 ) continue;\n<line11>if( pParse->iSelfTab ){\n<line12>if( p->iDataCur!=pParse->iSelfTab-1 ) continue;\n<line13>iDataCur = -1;\n<line14>}\n<line15>if( sqlite3ExprCompare(0, pExpr, p->pExpr, iDataCur)!=0 ) continue;\n<line16>assert( p->aff>=SQLITE_AFF_BLOB && p->aff<=SQLITE_AFF_NUMERIC );\n<line17>exprAff = sqlite3ExprAffinity(pExpr);\n<line18>if( (exprAff<=SQLITE_AFF_BLOB && p->aff!=SQLITE_AFF_BLOB)\n<line19>|| (exprAff==SQLITE_AFF_TEXT && p->aff!=SQLITE_AFF_TEXT)\n<line20>|| (exprAff>=SQLITE_AFF_NUMERIC && p->aff!=SQLITE_AFF_NUMERIC)\n<line21>){\n<line22>/* Affinity mismatch on a generated column */\n<line23>continue;\n<line24>}\n<line25>/* Functions that might set a subtype should not be replaced by the\n<line26>** value taken from an expression index if they are themselves an\n<line27>** argument to another scalar function or aggregate.\n<line28>** https://sqlite.org/forum/forumpost/68d284c86b082c3e */\n<line29>if( ExprHasProperty(pExpr, EP_SubtArg)\n<line30>&& sqlite3ExprCanReturnSubtype(pParse, pExpr)\n<line31>){\n<line32>continue;\n<line33>}\n<line34>v = pParse->pVdbe;\n<line35>assert( v!=0 );\n<line36>if( p->bMaybeNullRow ){\n<line37>/* If the index is on a NULL row due to an outer join, then we\n<line38>** cannot extract the value from the index.  The value must be\n<line39>** computed using the original expression. */\n<line40>int addr = sqlite3VdbeCurrentAddr(v);\n<line41>sqlite3VdbeAddOp3(v, OP_IfNullRow, p->iIdxCur, addr+3, target);\n<line42>VdbeCoverage(v);\n<line43>sqlite3VdbeAddOp3(v, OP_Column, p->iIdxCur, p->iIdxCol, target);\n<line44>VdbeComment((v, "%s expr-column %d", p->zIdxName, p->iIdxCol));\n<line45>sqlite3VdbeGoto(v, 0);\n<line46>p = pParse->pIdxEpr;\n<line47>pParse->pIdxEpr = 0;\n<line48>sqlite3ExprCode(pParse, pExpr, target);\n<line49>pParse->pIdxEpr = p;\n<line50>sqlite3VdbeJumpHere(v, addr+2);\n<line51>}else{\n<line52>sqlite3VdbeAddOp3(v, OP_Column, p->iIdxCur, p->iIdxCol, target);\n<line53>VdbeComment((v, "%s expr-column %d", p->zIdxName, p->iIdxCol));\n<line54>}\n<line55>return target;\n<line56>}\n<line57>return -1;  /* Not found */\n<line58>}
----------------------------------------
Function: exprPartidxExprLookup
Content: <line0>static int exprPartidxExprLookup(Parse *pParse, Expr *pExpr, int iTarget){\n<line1>IndexedExpr *p;\n<line2>for(p=pParse->pIdxPartExpr; p; p=p->pIENext){\n<line3>if( pExpr->iColumn==p->iIdxCol && pExpr->iTable==p->iDataCur ){\n<line4>Vdbe *v = pParse->pVdbe;\n<line5>int addr = 0;\n<line6>int ret;\n<line7>if( p->bMaybeNullRow ){\n<line8>addr = sqlite3VdbeAddOp1(v, OP_IfNullRow, p->iIdxCur);\n<line9>}\n<line10>ret = sqlite3ExprCodeTarget(pParse, p->pExpr, iTarget);\n<line11>sqlite3VdbeAddOp4(pParse->pVdbe, OP_Affinity, ret, 1, 0,\n<line12>(const char*)&p->aff, 1);\n<line13>if( addr ){\n<line14>sqlite3VdbeJumpHere(v, addr);\n<line15>sqlite3VdbeChangeP3(v, addr, ret);\n<line16>}\n<line17>return ret;\n<line18>}\n<line19>}\n<line20>return 0;\n<line21>}
----------------------------------------
Function: exprCodeTargetAndOr
Content: <line0>static SQLITE_NOINLINE int exprCodeTargetAndOr(\n<line1>Parse *pParse,     /* Parsing context */\n<line2>Expr *pExpr,       /* AND or OR expression to be coded */\n<line3>int target,        /* Put result in this register, guaranteed */\n<line4>int *pTmpReg       /* Write a temporary register here */\n<line5>){\n<line6>int op;            /* The opcode.  TK_AND or TK_OR */\n<line7>int skipOp;        /* Opcode for the branch that skips one operand */\n<line8>int addrSkip;      /* Branch instruction that skips one of the operands */\n<line9>int regSS = 0;     /* Register holding computed operand when other omitted */\n<line10>int r1, r2;        /* Registers for left and right operands, respectively */\n<line11>Expr *pAlt;        /* Alternative, simplified expression */\n<line12>Vdbe *v;           /* statement being coded */\n<line13>assert( pExpr!=0 );\n<line14>op = pExpr->op;\n<line15>assert( op==TK_AND || op==TK_OR );\n<line16>assert( TK_AND==OP_And );            testcase( op==TK_AND );\n<line17>assert( TK_OR==OP_Or );              testcase( op==TK_OR );\n<line18>assert( pParse->pVdbe!=0 );\n<line19>v = pParse->pVdbe;\n<line20>pAlt = sqlite3ExprSimplifiedAndOr(pExpr);\n<line21>if( pAlt!=pExpr ){\n<line22>r1 = sqlite3ExprCodeTarget(pParse, pAlt, target);\n<line23>sqlite3VdbeAddOp3(v, OP_And, r1, r1, target);\n<line24>return target;\n<line25>}\n<line26>skipOp = op==TK_AND ? OP_IfNot : OP_If;\n<line27>if( exprEvalRhsFirst(pExpr) ){\n<line28>/* Compute the right operand first.  Skip the computation of the left\n<line29>** operand if the right operand fully determines the result */\n<line30>r2 = regSS = sqlite3ExprCodeTarget(pParse, pExpr->pRight, target);\n<line31>addrSkip = sqlite3VdbeAddOp1(v, skipOp, r2);\n<line32>VdbeComment((v, "skip left operand"));\n<line33>VdbeCoverage(v);\n<line34>r1 = sqlite3ExprCodeTemp(pParse, pExpr->pLeft, pTmpReg);\n<line35>}else{\n<line36>/* Compute the left operand first */\n<line37>r1 = sqlite3ExprCodeTarget(pParse, pExpr->pLeft, target);\n<line38>if( ExprHasProperty(pExpr->pRight, EP_Subquery) ){\n<line39>/* Skip over the computation of the right operand if the right\n<line40>** operand is a subquery and the left operand completely determines\n<line41>** the result */\n<line42>regSS = r1;\n<line43>addrSkip = sqlite3VdbeAddOp1(v, skipOp, r1);\n<line44>VdbeComment((v, "skip right operand"));\n<line45>VdbeCoverage(v);\n<line46>}else{\n<line47>addrSkip = regSS = 0;\n<line48>}\n<line49>r2 = sqlite3ExprCodeTemp(pParse, pExpr->pRight, pTmpReg);\n<line50>}\n<line51>sqlite3VdbeAddOp3(v, op, r2, r1, target);\n<line52>testcase( (*pTmpReg)==0 );\n<line53>if( addrSkip ){\n<line54>sqlite3VdbeAddOp2(v, OP_Goto, 0, sqlite3VdbeCurrentAddr(v)+2);\n<line55>sqlite3VdbeJumpHere(v, addrSkip);\n<line56>sqlite3VdbeAddOp3(v, OP_Or, regSS, regSS, target);\n<line57>VdbeComment((v, "short-circut value"));\n<line58>}\n<line59>return target;\n<line60>}
----------------------------------------
Function: exprCodeBetween
Content: <line0>static void exprCodeBetween(\n<line1>Parse *pParse,    /* Parsing and code generating context */\n<line2>Expr *pExpr,      /* The BETWEEN expression */\n<line3>int dest,         /* Jump destination or storage location */\n<line4>void (*xJump)(Parse*,Expr*,int,int), /* Action to take */\n<line5>int jumpIfNull    /* Take the jump if the BETWEEN is NULL */\n<line6>){\n<line7>Expr exprAnd;     /* The AND operator in  x>=y AND x<=z  */\n<line8>Expr compLeft;    /* The  x>=y  term */\n<line9>Expr compRight;   /* The  x<=z  term */\n<line10>int regFree1 = 0; /* Temporary use register */\n<line11>Expr *pDel = 0;\n<line12>sqlite3 *db = pParse->db;\n<line13>memset(&compLeft, 0, sizeof(Expr));\n<line14>memset(&compRight, 0, sizeof(Expr));\n<line15>memset(&exprAnd, 0, sizeof(Expr));\n<line16>assert( ExprUseXList(pExpr) );\n<line17>pDel = sqlite3ExprDup(db, pExpr->pLeft, 0);\n<line18>if( db->mallocFailed==0 ){\n<line19>exprAnd.op = TK_AND;\n<line20>exprAnd.pLeft = &compLeft;\n<line21>exprAnd.pRight = &compRight;\n<line22>compLeft.op = TK_GE;\n<line23>compLeft.pLeft = pDel;\n<line24>compLeft.pRight = pExpr->x.pList->a[0].pExpr;\n<line25>compRight.op = TK_LE;\n<line26>compRight.pLeft = pDel;\n<line27>compRight.pRight = pExpr->x.pList->a[1].pExpr;\n<line28>sqlite3ExprToRegister(pDel, exprCodeVector(pParse, pDel, &regFree1));\n<line29>if( xJump ){\n<line30>xJump(pParse, &exprAnd, dest, jumpIfNull);\n<line31>}else{\n<line32>/* Mark the expression is being from the ON or USING clause of a join\n<line33>** so that the sqlite3ExprCodeTarget() routine will not attempt to move\n<line34>** it into the Parse.pConstExpr list.  We should use a new bit for this,\n<line35>** for clarity, but we are out of bits in the Expr.flags field so we\n<line36>** have to reuse the EP_OuterON bit.  Bummer. */\n<line37>pDel->flags |= EP_OuterON;\n<line38>sqlite3ExprCodeTarget(pParse, &exprAnd, dest);\n<line39>}\n<line40>sqlite3ReleaseTempReg(pParse, regFree1);\n<line41>}\n<line42>sqlite3ExprDelete(db, pDel);\n<line43>/* Ensure adequate test coverage */\n<line44>testcase( xJump==sqlite3ExprIfTrue  && jumpIfNull==0 && regFree1==0 );\n<line45>testcase( xJump==sqlite3ExprIfTrue  && jumpIfNull==0 && regFree1!=0 );\n<line46>testcase( xJump==sqlite3ExprIfTrue  && jumpIfNull!=0 && regFree1==0 );\n<line47>testcase( xJump==sqlite3ExprIfTrue  && jumpIfNull!=0 && regFree1!=0 );\n<line48>testcase( xJump==sqlite3ExprIfFalse && jumpIfNull==0 && regFree1==0 );\n<line49>testcase( xJump==sqlite3ExprIfFalse && jumpIfNull==0 && regFree1!=0 );\n<line50>testcase( xJump==sqlite3ExprIfFalse && jumpIfNull!=0 && regFree1==0 );\n<line51>testcase( xJump==sqlite3ExprIfFalse && jumpIfNull!=0 && regFree1!=0 );\n<line52>testcase( xJump==0 );\n<line53>}
----------------------------------------
Function: exprCompareVariable
Content: <line0>static SQLITE_NOINLINE int exprCompareVariable(\n<line1>const Parse *pParse,\n<line2>const Expr *pVar,\n<line3>const Expr *pExpr\n<line4>){\n<line5>int res = 2;\n<line6>int iVar;\n<line7>sqlite3_value *pL, *pR = 0;\n<line8>if( pExpr->op==TK_VARIABLE && pVar->iColumn==pExpr->iColumn ){\n<line9>return 0;\n<line10>}\n<line11>if( (pParse->db->flags & SQLITE_EnableQPSG)!=0 ) return 2;\n<line12>sqlite3ValueFromExpr(pParse->db, pExpr, SQLITE_UTF8, SQLITE_AFF_BLOB, &pR);\n<line13>if( pR ){\n<line14>iVar = pVar->iColumn;\n<line15>sqlite3VdbeSetVarmask(pParse->pVdbe, iVar);\n<line16>pL = sqlite3VdbeGetBoundValue(pParse->pReprepare, iVar, SQLITE_AFF_BLOB);\n<line17>if( pL ){\n<line18>if( sqlite3_value_type(pL)==SQLITE_TEXT ){\n<line19>sqlite3_value_text(pL); /* Make sure the encoding is UTF-8 */\n<line20>}\n<line21>res = sqlite3MemCompare(pL, pR, 0) ? 2 : 0;\n<line22>}\n<line23>sqlite3ValueFree(pR);\n<line24>sqlite3ValueFree(pL);\n<line25>}\n<line26>return res;\n<line27>}
----------------------------------------
Function: exprImpliesNotNull
Content: <line0>static int exprImpliesNotNull(\n<line1>const Parse *pParse,/* Parsing context */\n<line2>const Expr *p,      /* The expression to be checked */\n<line3>const Expr *pNN,    /* The expression that is NOT NULL */\n<line4>int iTab,           /* Table being evaluated */\n<line5>int seenNot         /* Return true only if p can be any non-NULL value */\n<line6>){\n<line7>assert( p );\n<line8>assert( pNN );\n<line9>if( sqlite3ExprCompare(pParse, p, pNN, iTab)==0 ){\n<line10>return pNN->op!=TK_NULL;\n<line11>}\n<line12>switch( p->op ){\n<line13>case TK_IN: {\n<line14>if( seenNot && ExprHasProperty(p, EP_xIsSelect) ) return 0;\n<line15>assert( ExprUseXSelect(p) || (p->x.pList!=0 && p->x.pList->nExpr>0) );\n<line16>return exprImpliesNotNull(pParse, p->pLeft, pNN, iTab, 1);\n<line17>}\n<line18>case TK_BETWEEN: {\n<line19>ExprList *pList;\n<line20>assert( ExprUseXList(p) );\n<line21>pList = p->x.pList;\n<line22>assert( pList!=0 );\n<line23>assert( pList->nExpr==2 );\n<line24>if( seenNot ) return 0;\n<line25>if( exprImpliesNotNull(pParse, pList->a[0].pExpr, pNN, iTab, 1)\n<line26>|| exprImpliesNotNull(pParse, pList->a[1].pExpr, pNN, iTab, 1)\n<line27>){\n<line28>return 1;\n<line29>}\n<line30>return exprImpliesNotNull(pParse, p->pLeft, pNN, iTab, 1);\n<line31>}\n<line32>case TK_EQ:\n<line33>case TK_NE:\n<line34>case TK_LT:\n<line35>case TK_LE:\n<line36>case TK_GT:\n<line37>case TK_GE:\n<line38>case TK_PLUS:\n<line39>case TK_MINUS:\n<line40>case TK_BITOR:\n<line41>case TK_LSHIFT:\n<line42>case TK_RSHIFT:\n<line43>case TK_CONCAT:\n<line44>seenNot = 1;\n<line45>/* no break */ deliberate_fall_through\n<line46>case TK_STAR:\n<line47>case TK_REM:\n<line48>case TK_BITAND:\n<line49>case TK_SLASH: {\n<line50>if( exprImpliesNotNull(pParse, p->pRight, pNN, iTab, seenNot) ) return 1;\n<line51>/* no break */ deliberate_fall_through\n<line52>}\n<line53>case TK_SPAN:\n<line54>case TK_COLLATE:\n<line55>case TK_UPLUS:\n<line56>case TK_UMINUS: {\n<line57>return exprImpliesNotNull(pParse, p->pLeft, pNN, iTab, seenNot);\n<line58>}\n<line59>case TK_TRUTH: {\n<line60>if( seenNot ) return 0;\n<line61>if( p->op2!=TK_IS ) return 0;\n<line62>return exprImpliesNotNull(pParse, p->pLeft, pNN, iTab, 1);\n<line63>}\n<line64>case TK_BITNOT:\n<line65>case TK_NOT: {\n<line66>return exprImpliesNotNull(pParse, p->pLeft, pNN, iTab, 1);\n<line67>}\n<line68>}\n<line69>return 0;\n<line70>}
----------------------------------------
Function: sqlite3ExprIsNotTrue
Content: <line0>static int sqlite3ExprIsNotTrue(Expr *pExpr){\n<line1>int v;\n<line2>if( pExpr->op==TK_NULL ) return 1;\n<line3>if( pExpr->op==TK_TRUEFALSE && sqlite3ExprTruthValue(pExpr)==0 ) return 1;\n<line4>v = 1;\n<line5>if( sqlite3ExprIsInteger(pExpr, &v, 0) && v==0 ) return 1;\n<line6>return 0;\n<line7>}
----------------------------------------
Function: sqlite3ExprIsIIF
Content: <line0>static int sqlite3ExprIsIIF(sqlite3 *db, const Expr *pExpr){\n<line1>ExprList *pList;\n<line2>if( pExpr->op==TK_FUNCTION ){\n<line3>const char *z = pExpr->u.zToken;\n<line4>FuncDef *pDef;\n<line5>if( (z[0]!='i' && z[0]!='I') ) return 0;\n<line6>if( pExpr->x.pList==0 ) return 0;\n<line7>pDef = sqlite3FindFunction(db, z, pExpr->x.pList->nExpr, ENC(db), 0);\n<line8>#ifdef SQLITE_ENABLE_UNKNOWN_SQL_FUNCTION\n<line9>if( pDef==0 ) return 0;\n<line10>#else\n<line11>if( NEVER(pDef==0) ) return 0;\n<line12>#endif\n<line13>if( (pDef->funcFlags & SQLITE_FUNC_INLINE)==0 ) return 0;\n<line14>if( SQLITE_PTR_TO_INT(pDef->pUserData)!=INLINEFUNC_iif ) return 0;\n<line15>}else if( pExpr->op==TK_CASE ){\n<line16>if( pExpr->pLeft!=0 ) return 0;\n<line17>}else{\n<line18>return 0;\n<line19>}\n<line20>pList = pExpr->x.pList;\n<line21>assert( pList!=0 );\n<line22>if( pList->nExpr==2 ) return 1;\n<line23>if( pList->nExpr==3 && sqlite3ExprIsNotTrue(pList->a[2].pExpr) ) return 1;\n<line24>return 0;\n<line25>}
----------------------------------------
Function: bothImplyNotNullRow
Content: <line0>static void bothImplyNotNullRow(Walker *pWalker, Expr *pE1, Expr *pE2){\n<line1>if( pWalker->eCode==0 ){\n<line2>sqlite3WalkExpr(pWalker, pE1);\n<line3>if( pWalker->eCode ){\n<line4>pWalker->eCode = 0;\n<line5>sqlite3WalkExpr(pWalker, pE2);\n<line6>}\n<line7>}\n<line8>}
----------------------------------------
Function: impliesNotNullRow
Content: <line0>static int impliesNotNullRow(Walker *pWalker, Expr *pExpr){\n<line1>testcase( pExpr->op==TK_AGG_COLUMN );\n<line2>testcase( pExpr->op==TK_AGG_FUNCTION );\n<line3>if( ExprHasProperty(pExpr, EP_OuterON) ) return WRC_Prune;\n<line4>if( ExprHasProperty(pExpr, EP_InnerON) && pWalker->mWFlags ){\n<line5>/* If iCur is used in an inner-join ON clause to the left of a\n<line6>** RIGHT JOIN, that does *not* mean that the table must be non-null.\n<line7>** But it is difficult to check for that condition precisely.\n<line8>** To keep things simple, any use of iCur from any inner-join is\n<line9>** ignored while attempting to simplify a RIGHT JOIN. */\n<line10>return WRC_Prune;\n<line11>}\n<line12>switch( pExpr->op ){\n<line13>case TK_ISNOT:\n<line14>case TK_ISNULL:\n<line15>case TK_NOTNULL:\n<line16>case TK_IS:\n<line17>case TK_VECTOR:\n<line18>case TK_FUNCTION:\n<line19>case TK_TRUTH:\n<line20>case TK_CASE:\n<line21>testcase( pExpr->op==TK_ISNOT );\n<line22>testcase( pExpr->op==TK_ISNULL );\n<line23>testcase( pExpr->op==TK_NOTNULL );\n<line24>testcase( pExpr->op==TK_IS );\n<line25>testcase( pExpr->op==TK_VECTOR );\n<line26>testcase( pExpr->op==TK_FUNCTION );\n<line27>testcase( pExpr->op==TK_TRUTH );\n<line28>testcase( pExpr->op==TK_CASE );\n<line29>return WRC_Prune;\n<line30>case TK_COLUMN:\n<line31>if( pWalker->u.iCur==pExpr->iTable ){\n<line32>pWalker->eCode = 1;\n<line33>return WRC_Abort;\n<line34>}\n<line35>return WRC_Prune;\n<line36>case TK_OR:\n<line37>case TK_AND:\n<line38>/* Both sides of an AND or OR must separately imply non-null-row.\n<line39>** Consider these cases:\n<line40>**    1.  NOT (x AND y)\n<line41>**    2.  x OR y\n<line42>** If only one of x or y is non-null-row, then the overall expression\n<line43>** can be true if the other arm is false (case 1) or true (case 2).\n<line44>*/\n<line45>testcase( pExpr->op==TK_OR );\n<line46>testcase( pExpr->op==TK_AND );\n<line47>bothImplyNotNullRow(pWalker, pExpr->pLeft, pExpr->pRight);\n<line48>return WRC_Prune;\n<line49>case TK_IN:\n<line50>/* Beware of "x NOT IN ()" and "x NOT IN (SELECT 1 WHERE false)",\n<line51>** both of which can be true.  But apart from these cases, if\n<line52>** the left-hand side of the IN is NULL then the IN itself will be\n<line53>** NULL. */\n<line54>if( ExprUseXList(pExpr) && ALWAYS(pExpr->x.pList->nExpr>0) ){\n<line55>sqlite3WalkExpr(pWalker, pExpr->pLeft);\n<line56>}\n<line57>return WRC_Prune;\n<line58>case TK_BETWEEN:\n<line59>/* In "x NOT BETWEEN y AND z" either x must be non-null-row or else\n<line60>** both y and z must be non-null row */\n<line61>assert( ExprUseXList(pExpr) );\n<line62>assert( pExpr->x.pList->nExpr==2 );\n<line63>sqlite3WalkExpr(pWalker, pExpr->pLeft);\n<line64>bothImplyNotNullRow(pWalker, pExpr->x.pList->a[0].pExpr,\n<line65>pExpr->x.pList->a[1].pExpr);\n<line66>return WRC_Prune;\n<line67>/* Virtual tables are allowed to use constraints like x=NULL.  So\n<line68>** a term of the form x=y does not prove that y is not null if x\n<line69>** is the column of a virtual table */\n<line70>case TK_EQ:\n<line71>case TK_NE:\n<line72>case TK_LT:\n<line73>case TK_LE:\n<line74>case TK_GT:\n<line75>case TK_GE: {\n<line76>Expr *pLeft = pExpr->pLeft;\n<line77>Expr *pRight = pExpr->pRight;\n<line78>testcase( pExpr->op==TK_EQ );\n<line79>testcase( pExpr->op==TK_NE );\n<line80>testcase( pExpr->op==TK_LT );\n<line81>testcase( pExpr->op==TK_LE );\n<line82>testcase( pExpr->op==TK_GT );\n<line83>testcase( pExpr->op==TK_GE );\n<line84>/* The y.pTab=0 assignment in wherecode.c always happens after the\n<line85>** impliesNotNullRow() test */\n<line86>assert( pLeft->op!=TK_COLUMN || ExprUseYTab(pLeft) );\n<line87>assert( pRight->op!=TK_COLUMN || ExprUseYTab(pRight) );\n<line88>if( (pLeft->op==TK_COLUMN\n<line89>&& ALWAYS(pLeft->y.pTab!=0)\n<line90>&& IsVirtual(pLeft->y.pTab))\n<line91>|| (pRight->op==TK_COLUMN\n<line92>&& ALWAYS(pRight->y.pTab!=0)\n<line93>&& IsVirtual(pRight->y.pTab))\n<line94>){\n<line95>return WRC_Prune;\n<line96>}\n<line97>/* no break */ deliberate_fall_through\n<line98>}\n<line99>default:\n<line100>return WRC_Continue;\n<line101>}\n<line102>}
----------------------------------------
Function: exprIdxCover
Content: <line0>static int exprIdxCover(Walker *pWalker, Expr *pExpr){\n<line1>if( pExpr->op==TK_COLUMN\n<line2>&& pExpr->iTable==pWalker->u.pIdxCover->iCur\n<line3>&& sqlite3TableColumnToIndex(pWalker->u.pIdxCover->pIdx, pExpr->iColumn)<0\n<line4>){\n<line5>pWalker->eCode = 1;\n<line6>return WRC_Abort;\n<line7>}\n<line8>return WRC_Continue;\n<line9>}
----------------------------------------
Function: selectRefEnter
Content: <line0>static int selectRefEnter(Walker *pWalker, Select *pSelect){\n<line1>struct RefSrcList *p = pWalker->u.pRefSrcList;\n<line2>SrcList *pSrc = pSelect->pSrc;\n<line3>i64 i, j;\n<line4>int *piNew;\n<line5>if( pSrc->nSrc==0 ) return WRC_Continue;\n<line6>j = p->nExclude;\n<line7>p->nExclude += pSrc->nSrc;\n<line8>piNew = sqlite3DbRealloc(p->db, p->aiExclude, p->nExclude*sizeof(int));\n<line9>if( piNew==0 ){\n<line10>p->nExclude = 0;\n<line11>return WRC_Abort;\n<line12>}else{\n<line13>p->aiExclude = piNew;\n<line14>}\n<line15>for(i=0; i<pSrc->nSrc; i++, j++){\n<line16>p->aiExclude[j] = pSrc->a[i].iCursor;\n<line17>}\n<line18>return WRC_Continue;\n<line19>}
----------------------------------------
Function: selectRefLeave
Content: <line0>static void selectRefLeave(Walker *pWalker, Select *pSelect){\n<line1>struct RefSrcList *p = pWalker->u.pRefSrcList;\n<line2>SrcList *pSrc = pSelect->pSrc;\n<line3>if( p->nExclude ){\n<line4>assert( p->nExclude>=pSrc->nSrc );\n<line5>p->nExclude -= pSrc->nSrc;\n<line6>}\n<line7>}
----------------------------------------
Function: exprRefToSrcList
Content: <line0>static int exprRefToSrcList(Walker *pWalker, Expr *pExpr){\n<line1>if( pExpr->op==TK_COLUMN\n<line2>|| pExpr->op==TK_AGG_COLUMN\n<line3>){\n<line4>int i;\n<line5>struct RefSrcList *p = pWalker->u.pRefSrcList;\n<line6>SrcList *pSrc = p->pRef;\n<line7>int nSrc = pSrc ? pSrc->nSrc : 0;\n<line8>for(i=0; i<nSrc; i++){\n<line9>if( pExpr->iTable==pSrc->a[i].iCursor ){\n<line10>pWalker->eCode |= 1;\n<line11>return WRC_Continue;\n<line12>}\n<line13>}\n<line14>for(i=0; i<p->nExclude && p->aiExclude[i]!=pExpr->iTable; i++){}\n<line15>if( i>=p->nExclude ){\n<line16>pWalker->eCode |= 2;\n<line17>}\n<line18>}\n<line19>return WRC_Continue;\n<line20>}
----------------------------------------
Function: agginfoPersistExprCb
Content: <line0>static int agginfoPersistExprCb(Walker *pWalker, Expr *pExpr){\n<line1>if( ALWAYS(!ExprHasProperty(pExpr, EP_TokenOnly|EP_Reduced))\n<line2>&& pExpr->pAggInfo!=0\n<line3>){\n<line4>AggInfo *pAggInfo = pExpr->pAggInfo;\n<line5>int iAgg = pExpr->iAgg;\n<line6>Parse *pParse = pWalker->pParse;\n<line7>sqlite3 *db = pParse->db;\n<line8>assert( iAgg>=0 );\n<line9>if( pExpr->op!=TK_AGG_FUNCTION ){\n<line10>if( iAgg<pAggInfo->nColumn\n<line11>&& pAggInfo->aCol[iAgg].pCExpr==pExpr\n<line12>){\n<line13>pExpr = sqlite3ExprDup(db, pExpr, 0);\n<line14>if( pExpr && !sqlite3ExprDeferredDelete(pParse, pExpr) ){\n<line15>pAggInfo->aCol[iAgg].pCExpr = pExpr;\n<line16>}\n<line17>}\n<line18>}else{\n<line19>assert( pExpr->op==TK_AGG_FUNCTION );\n<line20>if( ALWAYS(iAgg<pAggInfo->nFunc)\n<line21>&& pAggInfo->aFunc[iAgg].pFExpr==pExpr\n<line22>){\n<line23>pExpr = sqlite3ExprDup(db, pExpr, 0);\n<line24>if( pExpr && !sqlite3ExprDeferredDelete(pParse, pExpr) ){\n<line25>pAggInfo->aFunc[iAgg].pFExpr = pExpr;\n<line26>}\n<line27>}\n<line28>}\n<line29>}\n<line30>return WRC_Continue;\n<line31>}
----------------------------------------
Function: addAggInfoColumn
Content: <line0>static int addAggInfoColumn(sqlite3 *db, AggInfo *pInfo){\n<line1>int i;\n<line2>pInfo->aCol = sqlite3ArrayAllocate(\n<line3>db,\n<line4>pInfo->aCol,\n<line5>sizeof(pInfo->aCol[0]),\n<line6>&pInfo->nColumn,\n<line7>&i\n<line8>);\n<line9>return i;\n<line10>}
----------------------------------------
Function: addAggInfoFunc
Content: <line0>static int addAggInfoFunc(sqlite3 *db, AggInfo *pInfo){\n<line1>int i;\n<line2>pInfo->aFunc = sqlite3ArrayAllocate(\n<line3>db,\n<line4>pInfo->aFunc,\n<line5>sizeof(pInfo->aFunc[0]),\n<line6>&pInfo->nFunc,\n<line7>&i\n<line8>);\n<line9>return i;\n<line10>}
----------------------------------------
Function: findOrCreateAggInfoColumn
Content: <line0>static void findOrCreateAggInfoColumn(\n<line1>Parse *pParse,       /* Parsing context */\n<line2>AggInfo *pAggInfo,   /* The AggInfo object to search and/or modify */\n<line3>Expr *pExpr          /* Expr describing the column to find or insert */\n<line4>){\n<line5>struct AggInfo_col *pCol;\n<line6>int k;\n<line7>int mxTerm = pParse->db->aLimit[SQLITE_LIMIT_COLUMN];\n<line8>assert( mxTerm <= SMXV(i16) );\n<line9>assert( pAggInfo->iFirstReg==0 );\n<line10>pCol = pAggInfo->aCol;\n<line11>for(k=0; k<pAggInfo->nColumn; k++, pCol++){\n<line12>if( pCol->pCExpr==pExpr ) return;\n<line13>if( pCol->iTable==pExpr->iTable\n<line14>&& pCol->iColumn==pExpr->iColumn\n<line15>&& pExpr->op!=TK_IF_NULL_ROW\n<line16>){\n<line17>goto fix_up_expr;\n<line18>}\n<line19>}\n<line20>k = addAggInfoColumn(pParse->db, pAggInfo);\n<line21>if( k<0 ){\n<line22>/* OOM on resize */\n<line23>assert( pParse->db->mallocFailed );\n<line24>return;\n<line25>}\n<line26>if( k>mxTerm ){\n<line27>sqlite3ErrorMsg(pParse, "more than %d aggregate terms", mxTerm);\n<line28>k = mxTerm;\n<line29>}\n<line30>pCol = &pAggInfo->aCol[k];\n<line31>assert( ExprUseYTab(pExpr) );\n<line32>pCol->pTab = pExpr->y.pTab;\n<line33>pCol->iTable = pExpr->iTable;\n<line34>pCol->iColumn = pExpr->iColumn;\n<line35>pCol->iSorterColumn = -1;\n<line36>pCol->pCExpr = pExpr;\n<line37>if( pAggInfo->pGroupBy && pExpr->op!=TK_IF_NULL_ROW ){\n<line38>int j, n;\n<line39>ExprList *pGB = pAggInfo->pGroupBy;\n<line40>struct ExprList_item *pTerm = pGB->a;\n<line41>n = pGB->nExpr;\n<line42>for(j=0; j<n; j++, pTerm++){\n<line43>Expr *pE = pTerm->pExpr;\n<line44>if( pE->op==TK_COLUMN\n<line45>&& pE->iTable==pExpr->iTable\n<line46>&& pE->iColumn==pExpr->iColumn\n<line47>){\n<line48>pCol->iSorterColumn = j;\n<line49>break;\n<line50>}\n<line51>}\n<line52>}\n<line53>if( pCol->iSorterColumn<0 ){\n<line54>pCol->iSorterColumn = pAggInfo->nSortingColumn++;\n<line55>}\n<line56>fix_up_expr:\n<line57>ExprSetVVAProperty(pExpr, EP_NoReduce);\n<line58>assert( pExpr->pAggInfo==0 || pExpr->pAggInfo==pAggInfo );\n<line59>pExpr->pAggInfo = pAggInfo;\n<line60>if( pExpr->op==TK_COLUMN ){\n<line61>pExpr->op = TK_AGG_COLUMN;\n<line62>}\n<line63>assert( k <= SMXV(pExpr->iAgg) );\n<line64>pExpr->iAgg = (i16)k;\n<line65>}
----------------------------------------
Function: analyzeAggregate
Content: <line0>static int analyzeAggregate(Walker *pWalker, Expr *pExpr){\n<line1>int i;\n<line2>NameContext *pNC = pWalker->u.pNC;\n<line3>Parse *pParse = pNC->pParse;\n<line4>SrcList *pSrcList = pNC->pSrcList;\n<line5>AggInfo *pAggInfo = pNC->uNC.pAggInfo;\n<line6>assert( pNC->ncFlags & NC_UAggInfo );\n<line7>assert( pAggInfo->iFirstReg==0 );\n<line8>switch( pExpr->op ){\n<line9>default: {\n<line10>IndexedExpr *pIEpr;\n<line11>Expr tmp;\n<line12>assert( pParse->iSelfTab==0 );\n<line13>if( (pNC->ncFlags & NC_InAggFunc)==0 ) break;\n<line14>if( pParse->pIdxEpr==0 ) break;\n<line15>for(pIEpr=pParse->pIdxEpr; pIEpr; pIEpr=pIEpr->pIENext){\n<line16>int iDataCur = pIEpr->iDataCur;\n<line17>if( iDataCur<0 ) continue;\n<line18>if( sqlite3ExprCompare(0, pExpr, pIEpr->pExpr, iDataCur)==0 ) break;\n<line19>}\n<line20>if( pIEpr==0 ) break;\n<line21>if( NEVER(!ExprUseYTab(pExpr)) ) break;\n<line22>for(i=0; i<pSrcList->nSrc; i++){\n<line23>if( pSrcList->a[0].iCursor==pIEpr->iDataCur ) break;\n<line24>}\n<line25>if( i>=pSrcList->nSrc ) break;\n<line26>if( NEVER(pExpr->pAggInfo!=0) ) break; /* Resolved by outer context */\n<line27>if( pParse->nErr ){ return WRC_Abort; }\n<line28>/* If we reach this point, it means that expression pExpr can be\n<line29>** translated into a reference to an index column as described by\n<line30>** pIEpr.\n<line31>*/\n<line32>memset(&tmp, 0, sizeof(tmp));\n<line33>tmp.op = TK_AGG_COLUMN;\n<line34>tmp.iTable = pIEpr->iIdxCur;\n<line35>tmp.iColumn = pIEpr->iIdxCol;\n<line36>findOrCreateAggInfoColumn(pParse, pAggInfo, &tmp);\n<line37>if( pParse->nErr ){ return WRC_Abort; }\n<line38>assert( pAggInfo->aCol!=0 );\n<line39>assert( tmp.iAgg<pAggInfo->nColumn );\n<line40>pAggInfo->aCol[tmp.iAgg].pCExpr = pExpr;\n<line41>pExpr->pAggInfo = pAggInfo;\n<line42>pExpr->iAgg = tmp.iAgg;\n<line43>return WRC_Prune;\n<line44>}\n<line45>case TK_IF_NULL_ROW:\n<line46>case TK_AGG_COLUMN:\n<line47>case TK_COLUMN: {\n<line48>testcase( pExpr->op==TK_AGG_COLUMN );\n<line49>testcase( pExpr->op==TK_COLUMN );\n<line50>testcase( pExpr->op==TK_IF_NULL_ROW );\n<line51>/* Check to see if the column is in one of the tables in the FROM\n<line52>** clause of the aggregate query */\n<line53>if( ALWAYS(pSrcList!=0) ){\n<line54>SrcItem *pItem = pSrcList->a;\n<line55>for(i=0; i<pSrcList->nSrc; i++, pItem++){\n<line56>assert( !ExprHasProperty(pExpr, EP_TokenOnly|EP_Reduced) );\n<line57>if( pExpr->iTable==pItem->iCursor ){\n<line58>findOrCreateAggInfoColumn(pParse, pAggInfo, pExpr);\n<line59>break;\n<line60>} /* endif pExpr->iTable==pItem->iCursor */\n<line61>} /* end loop over pSrcList */\n<line62>}\n<line63>return WRC_Continue;\n<line64>}\n<line65>case TK_AGG_FUNCTION: {\n<line66>if( (pNC->ncFlags & NC_InAggFunc)==0\n<line67>&& pWalker->walkerDepth==pExpr->op2\n<line68>&& pExpr->pAggInfo==0\n<line69>){\n<line70>/* Check to see if pExpr is a duplicate of another aggregate\n<line71>** function that is already in the pAggInfo structure\n<line72>*/\n<line73>struct AggInfo_func *pItem = pAggInfo->aFunc;\n<line74>int mxTerm = pParse->db->aLimit[SQLITE_LIMIT_COLUMN];\n<line75>assert( mxTerm <= SMXV(i16) );\n<line76>for(i=0; i<pAggInfo->nFunc; i++, pItem++){\n<line77>if( NEVER(pItem->pFExpr==pExpr) ) break;\n<line78>if( sqlite3ExprCompare(0, pItem->pFExpr, pExpr, -1)==0 ){\n<line79>break;\n<line80>}\n<line81>}\n<line82>if( i>mxTerm ){\n<line83>sqlite3ErrorMsg(pParse, "more than %d aggregate terms", mxTerm);\n<line84>i = mxTerm;\n<line85>assert( i<pAggInfo->nFunc );\n<line86>}else if( i>=pAggInfo->nFunc ){\n<line87>/* pExpr is original.  Make a new entry in pAggInfo->aFunc[]\n<line88>*/\n<line89>u8 enc = ENC(pParse->db);\n<line90>i = addAggInfoFunc(pParse->db, pAggInfo);\n<line91>if( i>=0 ){\n<line92>int nArg;\n<line93>assert( !ExprHasProperty(pExpr, EP_xIsSelect) );\n<line94>pItem = &pAggInfo->aFunc[i];\n<line95>pItem->pFExpr = pExpr;\n<line96>assert( ExprUseUToken(pExpr) );\n<line97>nArg = pExpr->x.pList ? pExpr->x.pList->nExpr : 0;\n<line98>pItem->pFunc = sqlite3FindFunction(pParse->db,\n<line99>pExpr->u.zToken, nArg, enc, 0);\n<line100>assert( pItem->bOBUnique==0 );\n<line101>if( pExpr->pLeft\n<line102>&& (pItem->pFunc->funcFlags & SQLITE_FUNC_NEEDCOLL)==0\n<line103>){\n<line104>/* The NEEDCOLL test above causes any ORDER BY clause on\n<line105>** aggregate min() or max() to be ignored. */\n<line106>ExprList *pOBList;\n<line107>assert( nArg>0 );\n<line108>assert( pExpr->pLeft->op==TK_ORDER );\n<line109>assert( ExprUseXList(pExpr->pLeft) );\n<line110>pItem->iOBTab = pParse->nTab++;\n<line111>pOBList = pExpr->pLeft->x.pList;\n<line112>assert( pOBList->nExpr>0 );\n<line113>assert( pItem->bOBUnique==0 );\n<line114>if( pOBList->nExpr==1\n<line115>&& nArg==1\n<line116>&& sqlite3ExprCompare(0,pOBList->a[0].pExpr,\n<line117>pExpr->x.pList->a[0].pExpr,0)==0\n<line118>){\n<line119>pItem->bOBPayload = 0;\n<line120>pItem->bOBUnique = ExprHasProperty(pExpr, EP_Distinct);\n<line121>}else{\n<line122>pItem->bOBPayload = 1;\n<line123>}\n<line124>pItem->bUseSubtype =\n<line125>(pItem->pFunc->funcFlags & SQLITE_SUBTYPE)!=0;\n<line126>}else{\n<line127>pItem->iOBTab = -1;\n<line128>}\n<line129>if( ExprHasProperty(pExpr, EP_Distinct) && !pItem->bOBUnique ){\n<line130>pItem->iDistinct = pParse->nTab++;\n<line131>}else{\n<line132>pItem->iDistinct = -1;\n<line133>}\n<line134>}\n<line135>}\n<line136>/* Make pExpr point to the appropriate pAggInfo->aFunc[] entry\n<line137>*/\n<line138>assert( !ExprHasProperty(pExpr, EP_TokenOnly|EP_Reduced) );\n<line139>ExprSetVVAProperty(pExpr, EP_NoReduce);\n<line140>assert( i <= SMXV(pExpr->iAgg) );\n<line141>pExpr->iAgg = (i16)i;\n<line142>pExpr->pAggInfo = pAggInfo;\n<line143>return WRC_Prune;\n<line144>}else{\n<line145>return WRC_Continue;\n<line146>}\n<line147>}\n<line148>}\n<line149>return WRC_Continue;\n<line150>}
----------------------------------------
Function: isAlterableTable
Content: <line0>static int isAlterableTable(Parse *pParse, Table *pTab){\n<line1>if( 0==sqlite3StrNICmp(pTab->zName, "sqlite_", 7)\n<line2>#ifndef SQLITE_OMIT_VIRTUALTABLE\n<line3>|| (pTab->tabFlags & TF_Eponymous)!=0\n<line4>|| ( (pTab->tabFlags & TF_Shadow)!=0\n<line5>&& sqlite3ReadOnlyShadowTables(pParse->db)\n<line6>)\n<line7>#endif\n<line8>){\n<line9>sqlite3ErrorMsg(pParse, "table %s may not be altered", pTab->zName);\n<line10>return 1;\n<line11>}\n<line12>return 0;\n<line13>}
----------------------------------------
Function: renameTestSchema
Content: <line0>static void renameTestSchema(\n<line1>Parse *pParse,                  /* Parse context */\n<line2>const char *zDb,                /* Name of db to verify schema of */\n<line3>int bTemp,                      /* True if this is the temp db */\n<line4>const char *zWhen,              /* "when" part of error message */\n<line5>int bNoDQS                      /* Do not allow DQS in the schema */\n<line6>){\n<line7>pParse->colNamesSet = 1;\n<line8>sqlite3NestedParse(pParse,\n<line9>"SELECT 1 "\n<line10>"FROM \"%w\"." LEGACY_SCHEMA_TABLE " "\n<line11>"WHERE name NOT LIKE 'sqliteX_%%' ESCAPE 'X'"\n<line12>" AND sql NOT LIKE 'create virtual%%'"\n<line13>" AND sqlite_rename_test(%Q, sql, type, name, %d, %Q, %d)=NULL ",\n<line14>zDb,\n<line15>zDb, bTemp, zWhen, bNoDQS\n<line16>);\n<line17>if( bTemp==0 ){\n<line18>sqlite3NestedParse(pParse,\n<line19>"SELECT 1 "\n<line20>"FROM temp." LEGACY_SCHEMA_TABLE " "\n<line21>"WHERE name NOT LIKE 'sqliteX_%%' ESCAPE 'X'"\n<line22>" AND sql NOT LIKE 'create virtual%%'"\n<line23>" AND sqlite_rename_test(%Q, sql, type, name, 1, %Q, %d)=NULL ",\n<line24>zDb, zWhen, bNoDQS\n<line25>);\n<line26>}\n<line27>}
----------------------------------------
Function: renameFixQuotes
Content: <line0>static void renameFixQuotes(Parse *pParse, const char *zDb, int bTemp){\n<line1>sqlite3NestedParse(pParse,\n<line2>"UPDATE \"%w\"." LEGACY_SCHEMA_TABLE\n<line3>" SET sql = sqlite_rename_quotefix(%Q, sql)"\n<line4>"WHERE name NOT LIKE 'sqliteX_%%' ESCAPE 'X'"\n<line5>" AND sql NOT LIKE 'create virtual%%'" , zDb, zDb\n<line6>);\n<line7>if( bTemp==0 ){\n<line8>sqlite3NestedParse(pParse,\n<line9>"UPDATE temp." LEGACY_SCHEMA_TABLE\n<line10>" SET sql = sqlite_rename_quotefix('temp', sql)"\n<line11>"WHERE name NOT LIKE 'sqliteX_%%' ESCAPE 'X'"\n<line12>" AND sql NOT LIKE 'create virtual%%'"\n<line13>);\n<line14>}\n<line15>}
----------------------------------------
Function: renameReloadSchema
Content: <line0>static void renameReloadSchema(Parse *pParse, int iDb, u16 p5){\n<line1>Vdbe *v = pParse->pVdbe;\n<line2>if( v ){\n<line3>sqlite3ChangeCookie(pParse, iDb);\n<line4>sqlite3VdbeAddParseSchemaOp(pParse->pVdbe, iDb, 0, p5);\n<line5>if( iDb!=1 ) sqlite3VdbeAddParseSchemaOp(pParse->pVdbe, 1, 0, p5);\n<line6>}\n<line7>}
----------------------------------------
Function: sqlite3ErrorIfNotEmpty
Content: <line0>static void sqlite3ErrorIfNotEmpty(\n<line1>Parse *pParse,        /* Parsing context */\n<line2>const char *zDb,      /* Schema holding the table */\n<line3>const char *zTab,     /* Table to check for empty */\n<line4>const char *zErr      /* Error message text */\n<line5>){\n<line6>sqlite3NestedParse(pParse,\n<line7>"SELECT raise(ABORT,%Q) FROM \"%w\".\"%w\"",\n<line8>zErr, zDb, zTab\n<line9>);\n<line10>}
----------------------------------------
Function: isRealTable
Content: <line0>static int isRealTable(Parse *pParse, Table *pTab, int bDrop){\n<line1>const char *zType = 0;\n<line2>#ifndef SQLITE_OMIT_VIEW\n<line3>if( IsView(pTab) ){\n<line4>zType = "view";\n<line5>}\n<line6>#endif\n<line7>#ifndef SQLITE_OMIT_VIRTUALTABLE\n<line8>if( IsVirtual(pTab) ){\n<line9>zType = "virtual table";\n<line10>}\n<line11>#endif\n<line12>if( zType ){\n<line13>sqlite3ErrorMsg(pParse, "cannot %s %s \"%s\"",\n<line14>(bDrop ? "drop column from" : "rename columns of"),\n<line15>zType, pTab->zName\n<line16>);\n<line17>return 1;\n<line18>}\n<line19>return 0;\n<line20>}
----------------------------------------
Function: renameUnmapExprCb
Content: <line0>static int renameUnmapExprCb(Walker *pWalker, Expr *pExpr){\n<line1>Parse *pParse = pWalker->pParse;\n<line2>sqlite3RenameTokenRemap(pParse, 0, (const void*)pExpr);\n<line3>if( ExprUseYTab(pExpr) ){\n<line4>sqlite3RenameTokenRemap(pParse, 0, (const void*)&pExpr->y.pTab);\n<line5>}\n<line6>return WRC_Continue;\n<line7>}
----------------------------------------
Function: renameWalkWith
Content: <line0>static void renameWalkWith(Walker *pWalker, Select *pSelect){\n<line1>With *pWith = pSelect->pWith;\n<line2>if( pWith ){\n<line3>Parse *pParse = pWalker->pParse;\n<line4>int i;\n<line5>With *pCopy = 0;\n<line6>assert( pWith->nCte>0 );\n<line7>if( (pWith->a[0].pSelect->selFlags & SF_Expanded)==0 ){\n<line8>/* Push a copy of the With object onto the with-stack. We use a copy\n<line9>** here as the original will be expanded and resolved (flags SF_Expanded\n<line10>** and SF_Resolved) below. And the parser code that uses the with-stack\n<line11>** fails if the Select objects on it have already been expanded and\n<line12>** resolved.  */\n<line13>pCopy = sqlite3WithDup(pParse->db, pWith);\n<line14>pCopy = sqlite3WithPush(pParse, pCopy, 1);\n<line15>}\n<line16>for(i=0; i<pWith->nCte; i++){\n<line17>Select *p = pWith->a[i].pSelect;\n<line18>NameContext sNC;\n<line19>memset(&sNC, 0, sizeof(sNC));\n<line20>sNC.pParse = pParse;\n<line21>if( pCopy ) sqlite3SelectPrep(sNC.pParse, p, &sNC);\n<line22>if( sNC.pParse->db->mallocFailed ) return;\n<line23>sqlite3WalkSelect(pWalker, p);\n<line24>sqlite3RenameExprlistUnmap(pParse, pWith->a[i].pCols);\n<line25>}\n<line26>if( pCopy && pParse->pWith==pCopy ){\n<line27>pParse->pWith = pCopy->pOuter;\n<line28>}\n<line29>}\n<line30>}
----------------------------------------
Function: unmapColumnIdlistNames
Content: <line0>static void unmapColumnIdlistNames(\n<line1>Parse *pParse,\n<line2>const IdList *pIdList\n<line3>){\n<line4>int ii;\n<line5>assert( pIdList!=0 );\n<line6>for(ii=0; ii<pIdList->nId; ii++){\n<line7>sqlite3RenameTokenRemap(pParse, 0, (const void*)pIdList->a[ii].zName);\n<line8>}\n<line9>}
----------------------------------------
Function: renameUnmapSelectCb
Content: <line0>static int renameUnmapSelectCb(Walker *pWalker, Select *p){\n<line1>Parse *pParse = pWalker->pParse;\n<line2>int i;\n<line3>if( pParse->nErr ) return WRC_Abort;\n<line4>testcase( p->selFlags & SF_View );\n<line5>testcase( p->selFlags & SF_CopyCte );\n<line6>if( p->selFlags & (SF_View|SF_CopyCte) ){\n<line7>return WRC_Prune;\n<line8>}\n<line9>if( ALWAYS(p->pEList) ){\n<line10>ExprList *pList = p->pEList;\n<line11>for(i=0; i<pList->nExpr; i++){\n<line12>if( pList->a[i].zEName && pList->a[i].fg.eEName==ENAME_NAME ){\n<line13>sqlite3RenameTokenRemap(pParse, 0, (void*)pList->a[i].zEName);\n<line14>}\n<line15>}\n<line16>}\n<line17>if( ALWAYS(p->pSrc) ){  /* Every Select as a SrcList, even if it is empty */\n<line18>SrcList *pSrc = p->pSrc;\n<line19>for(i=0; i<pSrc->nSrc; i++){\n<line20>sqlite3RenameTokenRemap(pParse, 0, (void*)pSrc->a[i].zName);\n<line21>if( pSrc->a[i].fg.isUsing==0 ){\n<line22>sqlite3WalkExpr(pWalker, pSrc->a[i].u3.pOn);\n<line23>}else{\n<line24>unmapColumnIdlistNames(pParse, pSrc->a[i].u3.pUsing);\n<line25>}\n<line26>}\n<line27>}\n<line28>renameWalkWith(pWalker, p);\n<line29>return WRC_Continue;\n<line30>}
----------------------------------------
Function: renameTokenFree
Content: <line0>static void renameTokenFree(sqlite3 *db, RenameToken *pToken){\n<line1>RenameToken *pNext;\n<line2>RenameToken *p;\n<line3>for(p=pToken; p; p=pNext){\n<line4>pNext = p->pNext;\n<line5>sqlite3DbFree(db, p);\n<line6>}\n<line7>}
----------------------------------------
Function: renameTokenFind
Content: <line0>static RenameToken *renameTokenFind(\n<line1>Parse *pParse,\n<line2>struct RenameCtx *pCtx,\n<line3>const void *pPtr\n<line4>){\n<line5>RenameToken **pp;\n<line6>if( NEVER(pPtr==0) ){\n<line7>return 0;\n<line8>}\n<line9>for(pp=&pParse->pRename; (*pp); pp=&(*pp)->pNext){\n<line10>if( (*pp)->p==pPtr ){\n<line11>RenameToken *pToken = *pp;\n<line12>if( pCtx ){\n<line13>*pp = pToken->pNext;\n<line14>pToken->pNext = pCtx->pList;\n<line15>pCtx->pList = pToken;\n<line16>pCtx->nList++;\n<line17>}\n<line18>return pToken;\n<line19>}\n<line20>}\n<line21>return 0;\n<line22>}
----------------------------------------
Function: renameColumnSelectCb
Content: <line0>static int renameColumnSelectCb(Walker *pWalker, Select *p){\n<line1>if( p->selFlags & (SF_View|SF_CopyCte) ){\n<line2>testcase( p->selFlags & SF_View );\n<line3>testcase( p->selFlags & SF_CopyCte );\n<line4>return WRC_Prune;\n<line5>}\n<line6>renameWalkWith(pWalker, p);\n<line7>return WRC_Continue;\n<line8>}
----------------------------------------
Function: renameColumnExprCb
Content: <line0>static int renameColumnExprCb(Walker *pWalker, Expr *pExpr){\n<line1>RenameCtx *p = pWalker->u.pRename;\n<line2>if( pExpr->op==TK_TRIGGER\n<line3>&& pExpr->iColumn==p->iCol\n<line4>&& pWalker->pParse->pTriggerTab==p->pTab\n<line5>){\n<line6>renameTokenFind(pWalker->pParse, p, (void*)pExpr);\n<line7>}else if( pExpr->op==TK_COLUMN\n<line8>&& pExpr->iColumn==p->iCol\n<line9>&& ALWAYS(ExprUseYTab(pExpr))\n<line10>&& p->pTab==pExpr->y.pTab\n<line11>){\n<line12>renameTokenFind(pWalker->pParse, p, (void*)pExpr);\n<line13>}\n<line14>return WRC_Continue;\n<line15>}
----------------------------------------
Function: renameColumnTokenNext
Content: <line0>static RenameToken *renameColumnTokenNext(RenameCtx *pCtx){\n<line1>RenameToken *pBest = pCtx->pList;\n<line2>RenameToken *pToken;\n<line3>RenameToken **pp;\n<line4>for(pToken=pBest->pNext; pToken; pToken=pToken->pNext){\n<line5>if( pToken->t.z>pBest->t.z ) pBest = pToken;\n<line6>}\n<line7>for(pp=&pCtx->pList; *pp!=pBest; pp=&(*pp)->pNext);\n<line8>*pp = pBest->pNext;\n<line9>return pBest;\n<line10>}
----------------------------------------
Function: renameColumnParseError
Content: <line0>static void renameColumnParseError(\n<line1>sqlite3_context *pCtx,\n<line2>const char *zWhen,\n<line3>sqlite3_value *pType,\n<line4>sqlite3_value *pObject,\n<line5>Parse *pParse\n<line6>){\n<line7>const char *zT = (const char*)sqlite3_value_text(pType);\n<line8>const char *zN = (const char*)sqlite3_value_text(pObject);\n<line9>char *zErr;\n<line10>zErr = sqlite3MPrintf(pParse->db, "error in %s %s%s%s: %s",\n<line11>zT, zN, (zWhen[0] ? " " : ""), zWhen,\n<line12>pParse->zErrMsg\n<line13>);\n<line14>sqlite3_result_error(pCtx, zErr, -1);\n<line15>sqlite3DbFree(pParse->db, zErr);\n<line16>}
----------------------------------------
Function: renameColumnElistNames
Content: <line0>static void renameColumnElistNames(\n<line1>Parse *pParse,\n<line2>RenameCtx *pCtx,\n<line3>const ExprList *pEList,\n<line4>const char *zOld\n<line5>){\n<line6>if( pEList ){\n<line7>int i;\n<line8>for(i=0; i<pEList->nExpr; i++){\n<line9>const char *zName = pEList->a[i].zEName;\n<line10>if( ALWAYS(pEList->a[i].fg.eEName==ENAME_NAME)\n<line11>&& ALWAYS(zName!=0)\n<line12>&& 0==sqlite3_stricmp(zName, zOld)\n<line13>){\n<line14>renameTokenFind(pParse, pCtx, (const void*)zName);\n<line15>}\n<line16>}\n<line17>}\n<line18>}
----------------------------------------
Function: renameColumnIdlistNames
Content: <line0>static void renameColumnIdlistNames(\n<line1>Parse *pParse,\n<line2>RenameCtx *pCtx,\n<line3>const IdList *pIdList,\n<line4>const char *zOld\n<line5>){\n<line6>if( pIdList ){\n<line7>int i;\n<line8>for(i=0; i<pIdList->nId; i++){\n<line9>const char *zName = pIdList->a[i].zName;\n<line10>if( 0==sqlite3_stricmp(zName, zOld) ){\n<line11>renameTokenFind(pParse, pCtx, (const void*)zName);\n<line12>}\n<line13>}\n<line14>}\n<line15>}
----------------------------------------
Function: renameParseSql
Content: <line0>static int renameParseSql(\n<line1>Parse *p,                       /* Memory to use for Parse object */\n<line2>const char *zDb,                /* Name of schema SQL belongs to */\n<line3>sqlite3 *db,                    /* Database handle */\n<line4>const char *zSql,               /* SQL to parse */\n<line5>int bTemp                       /* True if SQL is from temp schema */\n<line6>){\n<line7>int rc;\n<line8>u64 flags;\n<line9>sqlite3ParseObjectInit(p, db);\n<line10>if( zSql==0 ){\n<line11>return SQLITE_NOMEM;\n<line12>}\n<line13>if( sqlite3StrNICmp(zSql,"CREATE ",7)!=0 ){\n<line14>return SQLITE_CORRUPT_BKPT;\n<line15>}\n<line16>if( bTemp ){\n<line17>db->init.iDb = 1;\n<line18>}else{\n<line19>int iDb = sqlite3FindDbName(db, zDb);\n<line20>assert( iDb>=0 && iDb<=0xff );\n<line21>db->init.iDb = (u8)iDb;\n<line22>}\n<line23>p->eParseMode = PARSE_MODE_RENAME;\n<line24>p->db = db;\n<line25>p->nQueryLoop = 1;\n<line26>flags = db->flags;\n<line27>testcase( (db->flags & SQLITE_Comments)==0 && strstr(zSql," /* ")!=0 );\n<line28>db->flags |= SQLITE_Comments;\n<line29>rc = sqlite3RunParser(p, zSql);\n<line30>db->flags = flags;\n<line31>if( db->mallocFailed ) rc = SQLITE_NOMEM;\n<line32>if( rc==SQLITE_OK\n<line33>&& NEVER(p->pNewTable==0 && p->pNewIndex==0 && p->pNewTrigger==0)\n<line34>){\n<line35>rc = SQLITE_CORRUPT_BKPT;\n<line36>}\n<line37>#ifdef SQLITE_DEBUG\n<line38>/* Ensure that all mappings in the Parse.pRename list really do map to\n<line39>** a part of the input string.  */\n<line40>if( rc==SQLITE_OK ){\n<line41>int nSql = sqlite3Strlen30(zSql);\n<line42>RenameToken *pToken;\n<line43>for(pToken=p->pRename; pToken; pToken=pToken->pNext){\n<line44>assert( pToken->t.z>=zSql && &pToken->t.z[pToken->t.n]<=&zSql[nSql] );\n<line45>}\n<line46>}\n<line47>#endif\n<line48>db->init.iDb = 0;\n<line49>return rc;\n<line50>}
----------------------------------------
Function: renameEditSql
Content: <line0>static int renameEditSql(\n<line1>sqlite3_context *pCtx,          /* Return result here */\n<line2>RenameCtx *pRename,             /* Rename context */\n<line3>const char *zSql,               /* SQL statement to edit */\n<line4>const char *zNew,               /* New token text */\n<line5>int bQuote                      /* True to always quote token */\n<line6>){\n<line7>i64 nNew = sqlite3Strlen30(zNew);\n<line8>i64 nSql = sqlite3Strlen30(zSql);\n<line9>sqlite3 *db = sqlite3_context_db_handle(pCtx);\n<line10>int rc = SQLITE_OK;\n<line11>char *zQuot = 0;\n<line12>char *zOut;\n<line13>i64 nQuot = 0;\n<line14>char *zBuf1 = 0;\n<line15>char *zBuf2 = 0;\n<line16>if( zNew ){\n<line17>/* Set zQuot to point to a buffer containing a quoted copy of the\n<line18>** identifier zNew. If the corresponding identifier in the original\n<line19>** ALTER TABLE statement was quoted (bQuote==1), then set zNew to\n<line20>** point to zQuot so that all substitutions are made using the\n<line21>** quoted version of the new column name.  */\n<line22>zQuot = sqlite3MPrintf(db, "\"%w\" ", zNew);\n<line23>if( zQuot==0 ){\n<line24>return SQLITE_NOMEM;\n<line25>}else{\n<line26>nQuot = sqlite3Strlen30(zQuot)-1;\n<line27>}\n<line28>assert( nQuot>=nNew && nSql>=0 && nNew>=0 );\n<line29>zOut = sqlite3DbMallocZero(db, (u64)nSql + pRename->nList*(u64)nQuot + 1);\n<line30>}else{\n<line31>assert( nSql>0 );\n<line32>zOut = (char*)sqlite3DbMallocZero(db, (2*(u64)nSql + 1) * 3);\n<line33>if( zOut ){\n<line34>zBuf1 = &zOut[nSql*2+1];\n<line35>zBuf2 = &zOut[nSql*4+2];\n<line36>}\n<line37>}\n<line38>/* At this point pRename->pList contains a list of RenameToken objects\n<line39>** corresponding to all tokens in the input SQL that must be replaced\n<line40>** with the new column name, or with single-quoted versions of themselves.\n<line41>** All that remains is to construct and return the edited SQL string. */\n<line42>if( zOut ){\n<line43>i64 nOut = nSql;\n<line44>assert( nSql>0 );\n<line45>memcpy(zOut, zSql, (size_t)nSql);\n<line46>while( pRename->pList ){\n<line47>int iOff;                   /* Offset of token to replace in zOut */\n<line48>i64 nReplace;\n<line49>const char *zReplace;\n<line50>RenameToken *pBest = renameColumnTokenNext(pRename);\n<line51>if( zNew ){\n<line52>if( bQuote==0 && sqlite3IsIdChar(*(u8*)pBest->t.z) ){\n<line53>nReplace = nNew;\n<line54>zReplace = zNew;\n<line55>}else{\n<line56>nReplace = nQuot;\n<line57>zReplace = zQuot;\n<line58>if( pBest->t.z[pBest->t.n]=='"' ) nReplace++;\n<line59>}\n<line60>}else{\n<line61>/* Dequote the double-quoted token. Then requote it again, this time\n<line62>** using single quotes. If the character immediately following the\n<line63>** original token within the input SQL was a single quote ('), then\n<line64>** add another space after the new, single-quoted version of the\n<line65>** token. This is so that (SELECT "string"'alias') maps to\n<line66>** (SELECT 'string' 'alias'), and not (SELECT 'string''alias').  */\n<line67>memcpy(zBuf1, pBest->t.z, pBest->t.n);\n<line68>zBuf1[pBest->t.n] = 0;\n<line69>sqlite3Dequote(zBuf1);\n<line70>assert( nSql < 0x15555554 /* otherwise malloc would have failed */ );\n<line71>sqlite3_snprintf((int)(nSql*2), zBuf2, "%Q%s", zBuf1,\n<line72>pBest->t.z[pBest->t.n]=='\'' ? " " : ""\n<line73>);\n<line74>zReplace = zBuf2;\n<line75>nReplace = sqlite3Strlen30(zReplace);\n<line76>}\n<line77>iOff = (int)(pBest->t.z - zSql);\n<line78>if( pBest->t.n!=nReplace ){\n<line79>memmove(&zOut[iOff + nReplace], &zOut[iOff + pBest->t.n],\n<line80>nOut - (iOff + pBest->t.n)\n<line81>);\n<line82>nOut += nReplace - pBest->t.n;\n<line83>zOut[nOut] = '\0';\n<line84>}\n<line85>memcpy(&zOut[iOff], zReplace, nReplace);\n<line86>sqlite3DbFree(db, pBest);\n<line87>}\n<line88>sqlite3_result_text(pCtx, zOut, -1, SQLITE_TRANSIENT);\n<line89>sqlite3DbFree(db, zOut);\n<line90>}else{\n<line91>rc = SQLITE_NOMEM;\n<line92>}\n<line93>sqlite3_free(zQuot);\n<line94>return rc;\n<line95>}
----------------------------------------
Function: renameSetENames
Content: <line0>static void renameSetENames(ExprList *pEList, int val){\n<line1>assert( val==ENAME_NAME || val==ENAME_TAB || val==ENAME_SPAN );\n<line2>if( pEList ){\n<line3>int i;\n<line4>for(i=0; i<pEList->nExpr; i++){\n<line5>assert( val==ENAME_NAME || pEList->a[i].fg.eEName==ENAME_NAME );\n<line6>pEList->a[i].fg.eEName = val&0x3;\n<line7>}\n<line8>}\n<line9>}
----------------------------------------
Function: renameResolveTrigger
Content: <line0>static int renameResolveTrigger(Parse *pParse){\n<line1>sqlite3 *db = pParse->db;\n<line2>Trigger *pNew = pParse->pNewTrigger;\n<line3>TriggerStep *pStep;\n<line4>NameContext sNC;\n<line5>int rc = SQLITE_OK;\n<line6>memset(&sNC, 0, sizeof(sNC));\n<line7>sNC.pParse = pParse;\n<line8>assert( pNew->pTabSchema );\n<line9>pParse->pTriggerTab = sqlite3FindTable(db, pNew->table,\n<line10>db->aDb[sqlite3SchemaToIndex(db, pNew->pTabSchema)].zDbSName\n<line11>);\n<line12>pParse->eTriggerOp = pNew->op;\n<line13>/* ALWAYS() because if the table of the trigger does not exist, the\n<line14>** error would have been hit before this point */\n<line15>if( ALWAYS(pParse->pTriggerTab) ){\n<line16>rc = sqlite3ViewGetColumnNames(pParse, pParse->pTriggerTab)!=0;\n<line17>}\n<line18>/* Resolve symbols in WHEN clause */\n<line19>if( rc==SQLITE_OK && pNew->pWhen ){\n<line20>rc = sqlite3ResolveExprNames(&sNC, pNew->pWhen);\n<line21>}\n<line22>for(pStep=pNew->step_list; rc==SQLITE_OK && pStep; pStep=pStep->pNext){\n<line23>if( pStep->pSelect ){\n<line24>sqlite3SelectPrep(pParse, pStep->pSelect, &sNC);\n<line25>if( pParse->nErr ) rc = pParse->rc;\n<line26>}\n<line27>if( rc==SQLITE_OK && pStep->zTarget ){\n<line28>SrcList *pSrc = sqlite3TriggerStepSrc(pParse, pStep);\n<line29>if( pSrc ){\n<line30>Select *pSel = sqlite3SelectNew(\n<line31>pParse, pStep->pExprList, pSrc, 0, 0, 0, 0, 0, 0\n<line32>);\n<line33>if( pSel==0 ){\n<line34>pStep->pExprList = 0;\n<line35>pSrc = 0;\n<line36>rc = SQLITE_NOMEM;\n<line37>}else{\n<line38>/* pStep->pExprList contains an expression-list used for an UPDATE\n<line39>** statement. So the a[].zEName values are the RHS of the\n<line40>** "<col> = <expr>" clauses of the UPDATE statement. So, before\n<line41>** running SelectPrep(), change all the eEName values in\n<line42>** pStep->pExprList to ENAME_SPAN (from their current value of\n<line43>** ENAME_NAME). This is to prevent any ids in ON() clauses that are\n<line44>** part of pSrc from being incorrectly resolved against the\n<line45>** a[].zEName values as if they were column aliases.  */\n<line46>renameSetENames(pStep->pExprList, ENAME_SPAN);\n<line47>sqlite3SelectPrep(pParse, pSel, 0);\n<line48>renameSetENames(pStep->pExprList, ENAME_NAME);\n<line49>rc = pParse->nErr ? SQLITE_ERROR : SQLITE_OK;\n<line50>assert( pStep->pExprList==0 || pStep->pExprList==pSel->pEList );\n<line51>assert( pSrc==pSel->pSrc );\n<line52>if( pStep->pExprList ) pSel->pEList = 0;\n<line53>pSel->pSrc = 0;\n<line54>sqlite3SelectDelete(db, pSel);\n<line55>}\n<line56>if( pStep->pFrom ){\n<line57>int i;\n<line58>for(i=0; i<pStep->pFrom->nSrc && rc==SQLITE_OK; i++){\n<line59>SrcItem *p = &pStep->pFrom->a[i];\n<line60>if( p->fg.isSubquery ){\n<line61>assert( p->u4.pSubq!=0 );\n<line62>sqlite3SelectPrep(pParse, p->u4.pSubq->pSelect, 0);\n<line63>}\n<line64>}\n<line65>}\n<line66>if(  db->mallocFailed ){\n<line67>rc = SQLITE_NOMEM;\n<line68>}\n<line69>sNC.pSrcList = pSrc;\n<line70>if( rc==SQLITE_OK && pStep->pWhere ){\n<line71>rc = sqlite3ResolveExprNames(&sNC, pStep->pWhere);\n<line72>}\n<line73>if( rc==SQLITE_OK ){\n<line74>rc = sqlite3ResolveExprListNames(&sNC, pStep->pExprList);\n<line75>}\n<line76>assert( !pStep->pUpsert || (!pStep->pWhere && !pStep->pExprList) );\n<line77>if( pStep->pUpsert && rc==SQLITE_OK ){\n<line78>Upsert *pUpsert = pStep->pUpsert;\n<line79>pUpsert->pUpsertSrc = pSrc;\n<line80>sNC.uNC.pUpsert = pUpsert;\n<line81>sNC.ncFlags = NC_UUpsert;\n<line82>rc = sqlite3ResolveExprListNames(&sNC, pUpsert->pUpsertTarget);\n<line83>if( rc==SQLITE_OK ){\n<line84>ExprList *pUpsertSet = pUpsert->pUpsertSet;\n<line85>rc = sqlite3ResolveExprListNames(&sNC, pUpsertSet);\n<line86>}\n<line87>if( rc==SQLITE_OK ){\n<line88>rc = sqlite3ResolveExprNames(&sNC, pUpsert->pUpsertWhere);\n<line89>}\n<line90>if( rc==SQLITE_OK ){\n<line91>rc = sqlite3ResolveExprNames(&sNC, pUpsert->pUpsertTargetWhere);\n<line92>}\n<line93>sNC.ncFlags = 0;\n<line94>}\n<line95>sNC.pSrcList = 0;\n<line96>sqlite3SrcListDelete(db, pSrc);\n<line97>}else{\n<line98>rc = SQLITE_NOMEM;\n<line99>}\n<line100>}\n<line101>}\n<line102>return rc;\n<line103>}
----------------------------------------
Function: renameWalkTrigger
Content: <line0>static void renameWalkTrigger(Walker *pWalker, Trigger *pTrigger){\n<line1>TriggerStep *pStep;\n<line2>/* Find tokens to edit in WHEN clause */\n<line3>sqlite3WalkExpr(pWalker, pTrigger->pWhen);\n<line4>/* Find tokens to edit in trigger steps */\n<line5>for(pStep=pTrigger->step_list; pStep; pStep=pStep->pNext){\n<line6>sqlite3WalkSelect(pWalker, pStep->pSelect);\n<line7>sqlite3WalkExpr(pWalker, pStep->pWhere);\n<line8>sqlite3WalkExprList(pWalker, pStep->pExprList);\n<line9>if( pStep->pUpsert ){\n<line10>Upsert *pUpsert = pStep->pUpsert;\n<line11>sqlite3WalkExprList(pWalker, pUpsert->pUpsertTarget);\n<line12>sqlite3WalkExprList(pWalker, pUpsert->pUpsertSet);\n<line13>sqlite3WalkExpr(pWalker, pUpsert->pUpsertWhere);\n<line14>sqlite3WalkExpr(pWalker, pUpsert->pUpsertTargetWhere);\n<line15>}\n<line16>if( pStep->pFrom ){\n<line17>int i;\n<line18>SrcList *pFrom = pStep->pFrom;\n<line19>for(i=0; i<pFrom->nSrc; i++){\n<line20>if( pFrom->a[i].fg.isSubquery ){\n<line21>assert( pFrom->a[i].u4.pSubq!=0 );\n<line22>sqlite3WalkSelect(pWalker, pFrom->a[i].u4.pSubq->pSelect);\n<line23>}\n<line24>}\n<line25>}\n<line26>}\n<line27>}
----------------------------------------
Function: renameParseCleanup
Content: <line0>static void renameParseCleanup(Parse *pParse){\n<line1>sqlite3 *db = pParse->db;\n<line2>Index *pIdx;\n<line3>if( pParse->pVdbe ){\n<line4>sqlite3VdbeFinalize(pParse->pVdbe);\n<line5>}\n<line6>sqlite3DeleteTable(db, pParse->pNewTable);\n<line7>while( (pIdx = pParse->pNewIndex)!=0 ){\n<line8>pParse->pNewIndex = pIdx->pNext;\n<line9>sqlite3FreeIndex(db, pIdx);\n<line10>}\n<line11>sqlite3DeleteTrigger(db, pParse->pNewTrigger);\n<line12>sqlite3DbFree(db, pParse->zErrMsg);\n<line13>renameTokenFree(db, pParse->pRename);\n<line14>sqlite3ParseObjectReset(pParse);\n<line15>}
----------------------------------------
Function: renameColumnFunc
Content: <line0>static void renameColumnFunc(\n<line1>sqlite3_context *context,\n<line2>int NotUsed,\n<line3>sqlite3_value **argv\n<line4>){\n<line5>sqlite3 *db = sqlite3_context_db_handle(context);\n<line6>RenameCtx sCtx;\n<line7>const char *zSql = (const char*)sqlite3_value_text(argv[0]);\n<line8>const char *zDb = (const char*)sqlite3_value_text(argv[3]);\n<line9>const char *zTable = (const char*)sqlite3_value_text(argv[4]);\n<line10>int iCol = sqlite3_value_int(argv[5]);\n<line11>const char *zNew = (const char*)sqlite3_value_text(argv[6]);\n<line12>int bQuote = sqlite3_value_int(argv[7]);\n<line13>int bTemp = sqlite3_value_int(argv[8]);\n<line14>const char *zOld;\n<line15>int rc;\n<line16>Parse sParse;\n<line17>Walker sWalker;\n<line18>Index *pIdx;\n<line19>int i;\n<line20>Table *pTab;\n<line21>#ifndef SQLITE_OMIT_AUTHORIZATION\n<line22>sqlite3_xauth xAuth = db->xAuth;\n<line23>#endif\n<line24>UNUSED_PARAMETER(NotUsed);\n<line25>if( zSql==0 ) return;\n<line26>if( zTable==0 ) return;\n<line27>if( zNew==0 ) return;\n<line28>if( iCol<0 ) return;\n<line29>sqlite3BtreeEnterAll(db);\n<line30>pTab = sqlite3FindTable(db, zTable, zDb);\n<line31>if( pTab==0 || iCol>=pTab->nCol ){\n<line32>sqlite3BtreeLeaveAll(db);\n<line33>return;\n<line34>}\n<line35>zOld = pTab->aCol[iCol].zCnName;\n<line36>memset(&sCtx, 0, sizeof(sCtx));\n<line37>sCtx.iCol = ((iCol==pTab->iPKey) ? -1 : iCol);\n<line38>#ifndef SQLITE_OMIT_AUTHORIZATION\n<line39>db->xAuth = 0;\n<line40>#endif\n<line41>rc = renameParseSql(&sParse, zDb, db, zSql, bTemp);\n<line42>/* Find tokens that need to be replaced. */\n<line43>memset(&sWalker, 0, sizeof(Walker));\n<line44>sWalker.pParse = &sParse;\n<line45>sWalker.xExprCallback = renameColumnExprCb;\n<line46>sWalker.xSelectCallback = renameColumnSelectCb;\n<line47>sWalker.u.pRename = &sCtx;\n<line48>sCtx.pTab = pTab;\n<line49>if( rc!=SQLITE_OK ) goto renameColumnFunc_done;\n<line50>if( sParse.pNewTable ){\n<line51>if( IsView(sParse.pNewTable) ){\n<line52>Select *pSelect = sParse.pNewTable->u.view.pSelect;\n<line53>pSelect->selFlags &= ~(u32)SF_View;\n<line54>sParse.rc = SQLITE_OK;\n<line55>sqlite3SelectPrep(&sParse, pSelect, 0);\n<line56>rc = (db->mallocFailed ? SQLITE_NOMEM : sParse.rc);\n<line57>if( rc==SQLITE_OK ){\n<line58>sqlite3WalkSelect(&sWalker, pSelect);\n<line59>}\n<line60>if( rc!=SQLITE_OK ) goto renameColumnFunc_done;\n<line61>}else if( IsOrdinaryTable(sParse.pNewTable) ){\n<line62>/* A regular table */\n<line63>int bFKOnly = sqlite3_stricmp(zTable, sParse.pNewTable->zName);\n<line64>FKey *pFKey;\n<line65>sCtx.pTab = sParse.pNewTable;\n<line66>if( bFKOnly==0 ){\n<line67>if( iCol<sParse.pNewTable->nCol ){\n<line68>renameTokenFind(\n<line69>&sParse, &sCtx, (void*)sParse.pNewTable->aCol[iCol].zCnName\n<line70>);\n<line71>}\n<line72>if( sCtx.iCol<0 ){\n<line73>renameTokenFind(&sParse, &sCtx, (void*)&sParse.pNewTable->iPKey);\n<line74>}\n<line75>sqlite3WalkExprList(&sWalker, sParse.pNewTable->pCheck);\n<line76>for(pIdx=sParse.pNewTable->pIndex; pIdx; pIdx=pIdx->pNext){\n<line77>sqlite3WalkExprList(&sWalker, pIdx->aColExpr);\n<line78>}\n<line79>for(pIdx=sParse.pNewIndex; pIdx; pIdx=pIdx->pNext){\n<line80>sqlite3WalkExprList(&sWalker, pIdx->aColExpr);\n<line81>}\n<line82>#ifndef SQLITE_OMIT_GENERATED_COLUMNS\n<line83>for(i=0; i<sParse.pNewTable->nCol; i++){\n<line84>Expr *pExpr = sqlite3ColumnExpr(sParse.pNewTable,\n<line85>&sParse.pNewTable->aCol[i]);\n<line86>sqlite3WalkExpr(&sWalker, pExpr);\n<line87>}\n<line88>#endif\n<line89>}\n<line90>assert( IsOrdinaryTable(sParse.pNewTable) );\n<line91>for(pFKey=sParse.pNewTable->u.tab.pFKey; pFKey; pFKey=pFKey->pNextFrom){\n<line92>for(i=0; i<pFKey->nCol; i++){\n<line93>if( bFKOnly==0 && pFKey->aCol[i].iFrom==iCol ){\n<line94>renameTokenFind(&sParse, &sCtx, (void*)&pFKey->aCol[i]);\n<line95>}\n<line96>if( 0==sqlite3_stricmp(pFKey->zTo, zTable)\n<line97>&& 0==sqlite3_stricmp(pFKey->aCol[i].zCol, zOld)\n<line98>){\n<line99>renameTokenFind(&sParse, &sCtx, (void*)pFKey->aCol[i].zCol);\n<line100>}\n<line101>}\n<line102>}\n<line103>}\n<line104>}else if( sParse.pNewIndex ){\n<line105>sqlite3WalkExprList(&sWalker, sParse.pNewIndex->aColExpr);\n<line106>sqlite3WalkExpr(&sWalker, sParse.pNewIndex->pPartIdxWhere);\n<line107>}else{\n<line108>/* A trigger */\n<line109>TriggerStep *pStep;\n<line110>rc = renameResolveTrigger(&sParse);\n<line111>if( rc!=SQLITE_OK ) goto renameColumnFunc_done;\n<line112>for(pStep=sParse.pNewTrigger->step_list; pStep; pStep=pStep->pNext){\n<line113>if( pStep->zTarget ){\n<line114>Table *pTarget = sqlite3LocateTable(&sParse, 0, pStep->zTarget, zDb);\n<line115>if( pTarget==pTab ){\n<line116>if( pStep->pUpsert ){\n<line117>ExprList *pUpsertSet = pStep->pUpsert->pUpsertSet;\n<line118>renameColumnElistNames(&sParse, &sCtx, pUpsertSet, zOld);\n<line119>}\n<line120>renameColumnIdlistNames(&sParse, &sCtx, pStep->pIdList, zOld);\n<line121>renameColumnElistNames(&sParse, &sCtx, pStep->pExprList, zOld);\n<line122>}\n<line123>}\n<line124>}\n<line125>/* Find tokens to edit in UPDATE OF clause */\n<line126>if( sParse.pTriggerTab==pTab ){\n<line127>renameColumnIdlistNames(&sParse, &sCtx,sParse.pNewTrigger->pColumns,zOld);\n<line128>}\n<line129>/* Find tokens to edit in various expressions and selects */\n<line130>renameWalkTrigger(&sWalker, sParse.pNewTrigger);\n<line131>}\n<line132>assert( rc==SQLITE_OK );\n<line133>rc = renameEditSql(context, &sCtx, zSql, zNew, bQuote);\n<line134>renameColumnFunc_done:\n<line135>if( rc!=SQLITE_OK ){\n<line136>if( rc==SQLITE_ERROR && sqlite3WritableSchema(db) ){\n<line137>sqlite3_result_value(context, argv[0]);\n<line138>}else if( sParse.zErrMsg ){\n<line139>renameColumnParseError(context, "", argv[1], argv[2], &sParse);\n<line140>}else{\n<line141>sqlite3_result_error_code(context, rc);\n<line142>}\n<line143>}\n<line144>renameParseCleanup(&sParse);\n<line145>renameTokenFree(db, sCtx.pList);\n<line146>#ifndef SQLITE_OMIT_AUTHORIZATION\n<line147>db->xAuth = xAuth;\n<line148>#endif\n<line149>sqlite3BtreeLeaveAll(db);\n<line150>}
----------------------------------------
Function: renameTableExprCb
Content: <line0>static int renameTableExprCb(Walker *pWalker, Expr *pExpr){\n<line1>RenameCtx *p = pWalker->u.pRename;\n<line2>if( pExpr->op==TK_COLUMN\n<line3>&& ALWAYS(ExprUseYTab(pExpr))\n<line4>&& p->pTab==pExpr->y.pTab\n<line5>){\n<line6>renameTokenFind(pWalker->pParse, p, (void*)&pExpr->y.pTab);\n<line7>}\n<line8>return WRC_Continue;\n<line9>}
----------------------------------------
Function: renameTableSelectCb
Content: <line0>static int renameTableSelectCb(Walker *pWalker, Select *pSelect){\n<line1>int i;\n<line2>RenameCtx *p = pWalker->u.pRename;\n<line3>SrcList *pSrc = pSelect->pSrc;\n<line4>if( pSelect->selFlags & (SF_View|SF_CopyCte) ){\n<line5>testcase( pSelect->selFlags & SF_View );\n<line6>testcase( pSelect->selFlags & SF_CopyCte );\n<line7>return WRC_Prune;\n<line8>}\n<line9>if( NEVER(pSrc==0) ){\n<line10>assert( pWalker->pParse->db->mallocFailed );\n<line11>return WRC_Abort;\n<line12>}\n<line13>for(i=0; i<pSrc->nSrc; i++){\n<line14>SrcItem *pItem = &pSrc->a[i];\n<line15>if( pItem->pSTab==p->pTab ){\n<line16>renameTokenFind(pWalker->pParse, p, pItem->zName);\n<line17>}\n<line18>}\n<line19>renameWalkWith(pWalker, pSelect);\n<line20>return WRC_Continue;\n<line21>}
----------------------------------------
Function: renameTableFunc
Content: <line0>static void renameTableFunc(\n<line1>sqlite3_context *context,\n<line2>int NotUsed,\n<line3>sqlite3_value **argv\n<line4>){\n<line5>sqlite3 *db = sqlite3_context_db_handle(context);\n<line6>const char *zDb = (const char*)sqlite3_value_text(argv[0]);\n<line7>const char *zInput = (const char*)sqlite3_value_text(argv[3]);\n<line8>const char *zOld = (const char*)sqlite3_value_text(argv[4]);\n<line9>const char *zNew = (const char*)sqlite3_value_text(argv[5]);\n<line10>int bTemp = sqlite3_value_int(argv[6]);\n<line11>UNUSED_PARAMETER(NotUsed);\n<line12>if( zInput && zOld && zNew ){\n<line13>Parse sParse;\n<line14>int rc;\n<line15>int bQuote = 1;\n<line16>RenameCtx sCtx;\n<line17>Walker sWalker;\n<line18>#ifndef SQLITE_OMIT_AUTHORIZATION\n<line19>sqlite3_xauth xAuth = db->xAuth;\n<line20>db->xAuth = 0;\n<line21>#endif\n<line22>sqlite3BtreeEnterAll(db);\n<line23>memset(&sCtx, 0, sizeof(RenameCtx));\n<line24>sCtx.pTab = sqlite3FindTable(db, zOld, zDb);\n<line25>memset(&sWalker, 0, sizeof(Walker));\n<line26>sWalker.pParse = &sParse;\n<line27>sWalker.xExprCallback = renameTableExprCb;\n<line28>sWalker.xSelectCallback = renameTableSelectCb;\n<line29>sWalker.u.pRename = &sCtx;\n<line30>rc = renameParseSql(&sParse, zDb, db, zInput, bTemp);\n<line31>if( rc==SQLITE_OK ){\n<line32>int isLegacy = (db->flags & SQLITE_LegacyAlter);\n<line33>if( sParse.pNewTable ){\n<line34>Table *pTab = sParse.pNewTable;\n<line35>if( IsView(pTab) ){\n<line36>if( isLegacy==0 ){\n<line37>Select *pSelect = pTab->u.view.pSelect;\n<line38>NameContext sNC;\n<line39>memset(&sNC, 0, sizeof(sNC));\n<line40>sNC.pParse = &sParse;\n<line41>assert( pSelect->selFlags & SF_View );\n<line42>pSelect->selFlags &= ~(u32)SF_View;\n<line43>sqlite3SelectPrep(&sParse, pTab->u.view.pSelect, &sNC);\n<line44>if( sParse.nErr ){\n<line45>rc = sParse.rc;\n<line46>}else{\n<line47>sqlite3WalkSelect(&sWalker, pTab->u.view.pSelect);\n<line48>}\n<line49>}\n<line50>}else{\n<line51>/* Modify any FK definitions to point to the new table. */\n<line52>#ifndef SQLITE_OMIT_FOREIGN_KEY\n<line53>if( (isLegacy==0 || (db->flags & SQLITE_ForeignKeys))\n<line54>&& !IsVirtual(pTab)\n<line55>){\n<line56>FKey *pFKey;\n<line57>assert( IsOrdinaryTable(pTab) );\n<line58>for(pFKey=pTab->u.tab.pFKey; pFKey; pFKey=pFKey->pNextFrom){\n<line59>if( sqlite3_stricmp(pFKey->zTo, zOld)==0 ){\n<line60>renameTokenFind(&sParse, &sCtx, (void*)pFKey->zTo);\n<line61>}\n<line62>}\n<line63>}\n<line64>#endif\n<line65>/* If this is the table being altered, fix any table refs in CHECK\n<line66>** expressions. Also update the name that appears right after the\n<line67>** "CREATE [VIRTUAL] TABLE" bit. */\n<line68>if( sqlite3_stricmp(zOld, pTab->zName)==0 ){\n<line69>sCtx.pTab = pTab;\n<line70>if( isLegacy==0 ){\n<line71>sqlite3WalkExprList(&sWalker, pTab->pCheck);\n<line72>}\n<line73>renameTokenFind(&sParse, &sCtx, pTab->zName);\n<line74>}\n<line75>}\n<line76>}\n<line77>else if( sParse.pNewIndex ){\n<line78>renameTokenFind(&sParse, &sCtx, sParse.pNewIndex->zName);\n<line79>if( isLegacy==0 ){\n<line80>sqlite3WalkExpr(&sWalker, sParse.pNewIndex->pPartIdxWhere);\n<line81>}\n<line82>}\n<line83>#ifndef SQLITE_OMIT_TRIGGER\n<line84>else{\n<line85>Trigger *pTrigger = sParse.pNewTrigger;\n<line86>TriggerStep *pStep;\n<line87>if( 0==sqlite3_stricmp(sParse.pNewTrigger->table, zOld)\n<line88>&& sCtx.pTab->pSchema==pTrigger->pTabSchema\n<line89>){\n<line90>renameTokenFind(&sParse, &sCtx, sParse.pNewTrigger->table);\n<line91>}\n<line92>if( isLegacy==0 ){\n<line93>rc = renameResolveTrigger(&sParse);\n<line94>if( rc==SQLITE_OK ){\n<line95>renameWalkTrigger(&sWalker, pTrigger);\n<line96>for(pStep=pTrigger->step_list; pStep; pStep=pStep->pNext){\n<line97>if( pStep->zTarget && 0==sqlite3_stricmp(pStep->zTarget, zOld) ){\n<line98>renameTokenFind(&sParse, &sCtx, pStep->zTarget);\n<line99>}\n<line100>if( pStep->pFrom ){\n<line101>int i;\n<line102>for(i=0; i<pStep->pFrom->nSrc; i++){\n<line103>SrcItem *pItem = &pStep->pFrom->a[i];\n<line104>if( 0==sqlite3_stricmp(pItem->zName, zOld) ){\n<line105>renameTokenFind(&sParse, &sCtx, pItem->zName);\n<line106>}\n<line107>}\n<line108>}\n<line109>}\n<line110>}\n<line111>}\n<line112>}\n<line113>#endif\n<line114>}\n<line115>if( rc==SQLITE_OK ){\n<line116>rc = renameEditSql(context, &sCtx, zInput, zNew, bQuote);\n<line117>}\n<line118>if( rc!=SQLITE_OK ){\n<line119>if( rc==SQLITE_ERROR && sqlite3WritableSchema(db) ){\n<line120>sqlite3_result_value(context, argv[3]);\n<line121>}else if( sParse.zErrMsg ){\n<line122>renameColumnParseError(context, "", argv[1], argv[2], &sParse);\n<line123>}else{\n<line124>sqlite3_result_error_code(context, rc);\n<line125>}\n<line126>}\n<line127>renameParseCleanup(&sParse);\n<line128>renameTokenFree(db, sCtx.pList);\n<line129>sqlite3BtreeLeaveAll(db);\n<line130>#ifndef SQLITE_OMIT_AUTHORIZATION\n<line131>db->xAuth = xAuth;\n<line132>#endif\n<line133>}\n<line134>return;\n<line135>}
----------------------------------------
Function: renameQuotefixExprCb
Content: <line0>static int renameQuotefixExprCb(Walker *pWalker, Expr *pExpr){\n<line1>if( pExpr->op==TK_STRING && (pExpr->flags & EP_DblQuoted) ){\n<line2>renameTokenFind(pWalker->pParse, pWalker->u.pRename, (const void*)pExpr);\n<line3>}\n<line4>return WRC_Continue;\n<line5>}
----------------------------------------
Function: renameQuotefixFunc
Content: <line0>static void renameQuotefixFunc(\n<line1>sqlite3_context *context,\n<line2>int NotUsed,\n<line3>sqlite3_value **argv\n<line4>){\n<line5>sqlite3 *db = sqlite3_context_db_handle(context);\n<line6>char const *zDb = (const char*)sqlite3_value_text(argv[0]);\n<line7>char const *zInput = (const char*)sqlite3_value_text(argv[1]);\n<line8>#ifndef SQLITE_OMIT_AUTHORIZATION\n<line9>sqlite3_xauth xAuth = db->xAuth;\n<line10>db->xAuth = 0;\n<line11>#endif\n<line12>sqlite3BtreeEnterAll(db);\n<line13>UNUSED_PARAMETER(NotUsed);\n<line14>if( zDb && zInput ){\n<line15>int rc;\n<line16>Parse sParse;\n<line17>rc = renameParseSql(&sParse, zDb, db, zInput, 0);\n<line18>if( rc==SQLITE_OK ){\n<line19>RenameCtx sCtx;\n<line20>Walker sWalker;\n<line21>/* Walker to find tokens that need to be replaced. */\n<line22>memset(&sCtx, 0, sizeof(RenameCtx));\n<line23>memset(&sWalker, 0, sizeof(Walker));\n<line24>sWalker.pParse = &sParse;\n<line25>sWalker.xExprCallback = renameQuotefixExprCb;\n<line26>sWalker.xSelectCallback = renameColumnSelectCb;\n<line27>sWalker.u.pRename = &sCtx;\n<line28>if( sParse.pNewTable ){\n<line29>if( IsView(sParse.pNewTable) ){\n<line30>Select *pSelect = sParse.pNewTable->u.view.pSelect;\n<line31>pSelect->selFlags &= ~(u32)SF_View;\n<line32>sParse.rc = SQLITE_OK;\n<line33>sqlite3SelectPrep(&sParse, pSelect, 0);\n<line34>rc = (db->mallocFailed ? SQLITE_NOMEM : sParse.rc);\n<line35>if( rc==SQLITE_OK ){\n<line36>sqlite3WalkSelect(&sWalker, pSelect);\n<line37>}\n<line38>}else{\n<line39>int i;\n<line40>sqlite3WalkExprList(&sWalker, sParse.pNewTable->pCheck);\n<line41>#ifndef SQLITE_OMIT_GENERATED_COLUMNS\n<line42>for(i=0; i<sParse.pNewTable->nCol; i++){\n<line43>sqlite3WalkExpr(&sWalker,\n<line44>sqlite3ColumnExpr(sParse.pNewTable,\n<line45>&sParse.pNewTable->aCol[i]));\n<line46>}\n<line47>#endif /* SQLITE_OMIT_GENERATED_COLUMNS */\n<line48>}\n<line49>}else if( sParse.pNewIndex ){\n<line50>sqlite3WalkExprList(&sWalker, sParse.pNewIndex->aColExpr);\n<line51>sqlite3WalkExpr(&sWalker, sParse.pNewIndex->pPartIdxWhere);\n<line52>}else{\n<line53>#ifndef SQLITE_OMIT_TRIGGER\n<line54>rc = renameResolveTrigger(&sParse);\n<line55>if( rc==SQLITE_OK ){\n<line56>renameWalkTrigger(&sWalker, sParse.pNewTrigger);\n<line57>}\n<line58>#endif /* SQLITE_OMIT_TRIGGER */\n<line59>}\n<line60>if( rc==SQLITE_OK ){\n<line61>rc = renameEditSql(context, &sCtx, zInput, 0, 0);\n<line62>}\n<line63>renameTokenFree(db, sCtx.pList);\n<line64>}\n<line65>if( rc!=SQLITE_OK ){\n<line66>if( sqlite3WritableSchema(db) && rc==SQLITE_ERROR ){\n<line67>sqlite3_result_value(context, argv[1]);\n<line68>}else{\n<line69>sqlite3_result_error_code(context, rc);\n<line70>}\n<line71>}\n<line72>renameParseCleanup(&sParse);\n<line73>}\n<line74>#ifndef SQLITE_OMIT_AUTHORIZATION\n<line75>db->xAuth = xAuth;\n<line76>#endif\n<line77>sqlite3BtreeLeaveAll(db);\n<line78>}
----------------------------------------
Function: renameTableTest
Content: <line0>static void renameTableTest(\n<line1>sqlite3_context *context,\n<line2>int NotUsed,\n<line3>sqlite3_value **argv\n<line4>){\n<line5>sqlite3 *db = sqlite3_context_db_handle(context);\n<line6>char const *zDb = (const char*)sqlite3_value_text(argv[0]);\n<line7>char const *zInput = (const char*)sqlite3_value_text(argv[1]);\n<line8>int bTemp = sqlite3_value_int(argv[4]);\n<line9>int isLegacy = (db->flags & SQLITE_LegacyAlter);\n<line10>char const *zWhen = (const char*)sqlite3_value_text(argv[5]);\n<line11>int bNoDQS = sqlite3_value_int(argv[6]);\n<line12>#ifndef SQLITE_OMIT_AUTHORIZATION\n<line13>sqlite3_xauth xAuth = db->xAuth;\n<line14>db->xAuth = 0;\n<line15>#endif\n<line16>UNUSED_PARAMETER(NotUsed);\n<line17>if( zDb && zInput ){\n<line18>int rc;\n<line19>Parse sParse;\n<line20>u64 flags = db->flags;\n<line21>if( bNoDQS ) db->flags &= ~(SQLITE_DqsDML|SQLITE_DqsDDL);\n<line22>rc = renameParseSql(&sParse, zDb, db, zInput, bTemp);\n<line23>db->flags = flags;\n<line24>if( rc==SQLITE_OK ){\n<line25>if( isLegacy==0 && sParse.pNewTable && IsView(sParse.pNewTable) ){\n<line26>NameContext sNC;\n<line27>memset(&sNC, 0, sizeof(sNC));\n<line28>sNC.pParse = &sParse;\n<line29>sqlite3SelectPrep(&sParse, sParse.pNewTable->u.view.pSelect, &sNC);\n<line30>if( sParse.nErr ) rc = sParse.rc;\n<line31>}\n<line32>else if( sParse.pNewTrigger ){\n<line33>if( isLegacy==0 ){\n<line34>rc = renameResolveTrigger(&sParse);\n<line35>}\n<line36>if( rc==SQLITE_OK ){\n<line37>int i1 = sqlite3SchemaToIndex(db, sParse.pNewTrigger->pTabSchema);\n<line38>int i2 = sqlite3FindDbName(db, zDb);\n<line39>if( i1==i2 ){\n<line40>/* Handle output case B */\n<line41>sqlite3_result_int(context, 1);\n<line42>}\n<line43>}\n<line44>}\n<line45>}\n<line46>if( rc!=SQLITE_OK && zWhen && !sqlite3WritableSchema(db) ){\n<line47>/* Output case A */\n<line48>renameColumnParseError(context, zWhen, argv[2], argv[3],&sParse);\n<line49>}\n<line50>renameParseCleanup(&sParse);\n<line51>}\n<line52>#ifndef SQLITE_OMIT_AUTHORIZATION\n<line53>db->xAuth = xAuth;\n<line54>#endif\n<line55>}
----------------------------------------
Function: dropColumnFunc
Content: <line0>static void dropColumnFunc(\n<line1>sqlite3_context *context,\n<line2>int NotUsed,\n<line3>sqlite3_value **argv\n<line4>){\n<line5>sqlite3 *db = sqlite3_context_db_handle(context);\n<line6>int iSchema = sqlite3_value_int(argv[0]);\n<line7>const char *zSql = (const char*)sqlite3_value_text(argv[1]);\n<line8>int iCol = sqlite3_value_int(argv[2]);\n<line9>const char *zDb = db->aDb[iSchema].zDbSName;\n<line10>int rc;\n<line11>Parse sParse;\n<line12>RenameToken *pCol;\n<line13>Table *pTab;\n<line14>const char *zEnd;\n<line15>char *zNew = 0;\n<line16>#ifndef SQLITE_OMIT_AUTHORIZATION\n<line17>sqlite3_xauth xAuth = db->xAuth;\n<line18>db->xAuth = 0;\n<line19>#endif\n<line20>UNUSED_PARAMETER(NotUsed);\n<line21>rc = renameParseSql(&sParse, zDb, db, zSql, iSchema==1);\n<line22>if( rc!=SQLITE_OK ) goto drop_column_done;\n<line23>pTab = sParse.pNewTable;\n<line24>if( pTab==0 || pTab->nCol==1 || iCol>=pTab->nCol ){\n<line25>/* This can happen if the sqlite_schema table is corrupt */\n<line26>rc = SQLITE_CORRUPT_BKPT;\n<line27>goto drop_column_done;\n<line28>}\n<line29>pCol = renameTokenFind(&sParse, 0, (void*)pTab->aCol[iCol].zCnName);\n<line30>if( iCol<pTab->nCol-1 ){\n<line31>RenameToken *pEnd;\n<line32>pEnd = renameTokenFind(&sParse, 0, (void*)pTab->aCol[iCol+1].zCnName);\n<line33>zEnd = (const char*)pEnd->t.z;\n<line34>}else{\n<line35>assert( IsOrdinaryTable(pTab) );\n<line36>zEnd = (const char*)&zSql[pTab->u.tab.addColOffset];\n<line37>while( ALWAYS(pCol->t.z[0]!=0) && pCol->t.z[0]!=',' ) pCol->t.z--;\n<line38>}\n<line39>zNew = sqlite3MPrintf(db, "%.*s%s", pCol->t.z-zSql, zSql, zEnd);\n<line40>sqlite3_result_text(context, zNew, -1, SQLITE_TRANSIENT);\n<line41>sqlite3_free(zNew);\n<line42>drop_column_done:\n<line43>renameParseCleanup(&sParse);\n<line44>#ifndef SQLITE_OMIT_AUTHORIZATION\n<line45>db->xAuth = xAuth;\n<line46>#endif\n<line47>if( rc!=SQLITE_OK ){\n<line48>sqlite3_result_error_code(context, rc);\n<line49>}\n<line50>}
----------------------------------------
Function: openStatTable
Content: <line0>static void openStatTable(\n<line1>Parse *pParse,          /* Parsing context */\n<line2>int iDb,                /* The database we are looking in */\n<line3>int iStatCur,           /* Open the sqlite_stat1 table on this cursor */\n<line4>const char *zWhere,     /* Delete entries for this table or index */\n<line5>const char *zWhereType  /* Either "tbl" or "idx" */\n<line6>){\n<line7>static const struct {\n<line8>const char *zName;\n<line9>const char *zCols;\n<line10>} aTable[] = {\n<line11>{ "sqlite_stat1", "tbl,idx,stat" },\n<line12>#if defined(SQLITE_ENABLE_STAT4)\n<line13>{ "sqlite_stat4", "tbl,idx,neq,nlt,ndlt,sample" },\n<line14>#else\n<line15>{ "sqlite_stat4", 0 },\n<line16>#endif\n<line17>{ "sqlite_stat3", 0 },\n<line18>};\n<line19>int i;\n<line20>sqlite3 *db = pParse->db;\n<line21>Db *pDb;\n<line22>Vdbe *v = sqlite3GetVdbe(pParse);\n<line23>u32 aRoot[ArraySize(aTable)];\n<line24>u8 aCreateTbl[ArraySize(aTable)];\n<line25>#ifdef SQLITE_ENABLE_STAT4\n<line26>const int nToOpen = OptimizationEnabled(db,SQLITE_Stat4) ? 2 : 1;\n<line27>#else\n<line28>const int nToOpen = 1;\n<line29>#endif\n<line30>if( v==0 ) return;\n<line31>assert( sqlite3BtreeHoldsAllMutexes(db) );\n<line32>assert( sqlite3VdbeDb(v)==db );\n<line33>pDb = &db->aDb[iDb];\n<line34>/* Create new statistic tables if they do not exist, or clear them\n<line35>** if they do already exist.\n<line36>*/\n<line37>for(i=0; i<ArraySize(aTable); i++){\n<line38>const char *zTab = aTable[i].zName;\n<line39>Table *pStat;\n<line40>aCreateTbl[i] = 0;\n<line41>if( (pStat = sqlite3FindTable(db, zTab, pDb->zDbSName))==0 ){\n<line42>if( i<nToOpen ){\n<line43>/* The sqlite_statN table does not exist. Create it. Note that a\n<line44>** side-effect of the CREATE TABLE statement is to leave the rootpage\n<line45>** of the new table in register pParse->regRoot. This is important\n<line46>** because the OpenWrite opcode below will be needing it. */\n<line47>sqlite3NestedParse(pParse,\n<line48>"CREATE TABLE %Q.%s(%s)", pDb->zDbSName, zTab, aTable[i].zCols\n<line49>);\n<line50>assert( pParse->isCreate || pParse->nErr );\n<line51>aRoot[i] = (u32)pParse->u1.cr.regRoot;\n<line52>aCreateTbl[i] = OPFLAG_P2ISREG;\n<line53>}\n<line54>}else{\n<line55>/* The table already exists. If zWhere is not NULL, delete all entries\n<line56>** associated with the table zWhere. If zWhere is NULL, delete the\n<line57>** entire contents of the table. */\n<line58>aRoot[i] = pStat->tnum;\n<line59>sqlite3TableLock(pParse, iDb, aRoot[i], 1, zTab);\n<line60>if( zWhere ){\n<line61>sqlite3NestedParse(pParse,\n<line62>"DELETE FROM %Q.%s WHERE %s=%Q",\n<line63>pDb->zDbSName, zTab, zWhereType, zWhere\n<line64>);\n<line65>#ifdef SQLITE_ENABLE_PREUPDATE_HOOK\n<line66>}else if( db->xPreUpdateCallback ){\n<line67>sqlite3NestedParse(pParse, "DELETE FROM %Q.%s", pDb->zDbSName, zTab);\n<line68>#endif\n<line69>}else{\n<line70>/* The sqlite_stat[134] table already exists.  Delete all rows. */\n<line71>sqlite3VdbeAddOp2(v, OP_Clear, (int)aRoot[i], iDb);\n<line72>}\n<line73>}\n<line74>}\n<line75>/* Open the sqlite_stat[134] tables for writing. */\n<line76>for(i=0; i<nToOpen; i++){\n<line77>assert( i<ArraySize(aTable) );\n<line78>sqlite3VdbeAddOp4Int(v, OP_OpenWrite, iStatCur+i, (int)aRoot[i], iDb, 3);\n<line79>sqlite3VdbeChangeP5(v, aCreateTbl[i]);\n<line80>VdbeComment((v, aTable[i].zName));\n<line81>}\n<line82>}
----------------------------------------
Function: statAccumDestructor
Content: <line0>static void statAccumDestructor(void *pOld){\n<line1>StatAccum *p = (StatAccum*)pOld;\n<line2>#ifdef SQLITE_ENABLE_STAT4\n<line3>if( p->mxSample ){\n<line4>int i;\n<line5>for(i=0; i<p->nCol; i++) sampleClear(p->db, p->aBest+i);\n<line6>for(i=0; i<p->mxSample; i++) sampleClear(p->db, p->a+i);\n<line7>sampleClear(p->db, &p->current);\n<line8>}\n<line9>#endif\n<line10>sqlite3DbFree(p->db, p);\n<line11>}
----------------------------------------
Function: statInit
Content: <line0>static void statInit(\n<line1>sqlite3_context *context,\n<line2>int argc,\n<line3>sqlite3_value **argv\n<line4>){\n<line5>StatAccum *p;\n<line6>int nCol;                       /* Number of columns in index being sampled */\n<line7>int nKeyCol;                    /* Number of key columns */\n<line8>int nColUp;                     /* nCol rounded up for alignment */\n<line9>i64 n;                          /* Bytes of space to allocate */\n<line10>sqlite3 *db = sqlite3_context_db_handle(context);   /* Database connection */\n<line11>#ifdef SQLITE_ENABLE_STAT4\n<line12>/* Maximum number of samples.  0 if STAT4 data is not collected */\n<line13>int mxSample = OptimizationEnabled(db,SQLITE_Stat4) ?SQLITE_STAT4_SAMPLES :0;\n<line14>#endif\n<line15>/* Decode the three function arguments */\n<line16>UNUSED_PARAMETER(argc);\n<line17>nCol = sqlite3_value_int(argv[0]);\n<line18>assert( nCol>0 );\n<line19>nColUp = sizeof(tRowcnt)<8 ? (nCol+1)&~1 : nCol;\n<line20>nKeyCol = sqlite3_value_int(argv[1]);\n<line21>assert( nKeyCol<=nCol );\n<line22>assert( nKeyCol>0 );\n<line23>/* Allocate the space required for the StatAccum object */\n<line24>n = sizeof(*p)\n<line25>+ sizeof(tRowcnt)*nColUp;                    /* StatAccum.anDLt */\n<line26>#ifdef SQLITE_ENABLE_STAT4\n<line27>n += sizeof(tRowcnt)*nColUp;                   /* StatAccum.anEq */\n<line28>if( mxSample ){\n<line29>n += sizeof(tRowcnt)*nColUp                  /* StatAccum.anLt */\n<line30>+ sizeof(StatSample)*(nCol+mxSample)       /* StatAccum.aBest[], a[] */\n<line31>+ sizeof(tRowcnt)*3*nColUp*(nCol+mxSample);\n<line32>}\n<line33>#endif\n<line34>p = sqlite3DbMallocZero(db, n);\n<line35>if( p==0 ){\n<line36>sqlite3_result_error_nomem(context);\n<line37>return;\n<line38>}\n<line39>p->db = db;\n<line40>p->nEst = sqlite3_value_int64(argv[2]);\n<line41>p->nRow = 0;\n<line42>p->nLimit = sqlite3_value_int(argv[3]);\n<line43>p->nCol = nCol;\n<line44>p->nKeyCol = nKeyCol;\n<line45>p->nSkipAhead = 0;\n<line46>p->current.anDLt = (tRowcnt*)&p[1];\n<line47>#ifdef SQLITE_ENABLE_STAT4\n<line48>p->current.anEq = &p->current.anDLt[nColUp];\n<line49>p->mxSample = p->nLimit==0 ? mxSample : 0;\n<line50>if( mxSample ){\n<line51>u8 *pSpace;                     /* Allocated space not yet assigned */\n<line52>int i;                          /* Used to iterate through p->aSample[] */\n<line53>p->iGet = -1;\n<line54>p->nPSample = (tRowcnt)(p->nEst/(mxSample/3+1) + 1);\n<line55>p->current.anLt = &p->current.anEq[nColUp];\n<line56>p->iPrn = 0x689e962d*(u32)nCol ^ 0xd0944565*(u32)sqlite3_value_int(argv[2]);\n<line57>/* Set up the StatAccum.a[] and aBest[] arrays */\n<line58>p->a = (struct StatSample*)&p->current.anLt[nColUp];\n<line59>p->aBest = &p->a[mxSample];\n<line60>pSpace = (u8*)(&p->a[mxSample+nCol]);\n<line61>for(i=0; i<(mxSample+nCol); i++){\n<line62>p->a[i].anEq = (tRowcnt *)pSpace; pSpace += (sizeof(tRowcnt) * nColUp);\n<line63>p->a[i].anLt = (tRowcnt *)pSpace; pSpace += (sizeof(tRowcnt) * nColUp);\n<line64>p->a[i].anDLt = (tRowcnt *)pSpace; pSpace += (sizeof(tRowcnt) * nColUp);\n<line65>}\n<line66>assert( (pSpace - (u8*)p)==n );\n<line67>for(i=0; i<nCol; i++){\n<line68>p->aBest[i].iCol = i;\n<line69>}\n<line70>}\n<line71>#endif\n<line72>/* Return a pointer to the allocated object to the caller.  Note that\n<line73>** only the pointer (the 2nd parameter) matters.  The size of the object\n<line74>** (given by the 3rd parameter) is never used and can be any positive\n<line75>** value. */\n<line76>sqlite3_result_blob(context, p, sizeof(*p), statAccumDestructor);\n<line77>}
----------------------------------------
Function: statPush
Content: <line0>static void statPush(\n<line1>sqlite3_context *context,\n<line2>int argc,\n<line3>sqlite3_value **argv\n<line4>){\n<line5>int i;\n<line6>/* The three function arguments */\n<line7>StatAccum *p = (StatAccum*)sqlite3_value_blob(argv[0]);\n<line8>int iChng = sqlite3_value_int(argv[1]);\n<line9>UNUSED_PARAMETER( argc );\n<line10>UNUSED_PARAMETER( context );\n<line11>assert( p->nCol>0 );\n<line12>assert( iChng<p->nCol );\n<line13>if( p->nRow==0 ){\n<line14>/* This is the first call to this function. Do initialization. */\n<line15>#ifdef SQLITE_ENABLE_STAT4\n<line16>for(i=0; i<p->nCol; i++) p->current.anEq[i] = 1;\n<line17>#endif\n<line18>}else{\n<line19>/* Second and subsequent calls get processed here */\n<line20>#ifdef SQLITE_ENABLE_STAT4\n<line21>if( p->mxSample ) samplePushPrevious(p, iChng);\n<line22>#endif\n<line23>/* Update anDLt[], anLt[] and anEq[] to reflect the values that apply\n<line24>** to the current row of the index. */\n<line25>#ifdef SQLITE_ENABLE_STAT4\n<line26>for(i=0; i<iChng; i++){\n<line27>p->current.anEq[i]++;\n<line28>}\n<line29>#endif\n<line30>for(i=iChng; i<p->nCol; i++){\n<line31>p->current.anDLt[i]++;\n<line32>#ifdef SQLITE_ENABLE_STAT4\n<line33>if( p->mxSample ) p->current.anLt[i] += p->current.anEq[i];\n<line34>p->current.anEq[i] = 1;\n<line35>#endif\n<line36>}\n<line37>}\n<line38>p->nRow++;\n<line39>#ifdef SQLITE_ENABLE_STAT4\n<line40>if( p->mxSample ){\n<line41>tRowcnt nLt;\n<line42>if( sqlite3_value_type(argv[2])==SQLITE_INTEGER ){\n<line43>sampleSetRowidInt64(p->db, &p->current, sqlite3_value_int64(argv[2]));\n<line44>}else{\n<line45>sampleSetRowid(p->db, &p->current, sqlite3_value_bytes(argv[2]),\n<line46>sqlite3_value_blob(argv[2]));\n<line47>}\n<line48>p->current.iHash = p->iPrn = p->iPrn*1103515245 + 12345;\n<line49>nLt = p->current.anLt[p->nCol-1];\n<line50>/* Check if this is to be a periodic sample. If so, add it. */\n<line51>if( (nLt/p->nPSample)!=(nLt+1)/p->nPSample ){\n<line52>p->current.isPSample = 1;\n<line53>p->current.iCol = 0;\n<line54>sampleInsert(p, &p->current, p->nCol-1);\n<line55>p->current.isPSample = 0;\n<line56>}\n<line57>/* Update the aBest[] array. */\n<line58>for(i=0; i<(p->nCol-1); i++){\n<line59>p->current.iCol = i;\n<line60>if( i>=iChng || sampleIsBetterPost(p, &p->current, &p->aBest[i]) ){\n<line61>sampleCopy(p, &p->aBest[i], &p->current);\n<line62>}\n<line63>}\n<line64>}else\n<line65>#endif\n<line66>if( p->nLimit && p->nRow>(tRowcnt)p->nLimit*(p->nSkipAhead+1) ){\n<line67>p->nSkipAhead++;\n<line68>sqlite3_result_int(context, p->current.anDLt[0]>0);\n<line69>}\n<line70>}
----------------------------------------
Function: statGet
Content: <line0>static void statGet(\n<line1>sqlite3_context *context,\n<line2>int argc,\n<line3>sqlite3_value **argv\n<line4>){\n<line5>StatAccum *p = (StatAccum*)sqlite3_value_blob(argv[0]);\n<line6>#ifdef SQLITE_ENABLE_STAT4\n<line7>/* STAT4 has a parameter on this routine. */\n<line8>int eCall = sqlite3_value_int(argv[1]);\n<line9>assert( argc==2 );\n<line10>assert( eCall==STAT_GET_STAT1 || eCall==STAT_GET_NEQ\n<line11>|| eCall==STAT_GET_ROWID || eCall==STAT_GET_NLT\n<line12>|| eCall==STAT_GET_NDLT\n<line13>);\n<line14>assert( eCall==STAT_GET_STAT1 || p->mxSample );\n<line15>if( eCall==STAT_GET_STAT1 )\n<line16>#else\n<line17>assert( argc==1 );\n<line18>#endif\n<line19>{\n<line20>/* Return the value to store in the "stat" column of the sqlite_stat1\n<line21>** table for this index.\n<line22>**\n<line23>** The value is a string composed of a list of integers describing\n<line24>** the index. The first integer in the list is the total number of\n<line25>** entries in the index. There is one additional integer in the list\n<line26>** for each indexed column. This additional integer is an estimate of\n<line27>** the number of rows matched by a equality query on the index using\n<line28>** a key with the corresponding number of fields. In other words,\n<line29>** if the index is on columns (a,b) and the sqlite_stat1 value is\n<line30>** "100 10 2", then SQLite estimates that:\n<line31>**\n<line32>**   * the index contains 100 rows,\n<line33>**   * "WHERE a=?" matches 10 rows, and\n<line34>**   * "WHERE a=? AND b=?" matches 2 rows.\n<line35>**\n<line36>** If D is the count of distinct values and K is the total number of\n<line37>** rows, then each estimate is usually computed as:\n<line38>**\n<line39>**        I = (K+D-1)/D\n<line40>**\n<line41>** In other words, I is K/D rounded up to the next whole integer.\n<line42>** However, if I is between 1.0 and 1.1 (in other words if I is\n<line43>** close to 1.0 but just a little larger) then do not round up but\n<line44>** instead keep the I value at 1.0.\n<line45>*/\n<line46>sqlite3_str sStat;   /* Text of the constructed "stat" line */\n<line47>int i;               /* Loop counter */\n<line48>sqlite3StrAccumInit(&sStat, 0, 0, 0, (p->nKeyCol+1)*100);\n<line49>sqlite3_str_appendf(&sStat, "%llu",\n<line50>p->nSkipAhead ? (u64)p->nEst : (u64)p->nRow);\n<line51>for(i=0; i<p->nKeyCol; i++){\n<line52>u64 nDistinct = p->current.anDLt[i] + 1;\n<line53>u64 iVal = (p->nRow + nDistinct - 1) / nDistinct;\n<line54>if( iVal==2 && p->nRow*10 <= nDistinct*11 ) iVal = 1;\n<line55>sqlite3_str_appendf(&sStat, " %llu", iVal);\n<line56>#ifdef SQLITE_ENABLE_STAT4\n<line57>assert( p->current.anEq[i] || p->nRow==0 );\n<line58>#endif\n<line59>}\n<line60>sqlite3ResultStrAccum(context, &sStat);\n<line61>}\n<line62>#ifdef SQLITE_ENABLE_STAT4\n<line63>else if( eCall==STAT_GET_ROWID ){\n<line64>if( p->iGet<0 ){\n<line65>samplePushPrevious(p, 0);\n<line66>p->iGet = 0;\n<line67>}\n<line68>if( p->iGet<p->nSample ){\n<line69>StatSample *pS = p->a + p->iGet;\n<line70>if( pS->nRowid==0 ){\n<line71>sqlite3_result_int64(context, pS->u.iRowid);\n<line72>}else{\n<line73>sqlite3_result_blob(context, pS->u.aRowid, pS->nRowid,\n<line74>SQLITE_TRANSIENT);\n<line75>}\n<line76>}\n<line77>}else{\n<line78>tRowcnt *aCnt = 0;\n<line79>sqlite3_str sStat;\n<line80>int i;\n<line81>assert( p->iGet<p->nSample );\n<line82>switch( eCall ){\n<line83>case STAT_GET_NEQ:  aCnt = p->a[p->iGet].anEq; break;\n<line84>case STAT_GET_NLT:  aCnt = p->a[p->iGet].anLt; break;\n<line85>default: {\n<line86>aCnt = p->a[p->iGet].anDLt;\n<line87>p->iGet++;\n<line88>break;\n<line89>}\n<line90>}\n<line91>sqlite3StrAccumInit(&sStat, 0, 0, 0, p->nCol*100);\n<line92>for(i=0; i<p->nCol; i++){\n<line93>sqlite3_str_appendf(&sStat, "%llu ", (u64)aCnt[i]);\n<line94>}\n<line95>if( sStat.nChar ) sStat.nChar--;\n<line96>sqlite3ResultStrAccum(context, &sStat);\n<line97>}\n<line98>#endif /* SQLITE_ENABLE_STAT4 */\n<line99>#ifndef SQLITE_DEBUG\n<line100>UNUSED_PARAMETER( argc );\n<line101>#endif\n<line102>}
----------------------------------------
Function: callStatGet
Content: <line0>static void callStatGet(Parse *pParse, int regStat, int iParam, int regOut){\n<line1>#ifdef SQLITE_ENABLE_STAT4\n<line2>sqlite3VdbeAddOp2(pParse->pVdbe, OP_Integer, iParam, regStat+1);\n<line3>#elif SQLITE_DEBUG\n<line4>assert( iParam==STAT_GET_STAT1 );\n<line5>#else\n<line6>UNUSED_PARAMETER( iParam );\n<line7>#endif\n<line8>assert( regOut!=regStat && regOut!=regStat+1 );\n<line9>sqlite3VdbeAddFunctionCall(pParse, 0, regStat, regOut, 1+IsStat4,\n<line10>&statGetFuncdef, 0);\n<line11>}
----------------------------------------
Function: analyzeOneTable
Content: <line0>static void analyzeOneTable(\n<line1>Parse *pParse,   /* Parser context */\n<line2>Table *pTab,     /* Table whose indices are to be analyzed */\n<line3>Index *pOnlyIdx, /* If not NULL, only analyze this one index */\n<line4>int iStatCur,    /* Index of VdbeCursor that writes the sqlite_stat1 table */\n<line5>int iMem,        /* Available memory locations begin here */\n<line6>int iTab         /* Next available cursor */\n<line7>){\n<line8>sqlite3 *db = pParse->db;    /* Database handle */\n<line9>Index *pIdx;                 /* An index to being analyzed */\n<line10>int iIdxCur;                 /* Cursor open on index being analyzed */\n<line11>int iTabCur;                 /* Table cursor */\n<line12>Vdbe *v;                     /* The virtual machine being built up */\n<line13>int i;                       /* Loop counter */\n<line14>int jZeroRows = -1;          /* Jump from here if number of rows is zero */\n<line15>int iDb;                     /* Index of database containing pTab */\n<line16>u8 needTableCnt = 1;         /* True to count the table */\n<line17>int regNewRowid = iMem++;    /* Rowid for the inserted record */\n<line18>int regStat = iMem++;        /* Register to hold StatAccum object */\n<line19>int regChng = iMem++;        /* Index of changed index field */\n<line20>int regRowid = iMem++;       /* Rowid argument passed to stat_push() */\n<line21>int regTemp = iMem++;        /* Temporary use register */\n<line22>int regTemp2 = iMem++;       /* Second temporary use register */\n<line23>int regTabname = iMem++;     /* Register containing table name */\n<line24>int regIdxname = iMem++;     /* Register containing index name */\n<line25>int regStat1 = iMem++;       /* Value for the stat column of sqlite_stat1 */\n<line26>int regPrev = iMem;          /* MUST BE LAST (see below) */\n<line27>#ifdef SQLITE_ENABLE_STAT4\n<line28>int doOnce = 1;              /* Flag for a one-time computation */\n<line29>#endif\n<line30>#ifdef SQLITE_ENABLE_PREUPDATE_HOOK\n<line31>Table *pStat1 = 0;\n<line32>#endif\n<line33>sqlite3TouchRegister(pParse, iMem);\n<line34>assert( sqlite3NoTempsInRange(pParse, regNewRowid, iMem) );\n<line35>v = sqlite3GetVdbe(pParse);\n<line36>if( v==0 || NEVER(pTab==0) ){\n<line37>return;\n<line38>}\n<line39>if( !IsOrdinaryTable(pTab) ){\n<line40>/* Do not gather statistics on views or virtual tables */\n<line41>return;\n<line42>}\n<line43>if( sqlite3_strlike("sqlite\\_%", pTab->zName, '\\')==0 ){\n<line44>/* Do not gather statistics on system tables */\n<line45>return;\n<line46>}\n<line47>assert( sqlite3BtreeHoldsAllMutexes(db) );\n<line48>iDb = sqlite3SchemaToIndex(db, pTab->pSchema);\n<line49>assert( iDb>=0 );\n<line50>assert( sqlite3SchemaMutexHeld(db, iDb, 0) );\n<line51>#ifndef SQLITE_OMIT_AUTHORIZATION\n<line52>if( sqlite3AuthCheck(pParse, SQLITE_ANALYZE, pTab->zName, 0,\n<line53>db->aDb[iDb].zDbSName ) ){\n<line54>return;\n<line55>}\n<line56>#endif\n<line57>#ifdef SQLITE_ENABLE_PREUPDATE_HOOK\n<line58>if( db->xPreUpdateCallback ){\n<line59>pStat1 = (Table*)sqlite3DbMallocZero(db, sizeof(Table) + 13);\n<line60>if( pStat1==0 ) return;\n<line61>pStat1->zName = (char*)&pStat1[1];\n<line62>memcpy(pStat1->zName, "sqlite_stat1", 13);\n<line63>pStat1->nCol = 3;\n<line64>pStat1->iPKey = -1;\n<line65>sqlite3VdbeAddOp4(pParse->pVdbe, OP_Noop, 0, 0, 0,(char*)pStat1,P4_DYNAMIC);\n<line66>}\n<line67>#endif\n<line68>/* Establish a read-lock on the table at the shared-cache level.\n<line69>** Open a read-only cursor on the table. Also allocate a cursor number\n<line70>** to use for scanning indexes (iIdxCur). No index cursor is opened at\n<line71>** this time though.  */\n<line72>sqlite3TableLock(pParse, iDb, pTab->tnum, 0, pTab->zName);\n<line73>iTabCur = iTab++;\n<line74>iIdxCur = iTab++;\n<line75>pParse->nTab = MAX(pParse->nTab, iTab);\n<line76>sqlite3OpenTable(pParse, iTabCur, iDb, pTab, OP_OpenRead);\n<line77>sqlite3VdbeLoadString(v, regTabname, pTab->zName);\n<line78>for(pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext){\n<line79>int nCol;                     /* Number of columns in pIdx. "N" */\n<line80>int addrGotoEnd;               /* Address of "OP_Rewind iIdxCur" */\n<line81>int addrNextRow;              /* Address of "next_row:" */\n<line82>const char *zIdxName;         /* Name of the index */\n<line83>int nColTest;                 /* Number of columns to test for changes */\n<line84>if( pOnlyIdx && pOnlyIdx!=pIdx ) continue;\n<line85>if( pIdx->pPartIdxWhere==0 ) needTableCnt = 0;\n<line86>if( !HasRowid(pTab) && IsPrimaryKeyIndex(pIdx) ){\n<line87>nCol = pIdx->nKeyCol;\n<line88>zIdxName = pTab->zName;\n<line89>nColTest = nCol - 1;\n<line90>}else{\n<line91>nCol = pIdx->nColumn;\n<line92>zIdxName = pIdx->zName;\n<line93>nColTest = pIdx->uniqNotNull ? pIdx->nKeyCol-1 : nCol-1;\n<line94>}\n<line95>/* Populate the register containing the index name. */\n<line96>sqlite3VdbeLoadString(v, regIdxname, zIdxName);\n<line97>VdbeComment((v, "Analysis for %s.%s", pTab->zName, zIdxName));\n<line98>/*\n<line99>** Pseudo-code for loop that calls stat_push():\n<line100>**\n<line101>**   regChng = 0\n<line102>**   Rewind csr\n<line103>**   if eof(csr){\n<line104>**      stat_init() with count = 0;\n<line105>**      goto end_of_scan;\n<line106>**   }\n<line107>**   count()\n<line108>**   stat_init()\n<line109>**   goto chng_addr_0;\n<line110>**\n<line111>**  next_row:\n<line112>**   regChng = 0\n<line113>**   if( idx(0) != regPrev(0) ) goto chng_addr_0\n<line114>**   regChng = 1\n<line115>**   if( idx(1) != regPrev(1) ) goto chng_addr_1\n<line116>**   ...\n<line117>**   regChng = N\n<line118>**   goto chng_addr_N\n<line119>**\n<line120>**  chng_addr_0:\n<line121>**   regPrev(0) = idx(0)\n<line122>**  chng_addr_1:\n<line123>**   regPrev(1) = idx(1)\n<line124>**  ...\n<line125>**\n<line126>**  endDistinctTest:\n<line127>**   regRowid = idx(rowid)\n<line128>**   stat_push(P, regChng, regRowid)\n<line129>**   Next csr\n<line130>**   if !eof(csr) goto next_row;\n<line131>**\n<line132>**  end_of_scan:\n<line133>*/\n<line134>/* Make sure there are enough memory cells allocated to accommodate\n<line135>** the regPrev array and a trailing rowid (the rowid slot is required\n<line136>** when building a record to insert into the sample column of\n<line137>** the sqlite_stat4 table.  */\n<line138>sqlite3TouchRegister(pParse, regPrev+nColTest);\n<line139>/* Open a read-only cursor on the index being analyzed. */\n<line140>assert( iDb==sqlite3SchemaToIndex(db, pIdx->pSchema) );\n<line141>sqlite3VdbeAddOp3(v, OP_OpenRead, iIdxCur, pIdx->tnum, iDb);\n<line142>sqlite3VdbeSetP4KeyInfo(pParse, pIdx);\n<line143>VdbeComment((v, "%s", pIdx->zName));\n<line144>/* Implementation of the following:\n<line145>**\n<line146>**   regChng = 0\n<line147>**   Rewind csr\n<line148>**   if eof(csr){\n<line149>**      stat_init() with count = 0;\n<line150>**      goto end_of_scan;\n<line151>**   }\n<line152>**   count()\n<line153>**   stat_init()\n<line154>**   goto chng_addr_0;\n<line155>*/\n<line156>assert( regTemp2==regStat+4 );\n<line157>sqlite3VdbeAddOp2(v, OP_Integer, db->nAnalysisLimit, regTemp2);\n<line158>/* Arguments to stat_init():\n<line159>**    (1) the number of columns in the index including the rowid\n<line160>**        (or for a WITHOUT ROWID table, the number of PK columns),\n<line161>**    (2) the number of columns in the key without the rowid/pk\n<line162>**    (3) estimated number of rows in the index. */\n<line163>sqlite3VdbeAddOp2(v, OP_Integer, nCol, regStat+1);\n<line164>assert( regRowid==regStat+2 );\n<line165>sqlite3VdbeAddOp2(v, OP_Integer, pIdx->nKeyCol, regRowid);\n<line166>sqlite3VdbeAddOp3(v, OP_Count, iIdxCur, regTemp,\n<line167>OptimizationDisabled(db, SQLITE_Stat4));\n<line168>sqlite3VdbeAddFunctionCall(pParse, 0, regStat+1, regStat, 4,\n<line169>&statInitFuncdef, 0);\n<line170>addrGotoEnd = sqlite3VdbeAddOp1(v, OP_Rewind, iIdxCur);\n<line171>VdbeCoverage(v);\n<line172>sqlite3VdbeAddOp2(v, OP_Integer, 0, regChng);\n<line173>addrNextRow = sqlite3VdbeCurrentAddr(v);\n<line174>if( nColTest>0 ){\n<line175>int endDistinctTest = sqlite3VdbeMakeLabel(pParse);\n<line176>int *aGotoChng;               /* Array of jump instruction addresses */\n<line177>aGotoChng = sqlite3DbMallocRawNN(db, sizeof(int)*nColTest);\n<line178>if( aGotoChng==0 ) continue;\n<line179>/*\n<line180>**  next_row:\n<line181>**   regChng = 0\n<line182>**   if( idx(0) != regPrev(0) ) goto chng_addr_0\n<line183>**   regChng = 1\n<line184>**   if( idx(1) != regPrev(1) ) goto chng_addr_1\n<line185>**   ...\n<line186>**   regChng = N\n<line187>**   goto endDistinctTest\n<line188>*/\n<line189>sqlite3VdbeAddOp0(v, OP_Goto);\n<line190>addrNextRow = sqlite3VdbeCurrentAddr(v);\n<line191>if( nColTest==1 && pIdx->nKeyCol==1 && IsUniqueIndex(pIdx) ){\n<line192>/* For a single-column UNIQUE index, once we have found a non-NULL\n<line193>** row, we know that all the rest will be distinct, so skip\n<line194>** subsequent distinctness tests. */\n<line195>sqlite3VdbeAddOp2(v, OP_NotNull, regPrev, endDistinctTest);\n<line196>VdbeCoverage(v);\n<line197>}\n<line198>for(i=0; i<nColTest; i++){\n<line199>char *pColl = (char*)sqlite3LocateCollSeq(pParse, pIdx->azColl[i]);\n<line200>sqlite3VdbeAddOp2(v, OP_Integer, i, regChng);\n<line201>sqlite3VdbeAddOp3(v, OP_Column, iIdxCur, i, regTemp);\n<line202>analyzeVdbeCommentIndexWithColumnName(v,pIdx,i);\n<line203>aGotoChng[i] =\n<line204>sqlite3VdbeAddOp4(v, OP_Ne, regTemp, 0, regPrev+i, pColl, P4_COLLSEQ);\n<line205>sqlite3VdbeChangeP5(v, SQLITE_NULLEQ);\n<line206>VdbeCoverage(v);\n<line207>}\n<line208>sqlite3VdbeAddOp2(v, OP_Integer, nColTest, regChng);\n<line209>sqlite3VdbeGoto(v, endDistinctTest);\n<line210>/*\n<line211>**  chng_addr_0:\n<line212>**   regPrev(0) = idx(0)\n<line213>**  chng_addr_1:\n<line214>**   regPrev(1) = idx(1)\n<line215>**  ...\n<line216>*/\n<line217>sqlite3VdbeJumpHere(v, addrNextRow-1);\n<line218>for(i=0; i<nColTest; i++){\n<line219>sqlite3VdbeJumpHere(v, aGotoChng[i]);\n<line220>sqlite3VdbeAddOp3(v, OP_Column, iIdxCur, i, regPrev+i);\n<line221>analyzeVdbeCommentIndexWithColumnName(v,pIdx,i);\n<line222>}\n<line223>sqlite3VdbeResolveLabel(v, endDistinctTest);\n<line224>sqlite3DbFree(db, aGotoChng);\n<line225>}\n<line226>/*\n<line227>**  chng_addr_N:\n<line228>**   regRowid = idx(rowid)            // STAT4 only\n<line229>**   stat_push(P, regChng, regRowid)  // 3rd parameter STAT4 only\n<line230>**   Next csr\n<line231>**   if !eof(csr) goto next_row;\n<line232>*/\n<line233>#ifdef SQLITE_ENABLE_STAT4\n<line234>if( OptimizationEnabled(db, SQLITE_Stat4) ){\n<line235>assert( regRowid==(regStat+2) );\n<line236>if( HasRowid(pTab) ){\n<line237>sqlite3VdbeAddOp2(v, OP_IdxRowid, iIdxCur, regRowid);\n<line238>}else{\n<line239>Index *pPk = sqlite3PrimaryKeyIndex(pIdx->pTable);\n<line240>int j, k, regKey;\n<line241>regKey = sqlite3GetTempRange(pParse, pPk->nKeyCol);\n<line242>for(j=0; j<pPk->nKeyCol; j++){\n<line243>k = sqlite3TableColumnToIndex(pIdx, pPk->aiColumn[j]);\n<line244>assert( k>=0 && k<pIdx->nColumn );\n<line245>sqlite3VdbeAddOp3(v, OP_Column, iIdxCur, k, regKey+j);\n<line246>analyzeVdbeCommentIndexWithColumnName(v,pIdx,k);\n<line247>}\n<line248>sqlite3VdbeAddOp3(v, OP_MakeRecord, regKey, pPk->nKeyCol, regRowid);\n<line249>sqlite3ReleaseTempRange(pParse, regKey, pPk->nKeyCol);\n<line250>}\n<line251>}\n<line252>#endif\n<line253>assert( regChng==(regStat+1) );\n<line254>{\n<line255>sqlite3VdbeAddFunctionCall(pParse, 1, regStat, regTemp, 2+IsStat4,\n<line256>&statPushFuncdef, 0);\n<line257>if( db->nAnalysisLimit ){\n<line258>int j1, j2, j3;\n<line259>j1 = sqlite3VdbeAddOp1(v, OP_IsNull, regTemp); VdbeCoverage(v);\n<line260>j2 = sqlite3VdbeAddOp1(v, OP_If, regTemp); VdbeCoverage(v);\n<line261>j3 = sqlite3VdbeAddOp4Int(v, OP_SeekGT, iIdxCur, 0, regPrev, 1);\n<line262>VdbeCoverage(v);\n<line263>sqlite3VdbeJumpHere(v, j1);\n<line264>sqlite3VdbeAddOp2(v, OP_Next, iIdxCur, addrNextRow); VdbeCoverage(v);\n<line265>sqlite3VdbeJumpHere(v, j2);\n<line266>sqlite3VdbeJumpHere(v, j3);\n<line267>}else{\n<line268>sqlite3VdbeAddOp2(v, OP_Next, iIdxCur, addrNextRow); VdbeCoverage(v);\n<line269>}\n<line270>}\n<line271>/* Add the entry to the stat1 table. */\n<line272>if( pIdx->pPartIdxWhere ){\n<line273>/* Partial indexes might get a zero-entry in sqlite_stat1.  But\n<line274>** an empty table is omitted from sqlite_stat1. */\n<line275>sqlite3VdbeJumpHere(v, addrGotoEnd);\n<line276>addrGotoEnd = 0;\n<line277>}\n<line278>callStatGet(pParse, regStat, STAT_GET_STAT1, regStat1);\n<line279>assert( "BBB"[0]==SQLITE_AFF_TEXT );\n<line280>sqlite3VdbeAddOp4(v, OP_MakeRecord, regTabname, 3, regTemp, "BBB", 0);\n<line281>sqlite3VdbeAddOp2(v, OP_NewRowid, iStatCur, regNewRowid);\n<line282>sqlite3VdbeAddOp3(v, OP_Insert, iStatCur, regTemp, regNewRowid);\n<line283>#ifdef SQLITE_ENABLE_PREUPDATE_HOOK\n<line284>sqlite3VdbeChangeP4(v, -1, (char*)pStat1, P4_TABLE);\n<line285>#endif\n<line286>sqlite3VdbeChangeP5(v, OPFLAG_APPEND);\n<line287>/* Add the entries to the stat4 table. */\n<line288>#ifdef SQLITE_ENABLE_STAT4\n<line289>if( OptimizationEnabled(db, SQLITE_Stat4) && db->nAnalysisLimit==0 ){\n<line290>int regEq = regStat1;\n<line291>int regLt = regStat1+1;\n<line292>int regDLt = regStat1+2;\n<line293>int regSample = regStat1+3;\n<line294>int regCol = regStat1+4;\n<line295>int regSampleRowid = regCol + nCol;\n<line296>int addrNext;\n<line297>int addrIsNull;\n<line298>u8 seekOp = HasRowid(pTab) ? OP_NotExists : OP_NotFound;\n<line299>/* No STAT4 data is generated if the number of rows is zero */\n<line300>if( addrGotoEnd==0 ){\n<line301>sqlite3VdbeAddOp2(v, OP_Cast, regStat1, SQLITE_AFF_INTEGER);\n<line302>addrGotoEnd = sqlite3VdbeAddOp1(v, OP_IfNot, regStat1);\n<line303>VdbeCoverage(v);\n<line304>}\n<line305>if( doOnce ){\n<line306>int mxCol = nCol;\n<line307>Index *pX;\n<line308>/* Compute the maximum number of columns in any index */\n<line309>for(pX=pTab->pIndex; pX; pX=pX->pNext){\n<line310>int nColX;                     /* Number of columns in pX */\n<line311>if( !HasRowid(pTab) && IsPrimaryKeyIndex(pX) ){\n<line312>nColX = pX->nKeyCol;\n<line313>}else{\n<line314>nColX = pX->nColumn;\n<line315>}\n<line316>if( nColX>mxCol ) mxCol = nColX;\n<line317>}\n<line318>/* Allocate space to compute results for the largest index */\n<line319>sqlite3TouchRegister(pParse, regCol+mxCol);\n<line320>doOnce = 0;\n<line321>#ifdef SQLITE_DEBUG\n<line322>/* Verify that the call to sqlite3ClearTempRegCache() below\n<line323>** really is needed.\n<line324>** https://sqlite.org/forum/forumpost/83cb4a95a0 (2023-03-25)\n<line325>*/\n<line326>testcase( !sqlite3NoTempsInRange(pParse, regEq, regCol+mxCol) );\n<line327>#endif\n<line328>sqlite3ClearTempRegCache(pParse);  /* tag-20230325-1 */\n<line329>assert( sqlite3NoTempsInRange(pParse, regEq, regCol+mxCol) );\n<line330>}\n<line331>assert( sqlite3NoTempsInRange(pParse, regEq, regCol+nCol) );\n<line332>addrNext = sqlite3VdbeCurrentAddr(v);\n<line333>callStatGet(pParse, regStat, STAT_GET_ROWID, regSampleRowid);\n<line334>addrIsNull = sqlite3VdbeAddOp1(v, OP_IsNull, regSampleRowid);\n<line335>VdbeCoverage(v);\n<line336>callStatGet(pParse, regStat, STAT_GET_NEQ, regEq);\n<line337>callStatGet(pParse, regStat, STAT_GET_NLT, regLt);\n<line338>callStatGet(pParse, regStat, STAT_GET_NDLT, regDLt);\n<line339>sqlite3VdbeAddOp4Int(v, seekOp, iTabCur, addrNext, regSampleRowid, 0);\n<line340>VdbeCoverage(v);\n<line341>for(i=0; i<nCol; i++){\n<line342>sqlite3ExprCodeLoadIndexColumn(pParse, pIdx, iTabCur, i, regCol+i);\n<line343>}\n<line344>sqlite3VdbeAddOp3(v, OP_MakeRecord, regCol, nCol, regSample);\n<line345>sqlite3VdbeAddOp3(v, OP_MakeRecord, regTabname, 6, regTemp);\n<line346>sqlite3VdbeAddOp2(v, OP_NewRowid, iStatCur+1, regNewRowid);\n<line347>sqlite3VdbeAddOp3(v, OP_Insert, iStatCur+1, regTemp, regNewRowid);\n<line348>sqlite3VdbeAddOp2(v, OP_Goto, 1, addrNext); /* P1==1 for end-of-loop */\n<line349>sqlite3VdbeJumpHere(v, addrIsNull);\n<line350>}\n<line351>#endif /* SQLITE_ENABLE_STAT4 */\n<line352>/* End of analysis */\n<line353>if( addrGotoEnd ) sqlite3VdbeJumpHere(v, addrGotoEnd);\n<line354>}\n<line355>/* Create a single sqlite_stat1 entry containing NULL as the index\n<line356>** name and the row count as the content.\n<line357>*/\n<line358>if( pOnlyIdx==0 && needTableCnt ){\n<line359>VdbeComment((v, "%s", pTab->zName));\n<line360>sqlite3VdbeAddOp2(v, OP_Count, iTabCur, regStat1);\n<line361>jZeroRows = sqlite3VdbeAddOp1(v, OP_IfNot, regStat1); VdbeCoverage(v);\n<line362>sqlite3VdbeAddOp2(v, OP_Null, 0, regIdxname);\n<line363>assert( "BBB"[0]==SQLITE_AFF_TEXT );\n<line364>sqlite3VdbeAddOp4(v, OP_MakeRecord, regTabname, 3, regTemp, "BBB", 0);\n<line365>sqlite3VdbeAddOp2(v, OP_NewRowid, iStatCur, regNewRowid);\n<line366>sqlite3VdbeAddOp3(v, OP_Insert, iStatCur, regTemp, regNewRowid);\n<line367>sqlite3VdbeChangeP5(v, OPFLAG_APPEND);\n<line368>#ifdef SQLITE_ENABLE_PREUPDATE_HOOK\n<line369>sqlite3VdbeChangeP4(v, -1, (char*)pStat1, P4_TABLE);\n<line370>#endif\n<line371>sqlite3VdbeJumpHere(v, jZeroRows);\n<line372>}\n<line373>}
----------------------------------------
Function: loadAnalysis
Content: <line0>static void loadAnalysis(Parse *pParse, int iDb){\n<line1>Vdbe *v = sqlite3GetVdbe(pParse);\n<line2>if( v ){\n<line3>sqlite3VdbeAddOp1(v, OP_LoadAnalysis, iDb);\n<line4>}\n<line5>}
----------------------------------------
Function: analyzeDatabase
Content: <line0>static void analyzeDatabase(Parse *pParse, int iDb){\n<line1>sqlite3 *db = pParse->db;\n<line2>Schema *pSchema = db->aDb[iDb].pSchema;    /* Schema of database iDb */\n<line3>HashElem *k;\n<line4>int iStatCur;\n<line5>int iMem;\n<line6>int iTab;\n<line7>sqlite3BeginWriteOperation(pParse, 0, iDb);\n<line8>iStatCur = pParse->nTab;\n<line9>pParse->nTab += 3;\n<line10>openStatTable(pParse, iDb, iStatCur, 0, 0);\n<line11>iMem = pParse->nMem+1;\n<line12>iTab = pParse->nTab;\n<line13>assert( sqlite3SchemaMutexHeld(db, iDb, 0) );\n<line14>for(k=sqliteHashFirst(&pSchema->tblHash); k; k=sqliteHashNext(k)){\n<line15>Table *pTab = (Table*)sqliteHashData(k);\n<line16>analyzeOneTable(pParse, pTab, 0, iStatCur, iMem, iTab);\n<line17>#ifdef SQLITE_ENABLE_STAT4\n<line18>iMem = sqlite3FirstAvailableRegister(pParse, iMem);\n<line19>#else\n<line20>assert( iMem==sqlite3FirstAvailableRegister(pParse,iMem) );\n<line21>#endif\n<line22>}\n<line23>loadAnalysis(pParse, iDb);\n<line24>}
----------------------------------------
Function: analyzeTable
Content: <line0>static void analyzeTable(Parse *pParse, Table *pTab, Index *pOnlyIdx){\n<line1>int iDb;\n<line2>int iStatCur;\n<line3>assert( pTab!=0 );\n<line4>assert( sqlite3BtreeHoldsAllMutexes(pParse->db) );\n<line5>iDb = sqlite3SchemaToIndex(pParse->db, pTab->pSchema);\n<line6>sqlite3BeginWriteOperation(pParse, 0, iDb);\n<line7>iStatCur = pParse->nTab;\n<line8>pParse->nTab += 3;\n<line9>if( pOnlyIdx ){\n<line10>openStatTable(pParse, iDb, iStatCur, pOnlyIdx->zName, "idx");\n<line11>}else{\n<line12>openStatTable(pParse, iDb, iStatCur, pTab->zName, "tbl");\n<line13>}\n<line14>analyzeOneTable(pParse, pTab, pOnlyIdx, iStatCur,pParse->nMem+1,pParse->nTab);\n<line15>loadAnalysis(pParse, iDb);\n<line16>}
----------------------------------------
Function: decodeIntArray
Content: <line0>static void decodeIntArray(\n<line1>char *zIntArray,       /* String containing int array to decode */\n<line2>int nOut,              /* Number of slots in aOut[] */\n<line3>tRowcnt *aOut,         /* Store integers here */\n<line4>LogEst *aLog,          /* Or, if aOut==0, here */\n<line5>Index *pIndex          /* Handle extra flags for this index, if not NULL */\n<line6>){\n<line7>char *z = zIntArray;\n<line8>int c;\n<line9>int i;\n<line10>tRowcnt v;\n<line11>#ifdef SQLITE_ENABLE_STAT4\n<line12>if( z==0 ) z = "";\n<line13>#else\n<line14>assert( z!=0 );\n<line15>#endif\n<line16>for(i=0; *z && i<nOut; i++){\n<line17>v = 0;\n<line18>while( (c=z[0])>='0' && c<='9' ){\n<line19>v = v*10 + c - '0';\n<line20>z++;\n<line21>}\n<line22>#ifdef SQLITE_ENABLE_STAT4\n<line23>if( aOut ) aOut[i] = v;\n<line24>if( aLog ) aLog[i] = sqlite3LogEst(v);\n<line25>#else\n<line26>assert( aOut==0 );\n<line27>UNUSED_PARAMETER(aOut);\n<line28>assert( aLog!=0 );\n<line29>aLog[i] = sqlite3LogEst(v);\n<line30>#endif\n<line31>if( *z==' ' ) z++;\n<line32>}\n<line33>#ifndef SQLITE_ENABLE_STAT4\n<line34>assert( pIndex!=0 ); {\n<line35>#else\n<line36>if( pIndex ){\n<line37>#endif\n<line38>pIndex->bUnordered = 0;\n<line39>pIndex->noSkipScan = 0;\n<line40>while( z[0] ){\n<line41>if( sqlite3_strglob("unordered*", z)==0 ){\n<line42>pIndex->bUnordered = 1;\n<line43>}else if( sqlite3_strglob("sz=[0-9]*", z)==0 ){\n<line44>int sz = sqlite3Atoi(z+3);\n<line45>if( sz<2 ) sz = 2;\n<line46>pIndex->szIdxRow = sqlite3LogEst(sz);\n<line47>}else if( sqlite3_strglob("noskipscan*", z)==0 ){\n<line48>pIndex->noSkipScan = 1;\n<line49>}\n<line50>#ifdef SQLITE_ENABLE_COSTMULT\n<line51>else if( sqlite3_strglob("costmult=[0-9]*",z)==0 ){\n<line52>pIndex->pTable->costMult = sqlite3LogEst(sqlite3Atoi(z+9));\n<line53>}\n<line54>#endif\n<line55>while( z[0]!=0 && z[0]!=' ' ) z++;\n<line56>while( z[0]==' ' ) z++;\n<line57>}\n<line58>}\n<line59>}
----------------------------------------
Function: analysisLoader
Content: <line0>static int analysisLoader(void *pData, int argc, char **argv, char **NotUsed){\n<line1>analysisInfo *pInfo = (analysisInfo*)pData;\n<line2>Index *pIndex;\n<line3>Table *pTable;\n<line4>const char *z;\n<line5>assert( argc==3 );\n<line6>UNUSED_PARAMETER2(NotUsed, argc);\n<line7>if( argv==0 || argv[0]==0 || argv[2]==0 ){\n<line8>return 0;\n<line9>}\n<line10>pTable = sqlite3FindTable(pInfo->db, argv[0], pInfo->zDatabase);\n<line11>if( pTable==0 ){\n<line12>return 0;\n<line13>}\n<line14>if( argv[1]==0 ){\n<line15>pIndex = 0;\n<line16>}else if( sqlite3_stricmp(argv[0],argv[1])==0 ){\n<line17>pIndex = sqlite3PrimaryKeyIndex(pTable);\n<line18>}else{\n<line19>pIndex = sqlite3FindIndex(pInfo->db, argv[1], pInfo->zDatabase);\n<line20>}\n<line21>z = argv[2];\n<line22>if( pIndex ){\n<line23>tRowcnt *aiRowEst = 0;\n<line24>int nCol = pIndex->nKeyCol+1;\n<line25>#ifdef SQLITE_ENABLE_STAT4\n<line26>/* Index.aiRowEst may already be set here if there are duplicate\n<line27>** sqlite_stat1 entries for this index. In that case just clobber\n<line28>** the old data with the new instead of allocating a new array.  */\n<line29>if( pIndex->aiRowEst==0 ){\n<line30>pIndex->aiRowEst = (tRowcnt*)sqlite3MallocZero(sizeof(tRowcnt) * nCol);\n<line31>if( pIndex->aiRowEst==0 ) sqlite3OomFault(pInfo->db);\n<line32>}\n<line33>aiRowEst = pIndex->aiRowEst;\n<line34>#endif\n<line35>pIndex->bUnordered = 0;\n<line36>decodeIntArray((char*)z, nCol, aiRowEst, pIndex->aiRowLogEst, pIndex);\n<line37>pIndex->hasStat1 = 1;\n<line38>if( pIndex->pPartIdxWhere==0 ){\n<line39>pTable->nRowLogEst = pIndex->aiRowLogEst[0];\n<line40>pTable->tabFlags |= TF_HasStat1;\n<line41>}\n<line42>}else{\n<line43>Index fakeIdx;\n<line44>fakeIdx.szIdxRow = pTable->szTabRow;\n<line45>#ifdef SQLITE_ENABLE_COSTMULT\n<line46>fakeIdx.pTable = pTable;\n<line47>#endif\n<line48>decodeIntArray((char*)z, 1, 0, &pTable->nRowLogEst, &fakeIdx);\n<line49>pTable->szTabRow = fakeIdx.szIdxRow;\n<line50>pTable->tabFlags |= TF_HasStat1;\n<line51>}\n<line52>return 0;\n<line53>}
----------------------------------------
Function: resolveAttachExpr
Content: <line0>static int resolveAttachExpr(NameContext *pName, Expr *pExpr)\n<line1>{\n<line2>int rc = SQLITE_OK;\n<line3>if( pExpr ){\n<line4>if( pExpr->op!=TK_ID ){\n<line5>rc = sqlite3ResolveExprNames(pName, pExpr);\n<line6>}else{\n<line7>pExpr->op = TK_STRING;\n<line8>}\n<line9>}\n<line10>return rc;\n<line11>}
----------------------------------------
Function: attachFunc
Content: <line0>static void attachFunc(\n<line1>sqlite3_context *context,\n<line2>int NotUsed,\n<line3>sqlite3_value **argv\n<line4>){\n<line5>int i;\n<line6>int rc = 0;\n<line7>sqlite3 *db = sqlite3_context_db_handle(context);\n<line8>const char *zName;\n<line9>const char *zFile;\n<line10>char *zPath = 0;\n<line11>char *zErr = 0;\n<line12>unsigned int flags;\n<line13>Db *aNew;                 /* New array of Db pointers */\n<line14>Db *pNew = 0;             /* Db object for the newly attached database */\n<line15>char *zErrDyn = 0;\n<line16>sqlite3_vfs *pVfs;\n<line17>UNUSED_PARAMETER(NotUsed);\n<line18>zFile = (const char *)sqlite3_value_text(argv[0]);\n<line19>zName = (const char *)sqlite3_value_text(argv[1]);\n<line20>if( zFile==0 ) zFile = "";\n<line21>if( zName==0 ) zName = "";\n<line22>#ifndef SQLITE_OMIT_DESERIALIZE\n<line23># define REOPEN_AS_MEMDB(db)  (db->init.reopenMemdb)\n<line24>#else\n<line25># define REOPEN_AS_MEMDB(db)  (0)\n<line26>#endif\n<line27>if( REOPEN_AS_MEMDB(db) ){\n<line28>/* This is not a real ATTACH.  Instead, this routine is being called\n<line29>** from sqlite3_deserialize() to close database db->init.iDb and\n<line30>** reopen it as a MemDB */\n<line31>Btree *pNewBt = 0;\n<line32>pVfs = sqlite3_vfs_find("memdb");\n<line33>if( pVfs==0 ) return;\n<line34>rc = sqlite3BtreeOpen(pVfs, "x\0", db, &pNewBt, 0, SQLITE_OPEN_MAIN_DB);\n<line35>if( rc==SQLITE_OK ){\n<line36>Schema *pNewSchema = sqlite3SchemaGet(db, pNewBt);\n<line37>if( pNewSchema ){\n<line38>/* Both the Btree and the new Schema were allocated successfully.\n<line39>** Close the old db and update the aDb[] slot with the new memdb\n<line40>** values.  */\n<line41>pNew = &db->aDb[db->init.iDb];\n<line42>if( ALWAYS(pNew->pBt) ) sqlite3BtreeClose(pNew->pBt);\n<line43>pNew->pBt = pNewBt;\n<line44>pNew->pSchema = pNewSchema;\n<line45>}else{\n<line46>sqlite3BtreeClose(pNewBt);\n<line47>rc = SQLITE_NOMEM;\n<line48>}\n<line49>}\n<line50>if( rc ) goto attach_error;\n<line51>}else{\n<line52>/* This is a real ATTACH\n<line53>**\n<line54>** Check for the following errors:\n<line55>**\n<line56>**     * Too many attached databases,\n<line57>**     * Transaction currently open\n<line58>**     * Specified database name already being used.\n<line59>*/\n<line60>if( db->nDb>=db->aLimit[SQLITE_LIMIT_ATTACHED]+2 ){\n<line61>zErrDyn = sqlite3MPrintf(db, "too many attached databases - max %d",\n<line62>db->aLimit[SQLITE_LIMIT_ATTACHED]\n<line63>);\n<line64>goto attach_error;\n<line65>}\n<line66>for(i=0; i<db->nDb; i++){\n<line67>assert( zName );\n<line68>if( sqlite3DbIsNamed(db, i, zName) ){\n<line69>zErrDyn = sqlite3MPrintf(db, "database %s is already in use", zName);\n<line70>goto attach_error;\n<line71>}\n<line72>}\n<line73>/* Allocate the new entry in the db->aDb[] array and initialize the schema\n<line74>** hash tables.\n<line75>*/\n<line76>if( db->aDb==db->aDbStatic ){\n<line77>aNew = sqlite3DbMallocRawNN(db, sizeof(db->aDb[0])*3 );\n<line78>if( aNew==0 ) return;\n<line79>memcpy(aNew, db->aDb, sizeof(db->aDb[0])*2);\n<line80>}else{\n<line81>aNew = sqlite3DbRealloc(db, db->aDb, sizeof(db->aDb[0])*(1+(i64)db->nDb));\n<line82>if( aNew==0 ) return;\n<line83>}\n<line84>db->aDb = aNew;\n<line85>pNew = &db->aDb[db->nDb];\n<line86>memset(pNew, 0, sizeof(*pNew));\n<line87>/* Open the database file. If the btree is successfully opened, use\n<line88>** it to obtain the database schema. At this point the schema may\n<line89>** or may not be initialized.\n<line90>*/\n<line91>flags = db->openFlags;\n<line92>rc = sqlite3ParseUri(db->pVfs->zName, zFile, &flags, &pVfs, &zPath, &zErr);\n<line93>if( rc!=SQLITE_OK ){\n<line94>if( rc==SQLITE_NOMEM ) sqlite3OomFault(db);\n<line95>sqlite3_result_error(context, zErr, -1);\n<line96>sqlite3_free(zErr);\n<line97>return;\n<line98>}\n<line99>if( (db->flags & SQLITE_AttachWrite)==0 ){\n<line100>flags &= ~(SQLITE_OPEN_CREATE|SQLITE_OPEN_READWRITE);\n<line101>flags |= SQLITE_OPEN_READONLY;\n<line102>}else if( (db->flags & SQLITE_AttachCreate)==0 ){\n<line103>flags &= ~SQLITE_OPEN_CREATE;\n<line104>}\n<line105>assert( pVfs );\n<line106>flags |= SQLITE_OPEN_MAIN_DB;\n<line107>rc = sqlite3BtreeOpen(pVfs, zPath, db, &pNew->pBt, 0, flags);\n<line108>db->nDb++;\n<line109>pNew->zDbSName = sqlite3DbStrDup(db, zName);\n<line110>}\n<line111>db->noSharedCache = 0;\n<line112>if( rc==SQLITE_CONSTRAINT ){\n<line113>rc = SQLITE_ERROR;\n<line114>zErrDyn = sqlite3MPrintf(db, "database is already attached");\n<line115>}else if( rc==SQLITE_OK ){\n<line116>Pager *pPager;\n<line117>pNew->pSchema = sqlite3SchemaGet(db, pNew->pBt);\n<line118>if( !pNew->pSchema ){\n<line119>rc = SQLITE_NOMEM_BKPT;\n<line120>}else if( pNew->pSchema->file_format && pNew->pSchema->enc!=ENC(db) ){\n<line121>zErrDyn = sqlite3MPrintf(db,\n<line122>"attached databases must use the same text encoding as main database");\n<line123>rc = SQLITE_ERROR;\n<line124>}\n<line125>sqlite3BtreeEnter(pNew->pBt);\n<line126>pPager = sqlite3BtreePager(pNew->pBt);\n<line127>sqlite3PagerLockingMode(pPager, db->dfltLockMode);\n<line128>sqlite3BtreeSecureDelete(pNew->pBt,\n<line129>sqlite3BtreeSecureDelete(db->aDb[0].pBt,-1) );\n<line130>#ifndef SQLITE_OMIT_PAGER_PRAGMAS\n<line131>sqlite3BtreeSetPagerFlags(pNew->pBt,\n<line132>PAGER_SYNCHRONOUS_FULL | (db->flags & PAGER_FLAGS_MASK));\n<line133>#endif\n<line134>sqlite3BtreeLeave(pNew->pBt);\n<line135>}\n<line136>pNew->safety_level = SQLITE_DEFAULT_SYNCHRONOUS+1;\n<line137>if( rc==SQLITE_OK && pNew->zDbSName==0 ){\n<line138>rc = SQLITE_NOMEM_BKPT;\n<line139>}\n<line140>sqlite3_free_filename( zPath );\n<line141>/* If the file was opened successfully, read the schema for the new database.\n<line142>** If this fails, or if opening the file failed, then close the file and\n<line143>** remove the entry from the db->aDb[] array. i.e. put everything back the\n<line144>** way we found it.\n<line145>*/\n<line146>if( rc==SQLITE_OK ){\n<line147>sqlite3BtreeEnterAll(db);\n<line148>db->init.iDb = 0;\n<line149>db->mDbFlags &= ~(DBFLAG_SchemaKnownOk);\n<line150>#ifdef SQLITE_ENABLE_SETLK_TIMEOUT\n<line151>if( db->setlkFlags & SQLITE_SETLK_BLOCK_ON_CONNECT ){\n<line152>int val = 1;\n<line153>sqlite3_file *fd = sqlite3PagerFile(sqlite3BtreePager(pNew->pBt));\n<line154>sqlite3OsFileControlHint(fd, SQLITE_FCNTL_BLOCK_ON_CONNECT, &val);\n<line155>}\n<line156>#endif\n<line157>if( !REOPEN_AS_MEMDB(db) ){\n<line158>rc = sqlite3Init(db, &zErrDyn);\n<line159>}\n<line160>sqlite3BtreeLeaveAll(db);\n<line161>assert( zErrDyn==0 || rc!=SQLITE_OK );\n<line162>}\n<line163>if( rc ){\n<line164>if( ALWAYS(!REOPEN_AS_MEMDB(db)) ){\n<line165>int iDb = db->nDb - 1;\n<line166>assert( iDb>=2 );\n<line167>if( db->aDb[iDb].pBt ){\n<line168>sqlite3BtreeClose(db->aDb[iDb].pBt);\n<line169>db->aDb[iDb].pBt = 0;\n<line170>db->aDb[iDb].pSchema = 0;\n<line171>}\n<line172>sqlite3ResetAllSchemasOfConnection(db);\n<line173>db->nDb = iDb;\n<line174>if( rc==SQLITE_NOMEM || rc==SQLITE_IOERR_NOMEM ){\n<line175>sqlite3OomFault(db);\n<line176>sqlite3DbFree(db, zErrDyn);\n<line177>zErrDyn = sqlite3MPrintf(db, "out of memory");\n<line178>}else if( zErrDyn==0 ){\n<line179>zErrDyn = sqlite3MPrintf(db, "unable to open database: %s", zFile);\n<line180>}\n<line181>}\n<line182>goto attach_error;\n<line183>}\n<line184>return;\n<line185>attach_error:\n<line186>/* Return an error if we get here */\n<line187>if( zErrDyn ){\n<line188>sqlite3_result_error(context, zErrDyn, -1);\n<line189>sqlite3DbFree(db, zErrDyn);\n<line190>}\n<line191>if( rc ) sqlite3_result_error_code(context, rc);\n<line192>}
----------------------------------------
Function: detachFunc
Content: <line0>static void detachFunc(\n<line1>sqlite3_context *context,\n<line2>int NotUsed,\n<line3>sqlite3_value **argv\n<line4>){\n<line5>const char *zName = (const char *)sqlite3_value_text(argv[0]);\n<line6>sqlite3 *db = sqlite3_context_db_handle(context);\n<line7>int i;\n<line8>Db *pDb = 0;\n<line9>HashElem *pEntry;\n<line10>char zErr[128];\n<line11>UNUSED_PARAMETER(NotUsed);\n<line12>if( zName==0 ) zName = "";\n<line13>for(i=0; i<db->nDb; i++){\n<line14>pDb = &db->aDb[i];\n<line15>if( pDb->pBt==0 ) continue;\n<line16>if( sqlite3DbIsNamed(db, i, zName) ) break;\n<line17>}\n<line18>if( i>=db->nDb ){\n<line19>sqlite3_snprintf(sizeof(zErr),zErr, "no such database: %s", zName);\n<line20>goto detach_error;\n<line21>}\n<line22>if( i<2 ){\n<line23>sqlite3_snprintf(sizeof(zErr),zErr, "cannot detach database %s", zName);\n<line24>goto detach_error;\n<line25>}\n<line26>if( sqlite3BtreeTxnState(pDb->pBt)!=SQLITE_TXN_NONE\n<line27>|| sqlite3BtreeIsInBackup(pDb->pBt)\n<line28>){\n<line29>sqlite3_snprintf(sizeof(zErr),zErr, "database %s is locked", zName);\n<line30>goto detach_error;\n<line31>}\n<line32>/* If any TEMP triggers reference the schema being detached, move those\n<line33>** triggers to reference the TEMP schema itself. */\n<line34>assert( db->aDb[1].pSchema );\n<line35>pEntry = sqliteHashFirst(&db->aDb[1].pSchema->trigHash);\n<line36>while( pEntry ){\n<line37>Trigger *pTrig = (Trigger*)sqliteHashData(pEntry);\n<line38>if( pTrig->pTabSchema==pDb->pSchema ){\n<line39>pTrig->pTabSchema = pTrig->pSchema;\n<line40>}\n<line41>pEntry = sqliteHashNext(pEntry);\n<line42>}\n<line43>sqlite3BtreeClose(pDb->pBt);\n<line44>pDb->pBt = 0;\n<line45>pDb->pSchema = 0;\n<line46>sqlite3CollapseDatabaseArray(db);\n<line47>return;\n<line48>detach_error:\n<line49>sqlite3_result_error(context, zErr, -1);\n<line50>}
----------------------------------------
Function: codeAttach
Content: <line0>static void codeAttach(\n<line1>Parse *pParse,       /* The parser context */\n<line2>int type,            /* Either SQLITE_ATTACH or SQLITE_DETACH */\n<line3>FuncDef const *pFunc,/* FuncDef wrapper for detachFunc() or attachFunc() */\n<line4>Expr *pAuthArg,      /* Expression to pass to authorization callback */\n<line5>Expr *pFilename,     /* Name of database file */\n<line6>Expr *pDbname,       /* Name of the database to use internally */\n<line7>Expr *pKey           /* Database key for encryption extension */\n<line8>){\n<line9>int rc;\n<line10>NameContext sName;\n<line11>Vdbe *v;\n<line12>sqlite3* db = pParse->db;\n<line13>int regArgs;\n<line14>if( SQLITE_OK!=sqlite3ReadSchema(pParse) ) goto attach_end;\n<line15>if( pParse->nErr ) goto attach_end;\n<line16>memset(&sName, 0, sizeof(NameContext));\n<line17>sName.pParse = pParse;\n<line18>if(\n<line19>SQLITE_OK!=resolveAttachExpr(&sName, pFilename) ||\n<line20>SQLITE_OK!=resolveAttachExpr(&sName, pDbname) ||\n<line21>SQLITE_OK!=resolveAttachExpr(&sName, pKey)\n<line22>){\n<line23>goto attach_end;\n<line24>}\n<line25>#ifndef SQLITE_OMIT_AUTHORIZATION\n<line26>if( ALWAYS(pAuthArg) ){\n<line27>char *zAuthArg;\n<line28>if( pAuthArg->op==TK_STRING ){\n<line29>assert( !ExprHasProperty(pAuthArg, EP_IntValue) );\n<line30>zAuthArg = pAuthArg->u.zToken;\n<line31>}else{\n<line32>zAuthArg = 0;\n<line33>}\n<line34>rc = sqlite3AuthCheck(pParse, type, zAuthArg, 0, 0);\n<line35>if(rc!=SQLITE_OK ){\n<line36>goto attach_end;\n<line37>}\n<line38>}\n<line39>#endif /* SQLITE_OMIT_AUTHORIZATION */\n<line40>v = sqlite3GetVdbe(pParse);\n<line41>regArgs = sqlite3GetTempRange(pParse, 4);\n<line42>sqlite3ExprCode(pParse, pFilename, regArgs);\n<line43>sqlite3ExprCode(pParse, pDbname, regArgs+1);\n<line44>sqlite3ExprCode(pParse, pKey, regArgs+2);\n<line45>assert( v || db->mallocFailed );\n<line46>if( v ){\n<line47>sqlite3VdbeAddFunctionCall(pParse, 0, regArgs+3-pFunc->nArg, regArgs+3,\n<line48>pFunc->nArg, pFunc, 0);\n<line49>/* Code an OP_Expire. For an ATTACH statement, set P1 to true (expire this\n<line50>** statement only). For DETACH, set it to false (expire all existing\n<line51>** statements).\n<line52>*/\n<line53>sqlite3VdbeAddOp1(v, OP_Expire, (type==SQLITE_ATTACH));\n<line54>}\n<line55>attach_end:\n<line56>sqlite3ExprDelete(db, pFilename);\n<line57>sqlite3ExprDelete(db, pDbname);\n<line58>sqlite3ExprDelete(db, pKey);\n<line59>}
----------------------------------------
Function: fixExprCb
Content: <line0>static int fixExprCb(Walker *p, Expr *pExpr){\n<line1>DbFixer *pFix = p->u.pFix;\n<line2>if( !pFix->bTemp ) ExprSetProperty(pExpr, EP_FromDDL);\n<line3>if( pExpr->op==TK_VARIABLE ){\n<line4>if( pFix->pParse->db->init.busy ){\n<line5>pExpr->op = TK_NULL;\n<line6>}else{\n<line7>sqlite3ErrorMsg(pFix->pParse, "%s cannot use variables", pFix->zType);\n<line8>return WRC_Abort;\n<line9>}\n<line10>}\n<line11>return WRC_Continue;\n<line12>}
----------------------------------------
Function: fixSelectCb
Content: <line0>static int fixSelectCb(Walker *p, Select *pSelect){\n<line1>DbFixer *pFix = p->u.pFix;\n<line2>int i;\n<line3>SrcItem *pItem;\n<line4>sqlite3 *db = pFix->pParse->db;\n<line5>int iDb = sqlite3FindDbName(db, pFix->zDb);\n<line6>SrcList *pList = pSelect->pSrc;\n<line7>if( NEVER(pList==0) ) return WRC_Continue;\n<line8>for(i=0, pItem=pList->a; i<pList->nSrc; i++, pItem++){\n<line9>if( pFix->bTemp==0 && pItem->fg.isSubquery==0 ){\n<line10>if( pItem->fg.fixedSchema==0 && pItem->u4.zDatabase!=0 ){\n<line11>if( iDb!=sqlite3FindDbName(db, pItem->u4.zDatabase) ){\n<line12>sqlite3ErrorMsg(pFix->pParse,\n<line13>"%s %T cannot reference objects in database %s",\n<line14>pFix->zType, pFix->pName, pItem->u4.zDatabase);\n<line15>return WRC_Abort;\n<line16>}\n<line17>sqlite3DbFree(db, pItem->u4.zDatabase);\n<line18>pItem->fg.notCte = 1;\n<line19>pItem->fg.hadSchema = 1;\n<line20>}\n<line21>pItem->u4.pSchema = pFix->pSchema;\n<line22>pItem->fg.fromDDL = 1;\n<line23>pItem->fg.fixedSchema = 1;\n<line24>}\n<line25>#if !defined(SQLITE_OMIT_VIEW) || !defined(SQLITE_OMIT_TRIGGER)\n<line26>if( pList->a[i].fg.isUsing==0\n<line27>&& sqlite3WalkExpr(&pFix->w, pList->a[i].u3.pOn)\n<line28>){\n<line29>return WRC_Abort;\n<line30>}\n<line31>#endif\n<line32>}\n<line33>if( pSelect->pWith ){\n<line34>for(i=0; i<pSelect->pWith->nCte; i++){\n<line35>if( sqlite3WalkSelect(p, pSelect->pWith->a[i].pSelect) ){\n<line36>return WRC_Abort;\n<line37>}\n<line38>}\n<line39>}\n<line40>return WRC_Continue;\n<line41>}
----------------------------------------
Function: sqlite3_set_authorizer
Content: <line0>SQLITE_API int sqlite3_set_authorizer(\n<line1>sqlite3 *db,\n<line2>int (*xAuth)(void*,int,const char*,const char*,const char*,const char*),\n<line3>void *pArg\n<line4>){\n<line5>#ifdef SQLITE_ENABLE_API_ARMOR\n<line6>if( !sqlite3SafetyCheckOk(db) ) return SQLITE_MISUSE_BKPT;\n<line7>#endif\n<line8>sqlite3_mutex_enter(db->mutex);\n<line9>db->xAuth = (sqlite3_xauth)xAuth;\n<line10>db->pAuthArg = pArg;\n<line11>if( db->xAuth ) sqlite3ExpirePreparedStatements(db, 1);\n<line12>sqlite3_mutex_leave(db->mutex);\n<line13>return SQLITE_OK;\n<line14>}
----------------------------------------
Function: sqliteAuthBadReturnCode
Content: <line0>static void sqliteAuthBadReturnCode(Parse *pParse){\n<line1>sqlite3ErrorMsg(pParse, "authorizer malfunction");\n<line2>pParse->rc = SQLITE_ERROR;\n<line3>}
----------------------------------------
Function: lockTable
Content: <line0>static SQLITE_NOINLINE void lockTable(\n<line1>Parse *pParse,     /* Parsing context */\n<line2>int iDb,           /* Index of the database containing the table to lock */\n<line3>Pgno iTab,         /* Root page number of the table to be locked */\n<line4>u8 isWriteLock,    /* True for a write lock */\n<line5>const char *zName  /* Name of the table to be locked */\n<line6>){\n<line7>Parse *pToplevel;\n<line8>int i;\n<line9>int nBytes;\n<line10>TableLock *p;\n<line11>assert( iDb>=0 );\n<line12>pToplevel = sqlite3ParseToplevel(pParse);\n<line13>for(i=0; i<pToplevel->nTableLock; i++){\n<line14>p = &pToplevel->aTableLock[i];\n<line15>if( p->iDb==iDb && p->iTab==iTab ){\n<line16>p->isWriteLock = (p->isWriteLock || isWriteLock);\n<line17>return;\n<line18>}\n<line19>}\n<line20>assert( pToplevel->nTableLock < 0x7fff0000 );\n<line21>nBytes = sizeof(TableLock) * (pToplevel->nTableLock+1);\n<line22>pToplevel->aTableLock =\n<line23>sqlite3DbReallocOrFree(pToplevel->db, pToplevel->aTableLock, nBytes);\n<line24>if( pToplevel->aTableLock ){\n<line25>p = &pToplevel->aTableLock[pToplevel->nTableLock++];\n<line26>p->iDb = iDb;\n<line27>p->iTab = iTab;\n<line28>p->isWriteLock = isWriteLock;\n<line29>p->zLockName = zName;\n<line30>}else{\n<line31>pToplevel->nTableLock = 0;\n<line32>sqlite3OomFault(pToplevel->db);\n<line33>}\n<line34>}
----------------------------------------
Function: codeTableLocks
Content: <line0>static void codeTableLocks(Parse *pParse){\n<line1>int i;\n<line2>Vdbe *pVdbe = pParse->pVdbe;\n<line3>assert( pVdbe!=0 );\n<line4>for(i=0; i<pParse->nTableLock; i++){\n<line5>TableLock *p = &pParse->aTableLock[i];\n<line6>int p1 = p->iDb;\n<line7>sqlite3VdbeAddOp4(pVdbe, OP_TableLock, p1, p->iTab, p->isWriteLock,\n<line8>p->zLockName, P4_STATIC);\n<line9>}\n<line10>}
----------------------------------------
Function: deleteTable
Content: <line0>static void SQLITE_NOINLINE deleteTable(sqlite3 *db, Table *pTable){\n<line1>Index *pIndex, *pNext;\n<line2>#ifdef SQLITE_DEBUG\n<line3>/* Record the number of outstanding lookaside allocations in schema Tables\n<line4>** prior to doing any free() operations. Since schema Tables do not use\n<line5>** lookaside, this number should not change.\n<line6>**\n<line7>** If malloc has already failed, it may be that it failed while allocating\n<line8>** a Table object that was going to be marked ephemeral. So do not check\n<line9>** that no lookaside memory is used in this case either. */\n<line10>int nLookaside = 0;\n<line11>assert( db!=0 );\n<line12>if( !db->mallocFailed && (pTable->tabFlags & TF_Ephemeral)==0 ){\n<line13>nLookaside = sqlite3LookasideUsed(db, 0);\n<line14>}\n<line15>#endif\n<line16>/* Delete all indices associated with this table. */\n<line17>for(pIndex = pTable->pIndex; pIndex; pIndex=pNext){\n<line18>pNext = pIndex->pNext;\n<line19>assert( pIndex->pSchema==pTable->pSchema\n<line20>|| (IsVirtual(pTable) && pIndex->idxType!=SQLITE_IDXTYPE_APPDEF) );\n<line21>if( db->pnBytesFreed==0 && !IsVirtual(pTable) ){\n<line22>char *zName = pIndex->zName;\n<line23>TESTONLY ( Index *pOld = ) sqlite3HashInsert(\n<line24>&pIndex->pSchema->idxHash, zName, 0\n<line25>);\n<line26>assert( db==0 || sqlite3SchemaMutexHeld(db, 0, pIndex->pSchema) );\n<line27>assert( pOld==pIndex || pOld==0 );\n<line28>}\n<line29>sqlite3FreeIndex(db, pIndex);\n<line30>}\n<line31>if( IsOrdinaryTable(pTable) ){\n<line32>sqlite3FkDelete(db, pTable);\n<line33>}\n<line34>#ifndef SQLITE_OMIT_VIRTUALTABLE\n<line35>else if( IsVirtual(pTable) ){\n<line36>sqlite3VtabClear(db, pTable);\n<line37>}\n<line38>#endif\n<line39>else{\n<line40>assert( IsView(pTable) );\n<line41>sqlite3SelectDelete(db, pTable->u.view.pSelect);\n<line42>}\n<line43>/* Delete the Table structure itself.\n<line44>*/\n<line45>sqlite3DeleteColumnNames(db, pTable);\n<line46>sqlite3DbFree(db, pTable->zName);\n<line47>sqlite3DbFree(db, pTable->zColAff);\n<line48>sqlite3ExprListDelete(db, pTable->pCheck);\n<line49>sqlite3DbFree(db, pTable);\n<line50>/* Verify that no lookaside memory was used by schema tables */\n<line51>assert( nLookaside==0 || nLookaside==sqlite3LookasideUsed(db,0) );\n<line52>}
----------------------------------------
Function: sqlite3ForceNotReadOnly
Content: <line0>static void sqlite3ForceNotReadOnly(Parse *pParse){\n<line1>int iReg = ++pParse->nMem;\n<line2>Vdbe *v = sqlite3GetVdbe(pParse);\n<line3>if( v ){\n<line4>sqlite3VdbeAddOp3(v, OP_JournalMode, 0, iReg, PAGER_JOURNALMODE_QUERY);\n<line5>sqlite3VdbeUsesBtree(v, 0);\n<line6>}\n<line7>}
----------------------------------------
Function: sqlite3DeleteReturning
Content: <line0>static void sqlite3DeleteReturning(sqlite3 *db, void *pArg){\n<line1>Returning *pRet = (Returning*)pArg;\n<line2>Hash *pHash;\n<line3>pHash = &(db->aDb[1].pSchema->trigHash);\n<line4>sqlite3HashInsert(pHash, pRet->zName, 0);\n<line5>sqlite3ExprListDelete(db, pRet->pReturnEL);\n<line6>sqlite3DbFree(db, pRet);\n<line7>}
----------------------------------------
Function: sqlite3StringToId
Content: <line0>static void sqlite3StringToId(Expr *p){\n<line1>if( p->op==TK_STRING ){\n<line2>p->op = TK_ID;\n<line3>}else if( p->op==TK_COLLATE && p->pLeft->op==TK_STRING ){\n<line4>p->pLeft->op = TK_ID;\n<line5>}\n<line6>}
----------------------------------------
Function: makeColumnPartOfPrimaryKey
Content: <line0>static void makeColumnPartOfPrimaryKey(Parse *pParse, Column *pCol){\n<line1>pCol->colFlags |= COLFLAG_PRIMKEY;\n<line2>#ifndef SQLITE_OMIT_GENERATED_COLUMNS\n<line3>if( pCol->colFlags & COLFLAG_GENERATED ){\n<line4>testcase( pCol->colFlags & COLFLAG_VIRTUAL );\n<line5>testcase( pCol->colFlags & COLFLAG_STORED );\n<line6>sqlite3ErrorMsg(pParse,\n<line7>"generated columns cannot be part of the PRIMARY KEY");\n<line8>}\n<line9>#endif\n<line10>}
----------------------------------------
Function: identLength
Content: <line0>static int identLength(const char *z){\n<line1>int n;\n<line2>for(n=0; *z; n++, z++){\n<line3>if( *z=='"' ){ n++; }\n<line4>}\n<line5>return n + 2;\n<line6>}
----------------------------------------
Function: identPut
Content: <line0>static void identPut(char *z, int *pIdx, char *zSignedIdent){\n<line1>unsigned char *zIdent = (unsigned char*)zSignedIdent;\n<line2>int i, j, needQuote;\n<line3>i = *pIdx;\n<line4>for(j=0; zIdent[j]; j++){\n<line5>if( !sqlite3Isalnum(zIdent[j]) && zIdent[j]!='_' ) break;\n<line6>}\n<line7>needQuote = sqlite3Isdigit(zIdent[0])\n<line8>|| sqlite3KeywordCode(zIdent, j)!=TK_ID\n<line9>|| zIdent[j]!=0\n<line10>|| j==0;\n<line11>if( needQuote ) z[i++] = '"';\n<line12>for(j=0; zIdent[j]; j++){\n<line13>z[i++] = zIdent[j];\n<line14>if( zIdent[j]=='"' ) z[i++] = '"';\n<line15>}\n<line16>if( needQuote ) z[i++] = '"';\n<line17>z[i] = 0;\n<line18>*pIdx = i;\n<line19>}
----------------------------------------
Function: createTableStmt
Content: <line0>static char *createTableStmt(sqlite3 *db, Table *p){\n<line1>int i, k, len;\n<line2>i64 n;\n<line3>char *zStmt;\n<line4>char *zSep, *zSep2, *zEnd;\n<line5>Column *pCol;\n<line6>n = 0;\n<line7>for(pCol = p->aCol, i=0; i<p->nCol; i++, pCol++){\n<line8>n += identLength(pCol->zCnName) + 5;\n<line9>}\n<line10>n += identLength(p->zName);\n<line11>if( n<50 ){\n<line12>zSep = "";\n<line13>zSep2 = ",";\n<line14>zEnd = ")";\n<line15>}else{\n<line16>zSep = "\n  ";\n<line17>zSep2 = ",\n  ";\n<line18>zEnd = "\n)";\n<line19>}\n<line20>n += 35 + 6*p->nCol;\n<line21>zStmt = sqlite3DbMallocRaw(0, n);\n<line22>if( zStmt==0 ){\n<line23>sqlite3OomFault(db);\n<line24>return 0;\n<line25>}\n<line26>assert( n>14 && n<=0x7fffffff );\n<line27>memcpy(zStmt, "CREATE TABLE ", 13);\n<line28>k = 13;\n<line29>identPut(zStmt, &k, p->zName);\n<line30>zStmt[k++] = '(';\n<line31>for(pCol=p->aCol, i=0; i<p->nCol; i++, pCol++){\n<line32>static const char * const azType[] = {\n<line33>/* SQLITE_AFF_BLOB    */ "",\n<line34>/* SQLITE_AFF_TEXT    */ " TEXT",\n<line35>/* SQLITE_AFF_NUMERIC */ " NUM",\n<line36>/* SQLITE_AFF_INTEGER */ " INT",\n<line37>/* SQLITE_AFF_REAL    */ " REAL",\n<line38>/* SQLITE_AFF_FLEXNUM */ " NUM",\n<line39>};\n<line40>const char *zType;\n<line41>len = sqlite3Strlen30(zSep);\n<line42>assert( k+len<n );\n<line43>memcpy(&zStmt[k], zSep, len);\n<line44>k += len;\n<line45>zSep = zSep2;\n<line46>identPut(zStmt, &k, pCol->zCnName);\n<line47>assert( k<n );\n<line48>assert( pCol->affinity-SQLITE_AFF_BLOB >= 0 );\n<line49>assert( pCol->affinity-SQLITE_AFF_BLOB < ArraySize(azType) );\n<line50>testcase( pCol->affinity==SQLITE_AFF_BLOB );\n<line51>testcase( pCol->affinity==SQLITE_AFF_TEXT );\n<line52>testcase( pCol->affinity==SQLITE_AFF_NUMERIC );\n<line53>testcase( pCol->affinity==SQLITE_AFF_INTEGER );\n<line54>testcase( pCol->affinity==SQLITE_AFF_REAL );\n<line55>testcase( pCol->affinity==SQLITE_AFF_FLEXNUM );\n<line56>zType = azType[pCol->affinity - SQLITE_AFF_BLOB];\n<line57>len = sqlite3Strlen30(zType);\n<line58>assert( pCol->affinity==SQLITE_AFF_BLOB\n<line59>|| pCol->affinity==SQLITE_AFF_FLEXNUM\n<line60>|| pCol->affinity==sqlite3AffinityType(zType, 0) );\n<line61>assert( k+len<n );\n<line62>memcpy(&zStmt[k], zType, len);\n<line63>k += len;\n<line64>assert( k<=n );\n<line65>}\n<line66>len = sqlite3Strlen30(zEnd);\n<line67>assert( k+len<n );\n<line68>memcpy(&zStmt[k], zEnd, len+1);\n<line69>return zStmt;\n<line70>}
----------------------------------------
Function: resizeIndexObject
Content: <line0>static int resizeIndexObject(Parse *pParse, Index *pIdx, int N){\n<line1>char *zExtra;\n<line2>u64 nByte;\n<line3>sqlite3 *db;\n<line4>if( pIdx->nColumn>=N ) return SQLITE_OK;\n<line5>db = pParse->db;\n<line6>assert( N>0 );\n<line7>assert( N <= SQLITE_MAX_COLUMN*2 /* tag-20250221-1 */ );\n<line8>testcase( N==2*pParse->db->aLimit[SQLITE_LIMIT_COLUMN] );\n<line9>assert( pIdx->isResized==0 );\n<line10>nByte = (sizeof(char*) + sizeof(LogEst) + sizeof(i16) + 1)*(u64)N;\n<line11>zExtra = sqlite3DbMallocZero(db, nByte);\n<line12>if( zExtra==0 ) return SQLITE_NOMEM_BKPT;\n<line13>memcpy(zExtra, pIdx->azColl, sizeof(char*)*pIdx->nColumn);\n<line14>pIdx->azColl = (const char**)zExtra;\n<line15>zExtra += sizeof(char*)*N;\n<line16>memcpy(zExtra, pIdx->aiRowLogEst, sizeof(LogEst)*(pIdx->nKeyCol+1));\n<line17>pIdx->aiRowLogEst = (LogEst*)zExtra;\n<line18>zExtra += sizeof(LogEst)*N;\n<line19>memcpy(zExtra, pIdx->aiColumn, sizeof(i16)*pIdx->nColumn);\n<line20>pIdx->aiColumn = (i16*)zExtra;\n<line21>zExtra += sizeof(i16)*N;\n<line22>memcpy(zExtra, pIdx->aSortOrder, pIdx->nColumn);\n<line23>pIdx->aSortOrder = (u8*)zExtra;\n<line24>pIdx->nColumn = (u16)N;  /* See tag-20250221-1 above for proof of safety */\n<line25>pIdx->isResized = 1;\n<line26>return SQLITE_OK;\n<line27>}
----------------------------------------
Function: estimateTableWidth
Content: <line0>static void estimateTableWidth(Table *pTab){\n<line1>unsigned wTable = 0;\n<line2>const Column *pTabCol;\n<line3>int i;\n<line4>for(i=pTab->nCol, pTabCol=pTab->aCol; i>0; i--, pTabCol++){\n<line5>wTable += pTabCol->szEst;\n<line6>}\n<line7>if( pTab->iPKey<0 ) wTable++;\n<line8>pTab->szTabRow = sqlite3LogEst(wTable*4);\n<line9>}
----------------------------------------
Function: estimateIndexWidth
Content: <line0>static void estimateIndexWidth(Index *pIdx){\n<line1>unsigned wIndex = 0;\n<line2>int i;\n<line3>const Column *aCol = pIdx->pTable->aCol;\n<line4>for(i=0; i<pIdx->nColumn; i++){\n<line5>i16 x = pIdx->aiColumn[i];\n<line6>assert( x<pIdx->pTable->nCol );\n<line7>wIndex += x<0 ? 1 : aCol[x].szEst;\n<line8>}\n<line9>pIdx->szIdxRow = sqlite3LogEst(wIndex*4);\n<line10>}
----------------------------------------
Function: hasColumn
Content: <line0>static int hasColumn(const i16 *aiCol, int nCol, int x){\n<line1>while( nCol-- > 0 ){\n<line2>if( x==*(aiCol++) ){\n<line3>return 1;\n<line4>}\n<line5>}\n<line6>return 0;\n<line7>}
----------------------------------------
Function: isDupColumn
Content: <line0>static int isDupColumn(Index *pIdx, int nKey, Index *pPk, int iCol){\n<line1>int i, j;\n<line2>assert( nKey<=pIdx->nColumn );\n<line3>assert( iCol<MAX(pPk->nColumn,pPk->nKeyCol) );\n<line4>assert( pPk->idxType==SQLITE_IDXTYPE_PRIMARYKEY );\n<line5>assert( pPk->pTable->tabFlags & TF_WithoutRowid );\n<line6>assert( pPk->pTable==pIdx->pTable );\n<line7>testcase( pPk==pIdx );\n<line8>j = pPk->aiColumn[iCol];\n<line9>assert( j!=XN_ROWID && j!=XN_EXPR );\n<line10>for(i=0; i<nKey; i++){\n<line11>assert( pIdx->aiColumn[i]>=0 || j>=0 );\n<line12>if( pIdx->aiColumn[i]==j\n<line13>&& sqlite3StrICmp(pIdx->azColl[i], pPk->azColl[iCol])==0\n<line14>){\n<line15>return 1;\n<line16>}\n<line17>}\n<line18>return 0;\n<line19>}
----------------------------------------
Function: recomputeColumnsNotIndexed
Content: <line0>static void recomputeColumnsNotIndexed(Index *pIdx){\n<line1>Bitmask m = 0;\n<line2>int j;\n<line3>Table *pTab = pIdx->pTable;\n<line4>for(j=pIdx->nColumn-1; j>=0; j--){\n<line5>int x = pIdx->aiColumn[j];\n<line6>if( x>=0 && (pTab->aCol[x].colFlags & COLFLAG_VIRTUAL)==0 ){\n<line7>testcase( x==BMS-1 );\n<line8>testcase( x==BMS-2 );\n<line9>if( x<BMS-1 ) m |= MASKBIT(x);\n<line10>}\n<line11>}\n<line12>pIdx->colNotIdxed = ~m;\n<line13>assert( (pIdx->colNotIdxed>>63)==1 );  /* See note-20221022-a */\n<line14>}
----------------------------------------
Function: convertToWithoutRowidTable
Content: <line0>static void convertToWithoutRowidTable(Parse *pParse, Table *pTab){\n<line1>Index *pIdx;\n<line2>Index *pPk;\n<line3>int nPk;\n<line4>int nExtra;\n<line5>int i, j;\n<line6>sqlite3 *db = pParse->db;\n<line7>Vdbe *v = pParse->pVdbe;\n<line8>/* Mark every PRIMARY KEY column as NOT NULL (except for imposter tables)\n<line9>*/\n<line10>if( !db->init.imposterTable ){\n<line11>for(i=0; i<pTab->nCol; i++){\n<line12>if( (pTab->aCol[i].colFlags & COLFLAG_PRIMKEY)!=0\n<line13>&& (pTab->aCol[i].notNull==OE_None)\n<line14>){\n<line15>pTab->aCol[i].notNull = OE_Abort;\n<line16>}\n<line17>}\n<line18>pTab->tabFlags |= TF_HasNotNull;\n<line19>}\n<line20>/* Convert the P3 operand of the OP_CreateBtree opcode from BTREE_INTKEY\n<line21>** into BTREE_BLOBKEY.\n<line22>*/\n<line23>assert( !pParse->bReturning );\n<line24>if( pParse->u1.cr.addrCrTab ){\n<line25>assert( v );\n<line26>sqlite3VdbeChangeP3(v, pParse->u1.cr.addrCrTab, BTREE_BLOBKEY);\n<line27>}\n<line28>/* Locate the PRIMARY KEY index.  Or, if this table was originally\n<line29>** an INTEGER PRIMARY KEY table, create a new PRIMARY KEY index.\n<line30>*/\n<line31>if( pTab->iPKey>=0 ){\n<line32>ExprList *pList;\n<line33>Token ipkToken;\n<line34>sqlite3TokenInit(&ipkToken, pTab->aCol[pTab->iPKey].zCnName);\n<line35>pList = sqlite3ExprListAppend(pParse, 0,\n<line36>sqlite3ExprAlloc(db, TK_ID, &ipkToken, 0));\n<line37>if( pList==0 ){\n<line38>pTab->tabFlags &= ~TF_WithoutRowid;\n<line39>return;\n<line40>}\n<line41>if( IN_RENAME_OBJECT ){\n<line42>sqlite3RenameTokenRemap(pParse, pList->a[0].pExpr, &pTab->iPKey);\n<line43>}\n<line44>pList->a[0].fg.sortFlags = pParse->iPkSortOrder;\n<line45>assert( pParse->pNewTable==pTab );\n<line46>pTab->iPKey = -1;\n<line47>sqlite3CreateIndex(pParse, 0, 0, 0, pList, pTab->keyConf, 0, 0, 0, 0,\n<line48>SQLITE_IDXTYPE_PRIMARYKEY);\n<line49>if( pParse->nErr ){\n<line50>pTab->tabFlags &= ~TF_WithoutRowid;\n<line51>return;\n<line52>}\n<line53>assert( db->mallocFailed==0 );\n<line54>pPk = sqlite3PrimaryKeyIndex(pTab);\n<line55>assert( pPk->nKeyCol==1 );\n<line56>}else{\n<line57>pPk = sqlite3PrimaryKeyIndex(pTab);\n<line58>assert( pPk!=0 );\n<line59>/*\n<line60>** Remove all redundant columns from the PRIMARY KEY.  For example, change\n<line61>** "PRIMARY KEY(a,b,a,b,c,b,c,d)" into just "PRIMARY KEY(a,b,c,d)".  Later\n<line62>** code assumes the PRIMARY KEY contains no repeated columns.\n<line63>*/\n<line64>for(i=j=1; i<pPk->nKeyCol; i++){\n<line65>if( isDupColumn(pPk, j, pPk, i) ){\n<line66>pPk->nColumn--;\n<line67>}else{\n<line68>testcase( hasColumn(pPk->aiColumn, j, pPk->aiColumn[i]) );\n<line69>pPk->azColl[j] = pPk->azColl[i];\n<line70>pPk->aSortOrder[j] = pPk->aSortOrder[i];\n<line71>pPk->aiColumn[j++] = pPk->aiColumn[i];\n<line72>}\n<line73>}\n<line74>pPk->nKeyCol = j;\n<line75>}\n<line76>assert( pPk!=0 );\n<line77>pPk->isCovering = 1;\n<line78>if( !db->init.imposterTable ) pPk->uniqNotNull = 1;\n<line79>nPk = pPk->nColumn = pPk->nKeyCol;\n<line80>/* Bypass the creation of the PRIMARY KEY btree and the sqlite_schema\n<line81>** table entry. This is only required if currently generating VDBE\n<line82>** code for a CREATE TABLE (not when parsing one as part of reading\n<line83>** a database schema).  */\n<line84>if( v && pPk->tnum>0 ){\n<line85>assert( db->init.busy==0 );\n<line86>sqlite3VdbeChangeOpcode(v, (int)pPk->tnum, OP_Goto);\n<line87>}\n<line88>/* The root page of the PRIMARY KEY is the table root page */\n<line89>pPk->tnum = pTab->tnum;\n<line90>/* Update the in-memory representation of all UNIQUE indices by converting\n<line91>** the final rowid column into one or more columns of the PRIMARY KEY.\n<line92>*/\n<line93>for(pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext){\n<line94>int n;\n<line95>if( IsPrimaryKeyIndex(pIdx) ) continue;\n<line96>for(i=n=0; i<nPk; i++){\n<line97>if( !isDupColumn(pIdx, pIdx->nKeyCol, pPk, i) ){\n<line98>testcase( hasColumn(pIdx->aiColumn, pIdx->nKeyCol, pPk->aiColumn[i]) );\n<line99>n++;\n<line100>}\n<line101>}\n<line102>if( n==0 ){\n<line103>/* This index is a superset of the primary key */\n<line104>pIdx->nColumn = pIdx->nKeyCol;\n<line105>continue;\n<line106>}\n<line107>if( resizeIndexObject(pParse, pIdx, pIdx->nKeyCol+n) ) return;\n<line108>for(i=0, j=pIdx->nKeyCol; i<nPk; i++){\n<line109>if( !isDupColumn(pIdx, pIdx->nKeyCol, pPk, i) ){\n<line110>testcase( hasColumn(pIdx->aiColumn, pIdx->nKeyCol, pPk->aiColumn[i]) );\n<line111>pIdx->aiColumn[j] = pPk->aiColumn[i];\n<line112>pIdx->azColl[j] = pPk->azColl[i];\n<line113>if( pPk->aSortOrder[i] ){\n<line114>/* See ticket https://sqlite.org/src/info/bba7b69f9849b5bf */\n<line115>pIdx->bAscKeyBug = 1;\n<line116>}\n<line117>j++;\n<line118>}\n<line119>}\n<line120>assert( pIdx->nColumn>=pIdx->nKeyCol+n );\n<line121>assert( pIdx->nColumn>=j );\n<line122>}\n<line123>/* Add all table columns to the PRIMARY KEY index\n<line124>*/\n<line125>nExtra = 0;\n<line126>for(i=0; i<pTab->nCol; i++){\n<line127>if( !hasColumn(pPk->aiColumn, nPk, i)\n<line128>&& (pTab->aCol[i].colFlags & COLFLAG_VIRTUAL)==0 ) nExtra++;\n<line129>}\n<line130>if( resizeIndexObject(pParse, pPk, nPk+nExtra) ) return;\n<line131>for(i=0, j=nPk; i<pTab->nCol; i++){\n<line132>if( !hasColumn(pPk->aiColumn, j, i)\n<line133>&& (pTab->aCol[i].colFlags & COLFLAG_VIRTUAL)==0\n<line134>){\n<line135>assert( j<pPk->nColumn );\n<line136>pPk->aiColumn[j] = i;\n<line137>pPk->azColl[j] = sqlite3StrBINARY;\n<line138>j++;\n<line139>}\n<line140>}\n<line141>assert( pPk->nColumn==j );\n<line142>assert( pTab->nNVCol<=j );\n<line143>recomputeColumnsNotIndexed(pPk);\n<line144>}
----------------------------------------
Function: viewGetColumnNames
Content: <line0>static SQLITE_NOINLINE int viewGetColumnNames(Parse *pParse, Table *pTable){\n<line1>Table *pSelTab;   /* A fake table from which we get the result set */\n<line2>Select *pSel;     /* Copy of the SELECT that implements the view */\n<line3>int nErr = 0;     /* Number of errors encountered */\n<line4>sqlite3 *db = pParse->db;  /* Database connection for malloc errors */\n<line5>#ifndef SQLITE_OMIT_VIRTUALTABLE\n<line6>int rc;\n<line7>#endif\n<line8>#ifndef SQLITE_OMIT_AUTHORIZATION\n<line9>sqlite3_xauth xAuth;       /* Saved xAuth pointer */\n<line10>#endif\n<line11>assert( pTable );\n<line12>#ifndef SQLITE_OMIT_VIRTUALTABLE\n<line13>if( IsVirtual(pTable) ){\n<line14>db->nSchemaLock++;\n<line15>rc = sqlite3VtabCallConnect(pParse, pTable);\n<line16>db->nSchemaLock--;\n<line17>return rc;\n<line18>}\n<line19>#endif\n<line20>#ifndef SQLITE_OMIT_VIEW\n<line21>/* A positive nCol means the columns names for this view are\n<line22>** already known.  This routine is not called unless either the\n<line23>** table is virtual or nCol is zero.\n<line24>*/\n<line25>assert( pTable->nCol<=0 );\n<line26>/* A negative nCol is a special marker meaning that we are currently\n<line27>** trying to compute the column names.  If we enter this routine with\n<line28>** a negative nCol, it means two or more views form a loop, like this:\n<line29>**\n<line30>**     CREATE VIEW one AS SELECT * FROM two;\n<line31>**     CREATE VIEW two AS SELECT * FROM one;\n<line32>**\n<line33>** Actually, the error above is now caught prior to reaching this point.\n<line34>** But the following test is still important as it does come up\n<line35>** in the following:\n<line36>**\n<line37>**     CREATE TABLE main.ex1(a);\n<line38>**     CREATE TEMP VIEW ex1 AS SELECT a FROM ex1;\n<line39>**     SELECT * FROM temp.ex1;\n<line40>*/\n<line41>if( pTable->nCol<0 ){\n<line42>sqlite3ErrorMsg(pParse, "view %s is circularly defined", pTable->zName);\n<line43>return 1;\n<line44>}\n<line45>assert( pTable->nCol>=0 );\n<line46>/* If we get this far, it means we need to compute the table names.\n<line47>** Note that the call to sqlite3ResultSetOfSelect() will expand any\n<line48>** "*" elements in the results set of the view and will assign cursors\n<line49>** to the elements of the FROM clause.  But we do not want these changes\n<line50>** to be permanent.  So the computation is done on a copy of the SELECT\n<line51>** statement that defines the view.\n<line52>*/\n<line53>assert( IsView(pTable) );\n<line54>pSel = sqlite3SelectDup(db, pTable->u.view.pSelect, 0);\n<line55>if( pSel ){\n<line56>u8 eParseMode = pParse->eParseMode;\n<line57>int nTab = pParse->nTab;\n<line58>int nSelect = pParse->nSelect;\n<line59>pParse->eParseMode = PARSE_MODE_NORMAL;\n<line60>sqlite3SrcListAssignCursors(pParse, pSel->pSrc);\n<line61>pTable->nCol = -1;\n<line62>DisableLookaside;\n<line63>#ifndef SQLITE_OMIT_AUTHORIZATION\n<line64>xAuth = db->xAuth;\n<line65>db->xAuth = 0;\n<line66>pSelTab = sqlite3ResultSetOfSelect(pParse, pSel, SQLITE_AFF_NONE);\n<line67>db->xAuth = xAuth;\n<line68>#else\n<line69>pSelTab = sqlite3ResultSetOfSelect(pParse, pSel, SQLITE_AFF_NONE);\n<line70>#endif\n<line71>pParse->nTab = nTab;\n<line72>pParse->nSelect = nSelect;\n<line73>if( pSelTab==0 ){\n<line74>pTable->nCol = 0;\n<line75>nErr++;\n<line76>}else if( pTable->pCheck ){\n<line77>/* CREATE VIEW name(arglist) AS ...\n<line78>** The names of the columns in the table are taken from\n<line79>** arglist which is stored in pTable->pCheck.  The pCheck field\n<line80>** normally holds CHECK constraints on an ordinary table, but for\n<line81>** a VIEW it holds the list of column names.\n<line82>*/\n<line83>sqlite3ColumnsFromExprList(pParse, pTable->pCheck,\n<line84>&pTable->nCol, &pTable->aCol);\n<line85>if( pParse->nErr==0\n<line86>&& pTable->nCol==pSel->pEList->nExpr\n<line87>){\n<line88>assert( db->mallocFailed==0 );\n<line89>sqlite3SubqueryColumnTypes(pParse, pTable, pSel, SQLITE_AFF_NONE);\n<line90>}\n<line91>}else{\n<line92>/* CREATE VIEW name AS...  without an argument list.  Construct\n<line93>** the column names from the SELECT statement that defines the view.\n<line94>*/\n<line95>assert( pTable->aCol==0 );\n<line96>pTable->nCol = pSelTab->nCol;\n<line97>pTable->aCol = pSelTab->aCol;\n<line98>pTable->tabFlags |= (pSelTab->tabFlags & COLFLAG_NOINSERT);\n<line99>pSelTab->nCol = 0;\n<line100>pSelTab->aCol = 0;\n<line101>assert( sqlite3SchemaMutexHeld(db, 0, pTable->pSchema) );\n<line102>}\n<line103>pTable->nNVCol = pTable->nCol;\n<line104>sqlite3DeleteTable(db, pSelTab);\n<line105>sqlite3SelectDelete(db, pSel);\n<line106>EnableLookaside;\n<line107>pParse->eParseMode = eParseMode;\n<line108>} else {\n<line109>nErr++;\n<line110>}\n<line111>pTable->pSchema->schemaFlags |= DB_UnresetViews;\n<line112>if( db->mallocFailed ){\n<line113>sqlite3DeleteColumnNames(db, pTable);\n<line114>}\n<line115>#endif /* SQLITE_OMIT_VIEW */\n<line116>return nErr + pParse->nErr;\n<line117>}
----------------------------------------
Function: sqliteViewResetAll
Content: <line0>static void sqliteViewResetAll(sqlite3 *db, int idx){\n<line1>HashElem *i;\n<line2>assert( sqlite3SchemaMutexHeld(db, idx, 0) );\n<line3>if( !DbHasProperty(db, idx, DB_UnresetViews) ) return;\n<line4>for(i=sqliteHashFirst(&db->aDb[idx].pSchema->tblHash); i;i=sqliteHashNext(i)){\n<line5>Table *pTab = sqliteHashData(i);\n<line6>if( IsView(pTab) ){\n<line7>sqlite3DeleteColumnNames(db, pTab);\n<line8>}\n<line9>}\n<line10>DbClearProperty(db, idx, DB_UnresetViews);\n<line11>}
----------------------------------------
Function: destroyRootPage
Content: <line0>static void destroyRootPage(Parse *pParse, int iTable, int iDb){\n<line1>Vdbe *v = sqlite3GetVdbe(pParse);\n<line2>int r1 = sqlite3GetTempReg(pParse);\n<line3>if( iTable<2 ) sqlite3ErrorMsg(pParse, "corrupt schema");\n<line4>sqlite3VdbeAddOp3(v, OP_Destroy, iTable, r1, iDb);\n<line5>sqlite3MayAbort(pParse);\n<line6>#ifndef SQLITE_OMIT_AUTOVACUUM\n<line7>/* OP_Destroy stores an in integer r1. If this integer\n<line8>** is non-zero, then it is the root page number of a table moved to\n<line9>** location iTable. The following code modifies the sqlite_schema table to\n<line10>** reflect this.\n<line11>**\n<line12>** The "#NNN" in the SQL is a special constant that means whatever value\n<line13>** is in register NNN.  See grammar rules associated with the TK_REGISTER\n<line14>** token for additional information.\n<line15>*/\n<line16>sqlite3NestedParse(pParse,\n<line17>"UPDATE %Q." LEGACY_SCHEMA_TABLE\n<line18>" SET rootpage=%d WHERE #%d AND rootpage=#%d",\n<line19>pParse->db->aDb[iDb].zDbSName, iTable, r1, r1);\n<line20>#endif\n<line21>sqlite3ReleaseTempReg(pParse, r1);\n<line22>}
----------------------------------------
Function: destroyTable
Content: <line0>static void destroyTable(Parse *pParse, Table *pTab){\n<line1>/* If the database may be auto-vacuum capable (if SQLITE_OMIT_AUTOVACUUM\n<line2>** is not defined), then it is important to call OP_Destroy on the\n<line3>** table and index root-pages in order, starting with the numerically\n<line4>** largest root-page number. This guarantees that none of the root-pages\n<line5>** to be destroyed is relocated by an earlier OP_Destroy. i.e. if the\n<line6>** following were coded:\n<line7>**\n<line8>** OP_Destroy 4 0\n<line9>** ...\n<line10>** OP_Destroy 5 0\n<line11>**\n<line12>** and root page 5 happened to be the largest root-page number in the\n<line13>** database, then root page 5 would be moved to page 4 by the\n<line14>** "OP_Destroy 4 0" opcode. The subsequent "OP_Destroy 5 0" would hit\n<line15>** a free-list page.\n<line16>*/\n<line17>Pgno iTab = pTab->tnum;\n<line18>Pgno iDestroyed = 0;\n<line19>while( 1 ){\n<line20>Index *pIdx;\n<line21>Pgno iLargest = 0;\n<line22>if( iDestroyed==0 || iTab<iDestroyed ){\n<line23>iLargest = iTab;\n<line24>}\n<line25>for(pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext){\n<line26>Pgno iIdx = pIdx->tnum;\n<line27>assert( pIdx->pSchema==pTab->pSchema );\n<line28>if( (iDestroyed==0 || (iIdx<iDestroyed)) && iIdx>iLargest ){\n<line29>iLargest = iIdx;\n<line30>}\n<line31>}\n<line32>if( iLargest==0 ){\n<line33>return;\n<line34>}else{\n<line35>int iDb = sqlite3SchemaToIndex(pParse->db, pTab->pSchema);\n<line36>assert( iDb>=0 && iDb<pParse->db->nDb );\n<line37>destroyRootPage(pParse, iLargest, iDb);\n<line38>iDestroyed = iLargest;\n<line39>}\n<line40>}\n<line41>}
----------------------------------------
Function: sqlite3ClearStatTables
Content: <line0>static void sqlite3ClearStatTables(\n<line1>Parse *pParse,         /* The parsing context */\n<line2>int iDb,               /* The database number */\n<line3>const char *zType,     /* "idx" or "tbl" */\n<line4>const char *zName      /* Name of index or table */\n<line5>){\n<line6>int i;\n<line7>const char *zDbName = pParse->db->aDb[iDb].zDbSName;\n<line8>for(i=1; i<=4; i++){\n<line9>char zTab[24];\n<line10>sqlite3_snprintf(sizeof(zTab),zTab,"sqlite_stat%d",i);\n<line11>if( sqlite3FindTable(pParse->db, zTab, zDbName) ){\n<line12>sqlite3NestedParse(pParse,\n<line13>"DELETE FROM %Q.%s WHERE %s=%Q",\n<line14>zDbName, zTab, zType, zName\n<line15>);\n<line16>}\n<line17>}\n<line18>}
----------------------------------------
Function: tableMayNotBeDropped
Content: <line0>static int tableMayNotBeDropped(sqlite3 *db, Table *pTab){\n<line1>if( sqlite3StrNICmp(pTab->zName, "sqlite_", 7)==0 ){\n<line2>if( sqlite3StrNICmp(pTab->zName+7, "stat", 4)==0 ) return 0;\n<line3>if( sqlite3StrNICmp(pTab->zName+7, "parameters", 10)==0 ) return 0;\n<line4>return 1;\n<line5>}\n<line6>if( (pTab->tabFlags & TF_Shadow)!=0 && sqlite3ReadOnlyShadowTables(db) ){\n<line7>return 1;\n<line8>}\n<line9>if( pTab->tabFlags & TF_Eponymous ){\n<line10>return 1;\n<line11>}\n<line12>return 0;\n<line13>}
----------------------------------------
Function: sqlite3RefillIndex
Content: <line0>static void sqlite3RefillIndex(Parse *pParse, Index *pIndex, int memRootPage){\n<line1>Table *pTab = pIndex->pTable;  /* The table that is indexed */\n<line2>int iTab = pParse->nTab++;     /* Btree cursor used for pTab */\n<line3>int iIdx = pParse->nTab++;     /* Btree cursor used for pIndex */\n<line4>int iSorter;                   /* Cursor opened by OpenSorter (if in use) */\n<line5>int addr1;                     /* Address of top of loop */\n<line6>int addr2;                     /* Address to jump to for next iteration */\n<line7>Pgno tnum;                     /* Root page of index */\n<line8>int iPartIdxLabel;             /* Jump to this label to skip a row */\n<line9>Vdbe *v;                       /* Generate code into this virtual machine */\n<line10>KeyInfo *pKey;                 /* KeyInfo for index */\n<line11>int regRecord;                 /* Register holding assembled index record */\n<line12>sqlite3 *db = pParse->db;      /* The database connection */\n<line13>int iDb = sqlite3SchemaToIndex(db, pIndex->pSchema);\n<line14>#ifndef SQLITE_OMIT_AUTHORIZATION\n<line15>if( sqlite3AuthCheck(pParse, SQLITE_REINDEX, pIndex->zName, 0,\n<line16>db->aDb[iDb].zDbSName ) ){\n<line17>return;\n<line18>}\n<line19>#endif\n<line20>/* Require a write-lock on the table to perform this operation */\n<line21>sqlite3TableLock(pParse, iDb, pTab->tnum, 1, pTab->zName);\n<line22>v = sqlite3GetVdbe(pParse);\n<line23>if( v==0 ) return;\n<line24>if( memRootPage>=0 ){\n<line25>tnum = (Pgno)memRootPage;\n<line26>}else{\n<line27>tnum = pIndex->tnum;\n<line28>}\n<line29>pKey = sqlite3KeyInfoOfIndex(pParse, pIndex);\n<line30>assert( pKey!=0 || pParse->nErr );\n<line31>/* Open the sorter cursor if we are to use one. */\n<line32>iSorter = pParse->nTab++;\n<line33>sqlite3VdbeAddOp4(v, OP_SorterOpen, iSorter, 0, pIndex->nKeyCol, (char*)\n<line34>sqlite3KeyInfoRef(pKey), P4_KEYINFO);\n<line35>/* Open the table. Loop through all rows of the table, inserting index\n<line36>** records into the sorter. */\n<line37>sqlite3OpenTable(pParse, iTab, iDb, pTab, OP_OpenRead);\n<line38>addr1 = sqlite3VdbeAddOp2(v, OP_Rewind, iTab, 0); VdbeCoverage(v);\n<line39>regRecord = sqlite3GetTempReg(pParse);\n<line40>sqlite3MultiWrite(pParse);\n<line41>sqlite3GenerateIndexKey(pParse,pIndex,iTab,regRecord,0,&iPartIdxLabel,0,0);\n<line42>sqlite3VdbeAddOp2(v, OP_SorterInsert, iSorter, regRecord);\n<line43>sqlite3ResolvePartIdxLabel(pParse, iPartIdxLabel);\n<line44>sqlite3VdbeAddOp2(v, OP_Next, iTab, addr1+1); VdbeCoverage(v);\n<line45>sqlite3VdbeJumpHere(v, addr1);\n<line46>if( memRootPage<0 ) sqlite3VdbeAddOp2(v, OP_Clear, tnum, iDb);\n<line47>sqlite3VdbeAddOp4(v, OP_OpenWrite, iIdx, (int)tnum, iDb,\n<line48>(char *)pKey, P4_KEYINFO);\n<line49>sqlite3VdbeChangeP5(v, OPFLAG_BULKCSR|((memRootPage>=0)?OPFLAG_P2ISREG:0));\n<line50>addr1 = sqlite3VdbeAddOp2(v, OP_SorterSort, iSorter, 0); VdbeCoverage(v);\n<line51>if( IsUniqueIndex(pIndex) ){\n<line52>int j2 = sqlite3VdbeGoto(v, 1);\n<line53>addr2 = sqlite3VdbeCurrentAddr(v);\n<line54>sqlite3VdbeVerifyAbortable(v, OE_Abort);\n<line55>sqlite3VdbeAddOp4Int(v, OP_SorterCompare, iSorter, j2, regRecord,\n<line56>pIndex->nKeyCol); VdbeCoverage(v);\n<line57>sqlite3UniqueConstraint(pParse, OE_Abort, pIndex);\n<line58>sqlite3VdbeJumpHere(v, j2);\n<line59>}else{\n<line60>/* Most CREATE INDEX and REINDEX statements that are not UNIQUE can not\n<line61>** abort. The exception is if one of the indexed expressions contains a\n<line62>** user function that throws an exception when it is evaluated. But the\n<line63>** overhead of adding a statement journal to a CREATE INDEX statement is\n<line64>** very small (since most of the pages written do not contain content that\n<line65>** needs to be restored if the statement aborts), so we call\n<line66>** sqlite3MayAbort() for all CREATE INDEX statements.  */\n<line67>sqlite3MayAbort(pParse);\n<line68>addr2 = sqlite3VdbeCurrentAddr(v);\n<line69>}\n<line70>sqlite3VdbeAddOp3(v, OP_SorterData, iSorter, regRecord, iIdx);\n<line71>if( !pIndex->bAscKeyBug ){\n<line72>/* This OP_SeekEnd opcode makes index insert for a REINDEX go much\n<line73>** faster by avoiding unnecessary seeks.  But the optimization does\n<line74>** not work for UNIQUE constraint indexes on WITHOUT ROWID tables\n<line75>** with DESC primary keys, since those indexes have there keys in\n<line76>** a different order from the main table.\n<line77>** See ticket: https://sqlite.org/src/info/bba7b69f9849b5bf\n<line78>*/\n<line79>sqlite3VdbeAddOp1(v, OP_SeekEnd, iIdx);\n<line80>}\n<line81>sqlite3VdbeAddOp2(v, OP_IdxInsert, iIdx, regRecord);\n<line82>sqlite3VdbeChangeP5(v, OPFLAG_USESEEKRESULT);\n<line83>sqlite3ReleaseTempReg(pParse, regRecord);\n<line84>sqlite3VdbeAddOp2(v, OP_SorterNext, iSorter, addr2); VdbeCoverage(v);\n<line85>sqlite3VdbeJumpHere(v, addr1);\n<line86>sqlite3VdbeAddOp1(v, OP_Close, iTab);\n<line87>sqlite3VdbeAddOp1(v, OP_Close, iIdx);\n<line88>sqlite3VdbeAddOp1(v, OP_Close, iSorter);\n<line89>}
----------------------------------------
Function: sqlite3CodeVerifySchemaAtToplevel
Content: <line0>static void sqlite3CodeVerifySchemaAtToplevel(Parse *pToplevel, int iDb){\n<line1>assert( iDb>=0 && iDb<pToplevel->db->nDb );\n<line2>assert( pToplevel->db->aDb[iDb].pBt!=0 || iDb==1 );\n<line3>assert( iDb<SQLITE_MAX_DB );\n<line4>assert( sqlite3SchemaMutexHeld(pToplevel->db, iDb, 0) );\n<line5>if( DbMaskTest(pToplevel->cookieMask, iDb)==0 ){\n<line6>DbMaskSet(pToplevel->cookieMask, iDb);\n<line7>if( !OMIT_TEMPDB && iDb==1 ){\n<line8>sqlite3OpenTempDatabase(pToplevel);\n<line9>}\n<line10>}\n<line11>}
----------------------------------------
Function: collationMatch
Content: <line0>static int collationMatch(const char *zColl, Index *pIndex){\n<line1>int i;\n<line2>assert( zColl!=0 );\n<line3>for(i=0; i<pIndex->nColumn; i++){\n<line4>const char *z = pIndex->azColl[i];\n<line5>assert( z!=0 || pIndex->aiColumn[i]<0 );\n<line6>if( pIndex->aiColumn[i]>=0 && 0==sqlite3StrICmp(z, zColl) ){\n<line7>return 1;\n<line8>}\n<line9>}\n<line10>return 0;\n<line11>}
----------------------------------------
Function: reindexTable
Content: <line0>static void reindexTable(Parse *pParse, Table *pTab, char const *zColl){\n<line1>if( !IsVirtual(pTab) ){\n<line2>Index *pIndex;              /* An index associated with pTab */\n<line3>for(pIndex=pTab->pIndex; pIndex; pIndex=pIndex->pNext){\n<line4>if( zColl==0 || collationMatch(zColl, pIndex) ){\n<line5>int iDb = sqlite3SchemaToIndex(pParse->db, pTab->pSchema);\n<line6>sqlite3BeginWriteOperation(pParse, 0, iDb);\n<line7>sqlite3RefillIndex(pParse, pIndex, -1);\n<line8>}\n<line9>}\n<line10>}\n<line11>}
----------------------------------------
Function: reindexDatabases
Content: <line0>static void reindexDatabases(Parse *pParse, char const *zColl){\n<line1>Db *pDb;                    /* A single database */\n<line2>int iDb;                    /* The database index number */\n<line3>sqlite3 *db = pParse->db;   /* The database connection */\n<line4>HashElem *k;                /* For looping over tables in pDb */\n<line5>Table *pTab;                /* A table in the database */\n<line6>assert( sqlite3BtreeHoldsAllMutexes(db) );  /* Needed for schema access */\n<line7>for(iDb=0, pDb=db->aDb; iDb<db->nDb; iDb++, pDb++){\n<line8>assert( pDb!=0 );\n<line9>for(k=sqliteHashFirst(&pDb->pSchema->tblHash);  k; k=sqliteHashNext(k)){\n<line10>pTab = (Table*)sqliteHashData(k);\n<line11>reindexTable(pParse, pTab, zColl);\n<line12>}\n<line13>}\n<line14>}
----------------------------------------
Function: cteClear
Content: <line0>static void cteClear(sqlite3 *db, Cte *pCte){\n<line1>assert( pCte!=0 );\n<line2>sqlite3ExprListDelete(db, pCte->pCols);\n<line3>sqlite3SelectDelete(db, pCte->pSelect);\n<line4>sqlite3DbFree(db, pCte->zName);\n<line5>}
----------------------------------------
Function: callCollNeeded
Content: <line0>static void callCollNeeded(sqlite3 *db, int enc, const char *zName){\n<line1>assert( !db->xCollNeeded || !db->xCollNeeded16 );\n<line2>if( db->xCollNeeded ){\n<line3>char *zExternal = sqlite3DbStrDup(db, zName);\n<line4>if( !zExternal ) return;\n<line5>db->xCollNeeded(db->pCollNeededArg, db, enc, zExternal);\n<line6>sqlite3DbFree(db, zExternal);\n<line7>}\n<line8>#ifndef SQLITE_OMIT_UTF16\n<line9>if( db->xCollNeeded16 ){\n<line10>char const *zExternal;\n<line11>sqlite3_value *pTmp = sqlite3ValueNew(db);\n<line12>sqlite3ValueSetStr(pTmp, -1, zName, SQLITE_UTF8, SQLITE_STATIC);\n<line13>zExternal = sqlite3ValueText(pTmp, SQLITE_UTF16NATIVE);\n<line14>if( zExternal ){\n<line15>db->xCollNeeded16(db->pCollNeededArg, db, (int)ENC(db), zExternal);\n<line16>}\n<line17>sqlite3ValueFree(pTmp);\n<line18>}\n<line19>#endif\n<line20>}
----------------------------------------
Function: synthCollSeq
Content: <line0>static int synthCollSeq(sqlite3 *db, CollSeq *pColl){\n<line1>CollSeq *pColl2;\n<line2>char *z = pColl->zName;\n<line3>int i;\n<line4>static const u8 aEnc[] = { SQLITE_UTF16BE, SQLITE_UTF16LE, SQLITE_UTF8 };\n<line5>for(i=0; i<3; i++){\n<line6>pColl2 = sqlite3FindCollSeq(db, aEnc[i], z, 0);\n<line7>if( pColl2->xCmp!=0 ){\n<line8>memcpy(pColl, pColl2, sizeof(CollSeq));\n<line9>pColl->xDel = 0;         /* Do not copy the destructor */\n<line10>return SQLITE_OK;\n<line11>}\n<line12>}\n<line13>return SQLITE_ERROR;\n<line14>}
----------------------------------------
Function: findCollSeqEntry
Content: <line0>static CollSeq *findCollSeqEntry(\n<line1>sqlite3 *db,          /* Database connection */\n<line2>const char *zName,    /* Name of the collating sequence */\n<line3>int create            /* Create a new entry if true */\n<line4>){\n<line5>CollSeq *pColl;\n<line6>pColl = sqlite3HashFind(&db->aCollSeq, zName);\n<line7>if( 0==pColl && create ){\n<line8>int nName = sqlite3Strlen30(zName) + 1;\n<line9>pColl = sqlite3DbMallocZero(db, 3*sizeof(*pColl) + nName);\n<line10>if( pColl ){\n<line11>CollSeq *pDel = 0;\n<line12>pColl[0].zName = (char*)&pColl[3];\n<line13>pColl[0].enc = SQLITE_UTF8;\n<line14>pColl[1].zName = (char*)&pColl[3];\n<line15>pColl[1].enc = SQLITE_UTF16LE;\n<line16>pColl[2].zName = (char*)&pColl[3];\n<line17>pColl[2].enc = SQLITE_UTF16BE;\n<line18>memcpy(pColl[0].zName, zName, nName);\n<line19>pDel = sqlite3HashInsert(&db->aCollSeq, pColl[0].zName, pColl);\n<line20>/* If a malloc() failure occurred in sqlite3HashInsert(), it will\n<line21>** return the pColl pointer to be deleted (because it wasn't added\n<line22>** to the hash table).\n<line23>*/\n<line24>assert( pDel==0 || pDel==pColl );\n<line25>if( pDel!=0 ){\n<line26>sqlite3OomFault(db);\n<line27>sqlite3DbFree(db, pDel);\n<line28>pColl = 0;\n<line29>}\n<line30>}\n<line31>}\n<line32>return pColl;\n<line33>}
----------------------------------------
Function: matchQuality
Content: <line0>static int matchQuality(\n<line1>FuncDef *p,     /* The function we are evaluating for match quality */\n<line2>int nArg,       /* Desired number of arguments.  (-1)==any */\n<line3>u8 enc          /* Desired text encoding */\n<line4>){\n<line5>int match;\n<line6>assert( p->nArg>=(-4) && p->nArg!=(-2) );\n<line7>assert( nArg>=(-2) );\n<line8>/* Wrong number of arguments means "no match" */\n<line9>if( p->nArg!=nArg ){\n<line10>if( nArg==(-2) ) return p->xSFunc==0 ? 0 : FUNC_PERFECT_MATCH;\n<line11>if( p->nArg>=0 ) return 0;\n<line12>/* Special p->nArg values available to built-in functions only:\n<line13>**    -3     1 or more arguments required\n<line14>**    -4     2 or more arguments required\n<line15>*/\n<line16>if( p->nArg<(-2) && nArg<(-2-p->nArg) ) return 0;\n<line17>}\n<line18>/* Give a better score to a function with a specific number of arguments\n<line19>** than to function that accepts any number of arguments. */\n<line20>if( p->nArg==nArg ){\n<line21>match = 4;\n<line22>}else{\n<line23>match = 1;\n<line24>}\n<line25>/* Bonus points if the text encoding matches */\n<line26>if( enc==(p->funcFlags & SQLITE_FUNC_ENCMASK) ){\n<line27>match += 2;  /* Exact encoding match */\n<line28>}else if( (enc & p->funcFlags & 2)!=0 ){\n<line29>match += 1;  /* Both are UTF16, but with different byte orders */\n<line30>}\n<line31>return match;\n<line32>}
----------------------------------------
Function: vtabIsReadOnly
Content: <line0>static int vtabIsReadOnly(Parse *pParse, Table *pTab){\n<line1>assert( IsVirtual(pTab) );\n<line2>if( sqlite3GetVTable(pParse->db, pTab)->pMod->pModule->xUpdate==0 ){\n<line3>return 1;\n<line4>}\n<line5>/* Within triggers:\n<line6>**   *  Do not allow DELETE, INSERT, or UPDATE of SQLITE_VTAB_DIRECTONLY\n<line7>**      virtual tables\n<line8>**   *  Only allow DELETE, INSERT, or UPDATE of non-SQLITE_VTAB_INNOCUOUS\n<line9>**      virtual tables if PRAGMA trusted_schema=ON.\n<line10>*/\n<line11>if( pParse->pToplevel!=0\n<line12>&& pTab->u.vtab.p->eVtabRisk >\n<line13>((pParse->db->flags & SQLITE_TrustedSchema)!=0)\n<line14>){\n<line15>sqlite3ErrorMsg(pParse, "unsafe use of virtual table \"%s\"",\n<line16>pTab->zName);\n<line17>}\n<line18>return 0;\n<line19>}
----------------------------------------
Function: tabIsReadOnly
Content: <line0>static int tabIsReadOnly(Parse *pParse, Table *pTab){\n<line1>sqlite3 *db;\n<line2>if( IsVirtual(pTab) ){\n<line3>return vtabIsReadOnly(pParse, pTab);\n<line4>}\n<line5>if( (pTab->tabFlags & (TF_Readonly|TF_Shadow))==0 ) return 0;\n<line6>db = pParse->db;\n<line7>if( (pTab->tabFlags & TF_Readonly)!=0 ){\n<line8>return sqlite3WritableSchema(db)==0 && pParse->nested==0;\n<line9>}\n<line10>assert( pTab->tabFlags & TF_Shadow );\n<line11>return sqlite3ReadOnlyShadowTables(db);\n<line12>}
----------------------------------------
Function: sqlite3GetFuncCollSeq
Content: <line0>static CollSeq *sqlite3GetFuncCollSeq(sqlite3_context *context){\n<line1>VdbeOp *pOp;\n<line2>assert( context->pVdbe!=0 );\n<line3>pOp = &context->pVdbe->aOp[context->iOp-1];\n<line4>assert( pOp->opcode==OP_CollSeq );\n<line5>assert( pOp->p4type==P4_COLLSEQ );\n<line6>return pOp->p4.pColl;\n<line7>}
----------------------------------------
Function: sqlite3SkipAccumulatorLoad
Content: <line0>static void sqlite3SkipAccumulatorLoad(sqlite3_context *context){\n<line1>assert( context->isError<=0 );\n<line2>context->isError = -1;\n<line3>context->skipFlag = 1;\n<line4>}
----------------------------------------
Function: minmaxFunc
Content: <line0>static void minmaxFunc(\n<line1>sqlite3_context *context,\n<line2>int argc,\n<line3>sqlite3_value **argv\n<line4>){\n<line5>int i;\n<line6>int mask;    /* 0 for min() or 0xffffffff for max() */\n<line7>int iBest;\n<line8>CollSeq *pColl;\n<line9>assert( argc>1 );\n<line10>mask = sqlite3_user_data(context)==0 ? 0 : -1;\n<line11>pColl = sqlite3GetFuncCollSeq(context);\n<line12>assert( pColl );\n<line13>assert( mask==-1 || mask==0 );\n<line14>iBest = 0;\n<line15>if( sqlite3_value_type(argv[0])==SQLITE_NULL ) return;\n<line16>for(i=1; i<argc; i++){\n<line17>if( sqlite3_value_type(argv[i])==SQLITE_NULL ) return;\n<line18>if( (sqlite3MemCompare(argv[iBest], argv[i], pColl)^mask)>=0 ){\n<line19>testcase( mask==0 );\n<line20>iBest = i;\n<line21>}\n<line22>}\n<line23>sqlite3_result_value(context, argv[iBest]);\n<line24>}
----------------------------------------
Function: typeofFunc
Content: <line0>static void typeofFunc(\n<line1>sqlite3_context *context,\n<line2>int NotUsed,\n<line3>sqlite3_value **argv\n<line4>){\n<line5>static const char *azType[] = { "integer", "real", "text", "blob", "null" };\n<line6>int i = sqlite3_value_type(argv[0]) - 1;\n<line7>UNUSED_PARAMETER(NotUsed);\n<line8>assert( i>=0 && i<ArraySize(azType) );\n<line9>assert( SQLITE_INTEGER==1 );\n<line10>assert( SQLITE_FLOAT==2 );\n<line11>assert( SQLITE_TEXT==3 );\n<line12>assert( SQLITE_BLOB==4 );\n<line13>assert( SQLITE_NULL==5 );\n<line14>/* EVIDENCE-OF: R-01470-60482 The sqlite3_value_type(V) interface returns\n<line15>** the datatype code for the initial datatype of the sqlite3_value object\n<line16>** V. The returned value is one of SQLITE_INTEGER, SQLITE_FLOAT,\n<line17>** SQLITE_TEXT, SQLITE_BLOB, or SQLITE_NULL. */\n<line18>sqlite3_result_text(context, azType[i], -1, SQLITE_STATIC);\n<line19>}
----------------------------------------
Function: subtypeFunc
Content: <line0>static void subtypeFunc(\n<line1>sqlite3_context *context,\n<line2>int argc,\n<line3>sqlite3_value **argv\n<line4>){\n<line5>UNUSED_PARAMETER(argc);\n<line6>sqlite3_result_int(context, sqlite3_value_subtype(argv[0]));\n<line7>}
----------------------------------------
Function: lengthFunc
Content: <line0>static void lengthFunc(\n<line1>sqlite3_context *context,\n<line2>int argc,\n<line3>sqlite3_value **argv\n<line4>){\n<line5>assert( argc==1 );\n<line6>UNUSED_PARAMETER(argc);\n<line7>switch( sqlite3_value_type(argv[0]) ){\n<line8>case SQLITE_BLOB:\n<line9>case SQLITE_INTEGER:\n<line10>case SQLITE_FLOAT: {\n<line11>sqlite3_result_int(context, sqlite3_value_bytes(argv[0]));\n<line12>break;\n<line13>}\n<line14>case SQLITE_TEXT: {\n<line15>const unsigned char *z = sqlite3_value_text(argv[0]);\n<line16>const unsigned char *z0;\n<line17>unsigned char c;\n<line18>if( z==0 ) return;\n<line19>z0 = z;\n<line20>while( (c = *z)!=0 ){\n<line21>z++;\n<line22>if( c>=0xc0 ){\n<line23>while( (*z & 0xc0)==0x80 ){ z++; z0++; }\n<line24>}\n<line25>}\n<line26>sqlite3_result_int(context, (int)(z-z0));\n<line27>break;\n<line28>}\n<line29>default: {\n<line30>sqlite3_result_null(context);\n<line31>break;\n<line32>}\n<line33>}\n<line34>}
----------------------------------------
Function: bytelengthFunc
Content: <line0>static void bytelengthFunc(\n<line1>sqlite3_context *context,\n<line2>int argc,\n<line3>sqlite3_value **argv\n<line4>){\n<line5>assert( argc==1 );\n<line6>UNUSED_PARAMETER(argc);\n<line7>switch( sqlite3_value_type(argv[0]) ){\n<line8>case SQLITE_BLOB: {\n<line9>sqlite3_result_int(context, sqlite3_value_bytes(argv[0]));\n<line10>break;\n<line11>}\n<line12>case SQLITE_INTEGER:\n<line13>case SQLITE_FLOAT: {\n<line14>i64 m = sqlite3_context_db_handle(context)->enc<=SQLITE_UTF8 ? 1 : 2;\n<line15>sqlite3_result_int64(context, sqlite3_value_bytes(argv[0])*m);\n<line16>break;\n<line17>}\n<line18>case SQLITE_TEXT: {\n<line19>if( sqlite3_value_encoding(argv[0])<=SQLITE_UTF8 ){\n<line20>sqlite3_result_int(context, sqlite3_value_bytes(argv[0]));\n<line21>}else{\n<line22>sqlite3_result_int(context, sqlite3_value_bytes16(argv[0]));\n<line23>}\n<line24>break;\n<line25>}\n<line26>default: {\n<line27>sqlite3_result_null(context);\n<line28>break;\n<line29>}\n<line30>}\n<line31>}
----------------------------------------
Function: absFunc
Content: <line0>static void absFunc(sqlite3_context *context, int argc, sqlite3_value **argv){\n<line1>assert( argc==1 );\n<line2>UNUSED_PARAMETER(argc);\n<line3>switch( sqlite3_value_type(argv[0]) ){\n<line4>case SQLITE_INTEGER: {\n<line5>i64 iVal = sqlite3_value_int64(argv[0]);\n<line6>if( iVal<0 ){\n<line7>if( iVal==SMALLEST_INT64 ){\n<line8>/* IMP: R-31676-45509 If X is the integer -9223372036854775808\n<line9>** then abs(X) throws an integer overflow error since there is no\n<line10>** equivalent positive 64-bit two complement value. */\n<line11>sqlite3_result_error(context, "integer overflow", -1);\n<line12>return;\n<line13>}\n<line14>iVal = -iVal;\n<line15>}\n<line16>sqlite3_result_int64(context, iVal);\n<line17>break;\n<line18>}\n<line19>case SQLITE_NULL: {\n<line20>/* IMP: R-37434-19929 Abs(X) returns NULL if X is NULL. */\n<line21>sqlite3_result_null(context);\n<line22>break;\n<line23>}\n<line24>default: {\n<line25>/* Because sqlite3_value_double() returns 0.0 if the argument is not\n<line26>** something that can be converted into a number, we have:\n<line27>** IMP: R-01992-00519 Abs(X) returns 0.0 if X is a string or blob\n<line28>** that cannot be converted to a numeric value.\n<line29>*/\n<line30>double rVal = sqlite3_value_double(argv[0]);\n<line31>if( rVal<0 ) rVal = -rVal;\n<line32>sqlite3_result_double(context, rVal);\n<line33>break;\n<line34>}\n<line35>}\n<line36>}
----------------------------------------
Function: instrFunc
Content: <line0>static void instrFunc(\n<line1>sqlite3_context *context,\n<line2>int argc,\n<line3>sqlite3_value **argv\n<line4>){\n<line5>const unsigned char *zHaystack;\n<line6>const unsigned char *zNeedle;\n<line7>int nHaystack;\n<line8>int nNeedle;\n<line9>int typeHaystack, typeNeedle;\n<line10>int N = 1;\n<line11>int isText;\n<line12>unsigned char firstChar;\n<line13>sqlite3_value *pC1 = 0;\n<line14>sqlite3_value *pC2 = 0;\n<line15>UNUSED_PARAMETER(argc);\n<line16>typeHaystack = sqlite3_value_type(argv[0]);\n<line17>typeNeedle = sqlite3_value_type(argv[1]);\n<line18>if( typeHaystack==SQLITE_NULL || typeNeedle==SQLITE_NULL ) return;\n<line19>nHaystack = sqlite3_value_bytes(argv[0]);\n<line20>nNeedle = sqlite3_value_bytes(argv[1]);\n<line21>if( nNeedle>0 ){\n<line22>if( typeHaystack==SQLITE_BLOB && typeNeedle==SQLITE_BLOB ){\n<line23>zHaystack = sqlite3_value_blob(argv[0]);\n<line24>zNeedle = sqlite3_value_blob(argv[1]);\n<line25>isText = 0;\n<line26>}else if( typeHaystack!=SQLITE_BLOB && typeNeedle!=SQLITE_BLOB ){\n<line27>zHaystack = sqlite3_value_text(argv[0]);\n<line28>zNeedle = sqlite3_value_text(argv[1]);\n<line29>isText = 1;\n<line30>}else{\n<line31>pC1 = sqlite3_value_dup(argv[0]);\n<line32>zHaystack = sqlite3_value_text(pC1);\n<line33>if( zHaystack==0 ) goto endInstrOOM;\n<line34>nHaystack = sqlite3_value_bytes(pC1);\n<line35>pC2 = sqlite3_value_dup(argv[1]);\n<line36>zNeedle = sqlite3_value_text(pC2);\n<line37>if( zNeedle==0 ) goto endInstrOOM;\n<line38>nNeedle = sqlite3_value_bytes(pC2);\n<line39>isText = 1;\n<line40>}\n<line41>if( zNeedle==0 || (nHaystack && zHaystack==0) ) goto endInstrOOM;\n<line42>firstChar = zNeedle[0];\n<line43>while( nNeedle<=nHaystack\n<line44>&& (zHaystack[0]!=firstChar || memcmp(zHaystack, zNeedle, nNeedle)!=0)\n<line45>){\n<line46>N++;\n<line47>do{\n<line48>nHaystack--;\n<line49>zHaystack++;\n<line50>}while( isText && (zHaystack[0]&0xc0)==0x80 );\n<line51>}\n<line52>if( nNeedle>nHaystack ) N = 0;\n<line53>}\n<line54>sqlite3_result_int(context, N);\n<line55>endInstr:\n<line56>sqlite3_value_free(pC1);\n<line57>sqlite3_value_free(pC2);\n<line58>return;\n<line59>endInstrOOM:\n<line60>sqlite3_result_error_nomem(context);\n<line61>goto endInstr;\n<line62>}
----------------------------------------
Function: printfFunc
Content: <line0>static void printfFunc(\n<line1>sqlite3_context *context,\n<line2>int argc,\n<line3>sqlite3_value **argv\n<line4>){\n<line5>PrintfArguments x;\n<line6>StrAccum str;\n<line7>const char *zFormat;\n<line8>int n;\n<line9>sqlite3 *db = sqlite3_context_db_handle(context);\n<line10>if( argc>=1 && (zFormat = (const char*)sqlite3_value_text(argv[0]))!=0 ){\n<line11>x.nArg = argc-1;\n<line12>x.nUsed = 0;\n<line13>x.apArg = argv+1;\n<line14>sqlite3StrAccumInit(&str, db, 0, 0, db->aLimit[SQLITE_LIMIT_LENGTH]);\n<line15>str.printfFlags = SQLITE_PRINTF_SQLFUNC;\n<line16>sqlite3_str_appendf(&str, zFormat, &x);\n<line17>n = str.nChar;\n<line18>sqlite3_result_text(context, sqlite3StrAccumFinish(&str), n,\n<line19>SQLITE_DYNAMIC);\n<line20>}\n<line21>}
----------------------------------------
Function: substrFunc
Content: <line0>static void substrFunc(\n<line1>sqlite3_context *context,\n<line2>int argc,\n<line3>sqlite3_value **argv\n<line4>){\n<line5>const unsigned char *z;\n<line6>const unsigned char *z2;\n<line7>int len;\n<line8>int p0type;\n<line9>i64 p1, p2;\n<line10>assert( argc==3 || argc==2 );\n<line11>p0type = sqlite3_value_type(argv[0]);\n<line12>p1 = sqlite3_value_int64(argv[1]);\n<line13>if( p0type==SQLITE_BLOB ){\n<line14>len = sqlite3_value_bytes(argv[0]);\n<line15>z = sqlite3_value_blob(argv[0]);\n<line16>if( z==0 ) return;\n<line17>assert( len==sqlite3_value_bytes(argv[0]) );\n<line18>}else{\n<line19>z = sqlite3_value_text(argv[0]);\n<line20>if( z==0 ) return;\n<line21>len = 0;\n<line22>if( p1<0 ){\n<line23>for(z2=z; *z2; len++){\n<line24>SQLITE_SKIP_UTF8(z2);\n<line25>}\n<line26>}\n<line27>}\n<line28>if( argc==3 ){\n<line29>p2 = sqlite3_value_int64(argv[2]);\n<line30>if( p2==0 && sqlite3_value_type(argv[2])==SQLITE_NULL ) return;\n<line31>}else{\n<line32>p2 = sqlite3_context_db_handle(context)->aLimit[SQLITE_LIMIT_LENGTH];\n<line33>}\n<line34>if( p1==0 ){\n<line35>#ifdef SQLITE_SUBSTR_COMPATIBILITY\n<line36>/* If SUBSTR_COMPATIBILITY is defined then substr(X,0,N) work the same as\n<line37>** as substr(X,1,N) - it returns the first N characters of X.  This\n<line38>** is essentially a back-out of the bug-fix in check-in [5fc125d362df4b8]\n<line39>** from 2009-02-02 for compatibility of applications that exploited the\n<line40>** old buggy behavior. */\n<line41>p1 = 1; /* <rdar://problem/6778339> */\n<line42>#endif\n<line43>if( sqlite3_value_type(argv[1])==SQLITE_NULL ) return;\n<line44>}\n<line45>if( p1<0 ){\n<line46>p1 += len;\n<line47>if( p1<0 ){\n<line48>if( p2<0 ){\n<line49>p2 = 0;\n<line50>}else{\n<line51>p2 += p1;\n<line52>}\n<line53>p1 = 0;\n<line54>}\n<line55>}else if( p1>0 ){\n<line56>p1--;\n<line57>}else if( p2>0 ){\n<line58>p2--;\n<line59>}\n<line60>if( p2<0 ){\n<line61>if( p2<-p1 ){\n<line62>p2 = p1;\n<line63>}else{\n<line64>p2 = -p2;\n<line65>}\n<line66>p1 -= p2;\n<line67>}\n<line68>assert( p1>=0 && p2>=0 );\n<line69>if( p0type!=SQLITE_BLOB ){\n<line70>while( *z && p1 ){\n<line71>SQLITE_SKIP_UTF8(z);\n<line72>p1--;\n<line73>}\n<line74>for(z2=z; *z2 && p2; p2--){\n<line75>SQLITE_SKIP_UTF8(z2);\n<line76>}\n<line77>sqlite3_result_text64(context, (char*)z, z2-z, SQLITE_TRANSIENT,\n<line78>SQLITE_UTF8);\n<line79>}else{\n<line80>if( p1>=len ){\n<line81>p1 = p2 = 0;\n<line82>}else if( p2>len-p1 ){\n<line83>p2 = len-p1;\n<line84>assert( p2>0 );\n<line85>}\n<line86>sqlite3_result_blob64(context, (char*)&z[p1], (u64)p2, SQLITE_TRANSIENT);\n<line87>}\n<line88>}
----------------------------------------
Function: roundFunc
Content: <line0>static void roundFunc(sqlite3_context *context, int argc, sqlite3_value **argv){\n<line1>i64 n = 0;\n<line2>double r;\n<line3>char *zBuf;\n<line4>assert( argc==1 || argc==2 );\n<line5>if( argc==2 ){\n<line6>if( SQLITE_NULL==sqlite3_value_type(argv[1]) ) return;\n<line7>n = sqlite3_value_int64(argv[1]);\n<line8>if( n>30 ) n = 30;\n<line9>if( n<0 ) n = 0;\n<line10>}\n<line11>if( sqlite3_value_type(argv[0])==SQLITE_NULL ) return;\n<line12>r = sqlite3_value_double(argv[0]);\n<line13>/* If Y==0 and X will fit in a 64-bit int,\n<line14>** handle the rounding directly,\n<line15>** otherwise use printf.\n<line16>*/\n<line17>if( r<-4503599627370496.0 || r>+4503599627370496.0 ){\n<line18>/* The value has no fractional part so there is nothing to round */\n<line19>}else if( n==0 ){\n<line20>r = (double)((sqlite_int64)(r+(r<0?-0.5:+0.5)));\n<line21>}else{\n<line22>zBuf = sqlite3_mprintf("%!.*f",(int)n,r);\n<line23>if( zBuf==0 ){\n<line24>sqlite3_result_error_nomem(context);\n<line25>return;\n<line26>}\n<line27>sqlite3AtoF(zBuf, &r, sqlite3Strlen30(zBuf), SQLITE_UTF8);\n<line28>sqlite3_free(zBuf);\n<line29>}\n<line30>sqlite3_result_double(context, r);\n<line31>}
----------------------------------------
Function: contextMalloc
Content: <line0>static void *contextMalloc(sqlite3_context *context, i64 nByte){\n<line1>char *z;\n<line2>sqlite3 *db = sqlite3_context_db_handle(context);\n<line3>assert( nByte>0 );\n<line4>testcase( nByte==db->aLimit[SQLITE_LIMIT_LENGTH] );\n<line5>testcase( nByte==(i64)db->aLimit[SQLITE_LIMIT_LENGTH]+1 );\n<line6>if( nByte>db->aLimit[SQLITE_LIMIT_LENGTH] ){\n<line7>sqlite3_result_error_toobig(context);\n<line8>z = 0;\n<line9>}else{\n<line10>z = sqlite3Malloc(nByte);\n<line11>if( !z ){\n<line12>sqlite3_result_error_nomem(context);\n<line13>}\n<line14>}\n<line15>return z;\n<line16>}
----------------------------------------
Function: upperFunc
Content: <line0>static void upperFunc(sqlite3_context *context, int argc, sqlite3_value **argv){\n<line1>char *z1;\n<line2>const char *z2;\n<line3>int i, n;\n<line4>UNUSED_PARAMETER(argc);\n<line5>z2 = (char*)sqlite3_value_text(argv[0]);\n<line6>n = sqlite3_value_bytes(argv[0]);\n<line7>/* Verify that the call to _bytes() does not invalidate the _text() pointer */\n<line8>assert( z2==(char*)sqlite3_value_text(argv[0]) );\n<line9>if( z2 ){\n<line10>z1 = contextMalloc(context, ((i64)n)+1);\n<line11>if( z1 ){\n<line12>for(i=0; i<n; i++){\n<line13>z1[i] = (char)sqlite3Toupper(z2[i]);\n<line14>}\n<line15>sqlite3_result_text(context, z1, n, sqlite3_free);\n<line16>}\n<line17>}\n<line18>}
----------------------------------------
Function: lowerFunc
Content: <line0>static void lowerFunc(sqlite3_context *context, int argc, sqlite3_value **argv){\n<line1>char *z1;\n<line2>const char *z2;\n<line3>int i, n;\n<line4>UNUSED_PARAMETER(argc);\n<line5>z2 = (char*)sqlite3_value_text(argv[0]);\n<line6>n = sqlite3_value_bytes(argv[0]);\n<line7>/* Verify that the call to _bytes() does not invalidate the _text() pointer */\n<line8>assert( z2==(char*)sqlite3_value_text(argv[0]) );\n<line9>if( z2 ){\n<line10>z1 = contextMalloc(context, ((i64)n)+1);\n<line11>if( z1 ){\n<line12>for(i=0; i<n; i++){\n<line13>z1[i] = sqlite3Tolower(z2[i]);\n<line14>}\n<line15>sqlite3_result_text(context, z1, n, sqlite3_free);\n<line16>}\n<line17>}\n<line18>}
----------------------------------------
Function: randomFunc
Content: <line0>static void randomFunc(\n<line1>sqlite3_context *context,\n<line2>int NotUsed,\n<line3>sqlite3_value **NotUsed2\n<line4>){\n<line5>sqlite_int64 r;\n<line6>UNUSED_PARAMETER2(NotUsed, NotUsed2);\n<line7>sqlite3_randomness(sizeof(r), &r);\n<line8>if( r<0 ){\n<line9>/* We need to prevent a random number of 0x8000000000000000\n<line10>** (or -9223372036854775808) since when you do abs() of that\n<line11>** number of you get the same value back again.  To do this\n<line12>** in a way that is testable, mask the sign bit off of negative\n<line13>** values, resulting in a positive value.  Then take the\n<line14>** 2s complement of that positive value.  The end result can\n<line15>** therefore be no less than -9223372036854775807.\n<line16>*/\n<line17>r = -(r & LARGEST_INT64);\n<line18>}\n<line19>sqlite3_result_int64(context, r);\n<line20>}
----------------------------------------
Function: randomBlob
Content: <line0>static void randomBlob(\n<line1>sqlite3_context *context,\n<line2>int argc,\n<line3>sqlite3_value **argv\n<line4>){\n<line5>sqlite3_int64 n;\n<line6>unsigned char *p;\n<line7>assert( argc==1 );\n<line8>UNUSED_PARAMETER(argc);\n<line9>n = sqlite3_value_int64(argv[0]);\n<line10>if( n<1 ){\n<line11>n = 1;\n<line12>}\n<line13>p = contextMalloc(context, n);\n<line14>if( p ){\n<line15>sqlite3_randomness(n, p);\n<line16>sqlite3_result_blob(context, (char*)p, n, sqlite3_free);\n<line17>}\n<line18>}
----------------------------------------
Function: last_insert_rowid
Content: <line0>static void last_insert_rowid(\n<line1>sqlite3_context *context,\n<line2>int NotUsed,\n<line3>sqlite3_value **NotUsed2\n<line4>){\n<line5>sqlite3 *db = sqlite3_context_db_handle(context);\n<line6>UNUSED_PARAMETER2(NotUsed, NotUsed2);\n<line7>/* IMP: R-51513-12026 The last_insert_rowid() SQL function is a\n<line8>** wrapper around the sqlite3_last_insert_rowid() C/C++ interface\n<line9>** function. */\n<line10>sqlite3_result_int64(context, sqlite3_last_insert_rowid(db));\n<line11>}
----------------------------------------
Function: changes
Content: <line0>static void changes(\n<line1>sqlite3_context *context,\n<line2>int NotUsed,\n<line3>sqlite3_value **NotUsed2\n<line4>){\n<line5>sqlite3 *db = sqlite3_context_db_handle(context);\n<line6>UNUSED_PARAMETER2(NotUsed, NotUsed2);\n<line7>sqlite3_result_int64(context, sqlite3_changes64(db));\n<line8>}
----------------------------------------
Function: total_changes
Content: <line0>static void total_changes(\n<line1>sqlite3_context *context,\n<line2>int NotUsed,\n<line3>sqlite3_value **NotUsed2\n<line4>){\n<line5>sqlite3 *db = sqlite3_context_db_handle(context);\n<line6>UNUSED_PARAMETER2(NotUsed, NotUsed2);\n<line7>/* IMP: R-11217-42568 This function is a wrapper around the\n<line8>** sqlite3_total_changes64() C/C++ interface. */\n<line9>sqlite3_result_int64(context, sqlite3_total_changes64(db));\n<line10>}
----------------------------------------
Function: patternCompare
Content: <line0>static int patternCompare(\n<line1>const u8 *zPattern,              /* The glob pattern */\n<line2>const u8 *zString,               /* The string to compare against the glob */\n<line3>const struct compareInfo *pInfo, /* Information about how to do the compare */\n<line4>u32 matchOther                   /* The escape char (LIKE) or '[' (GLOB) */\n<line5>){\n<line6>u32 c, c2;                       /* Next pattern and input string chars */\n<line7>u32 matchOne = pInfo->matchOne;  /* "?" or "_" */\n<line8>u32 matchAll = pInfo->matchAll;  /* "*" or "%" */\n<line9>u8 noCase = pInfo->noCase;       /* True if uppercase==lowercase */\n<line10>const u8 *zEscaped = 0;          /* One past the last escaped input char */\n<line11>while( (c = Utf8Read(zPattern))!=0 ){\n<line12>if( c==matchAll ){  /* Match "*" */\n<line13>/* Skip over multiple "*" characters in the pattern.  If there\n<line14>** are also "?" characters, skip those as well, but consume a\n<line15>** single character of the input string for each "?" skipped */\n<line16>while( (c=Utf8Read(zPattern)) == matchAll\n<line17>|| (c == matchOne && matchOne!=0) ){\n<line18>if( c==matchOne && sqlite3Utf8Read(&zString)==0 ){\n<line19>return SQLITE_NOWILDCARDMATCH;\n<line20>}\n<line21>}\n<line22>if( c==0 ){\n<line23>return SQLITE_MATCH;   /* "*" at the end of the pattern matches */\n<line24>}else if( c==matchOther ){\n<line25>if( pInfo->matchSet==0 ){\n<line26>c = sqlite3Utf8Read(&zPattern);\n<line27>if( c==0 ) return SQLITE_NOWILDCARDMATCH;\n<line28>}else{\n<line29>/* "[...]" immediately follows the "*".  We have to do a slow\n<line30>** recursive search in this case, but it is an unusual case. */\n<line31>assert( matchOther<0x80 );  /* '[' is a single-byte character */\n<line32>while( *zString ){\n<line33>int bMatch = patternCompare(&zPattern[-1],zString,pInfo,matchOther);\n<line34>if( bMatch!=SQLITE_NOMATCH ) return bMatch;\n<line35>SQLITE_SKIP_UTF8(zString);\n<line36>}\n<line37>return SQLITE_NOWILDCARDMATCH;\n<line38>}\n<line39>}\n<line40>/* At this point variable c contains the first character of the\n<line41>** pattern string past the "*".  Search in the input string for the\n<line42>** first matching character and recursively continue the match from\n<line43>** that point.\n<line44>**\n<line45>** For a case-insensitive search, set variable cx to be the same as\n<line46>** c but in the other case and search the input string for either\n<line47>** c or cx.\n<line48>*/\n<line49>if( c<0x80 ){\n<line50>char zStop[3];\n<line51>int bMatch;\n<line52>if( noCase ){\n<line53>zStop[0] = sqlite3Toupper(c);\n<line54>zStop[1] = sqlite3Tolower(c);\n<line55>zStop[2] = 0;\n<line56>}else{\n<line57>zStop[0] = c;\n<line58>zStop[1] = 0;\n<line59>}\n<line60>while(1){\n<line61>zString += strcspn((const char*)zString, zStop);\n<line62>if( zString[0]==0 ) break;\n<line63>zString++;\n<line64>bMatch = patternCompare(zPattern,zString,pInfo,matchOther);\n<line65>if( bMatch!=SQLITE_NOMATCH ) return bMatch;\n<line66>}\n<line67>}else{\n<line68>int bMatch;\n<line69>while( (c2 = Utf8Read(zString))!=0 ){\n<line70>if( c2!=c ) continue;\n<line71>bMatch = patternCompare(zPattern,zString,pInfo,matchOther);\n<line72>if( bMatch!=SQLITE_NOMATCH ) return bMatch;\n<line73>}\n<line74>}\n<line75>return SQLITE_NOWILDCARDMATCH;\n<line76>}\n<line77>if( c==matchOther ){\n<line78>if( pInfo->matchSet==0 ){\n<line79>c = sqlite3Utf8Read(&zPattern);\n<line80>if( c==0 ) return SQLITE_NOMATCH;\n<line81>zEscaped = zPattern;\n<line82>}else{\n<line83>u32 prior_c = 0;\n<line84>int seen = 0;\n<line85>int invert = 0;\n<line86>c = sqlite3Utf8Read(&zString);\n<line87>if( c==0 ) return SQLITE_NOMATCH;\n<line88>c2 = sqlite3Utf8Read(&zPattern);\n<line89>if( c2=='^' ){\n<line90>invert = 1;\n<line91>c2 = sqlite3Utf8Read(&zPattern);\n<line92>}\n<line93>if( c2==']' ){\n<line94>if( c==']' ) seen = 1;\n<line95>c2 = sqlite3Utf8Read(&zPattern);\n<line96>}\n<line97>while( c2 && c2!=']' ){\n<line98>if( c2=='-' && zPattern[0]!=']' && zPattern[0]!=0 && prior_c>0 ){\n<line99>c2 = sqlite3Utf8Read(&zPattern);\n<line100>if( c>=prior_c && c<=c2 ) seen = 1;\n<line101>prior_c = 0;\n<line102>}else{\n<line103>if( c==c2 ){\n<line104>seen = 1;\n<line105>}\n<line106>prior_c = c2;\n<line107>}\n<line108>c2 = sqlite3Utf8Read(&zPattern);\n<line109>}\n<line110>if( c2==0 || (seen ^ invert)==0 ){\n<line111>return SQLITE_NOMATCH;\n<line112>}\n<line113>continue;\n<line114>}\n<line115>}\n<line116>c2 = Utf8Read(zString);\n<line117>if( c==c2 ) continue;\n<line118>if( noCase  && sqlite3Tolower(c)==sqlite3Tolower(c2) && c<0x80 && c2<0x80 ){\n<line119>continue;\n<line120>}\n<line121>if( c==matchOne && zPattern!=zEscaped && c2!=0 ) continue;\n<line122>return SQLITE_NOMATCH;\n<line123>}\n<line124>return *zString==0 ? SQLITE_MATCH : SQLITE_NOMATCH;\n<line125>}
----------------------------------------
Function: sqlite3_strglob
Content: <line0>SQLITE_API int sqlite3_strglob(const char *zGlobPattern, const char *zString){\n<line1>if( zString==0 ){\n<line2>return zGlobPattern!=0;\n<line3>}else if( zGlobPattern==0 ){\n<line4>return 1;\n<line5>}else {\n<line6>return patternCompare((u8*)zGlobPattern, (u8*)zString, &globInfo, '[');\n<line7>}\n<line8>}
----------------------------------------
Function: sqlite3_strlike
Content: <line0>SQLITE_API int sqlite3_strlike(const char *zPattern, const char *zStr, unsigned int esc){\n<line1>if( zStr==0 ){\n<line2>return zPattern!=0;\n<line3>}else if( zPattern==0 ){\n<line4>return 1;\n<line5>}else{\n<line6>return patternCompare((u8*)zPattern, (u8*)zStr, &likeInfoNorm, esc);\n<line7>}\n<line8>}
----------------------------------------
Function: likeFunc
Content: <line0>static void likeFunc(\n<line1>sqlite3_context *context,\n<line2>int argc,\n<line3>sqlite3_value **argv\n<line4>){\n<line5>const unsigned char *zA, *zB;\n<line6>u32 escape;\n<line7>int nPat;\n<line8>sqlite3 *db = sqlite3_context_db_handle(context);\n<line9>struct compareInfo *pInfo = sqlite3_user_data(context);\n<line10>struct compareInfo backupInfo;\n<line11>#ifdef SQLITE_LIKE_DOESNT_MATCH_BLOBS\n<line12>if( sqlite3_value_type(argv[0])==SQLITE_BLOB\n<line13>|| sqlite3_value_type(argv[1])==SQLITE_BLOB\n<line14>){\n<line15>#ifdef SQLITE_TEST\n<line16>sqlite3_like_count++;\n<line17>#endif\n<line18>sqlite3_result_int(context, 0);\n<line19>return;\n<line20>}\n<line21>#endif\n<line22>/* Limit the length of the LIKE or GLOB pattern to avoid problems\n<line23>** of deep recursion and N*N behavior in patternCompare().\n<line24>*/\n<line25>nPat = sqlite3_value_bytes(argv[0]);\n<line26>testcase( nPat==db->aLimit[SQLITE_LIMIT_LIKE_PATTERN_LENGTH] );\n<line27>testcase( nPat==db->aLimit[SQLITE_LIMIT_LIKE_PATTERN_LENGTH]+1 );\n<line28>if( nPat > db->aLimit[SQLITE_LIMIT_LIKE_PATTERN_LENGTH] ){\n<line29>sqlite3_result_error(context, "LIKE or GLOB pattern too complex", -1);\n<line30>return;\n<line31>}\n<line32>if( argc==3 ){\n<line33>/* The escape character string must consist of a single UTF-8 character.\n<line34>** Otherwise, return an error.\n<line35>*/\n<line36>const unsigned char *zEsc = sqlite3_value_text(argv[2]);\n<line37>if( zEsc==0 ) return;\n<line38>if( sqlite3Utf8CharLen((char*)zEsc, -1)!=1 ){\n<line39>sqlite3_result_error(context,\n<line40>"ESCAPE expression must be a single character", -1);\n<line41>return;\n<line42>}\n<line43>escape = sqlite3Utf8Read(&zEsc);\n<line44>if( escape==pInfo->matchAll || escape==pInfo->matchOne ){\n<line45>memcpy(&backupInfo, pInfo, sizeof(backupInfo));\n<line46>pInfo = &backupInfo;\n<line47>if( escape==pInfo->matchAll ) pInfo->matchAll = 0;\n<line48>if( escape==pInfo->matchOne ) pInfo->matchOne = 0;\n<line49>}\n<line50>}else{\n<line51>escape = pInfo->matchSet;\n<line52>}\n<line53>zB = sqlite3_value_text(argv[0]);\n<line54>zA = sqlite3_value_text(argv[1]);\n<line55>if( zA && zB ){\n<line56>#ifdef SQLITE_TEST\n<line57>sqlite3_like_count++;\n<line58>#endif\n<line59>sqlite3_result_int(context,\n<line60>patternCompare(zB, zA, pInfo, escape)==SQLITE_MATCH);\n<line61>}\n<line62>}
----------------------------------------
Function: nullifFunc
Content: <line0>static void nullifFunc(\n<line1>sqlite3_context *context,\n<line2>int NotUsed,\n<line3>sqlite3_value **argv\n<line4>){\n<line5>CollSeq *pColl = sqlite3GetFuncCollSeq(context);\n<line6>UNUSED_PARAMETER(NotUsed);\n<line7>if( sqlite3MemCompare(argv[0], argv[1], pColl)!=0 ){\n<line8>sqlite3_result_value(context, argv[0]);\n<line9>}\n<line10>}
----------------------------------------
Function: versionFunc
Content: <line0>static void versionFunc(\n<line1>sqlite3_context *context,\n<line2>int NotUsed,\n<line3>sqlite3_value **NotUsed2\n<line4>){\n<line5>UNUSED_PARAMETER2(NotUsed, NotUsed2);\n<line6>/* IMP: R-48699-48617 This function is an SQL wrapper around the\n<line7>** sqlite3_libversion() C-interface. */\n<line8>sqlite3_result_text(context, sqlite3_libversion(), -1, SQLITE_STATIC);\n<line9>}
----------------------------------------
Function: sourceidFunc
Content: <line0>static void sourceidFunc(\n<line1>sqlite3_context *context,\n<line2>int NotUsed,\n<line3>sqlite3_value **NotUsed2\n<line4>){\n<line5>UNUSED_PARAMETER2(NotUsed, NotUsed2);\n<line6>/* IMP: R-24470-31136 This function is an SQL wrapper around the\n<line7>** sqlite3_sourceid() C interface. */\n<line8>sqlite3_result_text(context, sqlite3_sourceid(), -1, SQLITE_STATIC);\n<line9>}
----------------------------------------
Function: errlogFunc
Content: <line0>static void errlogFunc(\n<line1>sqlite3_context *context,\n<line2>int argc,\n<line3>sqlite3_value **argv\n<line4>){\n<line5>UNUSED_PARAMETER(argc);\n<line6>UNUSED_PARAMETER(context);\n<line7>sqlite3_log(sqlite3_value_int(argv[0]), "%s", sqlite3_value_text(argv[1]));\n<line8>}
----------------------------------------
Function: compileoptionusedFunc
Content: <line0>static void compileoptionusedFunc(\n<line1>sqlite3_context *context,\n<line2>int argc,\n<line3>sqlite3_value **argv\n<line4>){\n<line5>const char *zOptName;\n<line6>assert( argc==1 );\n<line7>UNUSED_PARAMETER(argc);\n<line8>/* IMP: R-39564-36305 The sqlite_compileoption_used() SQL\n<line9>** function is a wrapper around the sqlite3_compileoption_used() C/C++\n<line10>** function.\n<line11>*/\n<line12>if( (zOptName = (const char*)sqlite3_value_text(argv[0]))!=0 ){\n<line13>sqlite3_result_int(context, sqlite3_compileoption_used(zOptName));\n<line14>}\n<line15>}
----------------------------------------
Function: compileoptiongetFunc
Content: <line0>static void compileoptiongetFunc(\n<line1>sqlite3_context *context,\n<line2>int argc,\n<line3>sqlite3_value **argv\n<line4>){\n<line5>int n;\n<line6>assert( argc==1 );\n<line7>UNUSED_PARAMETER(argc);\n<line8>/* IMP: R-04922-24076 The sqlite_compileoption_get() SQL function\n<line9>** is a wrapper around the sqlite3_compileoption_get() C/C++ function.\n<line10>*/\n<line11>n = sqlite3_value_int(argv[0]);\n<line12>sqlite3_result_text(context, sqlite3_compileoption_get(n), -1, SQLITE_STATIC);\n<line13>}
----------------------------------------
Function: isNHex
Content: <line0>static int isNHex(const char *z, int N, u32 *pVal){\n<line1>int i;\n<line2>u32 v = 0;\n<line3>for(i=0; i<N; i++){\n<line4>if( !sqlite3Isxdigit(z[i]) ) return 0;\n<line5>v = (v<<4) + sqlite3HexToInt(z[i]);\n<line6>}\n<line7>*pVal = v;\n<line8>return 1;\n<line9>}
----------------------------------------
Function: unistrFunc
Content: <line0>static void unistrFunc(\n<line1>sqlite3_context *context,\n<line2>int argc,\n<line3>sqlite3_value **argv\n<line4>){\n<line5>char *zOut;\n<line6>const char *zIn;\n<line7>int nIn;\n<line8>int i, j, n;\n<line9>u32 v;\n<line10>assert( argc==1 );\n<line11>UNUSED_PARAMETER( argc );\n<line12>zIn = (const char*)sqlite3_value_text(argv[0]);\n<line13>if( zIn==0 ) return;\n<line14>nIn = sqlite3_value_bytes(argv[0]);\n<line15>zOut = sqlite3_malloc64(nIn+1);\n<line16>if( zOut==0 ){\n<line17>sqlite3_result_error_nomem(context);\n<line18>return;\n<line19>}\n<line20>i = j = 0;\n<line21>while( i<nIn ){\n<line22>char *z = strchr(&zIn[i],'\\');\n<line23>if( z==0 ){\n<line24>n = nIn - i;\n<line25>memmove(&zOut[j], &zIn[i], n);\n<line26>j += n;\n<line27>break;\n<line28>}\n<line29>n = z - &zIn[i];\n<line30>if( n>0 ){\n<line31>memmove(&zOut[j], &zIn[i], n);\n<line32>j += n;\n<line33>i += n;\n<line34>}\n<line35>if( zIn[i+1]=='\\' ){\n<line36>i += 2;\n<line37>zOut[j++] = '\\';\n<line38>}else if( sqlite3Isxdigit(zIn[i+1]) ){\n<line39>if( !isNHex(&zIn[i+1], 4, &v) ) goto unistr_error;\n<line40>i += 5;\n<line41>j += sqlite3AppendOneUtf8Character(&zOut[j], v);\n<line42>}else if( zIn[i+1]=='+' ){\n<line43>if( !isNHex(&zIn[i+2], 6, &v) ) goto unistr_error;\n<line44>i += 8;\n<line45>j += sqlite3AppendOneUtf8Character(&zOut[j], v);\n<line46>}else if( zIn[i+1]=='u' ){\n<line47>if( !isNHex(&zIn[i+2], 4, &v) ) goto unistr_error;\n<line48>i += 6;\n<line49>j += sqlite3AppendOneUtf8Character(&zOut[j], v);\n<line50>}else if( zIn[i+1]=='U' ){\n<line51>if( !isNHex(&zIn[i+2], 8, &v) ) goto unistr_error;\n<line52>i += 10;\n<line53>j += sqlite3AppendOneUtf8Character(&zOut[j], v);\n<line54>}else{\n<line55>goto unistr_error;\n<line56>}\n<line57>}\n<line58>zOut[j] = 0;\n<line59>sqlite3_result_text64(context, zOut, j, sqlite3_free, SQLITE_UTF8);\n<line60>return;\n<line61>unistr_error:\n<line62>sqlite3_free(zOut);\n<line63>sqlite3_result_error(context, "invalid Unicode escape", -1);\n<line64>return;\n<line65>}
----------------------------------------
Function: quoteFunc
Content: <line0>static void quoteFunc(sqlite3_context *context, int argc, sqlite3_value **argv){\n<line1>sqlite3_str str;\n<line2>sqlite3 *db = sqlite3_context_db_handle(context);\n<line3>assert( argc==1 );\n<line4>UNUSED_PARAMETER(argc);\n<line5>sqlite3StrAccumInit(&str, db, 0, 0, db->aLimit[SQLITE_LIMIT_LENGTH]);\n<line6>sqlite3QuoteValue(&str,argv[0],SQLITE_PTR_TO_INT(sqlite3_user_data(context)));\n<line7>sqlite3_result_text(context, sqlite3StrAccumFinish(&str), str.nChar,\n<line8>SQLITE_DYNAMIC);\n<line9>if( str.accError!=SQLITE_OK ){\n<line10>sqlite3_result_null(context);\n<line11>sqlite3_result_error_code(context, str.accError);\n<line12>}\n<line13>}
----------------------------------------
Function: unicodeFunc
Content: <line0>static void unicodeFunc(\n<line1>sqlite3_context *context,\n<line2>int argc,\n<line3>sqlite3_value **argv\n<line4>){\n<line5>const unsigned char *z = sqlite3_value_text(argv[0]);\n<line6>(void)argc;\n<line7>if( z && z[0] ) sqlite3_result_int(context, sqlite3Utf8Read(&z));\n<line8>}
----------------------------------------
Function: charFunc
Content: <line0>static void charFunc(\n<line1>sqlite3_context *context,\n<line2>int argc,\n<line3>sqlite3_value **argv\n<line4>){\n<line5>unsigned char *z, *zOut;\n<line6>int i;\n<line7>zOut = z = sqlite3_malloc64( argc*4+1 );\n<line8>if( z==0 ){\n<line9>sqlite3_result_error_nomem(context);\n<line10>return;\n<line11>}\n<line12>for(i=0; i<argc; i++){\n<line13>sqlite3_int64 x;\n<line14>unsigned c;\n<line15>x = sqlite3_value_int64(argv[i]);\n<line16>if( x<0 || x>0x10ffff ) x = 0xfffd;\n<line17>c = (unsigned)(x & 0x1fffff);\n<line18>if( c<0x00080 ){\n<line19>*zOut++ = (u8)(c&0xFF);\n<line20>}else if( c<0x00800 ){\n<line21>*zOut++ = 0xC0 + (u8)((c>>6)&0x1F);\n<line22>*zOut++ = 0x80 + (u8)(c & 0x3F);\n<line23>}else if( c<0x10000 ){\n<line24>*zOut++ = 0xE0 + (u8)((c>>12)&0x0F);\n<line25>*zOut++ = 0x80 + (u8)((c>>6) & 0x3F);\n<line26>*zOut++ = 0x80 + (u8)(c & 0x3F);\n<line27>}else{\n<line28>*zOut++ = 0xF0 + (u8)((c>>18) & 0x07);\n<line29>*zOut++ = 0x80 + (u8)((c>>12) & 0x3F);\n<line30>*zOut++ = 0x80 + (u8)((c>>6) & 0x3F);\n<line31>*zOut++ = 0x80 + (u8)(c & 0x3F);\n<line32>}                                                    \\n<line33>}\n<line34>*zOut = 0;\n<line35>sqlite3_result_text64(context, (char*)z, zOut-z, sqlite3_free, SQLITE_UTF8);\n<line36>}
----------------------------------------
Function: hexFunc
Content: <line0>static void hexFunc(\n<line1>sqlite3_context *context,\n<line2>int argc,\n<line3>sqlite3_value **argv\n<line4>){\n<line5>int i, n;\n<line6>const unsigned char *pBlob;\n<line7>char *zHex, *z;\n<line8>assert( argc==1 );\n<line9>UNUSED_PARAMETER(argc);\n<line10>pBlob = sqlite3_value_blob(argv[0]);\n<line11>n = sqlite3_value_bytes(argv[0]);\n<line12>assert( pBlob==sqlite3_value_blob(argv[0]) );  /* No encoding change */\n<line13>z = zHex = contextMalloc(context, ((i64)n)*2 + 1);\n<line14>if( zHex ){\n<line15>for(i=0; i<n; i++, pBlob++){\n<line16>unsigned char c = *pBlob;\n<line17>*(z++) = hexdigits[(c>>4)&0xf];\n<line18>*(z++) = hexdigits[c&0xf];\n<line19>}\n<line20>*z = 0;\n<line21>sqlite3_result_text64(context, zHex, (u64)(z-zHex),\n<line22>sqlite3_free, SQLITE_UTF8);\n<line23>}\n<line24>}
----------------------------------------
Function: strContainsChar
Content: <line0>static int strContainsChar(const u8 *zStr, int nStr, u32 ch){\n<line1>const u8 *zEnd = &zStr[nStr];\n<line2>const u8 *z = zStr;\n<line3>while( z<zEnd ){\n<line4>u32 tst = Utf8Read(z);\n<line5>if( tst==ch ) return 1;\n<line6>}\n<line7>return 0;\n<line8>}
----------------------------------------
Function: unhexFunc
Content: <line0>static void unhexFunc(\n<line1>sqlite3_context *pCtx,\n<line2>int argc,\n<line3>sqlite3_value **argv\n<line4>){\n<line5>const u8 *zPass = (const u8*)"";\n<line6>int nPass = 0;\n<line7>const u8 *zHex = sqlite3_value_text(argv[0]);\n<line8>int nHex = sqlite3_value_bytes(argv[0]);\n<line9>#ifdef SQLITE_DEBUG\n<line10>const u8 *zEnd = zHex ? &zHex[nHex] : 0;\n<line11>#endif\n<line12>u8 *pBlob = 0;\n<line13>u8 *p = 0;\n<line14>assert( argc==1 || argc==2 );\n<line15>if( argc==2 ){\n<line16>zPass = sqlite3_value_text(argv[1]);\n<line17>nPass = sqlite3_value_bytes(argv[1]);\n<line18>}\n<line19>if( !zHex || !zPass ) return;\n<line20>p = pBlob = contextMalloc(pCtx, (nHex/2)+1);\n<line21>if( pBlob ){\n<line22>u8 c;                         /* Most significant digit of next byte */\n<line23>u8 d;                         /* Least significant digit of next byte */\n<line24>while( (c = *zHex)!=0x00 ){\n<line25>while( !sqlite3Isxdigit(c) ){\n<line26>u32 ch = Utf8Read(zHex);\n<line27>assert( zHex<=zEnd );\n<line28>if( !strContainsChar(zPass, nPass, ch) ) goto unhex_null;\n<line29>c = *zHex;\n<line30>if( c==0x00 ) goto unhex_done;\n<line31>}\n<line32>zHex++;\n<line33>assert( *zEnd==0x00 );\n<line34>assert( zHex<=zEnd );\n<line35>d = *(zHex++);\n<line36>if( !sqlite3Isxdigit(d) ) goto unhex_null;\n<line37>*(p++) = (sqlite3HexToInt(c)<<4) | sqlite3HexToInt(d);\n<line38>}\n<line39>}\n<line40>unhex_done:\n<line41>sqlite3_result_blob(pCtx, pBlob, (p - pBlob), sqlite3_free);\n<line42>return;\n<line43>unhex_null:\n<line44>sqlite3_free(pBlob);\n<line45>return;\n<line46>}
----------------------------------------
Function: zeroblobFunc
Content: <line0>static void zeroblobFunc(\n<line1>sqlite3_context *context,\n<line2>int argc,\n<line3>sqlite3_value **argv\n<line4>){\n<line5>i64 n;\n<line6>int rc;\n<line7>assert( argc==1 );\n<line8>UNUSED_PARAMETER(argc);\n<line9>n = sqlite3_value_int64(argv[0]);\n<line10>if( n<0 ) n = 0;\n<line11>rc = sqlite3_result_zeroblob64(context, n); /* IMP: R-00293-64994 */\n<line12>if( rc ){\n<line13>sqlite3_result_error_code(context, rc);\n<line14>}\n<line15>}
----------------------------------------
Function: replaceFunc
Content: <line0>static void replaceFunc(\n<line1>sqlite3_context *context,\n<line2>int argc,\n<line3>sqlite3_value **argv\n<line4>){\n<line5>const unsigned char *zStr;        /* The input string A */\n<line6>const unsigned char *zPattern;    /* The pattern string B */\n<line7>const unsigned char *zRep;        /* The replacement string C */\n<line8>unsigned char *zOut;              /* The output */\n<line9>int nStr;                /* Size of zStr */\n<line10>int nPattern;            /* Size of zPattern */\n<line11>int nRep;                /* Size of zRep */\n<line12>i64 nOut;                /* Maximum size of zOut */\n<line13>int loopLimit;           /* Last zStr[] that might match zPattern[] */\n<line14>int i, j;                /* Loop counters */\n<line15>unsigned cntExpand;      /* Number zOut expansions */\n<line16>sqlite3 *db = sqlite3_context_db_handle(context);\n<line17>assert( argc==3 );\n<line18>UNUSED_PARAMETER(argc);\n<line19>zStr = sqlite3_value_text(argv[0]);\n<line20>if( zStr==0 ) return;\n<line21>nStr = sqlite3_value_bytes(argv[0]);\n<line22>assert( zStr==sqlite3_value_text(argv[0]) );  /* No encoding change */\n<line23>zPattern = sqlite3_value_text(argv[1]);\n<line24>if( zPattern==0 ){\n<line25>assert( sqlite3_value_type(argv[1])==SQLITE_NULL\n<line26>|| sqlite3_context_db_handle(context)->mallocFailed );\n<line27>return;\n<line28>}\n<line29>if( zPattern[0]==0 ){\n<line30>assert( sqlite3_value_type(argv[1])!=SQLITE_NULL );\n<line31>sqlite3_result_text(context, (const char*)zStr, nStr, SQLITE_TRANSIENT);\n<line32>return;\n<line33>}\n<line34>nPattern = sqlite3_value_bytes(argv[1]);\n<line35>assert( zPattern==sqlite3_value_text(argv[1]) );  /* No encoding change */\n<line36>zRep = sqlite3_value_text(argv[2]);\n<line37>if( zRep==0 ) return;\n<line38>nRep = sqlite3_value_bytes(argv[2]);\n<line39>assert( zRep==sqlite3_value_text(argv[2]) );\n<line40>nOut = nStr + 1;\n<line41>assert( nOut<SQLITE_MAX_LENGTH );\n<line42>zOut = contextMalloc(context, nOut);\n<line43>if( zOut==0 ){\n<line44>return;\n<line45>}\n<line46>loopLimit = nStr - nPattern;\n<line47>cntExpand = 0;\n<line48>for(i=j=0; i<=loopLimit; i++){\n<line49>if( zStr[i]!=zPattern[0] || memcmp(&zStr[i], zPattern, nPattern) ){\n<line50>zOut[j++] = zStr[i];\n<line51>}else{\n<line52>if( nRep>nPattern ){\n<line53>nOut += nRep - nPattern;\n<line54>testcase( nOut-1==db->aLimit[SQLITE_LIMIT_LENGTH] );\n<line55>testcase( nOut-2==db->aLimit[SQLITE_LIMIT_LENGTH] );\n<line56>if( nOut-1>db->aLimit[SQLITE_LIMIT_LENGTH] ){\n<line57>sqlite3_result_error_toobig(context);\n<line58>sqlite3_free(zOut);\n<line59>return;\n<line60>}\n<line61>cntExpand++;\n<line62>if( (cntExpand&(cntExpand-1))==0 ){\n<line63>/* Grow the size of the output buffer only on substitutions\n<line64>** whose index is a power of two: 1, 2, 4, 8, 16, 32, ... */\n<line65>u8 *zOld;\n<line66>zOld = zOut;\n<line67>zOut = sqlite3Realloc(zOut, (int)nOut + (nOut - nStr - 1));\n<line68>if( zOut==0 ){\n<line69>sqlite3_result_error_nomem(context);\n<line70>sqlite3_free(zOld);\n<line71>return;\n<line72>}\n<line73>}\n<line74>}\n<line75>memcpy(&zOut[j], zRep, nRep);\n<line76>j += nRep;\n<line77>i += nPattern-1;\n<line78>}\n<line79>}\n<line80>assert( j+nStr-i+1<=nOut );\n<line81>memcpy(&zOut[j], &zStr[i], nStr-i);\n<line82>j += nStr - i;\n<line83>assert( j<=nOut );\n<line84>zOut[j] = 0;\n<line85>sqlite3_result_text(context, (char*)zOut, j, sqlite3_free);\n<line86>}
----------------------------------------
Function: trimFunc
Content: <line0>static void trimFunc(\n<line1>sqlite3_context *context,\n<line2>int argc,\n<line3>sqlite3_value **argv\n<line4>){\n<line5>const unsigned char *zIn;         /* Input string */\n<line6>const unsigned char *zCharSet;    /* Set of characters to trim */\n<line7>unsigned int nIn;                 /* Number of bytes in input */\n<line8>int flags;                        /* 1: trimleft  2: trimright  3: trim */\n<line9>int i;                            /* Loop counter */\n<line10>unsigned int *aLen = 0;           /* Length of each character in zCharSet */\n<line11>unsigned char **azChar = 0;       /* Individual characters in zCharSet */\n<line12>int nChar;                        /* Number of characters in zCharSet */\n<line13>if( sqlite3_value_type(argv[0])==SQLITE_NULL ){\n<line14>return;\n<line15>}\n<line16>zIn = sqlite3_value_text(argv[0]);\n<line17>if( zIn==0 ) return;\n<line18>nIn = (unsigned)sqlite3_value_bytes(argv[0]);\n<line19>assert( zIn==sqlite3_value_text(argv[0]) );\n<line20>if( argc==1 ){\n<line21>static const unsigned lenOne[] = { 1 };\n<line22>static unsigned char * const azOne[] = { (u8*)" " };\n<line23>nChar = 1;\n<line24>aLen = (unsigned*)lenOne;\n<line25>azChar = (unsigned char **)azOne;\n<line26>zCharSet = 0;\n<line27>}else if( (zCharSet = sqlite3_value_text(argv[1]))==0 ){\n<line28>return;\n<line29>}else{\n<line30>const unsigned char *z;\n<line31>for(z=zCharSet, nChar=0; *z; nChar++){\n<line32>SQLITE_SKIP_UTF8(z);\n<line33>}\n<line34>if( nChar>0 ){\n<line35>azChar = contextMalloc(context,\n<line36>((i64)nChar)*(sizeof(char*)+sizeof(unsigned)));\n<line37>if( azChar==0 ){\n<line38>return;\n<line39>}\n<line40>aLen = (unsigned*)&azChar[nChar];\n<line41>for(z=zCharSet, nChar=0; *z; nChar++){\n<line42>azChar[nChar] = (unsigned char *)z;\n<line43>SQLITE_SKIP_UTF8(z);\n<line44>aLen[nChar] = (unsigned)(z - azChar[nChar]);\n<line45>}\n<line46>}\n<line47>}\n<line48>if( nChar>0 ){\n<line49>flags = SQLITE_PTR_TO_INT(sqlite3_user_data(context));\n<line50>if( flags & 1 ){\n<line51>while( nIn>0 ){\n<line52>unsigned int len = 0;\n<line53>for(i=0; i<nChar; i++){\n<line54>len = aLen[i];\n<line55>if( len<=nIn && memcmp(zIn, azChar[i], len)==0 ) break;\n<line56>}\n<line57>if( i>=nChar ) break;\n<line58>zIn += len;\n<line59>nIn -= len;\n<line60>}\n<line61>}\n<line62>if( flags & 2 ){\n<line63>while( nIn>0 ){\n<line64>unsigned int len = 0;\n<line65>for(i=0; i<nChar; i++){\n<line66>len = aLen[i];\n<line67>if( len<=nIn && memcmp(&zIn[nIn-len],azChar[i],len)==0 ) break;\n<line68>}\n<line69>if( i>=nChar ) break;\n<line70>nIn -= len;\n<line71>}\n<line72>}\n<line73>if( zCharSet ){\n<line74>sqlite3_free(azChar);\n<line75>}\n<line76>}\n<line77>sqlite3_result_text(context, (char*)zIn, nIn, SQLITE_TRANSIENT);\n<line78>}
----------------------------------------
Function: concatFuncCore
Content: <line0>static void concatFuncCore(\n<line1>sqlite3_context *context,\n<line2>int argc,\n<line3>sqlite3_value **argv,\n<line4>int nSep,\n<line5>const char *zSep\n<line6>){\n<line7>i64 j, n = 0;\n<line8>int i;\n<line9>int bNotNull = 0;   /* True after at least NOT NULL argument seen */\n<line10>char *z;\n<line11>for(i=0; i<argc; i++){\n<line12>n += sqlite3_value_bytes(argv[i]);\n<line13>}\n<line14>n += (argc-1)*(i64)nSep;\n<line15>z = sqlite3_malloc64(n+1);\n<line16>if( z==0 ){\n<line17>sqlite3_result_error_nomem(context);\n<line18>return;\n<line19>}\n<line20>j = 0;\n<line21>for(i=0; i<argc; i++){\n<line22>if( sqlite3_value_type(argv[i])!=SQLITE_NULL ){\n<line23>int k = sqlite3_value_bytes(argv[i]);\n<line24>const char *v = (const char*)sqlite3_value_text(argv[i]);\n<line25>if( v!=0 ){\n<line26>if( bNotNull && nSep>0 ){\n<line27>memcpy(&z[j], zSep, nSep);\n<line28>j += nSep;\n<line29>}\n<line30>memcpy(&z[j], v, k);\n<line31>j += k;\n<line32>bNotNull = 1;\n<line33>}\n<line34>}\n<line35>}\n<line36>z[j] = 0;\n<line37>assert( j<=n );\n<line38>sqlite3_result_text64(context, z, j, sqlite3_free, SQLITE_UTF8);\n<line39>}
----------------------------------------
Function: concatFunc
Content: <line0>static void concatFunc(\n<line1>sqlite3_context *context,\n<line2>int argc,\n<line3>sqlite3_value **argv\n<line4>){\n<line5>concatFuncCore(context, argc, argv, 0, "");\n<line6>}
----------------------------------------
Function: concatwsFunc
Content: <line0>static void concatwsFunc(\n<line1>sqlite3_context *context,\n<line2>int argc,\n<line3>sqlite3_value **argv\n<line4>){\n<line5>int nSep = sqlite3_value_bytes(argv[0]);\n<line6>const char *zSep = (const char*)sqlite3_value_text(argv[0]);\n<line7>if( zSep==0 ) return;\n<line8>concatFuncCore(context, argc-1, argv+1, nSep, zSep);\n<line9>}
----------------------------------------
Function: loadExt
Content: <line0>static void loadExt(sqlite3_context *context, int argc, sqlite3_value **argv){\n<line1>const char *zFile = (const char *)sqlite3_value_text(argv[0]);\n<line2>const char *zProc;\n<line3>sqlite3 *db = sqlite3_context_db_handle(context);\n<line4>char *zErrMsg = 0;\n<line5>/* Disallow the load_extension() SQL function unless the SQLITE_LoadExtFunc\n<line6>** flag is set.  See the sqlite3_enable_load_extension() API.\n<line7>*/\n<line8>if( (db->flags & SQLITE_LoadExtFunc)==0 ){\n<line9>sqlite3_result_error(context, "not authorized", -1);\n<line10>return;\n<line11>}\n<line12>if( argc==2 ){\n<line13>zProc = (const char *)sqlite3_value_text(argv[1]);\n<line14>}else{\n<line15>zProc = 0;\n<line16>}\n<line17>if( zFile && sqlite3_load_extension(db, zFile, zProc, &zErrMsg) ){\n<line18>sqlite3_result_error(context, zErrMsg, -1);\n<line19>sqlite3_free(zErrMsg);\n<line20>}\n<line21>}
----------------------------------------
Function: kahanBabuskaNeumaierStep
Content: <line0>static void kahanBabuskaNeumaierStep(\n<line1>volatile SumCtx *pSum,\n<line2>volatile double r\n<line3>){\n<line4>volatile double s = pSum->rSum;\n<line5>volatile double t = s + r;\n<line6>if( fabs(s) > fabs(r) ){\n<line7>pSum->rErr += (s - t) + r;\n<line8>}else{\n<line9>pSum->rErr += (r - t) + s;\n<line10>}\n<line11>pSum->rSum = t;\n<line12>}
----------------------------------------
Function: kahanBabuskaNeumaierStepInt64
Content: <line0>static void kahanBabuskaNeumaierStepInt64(volatile SumCtx *pSum, i64 iVal){\n<line1>if( iVal<=-4503599627370496LL || iVal>=+4503599627370496LL ){\n<line2>i64 iBig, iSm;\n<line3>iSm = iVal % 16384;\n<line4>iBig = iVal - iSm;\n<line5>kahanBabuskaNeumaierStep(pSum, iBig);\n<line6>kahanBabuskaNeumaierStep(pSum, iSm);\n<line7>}else{\n<line8>kahanBabuskaNeumaierStep(pSum, (double)iVal);\n<line9>}\n<line10>}
----------------------------------------
Function: kahanBabuskaNeumaierInit
Content: <line0>static void kahanBabuskaNeumaierInit(\n<line1>volatile SumCtx *p,\n<line2>i64 iVal\n<line3>){\n<line4>if( iVal<=-4503599627370496LL || iVal>=+4503599627370496LL ){\n<line5>i64 iSm = iVal % 16384;\n<line6>p->rSum = (double)(iVal - iSm);\n<line7>p->rErr = (double)iSm;\n<line8>}else{\n<line9>p->rSum = (double)iVal;\n<line10>p->rErr = 0.0;\n<line11>}\n<line12>}
----------------------------------------
Function: sumStep
Content: <line0>static void sumStep(sqlite3_context *context, int argc, sqlite3_value **argv){\n<line1>SumCtx *p;\n<line2>int type;\n<line3>assert( argc==1 );\n<line4>UNUSED_PARAMETER(argc);\n<line5>p = sqlite3_aggregate_context(context, sizeof(*p));\n<line6>type = sqlite3_value_numeric_type(argv[0]);\n<line7>if( p && type!=SQLITE_NULL ){\n<line8>p->cnt++;\n<line9>if( p->approx==0 ){\n<line10>if( type!=SQLITE_INTEGER ){\n<line11>kahanBabuskaNeumaierInit(p, p->iSum);\n<line12>p->approx = 1;\n<line13>kahanBabuskaNeumaierStep(p, sqlite3_value_double(argv[0]));\n<line14>}else{\n<line15>i64 x = p->iSum;\n<line16>if( sqlite3AddInt64(&x, sqlite3_value_int64(argv[0]))==0 ){\n<line17>p->iSum = x;\n<line18>}else{\n<line19>p->ovrfl = 1;\n<line20>kahanBabuskaNeumaierInit(p, p->iSum);\n<line21>p->approx = 1;\n<line22>kahanBabuskaNeumaierStepInt64(p, sqlite3_value_int64(argv[0]));\n<line23>}\n<line24>}\n<line25>}else{\n<line26>if( type==SQLITE_INTEGER ){\n<line27>kahanBabuskaNeumaierStepInt64(p, sqlite3_value_int64(argv[0]));\n<line28>}else{\n<line29>p->ovrfl = 0;\n<line30>kahanBabuskaNeumaierStep(p, sqlite3_value_double(argv[0]));\n<line31>}\n<line32>}\n<line33>}\n<line34>}
----------------------------------------
Function: sumInverse
Content: <line0>static void sumInverse(sqlite3_context *context, int argc, sqlite3_value**argv){\n<line1>SumCtx *p;\n<line2>int type;\n<line3>assert( argc==1 );\n<line4>UNUSED_PARAMETER(argc);\n<line5>p = sqlite3_aggregate_context(context, sizeof(*p));\n<line6>type = sqlite3_value_numeric_type(argv[0]);\n<line7>/* p is always non-NULL because sumStep() will have been called first\n<line8>** to initialize it */\n<line9>if( ALWAYS(p) && type!=SQLITE_NULL ){\n<line10>assert( p->cnt>0 );\n<line11>p->cnt--;\n<line12>if( !p->approx ){\n<line13>if( sqlite3SubInt64(&p->iSum, sqlite3_value_int64(argv[0])) ){\n<line14>p->ovrfl = 1;\n<line15>p->approx = 1;\n<line16>}\n<line17>}else if( type==SQLITE_INTEGER ){\n<line18>i64 iVal = sqlite3_value_int64(argv[0]);\n<line19>if( iVal!=SMALLEST_INT64 ){\n<line20>kahanBabuskaNeumaierStepInt64(p, -iVal);\n<line21>}else{\n<line22>kahanBabuskaNeumaierStepInt64(p, LARGEST_INT64);\n<line23>kahanBabuskaNeumaierStepInt64(p, 1);\n<line24>}\n<line25>}else{\n<line26>kahanBabuskaNeumaierStep(p, -sqlite3_value_double(argv[0]));\n<line27>}\n<line28>}\n<line29>}
----------------------------------------
Function: sumFinalize
Content: <line0>static void sumFinalize(sqlite3_context *context){\n<line1>SumCtx *p;\n<line2>p = sqlite3_aggregate_context(context, 0);\n<line3>if( p && p->cnt>0 ){\n<line4>if( p->approx ){\n<line5>if( p->ovrfl ){\n<line6>sqlite3_result_error(context,"integer overflow",-1);\n<line7>}else if( !sqlite3IsOverflow(p->rErr) ){\n<line8>sqlite3_result_double(context, p->rSum+p->rErr);\n<line9>}else{\n<line10>sqlite3_result_double(context, p->rSum);\n<line11>}\n<line12>}else{\n<line13>sqlite3_result_int64(context, p->iSum);\n<line14>}\n<line15>}\n<line16>}
----------------------------------------
Function: avgFinalize
Content: <line0>static void avgFinalize(sqlite3_context *context){\n<line1>SumCtx *p;\n<line2>p = sqlite3_aggregate_context(context, 0);\n<line3>if( p && p->cnt>0 ){\n<line4>double r;\n<line5>if( p->approx ){\n<line6>r = p->rSum;\n<line7>if( !sqlite3IsOverflow(p->rErr) ) r += p->rErr;\n<line8>}else{\n<line9>r = (double)(p->iSum);\n<line10>}\n<line11>sqlite3_result_double(context, r/(double)p->cnt);\n<line12>}\n<line13>}
----------------------------------------
Function: totalFinalize
Content: <line0>static void totalFinalize(sqlite3_context *context){\n<line1>SumCtx *p;\n<line2>double r = 0.0;\n<line3>p = sqlite3_aggregate_context(context, 0);\n<line4>if( p ){\n<line5>if( p->approx ){\n<line6>r = p->rSum;\n<line7>if( !sqlite3IsOverflow(p->rErr) ) r += p->rErr;\n<line8>}else{\n<line9>r = (double)(p->iSum);\n<line10>}\n<line11>}\n<line12>sqlite3_result_double(context, r);\n<line13>}
----------------------------------------
Function: countStep
Content: <line0>static void countStep(sqlite3_context *context, int argc, sqlite3_value **argv){\n<line1>CountCtx *p;\n<line2>p = sqlite3_aggregate_context(context, sizeof(*p));\n<line3>if( (argc==0 || SQLITE_NULL!=sqlite3_value_type(argv[0])) && p ){\n<line4>p->n++;\n<line5>}\n<line6>#ifndef SQLITE_OMIT_DEPRECATED\n<line7>/* The sqlite3_aggregate_count() function is deprecated.  But just to make\n<line8>** sure it still operates correctly, verify that its count agrees with our\n<line9>** internal count when using count(*) and when the total count can be\n<line10>** expressed as a 32-bit integer. */\n<line11>assert( argc==1 || p==0 || p->n>0x7fffffff || p->bInverse\n<line12>|| p->n==sqlite3_aggregate_count(context) );\n<line13>#endif\n<line14>}
----------------------------------------
Function: countFinalize
Content: <line0>static void countFinalize(sqlite3_context *context){\n<line1>CountCtx *p;\n<line2>p = sqlite3_aggregate_context(context, 0);\n<line3>sqlite3_result_int64(context, p ? p->n : 0);\n<line4>}
----------------------------------------
Function: countInverse
Content: <line0>static void countInverse(sqlite3_context *ctx, int argc, sqlite3_value **argv){\n<line1>CountCtx *p;\n<line2>p = sqlite3_aggregate_context(ctx, sizeof(*p));\n<line3>/* p is always non-NULL since countStep() will have been called first */\n<line4>if( (argc==0 || SQLITE_NULL!=sqlite3_value_type(argv[0])) && ALWAYS(p) ){\n<line5>p->n--;\n<line6>#ifdef SQLITE_DEBUG\n<line7>p->bInverse = 1;\n<line8>#endif\n<line9>}\n<line10>}
----------------------------------------
Function: minmaxStep
Content: <line0>static void minmaxStep(\n<line1>sqlite3_context *context,\n<line2>int NotUsed,\n<line3>sqlite3_value **argv\n<line4>){\n<line5>Mem *pArg  = (Mem *)argv[0];\n<line6>Mem *pBest;\n<line7>UNUSED_PARAMETER(NotUsed);\n<line8>pBest = (Mem *)sqlite3_aggregate_context(context, sizeof(*pBest));\n<line9>if( !pBest ) return;\n<line10>if( sqlite3_value_type(pArg)==SQLITE_NULL ){\n<line11>if( pBest->flags ) sqlite3SkipAccumulatorLoad(context);\n<line12>}else if( pBest->flags ){\n<line13>int max;\n<line14>int cmp;\n<line15>CollSeq *pColl = sqlite3GetFuncCollSeq(context);\n<line16>/* This step function is used for both the min() and max() aggregates,\n<line17>** the only difference between the two being that the sense of the\n<line18>** comparison is inverted. For the max() aggregate, the\n<line19>** sqlite3_user_data() function returns (void *)-1. For min() it\n<line20>** returns (void *)db, where db is the sqlite3* database pointer.\n<line21>** Therefore the next statement sets variable 'max' to 1 for the max()\n<line22>** aggregate, or 0 for min().\n<line23>*/\n<line24>max = sqlite3_user_data(context)!=0;\n<line25>cmp = sqlite3MemCompare(pBest, pArg, pColl);\n<line26>if( (max && cmp<0) || (!max && cmp>0) ){\n<line27>sqlite3VdbeMemCopy(pBest, pArg);\n<line28>}else{\n<line29>sqlite3SkipAccumulatorLoad(context);\n<line30>}\n<line31>}else{\n<line32>pBest->db = sqlite3_context_db_handle(context);\n<line33>sqlite3VdbeMemCopy(pBest, pArg);\n<line34>}\n<line35>}
----------------------------------------
Function: minMaxValueFinalize
Content: <line0>static void minMaxValueFinalize(sqlite3_context *context, int bValue){\n<line1>sqlite3_value *pRes;\n<line2>pRes = (sqlite3_value *)sqlite3_aggregate_context(context, 0);\n<line3>if( pRes ){\n<line4>if( pRes->flags ){\n<line5>sqlite3_result_value(context, pRes);\n<line6>}\n<line7>if( bValue==0 ) sqlite3VdbeMemRelease(pRes);\n<line8>}\n<line9>}
----------------------------------------
Function: minMaxValue
Content: <line0>static void minMaxValue(sqlite3_context *context){\n<line1>minMaxValueFinalize(context, 1);\n<line2>}
----------------------------------------
Function: minMaxFinalize
Content: <line0>static void minMaxFinalize(sqlite3_context *context){\n<line1>minMaxValueFinalize(context, 0);\n<line2>}
----------------------------------------
Function: groupConcatStep
Content: <line0>static void groupConcatStep(\n<line1>sqlite3_context *context,\n<line2>int argc,\n<line3>sqlite3_value **argv\n<line4>){\n<line5>const char *zVal;\n<line6>GroupConcatCtx *pGCC;\n<line7>const char *zSep;\n<line8>int nVal, nSep;\n<line9>assert( argc==1 || argc==2 );\n<line10>if( sqlite3_value_type(argv[0])==SQLITE_NULL ) return;\n<line11>pGCC = (GroupConcatCtx*)sqlite3_aggregate_context(context, sizeof(*pGCC));\n<line12>if( pGCC ){\n<line13>sqlite3 *db = sqlite3_context_db_handle(context);\n<line14>int firstTerm = pGCC->str.mxAlloc==0;\n<line15>pGCC->str.mxAlloc = db->aLimit[SQLITE_LIMIT_LENGTH];\n<line16>if( argc==1 ){\n<line17>if( !firstTerm ){\n<line18>sqlite3_str_appendchar(&pGCC->str, 1, ',');\n<line19>}\n<line20>#ifndef SQLITE_OMIT_WINDOWFUNC\n<line21>else{\n<line22>pGCC->nFirstSepLength = 1;\n<line23>}\n<line24>#endif\n<line25>}else if( !firstTerm ){\n<line26>zSep = (char*)sqlite3_value_text(argv[1]);\n<line27>nSep = sqlite3_value_bytes(argv[1]);\n<line28>if( zSep ){\n<line29>sqlite3_str_append(&pGCC->str, zSep, nSep);\n<line30>}\n<line31>#ifndef SQLITE_OMIT_WINDOWFUNC\n<line32>else{\n<line33>nSep = 0;\n<line34>}\n<line35>if( nSep != pGCC->nFirstSepLength || pGCC->pnSepLengths != 0 ){\n<line36>int *pnsl = pGCC->pnSepLengths;\n<line37>if( pnsl == 0 ){\n<line38>/* First separator length variation seen, start tracking them. */\n<line39>pnsl = (int*)sqlite3_malloc64((pGCC->nAccum+1) * sizeof(int));\n<line40>if( pnsl!=0 ){\n<line41>int i = 0, nA = pGCC->nAccum-1;\n<line42>while( i<nA ) pnsl[i++] = pGCC->nFirstSepLength;\n<line43>}\n<line44>}else{\n<line45>pnsl = (int*)sqlite3_realloc64(pnsl, pGCC->nAccum * sizeof(int));\n<line46>}\n<line47>if( pnsl!=0 ){\n<line48>if( ALWAYS(pGCC->nAccum>0) ){\n<line49>pnsl[pGCC->nAccum-1] = nSep;\n<line50>}\n<line51>pGCC->pnSepLengths = pnsl;\n<line52>}else{\n<line53>sqlite3StrAccumSetError(&pGCC->str, SQLITE_NOMEM);\n<line54>}\n<line55>}\n<line56>#endif\n<line57>}\n<line58>#ifndef SQLITE_OMIT_WINDOWFUNC\n<line59>else{\n<line60>pGCC->nFirstSepLength = sqlite3_value_bytes(argv[1]);\n<line61>}\n<line62>pGCC->nAccum += 1;\n<line63>#endif\n<line64>zVal = (char*)sqlite3_value_text(argv[0]);\n<line65>nVal = sqlite3_value_bytes(argv[0]);\n<line66>if( zVal ) sqlite3_str_append(&pGCC->str, zVal, nVal);\n<line67>}\n<line68>}
----------------------------------------
Function: groupConcatInverse
Content: <line0>static void groupConcatInverse(\n<line1>sqlite3_context *context,\n<line2>int argc,\n<line3>sqlite3_value **argv\n<line4>){\n<line5>GroupConcatCtx *pGCC;\n<line6>assert( argc==1 || argc==2 );\n<line7>(void)argc;  /* Suppress unused parameter warning */\n<line8>if( sqlite3_value_type(argv[0])==SQLITE_NULL ) return;\n<line9>pGCC = (GroupConcatCtx*)sqlite3_aggregate_context(context, sizeof(*pGCC));\n<line10>/* pGCC is always non-NULL since groupConcatStep() will have always\n<line11>** run first to initialize it */\n<line12>if( ALWAYS(pGCC) ){\n<line13>int nVS;  /* Number of characters to remove */\n<line14>/* Must call sqlite3_value_text() to convert the argument into text prior\n<line15>** to invoking sqlite3_value_bytes(), in case the text encoding is UTF16 */\n<line16>(void)sqlite3_value_text(argv[0]);\n<line17>nVS = sqlite3_value_bytes(argv[0]);\n<line18>pGCC->nAccum -= 1;\n<line19>if( pGCC->pnSepLengths!=0 ){\n<line20>assert(pGCC->nAccum >= 0);\n<line21>if( pGCC->nAccum>0 ){\n<line22>nVS += *pGCC->pnSepLengths;\n<line23>memmove(pGCC->pnSepLengths, pGCC->pnSepLengths+1,\n<line24>(pGCC->nAccum-1)*sizeof(int));\n<line25>}\n<line26>}else{\n<line27>/* If removing single accumulated string, harmlessly over-do. */\n<line28>nVS += pGCC->nFirstSepLength;\n<line29>}\n<line30>if( nVS>=(int)pGCC->str.nChar ){\n<line31>pGCC->str.nChar = 0;\n<line32>}else{\n<line33>pGCC->str.nChar -= nVS;\n<line34>memmove(pGCC->str.zText, &pGCC->str.zText[nVS], pGCC->str.nChar);\n<line35>}\n<line36>if( pGCC->str.nChar==0 ){\n<line37>pGCC->str.mxAlloc = 0;\n<line38>sqlite3_free(pGCC->pnSepLengths);\n<line39>pGCC->pnSepLengths = 0;\n<line40>}\n<line41>}\n<line42>}
----------------------------------------
Function: groupConcatFinalize
Content: <line0>static void groupConcatFinalize(sqlite3_context *context){\n<line1>GroupConcatCtx *pGCC\n<line2>= (GroupConcatCtx*)sqlite3_aggregate_context(context, 0);\n<line3>if( pGCC ){\n<line4>sqlite3ResultStrAccum(context, &pGCC->str);\n<line5>#ifndef SQLITE_OMIT_WINDOWFUNC\n<line6>sqlite3_free(pGCC->pnSepLengths);\n<line7>#endif\n<line8>}\n<line9>}
----------------------------------------
Function: groupConcatValue
Content: <line0>static void groupConcatValue(sqlite3_context *context){\n<line1>GroupConcatCtx *pGCC\n<line2>= (GroupConcatCtx*)sqlite3_aggregate_context(context, 0);\n<line3>if( pGCC ){\n<line4>StrAccum *pAccum = &pGCC->str;\n<line5>if( pAccum->accError==SQLITE_TOOBIG ){\n<line6>sqlite3_result_error_toobig(context);\n<line7>}else if( pAccum->accError==SQLITE_NOMEM ){\n<line8>sqlite3_result_error_nomem(context);\n<line9>}else if( pGCC->nAccum>0 && pAccum->nChar==0 ){\n<line10>sqlite3_result_text(context, "", 1, SQLITE_STATIC);\n<line11>}else{\n<line12>const char *zText = sqlite3_str_value(pAccum);\n<line13>sqlite3_result_text(context, zText, pAccum->nChar, SQLITE_TRANSIENT);\n<line14>}\n<line15>}\n<line16>}
----------------------------------------
Function: signFunc
Content: <line0>static void signFunc(\n<line1>sqlite3_context *context,\n<line2>int argc,\n<line3>sqlite3_value **argv\n<line4>){\n<line5>int type0;\n<line6>double x;\n<line7>UNUSED_PARAMETER(argc);\n<line8>assert( argc==1 );\n<line9>type0 = sqlite3_value_numeric_type(argv[0]);\n<line10>if( type0!=SQLITE_INTEGER && type0!=SQLITE_FLOAT ) return;\n<line11>x = sqlite3_value_double(argv[0]);\n<line12>sqlite3_result_int(context, x<0.0 ? -1 : x>0.0 ? +1 : 0);\n<line13>}
----------------------------------------
Function: fkLookupParent
Content: <line0>static void fkLookupParent(\n<line1>Parse *pParse,        /* Parse context */\n<line2>int iDb,              /* Index of database housing pTab */\n<line3>Table *pTab,          /* Parent table of FK pFKey */\n<line4>Index *pIdx,          /* Unique index on parent key columns in pTab */\n<line5>FKey *pFKey,          /* Foreign key constraint */\n<line6>int *aiCol,           /* Map from parent key columns to child table columns */\n<line7>int regData,          /* Address of array containing child table row */\n<line8>int nIncr,            /* Increment constraint counter by this */\n<line9>int isIgnore          /* If true, pretend pTab contains all NULL values */\n<line10>){\n<line11>int i;                                    /* Iterator variable */\n<line12>Vdbe *v = sqlite3GetVdbe(pParse);         /* Vdbe to add code to */\n<line13>int iCur = pParse->nTab - 1;              /* Cursor number to use */\n<line14>int iOk = sqlite3VdbeMakeLabel(pParse);   /* jump here if parent key found */\n<line15>sqlite3VdbeVerifyAbortable(v,\n<line16>(!pFKey->isDeferred\n<line17>&& !(pParse->db->flags & SQLITE_DeferFKs)\n<line18>&& !pParse->pToplevel\n<line19>&& !pParse->isMultiWrite) ? OE_Abort : OE_Ignore);\n<line20>/* If nIncr is less than zero, then check at runtime if there are any\n<line21>** outstanding constraints to resolve. If there are not, there is no need\n<line22>** to check if deleting this row resolves any outstanding violations.\n<line23>**\n<line24>** Check if any of the key columns in the child table row are NULL. If\n<line25>** any are, then the constraint is considered satisfied. No need to\n<line26>** search for a matching row in the parent table.  */\n<line27>if( nIncr<0 ){\n<line28>sqlite3VdbeAddOp2(v, OP_FkIfZero, pFKey->isDeferred, iOk);\n<line29>VdbeCoverage(v);\n<line30>}\n<line31>for(i=0; i<pFKey->nCol; i++){\n<line32>int iReg = sqlite3TableColumnToStorage(pFKey->pFrom,aiCol[i]) + regData + 1;\n<line33>sqlite3VdbeAddOp2(v, OP_IsNull, iReg, iOk); VdbeCoverage(v);\n<line34>}\n<line35>if( isIgnore==0 ){\n<line36>if( pIdx==0 ){\n<line37>/* If pIdx is NULL, then the parent key is the INTEGER PRIMARY KEY\n<line38>** column of the parent table (table pTab).  */\n<line39>int iMustBeInt;               /* Address of MustBeInt instruction */\n<line40>int regTemp = sqlite3GetTempReg(pParse);\n<line41>/* Invoke MustBeInt to coerce the child key value to an integer (i.e.\n<line42>** apply the affinity of the parent key). If this fails, then there\n<line43>** is no matching parent key. Before using MustBeInt, make a copy of\n<line44>** the value. Otherwise, the value inserted into the child key column\n<line45>** will have INTEGER affinity applied to it, which may not be correct.  */\n<line46>sqlite3VdbeAddOp2(v, OP_SCopy,\n<line47>sqlite3TableColumnToStorage(pFKey->pFrom,aiCol[0])+1+regData, regTemp);\n<line48>iMustBeInt = sqlite3VdbeAddOp2(v, OP_MustBeInt, regTemp, 0);\n<line49>VdbeCoverage(v);\n<line50>/* If the parent table is the same as the child table, and we are about\n<line51>** to increment the constraint-counter (i.e. this is an INSERT operation),\n<line52>** then check if the row being inserted matches itself. If so, do not\n<line53>** increment the constraint-counter.  */\n<line54>if( pTab==pFKey->pFrom && nIncr==1 ){\n<line55>sqlite3VdbeAddOp3(v, OP_Eq, regData, iOk, regTemp); VdbeCoverage(v);\n<line56>sqlite3VdbeChangeP5(v, SQLITE_NOTNULL);\n<line57>}\n<line58>sqlite3OpenTable(pParse, iCur, iDb, pTab, OP_OpenRead);\n<line59>sqlite3VdbeAddOp3(v, OP_NotExists, iCur, 0, regTemp); VdbeCoverage(v);\n<line60>sqlite3VdbeGoto(v, iOk);\n<line61>sqlite3VdbeJumpHere(v, sqlite3VdbeCurrentAddr(v)-2);\n<line62>sqlite3VdbeJumpHere(v, iMustBeInt);\n<line63>sqlite3ReleaseTempReg(pParse, regTemp);\n<line64>}else{\n<line65>int nCol = pFKey->nCol;\n<line66>int regTemp = sqlite3GetTempRange(pParse, nCol);\n<line67>sqlite3VdbeAddOp3(v, OP_OpenRead, iCur, pIdx->tnum, iDb);\n<line68>sqlite3VdbeSetP4KeyInfo(pParse, pIdx);\n<line69>for(i=0; i<nCol; i++){\n<line70>sqlite3VdbeAddOp2(v, OP_Copy,\n<line71>sqlite3TableColumnToStorage(pFKey->pFrom, aiCol[i])+1+regData,\n<line72>regTemp+i);\n<line73>}\n<line74>/* If the parent table is the same as the child table, and we are about\n<line75>** to increment the constraint-counter (i.e. this is an INSERT operation),\n<line76>** then check if the row being inserted matches itself. If so, do not\n<line77>** increment the constraint-counter.\n<line78>**\n<line79>** If any of the parent-key values are NULL, then the row cannot match\n<line80>** itself. So set JUMPIFNULL to make sure we do the OP_Found if any\n<line81>** of the parent-key values are NULL (at this point it is known that\n<line82>** none of the child key values are).\n<line83>*/\n<line84>if( pTab==pFKey->pFrom && nIncr==1 ){\n<line85>int iJump = sqlite3VdbeCurrentAddr(v) + nCol + 1;\n<line86>for(i=0; i<nCol; i++){\n<line87>int iChild = sqlite3TableColumnToStorage(pFKey->pFrom,aiCol[i])\n<line88>+1+regData;\n<line89>int iParent = 1+regData;\n<line90>iParent += sqlite3TableColumnToStorage(pIdx->pTable,\n<line91>pIdx->aiColumn[i]);\n<line92>assert( pIdx->aiColumn[i]>=0 );\n<line93>assert( aiCol[i]!=pTab->iPKey );\n<line94>if( pIdx->aiColumn[i]==pTab->iPKey ){\n<line95>/* The parent key is a composite key that includes the IPK column */\n<line96>iParent = regData;\n<line97>}\n<line98>sqlite3VdbeAddOp3(v, OP_Ne, iChild, iJump, iParent); VdbeCoverage(v);\n<line99>sqlite3VdbeChangeP5(v, SQLITE_JUMPIFNULL);\n<line100>}\n<line101>sqlite3VdbeGoto(v, iOk);\n<line102>}\n<line103>sqlite3VdbeAddOp4(v, OP_Affinity, regTemp, nCol, 0,\n<line104>sqlite3IndexAffinityStr(pParse->db,pIdx), nCol);\n<line105>sqlite3VdbeAddOp4Int(v, OP_Found, iCur, iOk, regTemp, nCol);\n<line106>VdbeCoverage(v);\n<line107>sqlite3ReleaseTempRange(pParse, regTemp, nCol);\n<line108>}\n<line109>}\n<line110>if( !pFKey->isDeferred && !(pParse->db->flags & SQLITE_DeferFKs)\n<line111>&& !pParse->pToplevel\n<line112>&& !pParse->isMultiWrite\n<line113>){\n<line114>/* Special case: If this is an INSERT statement that will insert exactly\n<line115>** one row into the table, raise a constraint immediately instead of\n<line116>** incrementing a counter. This is necessary as the VM code is being\n<line117>** generated for will not open a statement transaction.  */\n<line118>assert( nIncr==1 );\n<line119>sqlite3HaltConstraint(pParse, SQLITE_CONSTRAINT_FOREIGNKEY,\n<line120>OE_Abort, 0, P4_STATIC, P5_ConstraintFK);\n<line121>}else{\n<line122>if( nIncr>0 && pFKey->isDeferred==0 ){\n<line123>sqlite3MayAbort(pParse);\n<line124>}\n<line125>sqlite3VdbeAddOp2(v, OP_FkCounter, pFKey->isDeferred, nIncr);\n<line126>}\n<line127>sqlite3VdbeResolveLabel(v, iOk);\n<line128>sqlite3VdbeAddOp1(v, OP_Close, iCur);\n<line129>}
----------------------------------------
Function: exprTableRegister
Content: <line0>static Expr *exprTableRegister(\n<line1>Parse *pParse,     /* Parsing and code generating context */\n<line2>Table *pTab,       /* The table whose content is at r[regBase]... */\n<line3>int regBase,       /* Contents of table pTab */\n<line4>i16 iCol           /* Which column of pTab is desired */\n<line5>){\n<line6>Expr *pExpr;\n<line7>Column *pCol;\n<line8>const char *zColl;\n<line9>sqlite3 *db = pParse->db;\n<line10>pExpr = sqlite3Expr(db, TK_REGISTER, 0);\n<line11>if( pExpr ){\n<line12>if( iCol>=0 && iCol!=pTab->iPKey ){\n<line13>pCol = &pTab->aCol[iCol];\n<line14>pExpr->iTable = regBase + sqlite3TableColumnToStorage(pTab,iCol) + 1;\n<line15>pExpr->affExpr = pCol->affinity;\n<line16>zColl = sqlite3ColumnColl(pCol);\n<line17>if( zColl==0 ) zColl = db->pDfltColl->zName;\n<line18>pExpr = sqlite3ExprAddCollateString(pParse, pExpr, zColl);\n<line19>}else{\n<line20>pExpr->iTable = regBase;\n<line21>pExpr->affExpr = SQLITE_AFF_INTEGER;\n<line22>}\n<line23>}\n<line24>return pExpr;\n<line25>}
----------------------------------------
Function: exprTableColumn
Content: <line0>static Expr *exprTableColumn(\n<line1>sqlite3 *db,      /* The database connection */\n<line2>Table *pTab,      /* The table whose column is desired */\n<line3>int iCursor,      /* The open cursor on the table */\n<line4>i16 iCol          /* The column that is wanted */\n<line5>){\n<line6>Expr *pExpr = sqlite3Expr(db, TK_COLUMN, 0);\n<line7>if( pExpr ){\n<line8>assert( ExprUseYTab(pExpr) );\n<line9>pExpr->y.pTab = pTab;\n<line10>pExpr->iTable = iCursor;\n<line11>pExpr->iColumn = iCol;\n<line12>}\n<line13>return pExpr;\n<line14>}
----------------------------------------
Function: fkScanChildren
Content: <line0>static void fkScanChildren(\n<line1>Parse *pParse,                  /* Parse context */\n<line2>SrcList *pSrc,                  /* The child table to be scanned */\n<line3>Table *pTab,                    /* The parent table */\n<line4>Index *pIdx,                    /* Index on parent covering the foreign key */\n<line5>FKey *pFKey,                    /* The foreign key linking pSrc to pTab */\n<line6>int *aiCol,                     /* Map from pIdx cols to child table cols */\n<line7>int regData,                    /* Parent row data starts here */\n<line8>int nIncr                       /* Amount to increment deferred counter by */\n<line9>){\n<line10>sqlite3 *db = pParse->db;       /* Database handle */\n<line11>int i;                          /* Iterator variable */\n<line12>Expr *pWhere = 0;               /* WHERE clause to scan with */\n<line13>NameContext sNameContext;       /* Context used to resolve WHERE clause */\n<line14>WhereInfo *pWInfo;              /* Context used by sqlite3WhereXXX() */\n<line15>int iFkIfZero = 0;              /* Address of OP_FkIfZero */\n<line16>Vdbe *v = sqlite3GetVdbe(pParse);\n<line17>assert( pIdx==0 || pIdx->pTable==pTab );\n<line18>assert( pIdx==0 || pIdx->nKeyCol==pFKey->nCol );\n<line19>assert( pIdx!=0 || pFKey->nCol==1 );\n<line20>assert( pIdx!=0 || HasRowid(pTab) );\n<line21>if( nIncr<0 ){\n<line22>iFkIfZero = sqlite3VdbeAddOp2(v, OP_FkIfZero, pFKey->isDeferred, 0);\n<line23>VdbeCoverage(v);\n<line24>}\n<line25>/* Create an Expr object representing an SQL expression like:\n<line26>**\n<line27>**   <parent-key1> = <child-key1> AND <parent-key2> = <child-key2> ...\n<line28>**\n<line29>** The collation sequence used for the comparison should be that of\n<line30>** the parent key columns. The affinity of the parent key column should\n<line31>** be applied to each child key value before the comparison takes place.\n<line32>*/\n<line33>for(i=0; i<pFKey->nCol; i++){\n<line34>Expr *pLeft;                  /* Value from parent table row */\n<line35>Expr *pRight;                 /* Column ref to child table */\n<line36>Expr *pEq;                    /* Expression (pLeft = pRight) */\n<line37>i16 iCol;                     /* Index of column in child table */\n<line38>const char *zCol;             /* Name of column in child table */\n<line39>iCol = pIdx ? pIdx->aiColumn[i] : -1;\n<line40>pLeft = exprTableRegister(pParse, pTab, regData, iCol);\n<line41>iCol = aiCol ? aiCol[i] : pFKey->aCol[0].iFrom;\n<line42>assert( iCol>=0 );\n<line43>zCol = pFKey->pFrom->aCol[iCol].zCnName;\n<line44>pRight = sqlite3Expr(db, TK_ID, zCol);\n<line45>pEq = sqlite3PExpr(pParse, TK_EQ, pLeft, pRight);\n<line46>pWhere = sqlite3ExprAnd(pParse, pWhere, pEq);\n<line47>}\n<line48>/* If the child table is the same as the parent table, then add terms\n<line49>** to the WHERE clause that prevent this entry from being scanned.\n<line50>** The added WHERE clause terms are like this:\n<line51>**\n<line52>**     $current_rowid!=rowid\n<line53>**     NOT( $current_a==a AND $current_b==b AND ... )\n<line54>**\n<line55>** The first form is used for rowid tables.  The second form is used\n<line56>** for WITHOUT ROWID tables. In the second form, the *parent* key is\n<line57>** (a,b,...). Either the parent or primary key could be used to\n<line58>** uniquely identify the current row, but the parent key is more convenient\n<line59>** as the required values have already been loaded into registers\n<line60>** by the caller.\n<line61>*/\n<line62>if( pTab==pFKey->pFrom && nIncr>0 ){\n<line63>Expr *pNe;                    /* Expression (pLeft != pRight) */\n<line64>Expr *pLeft;                  /* Value from parent table row */\n<line65>Expr *pRight;                 /* Column ref to child table */\n<line66>if( HasRowid(pTab) ){\n<line67>pLeft = exprTableRegister(pParse, pTab, regData, -1);\n<line68>pRight = exprTableColumn(db, pTab, pSrc->a[0].iCursor, -1);\n<line69>pNe = sqlite3PExpr(pParse, TK_NE, pLeft, pRight);\n<line70>}else{\n<line71>Expr *pEq, *pAll = 0;\n<line72>assert( pIdx!=0 );\n<line73>for(i=0; i<pIdx->nKeyCol; i++){\n<line74>i16 iCol = pIdx->aiColumn[i];\n<line75>assert( iCol>=0 );\n<line76>pLeft = exprTableRegister(pParse, pTab, regData, iCol);\n<line77>pRight = sqlite3Expr(db, TK_ID, pTab->aCol[iCol].zCnName);\n<line78>pEq = sqlite3PExpr(pParse, TK_IS, pLeft, pRight);\n<line79>pAll = sqlite3ExprAnd(pParse, pAll, pEq);\n<line80>}\n<line81>pNe = sqlite3PExpr(pParse, TK_NOT, pAll, 0);\n<line82>}\n<line83>pWhere = sqlite3ExprAnd(pParse, pWhere, pNe);\n<line84>}\n<line85>/* Resolve the references in the WHERE clause. */\n<line86>memset(&sNameContext, 0, sizeof(NameContext));\n<line87>sNameContext.pSrcList = pSrc;\n<line88>sNameContext.pParse = pParse;\n<line89>sqlite3ResolveExprNames(&sNameContext, pWhere);\n<line90>/* Create VDBE to loop through the entries in pSrc that match the WHERE\n<line91>** clause. For each row found, increment either the deferred or immediate\n<line92>** foreign key constraint counter. */\n<line93>if( pParse->nErr==0 ){\n<line94>pWInfo = sqlite3WhereBegin(pParse, pSrc, pWhere, 0, 0, 0, 0, 0);\n<line95>sqlite3VdbeAddOp2(v, OP_FkCounter, pFKey->isDeferred, nIncr);\n<line96>if( pWInfo ){\n<line97>sqlite3WhereEnd(pWInfo);\n<line98>}\n<line99>}\n<line100>/* Clean up the WHERE clause constructed above. */\n<line101>sqlite3ExprDelete(db, pWhere);\n<line102>if( iFkIfZero ){\n<line103>sqlite3VdbeJumpHereOrPopInst(v, iFkIfZero);\n<line104>}\n<line105>}
----------------------------------------
Function: fkTriggerDelete
Content: <line0>static void fkTriggerDelete(sqlite3 *dbMem, Trigger *p){\n<line1>if( p ){\n<line2>TriggerStep *pStep = p->step_list;\n<line3>sqlite3ExprDelete(dbMem, pStep->pWhere);\n<line4>sqlite3ExprListDelete(dbMem, pStep->pExprList);\n<line5>sqlite3SelectDelete(dbMem, pStep->pSelect);\n<line6>sqlite3ExprDelete(dbMem, p->pWhen);\n<line7>sqlite3DbFree(dbMem, p);\n<line8>}\n<line9>}
----------------------------------------
Function: fkChildIsModified
Content: <line0>static int fkChildIsModified(\n<line1>Table *pTab,                    /* Table being updated */\n<line2>FKey *p,                        /* Foreign key for which pTab is the child */\n<line3>int *aChange,                   /* Array indicating modified columns */\n<line4>int bChngRowid                  /* True if rowid is modified by this update */\n<line5>){\n<line6>int i;\n<line7>for(i=0; i<p->nCol; i++){\n<line8>int iChildKey = p->aCol[i].iFrom;\n<line9>if( aChange[iChildKey]>=0 ) return 1;\n<line10>if( iChildKey==pTab->iPKey && bChngRowid ) return 1;\n<line11>}\n<line12>return 0;\n<line13>}
----------------------------------------
Function: fkParentIsModified
Content: <line0>static int fkParentIsModified(\n<line1>Table *pTab,\n<line2>FKey *p,\n<line3>int *aChange,\n<line4>int bChngRowid\n<line5>){\n<line6>int i;\n<line7>for(i=0; i<p->nCol; i++){\n<line8>char *zKey = p->aCol[i].zCol;\n<line9>int iKey;\n<line10>for(iKey=0; iKey<pTab->nCol; iKey++){\n<line11>if( aChange[iKey]>=0 || (iKey==pTab->iPKey && bChngRowid) ){\n<line12>Column *pCol = &pTab->aCol[iKey];\n<line13>if( zKey ){\n<line14>if( 0==sqlite3StrICmp(pCol->zCnName, zKey) ) return 1;\n<line15>}else if( pCol->colFlags & COLFLAG_PRIMKEY ){\n<line16>return 1;\n<line17>}\n<line18>}\n<line19>}\n<line20>}\n<line21>return 0;\n<line22>}
----------------------------------------
Function: isSetNullAction
Content: <line0>static int isSetNullAction(Parse *pParse, FKey *pFKey){\n<line1>Parse *pTop = sqlite3ParseToplevel(pParse);\n<line2>if( pTop->pTriggerPrg ){\n<line3>Trigger *p = pTop->pTriggerPrg->pTrigger;\n<line4>if( (p==pFKey->apTrigger[0] && pFKey->aAction[0]==OE_SetNull)\n<line5>|| (p==pFKey->apTrigger[1] && pFKey->aAction[1]==OE_SetNull)\n<line6>){\n<line7>assert( (pTop->db->flags & SQLITE_FkNoAction)==0 );\n<line8>return 1;\n<line9>}\n<line10>}\n<line11>return 0;\n<line12>}
----------------------------------------
Function: fkActionTrigger
Content: <line0>static Trigger *fkActionTrigger(\n<line1>Parse *pParse,                  /* Parse context */\n<line2>Table *pTab,                    /* Table being updated or deleted from */\n<line3>FKey *pFKey,                    /* Foreign key to get action for */\n<line4>ExprList *pChanges              /* Change-list for UPDATE, NULL for DELETE */\n<line5>){\n<line6>sqlite3 *db = pParse->db;       /* Database handle */\n<line7>int action;                     /* One of OE_None, OE_Cascade etc. */\n<line8>Trigger *pTrigger;              /* Trigger definition to return */\n<line9>int iAction = (pChanges!=0);    /* 1 for UPDATE, 0 for DELETE */\n<line10>action = pFKey->aAction[iAction];\n<line11>if( (db->flags & SQLITE_FkNoAction) ) action = OE_None;\n<line12>if( action==OE_Restrict && (db->flags & SQLITE_DeferFKs) ){\n<line13>return 0;\n<line14>}\n<line15>pTrigger = pFKey->apTrigger[iAction];\n<line16>if( action!=OE_None && !pTrigger ){\n<line17>char const *zFrom;            /* Name of child table */\n<line18>int nFrom;                    /* Length in bytes of zFrom */\n<line19>Index *pIdx = 0;              /* Parent key index for this FK */\n<line20>int *aiCol = 0;               /* child table cols -> parent key cols */\n<line21>TriggerStep *pStep = 0;        /* First (only) step of trigger program */\n<line22>Expr *pWhere = 0;             /* WHERE clause of trigger step */\n<line23>ExprList *pList = 0;          /* Changes list if ON UPDATE CASCADE */\n<line24>Select *pSelect = 0;          /* If RESTRICT, "SELECT RAISE(...)" */\n<line25>int i;                        /* Iterator variable */\n<line26>Expr *pWhen = 0;              /* WHEN clause for the trigger */\n<line27>if( sqlite3FkLocateIndex(pParse, pTab, pFKey, &pIdx, &aiCol) ) return 0;\n<line28>assert( aiCol || pFKey->nCol==1 );\n<line29>for(i=0; i<pFKey->nCol; i++){\n<line30>Token tOld = { "old", 3 };  /* Literal "old" token */\n<line31>Token tNew = { "new", 3 };  /* Literal "new" token */\n<line32>Token tFromCol;             /* Name of column in child table */\n<line33>Token tToCol;               /* Name of column in parent table */\n<line34>int iFromCol;               /* Idx of column in child table */\n<line35>Expr *pEq;                  /* tFromCol = OLD.tToCol */\n<line36>iFromCol = aiCol ? aiCol[i] : pFKey->aCol[0].iFrom;\n<line37>assert( iFromCol>=0 );\n<line38>assert( pIdx!=0 || (pTab->iPKey>=0 && pTab->iPKey<pTab->nCol) );\n<line39>assert( pIdx==0 || pIdx->aiColumn[i]>=0 );\n<line40>sqlite3TokenInit(&tToCol,\n<line41>pTab->aCol[pIdx ? pIdx->aiColumn[i] : pTab->iPKey].zCnName);\n<line42>sqlite3TokenInit(&tFromCol, pFKey->pFrom->aCol[iFromCol].zCnName);\n<line43>/* Create the expression "OLD.zToCol = zFromCol". It is important\n<line44>** that the "OLD.zToCol" term is on the LHS of the = operator, so\n<line45>** that the affinity and collation sequence associated with the\n<line46>** parent table are used for the comparison. */\n<line47>pEq = sqlite3PExpr(pParse, TK_EQ,\n<line48>sqlite3PExpr(pParse, TK_DOT,\n<line49>sqlite3ExprAlloc(db, TK_ID, &tOld, 0),\n<line50>sqlite3ExprAlloc(db, TK_ID, &tToCol, 0)),\n<line51>sqlite3ExprAlloc(db, TK_ID, &tFromCol, 0)\n<line52>);\n<line53>pWhere = sqlite3ExprAnd(pParse, pWhere, pEq);\n<line54>/* For ON UPDATE, construct the next term of the WHEN clause.\n<line55>** The final WHEN clause will be like this:\n<line56>**\n<line57>**    WHEN NOT(old.col1 IS new.col1 AND ... AND old.colN IS new.colN)\n<line58>*/\n<line59>if( pChanges ){\n<line60>pEq = sqlite3PExpr(pParse, TK_IS,\n<line61>sqlite3PExpr(pParse, TK_DOT,\n<line62>sqlite3ExprAlloc(db, TK_ID, &tOld, 0),\n<line63>sqlite3ExprAlloc(db, TK_ID, &tToCol, 0)),\n<line64>sqlite3PExpr(pParse, TK_DOT,\n<line65>sqlite3ExprAlloc(db, TK_ID, &tNew, 0),\n<line66>sqlite3ExprAlloc(db, TK_ID, &tToCol, 0))\n<line67>);\n<line68>pWhen = sqlite3ExprAnd(pParse, pWhen, pEq);\n<line69>}\n<line70>if( action!=OE_Restrict && (action!=OE_Cascade || pChanges) ){\n<line71>Expr *pNew;\n<line72>if( action==OE_Cascade ){\n<line73>pNew = sqlite3PExpr(pParse, TK_DOT,\n<line74>sqlite3ExprAlloc(db, TK_ID, &tNew, 0),\n<line75>sqlite3ExprAlloc(db, TK_ID, &tToCol, 0));\n<line76>}else if( action==OE_SetDflt ){\n<line77>Column *pCol = pFKey->pFrom->aCol + iFromCol;\n<line78>Expr *pDflt;\n<line79>if( pCol->colFlags & COLFLAG_GENERATED ){\n<line80>testcase( pCol->colFlags & COLFLAG_VIRTUAL );\n<line81>testcase( pCol->colFlags & COLFLAG_STORED );\n<line82>pDflt = 0;\n<line83>}else{\n<line84>pDflt = sqlite3ColumnExpr(pFKey->pFrom, pCol);\n<line85>}\n<line86>if( pDflt ){\n<line87>pNew = sqlite3ExprDup(db, pDflt, 0);\n<line88>}else{\n<line89>pNew = sqlite3ExprAlloc(db, TK_NULL, 0, 0);\n<line90>}\n<line91>}else{\n<line92>pNew = sqlite3ExprAlloc(db, TK_NULL, 0, 0);\n<line93>}\n<line94>pList = sqlite3ExprListAppend(pParse, pList, pNew);\n<line95>sqlite3ExprListSetName(pParse, pList, &tFromCol, 0);\n<line96>}\n<line97>}\n<line98>sqlite3DbFree(db, aiCol);\n<line99>zFrom = pFKey->pFrom->zName;\n<line100>nFrom = sqlite3Strlen30(zFrom);\n<line101>if( action==OE_Restrict ){\n<line102>int iDb = sqlite3SchemaToIndex(db, pTab->pSchema);\n<line103>SrcList *pSrc;\n<line104>Expr *pRaise;\n<line105>pRaise = sqlite3Expr(db, TK_STRING, "FOREIGN KEY constraint failed"),\n<line106>pRaise = sqlite3PExpr(pParse, TK_RAISE, pRaise, 0);\n<line107>if( pRaise ){\n<line108>pRaise->affExpr = OE_Abort;\n<line109>}\n<line110>pSrc = sqlite3SrcListAppend(pParse, 0, 0, 0);\n<line111>if( pSrc ){\n<line112>assert( pSrc->nSrc==1 );\n<line113>pSrc->a[0].zName = sqlite3DbStrDup(db, zFrom);\n<line114>assert( pSrc->a[0].fg.fixedSchema==0 && pSrc->a[0].fg.isSubquery==0 );\n<line115>pSrc->a[0].u4.zDatabase = sqlite3DbStrDup(db, db->aDb[iDb].zDbSName);\n<line116>}\n<line117>pSelect = sqlite3SelectNew(pParse,\n<line118>sqlite3ExprListAppend(pParse, 0, pRaise),\n<line119>pSrc,\n<line120>pWhere,\n<line121>0, 0, 0, 0, 0\n<line122>);\n<line123>pWhere = 0;\n<line124>}\n<line125>/* Disable lookaside memory allocation */\n<line126>DisableLookaside;\n<line127>pTrigger = (Trigger *)sqlite3DbMallocZero(db,\n<line128>sizeof(Trigger) +         /* struct Trigger */\n<line129>sizeof(TriggerStep) +     /* Single step in trigger program */\n<line130>nFrom + 1                 /* Space for pStep->zTarget */\n<line131>);\n<line132>if( pTrigger ){\n<line133>pStep = pTrigger->step_list = (TriggerStep *)&pTrigger[1];\n<line134>pStep->zTarget = (char *)&pStep[1];\n<line135>memcpy((char *)pStep->zTarget, zFrom, nFrom);\n<line136>pStep->pWhere = sqlite3ExprDup(db, pWhere, EXPRDUP_REDUCE);\n<line137>pStep->pExprList = sqlite3ExprListDup(db, pList, EXPRDUP_REDUCE);\n<line138>pStep->pSelect = sqlite3SelectDup(db, pSelect, EXPRDUP_REDUCE);\n<line139>if( pWhen ){\n<line140>pWhen = sqlite3PExpr(pParse, TK_NOT, pWhen, 0);\n<line141>pTrigger->pWhen = sqlite3ExprDup(db, pWhen, EXPRDUP_REDUCE);\n<line142>}\n<line143>}\n<line144>/* Re-enable the lookaside buffer, if it was disabled earlier. */\n<line145>EnableLookaside;\n<line146>sqlite3ExprDelete(db, pWhere);\n<line147>sqlite3ExprDelete(db, pWhen);\n<line148>sqlite3ExprListDelete(db, pList);\n<line149>sqlite3SelectDelete(db, pSelect);\n<line150>if( db->mallocFailed==1 ){\n<line151>fkTriggerDelete(db, pTrigger);\n<line152>return 0;\n<line153>}\n<line154>assert( pStep!=0 );\n<line155>assert( pTrigger!=0 );\n<line156>switch( action ){\n<line157>case OE_Restrict:\n<line158>pStep->op = TK_SELECT;\n<line159>break;\n<line160>case OE_Cascade:\n<line161>if( !pChanges ){\n<line162>pStep->op = TK_DELETE;\n<line163>break;\n<line164>}\n<line165>/* no break */ deliberate_fall_through\n<line166>default:\n<line167>pStep->op = TK_UPDATE;\n<line168>}\n<line169>pStep->pTrig = pTrigger;\n<line170>pTrigger->pSchema = pTab->pSchema;\n<line171>pTrigger->pTabSchema = pTab->pSchema;\n<line172>pFKey->apTrigger[iAction] = pTrigger;\n<line173>pTrigger->op = (pChanges ? TK_UPDATE : TK_DELETE);\n<line174>}\n<line175>return pTrigger;\n<line176>}
----------------------------------------
Function: computeIndexAffStr
Content: <line0>static SQLITE_NOINLINE const char *computeIndexAffStr(sqlite3 *db, Index *pIdx){\n<line1>/* The first time a column affinity string for a particular index is\n<line2>** required, it is allocated and populated here. It is then stored as\n<line3>** a member of the Index structure for subsequent use.\n<line4>**\n<line5>** The column affinity string will eventually be deleted by\n<line6>** sqliteDeleteIndex() when the Index structure itself is cleaned\n<line7>** up.\n<line8>*/\n<line9>int n;\n<line10>Table *pTab = pIdx->pTable;\n<line11>pIdx->zColAff = (char *)sqlite3DbMallocRaw(0, pIdx->nColumn+1);\n<line12>if( !pIdx->zColAff ){\n<line13>sqlite3OomFault(db);\n<line14>return 0;\n<line15>}\n<line16>for(n=0; n<pIdx->nColumn; n++){\n<line17>i16 x = pIdx->aiColumn[n];\n<line18>char aff;\n<line19>if( x>=0 ){\n<line20>aff = pTab->aCol[x].affinity;\n<line21>}else if( x==XN_ROWID ){\n<line22>aff = SQLITE_AFF_INTEGER;\n<line23>}else{\n<line24>assert( x==XN_EXPR );\n<line25>assert( pIdx->bHasExpr );\n<line26>assert( pIdx->aColExpr!=0 );\n<line27>aff = sqlite3ExprAffinity(pIdx->aColExpr->a[n].pExpr);\n<line28>}\n<line29>if( aff<SQLITE_AFF_BLOB ) aff = SQLITE_AFF_BLOB;\n<line30>if( aff>SQLITE_AFF_NUMERIC) aff = SQLITE_AFF_NUMERIC;\n<line31>pIdx->zColAff[n] = aff;\n<line32>}\n<line33>pIdx->zColAff[n] = 0;\n<line34>return pIdx->zColAff;\n<line35>}
----------------------------------------
Function: readsTable
Content: <line0>static int readsTable(Parse *p, int iDb, Table *pTab){\n<line1>Vdbe *v = sqlite3GetVdbe(p);\n<line2>int i;\n<line3>int iEnd = sqlite3VdbeCurrentAddr(v);\n<line4>#ifndef SQLITE_OMIT_VIRTUALTABLE\n<line5>VTable *pVTab = IsVirtual(pTab) ? sqlite3GetVTable(p->db, pTab) : 0;\n<line6>#endif\n<line7>for(i=1; i<iEnd; i++){\n<line8>VdbeOp *pOp = sqlite3VdbeGetOp(v, i);\n<line9>assert( pOp!=0 );\n<line10>if( pOp->opcode==OP_OpenRead && pOp->p3==iDb ){\n<line11>Index *pIndex;\n<line12>Pgno tnum = pOp->p2;\n<line13>if( tnum==pTab->tnum ){\n<line14>return 1;\n<line15>}\n<line16>for(pIndex=pTab->pIndex; pIndex; pIndex=pIndex->pNext){\n<line17>if( tnum==pIndex->tnum ){\n<line18>return 1;\n<line19>}\n<line20>}\n<line21>}\n<line22>#ifndef SQLITE_OMIT_VIRTUALTABLE\n<line23>if( pOp->opcode==OP_VOpen && pOp->p4.pVtab==pVTab ){\n<line24>assert( pOp->p4.pVtab!=0 );\n<line25>assert( pOp->p4type==P4_VTAB );\n<line26>return 1;\n<line27>}\n<line28>#endif\n<line29>}\n<line30>return 0;\n<line31>}
----------------------------------------
Function: exprColumnFlagUnion
Content: <line0>static int exprColumnFlagUnion(Walker *pWalker, Expr *pExpr){\n<line1>if( pExpr->op==TK_COLUMN && pExpr->iColumn>=0 ){\n<line2>assert( pExpr->iColumn < pWalker->u.pTab->nCol );\n<line3>pWalker->eCode |= pWalker->u.pTab->aCol[pExpr->iColumn].colFlags;\n<line4>}\n<line5>return WRC_Continue;\n<line6>}
----------------------------------------
Function: autoIncBegin
Content: <line0>static int autoIncBegin(\n<line1>Parse *pParse,      /* Parsing context */\n<line2>int iDb,            /* Index of the database holding pTab */\n<line3>Table *pTab         /* The table we are writing to */\n<line4>){\n<line5>int memId = 0;      /* Register holding maximum rowid */\n<line6>assert( pParse->db->aDb[iDb].pSchema!=0 );\n<line7>if( (pTab->tabFlags & TF_Autoincrement)!=0\n<line8>&& (pParse->db->mDbFlags & DBFLAG_Vacuum)==0\n<line9>){\n<line10>Parse *pToplevel = sqlite3ParseToplevel(pParse);\n<line11>AutoincInfo *pInfo;\n<line12>Table *pSeqTab = pParse->db->aDb[iDb].pSchema->pSeqTab;\n<line13>/* Verify that the sqlite_sequence table exists and is an ordinary\n<line14>** rowid table with exactly two columns.\n<line15>** Ticket d8dc2b3a58cd5dc2918a1d4acb 2018-05-23 */\n<line16>if( pSeqTab==0\n<line17>|| !HasRowid(pSeqTab)\n<line18>|| NEVER(IsVirtual(pSeqTab))\n<line19>|| pSeqTab->nCol!=2\n<line20>){\n<line21>pParse->nErr++;\n<line22>pParse->rc = SQLITE_CORRUPT_SEQUENCE;\n<line23>return 0;\n<line24>}\n<line25>pInfo = pToplevel->pAinc;\n<line26>while( pInfo && pInfo->pTab!=pTab ){ pInfo = pInfo->pNext; }\n<line27>if( pInfo==0 ){\n<line28>pInfo = sqlite3DbMallocRawNN(pParse->db, sizeof(*pInfo));\n<line29>sqlite3ParserAddCleanup(pToplevel, sqlite3DbFree, pInfo);\n<line30>testcase( pParse->earlyCleanup );\n<line31>if( pParse->db->mallocFailed ) return 0;\n<line32>pInfo->pNext = pToplevel->pAinc;\n<line33>pToplevel->pAinc = pInfo;\n<line34>pInfo->pTab = pTab;\n<line35>pInfo->iDb = iDb;\n<line36>pToplevel->nMem++;                  /* Register to hold name of table */\n<line37>pInfo->regCtr = ++pToplevel->nMem;  /* Max rowid register */\n<line38>pToplevel->nMem +=2;       /* Rowid in sqlite_sequence + orig max val */\n<line39>}\n<line40>memId = pInfo->regCtr;\n<line41>}\n<line42>return memId;\n<line43>}
----------------------------------------
Function: autoIncStep
Content: <line0>static void autoIncStep(Parse *pParse, int memId, int regRowid){\n<line1>if( memId>0 ){\n<line2>sqlite3VdbeAddOp2(pParse->pVdbe, OP_MemMax, memId, regRowid);\n<line3>}\n<line4>}
----------------------------------------
Function: autoIncrementEnd
Content: <line0>static SQLITE_NOINLINE void autoIncrementEnd(Parse *pParse){\n<line1>AutoincInfo *p;\n<line2>Vdbe *v = pParse->pVdbe;\n<line3>sqlite3 *db = pParse->db;\n<line4>assert( v );\n<line5>for(p = pParse->pAinc; p; p = p->pNext){\n<line6>static const int iLn = VDBE_OFFSET_LINENO(2);\n<line7>static const VdbeOpList autoIncEnd[] = {\n<line8>/* 0 */ {OP_NotNull,     0, 2, 0},\n<line9>/* 1 */ {OP_NewRowid,    0, 0, 0},\n<line10>/* 2 */ {OP_MakeRecord,  0, 2, 0},\n<line11>/* 3 */ {OP_Insert,      0, 0, 0},\n<line12>/* 4 */ {OP_Close,       0, 0, 0}\n<line13>};\n<line14>VdbeOp *aOp;\n<line15>Db *pDb = &db->aDb[p->iDb];\n<line16>int iRec;\n<line17>int memId = p->regCtr;\n<line18>iRec = sqlite3GetTempReg(pParse);\n<line19>assert( sqlite3SchemaMutexHeld(db, 0, pDb->pSchema) );\n<line20>sqlite3VdbeAddOp3(v, OP_Le, memId+2, sqlite3VdbeCurrentAddr(v)+7, memId);\n<line21>VdbeCoverage(v);\n<line22>sqlite3OpenTable(pParse, 0, p->iDb, pDb->pSchema->pSeqTab, OP_OpenWrite);\n<line23>aOp = sqlite3VdbeAddOpList(v, ArraySize(autoIncEnd), autoIncEnd, iLn);\n<line24>if( aOp==0 ) break;\n<line25>aOp[0].p1 = memId+1;\n<line26>aOp[1].p2 = memId+1;\n<line27>aOp[2].p1 = memId-1;\n<line28>aOp[2].p3 = iRec;\n<line29>aOp[3].p2 = iRec;\n<line30>aOp[3].p3 = memId+1;\n<line31>aOp[3].p5 = OPFLAG_APPEND;\n<line32>sqlite3ReleaseTempReg(pParse, iRec);\n<line33>}\n<line34>}
----------------------------------------
Function: exprListIsConstant
Content: <line0>static int exprListIsConstant(Parse *pParse, ExprList *pRow){\n<line1>int ii;\n<line2>for(ii=0; ii<pRow->nExpr; ii++){\n<line3>if( 0==sqlite3ExprIsConstant(pParse, pRow->a[ii].pExpr) ) return 0;\n<line4>}\n<line5>return 1;\n<line6>}
----------------------------------------
Function: exprListIsNoAffinity
Content: <line0>static int exprListIsNoAffinity(Parse *pParse, ExprList *pRow){\n<line1>int ii;\n<line2>if( exprListIsConstant(pParse,pRow)==0 ) return 0;\n<line3>for(ii=0; ii<pRow->nExpr; ii++){\n<line4>Expr *pExpr = pRow->a[ii].pExpr;\n<line5>assert( pExpr->op!=TK_RAISE );\n<line6>assert( pExpr->affExpr==0 );\n<line7>if( 0!=sqlite3ExprAffinity(pExpr) ) return 0;\n<line8>}\n<line9>return 1;\n<line10>}
----------------------------------------
Function: checkConstraintExprNode
Content: <line0>static int checkConstraintExprNode(Walker *pWalker, Expr *pExpr){\n<line1>if( pExpr->op==TK_COLUMN ){\n<line2>assert( pExpr->iColumn>=0 || pExpr->iColumn==-1 );\n<line3>if( pExpr->iColumn>=0 ){\n<line4>if( pWalker->u.aiCol[pExpr->iColumn]>=0 ){\n<line5>pWalker->eCode |= CKCNSTRNT_COLUMN;\n<line6>}\n<line7>}else{\n<line8>pWalker->eCode |= CKCNSTRNT_ROWID;\n<line9>}\n<line10>}\n<line11>return WRC_Continue;\n<line12>}
----------------------------------------
Function: indexIteratorFirst
Content: <line0>static Index *indexIteratorFirst(IndexIterator *pIter, int *pIx){\n<line1>assert( pIter->i==0 );\n<line2>if( pIter->eType ){\n<line3>*pIx = pIter->u.ax.aIdx[0].ix;\n<line4>return pIter->u.ax.aIdx[0].p;\n<line5>}else{\n<line6>*pIx = 0;\n<line7>return pIter->u.lx.pIdx;\n<line8>}\n<line9>}
----------------------------------------
Function: indexIteratorNext
Content: <line0>static Index *indexIteratorNext(IndexIterator *pIter, int *pIx){\n<line1>if( pIter->eType ){\n<line2>int i = ++pIter->i;\n<line3>if( i>=pIter->u.ax.nIdx ){\n<line4>*pIx = i;\n<line5>return 0;\n<line6>}\n<line7>*pIx = pIter->u.ax.aIdx[i].ix;\n<line8>return pIter->u.ax.aIdx[i].p;\n<line9>}else{\n<line10>++(*pIx);\n<line11>pIter->u.lx.pIdx = pIter->u.lx.pIdx->pNext;\n<line12>return pIter->u.lx.pIdx;\n<line13>}\n<line14>}
----------------------------------------
Function: xferCompatibleIndex
Content: <line0>static int xferCompatibleIndex(Index *pDest, Index *pSrc){\n<line1>int i;\n<line2>assert( pDest && pSrc );\n<line3>assert( pDest->pTable!=pSrc->pTable );\n<line4>if( pDest->nKeyCol!=pSrc->nKeyCol || pDest->nColumn!=pSrc->nColumn ){\n<line5>return 0;   /* Different number of columns */\n<line6>}\n<line7>if( pDest->onError!=pSrc->onError ){\n<line8>return 0;   /* Different conflict resolution strategies */\n<line9>}\n<line10>for(i=0; i<pSrc->nKeyCol; i++){\n<line11>if( pSrc->aiColumn[i]!=pDest->aiColumn[i] ){\n<line12>return 0;   /* Different columns indexed */\n<line13>}\n<line14>if( pSrc->aiColumn[i]==XN_EXPR ){\n<line15>assert( pSrc->aColExpr!=0 && pDest->aColExpr!=0 );\n<line16>if( sqlite3ExprCompare(0, pSrc->aColExpr->a[i].pExpr,\n<line17>pDest->aColExpr->a[i].pExpr, -1)!=0 ){\n<line18>return 0;   /* Different expressions in the index */\n<line19>}\n<line20>}\n<line21>if( pSrc->aSortOrder[i]!=pDest->aSortOrder[i] ){\n<line22>return 0;   /* Different sort orders */\n<line23>}\n<line24>if( sqlite3_stricmp(pSrc->azColl[i],pDest->azColl[i])!=0 ){\n<line25>return 0;   /* Different collating sequences */\n<line26>}\n<line27>}\n<line28>if( sqlite3ExprCompare(0, pSrc->pPartIdxWhere, pDest->pPartIdxWhere, -1) ){\n<line29>return 0;     /* Different WHERE clauses */\n<line30>}\n<line31>/* If no test above fails then the indices must be compatible */\n<line32>return 1;\n<line33>}
----------------------------------------
Function: xferOptimization
Content: <line0>static int xferOptimization(\n<line1>Parse *pParse,        /* Parser context */\n<line2>Table *pDest,         /* The table we are inserting into */\n<line3>Select *pSelect,      /* A SELECT statement to use as the data source */\n<line4>int onError,          /* How to handle constraint errors */\n<line5>int iDbDest           /* The database of pDest */\n<line6>){\n<line7>sqlite3 *db = pParse->db;\n<line8>ExprList *pEList;                /* The result set of the SELECT */\n<line9>Table *pSrc;                     /* The table in the FROM clause of SELECT */\n<line10>Index *pSrcIdx, *pDestIdx;       /* Source and destination indices */\n<line11>SrcItem *pItem;                  /* An element of pSelect->pSrc */\n<line12>int i;                           /* Loop counter */\n<line13>int iDbSrc;                      /* The database of pSrc */\n<line14>int iSrc, iDest;                 /* Cursors from source and destination */\n<line15>int addr1, addr2;                /* Loop addresses */\n<line16>int emptyDestTest = 0;           /* Address of test for empty pDest */\n<line17>int emptySrcTest = 0;            /* Address of test for empty pSrc */\n<line18>Vdbe *v;                         /* The VDBE we are building */\n<line19>int regAutoinc;                  /* Memory register used by AUTOINC */\n<line20>int destHasUniqueIdx = 0;        /* True if pDest has a UNIQUE index */\n<line21>int regData, regRowid;           /* Registers holding data and rowid */\n<line22>assert( pSelect!=0 );\n<line23>if( pParse->pWith || pSelect->pWith ){\n<line24>/* Do not attempt to process this query if there are an WITH clauses\n<line25>** attached to it. Proceeding may generate a false "no such table: xxx"\n<line26>** error if pSelect reads from a CTE named "xxx".  */\n<line27>return 0;\n<line28>}\n<line29>#ifndef SQLITE_OMIT_VIRTUALTABLE\n<line30>if( IsVirtual(pDest) ){\n<line31>return 0;   /* tab1 must not be a virtual table */\n<line32>}\n<line33>#endif\n<line34>if( onError==OE_Default ){\n<line35>if( pDest->iPKey>=0 ) onError = pDest->keyConf;\n<line36>if( onError==OE_Default ) onError = OE_Abort;\n<line37>}\n<line38>assert(pSelect->pSrc);   /* allocated even if there is no FROM clause */\n<line39>if( pSelect->pSrc->nSrc!=1 ){\n<line40>return 0;   /* FROM clause must have exactly one term */\n<line41>}\n<line42>if( pSelect->pSrc->a[0].fg.isSubquery ){\n<line43>return 0;   /* FROM clause cannot contain a subquery */\n<line44>}\n<line45>if( pSelect->pWhere ){\n<line46>return 0;   /* SELECT may not have a WHERE clause */\n<line47>}\n<line48>if( pSelect->pOrderBy ){\n<line49>return 0;   /* SELECT may not have an ORDER BY clause */\n<line50>}\n<line51>/* Do not need to test for a HAVING clause.  If HAVING is present but\n<line52>** there is no ORDER BY, we will get an error. */\n<line53>if( pSelect->pGroupBy ){\n<line54>return 0;   /* SELECT may not have a GROUP BY clause */\n<line55>}\n<line56>if( pSelect->pLimit ){\n<line57>return 0;   /* SELECT may not have a LIMIT clause */\n<line58>}\n<line59>if( pSelect->pPrior ){\n<line60>return 0;   /* SELECT may not be a compound query */\n<line61>}\n<line62>if( pSelect->selFlags & SF_Distinct ){\n<line63>return 0;   /* SELECT may not be DISTINCT */\n<line64>}\n<line65>pEList = pSelect->pEList;\n<line66>assert( pEList!=0 );\n<line67>if( pEList->nExpr!=1 ){\n<line68>return 0;   /* The result set must have exactly one column */\n<line69>}\n<line70>assert( pEList->a[0].pExpr );\n<line71>if( pEList->a[0].pExpr->op!=TK_ASTERISK ){\n<line72>return 0;   /* The result set must be the special operator "*" */\n<line73>}\n<line74>/* At this point we have established that the statement is of the\n<line75>** correct syntactic form to participate in this optimization.  Now\n<line76>** we have to check the semantics.\n<line77>*/\n<line78>pItem = pSelect->pSrc->a;\n<line79>pSrc = sqlite3LocateTableItem(pParse, 0, pItem);\n<line80>if( pSrc==0 ){\n<line81>return 0;   /* FROM clause does not contain a real table */\n<line82>}\n<line83>if( pSrc->tnum==pDest->tnum && pSrc->pSchema==pDest->pSchema ){\n<line84>testcase( pSrc!=pDest ); /* Possible due to bad sqlite_schema.rootpage */\n<line85>return 0;   /* tab1 and tab2 may not be the same table */\n<line86>}\n<line87>if( HasRowid(pDest)!=HasRowid(pSrc) ){\n<line88>return 0;   /* source and destination must both be WITHOUT ROWID or not */\n<line89>}\n<line90>if( !IsOrdinaryTable(pSrc) ){\n<line91>return 0;   /* tab2 may not be a view or virtual table */\n<line92>}\n<line93>if( pDest->nCol!=pSrc->nCol ){\n<line94>return 0;   /* Number of columns must be the same in tab1 and tab2 */\n<line95>}\n<line96>if( pDest->iPKey!=pSrc->iPKey ){\n<line97>return 0;   /* Both tables must have the same INTEGER PRIMARY KEY */\n<line98>}\n<line99>if( (pDest->tabFlags & TF_Strict)!=0 && (pSrc->tabFlags & TF_Strict)==0 ){\n<line100>return 0;   /* Cannot feed from a non-strict into a strict table */\n<line101>}\n<line102>for(i=0; i<pDest->nCol; i++){\n<line103>Column *pDestCol = &pDest->aCol[i];\n<line104>Column *pSrcCol = &pSrc->aCol[i];\n<line105>#ifdef SQLITE_ENABLE_HIDDEN_COLUMNS\n<line106>if( (db->mDbFlags & DBFLAG_Vacuum)==0\n<line107>&& (pDestCol->colFlags | pSrcCol->colFlags) & COLFLAG_HIDDEN\n<line108>){\n<line109>return 0;    /* Neither table may have __hidden__ columns */\n<line110>}\n<line111>#endif\n<line112>#ifndef SQLITE_OMIT_GENERATED_COLUMNS\n<line113>/* Even if tables t1 and t2 have identical schemas, if they contain\n<line114>** generated columns, then this statement is semantically incorrect:\n<line115>**\n<line116>**     INSERT INTO t2 SELECT * FROM t1;\n<line117>**\n<line118>** The reason is that generated column values are returned by the\n<line119>** the SELECT statement on the right but the INSERT statement on the\n<line120>** left wants them to be omitted.\n<line121>**\n<line122>** Nevertheless, this is a useful notational shorthand to tell SQLite\n<line123>** to do a bulk transfer all of the content from t1 over to t2.\n<line124>**\n<line125>** We could, in theory, disable this (except for internal use by the\n<line126>** VACUUM command where it is actually needed).  But why do that?  It\n<line127>** seems harmless enough, and provides a useful service.\n<line128>*/\n<line129>if( (pDestCol->colFlags & COLFLAG_GENERATED) !=\n<line130>(pSrcCol->colFlags & COLFLAG_GENERATED) ){\n<line131>return 0;    /* Both columns have the same generated-column type */\n<line132>}\n<line133>/* But the transfer is only allowed if both the source and destination\n<line134>** tables have the exact same expressions for generated columns.\n<line135>** This requirement could be relaxed for VIRTUAL columns, I suppose.\n<line136>*/\n<line137>if( (pDestCol->colFlags & COLFLAG_GENERATED)!=0 ){\n<line138>if( sqlite3ExprCompare(0,\n<line139>sqlite3ColumnExpr(pSrc, pSrcCol),\n<line140>sqlite3ColumnExpr(pDest, pDestCol), -1)!=0 ){\n<line141>testcase( pDestCol->colFlags & COLFLAG_VIRTUAL );\n<line142>testcase( pDestCol->colFlags & COLFLAG_STORED );\n<line143>return 0;  /* Different generator expressions */\n<line144>}\n<line145>}\n<line146>#endif\n<line147>if( pDestCol->affinity!=pSrcCol->affinity ){\n<line148>return 0;    /* Affinity must be the same on all columns */\n<line149>}\n<line150>if( sqlite3_stricmp(sqlite3ColumnColl(pDestCol),\n<line151>sqlite3ColumnColl(pSrcCol))!=0 ){\n<line152>return 0;    /* Collating sequence must be the same on all columns */\n<line153>}\n<line154>if( pDestCol->notNull && !pSrcCol->notNull ){\n<line155>return 0;    /* tab2 must be NOT NULL if tab1 is */\n<line156>}\n<line157>/* Default values for second and subsequent columns need to match. */\n<line158>if( (pDestCol->colFlags & COLFLAG_GENERATED)==0 && i>0 ){\n<line159>Expr *pDestExpr = sqlite3ColumnExpr(pDest, pDestCol);\n<line160>Expr *pSrcExpr = sqlite3ColumnExpr(pSrc, pSrcCol);\n<line161>assert( pDestExpr==0 || pDestExpr->op==TK_SPAN );\n<line162>assert( pDestExpr==0 || !ExprHasProperty(pDestExpr, EP_IntValue) );\n<line163>assert( pSrcExpr==0 || pSrcExpr->op==TK_SPAN );\n<line164>assert( pSrcExpr==0 || !ExprHasProperty(pSrcExpr, EP_IntValue) );\n<line165>if( (pDestExpr==0)!=(pSrcExpr==0)\n<line166>|| (pDestExpr!=0 && strcmp(pDestExpr->u.zToken,\n<line167>pSrcExpr->u.zToken)!=0)\n<line168>){\n<line169>return 0;    /* Default values must be the same for all columns */\n<line170>}\n<line171>}\n<line172>}\n<line173>for(pDestIdx=pDest->pIndex; pDestIdx; pDestIdx=pDestIdx->pNext){\n<line174>if( IsUniqueIndex(pDestIdx) ){\n<line175>destHasUniqueIdx = 1;\n<line176>}\n<line177>for(pSrcIdx=pSrc->pIndex; pSrcIdx; pSrcIdx=pSrcIdx->pNext){\n<line178>if( xferCompatibleIndex(pDestIdx, pSrcIdx) ) break;\n<line179>}\n<line180>if( pSrcIdx==0 ){\n<line181>return 0;    /* pDestIdx has no corresponding index in pSrc */\n<line182>}\n<line183>if( pSrcIdx->tnum==pDestIdx->tnum && pSrc->pSchema==pDest->pSchema\n<line184>&& sqlite3FaultSim(411)==SQLITE_OK ){\n<line185>/* The sqlite3FaultSim() call allows this corruption test to be\n<line186>** bypassed during testing, in order to exercise other corruption tests\n<line187>** further downstream. */\n<line188>return 0;   /* Corrupt schema - two indexes on the same btree */\n<line189>}\n<line190>}\n<line191>#ifndef SQLITE_OMIT_CHECK\n<line192>if( pDest->pCheck\n<line193>&& (db->mDbFlags & DBFLAG_Vacuum)==0\n<line194>&& sqlite3ExprListCompare(pSrc->pCheck,pDest->pCheck,-1)\n<line195>){\n<line196>return 0;   /* Tables have different CHECK constraints.  Ticket #2252 */\n<line197>}\n<line198>#endif\n<line199>#ifndef SQLITE_OMIT_FOREIGN_KEY\n<line200>/* Disallow the transfer optimization if the destination table contains\n<line201>** any foreign key constraints.  This is more restrictive than necessary.\n<line202>** But the main beneficiary of the transfer optimization is the VACUUM\n<line203>** command, and the VACUUM command disables foreign key constraints.  So\n<line204>** the extra complication to make this rule less restrictive is probably\n<line205>** not worth the effort.  Ticket [6284df89debdfa61db8073e062908af0c9b6118e]\n<line206>*/\n<line207>assert( IsOrdinaryTable(pDest) );\n<line208>if( (db->flags & SQLITE_ForeignKeys)!=0 && pDest->u.tab.pFKey!=0 ){\n<line209>return 0;\n<line210>}\n<line211>#endif\n<line212>if( (db->flags & SQLITE_CountRows)!=0 ){\n<line213>return 0;  /* xfer opt does not play well with PRAGMA count_changes */\n<line214>}\n<line215>/* If we get this far, it means that the xfer optimization is at\n<line216>** least a possibility, though it might only work if the destination\n<line217>** table (tab1) is initially empty.\n<line218>*/\n<line219>#ifdef SQLITE_TEST\n<line220>sqlite3_xferopt_count++;\n<line221>#endif\n<line222>iDbSrc = sqlite3SchemaToIndex(db, pSrc->pSchema);\n<line223>v = sqlite3GetVdbe(pParse);\n<line224>sqlite3CodeVerifySchema(pParse, iDbSrc);\n<line225>iSrc = pParse->nTab++;\n<line226>iDest = pParse->nTab++;\n<line227>regAutoinc = autoIncBegin(pParse, iDbDest, pDest);\n<line228>regData = sqlite3GetTempReg(pParse);\n<line229>sqlite3VdbeAddOp2(v, OP_Null, 0, regData);\n<line230>regRowid = sqlite3GetTempReg(pParse);\n<line231>sqlite3OpenTable(pParse, iDest, iDbDest, pDest, OP_OpenWrite);\n<line232>assert( HasRowid(pDest) || destHasUniqueIdx );\n<line233>if( (db->mDbFlags & DBFLAG_Vacuum)==0 && (\n<line234>(pDest->iPKey<0 && pDest->pIndex!=0)          /* (1) */\n<line235>|| destHasUniqueIdx                              /* (2) */\n<line236>|| (onError!=OE_Abort && onError!=OE_Rollback)   /* (3) */\n<line237>)){\n<line238>/* In some circumstances, we are able to run the xfer optimization\n<line239>** only if the destination table is initially empty. Unless the\n<line240>** DBFLAG_Vacuum flag is set, this block generates code to make\n<line241>** that determination. If DBFLAG_Vacuum is set, then the destination\n<line242>** table is always empty.\n<line243>**\n<line244>** Conditions under which the destination must be empty:\n<line245>**\n<line246>** (1) There is no INTEGER PRIMARY KEY but there are indices.\n<line247>**     (If the destination is not initially empty, the rowid fields\n<line248>**     of index entries might need to change.)\n<line249>**\n<line250>** (2) The destination has a unique index.  (The xfer optimization\n<line251>**     is unable to test uniqueness.)\n<line252>**\n<line253>** (3) onError is something other than OE_Abort and OE_Rollback.\n<line254>*/\n<line255>addr1 = sqlite3VdbeAddOp2(v, OP_Rewind, iDest, 0); VdbeCoverage(v);\n<line256>emptyDestTest = sqlite3VdbeAddOp0(v, OP_Goto);\n<line257>sqlite3VdbeJumpHere(v, addr1);\n<line258>}\n<line259>if( HasRowid(pSrc) ){\n<line260>u8 insFlags;\n<line261>sqlite3OpenTable(pParse, iSrc, iDbSrc, pSrc, OP_OpenRead);\n<line262>emptySrcTest = sqlite3VdbeAddOp2(v, OP_Rewind, iSrc, 0); VdbeCoverage(v);\n<line263>if( pDest->iPKey>=0 ){\n<line264>addr1 = sqlite3VdbeAddOp2(v, OP_Rowid, iSrc, regRowid);\n<line265>if( (db->mDbFlags & DBFLAG_Vacuum)==0 ){\n<line266>sqlite3VdbeVerifyAbortable(v, onError);\n<line267>addr2 = sqlite3VdbeAddOp3(v, OP_NotExists, iDest, 0, regRowid);\n<line268>VdbeCoverage(v);\n<line269>sqlite3RowidConstraint(pParse, onError, pDest);\n<line270>sqlite3VdbeJumpHere(v, addr2);\n<line271>}\n<line272>autoIncStep(pParse, regAutoinc, regRowid);\n<line273>}else if( pDest->pIndex==0 && !(db->mDbFlags & DBFLAG_VacuumInto) ){\n<line274>addr1 = sqlite3VdbeAddOp2(v, OP_NewRowid, iDest, regRowid);\n<line275>}else{\n<line276>addr1 = sqlite3VdbeAddOp2(v, OP_Rowid, iSrc, regRowid);\n<line277>assert( (pDest->tabFlags & TF_Autoincrement)==0 );\n<line278>}\n<line279>if( db->mDbFlags & DBFLAG_Vacuum ){\n<line280>sqlite3VdbeAddOp1(v, OP_SeekEnd, iDest);\n<line281>insFlags = OPFLAG_APPEND|OPFLAG_USESEEKRESULT|OPFLAG_PREFORMAT;\n<line282>}else{\n<line283>insFlags = OPFLAG_NCHANGE|OPFLAG_LASTROWID|OPFLAG_APPEND|OPFLAG_PREFORMAT;\n<line284>}\n<line285>#ifdef SQLITE_ENABLE_PREUPDATE_HOOK\n<line286>if( (db->mDbFlags & DBFLAG_Vacuum)==0 ){\n<line287>sqlite3VdbeAddOp3(v, OP_RowData, iSrc, regData, 1);\n<line288>insFlags &= ~OPFLAG_PREFORMAT;\n<line289>}else\n<line290>#endif\n<line291>{\n<line292>sqlite3VdbeAddOp3(v, OP_RowCell, iDest, iSrc, regRowid);\n<line293>}\n<line294>sqlite3VdbeAddOp3(v, OP_Insert, iDest, regData, regRowid);\n<line295>if( (db->mDbFlags & DBFLAG_Vacuum)==0 ){\n<line296>sqlite3VdbeChangeP4(v, -1, (char*)pDest, P4_TABLE);\n<line297>}\n<line298>sqlite3VdbeChangeP5(v, insFlags);\n<line299>sqlite3VdbeAddOp2(v, OP_Next, iSrc, addr1); VdbeCoverage(v);\n<line300>sqlite3VdbeAddOp2(v, OP_Close, iSrc, 0);\n<line301>sqlite3VdbeAddOp2(v, OP_Close, iDest, 0);\n<line302>}else{\n<line303>sqlite3TableLock(pParse, iDbDest, pDest->tnum, 1, pDest->zName);\n<line304>sqlite3TableLock(pParse, iDbSrc, pSrc->tnum, 0, pSrc->zName);\n<line305>}\n<line306>for(pDestIdx=pDest->pIndex; pDestIdx; pDestIdx=pDestIdx->pNext){\n<line307>u8 idxInsFlags = 0;\n<line308>for(pSrcIdx=pSrc->pIndex; ALWAYS(pSrcIdx); pSrcIdx=pSrcIdx->pNext){\n<line309>if( xferCompatibleIndex(pDestIdx, pSrcIdx) ) break;\n<line310>}\n<line311>assert( pSrcIdx );\n<line312>sqlite3VdbeAddOp3(v, OP_OpenRead, iSrc, pSrcIdx->tnum, iDbSrc);\n<line313>sqlite3VdbeSetP4KeyInfo(pParse, pSrcIdx);\n<line314>VdbeComment((v, "%s", pSrcIdx->zName));\n<line315>sqlite3VdbeAddOp3(v, OP_OpenWrite, iDest, pDestIdx->tnum, iDbDest);\n<line316>sqlite3VdbeSetP4KeyInfo(pParse, pDestIdx);\n<line317>sqlite3VdbeChangeP5(v, OPFLAG_BULKCSR);\n<line318>VdbeComment((v, "%s", pDestIdx->zName));\n<line319>addr1 = sqlite3VdbeAddOp2(v, OP_Rewind, iSrc, 0); VdbeCoverage(v);\n<line320>if( db->mDbFlags & DBFLAG_Vacuum ){\n<line321>/* This INSERT command is part of a VACUUM operation, which guarantees\n<line322>** that the destination table is empty. If all indexed columns use\n<line323>** collation sequence BINARY, then it can also be assumed that the\n<line324>** index will be populated by inserting keys in strictly sorted\n<line325>** order. In this case, instead of seeking within the b-tree as part\n<line326>** of every OP_IdxInsert opcode, an OP_SeekEnd is added before the\n<line327>** OP_IdxInsert to seek to the point within the b-tree where each key\n<line328>** should be inserted. This is faster.\n<line329>**\n<line330>** If any of the indexed columns use a collation sequence other than\n<line331>** BINARY, this optimization is disabled. This is because the user\n<line332>** might change the definition of a collation sequence and then run\n<line333>** a VACUUM command. In that case keys may not be written in strictly\n<line334>** sorted order.  */\n<line335>for(i=0; i<pSrcIdx->nColumn; i++){\n<line336>const char *zColl = pSrcIdx->azColl[i];\n<line337>if( sqlite3_stricmp(sqlite3StrBINARY, zColl) ) break;\n<line338>}\n<line339>if( i==pSrcIdx->nColumn ){\n<line340>idxInsFlags = OPFLAG_USESEEKRESULT|OPFLAG_PREFORMAT;\n<line341>sqlite3VdbeAddOp1(v, OP_SeekEnd, iDest);\n<line342>sqlite3VdbeAddOp2(v, OP_RowCell, iDest, iSrc);\n<line343>}\n<line344>}else if( !HasRowid(pSrc) && pDestIdx->idxType==SQLITE_IDXTYPE_PRIMARYKEY ){\n<line345>idxInsFlags |= OPFLAG_NCHANGE;\n<line346>}\n<line347>if( idxInsFlags!=(OPFLAG_USESEEKRESULT|OPFLAG_PREFORMAT) ){\n<line348>sqlite3VdbeAddOp3(v, OP_RowData, iSrc, regData, 1);\n<line349>if( (db->mDbFlags & DBFLAG_Vacuum)==0\n<line350>&& !HasRowid(pDest)\n<line351>&& IsPrimaryKeyIndex(pDestIdx)\n<line352>){\n<line353>codeWithoutRowidPreupdate(pParse, pDest, iDest, regData);\n<line354>}\n<line355>}\n<line356>sqlite3VdbeAddOp2(v, OP_IdxInsert, iDest, regData);\n<line357>sqlite3VdbeChangeP5(v, idxInsFlags|OPFLAG_APPEND);\n<line358>sqlite3VdbeAddOp2(v, OP_Next, iSrc, addr1+1); VdbeCoverage(v);\n<line359>sqlite3VdbeJumpHere(v, addr1);\n<line360>sqlite3VdbeAddOp2(v, OP_Close, iSrc, 0);\n<line361>sqlite3VdbeAddOp2(v, OP_Close, iDest, 0);\n<line362>}\n<line363>if( emptySrcTest ) sqlite3VdbeJumpHere(v, emptySrcTest);\n<line364>sqlite3ReleaseTempReg(pParse, regRowid);\n<line365>sqlite3ReleaseTempReg(pParse, regData);\n<line366>if( emptyDestTest ){\n<line367>sqlite3AutoincrementEnd(pParse);\n<line368>sqlite3VdbeAddOp2(v, OP_Halt, SQLITE_OK, 0);\n<line369>sqlite3VdbeJumpHere(v, emptyDestTest);\n<line370>sqlite3VdbeAddOp2(v, OP_Close, iDest, 0);\n<line371>return 0;\n<line372>}else{\n<line373>return 1;\n<line374>}\n<line375>}
----------------------------------------
Function: sqlite3_exec
Content: <line0>SQLITE_API int sqlite3_exec(\n<line1>sqlite3 *db,                /* The database on which the SQL executes */\n<line2>const char *zSql,           /* The SQL to be executed */\n<line3>sqlite3_callback xCallback, /* Invoke this callback routine */\n<line4>void *pArg,                 /* First argument to xCallback() */\n<line5>char **pzErrMsg             /* Write error messages here */\n<line6>){\n<line7>int rc = SQLITE_OK;         /* Return code */\n<line8>const char *zLeftover;      /* Tail of unprocessed SQL */\n<line9>sqlite3_stmt *pStmt = 0;    /* The current SQL statement */\n<line10>char **azCols = 0;          /* Names of result columns */\n<line11>int callbackIsInit;         /* True if callback data is initialized */\n<line12>if( !sqlite3SafetyCheckOk(db) ) return SQLITE_MISUSE_BKPT;\n<line13>if( zSql==0 ) zSql = "";\n<line14>sqlite3_mutex_enter(db->mutex);\n<line15>sqlite3Error(db, SQLITE_OK);\n<line16>while( rc==SQLITE_OK && zSql[0] ){\n<line17>int nCol = 0;\n<line18>char **azVals = 0;\n<line19>pStmt = 0;\n<line20>rc = sqlite3_prepare_v2(db, zSql, -1, &pStmt, &zLeftover);\n<line21>assert( rc==SQLITE_OK || pStmt==0 );\n<line22>if( rc!=SQLITE_OK ){\n<line23>continue;\n<line24>}\n<line25>if( !pStmt ){\n<line26>/* this happens for a comment or white-space */\n<line27>zSql = zLeftover;\n<line28>continue;\n<line29>}\n<line30>callbackIsInit = 0;\n<line31>while( 1 ){\n<line32>int i;\n<line33>rc = sqlite3_step(pStmt);\n<line34>/* Invoke the callback function if required */\n<line35>if( xCallback && (SQLITE_ROW==rc ||\n<line36>(SQLITE_DONE==rc && !callbackIsInit\n<line37>&& db->flags&SQLITE_NullCallback)) ){\n<line38>if( !callbackIsInit ){\n<line39>nCol = sqlite3_column_count(pStmt);\n<line40>azCols = sqlite3DbMallocRaw(db, (2*nCol+1)*sizeof(const char*));\n<line41>if( azCols==0 ){\n<line42>goto exec_out;\n<line43>}\n<line44>for(i=0; i<nCol; i++){\n<line45>azCols[i] = (char *)sqlite3_column_name(pStmt, i);\n<line46>/* sqlite3VdbeSetColName() installs column names as UTF8\n<line47>** strings so there is no way for sqlite3_column_name() to fail. */\n<line48>assert( azCols[i]!=0 );\n<line49>}\n<line50>callbackIsInit = 1;\n<line51>}\n<line52>if( rc==SQLITE_ROW ){\n<line53>azVals = &azCols[nCol];\n<line54>for(i=0; i<nCol; i++){\n<line55>azVals[i] = (char *)sqlite3_column_text(pStmt, i);\n<line56>if( !azVals[i] && sqlite3_column_type(pStmt, i)!=SQLITE_NULL ){\n<line57>sqlite3OomFault(db);\n<line58>goto exec_out;\n<line59>}\n<line60>}\n<line61>azVals[i] = 0;\n<line62>}\n<line63>if( xCallback(pArg, nCol, azVals, azCols) ){\n<line64>/* EVIDENCE-OF: R-38229-40159 If the callback function to\n<line65>** sqlite3_exec() returns non-zero, then sqlite3_exec() will\n<line66>** return SQLITE_ABORT. */\n<line67>rc = SQLITE_ABORT;\n<line68>sqlite3VdbeFinalize((Vdbe *)pStmt);\n<line69>pStmt = 0;\n<line70>sqlite3Error(db, SQLITE_ABORT);\n<line71>goto exec_out;\n<line72>}\n<line73>}\n<line74>if( rc!=SQLITE_ROW ){\n<line75>rc = sqlite3VdbeFinalize((Vdbe *)pStmt);\n<line76>pStmt = 0;\n<line77>zSql = zLeftover;\n<line78>while( sqlite3Isspace(zSql[0]) ) zSql++;\n<line79>break;\n<line80>}\n<line81>}\n<line82>sqlite3DbFree(db, azCols);\n<line83>azCols = 0;\n<line84>}\n<line85>exec_out:\n<line86>if( pStmt ) sqlite3VdbeFinalize((Vdbe *)pStmt);\n<line87>sqlite3DbFree(db, azCols);\n<line88>rc = sqlite3ApiExit(db, rc);\n<line89>if( rc!=SQLITE_OK && pzErrMsg ){\n<line90>*pzErrMsg = sqlite3DbStrDup(0, sqlite3_errmsg(db));\n<line91>if( *pzErrMsg==0 ){\n<line92>rc = SQLITE_NOMEM_BKPT;\n<line93>sqlite3Error(db, SQLITE_NOMEM);\n<line94>}\n<line95>}else if( pzErrMsg ){\n<line96>*pzErrMsg = 0;\n<line97>}\n<line98>assert( (rc&db->errMask)==rc );\n<line99>sqlite3_mutex_leave(db->mutex);\n<line100>return rc;\n<line101>}
----------------------------------------
Function: sqlite3LoadExtension
Content: <line0>static int sqlite3LoadExtension(\n<line1>sqlite3 *db,          /* Load the extension into this database connection */\n<line2>const char *zFile,    /* Name of the shared library containing extension */\n<line3>const char *zProc,    /* Entry point.  Use "sqlite3_extension_init" if 0 */\n<line4>char **pzErrMsg       /* Put error message here if not 0 */\n<line5>){\n<line6>sqlite3_vfs *pVfs = db->pVfs;\n<line7>void *handle;\n<line8>sqlite3_loadext_entry xInit;\n<line9>char *zErrmsg = 0;\n<line10>const char *zEntry;\n<line11>char *zAltEntry = 0;\n<line12>void **aHandle;\n<line13>u64 nMsg = strlen(zFile);\n<line14>int ii;\n<line15>int rc;\n<line16>/* Shared library endings to try if zFile cannot be loaded as written */\n<line17>static const char *azEndings[] = {\n<line18>#if SQLITE_OS_WIN\n<line19>"dll"\n<line20>#elif defined(__APPLE__)\n<line21>"dylib"\n<line22>#else\n<line23>"so"\n<line24>#endif\n<line25>};\n<line26>if( pzErrMsg ) *pzErrMsg = 0;\n<line27>/* Ticket #1863.  To avoid a creating security problems for older\n<line28>** applications that relink against newer versions of SQLite, the\n<line29>** ability to run load_extension is turned off by default.  One\n<line30>** must call either sqlite3_enable_load_extension(db) or\n<line31>** sqlite3_db_config(db, SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION, 1, 0)\n<line32>** to turn on extension loading.\n<line33>*/\n<line34>if( (db->flags & SQLITE_LoadExtension)==0 ){\n<line35>if( pzErrMsg ){\n<line36>*pzErrMsg = sqlite3_mprintf("not authorized");\n<line37>}\n<line38>return SQLITE_ERROR;\n<line39>}\n<line40>zEntry = zProc ? zProc : "sqlite3_extension_init";\n<line41>/* tag-20210611-1.  Some dlopen() implementations will segfault if given\n<line42>** an oversize filename.  Most filesystems have a pathname limit of 4K,\n<line43>** so limit the extension filename length to about twice that.\n<line44>** https://sqlite.org/forum/forumpost/08a0d6d9bf\n<line45>**\n<line46>** Later (2023-03-25): Save an extra 6 bytes for the filename suffix.\n<line47>** See https://sqlite.org/forum/forumpost/24083b579d.\n<line48>*/\n<line49>if( nMsg>SQLITE_MAX_PATHLEN ) goto extension_not_found;\n<line50>/* Do not allow sqlite3_load_extension() to link to a copy of the\n<line51>** running application, by passing in an empty filename. */\n<line52>if( nMsg==0 ) goto extension_not_found;\n<line53>handle = sqlite3OsDlOpen(pVfs, zFile);\n<line54>#if SQLITE_OS_UNIX || SQLITE_OS_WIN\n<line55>for(ii=0; ii<ArraySize(azEndings) && handle==0; ii++){\n<line56>char *zAltFile = sqlite3_mprintf("%s.%s", zFile, azEndings[ii]);\n<line57>if( zAltFile==0 ) return SQLITE_NOMEM_BKPT;\n<line58>if( nMsg+strlen(azEndings[ii])+1<=SQLITE_MAX_PATHLEN ){\n<line59>handle = sqlite3OsDlOpen(pVfs, zAltFile);\n<line60>}\n<line61>sqlite3_free(zAltFile);\n<line62>}\n<line63>#endif\n<line64>if( handle==0 ) goto extension_not_found;\n<line65>xInit = (sqlite3_loadext_entry)sqlite3OsDlSym(pVfs, handle, zEntry);\n<line66>/* If no entry point was specified and the default legacy\n<line67>** entry point name "sqlite3_extension_init" was not found, then\n<line68>** construct an entry point name "sqlite3_X_init" where the X is\n<line69>** replaced by the lowercase value of every ASCII alphabetic\n<line70>** character in the filename after the last "/" upto the first ".",\n<line71>** and eliding the first three characters if they are "lib".\n<line72>** Examples:\n<line73>**\n<line74>**    /usr/local/lib/libExample5.4.3.so ==>  sqlite3_example_init\n<line75>**    C:/lib/mathfuncs.dll              ==>  sqlite3_mathfuncs_init\n<line76>*/\n<line77>if( xInit==0 && zProc==0 ){\n<line78>int iFile, iEntry, c;\n<line79>int ncFile = sqlite3Strlen30(zFile);\n<line80>zAltEntry = sqlite3_malloc64(ncFile+30);\n<line81>if( zAltEntry==0 ){\n<line82>sqlite3OsDlClose(pVfs, handle);\n<line83>return SQLITE_NOMEM_BKPT;\n<line84>}\n<line85>memcpy(zAltEntry, "sqlite3_", 8);\n<line86>for(iFile=ncFile-1; iFile>=0 && !DirSep(zFile[iFile]); iFile--){}\n<line87>iFile++;\n<line88>if( sqlite3_strnicmp(zFile+iFile, "lib", 3)==0 ) iFile += 3;\n<line89>for(iEntry=8; (c = zFile[iFile])!=0 && c!='.'; iFile++){\n<line90>if( sqlite3Isalpha(c) ){\n<line91>zAltEntry[iEntry++] = (char)sqlite3UpperToLower[(unsigned)c];\n<line92>}\n<line93>}\n<line94>memcpy(zAltEntry+iEntry, "_init", 6);\n<line95>zEntry = zAltEntry;\n<line96>xInit = (sqlite3_loadext_entry)sqlite3OsDlSym(pVfs, handle, zEntry);\n<line97>}\n<line98>if( xInit==0 ){\n<line99>if( pzErrMsg ){\n<line100>nMsg += strlen(zEntry) + 300;\n<line101>*pzErrMsg = zErrmsg = sqlite3_malloc64(nMsg);\n<line102>if( zErrmsg ){\n<line103>assert( nMsg<0x7fffffff );  /* zErrmsg would be NULL if not so */\n<line104>sqlite3_snprintf((int)nMsg, zErrmsg,\n<line105>"no entry point [%s] in shared library [%s]", zEntry, zFile);\n<line106>sqlite3OsDlError(pVfs, nMsg-1, zErrmsg);\n<line107>}\n<line108>}\n<line109>sqlite3OsDlClose(pVfs, handle);\n<line110>sqlite3_free(zAltEntry);\n<line111>return SQLITE_ERROR;\n<line112>}\n<line113>sqlite3_free(zAltEntry);\n<line114>rc = xInit(db, &zErrmsg, &sqlite3Apis);\n<line115>if( rc ){\n<line116>if( rc==SQLITE_OK_LOAD_PERMANENTLY ) return SQLITE_OK;\n<line117>if( pzErrMsg ){\n<line118>*pzErrMsg = sqlite3_mprintf("error during initialization: %s", zErrmsg);\n<line119>}\n<line120>sqlite3_free(zErrmsg);\n<line121>sqlite3OsDlClose(pVfs, handle);\n<line122>return SQLITE_ERROR;\n<line123>}\n<line124>/* Append the new shared library handle to the db->aExtension array. */\n<line125>aHandle = sqlite3DbMallocZero(db, sizeof(handle)*(db->nExtension+1));\n<line126>if( aHandle==0 ){\n<line127>return SQLITE_NOMEM_BKPT;\n<line128>}\n<line129>if( db->nExtension>0 ){\n<line130>memcpy(aHandle, db->aExtension, sizeof(handle)*db->nExtension);\n<line131>}\n<line132>sqlite3DbFree(db, db->aExtension);\n<line133>db->aExtension = aHandle;\n<line134>db->aExtension[db->nExtension++] = handle;\n<line135>return SQLITE_OK;\n<line136>extension_not_found:\n<line137>if( pzErrMsg ){\n<line138>nMsg += 300;\n<line139>*pzErrMsg = zErrmsg = sqlite3_malloc64(nMsg);\n<line140>if( zErrmsg ){\n<line141>assert( nMsg<0x7fffffff );  /* zErrmsg would be NULL if not so */\n<line142>sqlite3_snprintf((int)nMsg, zErrmsg,\n<line143>"unable to open shared library [%.*s]", SQLITE_MAX_PATHLEN, zFile);\n<line144>sqlite3OsDlError(pVfs, nMsg-1, zErrmsg);\n<line145>}\n<line146>}\n<line147>return SQLITE_ERROR;\n<line148>}
----------------------------------------
Function: sqlite3_load_extension
Content: <line0>SQLITE_API int sqlite3_load_extension(\n<line1>sqlite3 *db,          /* Load the extension into this database connection */\n<line2>const char *zFile,    /* Name of the shared library containing extension */\n<line3>const char *zProc,    /* Entry point.  Use "sqlite3_extension_init" if 0 */\n<line4>char **pzErrMsg       /* Put error message here if not 0 */\n<line5>){\n<line6>int rc;\n<line7>sqlite3_mutex_enter(db->mutex);\n<line8>rc = sqlite3LoadExtension(db, zFile, zProc, pzErrMsg);\n<line9>rc = sqlite3ApiExit(db, rc);\n<line10>sqlite3_mutex_leave(db->mutex);\n<line11>return rc;\n<line12>}
----------------------------------------
Function: sqlite3_enable_load_extension
Content: <line0>SQLITE_API int sqlite3_enable_load_extension(sqlite3 *db, int onoff){\n<line1>#ifdef SQLITE_ENABLE_API_ARMOR\n<line2>if( !sqlite3SafetyCheckOk(db) ) return SQLITE_MISUSE_BKPT;\n<line3>#endif\n<line4>sqlite3_mutex_enter(db->mutex);\n<line5>if( onoff ){\n<line6>db->flags |= SQLITE_LoadExtension|SQLITE_LoadExtFunc;\n<line7>}else{\n<line8>db->flags &= ~(u64)(SQLITE_LoadExtension|SQLITE_LoadExtFunc);\n<line9>}\n<line10>sqlite3_mutex_leave(db->mutex);\n<line11>return SQLITE_OK;\n<line12>}
----------------------------------------
Function: sqlite3_auto_extension
Content: <line0>SQLITE_API int sqlite3_auto_extension(\n<line1>void (*xInit)(void)\n<line2>){\n<line3>int rc = SQLITE_OK;\n<line4>#ifdef SQLITE_ENABLE_API_ARMOR\n<line5>if( xInit==0 ) return SQLITE_MISUSE_BKPT;\n<line6>#endif\n<line7>#ifndef SQLITE_OMIT_AUTOINIT\n<line8>rc = sqlite3_initialize();\n<line9>if( rc ){\n<line10>return rc;\n<line11>}else\n<line12>#endif\n<line13>{\n<line14>u32 i;\n<line15>#if SQLITE_THREADSAFE\n<line16>sqlite3_mutex *mutex = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MAIN);\n<line17>#endif\n<line18>wsdAutoextInit;\n<line19>sqlite3_mutex_enter(mutex);\n<line20>for(i=0; i<wsdAutoext.nExt; i++){\n<line21>if( wsdAutoext.aExt[i]==xInit ) break;\n<line22>}\n<line23>if( i==wsdAutoext.nExt ){\n<line24>u64 nByte = (wsdAutoext.nExt+1)*sizeof(wsdAutoext.aExt[0]);\n<line25>void (**aNew)(void);\n<line26>aNew = sqlite3_realloc64(wsdAutoext.aExt, nByte);\n<line27>if( aNew==0 ){\n<line28>rc = SQLITE_NOMEM_BKPT;\n<line29>}else{\n<line30>wsdAutoext.aExt = aNew;\n<line31>wsdAutoext.aExt[wsdAutoext.nExt] = xInit;\n<line32>wsdAutoext.nExt++;\n<line33>}\n<line34>}\n<line35>sqlite3_mutex_leave(mutex);\n<line36>assert( (rc&0xff)==rc );\n<line37>return rc;\n<line38>}\n<line39>}
----------------------------------------
Function: sqlite3_cancel_auto_extension
Content: <line0>SQLITE_API int sqlite3_cancel_auto_extension(\n<line1>void (*xInit)(void)\n<line2>){\n<line3>#if SQLITE_THREADSAFE\n<line4>sqlite3_mutex *mutex = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MAIN);\n<line5>#endif\n<line6>int i;\n<line7>int n = 0;\n<line8>wsdAutoextInit;\n<line9>#ifdef SQLITE_ENABLE_API_ARMOR\n<line10>if( xInit==0 ) return 0;\n<line11>#endif\n<line12>sqlite3_mutex_enter(mutex);\n<line13>for(i=(int)wsdAutoext.nExt-1; i>=0; i--){\n<line14>if( wsdAutoext.aExt[i]==xInit ){\n<line15>wsdAutoext.nExt--;\n<line16>wsdAutoext.aExt[i] = wsdAutoext.aExt[wsdAutoext.nExt];\n<line17>n++;\n<line18>break;\n<line19>}\n<line20>}\n<line21>sqlite3_mutex_leave(mutex);\n<line22>return n;\n<line23>}
----------------------------------------
Function: sqlite3_reset_auto_extension
Content: <line0>SQLITE_API void sqlite3_reset_auto_extension(void){\n<line1>#ifndef SQLITE_OMIT_AUTOINIT\n<line2>if( sqlite3_initialize()==SQLITE_OK )\n<line3>#endif\n<line4>{\n<line5>#if SQLITE_THREADSAFE\n<line6>sqlite3_mutex *mutex = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MAIN);\n<line7>#endif\n<line8>wsdAutoextInit;\n<line9>sqlite3_mutex_enter(mutex);\n<line10>sqlite3_free(wsdAutoext.aExt);\n<line11>wsdAutoext.aExt = 0;\n<line12>wsdAutoext.nExt = 0;\n<line13>sqlite3_mutex_leave(mutex);\n<line14>}\n<line15>}
----------------------------------------
Function: getSafetyLevel
Content: <line0>static u8 getSafetyLevel(const char *z, int omitFull, u8 dflt){\n<line1>/* 123456789 123456789 123 */\n<line2>static const char zText[] = "onoffalseyestruextrafull";\n<line3>static const u8 iOffset[] = {0, 1, 2,  4,    9,  12,  15,   20};\n<line4>static const u8 iLength[] = {2, 2, 3,  5,    3,   4,   5,    4};\n<line5>static const u8 iValue[] =  {1, 0, 0,  0,    1,   1,   3,    2};\n<line6>/* on no off false yes true extra full */\n<line7>int i, n;\n<line8>if( sqlite3Isdigit(*z) ){\n<line9>return (u8)sqlite3Atoi(z);\n<line10>}\n<line11>n = sqlite3Strlen30(z);\n<line12>for(i=0; i<ArraySize(iLength); i++){\n<line13>if( iLength[i]==n && sqlite3StrNICmp(&zText[iOffset[i]],z,n)==0\n<line14>&& (!omitFull || iValue[i]<=1)\n<line15>){\n<line16>return iValue[i];\n<line17>}\n<line18>}\n<line19>return dflt;\n<line20>}
----------------------------------------
Function: getLockingMode
Content: <line0>static int getLockingMode(const char *z){\n<line1>if( z ){\n<line2>if( 0==sqlite3StrICmp(z, "exclusive") ) return PAGER_LOCKINGMODE_EXCLUSIVE;\n<line3>if( 0==sqlite3StrICmp(z, "normal") ) return PAGER_LOCKINGMODE_NORMAL;\n<line4>}\n<line5>return PAGER_LOCKINGMODE_QUERY;\n<line6>}
----------------------------------------
Function: getAutoVacuum
Content: <line0>static int getAutoVacuum(const char *z){\n<line1>int i;\n<line2>if( 0==sqlite3StrICmp(z, "none") ) return BTREE_AUTOVACUUM_NONE;\n<line3>if( 0==sqlite3StrICmp(z, "full") ) return BTREE_AUTOVACUUM_FULL;\n<line4>if( 0==sqlite3StrICmp(z, "incremental") ) return BTREE_AUTOVACUUM_INCR;\n<line5>i = sqlite3Atoi(z);\n<line6>return (u8)((i>=0&&i<=2)?i:0);\n<line7>}
----------------------------------------
Function: getTempStore
Content: <line0>static int getTempStore(const char *z){\n<line1>if( z[0]>='0' && z[0]<='2' ){\n<line2>return z[0] - '0';\n<line3>}else if( sqlite3StrICmp(z, "file")==0 ){\n<line4>return 1;\n<line5>}else if( sqlite3StrICmp(z, "memory")==0 ){\n<line6>return 2;\n<line7>}else{\n<line8>return 0;\n<line9>}\n<line10>}
----------------------------------------
Function: invalidateTempStorage
Content: <line0>static int invalidateTempStorage(Parse *pParse){\n<line1>sqlite3 *db = pParse->db;\n<line2>if( db->aDb[1].pBt!=0 ){\n<line3>if( !db->autoCommit\n<line4>|| sqlite3BtreeTxnState(db->aDb[1].pBt)!=SQLITE_TXN_NONE\n<line5>){\n<line6>sqlite3ErrorMsg(pParse, "temporary storage cannot be changed "\n<line7>"from within a transaction");\n<line8>return SQLITE_ERROR;\n<line9>}\n<line10>sqlite3BtreeClose(db->aDb[1].pBt);\n<line11>db->aDb[1].pBt = 0;\n<line12>sqlite3ResetAllSchemasOfConnection(db);\n<line13>}\n<line14>return SQLITE_OK;\n<line15>}
----------------------------------------
Function: changeTempStorage
Content: <line0>static int changeTempStorage(Parse *pParse, const char *zStorageType){\n<line1>int ts = getTempStore(zStorageType);\n<line2>sqlite3 *db = pParse->db;\n<line3>if( db->temp_store==ts ) return SQLITE_OK;\n<line4>if( invalidateTempStorage( pParse ) != SQLITE_OK ){\n<line5>return SQLITE_ERROR;\n<line6>}\n<line7>db->temp_store = (u8)ts;\n<line8>return SQLITE_OK;\n<line9>}
----------------------------------------
Function: setPragmaResultColumnNames
Content: <line0>static void setPragmaResultColumnNames(\n<line1>Vdbe *v,                     /* The query under construction */\n<line2>const PragmaName *pPragma    /* The pragma */\n<line3>){\n<line4>u8 n = pPragma->nPragCName;\n<line5>sqlite3VdbeSetNumCols(v, n==0 ? 1 : n);\n<line6>if( n==0 ){\n<line7>sqlite3VdbeSetColName(v, 0, COLNAME_NAME, pPragma->zName, SQLITE_STATIC);\n<line8>}else{\n<line9>int i, j;\n<line10>for(i=0, j=pPragma->iPragCName; i<n; i++, j++){\n<line11>sqlite3VdbeSetColName(v, i, COLNAME_NAME, pragCName[j], SQLITE_STATIC);\n<line12>}\n<line13>}\n<line14>}
----------------------------------------
Function: returnSingleInt
Content: <line0>static void returnSingleInt(Vdbe *v, i64 value){\n<line1>sqlite3VdbeAddOp4Dup8(v, OP_Int64, 0, 1, 0, (const u8*)&value, P4_INT64);\n<line2>sqlite3VdbeAddOp2(v, OP_ResultRow, 1, 1);\n<line3>}
----------------------------------------
Function: returnSingleText
Content: <line0>static void returnSingleText(\n<line1>Vdbe *v,                /* Prepared statement under construction */\n<line2>const char *zValue      /* Value to be returned */\n<line3>){\n<line4>if( zValue ){\n<line5>sqlite3VdbeLoadString(v, 1, (const char*)zValue);\n<line6>sqlite3VdbeAddOp2(v, OP_ResultRow, 1, 1);\n<line7>}\n<line8>}
----------------------------------------
Function: setAllPagerFlags
Content: <line0>static void setAllPagerFlags(sqlite3 *db){\n<line1>if( db->autoCommit ){\n<line2>Db *pDb = db->aDb;\n<line3>int n = db->nDb;\n<line4>assert( SQLITE_FullFSync==PAGER_FULLFSYNC );\n<line5>assert( SQLITE_CkptFullFSync==PAGER_CKPT_FULLFSYNC );\n<line6>assert( SQLITE_CacheSpill==PAGER_CACHESPILL );\n<line7>assert( (PAGER_FULLFSYNC | PAGER_CKPT_FULLFSYNC | PAGER_CACHESPILL)\n<line8>==  PAGER_FLAGS_MASK );\n<line9>assert( (pDb->safety_level & PAGER_SYNCHRONOUS_MASK)==pDb->safety_level );\n<line10>while( (n--) > 0 ){\n<line11>if( pDb->pBt ){\n<line12>sqlite3BtreeSetPagerFlags(pDb->pBt,\n<line13>pDb->safety_level | (db->flags & PAGER_FLAGS_MASK) );\n<line14>}\n<line15>pDb++;\n<line16>}\n<line17>}\n<line18>}
----------------------------------------
Function: actionName
Content: <line0>static const char *actionName(u8 action){\n<line1>const char *zName;\n<line2>switch( action ){\n<line3>case OE_SetNull:  zName = "SET NULL";        break;\n<line4>case OE_SetDflt:  zName = "SET DEFAULT";     break;\n<line5>case OE_Cascade:  zName = "CASCADE";         break;\n<line6>case OE_Restrict: zName = "RESTRICT";        break;\n<line7>default:          zName = "NO ACTION";\n<line8>assert( action==OE_None ); break;\n<line9>}\n<line10>return zName;\n<line11>}
----------------------------------------
Function: pragmaLocate
Content: <line0>static const PragmaName *pragmaLocate(const char *zName){\n<line1>int upr, lwr, mid = 0, rc;\n<line2>lwr = 0;\n<line3>upr = ArraySize(aPragmaName)-1;\n<line4>while( lwr<=upr ){\n<line5>mid = (lwr+upr)/2;\n<line6>rc = sqlite3_stricmp(zName, aPragmaName[mid].zName);\n<line7>if( rc==0 ) break;\n<line8>if( rc<0 ){\n<line9>upr = mid - 1;\n<line10>}else{\n<line11>lwr = mid + 1;\n<line12>}\n<line13>}\n<line14>return lwr>upr ? 0 : &aPragmaName[mid];\n<line15>}
----------------------------------------
Function: pragmaFunclistLine
Content: <line0>static void pragmaFunclistLine(\n<line1>Vdbe *v,               /* The prepared statement being created */\n<line2>FuncDef *p,            /* A particular function definition */\n<line3>int isBuiltin,         /* True if this is a built-in function */\n<line4>int showInternFuncs    /* True if showing internal functions */\n<line5>){\n<line6>u32 mask =\n<line7>SQLITE_DETERMINISTIC |\n<line8>SQLITE_DIRECTONLY |\n<line9>SQLITE_SUBTYPE |\n<line10>SQLITE_INNOCUOUS |\n<line11>SQLITE_FUNC_INTERNAL\n<line12>;\n<line13>if( showInternFuncs ) mask = 0xffffffff;\n<line14>for(; p; p=p->pNext){\n<line15>const char *zType;\n<line16>static const char *azEnc[] = { 0, "utf8", "utf16le", "utf16be" };\n<line17>assert( SQLITE_FUNC_ENCMASK==0x3 );\n<line18>assert( strcmp(azEnc[SQLITE_UTF8],"utf8")==0 );\n<line19>assert( strcmp(azEnc[SQLITE_UTF16LE],"utf16le")==0 );\n<line20>assert( strcmp(azEnc[SQLITE_UTF16BE],"utf16be")==0 );\n<line21>if( p->xSFunc==0 ) continue;\n<line22>if( (p->funcFlags & SQLITE_FUNC_INTERNAL)!=0\n<line23>&& showInternFuncs==0\n<line24>){\n<line25>continue;\n<line26>}\n<line27>if( p->xValue!=0 ){\n<line28>zType = "w";\n<line29>}else if( p->xFinalize!=0 ){\n<line30>zType = "a";\n<line31>}else{\n<line32>zType = "s";\n<line33>}\n<line34>sqlite3VdbeMultiLoad(v, 1, "sissii",\n<line35>p->zName, isBuiltin,\n<line36>zType, azEnc[p->funcFlags&SQLITE_FUNC_ENCMASK],\n<line37>p->nArg,\n<line38>(p->funcFlags & mask) ^ SQLITE_INNOCUOUS\n<line39>);\n<line40>}\n<line41>}
----------------------------------------
Function: integrityCheckResultRow
Content: <line0>static int integrityCheckResultRow(Vdbe *v){\n<line1>int addr;\n<line2>sqlite3VdbeAddOp2(v, OP_ResultRow, 3, 1);\n<line3>addr = sqlite3VdbeAddOp3(v, OP_IfPos, 1, sqlite3VdbeCurrentAddr(v)+2, 1);\n<line4>VdbeCoverage(v);\n<line5>sqlite3VdbeAddOp0(v, OP_Halt);\n<line6>return addr;\n<line7>}
----------------------------------------
Function: tableSkipIntegrityCheck
Content: <line0>static int tableSkipIntegrityCheck(const Table *pTab, const Table *pObjTab){\n<line1>if( pObjTab ){\n<line2>return pTab!=pObjTab;\n<line3>}else{\n<line4>return (pTab->tabFlags & TF_Imposter)!=0;\n<line5>}\n<line6>}
----------------------------------------
Function: pragmaVtabConnect
Content: <line0>static int pragmaVtabConnect(\n<line1>sqlite3 *db,\n<line2>void *pAux,\n<line3>int argc, const char *const*argv,\n<line4>sqlite3_vtab **ppVtab,\n<line5>char **pzErr\n<line6>){\n<line7>const PragmaName *pPragma = (const PragmaName*)pAux;\n<line8>PragmaVtab *pTab = 0;\n<line9>int rc;\n<line10>int i, j;\n<line11>char cSep = '(';\n<line12>StrAccum acc;\n<line13>char zBuf[200];\n<line14>UNUSED_PARAMETER(argc);\n<line15>UNUSED_PARAMETER(argv);\n<line16>sqlite3StrAccumInit(&acc, 0, zBuf, sizeof(zBuf), 0);\n<line17>sqlite3_str_appendall(&acc, "CREATE TABLE x");\n<line18>for(i=0, j=pPragma->iPragCName; i<pPragma->nPragCName; i++, j++){\n<line19>sqlite3_str_appendf(&acc, "%c\"%s\"", cSep, pragCName[j]);\n<line20>cSep = ',';\n<line21>}\n<line22>if( i==0 ){\n<line23>sqlite3_str_appendf(&acc, "(\"%s\"", pPragma->zName);\n<line24>i++;\n<line25>}\n<line26>j = 0;\n<line27>if( pPragma->mPragFlg & PragFlg_Result1 ){\n<line28>sqlite3_str_appendall(&acc, ",arg HIDDEN");\n<line29>j++;\n<line30>}\n<line31>if( pPragma->mPragFlg & (PragFlg_SchemaOpt|PragFlg_SchemaReq) ){\n<line32>sqlite3_str_appendall(&acc, ",schema HIDDEN");\n<line33>j++;\n<line34>}\n<line35>sqlite3_str_append(&acc, ")", 1);\n<line36>sqlite3StrAccumFinish(&acc);\n<line37>assert( strlen(zBuf) < sizeof(zBuf)-1 );\n<line38>rc = sqlite3_declare_vtab(db, zBuf);\n<line39>if( rc==SQLITE_OK ){\n<line40>pTab = (PragmaVtab*)sqlite3_malloc(sizeof(PragmaVtab));\n<line41>if( pTab==0 ){\n<line42>rc = SQLITE_NOMEM;\n<line43>}else{\n<line44>memset(pTab, 0, sizeof(PragmaVtab));\n<line45>pTab->pName = pPragma;\n<line46>pTab->db = db;\n<line47>pTab->iHidden = i;\n<line48>pTab->nHidden = j;\n<line49>}\n<line50>}else{\n<line51>*pzErr = sqlite3_mprintf("%s", sqlite3_errmsg(db));\n<line52>}\n<line53>*ppVtab = (sqlite3_vtab*)pTab;\n<line54>return rc;\n<line55>}
----------------------------------------
Function: pragmaVtabDisconnect
Content: <line0>static int pragmaVtabDisconnect(sqlite3_vtab *pVtab){\n<line1>PragmaVtab *pTab = (PragmaVtab*)pVtab;\n<line2>sqlite3_free(pTab);\n<line3>return SQLITE_OK;\n<line4>}
----------------------------------------
Function: pragmaVtabBestIndex
Content: <line0>static int pragmaVtabBestIndex(sqlite3_vtab *tab, sqlite3_index_info *pIdxInfo){\n<line1>PragmaVtab *pTab = (PragmaVtab*)tab;\n<line2>const struct sqlite3_index_constraint *pConstraint;\n<line3>int i, j;\n<line4>int seen[2];\n<line5>pIdxInfo->estimatedCost = (double)1;\n<line6>if( pTab->nHidden==0 ){ return SQLITE_OK; }\n<line7>pConstraint = pIdxInfo->aConstraint;\n<line8>seen[0] = 0;\n<line9>seen[1] = 0;\n<line10>for(i=0; i<pIdxInfo->nConstraint; i++, pConstraint++){\n<line11>if( pConstraint->iColumn < pTab->iHidden ) continue;\n<line12>if( pConstraint->op!=SQLITE_INDEX_CONSTRAINT_EQ ) continue;\n<line13>if( pConstraint->usable==0 ) return SQLITE_CONSTRAINT;\n<line14>j = pConstraint->iColumn - pTab->iHidden;\n<line15>assert( j < 2 );\n<line16>seen[j] = i+1;\n<line17>}\n<line18>if( seen[0]==0 ){\n<line19>pIdxInfo->estimatedCost = (double)2147483647;\n<line20>pIdxInfo->estimatedRows = 2147483647;\n<line21>return SQLITE_OK;\n<line22>}\n<line23>j = seen[0]-1;\n<line24>pIdxInfo->aConstraintUsage[j].argvIndex = 1;\n<line25>pIdxInfo->aConstraintUsage[j].omit = 1;\n<line26>pIdxInfo->estimatedCost = (double)20;\n<line27>pIdxInfo->estimatedRows = 20;\n<line28>if( seen[1] ){\n<line29>j = seen[1]-1;\n<line30>pIdxInfo->aConstraintUsage[j].argvIndex = 2;\n<line31>pIdxInfo->aConstraintUsage[j].omit = 1;\n<line32>}\n<line33>return SQLITE_OK;\n<line34>}
----------------------------------------
Function: pragmaVtabOpen
Content: <line0>static int pragmaVtabOpen(sqlite3_vtab *pVtab, sqlite3_vtab_cursor **ppCursor){\n<line1>PragmaVtabCursor *pCsr;\n<line2>pCsr = (PragmaVtabCursor*)sqlite3_malloc(sizeof(*pCsr));\n<line3>if( pCsr==0 ) return SQLITE_NOMEM;\n<line4>memset(pCsr, 0, sizeof(PragmaVtabCursor));\n<line5>pCsr->base.pVtab = pVtab;\n<line6>*ppCursor = &pCsr->base;\n<line7>return SQLITE_OK;\n<line8>}
----------------------------------------
Function: pragmaVtabCursorClear
Content: <line0>static void pragmaVtabCursorClear(PragmaVtabCursor *pCsr){\n<line1>int i;\n<line2>sqlite3_finalize(pCsr->pPragma);\n<line3>pCsr->pPragma = 0;\n<line4>pCsr->iRowid = 0;\n<line5>for(i=0; i<ArraySize(pCsr->azArg); i++){\n<line6>sqlite3_free(pCsr->azArg[i]);\n<line7>pCsr->azArg[i] = 0;\n<line8>}\n<line9>}
----------------------------------------
Function: pragmaVtabClose
Content: <line0>static int pragmaVtabClose(sqlite3_vtab_cursor *cur){\n<line1>PragmaVtabCursor *pCsr = (PragmaVtabCursor*)cur;\n<line2>pragmaVtabCursorClear(pCsr);\n<line3>sqlite3_free(pCsr);\n<line4>return SQLITE_OK;\n<line5>}
----------------------------------------
Function: pragmaVtabNext
Content: <line0>static int pragmaVtabNext(sqlite3_vtab_cursor *pVtabCursor){\n<line1>PragmaVtabCursor *pCsr = (PragmaVtabCursor*)pVtabCursor;\n<line2>int rc = SQLITE_OK;\n<line3>/* Increment the xRowid value */\n<line4>pCsr->iRowid++;\n<line5>assert( pCsr->pPragma );\n<line6>if( SQLITE_ROW!=sqlite3_step(pCsr->pPragma) ){\n<line7>rc = sqlite3_finalize(pCsr->pPragma);\n<line8>pCsr->pPragma = 0;\n<line9>pragmaVtabCursorClear(pCsr);\n<line10>}\n<line11>return rc;\n<line12>}
----------------------------------------
Function: pragmaVtabFilter
Content: <line0>static int pragmaVtabFilter(\n<line1>sqlite3_vtab_cursor *pVtabCursor,\n<line2>int idxNum, const char *idxStr,\n<line3>int argc, sqlite3_value **argv\n<line4>){\n<line5>PragmaVtabCursor *pCsr = (PragmaVtabCursor*)pVtabCursor;\n<line6>PragmaVtab *pTab = (PragmaVtab*)(pVtabCursor->pVtab);\n<line7>int rc;\n<line8>int i, j;\n<line9>StrAccum acc;\n<line10>char *zSql;\n<line11>UNUSED_PARAMETER(idxNum);\n<line12>UNUSED_PARAMETER(idxStr);\n<line13>pragmaVtabCursorClear(pCsr);\n<line14>j = (pTab->pName->mPragFlg & PragFlg_Result1)!=0 ? 0 : 1;\n<line15>for(i=0; i<argc; i++, j++){\n<line16>const char *zText = (const char*)sqlite3_value_text(argv[i]);\n<line17>assert( j<ArraySize(pCsr->azArg) );\n<line18>assert( pCsr->azArg[j]==0 );\n<line19>if( zText ){\n<line20>pCsr->azArg[j] = sqlite3_mprintf("%s", zText);\n<line21>if( pCsr->azArg[j]==0 ){\n<line22>return SQLITE_NOMEM;\n<line23>}\n<line24>}\n<line25>}\n<line26>sqlite3StrAccumInit(&acc, 0, 0, 0, pTab->db->aLimit[SQLITE_LIMIT_SQL_LENGTH]);\n<line27>sqlite3_str_appendall(&acc, "PRAGMA ");\n<line28>if( pCsr->azArg[1] ){\n<line29>sqlite3_str_appendf(&acc, "%Q.", pCsr->azArg[1]);\n<line30>}\n<line31>sqlite3_str_appendall(&acc, pTab->pName->zName);\n<line32>if( pCsr->azArg[0] ){\n<line33>sqlite3_str_appendf(&acc, "=%Q", pCsr->azArg[0]);\n<line34>}\n<line35>zSql = sqlite3StrAccumFinish(&acc);\n<line36>if( zSql==0 ) return SQLITE_NOMEM;\n<line37>rc = sqlite3_prepare_v2(pTab->db, zSql, -1, &pCsr->pPragma, 0);\n<line38>sqlite3_free(zSql);\n<line39>if( rc!=SQLITE_OK ){\n<line40>pTab->base.zErrMsg = sqlite3_mprintf("%s", sqlite3_errmsg(pTab->db));\n<line41>return rc;\n<line42>}\n<line43>return pragmaVtabNext(pVtabCursor);\n<line44>}
----------------------------------------
Function: pragmaVtabEof
Content: <line0>static int pragmaVtabEof(sqlite3_vtab_cursor *pVtabCursor){\n<line1>PragmaVtabCursor *pCsr = (PragmaVtabCursor*)pVtabCursor;\n<line2>return (pCsr->pPragma==0);\n<line3>}
----------------------------------------
Function: pragmaVtabColumn
Content: <line0>static int pragmaVtabColumn(\n<line1>sqlite3_vtab_cursor *pVtabCursor,\n<line2>sqlite3_context *ctx,\n<line3>int i\n<line4>){\n<line5>PragmaVtabCursor *pCsr = (PragmaVtabCursor*)pVtabCursor;\n<line6>PragmaVtab *pTab = (PragmaVtab*)(pVtabCursor->pVtab);\n<line7>if( i<pTab->iHidden ){\n<line8>sqlite3_result_value(ctx, sqlite3_column_value(pCsr->pPragma, i));\n<line9>}else{\n<line10>sqlite3_result_text(ctx, pCsr->azArg[i-pTab->iHidden],-1,SQLITE_TRANSIENT);\n<line11>}\n<line12>return SQLITE_OK;\n<line13>}
----------------------------------------
Function: pragmaVtabRowid
Content: <line0>static int pragmaVtabRowid(sqlite3_vtab_cursor *pVtabCursor, sqlite_int64 *p){\n<line1>PragmaVtabCursor *pCsr = (PragmaVtabCursor*)pVtabCursor;\n<line2>*p = pCsr->iRowid;\n<line3>return SQLITE_OK;\n<line4>}
----------------------------------------
Function: corruptSchema
Content: <line0>static void corruptSchema(\n<line1>InitData *pData,     /* Initialization context */\n<line2>char **azObj,        /* Type and name of object being parsed */\n<line3>const char *zExtra   /* Error information */\n<line4>){\n<line5>sqlite3 *db = pData->db;\n<line6>if( db->mallocFailed ){\n<line7>pData->rc = SQLITE_NOMEM_BKPT;\n<line8>}else if( pData->pzErrMsg[0]!=0 ){\n<line9>/* A error message has already been generated.  Do not overwrite it */\n<line10>}else if( pData->mInitFlags & (INITFLAG_AlterMask) ){\n<line11>static const char *azAlterType[] = {\n<line12>"rename",\n<line13>"drop column",\n<line14>"add column"\n<line15>};\n<line16>*pData->pzErrMsg = sqlite3MPrintf(db,\n<line17>"error in %s %s after %s: %s", azObj[0], azObj[1],\n<line18>azAlterType[(pData->mInitFlags&INITFLAG_AlterMask)-1],\n<line19>zExtra\n<line20>);\n<line21>pData->rc = SQLITE_ERROR;\n<line22>}else if( db->flags & SQLITE_WriteSchema ){\n<line23>pData->rc = SQLITE_CORRUPT_BKPT;\n<line24>}else{\n<line25>char *z;\n<line26>const char *zObj = azObj[1] ? azObj[1] : "?";\n<line27>z = sqlite3MPrintf(db, "malformed database schema (%s)", zObj);\n<line28>if( zExtra && zExtra[0] ) z = sqlite3MPrintf(db, "%z - %s", z, zExtra);\n<line29>*pData->pzErrMsg = z;\n<line30>pData->rc = SQLITE_CORRUPT_BKPT;\n<line31>}\n<line32>}
----------------------------------------
Function: schemaIsValid
Content: <line0>static void schemaIsValid(Parse *pParse){\n<line1>sqlite3 *db = pParse->db;\n<line2>int iDb;\n<line3>int rc;\n<line4>int cookie;\n<line5>assert( pParse->checkSchema );\n<line6>assert( sqlite3_mutex_held(db->mutex) );\n<line7>for(iDb=0; iDb<db->nDb; iDb++){\n<line8>int openedTransaction = 0;         /* True if a transaction is opened */\n<line9>Btree *pBt = db->aDb[iDb].pBt;     /* Btree database to read cookie from */\n<line10>if( pBt==0 ) continue;\n<line11>/* If there is not already a read-only (or read-write) transaction opened\n<line12>** on the b-tree database, open one now. If a transaction is opened, it\n<line13>** will be closed immediately after reading the meta-value. */\n<line14>if( sqlite3BtreeTxnState(pBt)==SQLITE_TXN_NONE ){\n<line15>rc = sqlite3BtreeBeginTrans(pBt, 0, 0);\n<line16>if( rc==SQLITE_NOMEM || rc==SQLITE_IOERR_NOMEM ){\n<line17>sqlite3OomFault(db);\n<line18>pParse->rc = SQLITE_NOMEM;\n<line19>}\n<line20>if( rc!=SQLITE_OK ) return;\n<line21>openedTransaction = 1;\n<line22>}\n<line23>/* Read the schema cookie from the database. If it does not match the\n<line24>** value stored as part of the in-memory schema representation,\n<line25>** set Parse.rc to SQLITE_SCHEMA. */\n<line26>sqlite3BtreeGetMeta(pBt, BTREE_SCHEMA_VERSION, (u32 *)&cookie);\n<line27>assert( sqlite3SchemaMutexHeld(db, iDb, 0) );\n<line28>if( cookie!=db->aDb[iDb].pSchema->schema_cookie ){\n<line29>if( DbHasProperty(db, iDb, DB_SchemaLoaded) ) pParse->rc = SQLITE_SCHEMA;\n<line30>sqlite3ResetOneSchema(db, iDb);\n<line31>}\n<line32>/* Close the transaction, if one was opened. */\n<line33>if( openedTransaction ){\n<line34>sqlite3BtreeCommit(pBt);\n<line35>}\n<line36>}\n<line37>}
----------------------------------------
Function: sqlite3Prepare
Content: <line0>static int sqlite3Prepare(\n<line1>sqlite3 *db,              /* Database handle. */\n<line2>const char *zSql,         /* UTF-8 encoded SQL statement. */\n<line3>int nBytes,               /* Length of zSql in bytes. */\n<line4>u32 prepFlags,            /* Zero or more SQLITE_PREPARE_* flags */\n<line5>Vdbe *pReprepare,         /* VM being reprepared */\n<line6>sqlite3_stmt **ppStmt,    /* OUT: A pointer to the prepared statement */\n<line7>const char **pzTail       /* OUT: End of parsed string */\n<line8>){\n<line9>int rc = SQLITE_OK;       /* Result code */\n<line10>int i;                    /* Loop counter */\n<line11>Parse sParse;             /* Parsing context */\n<line12>/* sqlite3ParseObjectInit(&sParse, db); // inlined for performance */\n<line13>memset(PARSE_HDR(&sParse), 0, PARSE_HDR_SZ);\n<line14>memset(PARSE_TAIL(&sParse), 0, PARSE_TAIL_SZ);\n<line15>sParse.pOuterParse = db->pParse;\n<line16>db->pParse = &sParse;\n<line17>sParse.db = db;\n<line18>if( pReprepare ){\n<line19>sParse.pReprepare = pReprepare;\n<line20>sParse.explain = sqlite3_stmt_isexplain((sqlite3_stmt*)pReprepare);\n<line21>}else{\n<line22>assert( sParse.pReprepare==0 );\n<line23>}\n<line24>assert( ppStmt && *ppStmt==0 );\n<line25>if( db->mallocFailed ){\n<line26>sqlite3ErrorMsg(&sParse, "out of memory");\n<line27>db->errCode = rc = SQLITE_NOMEM;\n<line28>goto end_prepare;\n<line29>}\n<line30>assert( sqlite3_mutex_held(db->mutex) );\n<line31>/* For a long-term use prepared statement avoid the use of\n<line32>** lookaside memory.\n<line33>*/\n<line34>if( prepFlags & SQLITE_PREPARE_PERSISTENT ){\n<line35>sParse.disableLookaside++;\n<line36>DisableLookaside;\n<line37>}\n<line38>sParse.prepFlags = prepFlags & 0xff;\n<line39>/* Check to verify that it is possible to get a read lock on all\n<line40>** database schemas.  The inability to get a read lock indicates that\n<line41>** some other database connection is holding a write-lock, which in\n<line42>** turn means that the other connection has made uncommitted changes\n<line43>** to the schema.\n<line44>**\n<line45>** Were we to proceed and prepare the statement against the uncommitted\n<line46>** schema changes and if those schema changes are subsequently rolled\n<line47>** back and different changes are made in their place, then when this\n<line48>** prepared statement goes to run the schema cookie would fail to detect\n<line49>** the schema change.  Disaster would follow.\n<line50>**\n<line51>** This thread is currently holding mutexes on all Btrees (because\n<line52>** of the sqlite3BtreeEnterAll() in sqlite3LockAndPrepare()) so it\n<line53>** is not possible for another thread to start a new schema change\n<line54>** while this routine is running.  Hence, we do not need to hold\n<line55>** locks on the schema, we just need to make sure nobody else is\n<line56>** holding them.\n<line57>**\n<line58>** Note that setting READ_UNCOMMITTED overrides most lock detection,\n<line59>** but it does *not* override schema lock detection, so this all still\n<line60>** works even if READ_UNCOMMITTED is set.\n<line61>*/\n<line62>if( !db->noSharedCache ){\n<line63>for(i=0; i<db->nDb; i++) {\n<line64>Btree *pBt = db->aDb[i].pBt;\n<line65>if( pBt ){\n<line66>assert( sqlite3BtreeHoldsMutex(pBt) );\n<line67>rc = sqlite3BtreeSchemaLocked(pBt);\n<line68>if( rc ){\n<line69>const char *zDb = db->aDb[i].zDbSName;\n<line70>sqlite3ErrorWithMsg(db, rc, "database schema is locked: %s", zDb);\n<line71>testcase( db->flags & SQLITE_ReadUncommit );\n<line72>goto end_prepare;\n<line73>}\n<line74>}\n<line75>}\n<line76>}\n<line77>#ifndef SQLITE_OMIT_VIRTUALTABLE\n<line78>if( db->pDisconnect ) sqlite3VtabUnlockList(db);\n<line79>#endif\n<line80>if( nBytes>=0 && (nBytes==0 || zSql[nBytes-1]!=0) ){\n<line81>char *zSqlCopy;\n<line82>int mxLen = db->aLimit[SQLITE_LIMIT_SQL_LENGTH];\n<line83>testcase( nBytes==mxLen );\n<line84>testcase( nBytes==mxLen+1 );\n<line85>if( nBytes>mxLen ){\n<line86>sqlite3ErrorWithMsg(db, SQLITE_TOOBIG, "statement too long");\n<line87>rc = sqlite3ApiExit(db, SQLITE_TOOBIG);\n<line88>goto end_prepare;\n<line89>}\n<line90>zSqlCopy = sqlite3DbStrNDup(db, zSql, nBytes);\n<line91>if( zSqlCopy ){\n<line92>sqlite3RunParser(&sParse, zSqlCopy);\n<line93>sParse.zTail = &zSql[sParse.zTail-zSqlCopy];\n<line94>sqlite3DbFree(db, zSqlCopy);\n<line95>}else{\n<line96>sParse.zTail = &zSql[nBytes];\n<line97>}\n<line98>}else{\n<line99>sqlite3RunParser(&sParse, zSql);\n<line100>}\n<line101>assert( 0==sParse.nQueryLoop );\n<line102>if( pzTail ){\n<line103>*pzTail = sParse.zTail;\n<line104>}\n<line105>if( db->init.busy==0 ){\n<line106>sqlite3VdbeSetSql(sParse.pVdbe, zSql, (int)(sParse.zTail-zSql), prepFlags);\n<line107>}\n<line108>if( db->mallocFailed ){\n<line109>sParse.rc = SQLITE_NOMEM_BKPT;\n<line110>sParse.checkSchema = 0;\n<line111>}\n<line112>if( sParse.rc!=SQLITE_OK && sParse.rc!=SQLITE_DONE ){\n<line113>if( sParse.checkSchema && db->init.busy==0 ){\n<line114>schemaIsValid(&sParse);\n<line115>}\n<line116>if( sParse.pVdbe ){\n<line117>sqlite3VdbeFinalize(sParse.pVdbe);\n<line118>}\n<line119>assert( 0==(*ppStmt) );\n<line120>rc = sParse.rc;\n<line121>if( sParse.zErrMsg ){\n<line122>sqlite3ErrorWithMsg(db, rc, "%s", sParse.zErrMsg);\n<line123>sqlite3DbFree(db, sParse.zErrMsg);\n<line124>}else{\n<line125>sqlite3Error(db, rc);\n<line126>}\n<line127>}else{\n<line128>assert( sParse.zErrMsg==0 );\n<line129>*ppStmt = (sqlite3_stmt*)sParse.pVdbe;\n<line130>rc = SQLITE_OK;\n<line131>sqlite3ErrorClear(db);\n<line132>}\n<line133>/* Delete any TriggerPrg structures allocated while parsing this statement. */\n<line134>while( sParse.pTriggerPrg ){\n<line135>TriggerPrg *pT = sParse.pTriggerPrg;\n<line136>sParse.pTriggerPrg = pT->pNext;\n<line137>sqlite3DbFree(db, pT);\n<line138>}\n<line139>end_prepare:\n<line140>sqlite3ParseObjectReset(&sParse);\n<line141>return rc;\n<line142>}
----------------------------------------
Function: sqlite3LockAndPrepare
Content: <line0>static int sqlite3LockAndPrepare(\n<line1>sqlite3 *db,              /* Database handle. */\n<line2>const char *zSql,         /* UTF-8 encoded SQL statement. */\n<line3>int nBytes,               /* Length of zSql in bytes. */\n<line4>u32 prepFlags,            /* Zero or more SQLITE_PREPARE_* flags */\n<line5>Vdbe *pOld,               /* VM being reprepared */\n<line6>sqlite3_stmt **ppStmt,    /* OUT: A pointer to the prepared statement */\n<line7>const char **pzTail       /* OUT: End of parsed string */\n<line8>){\n<line9>int rc;\n<line10>int cnt = 0;\n<line11>#ifdef SQLITE_ENABLE_API_ARMOR\n<line12>if( ppStmt==0 ) return SQLITE_MISUSE_BKPT;\n<line13>#endif\n<line14>*ppStmt = 0;\n<line15>if( !sqlite3SafetyCheckOk(db)||zSql==0 ){\n<line16>return SQLITE_MISUSE_BKPT;\n<line17>}\n<line18>sqlite3_mutex_enter(db->mutex);\n<line19>sqlite3BtreeEnterAll(db);\n<line20>do{\n<line21>/* Make multiple attempts to compile the SQL, until it either succeeds\n<line22>** or encounters a permanent error.  A schema problem after one schema\n<line23>** reset is considered a permanent error. */\n<line24>rc = sqlite3Prepare(db, zSql, nBytes, prepFlags, pOld, ppStmt, pzTail);\n<line25>assert( rc==SQLITE_OK || *ppStmt==0 );\n<line26>if( rc==SQLITE_OK || db->mallocFailed ) break;\n<line27>cnt++;\n<line28>}while( (rc==SQLITE_ERROR_RETRY && ALWAYS(cnt<=SQLITE_MAX_PREPARE_RETRY))\n<line29>|| (rc==SQLITE_SCHEMA && (sqlite3ResetOneSchema(db,-1), cnt)==1) );\n<line30>sqlite3BtreeLeaveAll(db);\n<line31>assert( rc!=SQLITE_ERROR_RETRY );\n<line32>rc = sqlite3ApiExit(db, rc);\n<line33>assert( (rc&db->errMask)==rc );\n<line34>db->busyHandler.nBusy = 0;\n<line35>sqlite3_mutex_leave(db->mutex);\n<line36>assert( rc==SQLITE_OK || (*ppStmt)==0 );\n<line37>return rc;\n<line38>}
----------------------------------------
Function: sqlite3_prepare
Content: <line0>SQLITE_API int sqlite3_prepare(\n<line1>sqlite3 *db,              /* Database handle. */\n<line2>const char *zSql,         /* UTF-8 encoded SQL statement. */\n<line3>int nBytes,               /* Length of zSql in bytes. */\n<line4>sqlite3_stmt **ppStmt,    /* OUT: A pointer to the prepared statement */\n<line5>const char **pzTail       /* OUT: End of parsed string */\n<line6>){\n<line7>int rc;\n<line8>rc = sqlite3LockAndPrepare(db,zSql,nBytes,0,0,ppStmt,pzTail);\n<line9>assert( rc==SQLITE_OK || ppStmt==0 || *ppStmt==0 );  /* VERIFY: F13021 */\n<line10>return rc;\n<line11>}
----------------------------------------
Function: sqlite3_prepare_v2
Content: <line0>SQLITE_API int sqlite3_prepare_v2(\n<line1>sqlite3 *db,              /* Database handle. */\n<line2>const char *zSql,         /* UTF-8 encoded SQL statement. */\n<line3>int nBytes,               /* Length of zSql in bytes. */\n<line4>sqlite3_stmt **ppStmt,    /* OUT: A pointer to the prepared statement */\n<line5>const char **pzTail       /* OUT: End of parsed string */\n<line6>){\n<line7>int rc;\n<line8>/* EVIDENCE-OF: R-37923-12173 The sqlite3_prepare_v2() interface works\n<line9>** exactly the same as sqlite3_prepare_v3() with a zero prepFlags\n<line10>** parameter.\n<line11>**\n<line12>** Proof in that the 5th parameter to sqlite3LockAndPrepare is 0 */\n<line13>rc = sqlite3LockAndPrepare(db,zSql,nBytes,SQLITE_PREPARE_SAVESQL,0,\n<line14>ppStmt,pzTail);\n<line15>assert( rc==SQLITE_OK || ppStmt==0 || *ppStmt==0 );\n<line16>return rc;\n<line17>}
----------------------------------------
Function: sqlite3_prepare_v3
Content: <line0>SQLITE_API int sqlite3_prepare_v3(\n<line1>sqlite3 *db,              /* Database handle. */\n<line2>const char *zSql,         /* UTF-8 encoded SQL statement. */\n<line3>int nBytes,               /* Length of zSql in bytes. */\n<line4>unsigned int prepFlags,   /* Zero or more SQLITE_PREPARE_* flags */\n<line5>sqlite3_stmt **ppStmt,    /* OUT: A pointer to the prepared statement */\n<line6>const char **pzTail       /* OUT: End of parsed string */\n<line7>){\n<line8>int rc;\n<line9>/* EVIDENCE-OF: R-56861-42673 sqlite3_prepare_v3() differs from\n<line10>** sqlite3_prepare_v2() only in having the extra prepFlags parameter,\n<line11>** which is a bit array consisting of zero or more of the\n<line12>** SQLITE_PREPARE_* flags.\n<line13>**\n<line14>** Proof by comparison to the implementation of sqlite3_prepare_v2()\n<line15>** directly above. */\n<line16>rc = sqlite3LockAndPrepare(db,zSql,nBytes,\n<line17>SQLITE_PREPARE_SAVESQL|(prepFlags&SQLITE_PREPARE_MASK),\n<line18>0,ppStmt,pzTail);\n<line19>assert( rc==SQLITE_OK || ppStmt==0 || *ppStmt==0 );\n<line20>return rc;\n<line21>}
----------------------------------------
Function: sqlite3Prepare16
Content: <line0>static int sqlite3Prepare16(\n<line1>sqlite3 *db,              /* Database handle. */\n<line2>const void *zSql,         /* UTF-16 encoded SQL statement. */\n<line3>int nBytes,               /* Length of zSql in bytes. */\n<line4>u32 prepFlags,            /* Zero or more SQLITE_PREPARE_* flags */\n<line5>sqlite3_stmt **ppStmt,    /* OUT: A pointer to the prepared statement */\n<line6>const void **pzTail       /* OUT: End of parsed string */\n<line7>){\n<line8>/* This function currently works by first transforming the UTF-16\n<line9>** encoded string to UTF-8, then invoking sqlite3_prepare(). The\n<line10>** tricky bit is figuring out the pointer to return in *pzTail.\n<line11>*/\n<line12>char *zSql8;\n<line13>const char *zTail8 = 0;\n<line14>int rc = SQLITE_OK;\n<line15>#ifdef SQLITE_ENABLE_API_ARMOR\n<line16>if( ppStmt==0 ) return SQLITE_MISUSE_BKPT;\n<line17>#endif\n<line18>*ppStmt = 0;\n<line19>if( !sqlite3SafetyCheckOk(db)||zSql==0 ){\n<line20>return SQLITE_MISUSE_BKPT;\n<line21>}\n<line22>/* Make sure nBytes is non-negative and correct.  It should be the\n<line23>** number of bytes until the end of the input buffer or until the first\n<line24>** U+0000 character.  If the input nBytes is odd, convert it into\n<line25>** an even number.  If the input nBytes is negative, then the input\n<line26>** must be terminated by at least one U+0000 character */\n<line27>if( nBytes>=0 ){\n<line28>int sz;\n<line29>const char *z = (const char*)zSql;\n<line30>for(sz=0; sz<nBytes && (z[sz]!=0 || z[sz+1]!=0); sz += 2){}\n<line31>nBytes = sz;\n<line32>}else{\n<line33>int sz;\n<line34>const char *z = (const char*)zSql;\n<line35>for(sz=0; z[sz]!=0 || z[sz+1]!=0; sz += 2){}\n<line36>nBytes = sz;\n<line37>}\n<line38>sqlite3_mutex_enter(db->mutex);\n<line39>zSql8 = sqlite3Utf16to8(db, zSql, nBytes, SQLITE_UTF16NATIVE);\n<line40>if( zSql8 ){\n<line41>rc = sqlite3LockAndPrepare(db, zSql8, -1, prepFlags, 0, ppStmt, &zTail8);\n<line42>}\n<line43>if( zTail8 && pzTail ){\n<line44>/* If sqlite3_prepare returns a tail pointer, we calculate the\n<line45>** equivalent pointer into the UTF-16 string by counting the unicode\n<line46>** characters between zSql8 and zTail8, and then returning a pointer\n<line47>** the same number of characters into the UTF-16 string.\n<line48>*/\n<line49>int chars_parsed = sqlite3Utf8CharLen(zSql8, (int)(zTail8-zSql8));\n<line50>*pzTail = (u8 *)zSql + sqlite3Utf16ByteLen(zSql, nBytes, chars_parsed);\n<line51>}\n<line52>sqlite3DbFree(db, zSql8);\n<line53>rc = sqlite3ApiExit(db, rc);\n<line54>sqlite3_mutex_leave(db->mutex);\n<line55>return rc;\n<line56>}
----------------------------------------
Function: sqlite3_prepare16
Content: <line0>SQLITE_API int sqlite3_prepare16(\n<line1>sqlite3 *db,              /* Database handle. */\n<line2>const void *zSql,         /* UTF-16 encoded SQL statement. */\n<line3>int nBytes,               /* Length of zSql in bytes. */\n<line4>sqlite3_stmt **ppStmt,    /* OUT: A pointer to the prepared statement */\n<line5>const void **pzTail       /* OUT: End of parsed string */\n<line6>){\n<line7>int rc;\n<line8>rc = sqlite3Prepare16(db,zSql,nBytes,0,ppStmt,pzTail);\n<line9>assert( rc==SQLITE_OK || ppStmt==0 || *ppStmt==0 );  /* VERIFY: F13021 */\n<line10>return rc;\n<line11>}
----------------------------------------
Function: sqlite3_prepare16_v2
Content: <line0>SQLITE_API int sqlite3_prepare16_v2(\n<line1>sqlite3 *db,              /* Database handle. */\n<line2>const void *zSql,         /* UTF-16 encoded SQL statement. */\n<line3>int nBytes,               /* Length of zSql in bytes. */\n<line4>sqlite3_stmt **ppStmt,    /* OUT: A pointer to the prepared statement */\n<line5>const void **pzTail       /* OUT: End of parsed string */\n<line6>){\n<line7>int rc;\n<line8>rc = sqlite3Prepare16(db,zSql,nBytes,SQLITE_PREPARE_SAVESQL,ppStmt,pzTail);\n<line9>assert( rc==SQLITE_OK || ppStmt==0 || *ppStmt==0 );  /* VERIFY: F13021 */\n<line10>return rc;\n<line11>}
----------------------------------------
Function: sqlite3_prepare16_v3
Content: <line0>SQLITE_API int sqlite3_prepare16_v3(\n<line1>sqlite3 *db,              /* Database handle. */\n<line2>const void *zSql,         /* UTF-16 encoded SQL statement. */\n<line3>int nBytes,               /* Length of zSql in bytes. */\n<line4>unsigned int prepFlags,   /* Zero or more SQLITE_PREPARE_* flags */\n<line5>sqlite3_stmt **ppStmt,    /* OUT: A pointer to the prepared statement */\n<line6>const void **pzTail       /* OUT: End of parsed string */\n<line7>){\n<line8>int rc;\n<line9>rc = sqlite3Prepare16(db,zSql,nBytes,\n<line10>SQLITE_PREPARE_SAVESQL|(prepFlags&SQLITE_PREPARE_MASK),\n<line11>ppStmt,pzTail);\n<line12>assert( rc==SQLITE_OK || ppStmt==0 || *ppStmt==0 );  /* VERIFY: F13021 */\n<line13>return rc;\n<line14>}
----------------------------------------
Function: clearSelect
Content: <line0>static void clearSelect(sqlite3 *db, Select *p, int bFree){\n<line1>assert( db!=0 );\n<line2>while( p ){\n<line3>Select *pPrior = p->pPrior;\n<line4>sqlite3ExprListDelete(db, p->pEList);\n<line5>sqlite3SrcListDelete(db, p->pSrc);\n<line6>sqlite3ExprDelete(db, p->pWhere);\n<line7>sqlite3ExprListDelete(db, p->pGroupBy);\n<line8>sqlite3ExprDelete(db, p->pHaving);\n<line9>sqlite3ExprListDelete(db, p->pOrderBy);\n<line10>sqlite3ExprDelete(db, p->pLimit);\n<line11>if( OK_IF_ALWAYS_TRUE(p->pWith) ) sqlite3WithDelete(db, p->pWith);\n<line12>#ifndef SQLITE_OMIT_WINDOWFUNC\n<line13>if( OK_IF_ALWAYS_TRUE(p->pWinDefn) ){\n<line14>sqlite3WindowListDelete(db, p->pWinDefn);\n<line15>}\n<line16>while( p->pWin ){\n<line17>assert( p->pWin->ppThis==&p->pWin );\n<line18>sqlite3WindowUnlinkFromSelect(p->pWin);\n<line19>}\n<line20>#endif\n<line21>if( bFree ) sqlite3DbNNFreeNN(db, p);\n<line22>p = pPrior;\n<line23>bFree = 1;\n<line24>}\n<line25>}
----------------------------------------
Function: findRightmost
Content: <line0>static Select *findRightmost(Select *p){\n<line1>while( p->pNext ) p = p->pNext;\n<line2>return p;\n<line3>}
----------------------------------------
Function: tableAndColumnIndex
Content: <line0>static int tableAndColumnIndex(\n<line1>SrcList *pSrc,       /* Array of tables to search */\n<line2>int iStart,          /* First member of pSrc->a[] to check */\n<line3>int iEnd,            /* Last member of pSrc->a[] to check */\n<line4>const char *zCol,    /* Name of the column we are looking for */\n<line5>int *piTab,          /* Write index of pSrc->a[] here */\n<line6>int *piCol,          /* Write index of pSrc->a[*piTab].pSTab->aCol[] here */\n<line7>int bIgnoreHidden    /* Ignore hidden columns */\n<line8>){\n<line9>int i;               /* For looping over tables in pSrc */\n<line10>int iCol;            /* Index of column matching zCol */\n<line11>assert( iEnd<pSrc->nSrc );\n<line12>assert( iStart>=0 );\n<line13>assert( (piTab==0)==(piCol==0) );  /* Both or neither are NULL */\n<line14>for(i=iStart; i<=iEnd; i++){\n<line15>iCol = sqlite3ColumnIndex(pSrc->a[i].pSTab, zCol);\n<line16>if( iCol>=0\n<line17>&& (bIgnoreHidden==0 || IsHiddenColumn(&pSrc->a[i].pSTab->aCol[iCol])==0)\n<line18>){\n<line19>if( piTab ){\n<line20>sqlite3SrcItemColumnUsed(&pSrc->a[i], iCol);\n<line21>*piTab = i;\n<line22>*piCol = iCol;\n<line23>}\n<line24>return 1;\n<line25>}\n<line26>}\n<line27>return 0;\n<line28>}
----------------------------------------
Function: unsetJoinExpr
Content: <line0>static void unsetJoinExpr(Expr *p, int iTable, int nullable){\n<line1>while( p ){\n<line2>if( iTable<0 || (ExprHasProperty(p, EP_OuterON) && p->w.iJoin==iTable) ){\n<line3>ExprClearProperty(p, EP_OuterON|EP_InnerON);\n<line4>if( iTable>=0 ) ExprSetProperty(p, EP_InnerON);\n<line5>}\n<line6>if( p->op==TK_COLUMN && p->iTable==iTable && !nullable ){\n<line7>ExprClearProperty(p, EP_CanBeNull);\n<line8>}\n<line9>if( p->op==TK_FUNCTION ){\n<line10>assert( ExprUseXList(p) );\n<line11>assert( p->pLeft==0 );\n<line12>if( p->x.pList ){\n<line13>int i;\n<line14>for(i=0; i<p->x.pList->nExpr; i++){\n<line15>unsetJoinExpr(p->x.pList->a[i].pExpr, iTable, nullable);\n<line16>}\n<line17>}\n<line18>}\n<line19>unsetJoinExpr(p->pLeft, iTable, nullable);\n<line20>p = p->pRight;\n<line21>}\n<line22>}
----------------------------------------
Function: sqlite3ProcessJoin
Content: <line0>static int sqlite3ProcessJoin(Parse *pParse, Select *p){\n<line1>SrcList *pSrc;                  /* All tables in the FROM clause */\n<line2>int i, j;                       /* Loop counters */\n<line3>SrcItem *pLeft;                 /* Left table being joined */\n<line4>SrcItem *pRight;                /* Right table being joined */\n<line5>pSrc = p->pSrc;\n<line6>pLeft = &pSrc->a[0];\n<line7>pRight = &pLeft[1];\n<line8>for(i=0; i<pSrc->nSrc-1; i++, pRight++, pLeft++){\n<line9>Table *pRightTab = pRight->pSTab;\n<line10>u32 joinType;\n<line11>if( NEVER(pLeft->pSTab==0 || pRightTab==0) ) continue;\n<line12>joinType = (pRight->fg.jointype & JT_OUTER)!=0 ? EP_OuterON : EP_InnerON;\n<line13>/* If this is a NATURAL join, synthesize an appropriate USING clause\n<line14>** to specify which columns should be joined.\n<line15>*/\n<line16>if( pRight->fg.jointype & JT_NATURAL ){\n<line17>IdList *pUsing = 0;\n<line18>if( pRight->fg.isUsing || pRight->u3.pOn ){\n<line19>sqlite3ErrorMsg(pParse, "a NATURAL join may not have "\n<line20>"an ON or USING clause", 0);\n<line21>return 1;\n<line22>}\n<line23>for(j=0; j<pRightTab->nCol; j++){\n<line24>char *zName;   /* Name of column in the right table */\n<line25>if( IsHiddenColumn(&pRightTab->aCol[j]) ) continue;\n<line26>zName = pRightTab->aCol[j].zCnName;\n<line27>if( tableAndColumnIndex(pSrc, 0, i, zName, 0, 0, 1) ){\n<line28>pUsing = sqlite3IdListAppend(pParse, pUsing, 0);\n<line29>if( pUsing ){\n<line30>assert( pUsing->nId>0 );\n<line31>assert( pUsing->a[pUsing->nId-1].zName==0 );\n<line32>pUsing->a[pUsing->nId-1].zName = sqlite3DbStrDup(pParse->db, zName);\n<line33>}\n<line34>}\n<line35>}\n<line36>if( pUsing ){\n<line37>pRight->fg.isUsing = 1;\n<line38>pRight->fg.isSynthUsing = 1;\n<line39>pRight->u3.pUsing = pUsing;\n<line40>}\n<line41>if( pParse->nErr ) return 1;\n<line42>}\n<line43>/* Create extra terms on the WHERE clause for each column named\n<line44>** in the USING clause.  Example: If the two tables to be joined are\n<line45>** A and B and the USING clause names X, Y, and Z, then add this\n<line46>** to the WHERE clause:    A.X=B.X AND A.Y=B.Y AND A.Z=B.Z\n<line47>** Report an error if any column mentioned in the USING clause is\n<line48>** not contained in both tables to be joined.\n<line49>*/\n<line50>if( pRight->fg.isUsing ){\n<line51>IdList *pList = pRight->u3.pUsing;\n<line52>sqlite3 *db = pParse->db;\n<line53>assert( pList!=0 );\n<line54>for(j=0; j<pList->nId; j++){\n<line55>char *zName;     /* Name of the term in the USING clause */\n<line56>int iLeft;       /* Table on the left with matching column name */\n<line57>int iLeftCol;    /* Column number of matching column on the left */\n<line58>int iRightCol;   /* Column number of matching column on the right */\n<line59>Expr *pE1;       /* Reference to the column on the LEFT of the join */\n<line60>Expr *pE2;       /* Reference to the column on the RIGHT of the join */\n<line61>Expr *pEq;       /* Equality constraint.  pE1 == pE2 */\n<line62>zName = pList->a[j].zName;\n<line63>iRightCol = sqlite3ColumnIndex(pRightTab, zName);\n<line64>if( iRightCol<0\n<line65>|| tableAndColumnIndex(pSrc, 0, i, zName, &iLeft, &iLeftCol,\n<line66>pRight->fg.isSynthUsing)==0\n<line67>){\n<line68>sqlite3ErrorMsg(pParse, "cannot join using column %s - column "\n<line69>"not present in both tables", zName);\n<line70>return 1;\n<line71>}\n<line72>pE1 = sqlite3CreateColumnExpr(db, pSrc, iLeft, iLeftCol);\n<line73>sqlite3SrcItemColumnUsed(&pSrc->a[iLeft], iLeftCol);\n<line74>if( (pSrc->a[0].fg.jointype & JT_LTORJ)!=0 && pParse->nErr==0 ){\n<line75>/* This branch runs if the query contains one or more RIGHT or FULL\n<line76>** JOINs.  If only a single table on the left side of this join\n<line77>** contains the zName column, then this branch is a no-op.\n<line78>** But if there are two or more tables on the left side\n<line79>** of the join, construct a coalesce() function that gathers all\n<line80>** such tables.  Raise an error if more than one of those references\n<line81>** to zName is not also within a prior USING clause.\n<line82>**\n<line83>** We really ought to raise an error if there are two or more\n<line84>** non-USING references to zName on the left of an INNER or LEFT\n<line85>** JOIN.  But older versions of SQLite do not do that, so we avoid\n<line86>** adding a new error so as to not break legacy applications.\n<line87>*/\n<line88>ExprList *pFuncArgs = 0;   /* Arguments to the coalesce() */\n<line89>static const Token tkCoalesce = { "coalesce", 8 };\n<line90>assert( pE1!=0 );\n<line91>ExprSetProperty(pE1, EP_CanBeNull);\n<line92>while( tableAndColumnIndex(pSrc, iLeft+1, i, zName, &iLeft, &iLeftCol,\n<line93>pRight->fg.isSynthUsing)!=0 ){\n<line94>if( pSrc->a[iLeft].fg.isUsing==0\n<line95>|| sqlite3IdListIndex(pSrc->a[iLeft].u3.pUsing, zName)<0\n<line96>){\n<line97>sqlite3ErrorMsg(pParse, "ambiguous reference to %s in USING()",\n<line98>zName);\n<line99>break;\n<line100>}\n<line101>pFuncArgs = sqlite3ExprListAppend(pParse, pFuncArgs, pE1);\n<line102>pE1 = sqlite3CreateColumnExpr(db, pSrc, iLeft, iLeftCol);\n<line103>sqlite3SrcItemColumnUsed(&pSrc->a[iLeft], iLeftCol);\n<line104>}\n<line105>if( pFuncArgs ){\n<line106>pFuncArgs = sqlite3ExprListAppend(pParse, pFuncArgs, pE1);\n<line107>pE1 = sqlite3ExprFunction(pParse, pFuncArgs, &tkCoalesce, 0);\n<line108>if( pE1 ){\n<line109>pE1->affExpr = SQLITE_AFF_DEFER;\n<line110>}\n<line111>}\n<line112>}else if( (pSrc->a[i+1].fg.jointype & JT_LEFT)!=0 && pParse->nErr==0 ){\n<line113>assert( pE1!=0 );\n<line114>ExprSetProperty(pE1, EP_CanBeNull);\n<line115>}\n<line116>pE2 = sqlite3CreateColumnExpr(db, pSrc, i+1, iRightCol);\n<line117>sqlite3SrcItemColumnUsed(pRight, iRightCol);\n<line118>pEq = sqlite3PExpr(pParse, TK_EQ, pE1, pE2);\n<line119>assert( pE2!=0 || pEq==0 );\n<line120>if( pEq ){\n<line121>ExprSetProperty(pEq, joinType);\n<line122>assert( !ExprHasProperty(pEq, EP_TokenOnly|EP_Reduced) );\n<line123>ExprSetVVAProperty(pEq, EP_NoReduce);\n<line124>pEq->w.iJoin = pE2->iTable;\n<line125>}\n<line126>p->pWhere = sqlite3ExprAnd(pParse, p->pWhere, pEq);\n<line127>}\n<line128>}\n<line129>/* Add the ON clause to the end of the WHERE clause, connected by\n<line130>** an AND operator.\n<line131>*/\n<line132>else if( pRight->u3.pOn ){\n<line133>sqlite3SetJoinExpr(pRight->u3.pOn, pRight->iCursor, joinType);\n<line134>p->pWhere = sqlite3ExprAnd(pParse, p->pWhere, pRight->u3.pOn);\n<line135>pRight->u3.pOn = 0;\n<line136>pRight->fg.isOn = 1;\n<line137>p->selFlags |= SF_OnToWhere;\n<line138>}\n<line139>}\n<line140>return 0;\n<line141>}
----------------------------------------
Function: innerLoopLoadRow
Content: <line0>static void innerLoopLoadRow(\n<line1>Parse *pParse,             /* Statement under construction */\n<line2>Select *pSelect,           /* The query being coded */\n<line3>RowLoadInfo *pInfo         /* Info needed to complete the row load */\n<line4>){\n<line5>sqlite3ExprCodeExprList(pParse, pSelect->pEList, pInfo->regResult,\n<line6>0, pInfo->ecelFlags);\n<line7>#ifdef SQLITE_ENABLE_SORTER_REFERENCES\n<line8>if( pInfo->pExtra ){\n<line9>sqlite3ExprCodeExprList(pParse, pInfo->pExtra, pInfo->regExtraResult, 0, 0);\n<line10>sqlite3ExprListDelete(pParse->db, pInfo->pExtra);\n<line11>}\n<line12>#endif\n<line13>}
----------------------------------------
Function: makeSorterRecord
Content: <line0>static int makeSorterRecord(\n<line1>Parse *pParse,\n<line2>SortCtx *pSort,\n<line3>Select *pSelect,\n<line4>int regBase,\n<line5>int nBase\n<line6>){\n<line7>int nOBSat = pSort->nOBSat;\n<line8>Vdbe *v = pParse->pVdbe;\n<line9>int regOut = ++pParse->nMem;\n<line10>if( pSort->pDeferredRowLoad ){\n<line11>innerLoopLoadRow(pParse, pSelect, pSort->pDeferredRowLoad);\n<line12>}\n<line13>sqlite3VdbeAddOp3(v, OP_MakeRecord, regBase+nOBSat, nBase-nOBSat, regOut);\n<line14>return regOut;\n<line15>}
----------------------------------------
Function: pushOntoSorter
Content: <line0>static void pushOntoSorter(\n<line1>Parse *pParse,         /* Parser context */\n<line2>SortCtx *pSort,        /* Information about the ORDER BY clause */\n<line3>Select *pSelect,       /* The whole SELECT statement */\n<line4>int regData,           /* First register holding data to be sorted */\n<line5>int regOrigData,       /* First register holding data before packing */\n<line6>int nData,             /* Number of elements in the regData data array */\n<line7>int nPrefixReg         /* No. of reg prior to regData available for use */\n<line8>){\n<line9>Vdbe *v = pParse->pVdbe;                         /* Stmt under construction */\n<line10>int bSeq = ((pSort->sortFlags & SORTFLAG_UseSorter)==0);\n<line11>int nExpr = pSort->pOrderBy->nExpr;              /* No. of ORDER BY terms */\n<line12>int nBase = nExpr + bSeq + nData;                /* Fields in sorter record */\n<line13>int regBase;                                     /* Regs for sorter record */\n<line14>int regRecord = 0;                               /* Assembled sorter record */\n<line15>int nOBSat = pSort->nOBSat;                      /* ORDER BY terms to skip */\n<line16>int op;                            /* Opcode to add sorter record to sorter */\n<line17>int iLimit;                        /* LIMIT counter */\n<line18>int iSkip = 0;                     /* End of the sorter insert loop */\n<line19>assert( bSeq==0 || bSeq==1 );\n<line20>/* Three cases:\n<line21>**   (1) The data to be sorted has already been packed into a Record\n<line22>**       by a prior OP_MakeRecord.  In this case nData==1 and regData\n<line23>**       will be completely unrelated to regOrigData.\n<line24>**   (2) All output columns are included in the sort record.  In that\n<line25>**       case regData==regOrigData.\n<line26>**   (3) Some output columns are omitted from the sort record due to\n<line27>**       the SQLITE_ENABLE_SORTER_REFERENCES optimization, or due to the\n<line28>**       SQLITE_ECEL_OMITREF optimization, or due to the\n<line29>**       SortCtx.pDeferredRowLoad optimization.  In any of these cases\n<line30>**       regOrigData is 0 to prevent this routine from trying to copy\n<line31>**       values that might not yet exist.\n<line32>*/\n<line33>assert( nData==1 || regData==regOrigData || regOrigData==0 );\n<line34>#ifdef SQLITE_ENABLE_STMT_SCANSTATUS\n<line35>pSort->addrPush = sqlite3VdbeCurrentAddr(v);\n<line36>#endif\n<line37>if( nPrefixReg ){\n<line38>assert( nPrefixReg==nExpr+bSeq );\n<line39>regBase = regData - nPrefixReg;\n<line40>}else{\n<line41>regBase = pParse->nMem + 1;\n<line42>pParse->nMem += nBase;\n<line43>}\n<line44>assert( pSelect->iOffset==0 || pSelect->iLimit!=0 );\n<line45>iLimit = pSelect->iOffset ? pSelect->iOffset+1 : pSelect->iLimit;\n<line46>pSort->labelDone = sqlite3VdbeMakeLabel(pParse);\n<line47>sqlite3ExprCodeExprList(pParse, pSort->pOrderBy, regBase, regOrigData,\n<line48>SQLITE_ECEL_DUP | (regOrigData? SQLITE_ECEL_REF : 0));\n<line49>if( bSeq ){\n<line50>sqlite3VdbeAddOp2(v, OP_Sequence, pSort->iECursor, regBase+nExpr);\n<line51>}\n<line52>if( nPrefixReg==0 && nData>0 ){\n<line53>sqlite3ExprCodeMove(pParse, regData, regBase+nExpr+bSeq, nData);\n<line54>}\n<line55>if( nOBSat>0 ){\n<line56>int regPrevKey;   /* The first nOBSat columns of the previous row */\n<line57>int addrFirst;    /* Address of the OP_IfNot opcode */\n<line58>int addrJmp;      /* Address of the OP_Jump opcode */\n<line59>VdbeOp *pOp;      /* Opcode that opens the sorter */\n<line60>int nKey;         /* Number of sorting key columns, including OP_Sequence */\n<line61>KeyInfo *pKI;     /* Original KeyInfo on the sorter table */\n<line62>regRecord = makeSorterRecord(pParse, pSort, pSelect, regBase, nBase);\n<line63>regPrevKey = pParse->nMem+1;\n<line64>pParse->nMem += pSort->nOBSat;\n<line65>nKey = nExpr - pSort->nOBSat + bSeq;\n<line66>if( bSeq ){\n<line67>addrFirst = sqlite3VdbeAddOp1(v, OP_IfNot, regBase+nExpr);\n<line68>}else{\n<line69>addrFirst = sqlite3VdbeAddOp1(v, OP_SequenceTest, pSort->iECursor);\n<line70>}\n<line71>VdbeCoverage(v);\n<line72>sqlite3VdbeAddOp3(v, OP_Compare, regPrevKey, regBase, pSort->nOBSat);\n<line73>pOp = sqlite3VdbeGetOp(v, pSort->addrSortIndex);\n<line74>if( pParse->db->mallocFailed ) return;\n<line75>pOp->p2 = nKey + nData;\n<line76>pKI = pOp->p4.pKeyInfo;\n<line77>memset(pKI->aSortFlags, 0, pKI->nKeyField); /* Makes OP_Jump testable */\n<line78>sqlite3VdbeChangeP4(v, -1, (char*)pKI, P4_KEYINFO);\n<line79>testcase( pKI->nAllField > pKI->nKeyField+2 );\n<line80>pOp->p4.pKeyInfo = sqlite3KeyInfoFromExprList(pParse,pSort->pOrderBy,nOBSat,\n<line81>pKI->nAllField-pKI->nKeyField-1);\n<line82>pOp = 0; /* Ensure pOp not used after sqlite3VdbeAddOp3() */\n<line83>addrJmp = sqlite3VdbeCurrentAddr(v);\n<line84>sqlite3VdbeAddOp3(v, OP_Jump, addrJmp+1, 0, addrJmp+1); VdbeCoverage(v);\n<line85>pSort->labelBkOut = sqlite3VdbeMakeLabel(pParse);\n<line86>pSort->regReturn = ++pParse->nMem;\n<line87>sqlite3VdbeAddOp2(v, OP_Gosub, pSort->regReturn, pSort->labelBkOut);\n<line88>sqlite3VdbeAddOp1(v, OP_ResetSorter, pSort->iECursor);\n<line89>if( iLimit ){\n<line90>sqlite3VdbeAddOp2(v, OP_IfNot, iLimit, pSort->labelDone);\n<line91>VdbeCoverage(v);\n<line92>}\n<line93>sqlite3VdbeJumpHere(v, addrFirst);\n<line94>sqlite3ExprCodeMove(pParse, regBase, regPrevKey, pSort->nOBSat);\n<line95>sqlite3VdbeJumpHere(v, addrJmp);\n<line96>}\n<line97>if( iLimit ){\n<line98>/* At this point the values for the new sorter entry are stored\n<line99>** in an array of registers. They need to be composed into a record\n<line100>** and inserted into the sorter if either (a) there are currently\n<line101>** less than LIMIT+OFFSET items or (b) the new record is smaller than\n<line102>** the largest record currently in the sorter. If (b) is true and there\n<line103>** are already LIMIT+OFFSET items in the sorter, delete the largest\n<line104>** entry before inserting the new one. This way there are never more\n<line105>** than LIMIT+OFFSET items in the sorter.\n<line106>**\n<line107>** If the new record does not need to be inserted into the sorter,\n<line108>** jump to the next iteration of the loop. If the pSort->labelOBLopt\n<line109>** value is not zero, then it is a label of where to jump.  Otherwise,\n<line110>** just bypass the row insert logic.  See the header comment on the\n<line111>** sqlite3WhereOrderByLimitOptLabel() function for additional info.\n<line112>*/\n<line113>int iCsr = pSort->iECursor;\n<line114>sqlite3VdbeAddOp2(v, OP_IfNotZero, iLimit, sqlite3VdbeCurrentAddr(v)+4);\n<line115>VdbeCoverage(v);\n<line116>sqlite3VdbeAddOp2(v, OP_Last, iCsr, 0);\n<line117>iSkip = sqlite3VdbeAddOp4Int(v, OP_IdxLE,\n<line118>iCsr, 0, regBase+nOBSat, nExpr-nOBSat);\n<line119>VdbeCoverage(v);\n<line120>sqlite3VdbeAddOp1(v, OP_Delete, iCsr);\n<line121>}\n<line122>if( regRecord==0 ){\n<line123>regRecord = makeSorterRecord(pParse, pSort, pSelect, regBase, nBase);\n<line124>}\n<line125>if( pSort->sortFlags & SORTFLAG_UseSorter ){\n<line126>op = OP_SorterInsert;\n<line127>}else{\n<line128>op = OP_IdxInsert;\n<line129>}\n<line130>sqlite3VdbeAddOp4Int(v, op, pSort->iECursor, regRecord,\n<line131>regBase+nOBSat, nBase-nOBSat);\n<line132>if( iSkip ){\n<line133>sqlite3VdbeChangeP2(v, iSkip,\n<line134>pSort->labelOBLopt ? pSort->labelOBLopt : sqlite3VdbeCurrentAddr(v));\n<line135>}\n<line136>#ifdef SQLITE_ENABLE_STMT_SCANSTATUS\n<line137>pSort->addrPushEnd = sqlite3VdbeCurrentAddr(v)-1;\n<line138>#endif\n<line139>}
----------------------------------------
Function: codeOffset
Content: <line0>static void codeOffset(\n<line1>Vdbe *v,          /* Generate code into this VM */\n<line2>int iOffset,      /* Register holding the offset counter */\n<line3>int iContinue     /* Jump here to skip the current record */\n<line4>){\n<line5>if( iOffset>0 ){\n<line6>sqlite3VdbeAddOp3(v, OP_IfPos, iOffset, iContinue, 1); VdbeCoverage(v);\n<line7>VdbeComment((v, "OFFSET"));\n<line8>}\n<line9>}
----------------------------------------
Function: codeDistinct
Content: <line0>static int codeDistinct(\n<line1>Parse *pParse,     /* Parsing and code generating context */\n<line2>int eTnctType,     /* WHERE_DISTINCT_* value */\n<line3>int iTab,          /* A sorting index used to test for distinctness */\n<line4>int addrRepeat,    /* Jump to here if not distinct */\n<line5>ExprList *pEList,  /* Expression for each element */\n<line6>int regElem        /* First element */\n<line7>){\n<line8>int iRet = 0;\n<line9>int nResultCol = pEList->nExpr;\n<line10>Vdbe *v = pParse->pVdbe;\n<line11>switch( eTnctType ){\n<line12>case WHERE_DISTINCT_ORDERED: {\n<line13>int i;\n<line14>int iJump;              /* Jump destination */\n<line15>int regPrev;            /* Previous row content */\n<line16>/* Allocate space for the previous row */\n<line17>iRet = regPrev = pParse->nMem+1;\n<line18>pParse->nMem += nResultCol;\n<line19>iJump = sqlite3VdbeCurrentAddr(v) + nResultCol;\n<line20>for(i=0; i<nResultCol; i++){\n<line21>CollSeq *pColl = sqlite3ExprCollSeq(pParse, pEList->a[i].pExpr);\n<line22>if( i<nResultCol-1 ){\n<line23>sqlite3VdbeAddOp3(v, OP_Ne, regElem+i, iJump, regPrev+i);\n<line24>VdbeCoverage(v);\n<line25>}else{\n<line26>sqlite3VdbeAddOp3(v, OP_Eq, regElem+i, addrRepeat, regPrev+i);\n<line27>VdbeCoverage(v);\n<line28>}\n<line29>sqlite3VdbeChangeP4(v, -1, (const char *)pColl, P4_COLLSEQ);\n<line30>sqlite3VdbeChangeP5(v, SQLITE_NULLEQ);\n<line31>}\n<line32>assert( sqlite3VdbeCurrentAddr(v)==iJump || pParse->db->mallocFailed );\n<line33>sqlite3VdbeAddOp3(v, OP_Copy, regElem, regPrev, nResultCol-1);\n<line34>break;\n<line35>}\n<line36>case WHERE_DISTINCT_UNIQUE: {\n<line37>/* nothing to do */\n<line38>break;\n<line39>}\n<line40>default: {\n<line41>int r1 = sqlite3GetTempReg(pParse);\n<line42>sqlite3VdbeAddOp4Int(v, OP_Found, iTab, addrRepeat, regElem, nResultCol);\n<line43>VdbeCoverage(v);\n<line44>sqlite3VdbeAddOp3(v, OP_MakeRecord, regElem, nResultCol, r1);\n<line45>sqlite3VdbeAddOp4Int(v, OP_IdxInsert, iTab, r1, regElem, nResultCol);\n<line46>sqlite3VdbeChangeP5(v, OPFLAG_USESEEKRESULT);\n<line47>sqlite3ReleaseTempReg(pParse, r1);\n<line48>iRet = iTab;\n<line49>break;\n<line50>}\n<line51>}\n<line52>return iRet;\n<line53>}
----------------------------------------
Function: fixDistinctOpenEph
Content: <line0>static void fixDistinctOpenEph(\n<line1>Parse *pParse,     /* Parsing and code generating context */\n<line2>int eTnctType,     /* WHERE_DISTINCT_* value */\n<line3>int iVal,          /* Value returned by codeDistinct() */\n<line4>int iOpenEphAddr   /* Address of OP_OpenEphemeral instruction for iTab */\n<line5>){\n<line6>if( pParse->nErr==0\n<line7>&& (eTnctType==WHERE_DISTINCT_UNIQUE || eTnctType==WHERE_DISTINCT_ORDERED)\n<line8>){\n<line9>Vdbe *v = pParse->pVdbe;\n<line10>sqlite3VdbeChangeToNoop(v, iOpenEphAddr);\n<line11>if( sqlite3VdbeGetOp(v, iOpenEphAddr+1)->opcode==OP_Explain ){\n<line12>sqlite3VdbeChangeToNoop(v, iOpenEphAddr+1);\n<line13>}\n<line14>if( eTnctType==WHERE_DISTINCT_ORDERED ){\n<line15>/* Change the OP_OpenEphemeral to an OP_Null that sets the MEM_Cleared\n<line16>** bit on the first register of the previous value.  This will cause the\n<line17>** OP_Ne added in codeDistinct() to always fail on the first iteration of\n<line18>** the loop even if the first row is all NULLs.  */\n<line19>VdbeOp *pOp = sqlite3VdbeGetOp(v, iOpenEphAddr);\n<line20>pOp->opcode = OP_Null;\n<line21>pOp->p1 = 1;\n<line22>pOp->p2 = iVal;\n<line23>}\n<line24>}\n<line25>}
----------------------------------------
Function: selectInnerLoop
Content: <line0>static void selectInnerLoop(\n<line1>Parse *pParse,          /* The parser context */\n<line2>Select *p,              /* The complete select statement being coded */\n<line3>int srcTab,             /* Pull data from this table if non-negative */\n<line4>SortCtx *pSort,         /* If not NULL, info on how to process ORDER BY */\n<line5>DistinctCtx *pDistinct, /* If not NULL, info on how to process DISTINCT */\n<line6>SelectDest *pDest,      /* How to dispose of the results */\n<line7>int iContinue,          /* Jump here to continue with next row */\n<line8>int iBreak              /* Jump here to break out of the inner loop */\n<line9>){\n<line10>Vdbe *v = pParse->pVdbe;\n<line11>int i;\n<line12>int hasDistinct;            /* True if the DISTINCT keyword is present */\n<line13>int eDest = pDest->eDest;   /* How to dispose of results */\n<line14>int iParm = pDest->iSDParm; /* First argument to disposal method */\n<line15>int nResultCol;             /* Number of result columns */\n<line16>int nPrefixReg = 0;         /* Number of extra registers before regResult */\n<line17>RowLoadInfo sRowLoadInfo;   /* Info for deferred row loading */\n<line18>/* Usually, regResult is the first cell in an array of memory cells\n<line19>** containing the current result row. In this case regOrig is set to the\n<line20>** same value. However, if the results are being sent to the sorter, the\n<line21>** values for any expressions that are also part of the sort-key are omitted\n<line22>** from this array. In this case regOrig is set to zero.  */\n<line23>int regResult;              /* Start of memory holding current results */\n<line24>int regOrig;                /* Start of memory holding full result (or 0) */\n<line25>assert( v );\n<line26>assert( p->pEList!=0 );\n<line27>hasDistinct = pDistinct ? pDistinct->eTnctType : WHERE_DISTINCT_NOOP;\n<line28>if( pSort && pSort->pOrderBy==0 ) pSort = 0;\n<line29>if( pSort==0 && !hasDistinct ){\n<line30>assert( iContinue!=0 );\n<line31>codeOffset(v, p->iOffset, iContinue);\n<line32>}\n<line33>/* Pull the requested columns.\n<line34>*/\n<line35>nResultCol = p->pEList->nExpr;\n<line36>if( pDest->iSdst==0 ){\n<line37>if( pSort ){\n<line38>nPrefixReg = pSort->pOrderBy->nExpr;\n<line39>if( !(pSort->sortFlags & SORTFLAG_UseSorter) ) nPrefixReg++;\n<line40>pParse->nMem += nPrefixReg;\n<line41>}\n<line42>pDest->iSdst = pParse->nMem+1;\n<line43>pParse->nMem += nResultCol;\n<line44>}else if( pDest->iSdst+nResultCol > pParse->nMem ){\n<line45>/* This is an error condition that can result, for example, when a SELECT\n<line46>** on the right-hand side of an INSERT contains more result columns than\n<line47>** there are columns in the table on the left.  The error will be caught\n<line48>** and reported later.  But we need to make sure enough memory is allocated\n<line49>** to avoid other spurious errors in the meantime. */\n<line50>pParse->nMem += nResultCol;\n<line51>}\n<line52>pDest->nSdst = nResultCol;\n<line53>regOrig = regResult = pDest->iSdst;\n<line54>if( srcTab>=0 ){\n<line55>for(i=0; i<nResultCol; i++){\n<line56>sqlite3VdbeAddOp3(v, OP_Column, srcTab, i, regResult+i);\n<line57>VdbeComment((v, "%s", p->pEList->a[i].zEName));\n<line58>}\n<line59>}else if( eDest!=SRT_Exists ){\n<line60>#ifdef SQLITE_ENABLE_SORTER_REFERENCES\n<line61>ExprList *pExtra = 0;\n<line62>#endif\n<line63>/* If the destination is an EXISTS(...) expression, the actual\n<line64>** values returned by the SELECT are not required.\n<line65>*/\n<line66>u8 ecelFlags;    /* "ecel" is an abbreviation of "ExprCodeExprList" */\n<line67>ExprList *pEList;\n<line68>if( eDest==SRT_Mem || eDest==SRT_Output || eDest==SRT_Coroutine ){\n<line69>ecelFlags = SQLITE_ECEL_DUP;\n<line70>}else{\n<line71>ecelFlags = 0;\n<line72>}\n<line73>if( pSort && hasDistinct==0 && eDest!=SRT_EphemTab && eDest!=SRT_Table ){\n<line74>/* For each expression in p->pEList that is a copy of an expression in\n<line75>** the ORDER BY clause (pSort->pOrderBy), set the associated\n<line76>** iOrderByCol value to one more than the index of the ORDER BY\n<line77>** expression within the sort-key that pushOntoSorter() will generate.\n<line78>** This allows the p->pEList field to be omitted from the sorted record,\n<line79>** saving space and CPU cycles.  */\n<line80>ecelFlags |= (SQLITE_ECEL_OMITREF|SQLITE_ECEL_REF);\n<line81>for(i=pSort->nOBSat; i<pSort->pOrderBy->nExpr; i++){\n<line82>int j;\n<line83>if( (j = pSort->pOrderBy->a[i].u.x.iOrderByCol)>0 ){\n<line84>p->pEList->a[j-1].u.x.iOrderByCol = i+1-pSort->nOBSat;\n<line85>}\n<line86>}\n<line87>#ifdef SQLITE_ENABLE_SORTER_REFERENCES\n<line88>selectExprDefer(pParse, pSort, p->pEList, &pExtra);\n<line89>if( pExtra && pParse->db->mallocFailed==0 ){\n<line90>/* If there are any extra PK columns to add to the sorter records,\n<line91>** allocate extra memory cells and adjust the OpenEphemeral\n<line92>** instruction to account for the larger records. This is only\n<line93>** required if there are one or more WITHOUT ROWID tables with\n<line94>** composite primary keys in the SortCtx.aDefer[] array.  */\n<line95>VdbeOp *pOp = sqlite3VdbeGetOp(v, pSort->addrSortIndex);\n<line96>pOp->p2 += (pExtra->nExpr - pSort->nDefer);\n<line97>pOp->p4.pKeyInfo->nAllField += (pExtra->nExpr - pSort->nDefer);\n<line98>pParse->nMem += pExtra->nExpr;\n<line99>}\n<line100>#endif\n<line101>/* Adjust nResultCol to account for columns that are omitted\n<line102>** from the sorter by the optimizations in this branch */\n<line103>pEList = p->pEList;\n<line104>for(i=0; i<pEList->nExpr; i++){\n<line105>if( pEList->a[i].u.x.iOrderByCol>0\n<line106>#ifdef SQLITE_ENABLE_SORTER_REFERENCES\n<line107>|| pEList->a[i].fg.bSorterRef\n<line108>#endif\n<line109>){\n<line110>nResultCol--;\n<line111>regOrig = 0;\n<line112>}\n<line113>}\n<line114>testcase( regOrig );\n<line115>testcase( eDest==SRT_Set );\n<line116>testcase( eDest==SRT_Mem );\n<line117>testcase( eDest==SRT_Coroutine );\n<line118>testcase( eDest==SRT_Output );\n<line119>assert( eDest==SRT_Set || eDest==SRT_Mem\n<line120>|| eDest==SRT_Coroutine || eDest==SRT_Output\n<line121>|| eDest==SRT_Upfrom );\n<line122>}\n<line123>sRowLoadInfo.regResult = regResult;\n<line124>sRowLoadInfo.ecelFlags = ecelFlags;\n<line125>#ifdef SQLITE_ENABLE_SORTER_REFERENCES\n<line126>sRowLoadInfo.pExtra = pExtra;\n<line127>sRowLoadInfo.regExtraResult = regResult + nResultCol;\n<line128>if( pExtra ) nResultCol += pExtra->nExpr;\n<line129>#endif\n<line130>if( p->iLimit\n<line131>&& (ecelFlags & SQLITE_ECEL_OMITREF)!=0\n<line132>&& nPrefixReg>0\n<line133>){\n<line134>assert( pSort!=0 );\n<line135>assert( hasDistinct==0 );\n<line136>pSort->pDeferredRowLoad = &sRowLoadInfo;\n<line137>regOrig = 0;\n<line138>}else{\n<line139>innerLoopLoadRow(pParse, p, &sRowLoadInfo);\n<line140>}\n<line141>}\n<line142>/* If the DISTINCT keyword was present on the SELECT statement\n<line143>** and this row has been seen before, then do not make this row\n<line144>** part of the result.\n<line145>*/\n<line146>if( hasDistinct ){\n<line147>int eType = pDistinct->eTnctType;\n<line148>int iTab = pDistinct->tabTnct;\n<line149>assert( nResultCol==p->pEList->nExpr );\n<line150>iTab = codeDistinct(pParse, eType, iTab, iContinue, p->pEList, regResult);\n<line151>fixDistinctOpenEph(pParse, eType, iTab, pDistinct->addrTnct);\n<line152>if( pSort==0 ){\n<line153>codeOffset(v, p->iOffset, iContinue);\n<line154>}\n<line155>}\n<line156>switch( eDest ){\n<line157>/* In this mode, write each query result to the key of the temporary\n<line158>** table iParm.\n<line159>*/\n<line160>#ifndef SQLITE_OMIT_COMPOUND_SELECT\n<line161>case SRT_Union: {\n<line162>int r1;\n<line163>r1 = sqlite3GetTempReg(pParse);\n<line164>sqlite3VdbeAddOp3(v, OP_MakeRecord, regResult, nResultCol, r1);\n<line165>sqlite3VdbeAddOp4Int(v, OP_IdxInsert, iParm, r1, regResult, nResultCol);\n<line166>sqlite3ReleaseTempReg(pParse, r1);\n<line167>break;\n<line168>}\n<line169>/* Construct a record from the query result, but instead of\n<line170>** saving that record, use it as a key to delete elements from\n<line171>** the temporary table iParm.\n<line172>*/\n<line173>case SRT_Except: {\n<line174>sqlite3VdbeAddOp3(v, OP_IdxDelete, iParm, regResult, nResultCol);\n<line175>break;\n<line176>}\n<line177>#endif /* SQLITE_OMIT_COMPOUND_SELECT */\n<line178>/* Store the result as data using a unique key.\n<line179>*/\n<line180>case SRT_Fifo:\n<line181>case SRT_DistFifo:\n<line182>case SRT_Table:\n<line183>case SRT_EphemTab: {\n<line184>int r1 = sqlite3GetTempRange(pParse, nPrefixReg+1);\n<line185>testcase( eDest==SRT_Table );\n<line186>testcase( eDest==SRT_EphemTab );\n<line187>testcase( eDest==SRT_Fifo );\n<line188>testcase( eDest==SRT_DistFifo );\n<line189>sqlite3VdbeAddOp3(v, OP_MakeRecord, regResult, nResultCol, r1+nPrefixReg);\n<line190>#if !defined(SQLITE_ENABLE_NULL_TRIM) && defined(SQLITE_DEBUG)\n<line191>/* A destination of SRT_Table and a non-zero iSDParm2 parameter means\n<line192>** that this is an "UPDATE ... FROM" on a virtual table or view. In this\n<line193>** case set the p5 parameter of the OP_MakeRecord to OPFLAG_NOCHNG_MAGIC.\n<line194>** This does not affect operation in any way - it just allows MakeRecord\n<line195>** to process OPFLAG_NOCHANGE values without an assert() failing. */\n<line196>if( eDest==SRT_Table && pDest->iSDParm2 ){\n<line197>sqlite3VdbeChangeP5(v, OPFLAG_NOCHNG_MAGIC);\n<line198>}\n<line199>#endif\n<line200>#ifndef SQLITE_OMIT_CTE\n<line201>if( eDest==SRT_DistFifo ){\n<line202>/* If the destination is DistFifo, then cursor (iParm+1) is open\n<line203>** on an ephemeral index. If the current row is already present\n<line204>** in the index, do not write it to the output. If not, add the\n<line205>** current row to the index and proceed with writing it to the\n<line206>** output table as well.  */\n<line207>int addr = sqlite3VdbeCurrentAddr(v) + 4;\n<line208>sqlite3VdbeAddOp4Int(v, OP_Found, iParm+1, addr, r1, 0);\n<line209>VdbeCoverage(v);\n<line210>sqlite3VdbeAddOp4Int(v, OP_IdxInsert, iParm+1, r1,regResult,nResultCol);\n<line211>assert( pSort==0 );\n<line212>}\n<line213>#endif\n<line214>if( pSort ){\n<line215>assert( regResult==regOrig );\n<line216>pushOntoSorter(pParse, pSort, p, r1+nPrefixReg, regOrig, 1, nPrefixReg);\n<line217>}else{\n<line218>int r2 = sqlite3GetTempReg(pParse);\n<line219>sqlite3VdbeAddOp2(v, OP_NewRowid, iParm, r2);\n<line220>sqlite3VdbeAddOp3(v, OP_Insert, iParm, r1, r2);\n<line221>sqlite3VdbeChangeP5(v, OPFLAG_APPEND);\n<line222>sqlite3ReleaseTempReg(pParse, r2);\n<line223>}\n<line224>sqlite3ReleaseTempRange(pParse, r1, nPrefixReg+1);\n<line225>break;\n<line226>}\n<line227>case SRT_Upfrom: {\n<line228>if( pSort ){\n<line229>pushOntoSorter(\n<line230>pParse, pSort, p, regResult, regOrig, nResultCol, nPrefixReg);\n<line231>}else{\n<line232>int i2 = pDest->iSDParm2;\n<line233>int r1 = sqlite3GetTempReg(pParse);\n<line234>/* If the UPDATE FROM join is an aggregate that matches no rows, it\n<line235>** might still be trying to return one row, because that is what\n<line236>** aggregates do.  Don't record that empty row in the output table. */\n<line237>sqlite3VdbeAddOp2(v, OP_IsNull, regResult, iBreak); VdbeCoverage(v);\n<line238>sqlite3VdbeAddOp3(v, OP_MakeRecord,\n<line239>regResult+(i2<0), nResultCol-(i2<0), r1);\n<line240>if( i2<0 ){\n<line241>sqlite3VdbeAddOp3(v, OP_Insert, iParm, r1, regResult);\n<line242>}else{\n<line243>sqlite3VdbeAddOp4Int(v, OP_IdxInsert, iParm, r1, regResult, i2);\n<line244>}\n<line245>}\n<line246>break;\n<line247>}\n<line248>#ifndef SQLITE_OMIT_SUBQUERY\n<line249>/* If we are creating a set for an "expr IN (SELECT ...)" construct,\n<line250>** then there should be a single item on the stack.  Write this\n<line251>** item into the set table with bogus data.\n<line252>*/\n<line253>case SRT_Set: {\n<line254>if( pSort ){\n<line255>/* At first glance you would think we could optimize out the\n<line256>** ORDER BY in this case since the order of entries in the set\n<line257>** does not matter.  But there might be a LIMIT clause, in which\n<line258>** case the order does matter */\n<line259>pushOntoSorter(\n<line260>pParse, pSort, p, regResult, regOrig, nResultCol, nPrefixReg);\n<line261>pDest->iSDParm2 = 0; /* Signal that any Bloom filter is unpopulated */\n<line262>}else{\n<line263>int r1 = sqlite3GetTempReg(pParse);\n<line264>assert( sqlite3Strlen30(pDest->zAffSdst)==nResultCol );\n<line265>sqlite3VdbeAddOp4(v, OP_MakeRecord, regResult, nResultCol,\n<line266>r1, pDest->zAffSdst, nResultCol);\n<line267>sqlite3VdbeAddOp4Int(v, OP_IdxInsert, iParm, r1, regResult, nResultCol);\n<line268>if( pDest->iSDParm2 ){\n<line269>sqlite3VdbeAddOp4Int(v, OP_FilterAdd, pDest->iSDParm2, 0,\n<line270>regResult, nResultCol);\n<line271>ExplainQueryPlan((pParse, 0, "CREATE BLOOM FILTER"));\n<line272>}\n<line273>sqlite3ReleaseTempReg(pParse, r1);\n<line274>}\n<line275>break;\n<line276>}\n<line277>/* If any row exist in the result set, record that fact and abort.\n<line278>*/\n<line279>case SRT_Exists: {\n<line280>sqlite3VdbeAddOp2(v, OP_Integer, 1, iParm);\n<line281>/* The LIMIT clause will terminate the loop for us */\n<line282>break;\n<line283>}\n<line284>/* If this is a scalar select that is part of an expression, then\n<line285>** store the results in the appropriate memory cell or array of\n<line286>** memory cells and break out of the scan loop.\n<line287>*/\n<line288>case SRT_Mem: {\n<line289>if( pSort ){\n<line290>assert( nResultCol<=pDest->nSdst );\n<line291>pushOntoSorter(\n<line292>pParse, pSort, p, regResult, regOrig, nResultCol, nPrefixReg);\n<line293>}else{\n<line294>assert( nResultCol==pDest->nSdst );\n<line295>assert( regResult==iParm );\n<line296>/* The LIMIT clause will jump out of the loop for us */\n<line297>}\n<line298>break;\n<line299>}\n<line300>#endif /* #ifndef SQLITE_OMIT_SUBQUERY */\n<line301>case SRT_Coroutine:       /* Send data to a co-routine */\n<line302>case SRT_Output: {        /* Return the results */\n<line303>testcase( eDest==SRT_Coroutine );\n<line304>testcase( eDest==SRT_Output );\n<line305>if( pSort ){\n<line306>pushOntoSorter(pParse, pSort, p, regResult, regOrig, nResultCol,\n<line307>nPrefixReg);\n<line308>}else if( eDest==SRT_Coroutine ){\n<line309>sqlite3VdbeAddOp1(v, OP_Yield, pDest->iSDParm);\n<line310>}else{\n<line311>sqlite3VdbeAddOp2(v, OP_ResultRow, regResult, nResultCol);\n<line312>}\n<line313>break;\n<line314>}\n<line315>#ifndef SQLITE_OMIT_CTE\n<line316>/* Write the results into a priority queue that is order according to\n<line317>** pDest->pOrderBy (in pSO).  pDest->iSDParm (in iParm) is the cursor for an\n<line318>** index with pSO->nExpr+2 columns.  Build a key using pSO for the first\n<line319>** pSO->nExpr columns, then make sure all keys are unique by adding a\n<line320>** final OP_Sequence column.  The last column is the record as a blob.\n<line321>*/\n<line322>case SRT_DistQueue:\n<line323>case SRT_Queue: {\n<line324>int nKey;\n<line325>int r1, r2, r3;\n<line326>int addrTest = 0;\n<line327>ExprList *pSO;\n<line328>pSO = pDest->pOrderBy;\n<line329>assert( pSO );\n<line330>nKey = pSO->nExpr;\n<line331>r1 = sqlite3GetTempReg(pParse);\n<line332>r2 = sqlite3GetTempRange(pParse, nKey+2);\n<line333>r3 = r2+nKey+1;\n<line334>if( eDest==SRT_DistQueue ){\n<line335>/* If the destination is DistQueue, then cursor (iParm+1) is open\n<line336>** on a second ephemeral index that holds all values every previously\n<line337>** added to the queue. */\n<line338>addrTest = sqlite3VdbeAddOp4Int(v, OP_Found, iParm+1, 0,\n<line339>regResult, nResultCol);\n<line340>VdbeCoverage(v);\n<line341>}\n<line342>sqlite3VdbeAddOp3(v, OP_MakeRecord, regResult, nResultCol, r3);\n<line343>if( eDest==SRT_DistQueue ){\n<line344>sqlite3VdbeAddOp2(v, OP_IdxInsert, iParm+1, r3);\n<line345>sqlite3VdbeChangeP5(v, OPFLAG_USESEEKRESULT);\n<line346>}\n<line347>for(i=0; i<nKey; i++){\n<line348>sqlite3VdbeAddOp2(v, OP_SCopy,\n<line349>regResult + pSO->a[i].u.x.iOrderByCol - 1,\n<line350>r2+i);\n<line351>}\n<line352>sqlite3VdbeAddOp2(v, OP_Sequence, iParm, r2+nKey);\n<line353>sqlite3VdbeAddOp3(v, OP_MakeRecord, r2, nKey+2, r1);\n<line354>sqlite3VdbeAddOp4Int(v, OP_IdxInsert, iParm, r1, r2, nKey+2);\n<line355>if( addrTest ) sqlite3VdbeJumpHere(v, addrTest);\n<line356>sqlite3ReleaseTempReg(pParse, r1);\n<line357>sqlite3ReleaseTempRange(pParse, r2, nKey+2);\n<line358>break;\n<line359>}\n<line360>#endif /* SQLITE_OMIT_CTE */\n<line361>#if !defined(SQLITE_OMIT_TRIGGER)\n<line362>/* Discard the results.  This is used for SELECT statements inside\n<line363>** the body of a TRIGGER.  The purpose of such selects is to call\n<line364>** user-defined functions that have side effects.  We do not care\n<line365>** about the actual results of the select.\n<line366>*/\n<line367>default: {\n<line368>assert( eDest==SRT_Discard );\n<line369>break;\n<line370>}\n<line371>#endif\n<line372>}\n<line373>/* Jump to the end of the loop if the LIMIT is reached.  Except, if\n<line374>** there is a sorter, in which case the sorter has already limited\n<line375>** the output for us.\n<line376>*/\n<line377>if( pSort==0 && p->iLimit ){\n<line378>sqlite3VdbeAddOp2(v, OP_DecrJumpZero, p->iLimit, iBreak); VdbeCoverage(v);\n<line379>}\n<line380>}
----------------------------------------
Function: explainTempTable
Content: <line0>static void explainTempTable(Parse *pParse, const char *zUsage){\n<line1>ExplainQueryPlan((pParse, 0, "USE TEMP B-TREE FOR %s", zUsage));\n<line2>}
----------------------------------------
Function: generateSortTail
Content: <line0>static void generateSortTail(\n<line1>Parse *pParse,    /* Parsing context */\n<line2>Select *p,        /* The SELECT statement */\n<line3>SortCtx *pSort,   /* Information on the ORDER BY clause */\n<line4>int nColumn,      /* Number of columns of data */\n<line5>SelectDest *pDest /* Write the sorted results here */\n<line6>){\n<line7>Vdbe *v = pParse->pVdbe;                     /* The prepared statement */\n<line8>int addrBreak = pSort->labelDone;            /* Jump here to exit loop */\n<line9>int addrContinue = sqlite3VdbeMakeLabel(pParse);/* Jump here for next cycle */\n<line10>int addr;                       /* Top of output loop. Jump for Next. */\n<line11>int addrOnce = 0;\n<line12>int iTab;\n<line13>ExprList *pOrderBy = pSort->pOrderBy;\n<line14>int eDest = pDest->eDest;\n<line15>int iParm = pDest->iSDParm;\n<line16>int regRow;\n<line17>int regRowid;\n<line18>int iCol;\n<line19>int nKey;                       /* Number of key columns in sorter record */\n<line20>int iSortTab;                   /* Sorter cursor to read from */\n<line21>int i;\n<line22>int bSeq;                       /* True if sorter record includes seq. no. */\n<line23>int nRefKey = 0;\n<line24>struct ExprList_item *aOutEx = p->pEList->a;\n<line25>#ifdef SQLITE_ENABLE_STMT_SCANSTATUS\n<line26>int addrExplain;                /* Address of OP_Explain instruction */\n<line27>#endif\n<line28>nKey = pOrderBy->nExpr - pSort->nOBSat;\n<line29>if( pSort->nOBSat==0 || nKey==1 ){\n<line30>ExplainQueryPlan2(addrExplain, (pParse, 0,\n<line31>"USE TEMP B-TREE FOR %sORDER BY", pSort->nOBSat?"LAST TERM OF ":""\n<line32>));\n<line33>}else{\n<line34>ExplainQueryPlan2(addrExplain, (pParse, 0,\n<line35>"USE TEMP B-TREE FOR LAST %d TERMS OF ORDER BY", nKey\n<line36>));\n<line37>}\n<line38>sqlite3VdbeScanStatusRange(v, addrExplain,pSort->addrPush,pSort->addrPushEnd);\n<line39>sqlite3VdbeScanStatusCounters(v, addrExplain, addrExplain, pSort->addrPush);\n<line40>assert( addrBreak<0 );\n<line41>if( pSort->labelBkOut ){\n<line42>sqlite3VdbeAddOp2(v, OP_Gosub, pSort->regReturn, pSort->labelBkOut);\n<line43>sqlite3VdbeGoto(v, addrBreak);\n<line44>sqlite3VdbeResolveLabel(v, pSort->labelBkOut);\n<line45>}\n<line46>#ifdef SQLITE_ENABLE_SORTER_REFERENCES\n<line47>/* Open any cursors needed for sorter-reference expressions */\n<line48>for(i=0; i<pSort->nDefer; i++){\n<line49>Table *pTab = pSort->aDefer[i].pTab;\n<line50>int iDb = sqlite3SchemaToIndex(pParse->db, pTab->pSchema);\n<line51>sqlite3OpenTable(pParse, pSort->aDefer[i].iCsr, iDb, pTab, OP_OpenRead);\n<line52>nRefKey = MAX(nRefKey, pSort->aDefer[i].nKey);\n<line53>}\n<line54>#endif\n<line55>iTab = pSort->iECursor;\n<line56>if( eDest==SRT_Output || eDest==SRT_Coroutine || eDest==SRT_Mem ){\n<line57>if( eDest==SRT_Mem && p->iOffset ){\n<line58>sqlite3VdbeAddOp2(v, OP_Null, 0, pDest->iSdst);\n<line59>}\n<line60>regRowid = 0;\n<line61>regRow = pDest->iSdst;\n<line62>}else{\n<line63>regRowid = sqlite3GetTempReg(pParse);\n<line64>if( eDest==SRT_EphemTab || eDest==SRT_Table ){\n<line65>regRow = sqlite3GetTempReg(pParse);\n<line66>nColumn = 0;\n<line67>}else{\n<line68>regRow = sqlite3GetTempRange(pParse, nColumn);\n<line69>}\n<line70>}\n<line71>if( pSort->sortFlags & SORTFLAG_UseSorter ){\n<line72>int regSortOut = ++pParse->nMem;\n<line73>iSortTab = pParse->nTab++;\n<line74>if( pSort->labelBkOut ){\n<line75>addrOnce = sqlite3VdbeAddOp0(v, OP_Once); VdbeCoverage(v);\n<line76>}\n<line77>sqlite3VdbeAddOp3(v, OP_OpenPseudo, iSortTab, regSortOut,\n<line78>nKey+1+nColumn+nRefKey);\n<line79>if( addrOnce ) sqlite3VdbeJumpHere(v, addrOnce);\n<line80>addr = 1 + sqlite3VdbeAddOp2(v, OP_SorterSort, iTab, addrBreak);\n<line81>VdbeCoverage(v);\n<line82>assert( p->iLimit==0 && p->iOffset==0 );\n<line83>sqlite3VdbeAddOp3(v, OP_SorterData, iTab, regSortOut, iSortTab);\n<line84>bSeq = 0;\n<line85>}else{\n<line86>addr = 1 + sqlite3VdbeAddOp2(v, OP_Sort, iTab, addrBreak); VdbeCoverage(v);\n<line87>codeOffset(v, p->iOffset, addrContinue);\n<line88>iSortTab = iTab;\n<line89>bSeq = 1;\n<line90>if( p->iOffset>0 ){\n<line91>sqlite3VdbeAddOp2(v, OP_AddImm, p->iLimit, -1);\n<line92>}\n<line93>}\n<line94>for(i=0, iCol=nKey+bSeq-1; i<nColumn; i++){\n<line95>#ifdef SQLITE_ENABLE_SORTER_REFERENCES\n<line96>if( aOutEx[i].fg.bSorterRef ) continue;\n<line97>#endif\n<line98>if( aOutEx[i].u.x.iOrderByCol==0 ) iCol++;\n<line99>}\n<line100>#ifdef SQLITE_ENABLE_SORTER_REFERENCES\n<line101>if( pSort->nDefer ){\n<line102>int iKey = iCol+1;\n<line103>int regKey = sqlite3GetTempRange(pParse, nRefKey);\n<line104>for(i=0; i<pSort->nDefer; i++){\n<line105>int iCsr = pSort->aDefer[i].iCsr;\n<line106>Table *pTab = pSort->aDefer[i].pTab;\n<line107>int nKey = pSort->aDefer[i].nKey;\n<line108>sqlite3VdbeAddOp1(v, OP_NullRow, iCsr);\n<line109>if( HasRowid(pTab) ){\n<line110>sqlite3VdbeAddOp3(v, OP_Column, iSortTab, iKey++, regKey);\n<line111>sqlite3VdbeAddOp3(v, OP_SeekRowid, iCsr,\n<line112>sqlite3VdbeCurrentAddr(v)+1, regKey);\n<line113>}else{\n<line114>int k;\n<line115>int iJmp;\n<line116>assert( sqlite3PrimaryKeyIndex(pTab)->nKeyCol==nKey );\n<line117>for(k=0; k<nKey; k++){\n<line118>sqlite3VdbeAddOp3(v, OP_Column, iSortTab, iKey++, regKey+k);\n<line119>}\n<line120>iJmp = sqlite3VdbeCurrentAddr(v);\n<line121>sqlite3VdbeAddOp4Int(v, OP_SeekGE, iCsr, iJmp+2, regKey, nKey);\n<line122>sqlite3VdbeAddOp4Int(v, OP_IdxLE, iCsr, iJmp+3, regKey, nKey);\n<line123>sqlite3VdbeAddOp1(v, OP_NullRow, iCsr);\n<line124>}\n<line125>}\n<line126>sqlite3ReleaseTempRange(pParse, regKey, nRefKey);\n<line127>}\n<line128>#endif\n<line129>for(i=nColumn-1; i>=0; i--){\n<line130>#ifdef SQLITE_ENABLE_SORTER_REFERENCES\n<line131>if( aOutEx[i].fg.bSorterRef ){\n<line132>sqlite3ExprCode(pParse, aOutEx[i].pExpr, regRow+i);\n<line133>}else\n<line134>#endif\n<line135>{\n<line136>int iRead;\n<line137>if( aOutEx[i].u.x.iOrderByCol ){\n<line138>iRead = aOutEx[i].u.x.iOrderByCol-1;\n<line139>}else{\n<line140>iRead = iCol--;\n<line141>}\n<line142>sqlite3VdbeAddOp3(v, OP_Column, iSortTab, iRead, regRow+i);\n<line143>VdbeComment((v, "%s", aOutEx[i].zEName));\n<line144>}\n<line145>}\n<line146>sqlite3VdbeScanStatusRange(v, addrExplain, addrExplain, -1);\n<line147>switch( eDest ){\n<line148>case SRT_Table:\n<line149>case SRT_EphemTab: {\n<line150>sqlite3VdbeAddOp3(v, OP_Column, iSortTab, nKey+bSeq, regRow);\n<line151>sqlite3VdbeAddOp2(v, OP_NewRowid, iParm, regRowid);\n<line152>sqlite3VdbeAddOp3(v, OP_Insert, iParm, regRow, regRowid);\n<line153>sqlite3VdbeChangeP5(v, OPFLAG_APPEND);\n<line154>break;\n<line155>}\n<line156>#ifndef SQLITE_OMIT_SUBQUERY\n<line157>case SRT_Set: {\n<line158>assert( nColumn==sqlite3Strlen30(pDest->zAffSdst) );\n<line159>sqlite3VdbeAddOp4(v, OP_MakeRecord, regRow, nColumn, regRowid,\n<line160>pDest->zAffSdst, nColumn);\n<line161>sqlite3VdbeAddOp4Int(v, OP_IdxInsert, iParm, regRowid, regRow, nColumn);\n<line162>break;\n<line163>}\n<line164>case SRT_Mem: {\n<line165>/* The LIMIT clause will terminate the loop for us */\n<line166>break;\n<line167>}\n<line168>#endif\n<line169>case SRT_Upfrom: {\n<line170>int i2 = pDest->iSDParm2;\n<line171>int r1 = sqlite3GetTempReg(pParse);\n<line172>sqlite3VdbeAddOp3(v, OP_MakeRecord,regRow+(i2<0),nColumn-(i2<0),r1);\n<line173>if( i2<0 ){\n<line174>sqlite3VdbeAddOp3(v, OP_Insert, iParm, r1, regRow);\n<line175>}else{\n<line176>sqlite3VdbeAddOp4Int(v, OP_IdxInsert, iParm, r1, regRow, i2);\n<line177>}\n<line178>break;\n<line179>}\n<line180>default: {\n<line181>assert( eDest==SRT_Output || eDest==SRT_Coroutine );\n<line182>testcase( eDest==SRT_Output );\n<line183>testcase( eDest==SRT_Coroutine );\n<line184>if( eDest==SRT_Output ){\n<line185>sqlite3VdbeAddOp2(v, OP_ResultRow, pDest->iSdst, nColumn);\n<line186>}else{\n<line187>sqlite3VdbeAddOp1(v, OP_Yield, pDest->iSDParm);\n<line188>}\n<line189>break;\n<line190>}\n<line191>}\n<line192>if( regRowid ){\n<line193>if( eDest==SRT_Set ){\n<line194>sqlite3ReleaseTempRange(pParse, regRow, nColumn);\n<line195>}else{\n<line196>sqlite3ReleaseTempReg(pParse, regRow);\n<line197>}\n<line198>sqlite3ReleaseTempReg(pParse, regRowid);\n<line199>}\n<line200>/* The bottom of the loop\n<line201>*/\n<line202>sqlite3VdbeResolveLabel(v, addrContinue);\n<line203>if( pSort->sortFlags & SORTFLAG_UseSorter ){\n<line204>sqlite3VdbeAddOp2(v, OP_SorterNext, iTab, addr); VdbeCoverage(v);\n<line205>}else{\n<line206>sqlite3VdbeAddOp2(v, OP_Next, iTab, addr); VdbeCoverage(v);\n<line207>}\n<line208>sqlite3VdbeScanStatusRange(v, addrExplain, sqlite3VdbeCurrentAddr(v)-1, -1);\n<line209>if( pSort->regReturn ) sqlite3VdbeAddOp1(v, OP_Return, pSort->regReturn);\n<line210>sqlite3VdbeResolveLabel(v, addrBreak);\n<line211>}
----------------------------------------
Function: columnTypeImpl
Content: <line0>static const char *columnTypeImpl(\n<line1>NameContext *pNC,\n<line2>#ifndef SQLITE_ENABLE_COLUMN_METADATA\n<line3>Expr *pExpr\n<line4>#else\n<line5>Expr *pExpr,\n<line6>const char **pzOrigDb,\n<line7>const char **pzOrigTab,\n<line8>const char **pzOrigCol\n<line9>#endif\n<line10>){\n<line11>char const *zType = 0;\n<line12>int j;\n<line13>#ifdef SQLITE_ENABLE_COLUMN_METADATA\n<line14>char const *zOrigDb = 0;\n<line15>char const *zOrigTab = 0;\n<line16>char const *zOrigCol = 0;\n<line17>#endif\n<line18>assert( pExpr!=0 );\n<line19>assert( pNC->pSrcList!=0 );\n<line20>switch( pExpr->op ){\n<line21>case TK_COLUMN: {\n<line22>/* The expression is a column. Locate the table the column is being\n<line23>** extracted from in NameContext.pSrcList. This table may be real\n<line24>** database table or a subquery.\n<line25>*/\n<line26>Table *pTab = 0;            /* Table structure column is extracted from */\n<line27>Select *pS = 0;             /* Select the column is extracted from */\n<line28>int iCol = pExpr->iColumn;  /* Index of column in pTab */\n<line29>while( pNC && !pTab ){\n<line30>SrcList *pTabList = pNC->pSrcList;\n<line31>for(j=0;j<pTabList->nSrc && pTabList->a[j].iCursor!=pExpr->iTable;j++);\n<line32>if( j<pTabList->nSrc ){\n<line33>pTab = pTabList->a[j].pSTab;\n<line34>if( pTabList->a[j].fg.isSubquery ){\n<line35>pS = pTabList->a[j].u4.pSubq->pSelect;\n<line36>}else{\n<line37>pS = 0;\n<line38>}\n<line39>}else{\n<line40>pNC = pNC->pNext;\n<line41>}\n<line42>}\n<line43>if( pTab==0 ){\n<line44>/* At one time, code such as "SELECT new.x" within a trigger would\n<line45>** cause this condition to run.  Since then, we have restructured how\n<line46>** trigger code is generated and so this condition is no longer\n<line47>** possible. However, it can still be true for statements like\n<line48>** the following:\n<line49>**\n<line50>**   CREATE TABLE t1(col INTEGER);\n<line51>**   SELECT (SELECT t1.col) FROM FROM t1;\n<line52>**\n<line53>** when columnType() is called on the expression "t1.col" in the\n<line54>** sub-select. In this case, set the column type to NULL, even\n<line55>** though it should really be "INTEGER".\n<line56>**\n<line57>** This is not a problem, as the column type of "t1.col" is never\n<line58>** used. When columnType() is called on the expression\n<line59>** "(SELECT t1.col)", the correct type is returned (see the TK_SELECT\n<line60>** branch below.  */\n<line61>break;\n<line62>}\n<line63>assert( pTab && ExprUseYTab(pExpr) && pExpr->y.pTab==pTab );\n<line64>if( pS ){\n<line65>/* The "table" is actually a sub-select or a view in the FROM clause\n<line66>** of the SELECT statement. Return the declaration type and origin\n<line67>** data for the result-set column of the sub-select.\n<line68>*/\n<line69>if( iCol<pS->pEList->nExpr\n<line70>&& (!ViewCanHaveRowid || iCol>=0)\n<line71>){\n<line72>/* If iCol is less than zero, then the expression requests the\n<line73>** rowid of the sub-select or view. This expression is legal (see\n<line74>** test case misc2.2.2) - it always evaluates to NULL.\n<line75>*/\n<line76>NameContext sNC;\n<line77>Expr *p = pS->pEList->a[iCol].pExpr;\n<line78>sNC.pSrcList = pS->pSrc;\n<line79>sNC.pNext = pNC;\n<line80>sNC.pParse = pNC->pParse;\n<line81>zType = columnType(&sNC, p,&zOrigDb,&zOrigTab,&zOrigCol);\n<line82>}\n<line83>}else{\n<line84>/* A real table or a CTE table */\n<line85>assert( !pS );\n<line86>#ifdef SQLITE_ENABLE_COLUMN_METADATA\n<line87>if( iCol<0 ) iCol = pTab->iPKey;\n<line88>assert( iCol==XN_ROWID || (iCol>=0 && iCol<pTab->nCol) );\n<line89>if( iCol<0 ){\n<line90>zType = "INTEGER";\n<line91>zOrigCol = "rowid";\n<line92>}else{\n<line93>zOrigCol = pTab->aCol[iCol].zCnName;\n<line94>zType = sqlite3ColumnType(&pTab->aCol[iCol],0);\n<line95>}\n<line96>zOrigTab = pTab->zName;\n<line97>if( pNC->pParse && pTab->pSchema ){\n<line98>int iDb = sqlite3SchemaToIndex(pNC->pParse->db, pTab->pSchema);\n<line99>zOrigDb = pNC->pParse->db->aDb[iDb].zDbSName;\n<line100>}\n<line101>#else\n<line102>assert( iCol==XN_ROWID || (iCol>=0 && iCol<pTab->nCol) );\n<line103>if( iCol<0 ){\n<line104>zType = "INTEGER";\n<line105>}else{\n<line106>zType = sqlite3ColumnType(&pTab->aCol[iCol],0);\n<line107>}\n<line108>#endif\n<line109>}\n<line110>break;\n<line111>}\n<line112>#ifndef SQLITE_OMIT_SUBQUERY\n<line113>case TK_SELECT: {\n<line114>/* The expression is a sub-select. Return the declaration type and\n<line115>** origin info for the single column in the result set of the SELECT\n<line116>** statement.\n<line117>*/\n<line118>NameContext sNC;\n<line119>Select *pS;\n<line120>Expr *p;\n<line121>assert( ExprUseXSelect(pExpr) );\n<line122>pS = pExpr->x.pSelect;\n<line123>p = pS->pEList->a[0].pExpr;\n<line124>sNC.pSrcList = pS->pSrc;\n<line125>sNC.pNext = pNC;\n<line126>sNC.pParse = pNC->pParse;\n<line127>zType = columnType(&sNC, p, &zOrigDb, &zOrigTab, &zOrigCol);\n<line128>break;\n<line129>}\n<line130>#endif\n<line131>}\n<line132>#ifdef SQLITE_ENABLE_COLUMN_METADATA\n<line133>if( pzOrigDb ){\n<line134>assert( pzOrigTab && pzOrigCol );\n<line135>*pzOrigDb = zOrigDb;\n<line136>*pzOrigTab = zOrigTab;\n<line137>*pzOrigCol = zOrigCol;\n<line138>}\n<line139>#endif\n<line140>return zType;\n<line141>}
----------------------------------------
Function: generateColumnTypes
Content: <line0>static void generateColumnTypes(\n<line1>Parse *pParse,      /* Parser context */\n<line2>SrcList *pTabList,  /* List of tables */\n<line3>ExprList *pEList    /* Expressions defining the result set */\n<line4>){\n<line5>#ifndef SQLITE_OMIT_DECLTYPE\n<line6>Vdbe *v = pParse->pVdbe;\n<line7>int i;\n<line8>NameContext sNC;\n<line9>sNC.pSrcList = pTabList;\n<line10>sNC.pParse = pParse;\n<line11>sNC.pNext = 0;\n<line12>for(i=0; i<pEList->nExpr; i++){\n<line13>Expr *p = pEList->a[i].pExpr;\n<line14>const char *zType;\n<line15>#ifdef SQLITE_ENABLE_COLUMN_METADATA\n<line16>const char *zOrigDb = 0;\n<line17>const char *zOrigTab = 0;\n<line18>const char *zOrigCol = 0;\n<line19>zType = columnType(&sNC, p, &zOrigDb, &zOrigTab, &zOrigCol);\n<line20>/* The vdbe must make its own copy of the column-type and other\n<line21>** column specific strings, in case the schema is reset before this\n<line22>** virtual machine is deleted.\n<line23>*/\n<line24>sqlite3VdbeSetColName(v, i, COLNAME_DATABASE, zOrigDb, SQLITE_TRANSIENT);\n<line25>sqlite3VdbeSetColName(v, i, COLNAME_TABLE, zOrigTab, SQLITE_TRANSIENT);\n<line26>sqlite3VdbeSetColName(v, i, COLNAME_COLUMN, zOrigCol, SQLITE_TRANSIENT);\n<line27>#else\n<line28>zType = columnType(&sNC, p, 0, 0, 0);\n<line29>#endif\n<line30>sqlite3VdbeSetColName(v, i, COLNAME_DECLTYPE, zType, SQLITE_TRANSIENT);\n<line31>}\n<line32>#else\n<line33>UNUSED_PARAMETER(pParse);\n<line34>UNUSED_PARAMETER(pTabList);\n<line35>UNUSED_PARAMETER(pEList);\n<line36>#endif /* !defined(SQLITE_OMIT_DECLTYPE) */\n<line37>}
----------------------------------------
Function: computeLimitRegisters
Content: <line0>static void computeLimitRegisters(Parse *pParse, Select *p, int iBreak){\n<line1>Vdbe *v = 0;\n<line2>int iLimit = 0;\n<line3>int iOffset;\n<line4>int n;\n<line5>Expr *pLimit = p->pLimit;\n<line6>if( p->iLimit ) return;\n<line7>/*\n<line8>** "LIMIT -1" always shows all rows.  There is some\n<line9>** controversy about what the correct behavior should be.\n<line10>** The current implementation interprets "LIMIT 0" to mean\n<line11>** no rows.\n<line12>*/\n<line13>if( pLimit ){\n<line14>assert( pLimit->op==TK_LIMIT );\n<line15>assert( pLimit->pLeft!=0 );\n<line16>p->iLimit = iLimit = ++pParse->nMem;\n<line17>v = sqlite3GetVdbe(pParse);\n<line18>assert( v!=0 );\n<line19>if( sqlite3ExprIsInteger(pLimit->pLeft, &n, pParse) ){\n<line20>sqlite3VdbeAddOp2(v, OP_Integer, n, iLimit);\n<line21>VdbeComment((v, "LIMIT counter"));\n<line22>if( n==0 ){\n<line23>sqlite3VdbeGoto(v, iBreak);\n<line24>}else if( n>=0 && p->nSelectRow>sqlite3LogEst((u64)n) ){\n<line25>p->nSelectRow = sqlite3LogEst((u64)n);\n<line26>p->selFlags |= SF_FixedLimit;\n<line27>}\n<line28>}else{\n<line29>sqlite3ExprCode(pParse, pLimit->pLeft, iLimit);\n<line30>sqlite3VdbeAddOp1(v, OP_MustBeInt, iLimit); VdbeCoverage(v);\n<line31>VdbeComment((v, "LIMIT counter"));\n<line32>sqlite3VdbeAddOp2(v, OP_IfNot, iLimit, iBreak); VdbeCoverage(v);\n<line33>}\n<line34>if( pLimit->pRight ){\n<line35>p->iOffset = iOffset = ++pParse->nMem;\n<line36>pParse->nMem++;   /* Allocate an extra register for limit+offset */\n<line37>sqlite3ExprCode(pParse, pLimit->pRight, iOffset);\n<line38>sqlite3VdbeAddOp1(v, OP_MustBeInt, iOffset); VdbeCoverage(v);\n<line39>VdbeComment((v, "OFFSET counter"));\n<line40>sqlite3VdbeAddOp3(v, OP_OffsetLimit, iLimit, iOffset+1, iOffset);\n<line41>VdbeComment((v, "LIMIT+OFFSET"));\n<line42>}\n<line43>}\n<line44>}
----------------------------------------
Function: multiSelectCollSeq
Content: <line0>static CollSeq *multiSelectCollSeq(Parse *pParse, Select *p, int iCol){\n<line1>CollSeq *pRet;\n<line2>if( p->pPrior ){\n<line3>pRet = multiSelectCollSeq(pParse, p->pPrior, iCol);\n<line4>}else{\n<line5>pRet = 0;\n<line6>}\n<line7>assert( iCol>=0 );\n<line8>/* iCol must be less than p->pEList->nExpr.  Otherwise an error would\n<line9>** have been thrown during name resolution and we would not have gotten\n<line10>** this far */\n<line11>if( pRet==0 && ALWAYS(iCol<p->pEList->nExpr) ){\n<line12>pRet = sqlite3ExprCollSeq(pParse, p->pEList->a[iCol].pExpr);\n<line13>}\n<line14>return pRet;\n<line15>}
----------------------------------------
Function: multiSelectOrderByKeyInfo
Content: <line0>static KeyInfo *multiSelectOrderByKeyInfo(Parse *pParse, Select *p, int nExtra){\n<line1>ExprList *pOrderBy = p->pOrderBy;\n<line2>int nOrderBy = ALWAYS(pOrderBy!=0) ? pOrderBy->nExpr : 0;\n<line3>sqlite3 *db = pParse->db;\n<line4>KeyInfo *pRet = sqlite3KeyInfoAlloc(db, nOrderBy+nExtra, 1);\n<line5>if( pRet ){\n<line6>int i;\n<line7>for(i=0; i<nOrderBy; i++){\n<line8>struct ExprList_item *pItem = &pOrderBy->a[i];\n<line9>Expr *pTerm = pItem->pExpr;\n<line10>CollSeq *pColl;\n<line11>if( pTerm->flags & EP_Collate ){\n<line12>pColl = sqlite3ExprCollSeq(pParse, pTerm);\n<line13>}else{\n<line14>pColl = multiSelectCollSeq(pParse, p, pItem->u.x.iOrderByCol-1);\n<line15>if( pColl==0 ) pColl = db->pDfltColl;\n<line16>pOrderBy->a[i].pExpr =\n<line17>sqlite3ExprAddCollateString(pParse, pTerm, pColl->zName);\n<line18>}\n<line19>assert( sqlite3KeyInfoIsWriteable(pRet) );\n<line20>pRet->aColl[i] = pColl;\n<line21>pRet->aSortFlags[i] = pOrderBy->a[i].fg.sortFlags;\n<line22>}\n<line23>}\n<line24>return pRet;\n<line25>}
----------------------------------------
Function: generateWithRecursiveQuery
Content: <line0>static void generateWithRecursiveQuery(\n<line1>Parse *pParse,        /* Parsing context */\n<line2>Select *p,            /* The recursive SELECT to be coded */\n<line3>SelectDest *pDest     /* What to do with query results */\n<line4>){\n<line5>SrcList *pSrc = p->pSrc;      /* The FROM clause of the recursive query */\n<line6>int nCol = p->pEList->nExpr;  /* Number of columns in the recursive table */\n<line7>Vdbe *v = pParse->pVdbe;      /* The prepared statement under construction */\n<line8>Select *pSetup;               /* The setup query */\n<line9>Select *pFirstRec;            /* Left-most recursive term */\n<line10>int addrTop;                  /* Top of the loop */\n<line11>int addrCont, addrBreak;      /* CONTINUE and BREAK addresses */\n<line12>int iCurrent = 0;             /* The Current table */\n<line13>int regCurrent;               /* Register holding Current table */\n<line14>int iQueue;                   /* The Queue table */\n<line15>int iDistinct = 0;            /* To ensure unique results if UNION */\n<line16>int eDest = SRT_Fifo;         /* How to write to Queue */\n<line17>SelectDest destQueue;         /* SelectDest targeting the Queue table */\n<line18>int i;                        /* Loop counter */\n<line19>int rc;                       /* Result code */\n<line20>ExprList *pOrderBy;           /* The ORDER BY clause */\n<line21>Expr *pLimit;                 /* Saved LIMIT and OFFSET */\n<line22>int regLimit, regOffset;      /* Registers used by LIMIT and OFFSET */\n<line23>#ifndef SQLITE_OMIT_WINDOWFUNC\n<line24>if( p->pWin ){\n<line25>sqlite3ErrorMsg(pParse, "cannot use window functions in recursive queries");\n<line26>return;\n<line27>}\n<line28>#endif\n<line29>/* Obtain authorization to do a recursive query */\n<line30>if( sqlite3AuthCheck(pParse, SQLITE_RECURSIVE, 0, 0, 0) ) return;\n<line31>/* Process the LIMIT and OFFSET clauses, if they exist */\n<line32>addrBreak = sqlite3VdbeMakeLabel(pParse);\n<line33>p->nSelectRow = 320;  /* 4 billion rows */\n<line34>computeLimitRegisters(pParse, p, addrBreak);\n<line35>pLimit = p->pLimit;\n<line36>regLimit = p->iLimit;\n<line37>regOffset = p->iOffset;\n<line38>p->pLimit = 0;\n<line39>p->iLimit = p->iOffset = 0;\n<line40>pOrderBy = p->pOrderBy;\n<line41>/* Locate the cursor number of the Current table */\n<line42>for(i=0; ALWAYS(i<pSrc->nSrc); i++){\n<line43>if( pSrc->a[i].fg.isRecursive ){\n<line44>iCurrent = pSrc->a[i].iCursor;\n<line45>break;\n<line46>}\n<line47>}\n<line48>/* Allocate cursors numbers for Queue and Distinct.  The cursor number for\n<line49>** the Distinct table must be exactly one greater than Queue in order\n<line50>** for the SRT_DistFifo and SRT_DistQueue destinations to work. */\n<line51>iQueue = pParse->nTab++;\n<line52>if( p->op==TK_UNION ){\n<line53>eDest = pOrderBy ? SRT_DistQueue : SRT_DistFifo;\n<line54>iDistinct = pParse->nTab++;\n<line55>}else{\n<line56>eDest = pOrderBy ? SRT_Queue : SRT_Fifo;\n<line57>}\n<line58>sqlite3SelectDestInit(&destQueue, eDest, iQueue);\n<line59>/* Allocate cursors for Current, Queue, and Distinct. */\n<line60>regCurrent = ++pParse->nMem;\n<line61>sqlite3VdbeAddOp3(v, OP_OpenPseudo, iCurrent, regCurrent, nCol);\n<line62>if( pOrderBy ){\n<line63>KeyInfo *pKeyInfo = multiSelectOrderByKeyInfo(pParse, p, 1);\n<line64>sqlite3VdbeAddOp4(v, OP_OpenEphemeral, iQueue, pOrderBy->nExpr+2, 0,\n<line65>(char*)pKeyInfo, P4_KEYINFO);\n<line66>destQueue.pOrderBy = pOrderBy;\n<line67>}else{\n<line68>sqlite3VdbeAddOp2(v, OP_OpenEphemeral, iQueue, nCol);\n<line69>}\n<line70>VdbeComment((v, "Queue table"));\n<line71>if( iDistinct ){\n<line72>p->addrOpenEphm[0] = sqlite3VdbeAddOp2(v, OP_OpenEphemeral, iDistinct, 0);\n<line73>p->selFlags |= SF_UsesEphemeral;\n<line74>}\n<line75>/* Detach the ORDER BY clause from the compound SELECT */\n<line76>p->pOrderBy = 0;\n<line77>/* Figure out how many elements of the compound SELECT are part of the\n<line78>** recursive query.  Make sure no recursive elements use aggregate\n<line79>** functions.  Mark the recursive elements as UNION ALL even if they\n<line80>** are really UNION because the distinctness will be enforced by the\n<line81>** iDistinct table.  pFirstRec is left pointing to the left-most\n<line82>** recursive term of the CTE.\n<line83>*/\n<line84>for(pFirstRec=p; ALWAYS(pFirstRec!=0); pFirstRec=pFirstRec->pPrior){\n<line85>if( pFirstRec->selFlags & SF_Aggregate ){\n<line86>sqlite3ErrorMsg(pParse, "recursive aggregate queries not supported");\n<line87>goto end_of_recursive_query;\n<line88>}\n<line89>pFirstRec->op = TK_ALL;\n<line90>if( (pFirstRec->pPrior->selFlags & SF_Recursive)==0 ) break;\n<line91>}\n<line92>/* Store the results of the setup-query in Queue. */\n<line93>pSetup = pFirstRec->pPrior;\n<line94>pSetup->pNext = 0;\n<line95>ExplainQueryPlan((pParse, 1, "SETUP"));\n<line96>rc = sqlite3Select(pParse, pSetup, &destQueue);\n<line97>pSetup->pNext = p;\n<line98>if( rc ) goto end_of_recursive_query;\n<line99>/* Find the next row in the Queue and output that row */\n<line100>addrTop = sqlite3VdbeAddOp2(v, OP_Rewind, iQueue, addrBreak); VdbeCoverage(v);\n<line101>/* Transfer the next row in Queue over to Current */\n<line102>sqlite3VdbeAddOp1(v, OP_NullRow, iCurrent); /* To reset column cache */\n<line103>if( pOrderBy ){\n<line104>sqlite3VdbeAddOp3(v, OP_Column, iQueue, pOrderBy->nExpr+1, regCurrent);\n<line105>}else{\n<line106>sqlite3VdbeAddOp2(v, OP_RowData, iQueue, regCurrent);\n<line107>}\n<line108>sqlite3VdbeAddOp1(v, OP_Delete, iQueue);\n<line109>/* Output the single row in Current */\n<line110>addrCont = sqlite3VdbeMakeLabel(pParse);\n<line111>codeOffset(v, regOffset, addrCont);\n<line112>selectInnerLoop(pParse, p, iCurrent,\n<line113>0, 0, pDest, addrCont, addrBreak);\n<line114>if( regLimit ){\n<line115>sqlite3VdbeAddOp2(v, OP_DecrJumpZero, regLimit, addrBreak);\n<line116>VdbeCoverage(v);\n<line117>}\n<line118>sqlite3VdbeResolveLabel(v, addrCont);\n<line119>/* Execute the recursive SELECT taking the single row in Current as\n<line120>** the value for the recursive-table. Store the results in the Queue.\n<line121>*/\n<line122>pFirstRec->pPrior = 0;\n<line123>ExplainQueryPlan((pParse, 1, "RECURSIVE STEP"));\n<line124>sqlite3Select(pParse, p, &destQueue);\n<line125>assert( pFirstRec->pPrior==0 );\n<line126>pFirstRec->pPrior = pSetup;\n<line127>/* Keep running the loop until the Queue is empty */\n<line128>sqlite3VdbeGoto(v, addrTop);\n<line129>sqlite3VdbeResolveLabel(v, addrBreak);\n<line130>end_of_recursive_query:\n<line131>sqlite3ExprListDelete(pParse->db, p->pOrderBy);\n<line132>p->pOrderBy = pOrderBy;\n<line133>p->pLimit = pLimit;\n<line134>return;\n<line135>}
----------------------------------------
Function: multiSelectValues
Content: <line0>static int multiSelectValues(\n<line1>Parse *pParse,        /* Parsing context */\n<line2>Select *p,            /* The right-most of SELECTs to be coded */\n<line3>SelectDest *pDest     /* What to do with query results */\n<line4>){\n<line5>int nRow = 1;\n<line6>int rc = 0;\n<line7>int bShowAll = p->pLimit==0;\n<line8>assert( p->selFlags & SF_MultiValue );\n<line9>do{\n<line10>assert( p->selFlags & SF_Values );\n<line11>assert( p->op==TK_ALL || (p->op==TK_SELECT && p->pPrior==0) );\n<line12>assert( p->pNext==0 || p->pEList->nExpr==p->pNext->pEList->nExpr );\n<line13>#ifndef SQLITE_OMIT_WINDOWFUNC\n<line14>if( p->pWin ) return -1;\n<line15>#endif\n<line16>if( p->pPrior==0 ) break;\n<line17>assert( p->pPrior->pNext==p );\n<line18>p = p->pPrior;\n<line19>nRow += bShowAll;\n<line20>}while(1);\n<line21>ExplainQueryPlan((pParse, 0, "SCAN %d CONSTANT ROW%s", nRow,\n<line22>nRow==1 ? "" : "S"));\n<line23>while( p ){\n<line24>selectInnerLoop(pParse, p, -1, 0, 0, pDest, 1, 1);\n<line25>if( !bShowAll ) break;\n<line26>p->nSelectRow = nRow;\n<line27>p = p->pNext;\n<line28>}\n<line29>return rc;\n<line30>}
----------------------------------------
Function: hasAnchor
Content: <line0>static int hasAnchor(Select *p){\n<line1>while( p && (p->selFlags & SF_Recursive)!=0 ){ p = p->pPrior; }\n<line2>return p!=0;\n<line3>}
----------------------------------------
Function: multiSelect
Content: <line0>static int multiSelect(\n<line1>Parse *pParse,        /* Parsing context */\n<line2>Select *p,            /* The right-most of SELECTs to be coded */\n<line3>SelectDest *pDest     /* What to do with query results */\n<line4>){\n<line5>int rc = SQLITE_OK;   /* Success code from a subroutine */\n<line6>Select *pPrior;       /* Another SELECT immediately to our left */\n<line7>Vdbe *v;              /* Generate code to this VDBE */\n<line8>SelectDest dest;      /* Alternative data destination */\n<line9>Select *pDelete = 0;  /* Chain of simple selects to delete */\n<line10>sqlite3 *db;          /* Database connection */\n<line11>/* Make sure there is no ORDER BY or LIMIT clause on prior SELECTs.  Only\n<line12>** the last (right-most) SELECT in the series may have an ORDER BY or LIMIT.\n<line13>*/\n<line14>assert( p && p->pPrior );  /* Calling function guarantees this much */\n<line15>assert( (p->selFlags & SF_Recursive)==0 || p->op==TK_ALL || p->op==TK_UNION );\n<line16>assert( p->selFlags & SF_Compound );\n<line17>db = pParse->db;\n<line18>pPrior = p->pPrior;\n<line19>dest = *pDest;\n<line20>assert( pPrior->pOrderBy==0 );\n<line21>assert( pPrior->pLimit==0 );\n<line22>v = sqlite3GetVdbe(pParse);\n<line23>assert( v!=0 );  /* The VDBE already created by calling function */\n<line24>/* Create the destination temporary table if necessary\n<line25>*/\n<line26>if( dest.eDest==SRT_EphemTab ){\n<line27>assert( p->pEList );\n<line28>sqlite3VdbeAddOp2(v, OP_OpenEphemeral, dest.iSDParm, p->pEList->nExpr);\n<line29>dest.eDest = SRT_Table;\n<line30>}\n<line31>/* Special handling for a compound-select that originates as a VALUES clause.\n<line32>*/\n<line33>if( p->selFlags & SF_MultiValue ){\n<line34>rc = multiSelectValues(pParse, p, &dest);\n<line35>if( rc>=0 ) goto multi_select_end;\n<line36>rc = SQLITE_OK;\n<line37>}\n<line38>/* Make sure all SELECTs in the statement have the same number of elements\n<line39>** in their result sets.\n<line40>*/\n<line41>assert( p->pEList && pPrior->pEList );\n<line42>assert( p->pEList->nExpr==pPrior->pEList->nExpr );\n<line43>#ifndef SQLITE_OMIT_CTE\n<line44>if( (p->selFlags & SF_Recursive)!=0 && hasAnchor(p) ){\n<line45>generateWithRecursiveQuery(pParse, p, &dest);\n<line46>}else\n<line47>#endif\n<line48>/* Compound SELECTs that have an ORDER BY clause are handled separately.\n<line49>*/\n<line50>if( p->pOrderBy ){\n<line51>return multiSelectOrderBy(pParse, p, pDest);\n<line52>}else{\n<line53>#ifndef SQLITE_OMIT_EXPLAIN\n<line54>if( pPrior->pPrior==0 ){\n<line55>ExplainQueryPlan((pParse, 1, "COMPOUND QUERY"));\n<line56>ExplainQueryPlan((pParse, 1, "LEFT-MOST SUBQUERY"));\n<line57>}\n<line58>#endif\n<line59>/* Generate code for the left and right SELECT statements.\n<line60>*/\n<line61>switch( p->op ){\n<line62>case TK_ALL: {\n<line63>int addr = 0;\n<line64>int nLimit = 0;  /* Initialize to suppress harmless compiler warning */\n<line65>assert( !pPrior->pLimit );\n<line66>pPrior->iLimit = p->iLimit;\n<line67>pPrior->iOffset = p->iOffset;\n<line68>pPrior->pLimit = p->pLimit;\n<line69>TREETRACE(0x200, pParse, p, ("multiSelect UNION ALL left...\n"));\n<line70>rc = sqlite3Select(pParse, pPrior, &dest);\n<line71>pPrior->pLimit = 0;\n<line72>if( rc ){\n<line73>goto multi_select_end;\n<line74>}\n<line75>p->pPrior = 0;\n<line76>p->iLimit = pPrior->iLimit;\n<line77>p->iOffset = pPrior->iOffset;\n<line78>if( p->iLimit ){\n<line79>addr = sqlite3VdbeAddOp1(v, OP_IfNot, p->iLimit); VdbeCoverage(v);\n<line80>VdbeComment((v, "Jump ahead if LIMIT reached"));\n<line81>if( p->iOffset ){\n<line82>sqlite3VdbeAddOp3(v, OP_OffsetLimit,\n<line83>p->iLimit, p->iOffset+1, p->iOffset);\n<line84>}\n<line85>}\n<line86>ExplainQueryPlan((pParse, 1, "UNION ALL"));\n<line87>TREETRACE(0x200, pParse, p, ("multiSelect UNION ALL right...\n"));\n<line88>rc = sqlite3Select(pParse, p, &dest);\n<line89>testcase( rc!=SQLITE_OK );\n<line90>pDelete = p->pPrior;\n<line91>p->pPrior = pPrior;\n<line92>p->nSelectRow = sqlite3LogEstAdd(p->nSelectRow, pPrior->nSelectRow);\n<line93>if( p->pLimit\n<line94>&& sqlite3ExprIsInteger(p->pLimit->pLeft, &nLimit, pParse)\n<line95>&& nLimit>0 && p->nSelectRow > sqlite3LogEst((u64)nLimit)\n<line96>){\n<line97>p->nSelectRow = sqlite3LogEst((u64)nLimit);\n<line98>}\n<line99>if( addr ){\n<line100>sqlite3VdbeJumpHere(v, addr);\n<line101>}\n<line102>break;\n<line103>}\n<line104>case TK_EXCEPT:\n<line105>case TK_UNION: {\n<line106>int unionTab;    /* Cursor number of the temp table holding result */\n<line107>u8 op = 0;       /* One of the SRT_ operations to apply to self */\n<line108>int priorOp;     /* The SRT_ operation to apply to prior selects */\n<line109>Expr *pLimit;    /* Saved values of p->nLimit  */\n<line110>int addr;\n<line111>int emptyBypass = 0;   /* IfEmpty opcode to bypass RHS */\n<line112>SelectDest uniondest;\n<line113>testcase( p->op==TK_EXCEPT );\n<line114>testcase( p->op==TK_UNION );\n<line115>priorOp = SRT_Union;\n<line116>if( dest.eDest==priorOp ){\n<line117>/* We can reuse a temporary table generated by a SELECT to our\n<line118>** right.\n<line119>*/\n<line120>assert( p->pLimit==0 );      /* Not allowed on leftward elements */\n<line121>unionTab = dest.iSDParm;\n<line122>}else{\n<line123>/* We will need to create our own temporary table to hold the\n<line124>** intermediate results.\n<line125>*/\n<line126>unionTab = pParse->nTab++;\n<line127>assert( p->pOrderBy==0 );\n<line128>addr = sqlite3VdbeAddOp2(v, OP_OpenEphemeral, unionTab, 0);\n<line129>assert( p->addrOpenEphm[0] == -1 );\n<line130>p->addrOpenEphm[0] = addr;\n<line131>findRightmost(p)->selFlags |= SF_UsesEphemeral;\n<line132>assert( p->pEList );\n<line133>}\n<line134>/* Code the SELECT statements to our left\n<line135>*/\n<line136>assert( !pPrior->pOrderBy );\n<line137>sqlite3SelectDestInit(&uniondest, priorOp, unionTab);\n<line138>TREETRACE(0x200, pParse, p, ("multiSelect EXCEPT/UNION left...\n"));\n<line139>rc = sqlite3Select(pParse, pPrior, &uniondest);\n<line140>if( rc ){\n<line141>goto multi_select_end;\n<line142>}\n<line143>/* Code the current SELECT statement\n<line144>*/\n<line145>if( p->op==TK_EXCEPT ){\n<line146>op = SRT_Except;\n<line147>emptyBypass = sqlite3VdbeAddOp1(v, OP_IfEmpty, unionTab);\n<line148>VdbeCoverage(v);\n<line149>}else{\n<line150>assert( p->op==TK_UNION );\n<line151>op = SRT_Union;\n<line152>}\n<line153>p->pPrior = 0;\n<line154>pLimit = p->pLimit;\n<line155>p->pLimit = 0;\n<line156>uniondest.eDest = op;\n<line157>ExplainQueryPlan((pParse, 1, "%s USING TEMP B-TREE",\n<line158>sqlite3SelectOpName(p->op)));\n<line159>TREETRACE(0x200, pParse, p, ("multiSelect EXCEPT/UNION right...\n"));\n<line160>rc = sqlite3Select(pParse, p, &uniondest);\n<line161>testcase( rc!=SQLITE_OK );\n<line162>assert( p->pOrderBy==0 );\n<line163>pDelete = p->pPrior;\n<line164>p->pPrior = pPrior;\n<line165>p->pOrderBy = 0;\n<line166>if( p->op==TK_UNION ){\n<line167>p->nSelectRow = sqlite3LogEstAdd(p->nSelectRow, pPrior->nSelectRow);\n<line168>}\n<line169>if( emptyBypass ) sqlite3VdbeJumpHere(v, emptyBypass);\n<line170>sqlite3ExprDelete(db, p->pLimit);\n<line171>p->pLimit = pLimit;\n<line172>p->iLimit = 0;\n<line173>p->iOffset = 0;\n<line174>/* Convert the data in the temporary table into whatever form\n<line175>** it is that we currently need.\n<line176>*/\n<line177>assert( unionTab==dest.iSDParm || dest.eDest!=priorOp );\n<line178>assert( p->pEList || db->mallocFailed );\n<line179>if( dest.eDest!=priorOp && db->mallocFailed==0 ){\n<line180>int iCont, iBreak, iStart;\n<line181>iBreak = sqlite3VdbeMakeLabel(pParse);\n<line182>iCont = sqlite3VdbeMakeLabel(pParse);\n<line183>computeLimitRegisters(pParse, p, iBreak);\n<line184>sqlite3VdbeAddOp2(v, OP_Rewind, unionTab, iBreak); VdbeCoverage(v);\n<line185>iStart = sqlite3VdbeCurrentAddr(v);\n<line186>selectInnerLoop(pParse, p, unionTab,\n<line187>0, 0, &dest, iCont, iBreak);\n<line188>sqlite3VdbeResolveLabel(v, iCont);\n<line189>sqlite3VdbeAddOp2(v, OP_Next, unionTab, iStart); VdbeCoverage(v);\n<line190>sqlite3VdbeResolveLabel(v, iBreak);\n<line191>sqlite3VdbeAddOp2(v, OP_Close, unionTab, 0);\n<line192>}\n<line193>break;\n<line194>}\n<line195>default: assert( p->op==TK_INTERSECT ); {\n<line196>int tab1, tab2;\n<line197>int iCont, iBreak, iStart;\n<line198>Expr *pLimit;\n<line199>int addr, iLimit, iOffset;\n<line200>SelectDest intersectdest;\n<line201>int r1;\n<line202>int emptyBypass;\n<line203>/* INTERSECT is different from the others since it requires\n<line204>** two temporary tables.  Hence it has its own case.  Begin\n<line205>** by allocating the tables we will need.\n<line206>*/\n<line207>tab1 = pParse->nTab++;\n<line208>tab2 = pParse->nTab++;\n<line209>assert( p->pOrderBy==0 );\n<line210>addr = sqlite3VdbeAddOp2(v, OP_OpenEphemeral, tab1, 0);\n<line211>assert( p->addrOpenEphm[0] == -1 );\n<line212>p->addrOpenEphm[0] = addr;\n<line213>findRightmost(p)->selFlags |= SF_UsesEphemeral;\n<line214>assert( p->pEList );\n<line215>/* Code the SELECTs to our left into temporary table "tab1".\n<line216>*/\n<line217>sqlite3SelectDestInit(&intersectdest, SRT_Union, tab1);\n<line218>TREETRACE(0x400, pParse, p, ("multiSelect INTERSECT left...\n"));\n<line219>rc = sqlite3Select(pParse, pPrior, &intersectdest);\n<line220>if( rc ){\n<line221>goto multi_select_end;\n<line222>}\n<line223>/* Initialize LIMIT counters before checking to see if the LHS\n<line224>** is empty, in case the jump is taken */\n<line225>iBreak = sqlite3VdbeMakeLabel(pParse);\n<line226>computeLimitRegisters(pParse, p, iBreak);\n<line227>emptyBypass = sqlite3VdbeAddOp1(v, OP_IfEmpty, tab1); VdbeCoverage(v);\n<line228>/* Code the current SELECT into temporary table "tab2"\n<line229>*/\n<line230>addr = sqlite3VdbeAddOp2(v, OP_OpenEphemeral, tab2, 0);\n<line231>assert( p->addrOpenEphm[1] == -1 );\n<line232>p->addrOpenEphm[1] = addr;\n<line233>/* Disable prior SELECTs and the LIMIT counters during the computation\n<line234>** of the RHS select */\n<line235>pLimit = p->pLimit;\n<line236>iLimit = p->iLimit;\n<line237>iOffset = p->iOffset;\n<line238>p->pPrior = 0;\n<line239>p->pLimit = 0;\n<line240>p->iLimit = 0;\n<line241>p->iOffset = 0;\n<line242>intersectdest.iSDParm = tab2;\n<line243>ExplainQueryPlan((pParse, 1, "%s USING TEMP B-TREE",\n<line244>sqlite3SelectOpName(p->op)));\n<line245>TREETRACE(0x400, pParse, p, ("multiSelect INTERSECT right...\n"));\n<line246>rc = sqlite3Select(pParse, p, &intersectdest);\n<line247>testcase( rc!=SQLITE_OK );\n<line248>pDelete = p->pPrior;\n<line249>p->pPrior = pPrior;\n<line250>if( p->nSelectRow>pPrior->nSelectRow ){\n<line251>p->nSelectRow = pPrior->nSelectRow;\n<line252>}\n<line253>sqlite3ExprDelete(db, p->pLimit);\n<line254>/* Reinstate the LIMIT counters prior to running the final intersect */\n<line255>p->pLimit = pLimit;\n<line256>p->iLimit = iLimit;\n<line257>p->iOffset = iOffset;\n<line258>/* Generate code to take the intersection of the two temporary\n<line259>** tables.\n<line260>*/\n<line261>if( rc ) break;\n<line262>assert( p->pEList );\n<line263>sqlite3VdbeAddOp1(v, OP_Rewind, tab1);\n<line264>r1 = sqlite3GetTempReg(pParse);\n<line265>iStart = sqlite3VdbeAddOp2(v, OP_RowData, tab1, r1);\n<line266>iCont = sqlite3VdbeMakeLabel(pParse);\n<line267>sqlite3VdbeAddOp4Int(v, OP_NotFound, tab2, iCont, r1, 0);\n<line268>VdbeCoverage(v);\n<line269>sqlite3ReleaseTempReg(pParse, r1);\n<line270>selectInnerLoop(pParse, p, tab1,\n<line271>0, 0, &dest, iCont, iBreak);\n<line272>sqlite3VdbeResolveLabel(v, iCont);\n<line273>sqlite3VdbeAddOp2(v, OP_Next, tab1, iStart); VdbeCoverage(v);\n<line274>sqlite3VdbeResolveLabel(v, iBreak);\n<line275>sqlite3VdbeAddOp2(v, OP_Close, tab2, 0);\n<line276>sqlite3VdbeJumpHere(v, emptyBypass);\n<line277>sqlite3VdbeAddOp2(v, OP_Close, tab1, 0);\n<line278>break;\n<line279>}\n<line280>}\n<line281>#ifndef SQLITE_OMIT_EXPLAIN\n<line282>if( p->pNext==0 ){\n<line283>ExplainQueryPlanPop(pParse);\n<line284>}\n<line285>#endif\n<line286>}\n<line287>if( pParse->nErr ) goto multi_select_end;\n<line288>/* Compute collating sequences used by\n<line289>** temporary tables needed to implement the compound select.\n<line290>** Attach the KeyInfo structure to all temporary tables.\n<line291>**\n<line292>** This section is run by the right-most SELECT statement only.\n<line293>** SELECT statements to the left always skip this part.  The right-most\n<line294>** SELECT might also skip this part if it has no ORDER BY clause and\n<line295>** no temp tables are required.\n<line296>*/\n<line297>if( p->selFlags & SF_UsesEphemeral ){\n<line298>int i;                        /* Loop counter */\n<line299>KeyInfo *pKeyInfo;            /* Collating sequence for the result set */\n<line300>Select *pLoop;                /* For looping through SELECT statements */\n<line301>CollSeq **apColl;             /* For looping through pKeyInfo->aColl[] */\n<line302>int nCol;                     /* Number of columns in result set */\n<line303>assert( p->pNext==0 );\n<line304>assert( p->pEList!=0 );\n<line305>nCol = p->pEList->nExpr;\n<line306>pKeyInfo = sqlite3KeyInfoAlloc(db, nCol, 1);\n<line307>if( !pKeyInfo ){\n<line308>rc = SQLITE_NOMEM_BKPT;\n<line309>goto multi_select_end;\n<line310>}\n<line311>for(i=0, apColl=pKeyInfo->aColl; i<nCol; i++, apColl++){\n<line312>*apColl = multiSelectCollSeq(pParse, p, i);\n<line313>if( 0==*apColl ){\n<line314>*apColl = db->pDfltColl;\n<line315>}\n<line316>}\n<line317>for(pLoop=p; pLoop; pLoop=pLoop->pPrior){\n<line318>for(i=0; i<2; i++){\n<line319>int addr = pLoop->addrOpenEphm[i];\n<line320>if( addr<0 ){\n<line321>/* If [0] is unused then [1] is also unused.  So we can\n<line322>** always safely abort as soon as the first unused slot is found */\n<line323>assert( pLoop->addrOpenEphm[1]<0 );\n<line324>break;\n<line325>}\n<line326>sqlite3VdbeChangeP2(v, addr, nCol);\n<line327>sqlite3VdbeChangeP4(v, addr, (char*)sqlite3KeyInfoRef(pKeyInfo),\n<line328>P4_KEYINFO);\n<line329>pLoop->addrOpenEphm[i] = -1;\n<line330>}\n<line331>}\n<line332>sqlite3KeyInfoUnref(pKeyInfo);\n<line333>}\n<line334>multi_select_end:\n<line335>pDest->iSdst = dest.iSdst;\n<line336>pDest->nSdst = dest.nSdst;\n<line337>pDest->iSDParm2 = dest.iSDParm2;\n<line338>if( pDelete ){\n<line339>sqlite3ParserAddCleanup(pParse, sqlite3SelectDeleteGeneric, pDelete);\n<line340>}\n<line341>return rc;\n<line342>}
----------------------------------------
Function: generateOutputSubroutine
Content: <line0>static int generateOutputSubroutine(\n<line1>Parse *pParse,          /* Parsing context */\n<line2>Select *p,              /* The SELECT statement */\n<line3>SelectDest *pIn,        /* Coroutine supplying data */\n<line4>SelectDest *pDest,      /* Where to send the data */\n<line5>int regReturn,          /* The return address register */\n<line6>int regPrev,            /* Previous result register.  No uniqueness if 0 */\n<line7>KeyInfo *pKeyInfo,      /* For comparing with previous entry */\n<line8>int iBreak              /* Jump here if we hit the LIMIT */\n<line9>){\n<line10>Vdbe *v = pParse->pVdbe;\n<line11>int iContinue;\n<line12>int addr;\n<line13>addr = sqlite3VdbeCurrentAddr(v);\n<line14>iContinue = sqlite3VdbeMakeLabel(pParse);\n<line15>/* Suppress duplicates for UNION, EXCEPT, and INTERSECT\n<line16>*/\n<line17>if( regPrev ){\n<line18>int addr1, addr2;\n<line19>addr1 = sqlite3VdbeAddOp1(v, OP_IfNot, regPrev); VdbeCoverage(v);\n<line20>addr2 = sqlite3VdbeAddOp4(v, OP_Compare, pIn->iSdst, regPrev+1, pIn->nSdst,\n<line21>(char*)sqlite3KeyInfoRef(pKeyInfo), P4_KEYINFO);\n<line22>sqlite3VdbeAddOp3(v, OP_Jump, addr2+2, iContinue, addr2+2); VdbeCoverage(v);\n<line23>sqlite3VdbeJumpHere(v, addr1);\n<line24>sqlite3VdbeAddOp3(v, OP_Copy, pIn->iSdst, regPrev+1, pIn->nSdst-1);\n<line25>sqlite3VdbeAddOp2(v, OP_Integer, 1, regPrev);\n<line26>}\n<line27>if( pParse->db->mallocFailed ) return 0;\n<line28>/* Suppress the first OFFSET entries if there is an OFFSET clause\n<line29>*/\n<line30>codeOffset(v, p->iOffset, iContinue);\n<line31>assert( pDest->eDest!=SRT_Exists );\n<line32>assert( pDest->eDest!=SRT_Table );\n<line33>switch( pDest->eDest ){\n<line34>/* Store the result as data using a unique key.\n<line35>*/\n<line36>case SRT_EphemTab: {\n<line37>int r1 = sqlite3GetTempReg(pParse);\n<line38>int r2 = sqlite3GetTempReg(pParse);\n<line39>sqlite3VdbeAddOp3(v, OP_MakeRecord, pIn->iSdst, pIn->nSdst, r1);\n<line40>sqlite3VdbeAddOp2(v, OP_NewRowid, pDest->iSDParm, r2);\n<line41>sqlite3VdbeAddOp3(v, OP_Insert, pDest->iSDParm, r1, r2);\n<line42>sqlite3VdbeChangeP5(v, OPFLAG_APPEND);\n<line43>sqlite3ReleaseTempReg(pParse, r2);\n<line44>sqlite3ReleaseTempReg(pParse, r1);\n<line45>break;\n<line46>}\n<line47>#ifndef SQLITE_OMIT_SUBQUERY\n<line48>/* If we are creating a set for an "expr IN (SELECT ...)".\n<line49>*/\n<line50>case SRT_Set: {\n<line51>int r1;\n<line52>testcase( pIn->nSdst>1 );\n<line53>r1 = sqlite3GetTempReg(pParse);\n<line54>sqlite3VdbeAddOp4(v, OP_MakeRecord, pIn->iSdst, pIn->nSdst,\n<line55>r1, pDest->zAffSdst, pIn->nSdst);\n<line56>sqlite3VdbeAddOp4Int(v, OP_IdxInsert, pDest->iSDParm, r1,\n<line57>pIn->iSdst, pIn->nSdst);\n<line58>if( pDest->iSDParm2>0 ){\n<line59>sqlite3VdbeAddOp4Int(v, OP_FilterAdd, pDest->iSDParm2, 0,\n<line60>pIn->iSdst, pIn->nSdst);\n<line61>ExplainQueryPlan((pParse, 0, "CREATE BLOOM FILTER"));\n<line62>}\n<line63>sqlite3ReleaseTempReg(pParse, r1);\n<line64>break;\n<line65>}\n<line66>/* If this is a scalar select that is part of an expression, then\n<line67>** store the results in the appropriate memory cell and break out\n<line68>** of the scan loop.  Note that the select might return multiple columns\n<line69>** if it is the RHS of a row-value IN operator.\n<line70>*/\n<line71>case SRT_Mem: {\n<line72>testcase( pIn->nSdst>1 );\n<line73>sqlite3ExprCodeMove(pParse, pIn->iSdst, pDest->iSDParm, pIn->nSdst);\n<line74>/* The LIMIT clause will jump out of the loop for us */\n<line75>break;\n<line76>}\n<line77>#endif /* #ifndef SQLITE_OMIT_SUBQUERY */\n<line78>/* The results are stored in a sequence of registers\n<line79>** starting at pDest->iSdst.  Then the co-routine yields.\n<line80>*/\n<line81>case SRT_Coroutine: {\n<line82>if( pDest->iSdst==0 ){\n<line83>pDest->iSdst = sqlite3GetTempRange(pParse, pIn->nSdst);\n<line84>pDest->nSdst = pIn->nSdst;\n<line85>}\n<line86>sqlite3ExprCodeMove(pParse, pIn->iSdst, pDest->iSdst, pIn->nSdst);\n<line87>sqlite3VdbeAddOp1(v, OP_Yield, pDest->iSDParm);\n<line88>break;\n<line89>}\n<line90>/* If none of the above, then the result destination must be\n<line91>** SRT_Output.  This routine is never called with any other\n<line92>** destination other than the ones handled above or SRT_Output.\n<line93>**\n<line94>** For SRT_Output, results are stored in a sequence of registers.\n<line95>** Then the OP_ResultRow opcode is used to cause sqlite3_step() to\n<line96>** return the next row of result.\n<line97>*/\n<line98>default: {\n<line99>assert( pDest->eDest==SRT_Output );\n<line100>sqlite3VdbeAddOp2(v, OP_ResultRow, pIn->iSdst, pIn->nSdst);\n<line101>break;\n<line102>}\n<line103>}\n<line104>/* Jump to the end of the loop if the LIMIT is reached.\n<line105>*/\n<line106>if( p->iLimit ){\n<line107>sqlite3VdbeAddOp2(v, OP_DecrJumpZero, p->iLimit, iBreak); VdbeCoverage(v);\n<line108>}\n<line109>/* Generate the subroutine return\n<line110>*/\n<line111>sqlite3VdbeResolveLabel(v, iContinue);\n<line112>sqlite3VdbeAddOp1(v, OP_Return, regReturn);\n<line113>return addr;\n<line114>}
----------------------------------------
Function: multiSelectOrderBy
Content: <line0>static int multiSelectOrderBy(\n<line1>Parse *pParse,        /* Parsing context */\n<line2>Select *p,            /* The right-most of SELECTs to be coded */\n<line3>SelectDest *pDest     /* What to do with query results */\n<line4>){\n<line5>int i, j;             /* Loop counters */\n<line6>Select *pPrior;       /* Another SELECT immediately to our left */\n<line7>Select *pSplit;       /* Left-most SELECT in the right-hand group */\n<line8>int nSelect;          /* Number of SELECT statements in the compound */\n<line9>Vdbe *v;              /* Generate code to this VDBE */\n<line10>SelectDest destA;     /* Destination for coroutine A */\n<line11>SelectDest destB;     /* Destination for coroutine B */\n<line12>int regAddrA;         /* Address register for select-A coroutine */\n<line13>int regAddrB;         /* Address register for select-B coroutine */\n<line14>int addrSelectA;      /* Address of the select-A coroutine */\n<line15>int addrSelectB;      /* Address of the select-B coroutine */\n<line16>int regOutA;          /* Address register for the output-A subroutine */\n<line17>int regOutB;          /* Address register for the output-B subroutine */\n<line18>int addrOutA;         /* Address of the output-A subroutine */\n<line19>int addrOutB = 0;     /* Address of the output-B subroutine */\n<line20>int addrEofA;         /* Address of the select-A-exhausted subroutine */\n<line21>int addrEofA_noB;     /* Alternate addrEofA if B is uninitialized */\n<line22>int addrEofB;         /* Address of the select-B-exhausted subroutine */\n<line23>int addrAltB;         /* Address of the A<B subroutine */\n<line24>int addrAeqB;         /* Address of the A==B subroutine */\n<line25>int addrAgtB;         /* Address of the A>B subroutine */\n<line26>int regLimitA;        /* Limit register for select-A */\n<line27>int regLimitB;        /* Limit register for select-A */\n<line28>int regPrev;          /* A range of registers to hold previous output */\n<line29>int savedLimit;       /* Saved value of p->iLimit */\n<line30>int savedOffset;      /* Saved value of p->iOffset */\n<line31>int labelCmpr;        /* Label for the start of the merge algorithm */\n<line32>int labelEnd;         /* Label for the end of the overall SELECT stmt */\n<line33>int addr1;            /* Jump instructions that get retargeted */\n<line34>int op;               /* One of TK_ALL, TK_UNION, TK_EXCEPT, TK_INTERSECT */\n<line35>KeyInfo *pKeyDup = 0; /* Comparison information for duplicate removal */\n<line36>KeyInfo *pKeyMerge;   /* Comparison information for merging rows */\n<line37>sqlite3 *db;          /* Database connection */\n<line38>ExprList *pOrderBy;   /* The ORDER BY clause */\n<line39>int nOrderBy;         /* Number of terms in the ORDER BY clause */\n<line40>u32 *aPermute;        /* Mapping from ORDER BY terms to result set columns */\n<line41>assert( p->pOrderBy!=0 );\n<line42>assert( pKeyDup==0 ); /* "Managed" code needs this.  Ticket #3382. */\n<line43>db = pParse->db;\n<line44>v = pParse->pVdbe;\n<line45>assert( v!=0 );       /* Already thrown the error if VDBE alloc failed */\n<line46>labelEnd = sqlite3VdbeMakeLabel(pParse);\n<line47>labelCmpr = sqlite3VdbeMakeLabel(pParse);\n<line48>/* Patch up the ORDER BY clause\n<line49>*/\n<line50>op = p->op;\n<line51>assert( p->pPrior->pOrderBy==0 );\n<line52>pOrderBy = p->pOrderBy;\n<line53>assert( pOrderBy );\n<line54>nOrderBy = pOrderBy->nExpr;\n<line55>/* For operators other than UNION ALL we have to make sure that\n<line56>** the ORDER BY clause covers every term of the result set.  Add\n<line57>** terms to the ORDER BY clause as necessary.\n<line58>*/\n<line59>if( op!=TK_ALL ){\n<line60>for(i=1; db->mallocFailed==0 && i<=p->pEList->nExpr; i++){\n<line61>struct ExprList_item *pItem;\n<line62>for(j=0, pItem=pOrderBy->a; j<nOrderBy; j++, pItem++){\n<line63>assert( pItem!=0 );\n<line64>assert( pItem->u.x.iOrderByCol>0 );\n<line65>if( pItem->u.x.iOrderByCol==i ) break;\n<line66>}\n<line67>if( j==nOrderBy ){\n<line68>Expr *pNew = sqlite3Expr(db, TK_INTEGER, 0);\n<line69>if( pNew==0 ) return SQLITE_NOMEM_BKPT;\n<line70>pNew->flags |= EP_IntValue;\n<line71>pNew->u.iValue = i;\n<line72>p->pOrderBy = pOrderBy = sqlite3ExprListAppend(pParse, pOrderBy, pNew);\n<line73>if( pOrderBy ) pOrderBy->a[nOrderBy++].u.x.iOrderByCol = (u16)i;\n<line74>}\n<line75>}\n<line76>}\n<line77>/* Compute the comparison permutation and keyinfo that is used with\n<line78>** the permutation used to determine if the next\n<line79>** row of results comes from selectA or selectB.  Also add explicit\n<line80>** collations to the ORDER BY clause terms so that when the subqueries\n<line81>** to the right and the left are evaluated, they use the correct\n<line82>** collation.\n<line83>*/\n<line84>aPermute = sqlite3DbMallocRawNN(db, sizeof(u32)*(nOrderBy + 1));\n<line85>if( aPermute ){\n<line86>struct ExprList_item *pItem;\n<line87>aPermute[0] = nOrderBy;\n<line88>for(i=1, pItem=pOrderBy->a; i<=nOrderBy; i++, pItem++){\n<line89>assert( pItem!=0 );\n<line90>assert( pItem->u.x.iOrderByCol>0 );\n<line91>assert( pItem->u.x.iOrderByCol<=p->pEList->nExpr );\n<line92>aPermute[i] = pItem->u.x.iOrderByCol - 1;\n<line93>}\n<line94>pKeyMerge = multiSelectOrderByKeyInfo(pParse, p, 1);\n<line95>}else{\n<line96>pKeyMerge = 0;\n<line97>}\n<line98>/* Allocate a range of temporary registers and the KeyInfo needed\n<line99>** for the logic that removes duplicate result rows when the\n<line100>** operator is UNION, EXCEPT, or INTERSECT (but not UNION ALL).\n<line101>*/\n<line102>if( op==TK_ALL ){\n<line103>regPrev = 0;\n<line104>}else{\n<line105>int nExpr = p->pEList->nExpr;\n<line106>assert( nOrderBy>=nExpr || db->mallocFailed );\n<line107>regPrev = pParse->nMem+1;\n<line108>pParse->nMem += nExpr+1;\n<line109>sqlite3VdbeAddOp2(v, OP_Integer, 0, regPrev);\n<line110>pKeyDup = sqlite3KeyInfoAlloc(db, nExpr, 1);\n<line111>if( pKeyDup ){\n<line112>assert( sqlite3KeyInfoIsWriteable(pKeyDup) );\n<line113>for(i=0; i<nExpr; i++){\n<line114>pKeyDup->aColl[i] = multiSelectCollSeq(pParse, p, i);\n<line115>pKeyDup->aSortFlags[i] = 0;\n<line116>}\n<line117>}\n<line118>}\n<line119>/* Separate the left and the right query from one another\n<line120>*/\n<line121>nSelect = 1;\n<line122>if( (op==TK_ALL || op==TK_UNION)\n<line123>&& OptimizationEnabled(db, SQLITE_BalancedMerge)\n<line124>){\n<line125>for(pSplit=p; pSplit->pPrior!=0 && pSplit->op==op; pSplit=pSplit->pPrior){\n<line126>nSelect++;\n<line127>assert( pSplit->pPrior->pNext==pSplit );\n<line128>}\n<line129>}\n<line130>if( nSelect<=3 ){\n<line131>pSplit = p;\n<line132>}else{\n<line133>pSplit = p;\n<line134>for(i=2; i<nSelect; i+=2){ pSplit = pSplit->pPrior; }\n<line135>}\n<line136>pPrior = pSplit->pPrior;\n<line137>assert( pPrior!=0 );\n<line138>pSplit->pPrior = 0;\n<line139>pPrior->pNext = 0;\n<line140>assert( p->pOrderBy == pOrderBy );\n<line141>assert( pOrderBy!=0 || db->mallocFailed );\n<line142>pPrior->pOrderBy = sqlite3ExprListDup(pParse->db, pOrderBy, 0);\n<line143>sqlite3ResolveOrderGroupBy(pParse, p, p->pOrderBy, "ORDER");\n<line144>sqlite3ResolveOrderGroupBy(pParse, pPrior, pPrior->pOrderBy, "ORDER");\n<line145>/* Compute the limit registers */\n<line146>computeLimitRegisters(pParse, p, labelEnd);\n<line147>if( p->iLimit && op==TK_ALL ){\n<line148>regLimitA = ++pParse->nMem;\n<line149>regLimitB = ++pParse->nMem;\n<line150>sqlite3VdbeAddOp2(v, OP_Copy, p->iOffset ? p->iOffset+1 : p->iLimit,\n<line151>regLimitA);\n<line152>sqlite3VdbeAddOp2(v, OP_Copy, regLimitA, regLimitB);\n<line153>}else{\n<line154>regLimitA = regLimitB = 0;\n<line155>}\n<line156>sqlite3ExprDelete(db, p->pLimit);\n<line157>p->pLimit = 0;\n<line158>regAddrA = ++pParse->nMem;\n<line159>regAddrB = ++pParse->nMem;\n<line160>regOutA = ++pParse->nMem;\n<line161>regOutB = ++pParse->nMem;\n<line162>sqlite3SelectDestInit(&destA, SRT_Coroutine, regAddrA);\n<line163>sqlite3SelectDestInit(&destB, SRT_Coroutine, regAddrB);\n<line164>ExplainQueryPlan((pParse, 1, "MERGE (%s)", sqlite3SelectOpName(p->op)));\n<line165>/* Generate a coroutine to evaluate the SELECT statement to the\n<line166>** left of the compound operator - the "A" select.\n<line167>*/\n<line168>addrSelectA = sqlite3VdbeCurrentAddr(v) + 1;\n<line169>addr1 = sqlite3VdbeAddOp3(v, OP_InitCoroutine, regAddrA, 0, addrSelectA);\n<line170>VdbeComment((v, "left SELECT"));\n<line171>pPrior->iLimit = regLimitA;\n<line172>ExplainQueryPlan((pParse, 1, "LEFT"));\n<line173>sqlite3Select(pParse, pPrior, &destA);\n<line174>sqlite3VdbeEndCoroutine(v, regAddrA);\n<line175>sqlite3VdbeJumpHere(v, addr1);\n<line176>/* Generate a coroutine to evaluate the SELECT statement on\n<line177>** the right - the "B" select\n<line178>*/\n<line179>addrSelectB = sqlite3VdbeCurrentAddr(v) + 1;\n<line180>addr1 = sqlite3VdbeAddOp3(v, OP_InitCoroutine, regAddrB, 0, addrSelectB);\n<line181>VdbeComment((v, "right SELECT"));\n<line182>savedLimit = p->iLimit;\n<line183>savedOffset = p->iOffset;\n<line184>p->iLimit = regLimitB;\n<line185>p->iOffset = 0;\n<line186>ExplainQueryPlan((pParse, 1, "RIGHT"));\n<line187>sqlite3Select(pParse, p, &destB);\n<line188>p->iLimit = savedLimit;\n<line189>p->iOffset = savedOffset;\n<line190>sqlite3VdbeEndCoroutine(v, regAddrB);\n<line191>/* Generate a subroutine that outputs the current row of the A\n<line192>** select as the next output row of the compound select.\n<line193>*/\n<line194>VdbeNoopComment((v, "Output routine for A"));\n<line195>addrOutA = generateOutputSubroutine(pParse,\n<line196>p, &destA, pDest, regOutA,\n<line197>regPrev, pKeyDup, labelEnd);\n<line198>/* Generate a subroutine that outputs the current row of the B\n<line199>** select as the next output row of the compound select.\n<line200>*/\n<line201>if( op==TK_ALL || op==TK_UNION ){\n<line202>VdbeNoopComment((v, "Output routine for B"));\n<line203>addrOutB = generateOutputSubroutine(pParse,\n<line204>p, &destB, pDest, regOutB,\n<line205>regPrev, pKeyDup, labelEnd);\n<line206>}\n<line207>sqlite3KeyInfoUnref(pKeyDup);\n<line208>/* Generate a subroutine to run when the results from select A\n<line209>** are exhausted and only data in select B remains.\n<line210>*/\n<line211>if( op==TK_EXCEPT || op==TK_INTERSECT ){\n<line212>addrEofA_noB = addrEofA = labelEnd;\n<line213>}else{\n<line214>VdbeNoopComment((v, "eof-A subroutine"));\n<line215>addrEofA = sqlite3VdbeAddOp2(v, OP_Gosub, regOutB, addrOutB);\n<line216>addrEofA_noB = sqlite3VdbeAddOp2(v, OP_Yield, regAddrB, labelEnd);\n<line217>VdbeCoverage(v);\n<line218>sqlite3VdbeGoto(v, addrEofA);\n<line219>p->nSelectRow = sqlite3LogEstAdd(p->nSelectRow, pPrior->nSelectRow);\n<line220>}\n<line221>/* Generate a subroutine to run when the results from select B\n<line222>** are exhausted and only data in select A remains.\n<line223>*/\n<line224>if( op==TK_INTERSECT ){\n<line225>addrEofB = addrEofA;\n<line226>if( p->nSelectRow > pPrior->nSelectRow ) p->nSelectRow = pPrior->nSelectRow;\n<line227>}else{\n<line228>VdbeNoopComment((v, "eof-B subroutine"));\n<line229>addrEofB = sqlite3VdbeAddOp2(v, OP_Gosub, regOutA, addrOutA);\n<line230>sqlite3VdbeAddOp2(v, OP_Yield, regAddrA, labelEnd); VdbeCoverage(v);\n<line231>sqlite3VdbeGoto(v, addrEofB);\n<line232>}\n<line233>/* Generate code to handle the case of A<B\n<line234>*/\n<line235>VdbeNoopComment((v, "A-lt-B subroutine"));\n<line236>addrAltB = sqlite3VdbeAddOp2(v, OP_Gosub, regOutA, addrOutA);\n<line237>sqlite3VdbeAddOp2(v, OP_Yield, regAddrA, addrEofA); VdbeCoverage(v);\n<line238>sqlite3VdbeGoto(v, labelCmpr);\n<line239>/* Generate code to handle the case of A==B\n<line240>*/\n<line241>if( op==TK_ALL ){\n<line242>addrAeqB = addrAltB;\n<line243>}else if( op==TK_INTERSECT ){\n<line244>addrAeqB = addrAltB;\n<line245>addrAltB++;\n<line246>}else{\n<line247>VdbeNoopComment((v, "A-eq-B subroutine"));\n<line248>addrAeqB =\n<line249>sqlite3VdbeAddOp2(v, OP_Yield, regAddrA, addrEofA); VdbeCoverage(v);\n<line250>sqlite3VdbeGoto(v, labelCmpr);\n<line251>}\n<line252>/* Generate code to handle the case of A>B\n<line253>*/\n<line254>VdbeNoopComment((v, "A-gt-B subroutine"));\n<line255>addrAgtB = sqlite3VdbeCurrentAddr(v);\n<line256>if( op==TK_ALL || op==TK_UNION ){\n<line257>sqlite3VdbeAddOp2(v, OP_Gosub, regOutB, addrOutB);\n<line258>}\n<line259>sqlite3VdbeAddOp2(v, OP_Yield, regAddrB, addrEofB); VdbeCoverage(v);\n<line260>sqlite3VdbeGoto(v, labelCmpr);\n<line261>/* This code runs once to initialize everything.\n<line262>*/\n<line263>sqlite3VdbeJumpHere(v, addr1);\n<line264>sqlite3VdbeAddOp2(v, OP_Yield, regAddrA, addrEofA_noB); VdbeCoverage(v);\n<line265>sqlite3VdbeAddOp2(v, OP_Yield, regAddrB, addrEofB); VdbeCoverage(v);\n<line266>/* Implement the main merge loop\n<line267>*/\n<line268>sqlite3VdbeResolveLabel(v, labelCmpr);\n<line269>sqlite3VdbeAddOp4(v, OP_Permutation, 0, 0, 0, (char*)aPermute, P4_INTARRAY);\n<line270>sqlite3VdbeAddOp4(v, OP_Compare, destA.iSdst, destB.iSdst, nOrderBy,\n<line271>(char*)pKeyMerge, P4_KEYINFO);\n<line272>sqlite3VdbeChangeP5(v, OPFLAG_PERMUTE);\n<line273>sqlite3VdbeAddOp3(v, OP_Jump, addrAltB, addrAeqB, addrAgtB); VdbeCoverage(v);\n<line274>/* Jump to the this point in order to terminate the query.\n<line275>*/\n<line276>sqlite3VdbeResolveLabel(v, labelEnd);\n<line277>/* Make arrangements to free the 2nd and subsequent arms of the compound\n<line278>** after the parse has finished */\n<line279>if( pSplit->pPrior ){\n<line280>sqlite3ParserAddCleanup(pParse, sqlite3SelectDeleteGeneric, pSplit->pPrior);\n<line281>}\n<line282>pSplit->pPrior = pPrior;\n<line283>pPrior->pNext = pSplit;\n<line284>sqlite3ExprListDelete(db, pPrior->pOrderBy);\n<line285>pPrior->pOrderBy = 0;\n<line286>/*** TBD:  Insert subroutine calls to close cursors on incomplete\n<line287>**** subqueries ****/\n<line288>ExplainQueryPlanPop(pParse);\n<line289>return pParse->nErr!=0;\n<line290>}
----------------------------------------
Function: substExpr
Content: <line0>static Expr *substExpr(\n<line1>SubstContext *pSubst,  /* Description of the substitution */\n<line2>Expr *pExpr            /* Expr in which substitution occurs */\n<line3>){\n<line4>if( pExpr==0 ) return 0;\n<line5>if( ExprHasProperty(pExpr, EP_OuterON|EP_InnerON)\n<line6>&& pExpr->w.iJoin==pSubst->iTable\n<line7>){\n<line8>testcase( ExprHasProperty(pExpr, EP_InnerON) );\n<line9>pExpr->w.iJoin = pSubst->iNewTable;\n<line10>}\n<line11>if( pExpr->op==TK_COLUMN\n<line12>&& pExpr->iTable==pSubst->iTable\n<line13>&& !ExprHasProperty(pExpr, EP_FixedCol)\n<line14>){\n<line15>#ifdef SQLITE_ALLOW_ROWID_IN_VIEW\n<line16>if( pExpr->iColumn<0 ){\n<line17>pExpr->op = TK_NULL;\n<line18>}else\n<line19>#endif\n<line20>{\n<line21>Expr *pNew;\n<line22>int iColumn;\n<line23>Expr *pCopy;\n<line24>Expr ifNullRow;\n<line25>iColumn = pExpr->iColumn;\n<line26>assert( iColumn>=0 );\n<line27>assert( pSubst->pEList!=0 && iColumn<pSubst->pEList->nExpr );\n<line28>assert( pExpr->pRight==0 );\n<line29>pCopy = pSubst->pEList->a[iColumn].pExpr;\n<line30>if( sqlite3ExprIsVector(pCopy) ){\n<line31>sqlite3VectorErrorMsg(pSubst->pParse, pCopy);\n<line32>}else{\n<line33>sqlite3 *db = pSubst->pParse->db;\n<line34>if( pSubst->isOuterJoin\n<line35>&& (pCopy->op!=TK_COLUMN || pCopy->iTable!=pSubst->iNewTable)\n<line36>){\n<line37>memset(&ifNullRow, 0, sizeof(ifNullRow));\n<line38>ifNullRow.op = TK_IF_NULL_ROW;\n<line39>ifNullRow.pLeft = pCopy;\n<line40>ifNullRow.iTable = pSubst->iNewTable;\n<line41>ifNullRow.iColumn = -99;\n<line42>ifNullRow.flags = EP_IfNullRow;\n<line43>pCopy = &ifNullRow;\n<line44>}\n<line45>testcase( ExprHasProperty(pCopy, EP_Subquery) );\n<line46>pNew = sqlite3ExprDup(db, pCopy, 0);\n<line47>if( db->mallocFailed ){\n<line48>sqlite3ExprDelete(db, pNew);\n<line49>return pExpr;\n<line50>}\n<line51>if( pSubst->isOuterJoin ){\n<line52>ExprSetProperty(pNew, EP_CanBeNull);\n<line53>}\n<line54>if( pNew->op==TK_TRUEFALSE ){\n<line55>pNew->u.iValue = sqlite3ExprTruthValue(pNew);\n<line56>pNew->op = TK_INTEGER;\n<line57>ExprSetProperty(pNew, EP_IntValue);\n<line58>}\n<line59>/* Ensure that the expression now has an implicit collation sequence,\n<line60>** just as it did when it was a column of a view or sub-query. */\n<line61>{\n<line62>CollSeq *pNat = sqlite3ExprCollSeq(pSubst->pParse, pNew);\n<line63>CollSeq *pColl = sqlite3ExprCollSeq(pSubst->pParse,\n<line64>pSubst->pCList->a[iColumn].pExpr\n<line65>);\n<line66>if( pNat!=pColl || (pNew->op!=TK_COLUMN && pNew->op!=TK_COLLATE) ){\n<line67>pNew = sqlite3ExprAddCollateString(pSubst->pParse, pNew,\n<line68>(pColl ? pColl->zName : "BINARY")\n<line69>);\n<line70>}\n<line71>}\n<line72>ExprClearProperty(pNew, EP_Collate);\n<line73>if( ExprHasProperty(pExpr,EP_OuterON|EP_InnerON) ){\n<line74>sqlite3SetJoinExpr(pNew, pExpr->w.iJoin,\n<line75>pExpr->flags & (EP_OuterON|EP_InnerON));\n<line76>}\n<line77>sqlite3ExprDelete(db, pExpr);\n<line78>pExpr = pNew;\n<line79>}\n<line80>}\n<line81>}else{\n<line82>if( pExpr->op==TK_IF_NULL_ROW && pExpr->iTable==pSubst->iTable ){\n<line83>pExpr->iTable = pSubst->iNewTable;\n<line84>}\n<line85>if( pExpr->op==TK_AGG_FUNCTION && pExpr->op2>=pSubst->nSelDepth ){\n<line86>pExpr->op2--;\n<line87>}\n<line88>pExpr->pLeft = substExpr(pSubst, pExpr->pLeft);\n<line89>pExpr->pRight = substExpr(pSubst, pExpr->pRight);\n<line90>if( ExprUseXSelect(pExpr) ){\n<line91>substSelect(pSubst, pExpr->x.pSelect, 1);\n<line92>}else{\n<line93>substExprList(pSubst, pExpr->x.pList);\n<line94>}\n<line95>#ifndef SQLITE_OMIT_WINDOWFUNC\n<line96>if( ExprHasProperty(pExpr, EP_WinFunc) ){\n<line97>Window *pWin = pExpr->y.pWin;\n<line98>pWin->pFilter = substExpr(pSubst, pWin->pFilter);\n<line99>substExprList(pSubst, pWin->pPartition);\n<line100>substExprList(pSubst, pWin->pOrderBy);\n<line101>}\n<line102>#endif\n<line103>}\n<line104>return pExpr;\n<line105>}
----------------------------------------
Function: substExprList
Content: <line0>static void substExprList(\n<line1>SubstContext *pSubst, /* Description of the substitution */\n<line2>ExprList *pList       /* List to scan and in which to make substitutes */\n<line3>){\n<line4>int i;\n<line5>if( pList==0 ) return;\n<line6>for(i=0; i<pList->nExpr; i++){\n<line7>pList->a[i].pExpr = substExpr(pSubst, pList->a[i].pExpr);\n<line8>}\n<line9>}
----------------------------------------
Function: substSelect
Content: <line0>static void substSelect(\n<line1>SubstContext *pSubst, /* Description of the substitution */\n<line2>Select *p,            /* SELECT statement in which to make substitutions */\n<line3>int doPrior           /* Do substitutes on p->pPrior too */\n<line4>){\n<line5>SrcList *pSrc;\n<line6>SrcItem *pItem;\n<line7>int i;\n<line8>if( !p ) return;\n<line9>pSubst->nSelDepth++;\n<line10>do{\n<line11>substExprList(pSubst, p->pEList);\n<line12>substExprList(pSubst, p->pGroupBy);\n<line13>substExprList(pSubst, p->pOrderBy);\n<line14>p->pHaving = substExpr(pSubst, p->pHaving);\n<line15>p->pWhere = substExpr(pSubst, p->pWhere);\n<line16>pSrc = p->pSrc;\n<line17>assert( pSrc!=0 );\n<line18>for(i=pSrc->nSrc, pItem=pSrc->a; i>0; i--, pItem++){\n<line19>if( pItem->fg.isSubquery ){\n<line20>substSelect(pSubst, pItem->u4.pSubq->pSelect, 1);\n<line21>}\n<line22>if( pItem->fg.isTabFunc ){\n<line23>substExprList(pSubst, pItem->u1.pFuncArg);\n<line24>}\n<line25>}\n<line26>}while( doPrior && (p = p->pPrior)!=0 );\n<line27>pSubst->nSelDepth--;\n<line28>}
----------------------------------------
Function: recomputeColumnsUsedExpr
Content: <line0>static int recomputeColumnsUsedExpr(Walker *pWalker, Expr *pExpr){\n<line1>SrcItem *pItem;\n<line2>if( pExpr->op!=TK_COLUMN ) return WRC_Continue;\n<line3>pItem = pWalker->u.pSrcItem;\n<line4>if( pItem->iCursor!=pExpr->iTable ) return WRC_Continue;\n<line5>if( pExpr->iColumn<0 ) return WRC_Continue;\n<line6>pItem->colUsed |= sqlite3ExprColUsed(pExpr);\n<line7>return WRC_Continue;\n<line8>}
----------------------------------------
Function: recomputeColumnsUsed
Content: <line0>static void recomputeColumnsUsed(\n<line1>Select *pSelect,                 /* The complete SELECT statement */\n<line2>SrcItem *pSrcItem                /* Which FROM clause item to recompute */\n<line3>){\n<line4>Walker w;\n<line5>if( NEVER(pSrcItem->pSTab==0) ) return;\n<line6>memset(&w, 0, sizeof(w));\n<line7>w.xExprCallback = recomputeColumnsUsedExpr;\n<line8>w.xSelectCallback = sqlite3SelectWalkNoop;\n<line9>w.u.pSrcItem = pSrcItem;\n<line10>pSrcItem->colUsed = 0;\n<line11>sqlite3WalkSelect(&w, pSelect);\n<line12>}
----------------------------------------
Function: srclistRenumberCursors
Content: <line0>static void srclistRenumberCursors(\n<line1>Parse *pParse,                  /* Parse context */\n<line2>int *aCsrMap,                   /* Array to store cursor mappings in */\n<line3>SrcList *pSrc,                  /* FROM clause to renumber */\n<line4>int iExcept                     /* FROM clause item to skip */\n<line5>){\n<line6>int i;\n<line7>SrcItem *pItem;\n<line8>for(i=0, pItem=pSrc->a; i<pSrc->nSrc; i++, pItem++){\n<line9>if( i!=iExcept ){\n<line10>Select *p;\n<line11>assert( pItem->iCursor < aCsrMap[0] );\n<line12>if( !pItem->fg.isRecursive || aCsrMap[pItem->iCursor+1]==0 ){\n<line13>aCsrMap[pItem->iCursor+1] = pParse->nTab++;\n<line14>}\n<line15>pItem->iCursor = aCsrMap[pItem->iCursor+1];\n<line16>if( pItem->fg.isSubquery ){\n<line17>for(p=pItem->u4.pSubq->pSelect; p; p=p->pPrior){\n<line18>srclistRenumberCursors(pParse, aCsrMap, p->pSrc, -1);\n<line19>}\n<line20>}\n<line21>}\n<line22>}\n<line23>}
----------------------------------------
Function: renumberCursorDoMapping
Content: <line0>static void renumberCursorDoMapping(Walker *pWalker, int *piCursor){\n<line1>int *aCsrMap = pWalker->u.aiCol;\n<line2>int iCsr = *piCursor;\n<line3>if( iCsr < aCsrMap[0] && aCsrMap[iCsr+1]>0 ){\n<line4>*piCursor = aCsrMap[iCsr+1];\n<line5>}\n<line6>}
----------------------------------------
Function: renumberCursorsCb
Content: <line0>static int renumberCursorsCb(Walker *pWalker, Expr *pExpr){\n<line1>int op = pExpr->op;\n<line2>if( op==TK_COLUMN || op==TK_IF_NULL_ROW ){\n<line3>renumberCursorDoMapping(pWalker, &pExpr->iTable);\n<line4>}\n<line5>if( ExprHasProperty(pExpr, EP_OuterON) ){\n<line6>renumberCursorDoMapping(pWalker, &pExpr->w.iJoin);\n<line7>}\n<line8>return WRC_Continue;\n<line9>}
----------------------------------------
Function: renumberCursors
Content: <line0>static void renumberCursors(\n<line1>Parse *pParse,                  /* Parse context */\n<line2>Select *p,                      /* Select to renumber cursors within */\n<line3>int iExcept,                    /* FROM clause item to skip */\n<line4>int *aCsrMap                    /* Working space */\n<line5>){\n<line6>Walker w;\n<line7>srclistRenumberCursors(pParse, aCsrMap, p->pSrc, iExcept);\n<line8>memset(&w, 0, sizeof(w));\n<line9>w.u.aiCol = aCsrMap;\n<line10>w.xExprCallback = renumberCursorsCb;\n<line11>w.xSelectCallback = sqlite3SelectWalkNoop;\n<line12>sqlite3WalkSelect(&w, p);\n<line13>}
----------------------------------------
Function: findLeftmostExprlist
Content: <line0>static ExprList *findLeftmostExprlist(Select *pSel){\n<line1>while( pSel->pPrior ){\n<line2>pSel = pSel->pPrior;\n<line3>}\n<line4>return pSel->pEList;\n<line5>}
----------------------------------------
Function: compoundHasDifferentAffinities
Content: <line0>static int compoundHasDifferentAffinities(Select *p){\n<line1>int ii;\n<line2>ExprList *pList;\n<line3>assert( p!=0 );\n<line4>assert( p->pEList!=0 );\n<line5>assert( p->pPrior!=0 );\n<line6>pList = p->pEList;\n<line7>for(ii=0; ii<pList->nExpr; ii++){\n<line8>char aff;\n<line9>Select *pSub1;\n<line10>assert( pList->a[ii].pExpr!=0 );\n<line11>aff = sqlite3ExprAffinity(pList->a[ii].pExpr);\n<line12>for(pSub1=p->pPrior; pSub1; pSub1=pSub1->pPrior){\n<line13>assert( pSub1->pEList!=0 );\n<line14>assert( pSub1->pEList->nExpr>ii );\n<line15>assert( pSub1->pEList->a[ii].pExpr!=0 );\n<line16>if( sqlite3ExprAffinity(pSub1->pEList->a[ii].pExpr)!=aff ){\n<line17>return 1;\n<line18>}\n<line19>}\n<line20>}\n<line21>return 0;\n<line22>}
----------------------------------------
Function: flattenSubquery
Content: <line0>static int flattenSubquery(\n<line1>Parse *pParse,       /* Parsing context */\n<line2>Select *p,           /* The parent or outer SELECT statement */\n<line3>int iFrom,           /* Index in p->pSrc->a[] of the inner subquery */\n<line4>int isAgg            /* True if outer SELECT uses aggregate functions */\n<line5>){\n<line6>const char *zSavedAuthContext = pParse->zAuthContext;\n<line7>Select *pParent;    /* Current UNION ALL term of the other query */\n<line8>Select *pSub;       /* The inner query or "subquery" */\n<line9>Select *pSub1;      /* Pointer to the rightmost select in sub-query */\n<line10>SrcList *pSrc;      /* The FROM clause of the outer query */\n<line11>SrcList *pSubSrc;   /* The FROM clause of the subquery */\n<line12>int iParent;        /* VDBE cursor number of the pSub result set temp table */\n<line13>int iNewParent = -1;/* Replacement table for iParent */\n<line14>int isOuterJoin = 0; /* True if pSub is the right side of a LEFT JOIN */\n<line15>int i;              /* Loop counter */\n<line16>Expr *pWhere;                    /* The WHERE clause */\n<line17>SrcItem *pSubitem;               /* The subquery */\n<line18>sqlite3 *db = pParse->db;\n<line19>Walker w;                        /* Walker to persist agginfo data */\n<line20>int *aCsrMap = 0;\n<line21>/* Check to see if flattening is permitted.  Return 0 if not.\n<line22>*/\n<line23>assert( p!=0 );\n<line24>assert( p->pPrior==0 );\n<line25>if( OptimizationDisabled(db, SQLITE_QueryFlattener) ) return 0;\n<line26>pSrc = p->pSrc;\n<line27>assert( pSrc && iFrom>=0 && iFrom<pSrc->nSrc );\n<line28>pSubitem = &pSrc->a[iFrom];\n<line29>iParent = pSubitem->iCursor;\n<line30>assert( pSubitem->fg.isSubquery );\n<line31>pSub = pSubitem->u4.pSubq->pSelect;\n<line32>assert( pSub!=0 );\n<line33>#ifndef SQLITE_OMIT_WINDOWFUNC\n<line34>if( p->pWin || pSub->pWin ) return 0;                  /* Restriction (25) */\n<line35>#endif\n<line36>pSubSrc = pSub->pSrc;\n<line37>assert( pSubSrc );\n<line38>/* Prior to version 3.1.2, when LIMIT and OFFSET had to be simple constants,\n<line39>** not arbitrary expressions, we allowed some combining of LIMIT and OFFSET\n<line40>** because they could be computed at compile-time.  But when LIMIT and OFFSET\n<line41>** became arbitrary expressions, we were forced to add restrictions (13)\n<line42>** and (14). */\n<line43>if( pSub->pLimit && p->pLimit ) return 0;              /* Restriction (13) */\n<line44>if( pSub->pLimit && pSub->pLimit->pRight ) return 0;   /* Restriction (14) */\n<line45>if( (p->selFlags & SF_Compound)!=0 && pSub->pLimit ){\n<line46>return 0;                                            /* Restriction (15) */\n<line47>}\n<line48>if( pSubSrc->nSrc==0 ) return 0;                       /* Restriction (7)  */\n<line49>if( pSub->selFlags & SF_Distinct ) return 0;           /* Restriction (4)  */\n<line50>if( pSub->pLimit && (pSrc->nSrc>1 || isAgg) ){\n<line51>return 0;         /* Restrictions (8)(9) */\n<line52>}\n<line53>if( p->pOrderBy && pSub->pOrderBy ){\n<line54>return 0;                                           /* Restriction (11) */\n<line55>}\n<line56>if( isAgg && pSub->pOrderBy ) return 0;                /* Restriction (16) */\n<line57>if( pSub->pLimit && p->pWhere ) return 0;              /* Restriction (19) */\n<line58>if( pSub->pLimit && (p->selFlags & SF_Distinct)!=0 ){\n<line59>return 0;         /* Restriction (21) */\n<line60>}\n<line61>if( pSub->selFlags & (SF_Recursive) ){\n<line62>return 0; /* Restrictions (22) */\n<line63>}\n<line64>/*\n<line65>** If the subquery is the right operand of a LEFT JOIN, then the\n<line66>** subquery may not be a join itself (3a). Example of why this is not\n<line67>** allowed:\n<line68>**\n<line69>**         t1 LEFT OUTER JOIN (t2 JOIN t3)\n<line70>**\n<line71>** If we flatten the above, we would get\n<line72>**\n<line73>**         (t1 LEFT OUTER JOIN t2) JOIN t3\n<line74>**\n<line75>** which is not at all the same thing.\n<line76>**\n<line77>** See also tickets #306, #350, and #3300.\n<line78>*/\n<line79>if( (pSubitem->fg.jointype & (JT_OUTER|JT_LTORJ))!=0 ){\n<line80>if( pSubSrc->nSrc>1                        /* (3a) */\n<line81>/**** || IsVirtual(pSubSrc->a[0].pSTab)      (3b)-omitted */\n<line82>|| (p->selFlags & SF_Distinct)!=0         /* (3d) */\n<line83>|| (pSubitem->fg.jointype & JT_RIGHT)!=0  /* (26) */\n<line84>){\n<line85>return 0;\n<line86>}\n<line87>isOuterJoin = 1;\n<line88>}\n<line89>assert( pSubSrc->nSrc>0 );  /* True by restriction (7) */\n<line90>if( iFrom>0 && (pSubSrc->a[0].fg.jointype & JT_LTORJ)!=0 ){\n<line91>return 0;   /* Restriction (27a) */\n<line92>}\n<line93>/* Condition (28) is blocked by the caller */\n<line94>assert( !pSubitem->fg.isCte || pSubitem->u2.pCteUse->eM10d!=M10d_Yes );\n<line95>/* Restriction (17): If the sub-query is a compound SELECT, then it must\n<line96>** use only the UNION ALL operator. And none of the simple select queries\n<line97>** that make up the compound SELECT are allowed to be aggregate or distinct\n<line98>** queries.\n<line99>*/\n<line100>if( pSub->pPrior ){\n<line101>int ii;\n<line102>if( pSub->pOrderBy ){\n<line103>return 0;  /* Restriction (20) */\n<line104>}\n<line105>if( isAgg || (p->selFlags & SF_Distinct)!=0 || isOuterJoin>0 ){\n<line106>return 0; /* (17d1), (17d2), or (17f) */\n<line107>}\n<line108>for(pSub1=pSub; pSub1; pSub1=pSub1->pPrior){\n<line109>testcase( (pSub1->selFlags & (SF_Distinct|SF_Aggregate))==SF_Distinct );\n<line110>testcase( (pSub1->selFlags & (SF_Distinct|SF_Aggregate))==SF_Aggregate );\n<line111>assert( pSub->pSrc!=0 );\n<line112>assert( (pSub->selFlags & SF_Recursive)==0 );\n<line113>assert( pSub->pEList->nExpr==pSub1->pEList->nExpr );\n<line114>if( (pSub1->selFlags & (SF_Distinct|SF_Aggregate))!=0    /* (17b) */\n<line115>|| (pSub1->pPrior && pSub1->op!=TK_ALL)                 /* (17a) */\n<line116>|| pSub1->pSrc->nSrc<1                                  /* (17c) */\n<line117>#ifndef SQLITE_OMIT_WINDOWFUNC\n<line118>|| pSub1->pWin                                          /* (17e) */\n<line119>#endif\n<line120>){\n<line121>return 0;\n<line122>}\n<line123>if( iFrom>0 && (pSub1->pSrc->a[0].fg.jointype & JT_LTORJ)!=0 ){\n<line124>/* Without this restriction, the JT_LTORJ flag would end up being\n<line125>** omitted on left-hand tables of the right join that is being\n<line126>** flattened. */\n<line127>return 0;   /* Restrictions (17g), (27b) */\n<line128>}\n<line129>testcase( pSub1->pSrc->nSrc>1 );\n<line130>}\n<line131>/* Restriction (18). */\n<line132>if( p->pOrderBy ){\n<line133>for(ii=0; ii<p->pOrderBy->nExpr; ii++){\n<line134>if( p->pOrderBy->a[ii].u.x.iOrderByCol==0 ) return 0;\n<line135>}\n<line136>}\n<line137>/* Restriction (23) */\n<line138>if( (p->selFlags & SF_Recursive) ) return 0;\n<line139>/* Restriction (17h) */\n<line140>if( compoundHasDifferentAffinities(pSub) ) return 0;\n<line141>if( pSrc->nSrc>1 ){\n<line142>if( pParse->nSelect>500 ) return 0;\n<line143>if( OptimizationDisabled(db, SQLITE_FlttnUnionAll) ) return 0;\n<line144>aCsrMap = sqlite3DbMallocZero(db, ((i64)pParse->nTab+1)*sizeof(int));\n<line145>if( aCsrMap ) aCsrMap[0] = pParse->nTab;\n<line146>}\n<line147>}\n<line148>/***** If we reach this point, flattening is permitted. *****/\n<line149>TREETRACE(0x4,pParse,p,("flatten %u.%p from term %d\n",\n<line150>pSub->selId, pSub, iFrom));\n<line151>/* Authorize the subquery */\n<line152>pParse->zAuthContext = pSubitem->zName;\n<line153>TESTONLY(i =) sqlite3AuthCheck(pParse, SQLITE_SELECT, 0, 0, 0);\n<line154>testcase( i==SQLITE_DENY );\n<line155>pParse->zAuthContext = zSavedAuthContext;\n<line156>/* Delete the transient structures associated with the subquery */\n<line157>if( ALWAYS(pSubitem->fg.isSubquery) ){\n<line158>pSub1 = sqlite3SubqueryDetach(db, pSubitem);\n<line159>}else{\n<line160>pSub1 = 0;\n<line161>}\n<line162>assert( pSubitem->fg.isSubquery==0 );\n<line163>assert( pSubitem->fg.fixedSchema==0 );\n<line164>sqlite3DbFree(db, pSubitem->zName);\n<line165>sqlite3DbFree(db, pSubitem->zAlias);\n<line166>pSubitem->zName = 0;\n<line167>pSubitem->zAlias = 0;\n<line168>assert( pSubitem->fg.isUsing!=0 || pSubitem->u3.pOn==0 );\n<line169>/* If the sub-query is a compound SELECT statement, then (by restrictions\n<line170>** 17 and 18 above) it must be a UNION ALL and the parent query must\n<line171>** be of the form:\n<line172>**\n<line173>**     SELECT <expr-list> FROM (<sub-query>) <where-clause>\n<line174>**\n<line175>** followed by any ORDER BY, LIMIT and/or OFFSET clauses. This block\n<line176>** creates N-1 copies of the parent query without any ORDER BY, LIMIT or\n<line177>** OFFSET clauses and joins them to the left-hand-side of the original\n<line178>** using UNION ALL operators. In this case N is the number of simple\n<line179>** select statements in the compound sub-query.\n<line180>**\n<line181>** Example:\n<line182>**\n<line183>**     SELECT a+1 FROM (\n<line184>**        SELECT x FROM tab\n<line185>**        UNION ALL\n<line186>**        SELECT y FROM tab\n<line187>**        UNION ALL\n<line188>**        SELECT abs(z*2) FROM tab2\n<line189>**     ) WHERE a!=5 ORDER BY 1\n<line190>**\n<line191>** Transformed into:\n<line192>**\n<line193>**     SELECT x+1 FROM tab WHERE x+1!=5\n<line194>**     UNION ALL\n<line195>**     SELECT y+1 FROM tab WHERE y+1!=5\n<line196>**     UNION ALL\n<line197>**     SELECT abs(z*2)+1 FROM tab2 WHERE abs(z*2)+1!=5\n<line198>**     ORDER BY 1\n<line199>**\n<line200>** We call this the "compound-subquery flattening".\n<line201>*/\n<line202>for(pSub=pSub->pPrior; pSub; pSub=pSub->pPrior){\n<line203>Select *pNew;\n<line204>ExprList *pOrderBy = p->pOrderBy;\n<line205>Expr *pLimit = p->pLimit;\n<line206>Select *pPrior = p->pPrior;\n<line207>Table *pItemTab = pSubitem->pSTab;\n<line208>pSubitem->pSTab = 0;\n<line209>p->pOrderBy = 0;\n<line210>p->pPrior = 0;\n<line211>p->pLimit = 0;\n<line212>pNew = sqlite3SelectDup(db, p, 0);\n<line213>p->pLimit = pLimit;\n<line214>p->pOrderBy = pOrderBy;\n<line215>p->op = TK_ALL;\n<line216>pSubitem->pSTab = pItemTab;\n<line217>if( pNew==0 ){\n<line218>p->pPrior = pPrior;\n<line219>}else{\n<line220>pNew->selId = ++pParse->nSelect;\n<line221>if( aCsrMap && ALWAYS(db->mallocFailed==0) ){\n<line222>renumberCursors(pParse, pNew, iFrom, aCsrMap);\n<line223>}\n<line224>pNew->pPrior = pPrior;\n<line225>if( pPrior ) pPrior->pNext = pNew;\n<line226>pNew->pNext = p;\n<line227>p->pPrior = pNew;\n<line228>TREETRACE(0x4,pParse,p,("compound-subquery flattener"\n<line229>" creates %u as peer\n",pNew->selId));\n<line230>}\n<line231>assert( pSubitem->fg.isSubquery==0 );\n<line232>}\n<line233>sqlite3DbFree(db, aCsrMap);\n<line234>if( db->mallocFailed ){\n<line235>assert( pSubitem->fg.fixedSchema==0 );\n<line236>assert( pSubitem->fg.isSubquery==0 );\n<line237>assert( pSubitem->u4.zDatabase==0 );\n<line238>sqlite3SrcItemAttachSubquery(pParse, pSubitem, pSub1, 0);\n<line239>return 1;\n<line240>}\n<line241>/* Defer deleting the Table object associated with the\n<line242>** subquery until code generation is\n<line243>** complete, since there may still exist Expr.pTab entries that\n<line244>** refer to the subquery even after flattening.  Ticket #3346.\n<line245>**\n<line246>** pSubitem->pSTab is always non-NULL by test restrictions and tests above.\n<line247>*/\n<line248>if( ALWAYS(pSubitem->pSTab!=0) ){\n<line249>Table *pTabToDel = pSubitem->pSTab;\n<line250>if( pTabToDel->nTabRef==1 ){\n<line251>Parse *pToplevel = sqlite3ParseToplevel(pParse);\n<line252>sqlite3ParserAddCleanup(pToplevel, sqlite3DeleteTableGeneric, pTabToDel);\n<line253>testcase( pToplevel->earlyCleanup );\n<line254>}else{\n<line255>pTabToDel->nTabRef--;\n<line256>}\n<line257>pSubitem->pSTab = 0;\n<line258>}\n<line259>/* The following loop runs once for each term in a compound-subquery\n<line260>** flattening (as described above).  If we are doing a different kind\n<line261>** of flattening - a flattening other than a compound-subquery flattening -\n<line262>** then this loop only runs once.\n<line263>**\n<line264>** This loop moves all of the FROM elements of the subquery into the\n<line265>** the FROM clause of the outer query.  Before doing this, remember\n<line266>** the cursor number for the original outer query FROM element in\n<line267>** iParent.  The iParent cursor will never be used.  Subsequent code\n<line268>** will scan expressions looking for iParent references and replace\n<line269>** those references with expressions that resolve to the subquery FROM\n<line270>** elements we are now copying in.\n<line271>*/\n<line272>pSub = pSub1;\n<line273>for(pParent=p; pParent; pParent=pParent->pPrior, pSub=pSub->pPrior){\n<line274>int nSubSrc;\n<line275>u8 jointype = pSubitem->fg.jointype;\n<line276>assert( pSub!=0 );\n<line277>pSubSrc = pSub->pSrc;     /* FROM clause of subquery */\n<line278>nSubSrc = pSubSrc->nSrc;  /* Number of terms in subquery FROM clause */\n<line279>pSrc = pParent->pSrc;     /* FROM clause of the outer query */\n<line280>/* The subquery uses a single slot of the FROM clause of the outer\n<line281>** query.  If the subquery has more than one element in its FROM clause,\n<line282>** then expand the outer query to make space for it to hold all elements\n<line283>** of the subquery.\n<line284>**\n<line285>** Example:\n<line286>**\n<line287>**    SELECT * FROM tabA, (SELECT * FROM sub1, sub2), tabB;\n<line288>**\n<line289>** The outer query has 3 slots in its FROM clause.  One slot of the\n<line290>** outer query (the middle slot) is used by the subquery.  The next\n<line291>** block of code will expand the outer query FROM clause to 4 slots.\n<line292>** The middle slot is expanded to two slots in order to make space\n<line293>** for the two elements in the FROM clause of the subquery.\n<line294>*/\n<line295>if( nSubSrc>1 ){\n<line296>pSrc = sqlite3SrcListEnlarge(pParse, pSrc, nSubSrc-1,iFrom+1);\n<line297>if( pSrc==0 ) break;\n<line298>pParent->pSrc = pSrc;\n<line299>pSubitem = &pSrc->a[iFrom];\n<line300>}\n<line301>/* Transfer the FROM clause terms from the subquery into the\n<line302>** outer query.\n<line303>*/\n<line304>iNewParent = pSubSrc->a[0].iCursor;\n<line305>for(i=0; i<nSubSrc; i++){\n<line306>SrcItem *pItem = &pSrc->a[i+iFrom];\n<line307>assert( pItem->fg.isTabFunc==0 );\n<line308>assert( pItem->fg.isSubquery\n<line309>|| pItem->fg.fixedSchema\n<line310>|| pItem->u4.zDatabase==0 );\n<line311>if( pItem->fg.isUsing ) sqlite3IdListDelete(db, pItem->u3.pUsing);\n<line312>*pItem = pSubSrc->a[i];\n<line313>pItem->fg.jointype |= (jointype & JT_LTORJ);\n<line314>memset(&pSubSrc->a[i], 0, sizeof(pSubSrc->a[i]));\n<line315>}\n<line316>pSubitem->fg.jointype |= jointype;\n<line317>/* Now begin substituting subquery result set expressions for\n<line318>** references to the iParent in the outer query.\n<line319>**\n<line320>** Example:\n<line321>**\n<line322>**   SELECT a+5, b*10 FROM (SELECT x*3 AS a, y+10 AS b FROM t1) WHERE a>b;\n<line323>**   \                     \_____________ subquery __________/          /\n<line324>**    \_____________________ outer query ______________________________/\n<line325>**\n<line326>** We look at every expression in the outer query and every place we see\n<line327>** "a" we substitute "x*3" and every place we see "b" we substitute "y+10".\n<line328>*/\n<line329>if( pSub->pOrderBy && (pParent->selFlags & SF_NoopOrderBy)==0 ){\n<line330>/* At this point, any non-zero iOrderByCol values indicate that the\n<line331>** ORDER BY column expression is identical to the iOrderByCol'th\n<line332>** expression returned by SELECT statement pSub. Since these values\n<line333>** do not necessarily correspond to columns in SELECT statement pParent,\n<line334>** zero them before transferring the ORDER BY clause.\n<line335>**\n<line336>** Not doing this may cause an error if a subsequent call to this\n<line337>** function attempts to flatten a compound sub-query into pParent\n<line338>** (the only way this can happen is if the compound sub-query is\n<line339>** currently part of pSub->pSrc). See ticket [d11a6e908f].  */\n<line340>ExprList *pOrderBy = pSub->pOrderBy;\n<line341>for(i=0; i<pOrderBy->nExpr; i++){\n<line342>pOrderBy->a[i].u.x.iOrderByCol = 0;\n<line343>}\n<line344>assert( pParent->pOrderBy==0 );\n<line345>pParent->pOrderBy = pOrderBy;\n<line346>pSub->pOrderBy = 0;\n<line347>}\n<line348>pWhere = pSub->pWhere;\n<line349>pSub->pWhere = 0;\n<line350>if( isOuterJoin>0 ){\n<line351>assert( pSubSrc->nSrc==1 );\n<line352>sqlite3SetJoinExpr(pWhere, iNewParent, EP_OuterON);\n<line353>}\n<line354>if( pWhere ){\n<line355>if( pParent->pWhere ){\n<line356>pParent->pWhere = sqlite3PExpr(pParse, TK_AND, pWhere, pParent->pWhere);\n<line357>}else{\n<line358>pParent->pWhere = pWhere;\n<line359>}\n<line360>}\n<line361>if( db->mallocFailed==0 ){\n<line362>SubstContext x;\n<line363>x.pParse = pParse;\n<line364>x.iTable = iParent;\n<line365>x.iNewTable = iNewParent;\n<line366>x.isOuterJoin = isOuterJoin;\n<line367>x.nSelDepth = 0;\n<line368>x.pEList = pSub->pEList;\n<line369>x.pCList = findLeftmostExprlist(pSub);\n<line370>substSelect(&x, pParent, 0);\n<line371>}\n<line372>/* The flattened query is a compound if either the inner or the\n<line373>** outer query is a compound. */\n<line374>pParent->selFlags |= pSub->selFlags & SF_Compound;\n<line375>assert( (pSub->selFlags & SF_Distinct)==0 ); /* restriction (17b) */\n<line376>/*\n<line377>** SELECT ... FROM (SELECT ... LIMIT a OFFSET b) LIMIT x OFFSET y;\n<line378>**\n<line379>** One is tempted to try to add a and b to combine the limits.  But this\n<line380>** does not work if either limit is negative.\n<line381>*/\n<line382>if( pSub->pLimit ){\n<line383>pParent->pLimit = pSub->pLimit;\n<line384>pSub->pLimit = 0;\n<line385>}\n<line386>/* Recompute the SrcItem.colUsed masks for the flattened\n<line387>** tables. */\n<line388>for(i=0; i<nSubSrc; i++){\n<line389>recomputeColumnsUsed(pParent, &pSrc->a[i+iFrom]);\n<line390>}\n<line391>}\n<line392>/* Finally, delete what is left of the subquery and return success.\n<line393>*/\n<line394>sqlite3AggInfoPersistWalkerInit(&w, pParse);\n<line395>sqlite3WalkSelect(&w,pSub1);\n<line396>sqlite3SelectDelete(db, pSub1);\n<line397>#if TREETRACE_ENABLED\n<line398>if( sqlite3TreeTrace & 0x4 ){\n<line399>TREETRACE(0x4,pParse,p,("After flattening:\n"));\n<line400>sqlite3TreeViewSelect(0, p, 0);\n<line401>}\n<line402>#endif\n<line403>return 1;\n<line404>}
----------------------------------------
Function: constInsert
Content: <line0>static void constInsert(\n<line1>WhereConst *pConst,  /* The WhereConst into which we are inserting */\n<line2>Expr *pColumn,       /* The COLUMN part of the constraint */\n<line3>Expr *pValue,        /* The VALUE part of the constraint */\n<line4>Expr *pExpr          /* Overall expression: COLUMN=VALUE or VALUE=COLUMN */\n<line5>){\n<line6>int i;\n<line7>assert( pColumn->op==TK_COLUMN );\n<line8>assert( sqlite3ExprIsConstant(pConst->pParse, pValue) );\n<line9>if( ExprHasProperty(pColumn, EP_FixedCol) ) return;\n<line10>if( sqlite3ExprAffinity(pValue)!=0 ) return;\n<line11>if( !sqlite3IsBinary(sqlite3ExprCompareCollSeq(pConst->pParse,pExpr)) ){\n<line12>return;\n<line13>}\n<line14>/* 2018-10-25 ticket [cf5ed20f]\n<line15>** Make sure the same pColumn is not inserted more than once */\n<line16>for(i=0; i<pConst->nConst; i++){\n<line17>const Expr *pE2 = pConst->apExpr[i*2];\n<line18>assert( pE2->op==TK_COLUMN );\n<line19>if( pE2->iTable==pColumn->iTable\n<line20>&& pE2->iColumn==pColumn->iColumn\n<line21>){\n<line22>return;  /* Already present.  Return without doing anything. */\n<line23>}\n<line24>}\n<line25>assert( SQLITE_AFF_NONE<SQLITE_AFF_BLOB );\n<line26>if( sqlite3ExprAffinity(pColumn)<=SQLITE_AFF_BLOB ){\n<line27>pConst->bHasAffBlob = 1;\n<line28>}\n<line29>pConst->nConst++;\n<line30>pConst->apExpr = sqlite3DbReallocOrFree(pConst->pParse->db, pConst->apExpr,\n<line31>pConst->nConst*2*sizeof(Expr*));\n<line32>if( pConst->apExpr==0 ){\n<line33>pConst->nConst = 0;\n<line34>}else{\n<line35>pConst->apExpr[pConst->nConst*2-2] = pColumn;\n<line36>pConst->apExpr[pConst->nConst*2-1] = pValue;\n<line37>}\n<line38>}
----------------------------------------
Function: findConstInWhere
Content: <line0>static void findConstInWhere(WhereConst *pConst, Expr *pExpr){\n<line1>Expr *pRight, *pLeft;\n<line2>if( NEVER(pExpr==0) ) return;\n<line3>if( ExprHasProperty(pExpr, pConst->mExcludeOn) ){\n<line4>testcase( ExprHasProperty(pExpr, EP_OuterON) );\n<line5>testcase( ExprHasProperty(pExpr, EP_InnerON) );\n<line6>return;\n<line7>}\n<line8>if( pExpr->op==TK_AND ){\n<line9>findConstInWhere(pConst, pExpr->pRight);\n<line10>findConstInWhere(pConst, pExpr->pLeft);\n<line11>return;\n<line12>}\n<line13>if( pExpr->op!=TK_EQ ) return;\n<line14>pRight = pExpr->pRight;\n<line15>pLeft = pExpr->pLeft;\n<line16>assert( pRight!=0 );\n<line17>assert( pLeft!=0 );\n<line18>if( pRight->op==TK_COLUMN && sqlite3ExprIsConstant(pConst->pParse, pLeft) ){\n<line19>constInsert(pConst,pRight,pLeft,pExpr);\n<line20>}\n<line21>if( pLeft->op==TK_COLUMN && sqlite3ExprIsConstant(pConst->pParse, pRight) ){\n<line22>constInsert(pConst,pLeft,pRight,pExpr);\n<line23>}\n<line24>}
----------------------------------------
Function: propagateConstantExprRewriteOne
Content: <line0>static int propagateConstantExprRewriteOne(\n<line1>WhereConst *pConst,\n<line2>Expr *pExpr,\n<line3>int bIgnoreAffBlob\n<line4>){\n<line5>int i;\n<line6>if( pConst->pOomFault[0] ) return WRC_Prune;\n<line7>if( pExpr->op!=TK_COLUMN ) return WRC_Continue;\n<line8>if( ExprHasProperty(pExpr, EP_FixedCol|pConst->mExcludeOn) ){\n<line9>testcase( ExprHasProperty(pExpr, EP_FixedCol) );\n<line10>testcase( ExprHasProperty(pExpr, EP_OuterON) );\n<line11>testcase( ExprHasProperty(pExpr, EP_InnerON) );\n<line12>return WRC_Continue;\n<line13>}\n<line14>for(i=0; i<pConst->nConst; i++){\n<line15>Expr *pColumn = pConst->apExpr[i*2];\n<line16>if( pColumn==pExpr ) continue;\n<line17>if( pColumn->iTable!=pExpr->iTable ) continue;\n<line18>if( pColumn->iColumn!=pExpr->iColumn ) continue;\n<line19>assert( SQLITE_AFF_NONE<SQLITE_AFF_BLOB );\n<line20>if( bIgnoreAffBlob && sqlite3ExprAffinity(pColumn)<=SQLITE_AFF_BLOB ){\n<line21>break;\n<line22>}\n<line23>/* A match is found.  Add the EP_FixedCol property */\n<line24>pConst->nChng++;\n<line25>ExprClearProperty(pExpr, EP_Leaf);\n<line26>ExprSetProperty(pExpr, EP_FixedCol);\n<line27>assert( pExpr->pLeft==0 );\n<line28>pExpr->pLeft = sqlite3ExprDup(pConst->pParse->db, pConst->apExpr[i*2+1], 0);\n<line29>if( pConst->pParse->db->mallocFailed ) return WRC_Prune;\n<line30>break;\n<line31>}\n<line32>return WRC_Prune;\n<line33>}
----------------------------------------
Function: propagateConstantExprRewrite
Content: <line0>static int propagateConstantExprRewrite(Walker *pWalker, Expr *pExpr){\n<line1>WhereConst *pConst = pWalker->u.pConst;\n<line2>assert( TK_GT==TK_EQ+1 );\n<line3>assert( TK_LE==TK_EQ+2 );\n<line4>assert( TK_LT==TK_EQ+3 );\n<line5>assert( TK_GE==TK_EQ+4 );\n<line6>if( pConst->bHasAffBlob ){\n<line7>if( (pExpr->op>=TK_EQ && pExpr->op<=TK_GE)\n<line8>|| pExpr->op==TK_IS\n<line9>){\n<line10>propagateConstantExprRewriteOne(pConst, pExpr->pLeft, 0);\n<line11>if( pConst->pOomFault[0] ) return WRC_Prune;\n<line12>if( sqlite3ExprAffinity(pExpr->pLeft)!=SQLITE_AFF_TEXT ){\n<line13>propagateConstantExprRewriteOne(pConst, pExpr->pRight, 0);\n<line14>}\n<line15>}\n<line16>}\n<line17>return propagateConstantExprRewriteOne(pConst, pExpr, pConst->bHasAffBlob);\n<line18>}
----------------------------------------
Function: propagateConstants
Content: <line0>static int propagateConstants(\n<line1>Parse *pParse,   /* The parsing context */\n<line2>Select *p        /* The query in which to propagate constants */\n<line3>){\n<line4>WhereConst x;\n<line5>Walker w;\n<line6>int nChng = 0;\n<line7>x.pParse = pParse;\n<line8>x.pOomFault = &pParse->db->mallocFailed;\n<line9>do{\n<line10>x.nConst = 0;\n<line11>x.nChng = 0;\n<line12>x.apExpr = 0;\n<line13>x.bHasAffBlob = 0;\n<line14>if( ALWAYS(p->pSrc!=0)\n<line15>&& p->pSrc->nSrc>0\n<line16>&& (p->pSrc->a[0].fg.jointype & JT_LTORJ)!=0\n<line17>){\n<line18>/* Do not propagate constants on any ON clause if there is a\n<line19>** RIGHT JOIN anywhere in the query */\n<line20>x.mExcludeOn = EP_InnerON | EP_OuterON;\n<line21>}else{\n<line22>/* Do not propagate constants through the ON clause of a LEFT JOIN */\n<line23>x.mExcludeOn = EP_OuterON;\n<line24>}\n<line25>findConstInWhere(&x, p->pWhere);\n<line26>if( x.nConst ){\n<line27>memset(&w, 0, sizeof(w));\n<line28>w.pParse = pParse;\n<line29>w.xExprCallback = propagateConstantExprRewrite;\n<line30>w.xSelectCallback = sqlite3SelectWalkNoop;\n<line31>w.xSelectCallback2 = 0;\n<line32>w.walkerDepth = 0;\n<line33>w.u.pConst = &x;\n<line34>sqlite3WalkExpr(&w, p->pWhere);\n<line35>sqlite3DbFree(x.pParse->db, x.apExpr);\n<line36>nChng += x.nChng;\n<line37>}\n<line38>}while( x.nChng );\n<line39>return nChng;\n<line40>}
----------------------------------------
Function: pushDownWindowCheck
Content: <line0>static int pushDownWindowCheck(Parse *pParse, Select *pSubq, Expr *pExpr){\n<line1>assert( pSubq->pWin->pPartition );\n<line2>assert( (pSubq->selFlags & SF_MultiPart)==0 );\n<line3>assert( pSubq->pPrior==0 );\n<line4>return sqlite3ExprIsConstantOrGroupBy(pParse, pExpr, pSubq->pWin->pPartition);\n<line5>}
----------------------------------------
Function: pushDownWhereTerms
Content: <line0>static int pushDownWhereTerms(\n<line1>Parse *pParse,        /* Parse context (for malloc() and error reporting) */\n<line2>Select *pSubq,        /* The subquery whose WHERE clause is to be augmented */\n<line3>Expr *pWhere,         /* The WHERE clause of the outer query */\n<line4>SrcList *pSrcList,    /* The complete from clause of the outer query */\n<line5>int iSrc              /* Which FROM clause term to try to push into  */\n<line6>){\n<line7>Expr *pNew;\n<line8>SrcItem *pSrc;        /* The subquery FROM term into which WHERE is pushed */\n<line9>int nChng = 0;\n<line10>pSrc = &pSrcList->a[iSrc];\n<line11>if( pWhere==0 ) return 0;\n<line12>if( pSubq->selFlags & (SF_Recursive|SF_MultiPart) ){\n<line13>return 0;           /* restrictions (2) and (11) */\n<line14>}\n<line15>if( pSrc->fg.jointype & (JT_LTORJ|JT_RIGHT) ){\n<line16>return 0;           /* restrictions (10) */\n<line17>}\n<line18>if( pSubq->pPrior ){\n<line19>Select *pSel;\n<line20>int notUnionAll = 0;\n<line21>for(pSel=pSubq; pSel; pSel=pSel->pPrior){\n<line22>u8 op = pSel->op;\n<line23>assert( op==TK_ALL || op==TK_SELECT\n<line24>|| op==TK_UNION || op==TK_INTERSECT || op==TK_EXCEPT );\n<line25>if( op!=TK_ALL && op!=TK_SELECT ){\n<line26>notUnionAll = 1;\n<line27>}\n<line28>#ifndef SQLITE_OMIT_WINDOWFUNC\n<line29>if( pSel->pWin ) return 0;    /* restriction (6b) */\n<line30>#endif\n<line31>}\n<line32>if( notUnionAll ){\n<line33>/* If any of the compound arms are connected using UNION, INTERSECT,\n<line34>** or EXCEPT, then we must ensure that none of the columns use a\n<line35>** non-BINARY collating sequence. */\n<line36>for(pSel=pSubq; pSel; pSel=pSel->pPrior){\n<line37>int ii;\n<line38>const ExprList *pList = pSel->pEList;\n<line39>assert( pList!=0 );\n<line40>for(ii=0; ii<pList->nExpr; ii++){\n<line41>CollSeq *pColl = sqlite3ExprCollSeq(pParse, pList->a[ii].pExpr);\n<line42>if( !sqlite3IsBinary(pColl) ){\n<line43>return 0;  /* Restriction (8) */\n<line44>}\n<line45>}\n<line46>}\n<line47>}\n<line48>}else{\n<line49>#ifndef SQLITE_OMIT_WINDOWFUNC\n<line50>if( pSubq->pWin && pSubq->pWin->pPartition==0 ) return 0;\n<line51>#endif\n<line52>}\n<line53>#ifdef SQLITE_DEBUG\n<line54>/* Only the first term of a compound can have a WITH clause.  But make\n<line55>** sure no other terms are marked SF_Recursive in case something changes\n<line56>** in the future.\n<line57>*/\n<line58>{\n<line59>Select *pX;\n<line60>for(pX=pSubq; pX; pX=pX->pPrior){\n<line61>assert( (pX->selFlags & (SF_Recursive))==0 );\n<line62>}\n<line63>}\n<line64>#endif\n<line65>if( pSubq->pLimit!=0 ){\n<line66>return 0; /* restriction (3) */\n<line67>}\n<line68>while( pWhere->op==TK_AND ){\n<line69>nChng += pushDownWhereTerms(pParse, pSubq, pWhere->pRight, pSrcList, iSrc);\n<line70>pWhere = pWhere->pLeft;\n<line71>}\n<line72>#if 0 /* These checks now done by sqlite3ExprIsSingleTableConstraint() */\n<line73>if( ExprHasProperty(pWhere, EP_OuterON|EP_InnerON) /* (9a) */\n<line74>&& (pSrcList->a[0].fg.jointype & JT_LTORJ)!=0     /* Fast pre-test of (9c) */\n<line75>){\n<line76>int jj;\n<line77>for(jj=0; jj<iSrc; jj++){\n<line78>if( pWhere->w.iJoin==pSrcList->a[jj].iCursor ){\n<line79>/* If we reach this point, both (9a) and (9b) are satisfied.\n<line80>** The following loop checks (9c):\n<line81>*/\n<line82>for(jj++; jj<iSrc; jj++){\n<line83>if( (pSrcList->a[jj].fg.jointype & JT_RIGHT)!=0 ){\n<line84>return 0;  /* restriction (9) */\n<line85>}\n<line86>}\n<line87>}\n<line88>}\n<line89>}\n<line90>if( isLeftJoin\n<line91>&& (ExprHasProperty(pWhere,EP_OuterON)==0\n<line92>|| pWhere->w.iJoin!=iCursor)\n<line93>){\n<line94>return 0; /* restriction (4) */\n<line95>}\n<line96>if( ExprHasProperty(pWhere,EP_OuterON)\n<line97>&& pWhere->w.iJoin!=iCursor\n<line98>){\n<line99>return 0; /* restriction (5) */\n<line100>}\n<line101>#endif\n<line102>#ifdef SQLITE_ALLOW_ROWID_IN_VIEW\n<line103>if( ViewCanHaveRowid && (pWhere->op==TK_ISNULL || pWhere->op==TK_NOTNULL) ){\n<line104>Expr *pLeft = pWhere->pLeft;\n<line105>if( ALWAYS(pLeft)\n<line106>&& pLeft->op==TK_COLUMN\n<line107>&& pLeft->iColumn < 0\n<line108>){\n<line109>return 0;  /* Restriction (12) */\n<line110>}\n<line111>}\n<line112>#endif\n<line113>if( sqlite3ExprIsSingleTableConstraint(pWhere, pSrcList, iSrc, 1) ){\n<line114>nChng++;\n<line115>pSubq->selFlags |= SF_PushDown;\n<line116>while( pSubq ){\n<line117>SubstContext x;\n<line118>pNew = sqlite3ExprDup(pParse->db, pWhere, 0);\n<line119>unsetJoinExpr(pNew, -1, 1);\n<line120>x.pParse = pParse;\n<line121>x.iTable = pSrc->iCursor;\n<line122>x.iNewTable = pSrc->iCursor;\n<line123>x.isOuterJoin = 0;\n<line124>x.nSelDepth = 0;\n<line125>x.pEList = pSubq->pEList;\n<line126>x.pCList = findLeftmostExprlist(pSubq);\n<line127>pNew = substExpr(&x, pNew);\n<line128>#ifndef SQLITE_OMIT_WINDOWFUNC\n<line129>if( pSubq->pWin && 0==pushDownWindowCheck(pParse, pSubq, pNew) ){\n<line130>/* Restriction 6c has prevented push-down in this case */\n<line131>sqlite3ExprDelete(pParse->db, pNew);\n<line132>nChng--;\n<line133>break;\n<line134>}\n<line135>#endif\n<line136>if( pSubq->selFlags & SF_Aggregate ){\n<line137>pSubq->pHaving = sqlite3ExprAnd(pParse, pSubq->pHaving, pNew);\n<line138>}else{\n<line139>pSubq->pWhere = sqlite3ExprAnd(pParse, pSubq->pWhere, pNew);\n<line140>}\n<line141>pSubq = pSubq->pPrior;\n<line142>}\n<line143>}\n<line144>return nChng;\n<line145>}
----------------------------------------
Function: disableUnusedSubqueryResultColumns
Content: <line0>static int disableUnusedSubqueryResultColumns(SrcItem *pItem){\n<line1>int nCol;\n<line2>Select *pSub;      /* The subquery to be simplified */\n<line3>Select *pX;        /* For looping over compound elements of pSub */\n<line4>Table *pTab;       /* The table that describes the subquery */\n<line5>int j;             /* Column number */\n<line6>int nChng = 0;     /* Number of columns converted to NULL */\n<line7>Bitmask colUsed;   /* Columns that may not be NULLed out */\n<line8>assert( pItem!=0 );\n<line9>if( pItem->fg.isCorrelated || pItem->fg.isCte ){\n<line10>return 0;\n<line11>}\n<line12>assert( pItem->pSTab!=0 );\n<line13>pTab = pItem->pSTab;\n<line14>assert( pItem->fg.isSubquery );\n<line15>pSub = pItem->u4.pSubq->pSelect;\n<line16>assert( pSub->pEList->nExpr==pTab->nCol );\n<line17>for(pX=pSub; pX; pX=pX->pPrior){\n<line18>if( (pX->selFlags & (SF_Distinct|SF_Aggregate))!=0 ){\n<line19>testcase( pX->selFlags & SF_Distinct );\n<line20>testcase( pX->selFlags & SF_Aggregate );\n<line21>return 0;\n<line22>}\n<line23>if( pX->pPrior && pX->op!=TK_ALL ){\n<line24>/* This optimization does not work for compound subqueries that\n<line25>** use UNION, INTERSECT, or EXCEPT.  Only UNION ALL is allowed. */\n<line26>return 0;\n<line27>}\n<line28>#ifndef SQLITE_OMIT_WINDOWFUNC\n<line29>if( pX->pWin ){\n<line30>/* This optimization does not work for subqueries that use window\n<line31>** functions. */\n<line32>return 0;\n<line33>}\n<line34>#endif\n<line35>}\n<line36>colUsed = pItem->colUsed;\n<line37>if( pSub->pOrderBy ){\n<line38>ExprList *pList = pSub->pOrderBy;\n<line39>for(j=0; j<pList->nExpr; j++){\n<line40>u16 iCol = pList->a[j].u.x.iOrderByCol;\n<line41>if( iCol>0 ){\n<line42>iCol--;\n<line43>colUsed |= ((Bitmask)1)<<(iCol>=BMS ? BMS-1 : iCol);\n<line44>}\n<line45>}\n<line46>}\n<line47>nCol = pTab->nCol;\n<line48>for(j=0; j<nCol; j++){\n<line49>Bitmask m = j<BMS-1 ? MASKBIT(j) : TOPBIT;\n<line50>if( (m & colUsed)!=0 ) continue;\n<line51>for(pX=pSub; pX; pX=pX->pPrior) {\n<line52>Expr *pY = pX->pEList->a[j].pExpr;\n<line53>if( pY->op==TK_NULL ) continue;\n<line54>pY->op = TK_NULL;\n<line55>ExprClearProperty(pY, EP_Skip|EP_Unlikely);\n<line56>pX->selFlags |= SF_PushDown;\n<line57>nChng++;\n<line58>}\n<line59>}\n<line60>return nChng;\n<line61>}
----------------------------------------
Function: minMaxQuery
Content: <line0>static u8 minMaxQuery(sqlite3 *db, Expr *pFunc, ExprList **ppMinMax){\n<line1>int eRet = WHERE_ORDERBY_NORMAL;      /* Return value */\n<line2>ExprList *pEList;                     /* Arguments to agg function */\n<line3>const char *zFunc;                    /* Name of aggregate function pFunc */\n<line4>ExprList *pOrderBy;\n<line5>u8 sortFlags = 0;\n<line6>assert( *ppMinMax==0 );\n<line7>assert( pFunc->op==TK_AGG_FUNCTION );\n<line8>assert( !IsWindowFunc(pFunc) );\n<line9>assert( ExprUseXList(pFunc) );\n<line10>pEList = pFunc->x.pList;\n<line11>if( pEList==0\n<line12>|| pEList->nExpr!=1\n<line13>|| ExprHasProperty(pFunc, EP_WinFunc)\n<line14>|| OptimizationDisabled(db, SQLITE_MinMaxOpt)\n<line15>){\n<line16>return eRet;\n<line17>}\n<line18>assert( !ExprHasProperty(pFunc, EP_IntValue) );\n<line19>zFunc = pFunc->u.zToken;\n<line20>if( sqlite3StrICmp(zFunc, "min")==0 ){\n<line21>eRet = WHERE_ORDERBY_MIN;\n<line22>if( sqlite3ExprCanBeNull(pEList->a[0].pExpr) ){\n<line23>sortFlags = KEYINFO_ORDER_BIGNULL;\n<line24>}\n<line25>}else if( sqlite3StrICmp(zFunc, "max")==0 ){\n<line26>eRet = WHERE_ORDERBY_MAX;\n<line27>sortFlags = KEYINFO_ORDER_DESC;\n<line28>}else{\n<line29>return eRet;\n<line30>}\n<line31>*ppMinMax = pOrderBy = sqlite3ExprListDup(db, pEList, 0);\n<line32>assert( pOrderBy!=0 || db->mallocFailed );\n<line33>if( pOrderBy ) pOrderBy->a[0].fg.sortFlags = sortFlags;\n<line34>return eRet;\n<line35>}
----------------------------------------
Function: isSimpleCount
Content: <line0>static Table *isSimpleCount(Select *p, AggInfo *pAggInfo){\n<line1>Table *pTab;\n<line2>Expr *pExpr;\n<line3>assert( !p->pGroupBy );\n<line4>if( p->pWhere\n<line5>|| p->pEList->nExpr!=1\n<line6>|| p->pSrc->nSrc!=1\n<line7>|| p->pSrc->a[0].fg.isSubquery\n<line8>|| pAggInfo->nFunc!=1\n<line9>|| p->pHaving\n<line10>){\n<line11>return 0;\n<line12>}\n<line13>pTab = p->pSrc->a[0].pSTab;\n<line14>assert( pTab!=0 );\n<line15>assert( !IsView(pTab) );\n<line16>if( !IsOrdinaryTable(pTab) ) return 0;\n<line17>pExpr = p->pEList->a[0].pExpr;\n<line18>assert( pExpr!=0 );\n<line19>if( pExpr->op!=TK_AGG_FUNCTION ) return 0;\n<line20>if( pExpr->pAggInfo!=pAggInfo ) return 0;\n<line21>if( (pAggInfo->aFunc[0].pFunc->funcFlags&SQLITE_FUNC_COUNT)==0 ) return 0;\n<line22>assert( pAggInfo->aFunc[0].pFExpr==pExpr );\n<line23>testcase( ExprHasProperty(pExpr, EP_Distinct) );\n<line24>testcase( ExprHasProperty(pExpr, EP_WinFunc) );\n<line25>if( ExprHasProperty(pExpr, EP_Distinct|EP_WinFunc) ) return 0;\n<line26>return pTab;\n<line27>}
----------------------------------------
Function: convertCompoundSelectToSubquery
Content: <line0>static int convertCompoundSelectToSubquery(Walker *pWalker, Select *p){\n<line1>int i;\n<line2>Select *pNew;\n<line3>Select *pX;\n<line4>sqlite3 *db;\n<line5>struct ExprList_item *a;\n<line6>SrcList *pNewSrc;\n<line7>Parse *pParse;\n<line8>Token dummy;\n<line9>if( p->pPrior==0 ) return WRC_Continue;\n<line10>if( p->pOrderBy==0 ) return WRC_Continue;\n<line11>for(pX=p; pX && (pX->op==TK_ALL || pX->op==TK_SELECT); pX=pX->pPrior){}\n<line12>if( pX==0 ) return WRC_Continue;\n<line13>a = p->pOrderBy->a;\n<line14>#ifndef SQLITE_OMIT_WINDOWFUNC\n<line15>/* If iOrderByCol is already non-zero, then it has already been matched\n<line16>** to a result column of the SELECT statement. This occurs when the\n<line17>** SELECT is rewritten for window-functions processing and then passed\n<line18>** to sqlite3SelectPrep() and similar a second time. The rewriting done\n<line19>** by this function is not required in this case. */\n<line20>if( a[0].u.x.iOrderByCol ) return WRC_Continue;\n<line21>#endif\n<line22>for(i=p->pOrderBy->nExpr-1; i>=0; i--){\n<line23>if( a[i].pExpr->flags & EP_Collate ) break;\n<line24>}\n<line25>if( i<0 ) return WRC_Continue;\n<line26>/* If we reach this point, that means the transformation is required. */\n<line27>pParse = pWalker->pParse;\n<line28>db = pParse->db;\n<line29>pNew = sqlite3DbMallocZero(db, sizeof(*pNew) );\n<line30>if( pNew==0 ) return WRC_Abort;\n<line31>memset(&dummy, 0, sizeof(dummy));\n<line32>pNewSrc = sqlite3SrcListAppendFromTerm(pParse,0,0,0,&dummy,pNew,0);\n<line33>assert( pNewSrc!=0 || pParse->nErr );\n<line34>if( pParse->nErr ){\n<line35>sqlite3SrcListDelete(db, pNewSrc);\n<line36>return WRC_Abort;\n<line37>}\n<line38>*pNew = *p;\n<line39>p->pSrc = pNewSrc;\n<line40>p->pEList = sqlite3ExprListAppend(pParse, 0, sqlite3Expr(db, TK_ASTERISK, 0));\n<line41>p->op = TK_SELECT;\n<line42>p->pWhere = 0;\n<line43>pNew->pGroupBy = 0;\n<line44>pNew->pHaving = 0;\n<line45>pNew->pOrderBy = 0;\n<line46>p->pPrior = 0;\n<line47>p->pNext = 0;\n<line48>p->pWith = 0;\n<line49>#ifndef SQLITE_OMIT_WINDOWFUNC\n<line50>p->pWinDefn = 0;\n<line51>#endif\n<line52>p->selFlags &= ~(u32)SF_Compound;\n<line53>assert( (p->selFlags & SF_Converted)==0 );\n<line54>p->selFlags |= SF_Converted;\n<line55>assert( pNew->pPrior!=0 );\n<line56>pNew->pPrior->pNext = pNew;\n<line57>pNew->pLimit = 0;\n<line58>return WRC_Continue;\n<line59>}
----------------------------------------
Function: cannotBeFunction
Content: <line0>static int cannotBeFunction(Parse *pParse, SrcItem *pFrom){\n<line1>if( pFrom->fg.isTabFunc ){\n<line2>sqlite3ErrorMsg(pParse, "'%s' is not a function", pFrom->zName);\n<line3>return 1;\n<line4>}\n<line5>return 0;\n<line6>}
----------------------------------------
Function: searchWith
Content: <line0>static struct Cte *searchWith(\n<line1>With *pWith,                    /* Current innermost WITH clause */\n<line2>SrcItem *pItem,                 /* FROM clause element to resolve */\n<line3>With **ppContext                /* OUT: WITH clause return value belongs to */\n<line4>){\n<line5>const char *zName = pItem->zName;\n<line6>With *p;\n<line7>assert( pItem->fg.fixedSchema || pItem->u4.zDatabase==0 );\n<line8>assert( zName!=0 );\n<line9>for(p=pWith; p; p=p->pOuter){\n<line10>int i;\n<line11>for(i=0; i<p->nCte; i++){\n<line12>if( sqlite3StrICmp(zName, p->a[i].zName)==0 ){\n<line13>*ppContext = p;\n<line14>return &p->a[i];\n<line15>}\n<line16>}\n<line17>if( p->bView ) break;\n<line18>}\n<line19>return 0;\n<line20>}
----------------------------------------
Function: resolveFromTermToCte
Content: <line0>static int resolveFromTermToCte(\n<line1>Parse *pParse,                  /* The parsing context */\n<line2>Walker *pWalker,                /* Current tree walker */\n<line3>SrcItem *pFrom                  /* The FROM clause term to check */\n<line4>){\n<line5>Cte *pCte;               /* Matched CTE (or NULL if no match) */\n<line6>With *pWith;             /* The matching WITH */\n<line7>assert( pFrom->pSTab==0 );\n<line8>if( pParse->pWith==0 ){\n<line9>/* There are no WITH clauses in the stack.  No match is possible */\n<line10>return 0;\n<line11>}\n<line12>if( pParse->nErr ){\n<line13>/* Prior errors might have left pParse->pWith in a goofy state, so\n<line14>** go no further. */\n<line15>return 0;\n<line16>}\n<line17>assert( pFrom->fg.hadSchema==0 || pFrom->fg.notCte!=0 );\n<line18>if( pFrom->fg.fixedSchema==0 && pFrom->u4.zDatabase!=0 ){\n<line19>/* The FROM term contains a schema qualifier (ex: main.t1) and so\n<line20>** it cannot possibly be a CTE reference. */\n<line21>return 0;\n<line22>}\n<line23>if( pFrom->fg.notCte ){\n<line24>/* The FROM term is specifically excluded from matching a CTE.\n<line25>**   (1)  It is part of a trigger that used to have zDatabase but had\n<line26>**        zDatabase removed by sqlite3FixTriggerStep().\n<line27>**   (2)  This is the first term in the FROM clause of an UPDATE.\n<line28>*/\n<line29>return 0;\n<line30>}\n<line31>pCte = searchWith(pParse->pWith, pFrom, &pWith);\n<line32>if( pCte ){\n<line33>sqlite3 *db = pParse->db;\n<line34>Table *pTab;\n<line35>ExprList *pEList;\n<line36>Select *pSel;\n<line37>Select *pLeft;                /* Left-most SELECT statement */\n<line38>Select *pRecTerm;             /* Left-most recursive term */\n<line39>int bMayRecursive;            /* True if compound joined by UNION [ALL] */\n<line40>With *pSavedWith;             /* Initial value of pParse->pWith */\n<line41>int iRecTab = -1;             /* Cursor for recursive table */\n<line42>CteUse *pCteUse;\n<line43>/* If pCte->zCteErr is non-NULL at this point, then this is an illegal\n<line44>** recursive reference to CTE pCte. Leave an error in pParse and return\n<line45>** early. If pCte->zCteErr is NULL, then this is not a recursive reference.\n<line46>** In this case, proceed.  */\n<line47>if( pCte->zCteErr ){\n<line48>sqlite3ErrorMsg(pParse, pCte->zCteErr, pCte->zName);\n<line49>return 2;\n<line50>}\n<line51>if( cannotBeFunction(pParse, pFrom) ) return 2;\n<line52>assert( pFrom->pSTab==0 );\n<line53>pTab = sqlite3DbMallocZero(db, sizeof(Table));\n<line54>if( pTab==0 ) return 2;\n<line55>pCteUse = pCte->pUse;\n<line56>if( pCteUse==0 ){\n<line57>pCte->pUse = pCteUse = sqlite3DbMallocZero(db, sizeof(pCteUse[0]));\n<line58>if( pCteUse==0\n<line59>|| sqlite3ParserAddCleanup(pParse,sqlite3DbFree,pCteUse)==0\n<line60>){\n<line61>sqlite3DbFree(db, pTab);\n<line62>return 2;\n<line63>}\n<line64>pCteUse->eM10d = pCte->eM10d;\n<line65>}\n<line66>pFrom->pSTab = pTab;\n<line67>pTab->nTabRef = 1;\n<line68>pTab->zName = sqlite3DbStrDup(db, pCte->zName);\n<line69>pTab->iPKey = -1;\n<line70>pTab->nRowLogEst = 200; assert( 200==sqlite3LogEst(1048576) );\n<line71>pTab->tabFlags |= TF_Ephemeral | TF_NoVisibleRowid;\n<line72>sqlite3SrcItemAttachSubquery(pParse, pFrom, pCte->pSelect, 1);\n<line73>if( db->mallocFailed ) return 2;\n<line74>assert( pFrom->fg.isSubquery && pFrom->u4.pSubq );\n<line75>pSel = pFrom->u4.pSubq->pSelect;\n<line76>assert( pSel!=0 );\n<line77>pSel->selFlags |= SF_CopyCte;\n<line78>if( pFrom->fg.isIndexedBy ){\n<line79>sqlite3ErrorMsg(pParse, "no such index: \"%s\"", pFrom->u1.zIndexedBy);\n<line80>return 2;\n<line81>}\n<line82>assert( !pFrom->fg.isIndexedBy );\n<line83>pFrom->fg.isCte = 1;\n<line84>pFrom->u2.pCteUse = pCteUse;\n<line85>pCteUse->nUse++;\n<line86>/* Check if this is a recursive CTE. */\n<line87>pRecTerm = pSel;\n<line88>bMayRecursive = ( pSel->op==TK_ALL || pSel->op==TK_UNION );\n<line89>while( bMayRecursive && pRecTerm->op==pSel->op ){\n<line90>int i;\n<line91>SrcList *pSrc = pRecTerm->pSrc;\n<line92>assert( pRecTerm->pPrior!=0 );\n<line93>for(i=0; i<pSrc->nSrc; i++){\n<line94>SrcItem *pItem = &pSrc->a[i];\n<line95>if( pItem->zName!=0\n<line96>&& !pItem->fg.hadSchema\n<line97>&& ALWAYS( !pItem->fg.isSubquery )\n<line98>&& (pItem->fg.fixedSchema || pItem->u4.zDatabase==0)\n<line99>&& 0==sqlite3StrICmp(pItem->zName, pCte->zName)\n<line100>){\n<line101>pItem->pSTab = pTab;\n<line102>pTab->nTabRef++;\n<line103>pItem->fg.isRecursive = 1;\n<line104>if( pRecTerm->selFlags & SF_Recursive ){\n<line105>sqlite3ErrorMsg(pParse,\n<line106>"multiple references to recursive table: %s", pCte->zName\n<line107>);\n<line108>return 2;\n<line109>}\n<line110>pRecTerm->selFlags |= SF_Recursive;\n<line111>if( iRecTab<0 ) iRecTab = pParse->nTab++;\n<line112>pItem->iCursor = iRecTab;\n<line113>}\n<line114>}\n<line115>if( (pRecTerm->selFlags & SF_Recursive)==0 ) break;\n<line116>pRecTerm = pRecTerm->pPrior;\n<line117>}\n<line118>pCte->zCteErr = "circular reference: %s";\n<line119>pSavedWith = pParse->pWith;\n<line120>pParse->pWith = pWith;\n<line121>if( pSel->selFlags & SF_Recursive ){\n<line122>int rc;\n<line123>assert( pRecTerm!=0 );\n<line124>assert( (pRecTerm->selFlags & SF_Recursive)==0 );\n<line125>assert( pRecTerm->pNext!=0 );\n<line126>assert( (pRecTerm->pNext->selFlags & SF_Recursive)!=0 );\n<line127>assert( pRecTerm->pWith==0 );\n<line128>pRecTerm->pWith = pSel->pWith;\n<line129>rc = sqlite3WalkSelect(pWalker, pRecTerm);\n<line130>pRecTerm->pWith = 0;\n<line131>if( rc ){\n<line132>pParse->pWith = pSavedWith;\n<line133>return 2;\n<line134>}\n<line135>}else{\n<line136>if( sqlite3WalkSelect(pWalker, pSel) ){\n<line137>pParse->pWith = pSavedWith;\n<line138>return 2;\n<line139>}\n<line140>}\n<line141>pParse->pWith = pWith;\n<line142>for(pLeft=pSel; pLeft->pPrior; pLeft=pLeft->pPrior);\n<line143>pEList = pLeft->pEList;\n<line144>if( pCte->pCols ){\n<line145>if( pEList && pEList->nExpr!=pCte->pCols->nExpr ){\n<line146>sqlite3ErrorMsg(pParse, "table %s has %d values for %d columns",\n<line147>pCte->zName, pEList->nExpr, pCte->pCols->nExpr\n<line148>);\n<line149>pParse->pWith = pSavedWith;\n<line150>return 2;\n<line151>}\n<line152>pEList = pCte->pCols;\n<line153>}\n<line154>sqlite3ColumnsFromExprList(pParse, pEList, &pTab->nCol, &pTab->aCol);\n<line155>if( bMayRecursive ){\n<line156>if( pSel->selFlags & SF_Recursive ){\n<line157>pCte->zCteErr = "multiple recursive references: %s";\n<line158>}else{\n<line159>pCte->zCteErr = "recursive reference in a subquery: %s";\n<line160>}\n<line161>sqlite3WalkSelect(pWalker, pSel);\n<line162>}\n<line163>pCte->zCteErr = 0;\n<line164>pParse->pWith = pSavedWith;\n<line165>return 1;  /* Success */\n<line166>}\n<line167>return 0;  /* No match */\n<line168>}
----------------------------------------
Function: inAnyUsingClause
Content: <line0>static int inAnyUsingClause(\n<line1>const char *zName, /* Name we are looking for */\n<line2>SrcItem *pBase,    /* The base SrcItem.  Looking at pBase[1] and following */\n<line3>int N              /* How many SrcItems to check */\n<line4>){\n<line5>while( N>0 ){\n<line6>N--;\n<line7>pBase++;\n<line8>if( pBase->fg.isUsing==0 ) continue;\n<line9>if( NEVER(pBase->u3.pUsing==0) ) continue;\n<line10>if( sqlite3IdListIndex(pBase->u3.pUsing, zName)>=0 ) return 1;\n<line11>}\n<line12>return 0;\n<line13>}
----------------------------------------
Function: selectExpander
Content: <line0>static int selectExpander(Walker *pWalker, Select *p){\n<line1>Parse *pParse = pWalker->pParse;\n<line2>int i, j, k, rc;\n<line3>SrcList *pTabList;\n<line4>ExprList *pEList;\n<line5>SrcItem *pFrom;\n<line6>sqlite3 *db = pParse->db;\n<line7>Expr *pE, *pRight, *pExpr;\n<line8>u16 selFlags = p->selFlags;\n<line9>u32 elistFlags = 0;\n<line10>p->selFlags |= SF_Expanded;\n<line11>if( db->mallocFailed  ){\n<line12>return WRC_Abort;\n<line13>}\n<line14>assert( p->pSrc!=0 );\n<line15>if( (selFlags & SF_Expanded)!=0 ){\n<line16>return WRC_Prune;\n<line17>}\n<line18>if( pWalker->eCode ){\n<line19>/* Renumber selId because it has been copied from a view */\n<line20>p->selId = ++pParse->nSelect;\n<line21>}\n<line22>pTabList = p->pSrc;\n<line23>pEList = p->pEList;\n<line24>if( pParse->pWith && (p->selFlags & SF_View) ){\n<line25>if( p->pWith==0 ){\n<line26>p->pWith = (With*)sqlite3DbMallocZero(db, SZ_WITH(1) );\n<line27>if( p->pWith==0 ){\n<line28>return WRC_Abort;\n<line29>}\n<line30>}\n<line31>p->pWith->bView = 1;\n<line32>}\n<line33>sqlite3WithPush(pParse, p->pWith, 0);\n<line34>/* Make sure cursor numbers have been assigned to all entries in\n<line35>** the FROM clause of the SELECT statement.\n<line36>*/\n<line37>sqlite3SrcListAssignCursors(pParse, pTabList);\n<line38>/* Look up every table named in the FROM clause of the select.  If\n<line39>** an entry of the FROM clause is a subquery instead of a table or view,\n<line40>** then create a transient table structure to describe the subquery.\n<line41>*/\n<line42>for(i=0, pFrom=pTabList->a; i<pTabList->nSrc; i++, pFrom++){\n<line43>Table *pTab;\n<line44>assert( pFrom->fg.isRecursive==0 || pFrom->pSTab!=0 );\n<line45>if( pFrom->pSTab ) continue;\n<line46>assert( pFrom->fg.isRecursive==0 );\n<line47>if( pFrom->zName==0 ){\n<line48>#ifndef SQLITE_OMIT_SUBQUERY\n<line49>Select *pSel;\n<line50>assert( pFrom->fg.isSubquery && pFrom->u4.pSubq!=0 );\n<line51>pSel = pFrom->u4.pSubq->pSelect;\n<line52>/* A sub-query in the FROM clause of a SELECT */\n<line53>assert( pSel!=0 );\n<line54>assert( pFrom->pSTab==0 );\n<line55>if( sqlite3WalkSelect(pWalker, pSel) ) return WRC_Abort;\n<line56>if( sqlite3ExpandSubquery(pParse, pFrom) ) return WRC_Abort;\n<line57>#endif\n<line58>#ifndef SQLITE_OMIT_CTE\n<line59>}else if( (rc = resolveFromTermToCte(pParse, pWalker, pFrom))!=0 ){\n<line60>if( rc>1 ) return WRC_Abort;\n<line61>pTab = pFrom->pSTab;\n<line62>assert( pTab!=0 );\n<line63>#endif\n<line64>}else{\n<line65>/* An ordinary table or view name in the FROM clause */\n<line66>assert( pFrom->pSTab==0 );\n<line67>pFrom->pSTab = pTab = sqlite3LocateTableItem(pParse, 0, pFrom);\n<line68>if( pTab==0 ) return WRC_Abort;\n<line69>if( pTab->nTabRef>=0xffff ){\n<line70>sqlite3ErrorMsg(pParse, "too many references to \"%s\": max 65535",\n<line71>pTab->zName);\n<line72>pFrom->pSTab = 0;\n<line73>return WRC_Abort;\n<line74>}\n<line75>pTab->nTabRef++;\n<line76>if( !IsVirtual(pTab) && cannotBeFunction(pParse, pFrom) ){\n<line77>return WRC_Abort;\n<line78>}\n<line79>#if !defined(SQLITE_OMIT_VIEW) || !defined(SQLITE_OMIT_VIRTUALTABLE)\n<line80>if( !IsOrdinaryTable(pTab) ){\n<line81>i16 nCol;\n<line82>u8 eCodeOrig = pWalker->eCode;\n<line83>if( sqlite3ViewGetColumnNames(pParse, pTab) ) return WRC_Abort;\n<line84>assert( pFrom->fg.isSubquery==0 );\n<line85>if( IsView(pTab) ){\n<line86>if( (db->flags & SQLITE_EnableView)==0\n<line87>&& pTab->pSchema!=db->aDb[1].pSchema\n<line88>){\n<line89>sqlite3ErrorMsg(pParse, "access to view \"%s\" prohibited",\n<line90>pTab->zName);\n<line91>}\n<line92>sqlite3SrcItemAttachSubquery(pParse, pFrom, pTab->u.view.pSelect, 1);\n<line93>}\n<line94>#ifndef SQLITE_OMIT_VIRTUALTABLE\n<line95>else if( ALWAYS(IsVirtual(pTab))\n<line96>&& pFrom->fg.fromDDL\n<line97>&& ALWAYS(pTab->u.vtab.p!=0)\n<line98>&& pTab->u.vtab.p->eVtabRisk > ((db->flags & SQLITE_TrustedSchema)!=0)\n<line99>){\n<line100>sqlite3ErrorMsg(pParse, "unsafe use of virtual table \"%s\"",\n<line101>pTab->zName);\n<line102>}\n<line103>assert( SQLITE_VTABRISK_Normal==1 && SQLITE_VTABRISK_High==2 );\n<line104>#endif\n<line105>nCol = pTab->nCol;\n<line106>pTab->nCol = -1;\n<line107>pWalker->eCode = 1;  /* Turn on Select.selId renumbering */\n<line108>if( pFrom->fg.isSubquery ){\n<line109>sqlite3WalkSelect(pWalker, pFrom->u4.pSubq->pSelect);\n<line110>}\n<line111>pWalker->eCode = eCodeOrig;\n<line112>pTab->nCol = nCol;\n<line113>}\n<line114>#endif\n<line115>}\n<line116>/* Locate the index named by the INDEXED BY clause, if any. */\n<line117>if( pFrom->fg.isIndexedBy && sqlite3IndexedByLookup(pParse, pFrom) ){\n<line118>return WRC_Abort;\n<line119>}\n<line120>}\n<line121>/* Process NATURAL keywords, and ON and USING clauses of joins.\n<line122>*/\n<line123>assert( db->mallocFailed==0 || pParse->nErr!=0 );\n<line124>if( pParse->nErr || sqlite3ProcessJoin(pParse, p) ){\n<line125>return WRC_Abort;\n<line126>}\n<line127>/* For every "*" that occurs in the column list, insert the names of\n<line128>** all columns in all tables.  And for every TABLE.* insert the names\n<line129>** of all columns in TABLE.  The parser inserted a special expression\n<line130>** with the TK_ASTERISK operator for each "*" that it found in the column\n<line131>** list.  The following code just has to locate the TK_ASTERISK\n<line132>** expressions and expand each one to the list of all columns in\n<line133>** all tables.\n<line134>**\n<line135>** The first loop just checks to see if there are any "*" operators\n<line136>** that need expanding.\n<line137>*/\n<line138>for(k=0; k<pEList->nExpr; k++){\n<line139>pE = pEList->a[k].pExpr;\n<line140>if( pE->op==TK_ASTERISK ) break;\n<line141>assert( pE->op!=TK_DOT || pE->pRight!=0 );\n<line142>assert( pE->op!=TK_DOT || (pE->pLeft!=0 && pE->pLeft->op==TK_ID) );\n<line143>if( pE->op==TK_DOT && pE->pRight->op==TK_ASTERISK ) break;\n<line144>elistFlags |= pE->flags;\n<line145>}\n<line146>if( k<pEList->nExpr ){\n<line147>/*\n<line148>** If we get here it means the result set contains one or more "*"\n<line149>** operators that need to be expanded.  Loop through each expression\n<line150>** in the result set and expand them one by one.\n<line151>*/\n<line152>struct ExprList_item *a = pEList->a;\n<line153>ExprList *pNew = 0;\n<line154>int flags = pParse->db->flags;\n<line155>int longNames = (flags & SQLITE_FullColNames)!=0\n<line156>&& (flags & SQLITE_ShortColNames)==0;\n<line157>for(k=0; k<pEList->nExpr; k++){\n<line158>pE = a[k].pExpr;\n<line159>elistFlags |= pE->flags;\n<line160>pRight = pE->pRight;\n<line161>assert( pE->op!=TK_DOT || pRight!=0 );\n<line162>if( pE->op!=TK_ASTERISK\n<line163>&& (pE->op!=TK_DOT || pRight->op!=TK_ASTERISK)\n<line164>){\n<line165>/* This particular expression does not need to be expanded.\n<line166>*/\n<line167>pNew = sqlite3ExprListAppend(pParse, pNew, a[k].pExpr);\n<line168>if( pNew ){\n<line169>pNew->a[pNew->nExpr-1].zEName = a[k].zEName;\n<line170>pNew->a[pNew->nExpr-1].fg.eEName = a[k].fg.eEName;\n<line171>a[k].zEName = 0;\n<line172>}\n<line173>a[k].pExpr = 0;\n<line174>}else{\n<line175>/* This expression is a "*" or a "TABLE.*" and needs to be\n<line176>** expanded. */\n<line177>int tableSeen = 0;      /* Set to 1 when TABLE matches */\n<line178>char *zTName = 0;       /* text of name of TABLE */\n<line179>int iErrOfst;\n<line180>if( pE->op==TK_DOT ){\n<line181>assert( (selFlags & SF_NestedFrom)==0 );\n<line182>assert( pE->pLeft!=0 );\n<line183>assert( !ExprHasProperty(pE->pLeft, EP_IntValue) );\n<line184>zTName = pE->pLeft->u.zToken;\n<line185>assert( ExprUseWOfst(pE->pLeft) );\n<line186>iErrOfst = pE->pRight->w.iOfst;\n<line187>}else{\n<line188>assert( ExprUseWOfst(pE) );\n<line189>iErrOfst = pE->w.iOfst;\n<line190>}\n<line191>for(i=0, pFrom=pTabList->a; i<pTabList->nSrc; i++, pFrom++){\n<line192>int nAdd;                    /* Number of cols including rowid */\n<line193>Table *pTab = pFrom->pSTab;  /* Table for this data source */\n<line194>ExprList *pNestedFrom;       /* Result-set of a nested FROM clause */\n<line195>char *zTabName;              /* AS name for this data source */\n<line196>const char *zSchemaName = 0; /* Schema name for this data source */\n<line197>int iDb;                     /* Schema index for this data src */\n<line198>IdList *pUsing;              /* USING clause for pFrom[1] */\n<line199>if( (zTabName = pFrom->zAlias)==0 ){\n<line200>zTabName = pTab->zName;\n<line201>}\n<line202>if( db->mallocFailed ) break;\n<line203>assert( (int)pFrom->fg.isNestedFrom == IsNestedFrom(pFrom) );\n<line204>if( pFrom->fg.isNestedFrom ){\n<line205>assert( pFrom->fg.isSubquery && pFrom->u4.pSubq );\n<line206>assert( pFrom->u4.pSubq->pSelect!=0 );\n<line207>pNestedFrom = pFrom->u4.pSubq->pSelect->pEList;\n<line208>assert( pNestedFrom!=0 );\n<line209>assert( pNestedFrom->nExpr==pTab->nCol );\n<line210>assert( VisibleRowid(pTab)==0 || ViewCanHaveRowid );\n<line211>}else{\n<line212>if( zTName && sqlite3StrICmp(zTName, zTabName)!=0 ){\n<line213>continue;\n<line214>}\n<line215>pNestedFrom = 0;\n<line216>iDb = sqlite3SchemaToIndex(db, pTab->pSchema);\n<line217>zSchemaName = iDb>=0 ? db->aDb[iDb].zDbSName : "*";\n<line218>}\n<line219>if( i+1<pTabList->nSrc\n<line220>&& pFrom[1].fg.isUsing\n<line221>&& (selFlags & SF_NestedFrom)!=0\n<line222>){\n<line223>int ii;\n<line224>pUsing = pFrom[1].u3.pUsing;\n<line225>for(ii=0; ii<pUsing->nId; ii++){\n<line226>const char *zUName = pUsing->a[ii].zName;\n<line227>pRight = sqlite3Expr(db, TK_ID, zUName);\n<line228>sqlite3ExprSetErrorOffset(pRight, iErrOfst);\n<line229>pNew = sqlite3ExprListAppend(pParse, pNew, pRight);\n<line230>if( pNew ){\n<line231>struct ExprList_item *pX = &pNew->a[pNew->nExpr-1];\n<line232>assert( pX->zEName==0 );\n<line233>pX->zEName = sqlite3MPrintf(db,"..%s", zUName);\n<line234>pX->fg.eEName = ENAME_TAB;\n<line235>pX->fg.bUsingTerm = 1;\n<line236>}\n<line237>}\n<line238>}else{\n<line239>pUsing = 0;\n<line240>}\n<line241>nAdd = pTab->nCol;\n<line242>if( VisibleRowid(pTab) && (selFlags & SF_NestedFrom)!=0 ) nAdd++;\n<line243>for(j=0; j<nAdd; j++){\n<line244>const char *zName;\n<line245>struct ExprList_item *pX; /* Newly added ExprList term */\n<line246>if( j==pTab->nCol ){\n<line247>zName = sqlite3RowidAlias(pTab);\n<line248>if( zName==0 ) continue;\n<line249>}else{\n<line250>zName = pTab->aCol[j].zCnName;\n<line251>/* If pTab is actually an SF_NestedFrom sub-select, do not\n<line252>** expand any ENAME_ROWID columns.  */\n<line253>if( pNestedFrom && pNestedFrom->a[j].fg.eEName==ENAME_ROWID ){\n<line254>continue;\n<line255>}\n<line256>if( zTName\n<line257>&& pNestedFrom\n<line258>&& sqlite3MatchEName(&pNestedFrom->a[j], 0, zTName, 0, 0)==0\n<line259>){\n<line260>continue;\n<line261>}\n<line262>/* If a column is marked as 'hidden', omit it from the expanded\n<line263>** result-set list unless the SELECT has the SF_IncludeHidden\n<line264>** bit set.\n<line265>*/\n<line266>if( (p->selFlags & SF_IncludeHidden)==0\n<line267>&& IsHiddenColumn(&pTab->aCol[j])\n<line268>){\n<line269>continue;\n<line270>}\n<line271>if( (pTab->aCol[j].colFlags & COLFLAG_NOEXPAND)!=0\n<line272>&& zTName==0\n<line273>&& (selFlags & (SF_NestedFrom))==0\n<line274>){\n<line275>continue;\n<line276>}\n<line277>}\n<line278>assert( zName );\n<line279>tableSeen = 1;\n<line280>if( i>0 && zTName==0 && (selFlags & SF_NestedFrom)==0 ){\n<line281>if( pFrom->fg.isUsing\n<line282>&& sqlite3IdListIndex(pFrom->u3.pUsing, zName)>=0\n<line283>){\n<line284>/* In a join with a USING clause, omit columns in the\n<line285>** using clause from the table on the right. */\n<line286>continue;\n<line287>}\n<line288>}\n<line289>pRight = sqlite3Expr(db, TK_ID, zName);\n<line290>if( (pTabList->nSrc>1\n<line291>&& (  (pFrom->fg.jointype & JT_LTORJ)==0\n<line292>|| (selFlags & SF_NestedFrom)!=0\n<line293>|| !inAnyUsingClause(zName,pFrom,pTabList->nSrc-i-1)\n<line294>)\n<line295>)\n<line296>|| IN_RENAME_OBJECT\n<line297>){\n<line298>Expr *pLeft;\n<line299>pLeft = sqlite3Expr(db, TK_ID, zTabName);\n<line300>pExpr = sqlite3PExpr(pParse, TK_DOT, pLeft, pRight);\n<line301>if( IN_RENAME_OBJECT && pE->pLeft ){\n<line302>sqlite3RenameTokenRemap(pParse, pLeft, pE->pLeft);\n<line303>}\n<line304>if( zSchemaName ){\n<line305>pLeft = sqlite3Expr(db, TK_ID, zSchemaName);\n<line306>pExpr = sqlite3PExpr(pParse, TK_DOT, pLeft, pExpr);\n<line307>}\n<line308>}else{\n<line309>pExpr = pRight;\n<line310>}\n<line311>sqlite3ExprSetErrorOffset(pExpr, iErrOfst);\n<line312>pNew = sqlite3ExprListAppend(pParse, pNew, pExpr);\n<line313>if( pNew==0 ){\n<line314>break;  /* OOM */\n<line315>}\n<line316>pX = &pNew->a[pNew->nExpr-1];\n<line317>assert( pX->zEName==0 );\n<line318>if( (selFlags & SF_NestedFrom)!=0 && !IN_RENAME_OBJECT ){\n<line319>if( pNestedFrom && (!ViewCanHaveRowid || j<pNestedFrom->nExpr) ){\n<line320>assert( j<pNestedFrom->nExpr );\n<line321>pX->zEName = sqlite3DbStrDup(db, pNestedFrom->a[j].zEName);\n<line322>testcase( pX->zEName==0 );\n<line323>}else{\n<line324>pX->zEName = sqlite3MPrintf(db, "%s.%s.%s",\n<line325>zSchemaName, zTabName, zName);\n<line326>testcase( pX->zEName==0 );\n<line327>}\n<line328>pX->fg.eEName = (j==pTab->nCol ? ENAME_ROWID : ENAME_TAB);\n<line329>if( (pFrom->fg.isUsing\n<line330>&& sqlite3IdListIndex(pFrom->u3.pUsing, zName)>=0)\n<line331>|| (pUsing && sqlite3IdListIndex(pUsing, zName)>=0)\n<line332>|| (j<pTab->nCol && (pTab->aCol[j].colFlags & COLFLAG_NOEXPAND))\n<line333>){\n<line334>pX->fg.bNoExpand = 1;\n<line335>}\n<line336>}else if( longNames ){\n<line337>pX->zEName = sqlite3MPrintf(db, "%s.%s", zTabName, zName);\n<line338>pX->fg.eEName = ENAME_NAME;\n<line339>}else{\n<line340>pX->zEName = sqlite3DbStrDup(db, zName);\n<line341>pX->fg.eEName = ENAME_NAME;\n<line342>}\n<line343>}\n<line344>}\n<line345>if( !tableSeen ){\n<line346>if( zTName ){\n<line347>sqlite3ErrorMsg(pParse, "no such table: %s", zTName);\n<line348>}else{\n<line349>sqlite3ErrorMsg(pParse, "no tables specified");\n<line350>}\n<line351>}\n<line352>}\n<line353>}\n<line354>sqlite3ExprListDelete(db, pEList);\n<line355>p->pEList = pNew;\n<line356>}\n<line357>if( p->pEList ){\n<line358>if( p->pEList->nExpr>db->aLimit[SQLITE_LIMIT_COLUMN] ){\n<line359>sqlite3ErrorMsg(pParse, "too many columns in result set");\n<line360>return WRC_Abort;\n<line361>}\n<line362>if( (elistFlags & (EP_HasFunc|EP_Subquery))!=0 ){\n<line363>p->selFlags |= SF_ComplexResult;\n<line364>}\n<line365>}\n<line366>#if TREETRACE_ENABLED\n<line367>if( sqlite3TreeTrace & 0x8 ){\n<line368>TREETRACE(0x8,pParse,p,("After result-set wildcard expansion:\n"));\n<line369>sqlite3TreeViewSelect(0, p, 0);\n<line370>}\n<line371>#endif\n<line372>return WRC_Continue;\n<line373>}
----------------------------------------
Function: sqlite3SelectExpand
Content: <line0>static void sqlite3SelectExpand(Parse *pParse, Select *pSelect){\n<line1>Walker w;\n<line2>w.xExprCallback = sqlite3ExprWalkNoop;\n<line3>w.pParse = pParse;\n<line4>if( OK_IF_ALWAYS_TRUE(pParse->hasCompound) ){\n<line5>w.xSelectCallback = convertCompoundSelectToSubquery;\n<line6>w.xSelectCallback2 = 0;\n<line7>sqlite3WalkSelect(&w, pSelect);\n<line8>}\n<line9>w.xSelectCallback = selectExpander;\n<line10>w.xSelectCallback2 = sqlite3SelectPopWith;\n<line11>w.eCode = 0;\n<line12>sqlite3WalkSelect(&w, pSelect);\n<line13>}
----------------------------------------
Function: selectAddSubqueryTypeInfo
Content: <line0>static void selectAddSubqueryTypeInfo(Walker *pWalker, Select *p){\n<line1>Parse *pParse;\n<line2>int i;\n<line3>SrcList *pTabList;\n<line4>SrcItem *pFrom;\n<line5>if( p->selFlags & SF_HasTypeInfo ) return;\n<line6>p->selFlags |= SF_HasTypeInfo;\n<line7>pParse = pWalker->pParse;\n<line8>assert( (p->selFlags & SF_Resolved) );\n<line9>pTabList = p->pSrc;\n<line10>for(i=0, pFrom=pTabList->a; i<pTabList->nSrc; i++, pFrom++){\n<line11>Table *pTab = pFrom->pSTab;\n<line12>assert( pTab!=0 );\n<line13>if( (pTab->tabFlags & TF_Ephemeral)!=0 && pFrom->fg.isSubquery ){\n<line14>/* A sub-query in the FROM clause of a SELECT */\n<line15>Select *pSel = pFrom->u4.pSubq->pSelect;\n<line16>sqlite3SubqueryColumnTypes(pParse, pTab, pSel, SQLITE_AFF_NONE);\n<line17>}\n<line18>}\n<line19>}
----------------------------------------
Function: sqlite3SelectAddTypeInfo
Content: <line0>static void sqlite3SelectAddTypeInfo(Parse *pParse, Select *pSelect){\n<line1>#ifndef SQLITE_OMIT_SUBQUERY\n<line2>Walker w;\n<line3>w.xSelectCallback = sqlite3SelectWalkNoop;\n<line4>w.xSelectCallback2 = selectAddSubqueryTypeInfo;\n<line5>w.xExprCallback = sqlite3ExprWalkNoop;\n<line6>w.pParse = pParse;\n<line7>sqlite3WalkSelect(&w, pSelect);\n<line8>#endif\n<line9>}
----------------------------------------
Function: analyzeAggFuncArgs
Content: <line0>static void analyzeAggFuncArgs(\n<line1>AggInfo *pAggInfo,\n<line2>NameContext *pNC\n<line3>){\n<line4>int i;\n<line5>assert( pAggInfo!=0 );\n<line6>assert( pAggInfo->iFirstReg==0 );\n<line7>pNC->ncFlags |= NC_InAggFunc;\n<line8>for(i=0; i<pAggInfo->nFunc; i++){\n<line9>Expr *pExpr = pAggInfo->aFunc[i].pFExpr;\n<line10>assert( pExpr->op==TK_FUNCTION || pExpr->op==TK_AGG_FUNCTION );\n<line11>assert( ExprUseXList(pExpr) );\n<line12>sqlite3ExprAnalyzeAggList(pNC, pExpr->x.pList);\n<line13>if( pExpr->pLeft ){\n<line14>assert( pExpr->pLeft->op==TK_ORDER );\n<line15>assert( ExprUseXList(pExpr->pLeft) );\n<line16>sqlite3ExprAnalyzeAggList(pNC, pExpr->pLeft->x.pList);\n<line17>}\n<line18>#ifndef SQLITE_OMIT_WINDOWFUNC\n<line19>assert( !IsWindowFunc(pExpr) );\n<line20>if( ExprHasProperty(pExpr, EP_WinFunc) ){\n<line21>sqlite3ExprAnalyzeAggregates(pNC, pExpr->y.pWin->pFilter);\n<line22>}\n<line23>#endif\n<line24>}\n<line25>pNC->ncFlags &= ~NC_InAggFunc;\n<line26>}
----------------------------------------
Function: optimizeAggregateUseOfIndexedExpr
Content: <line0>static void optimizeAggregateUseOfIndexedExpr(\n<line1>Parse *pParse,          /* Parsing context */\n<line2>Select *pSelect,        /* The SELECT statement being processed */\n<line3>AggInfo *pAggInfo,      /* The aggregate info */\n<line4>NameContext *pNC        /* Name context used to resolve agg-func args */\n<line5>){\n<line6>assert( pAggInfo->iFirstReg==0 );\n<line7>assert( pSelect!=0 );\n<line8>assert( pSelect->pGroupBy!=0 );\n<line9>pAggInfo->nColumn = pAggInfo->nAccumulator;\n<line10>if( ALWAYS(pAggInfo->nSortingColumn>0) ){\n<line11>int mx = pSelect->pGroupBy->nExpr - 1;\n<line12>int j, k;\n<line13>for(j=0; j<pAggInfo->nColumn; j++){\n<line14>k = pAggInfo->aCol[j].iSorterColumn;\n<line15>if( k>mx ) mx = k;\n<line16>}\n<line17>pAggInfo->nSortingColumn = mx+1;\n<line18>}\n<line19>analyzeAggFuncArgs(pAggInfo, pNC);\n<line20>#if TREETRACE_ENABLED\n<line21>if( sqlite3TreeTrace & 0x20 ){\n<line22>IndexedExpr *pIEpr;\n<line23>TREETRACE(0x20, pParse, pSelect,\n<line24>("AggInfo (possibly) adjusted for Indexed Exprs\n"));\n<line25>sqlite3TreeViewSelect(0, pSelect, 0);\n<line26>for(pIEpr=pParse->pIdxEpr; pIEpr; pIEpr=pIEpr->pIENext){\n<line27>printf("data-cursor=%d index={%d,%d}\n",\n<line28>pIEpr->iDataCur, pIEpr->iIdxCur, pIEpr->iIdxCol);\n<line29>sqlite3TreeViewExpr(0, pIEpr->pExpr, 0);\n<line30>}\n<line31>printAggInfo(pAggInfo);\n<line32>}\n<line33>#else\n<line34>UNUSED_PARAMETER(pSelect);\n<line35>UNUSED_PARAMETER(pParse);\n<line36>#endif\n<line37>}
----------------------------------------
Function: aggregateIdxEprRefToColCallback
Content: <line0>static int aggregateIdxEprRefToColCallback(Walker *pWalker, Expr *pExpr){\n<line1>AggInfo *pAggInfo;\n<line2>struct AggInfo_col *pCol;\n<line3>UNUSED_PARAMETER(pWalker);\n<line4>if( pExpr->pAggInfo==0 ) return WRC_Continue;\n<line5>if( pExpr->op==TK_AGG_COLUMN ) return WRC_Continue;\n<line6>if( pExpr->op==TK_AGG_FUNCTION ) return WRC_Continue;\n<line7>if( pExpr->op==TK_IF_NULL_ROW ) return WRC_Continue;\n<line8>pAggInfo = pExpr->pAggInfo;\n<line9>if( NEVER(pExpr->iAgg>=pAggInfo->nColumn) ) return WRC_Continue;\n<line10>assert( pExpr->iAgg>=0 );\n<line11>pCol = &pAggInfo->aCol[pExpr->iAgg];\n<line12>pExpr->op = TK_AGG_COLUMN;\n<line13>pExpr->iTable = pCol->iTable;\n<line14>pExpr->iColumn = pCol->iColumn;\n<line15>ExprClearProperty(pExpr, EP_Skip|EP_Collate|EP_Unlikely);\n<line16>return WRC_Prune;\n<line17>}
----------------------------------------
Function: aggregateConvertIndexedExprRefToColumn
Content: <line0>static void aggregateConvertIndexedExprRefToColumn(AggInfo *pAggInfo){\n<line1>int i;\n<line2>Walker w;\n<line3>memset(&w, 0, sizeof(w));\n<line4>w.xExprCallback = aggregateIdxEprRefToColCallback;\n<line5>for(i=0; i<pAggInfo->nFunc; i++){\n<line6>sqlite3WalkExpr(&w, pAggInfo->aFunc[i].pFExpr);\n<line7>}\n<line8>}
----------------------------------------
Function: assignAggregateRegisters
Content: <line0>static void assignAggregateRegisters(Parse *pParse, AggInfo *pAggInfo){\n<line1>assert( pAggInfo!=0 );\n<line2>assert( pAggInfo->iFirstReg==0 );\n<line3>pAggInfo->iFirstReg = pParse->nMem + 1;\n<line4>pParse->nMem += pAggInfo->nColumn + pAggInfo->nFunc;\n<line5>}
----------------------------------------
Function: resetAccumulator
Content: <line0>static void resetAccumulator(Parse *pParse, AggInfo *pAggInfo){\n<line1>Vdbe *v = pParse->pVdbe;\n<line2>int i;\n<line3>struct AggInfo_func *pFunc;\n<line4>int nReg = pAggInfo->nFunc + pAggInfo->nColumn;\n<line5>assert( pAggInfo->iFirstReg>0 );\n<line6>assert( pParse->db->pParse==pParse );\n<line7>assert( pParse->db->mallocFailed==0 || pParse->nErr!=0 );\n<line8>if( nReg==0 ) return;\n<line9>if( pParse->nErr ) return;\n<line10>sqlite3VdbeAddOp3(v, OP_Null, 0, pAggInfo->iFirstReg,\n<line11>pAggInfo->iFirstReg+nReg-1);\n<line12>for(pFunc=pAggInfo->aFunc, i=0; i<pAggInfo->nFunc; i++, pFunc++){\n<line13>if( pFunc->iDistinct>=0 ){\n<line14>Expr *pE = pFunc->pFExpr;\n<line15>assert( ExprUseXList(pE) );\n<line16>if( pE->x.pList==0 || pE->x.pList->nExpr!=1 ){\n<line17>sqlite3ErrorMsg(pParse, "DISTINCT aggregates must have exactly one "\n<line18>"argument");\n<line19>pFunc->iDistinct = -1;\n<line20>}else{\n<line21>KeyInfo *pKeyInfo = sqlite3KeyInfoFromExprList(pParse, pE->x.pList,0,0);\n<line22>pFunc->iDistAddr = sqlite3VdbeAddOp4(v, OP_OpenEphemeral,\n<line23>pFunc->iDistinct, 0, 0, (char*)pKeyInfo, P4_KEYINFO);\n<line24>ExplainQueryPlan((pParse, 0, "USE TEMP B-TREE FOR %s(DISTINCT)",\n<line25>pFunc->pFunc->zName));\n<line26>}\n<line27>}\n<line28>if( pFunc->iOBTab>=0 ){\n<line29>ExprList *pOBList;\n<line30>KeyInfo *pKeyInfo;\n<line31>int nExtra = 0;\n<line32>assert( pFunc->pFExpr->pLeft!=0 );\n<line33>assert( pFunc->pFExpr->pLeft->op==TK_ORDER );\n<line34>assert( ExprUseXList(pFunc->pFExpr->pLeft) );\n<line35>assert( pFunc->pFunc!=0 );\n<line36>pOBList = pFunc->pFExpr->pLeft->x.pList;\n<line37>if( !pFunc->bOBUnique ){\n<line38>nExtra++;  /* One extra column for the OP_Sequence */\n<line39>}\n<line40>if( pFunc->bOBPayload ){\n<line41>/* extra columns for the function arguments */\n<line42>assert( ExprUseXList(pFunc->pFExpr) );\n<line43>assert( pFunc->pFExpr->x.pList!=0 );\n<line44>nExtra += pFunc->pFExpr->x.pList->nExpr;\n<line45>}\n<line46>if( pFunc->bUseSubtype ){\n<line47>nExtra += pFunc->pFExpr->x.pList->nExpr;\n<line48>}\n<line49>pKeyInfo = sqlite3KeyInfoFromExprList(pParse, pOBList, 0, nExtra);\n<line50>if( !pFunc->bOBUnique && pParse->nErr==0 ){\n<line51>pKeyInfo->nKeyField++;\n<line52>}\n<line53>sqlite3VdbeAddOp4(v, OP_OpenEphemeral,\n<line54>pFunc->iOBTab, pOBList->nExpr+nExtra, 0,\n<line55>(char*)pKeyInfo, P4_KEYINFO);\n<line56>ExplainQueryPlan((pParse, 0, "USE TEMP B-TREE FOR %s(ORDER BY)",\n<line57>pFunc->pFunc->zName));\n<line58>}\n<line59>}\n<line60>}
----------------------------------------
Function: finalizeAggFunctions
Content: <line0>static void finalizeAggFunctions(Parse *pParse, AggInfo *pAggInfo){\n<line1>Vdbe *v = pParse->pVdbe;\n<line2>int i;\n<line3>struct AggInfo_func *pF;\n<line4>for(i=0, pF=pAggInfo->aFunc; i<pAggInfo->nFunc; i++, pF++){\n<line5>ExprList *pList;\n<line6>assert( ExprUseXList(pF->pFExpr) );\n<line7>if( pParse->nErr ) return;\n<line8>pList = pF->pFExpr->x.pList;\n<line9>if( pF->iOBTab>=0 ){\n<line10>/* For an ORDER BY aggregate, calls to OP_AggStep were deferred.  Inputs\n<line11>** were stored in emphermal table pF->iOBTab.  Here, we extract those\n<line12>** inputs (in ORDER BY order) and make all calls to OP_AggStep\n<line13>** before doing the OP_AggFinal call. */\n<line14>int iTop;        /* Start of loop for extracting columns */\n<line15>int nArg;        /* Number of columns to extract */\n<line16>int nKey;        /* Key columns to be skipped */\n<line17>int regAgg;      /* Extract into this array */\n<line18>int j;           /* Loop counter */\n<line19>assert( pF->pFunc!=0 );\n<line20>nArg = pList->nExpr;\n<line21>regAgg = sqlite3GetTempRange(pParse, nArg);\n<line22>if( pF->bOBPayload==0 ){\n<line23>nKey = 0;\n<line24>}else{\n<line25>assert( pF->pFExpr->pLeft!=0 );\n<line26>assert( ExprUseXList(pF->pFExpr->pLeft) );\n<line27>assert( pF->pFExpr->pLeft->x.pList!=0 );\n<line28>nKey = pF->pFExpr->pLeft->x.pList->nExpr;\n<line29>if( ALWAYS(!pF->bOBUnique) ) nKey++;\n<line30>}\n<line31>iTop = sqlite3VdbeAddOp1(v, OP_Rewind, pF->iOBTab); VdbeCoverage(v);\n<line32>for(j=nArg-1; j>=0; j--){\n<line33>sqlite3VdbeAddOp3(v, OP_Column, pF->iOBTab, nKey+j, regAgg+j);\n<line34>}\n<line35>if( pF->bUseSubtype ){\n<line36>int regSubtype = sqlite3GetTempReg(pParse);\n<line37>int iBaseCol = nKey + nArg + (pF->bOBPayload==0 && pF->bOBUnique==0);\n<line38>for(j=nArg-1; j>=0; j--){\n<line39>sqlite3VdbeAddOp3(v, OP_Column, pF->iOBTab, iBaseCol+j, regSubtype);\n<line40>sqlite3VdbeAddOp2(v, OP_SetSubtype, regSubtype, regAgg+j);\n<line41>}\n<line42>sqlite3ReleaseTempReg(pParse, regSubtype);\n<line43>}\n<line44>sqlite3VdbeAddOp3(v, OP_AggStep, 0, regAgg, AggInfoFuncReg(pAggInfo,i));\n<line45>sqlite3VdbeAppendP4(v, pF->pFunc, P4_FUNCDEF);\n<line46>sqlite3VdbeChangeP5(v, (u16)nArg);\n<line47>sqlite3VdbeAddOp2(v, OP_Next, pF->iOBTab, iTop+1); VdbeCoverage(v);\n<line48>sqlite3VdbeJumpHere(v, iTop);\n<line49>sqlite3ReleaseTempRange(pParse, regAgg, nArg);\n<line50>}\n<line51>sqlite3VdbeAddOp2(v, OP_AggFinal, AggInfoFuncReg(pAggInfo,i),\n<line52>pList ? pList->nExpr : 0);\n<line53>sqlite3VdbeAppendP4(v, pF->pFunc, P4_FUNCDEF);\n<line54>}\n<line55>}
----------------------------------------
Function: updateAccumulator
Content: <line0>static void updateAccumulator(\n<line1>Parse *pParse,\n<line2>int regAcc,\n<line3>AggInfo *pAggInfo,\n<line4>int eDistinctType\n<line5>){\n<line6>Vdbe *v = pParse->pVdbe;\n<line7>int i;\n<line8>int regHit = 0;\n<line9>int addrHitTest = 0;\n<line10>struct AggInfo_func *pF;\n<line11>struct AggInfo_col *pC;\n<line12>assert( pAggInfo->iFirstReg>0 );\n<line13>if( pParse->nErr ) return;\n<line14>pAggInfo->directMode = 1;\n<line15>for(i=0, pF=pAggInfo->aFunc; i<pAggInfo->nFunc; i++, pF++){\n<line16>int nArg;\n<line17>int addrNext = 0;\n<line18>int regAgg;\n<line19>int regAggSz = 0;\n<line20>int regDistinct = 0;\n<line21>ExprList *pList;\n<line22>assert( ExprUseXList(pF->pFExpr) );\n<line23>assert( !IsWindowFunc(pF->pFExpr) );\n<line24>assert( pF->pFunc!=0 );\n<line25>pList = pF->pFExpr->x.pList;\n<line26>if( ExprHasProperty(pF->pFExpr, EP_WinFunc) ){\n<line27>Expr *pFilter = pF->pFExpr->y.pWin->pFilter;\n<line28>if( pAggInfo->nAccumulator\n<line29>&& (pF->pFunc->funcFlags & SQLITE_FUNC_NEEDCOLL)\n<line30>&& regAcc\n<line31>){\n<line32>/* If regAcc==0, there there exists some min() or max() function\n<line33>** without a FILTER clause that will ensure the magnet registers\n<line34>** are populated. */\n<line35>if( regHit==0 ) regHit = ++pParse->nMem;\n<line36>/* If this is the first row of the group (regAcc contains 0), clear the\n<line37>** "magnet" register regHit so that the accumulator registers\n<line38>** are populated if the FILTER clause jumps over the the\n<line39>** invocation of min() or max() altogether. Or, if this is not\n<line40>** the first row (regAcc contains 1), set the magnet register so that\n<line41>** the accumulators are not populated unless the min()/max() is invoked\n<line42>** and indicates that they should be.  */\n<line43>sqlite3VdbeAddOp2(v, OP_Copy, regAcc, regHit);\n<line44>}\n<line45>addrNext = sqlite3VdbeMakeLabel(pParse);\n<line46>sqlite3ExprIfFalse(pParse, pFilter, addrNext, SQLITE_JUMPIFNULL);\n<line47>}\n<line48>if( pF->iOBTab>=0 ){\n<line49>/* Instead of invoking AggStep, we must push the arguments that would\n<line50>** have been passed to AggStep onto the sorting table. */\n<line51>int jj;                /* Registered used so far in building the record */\n<line52>ExprList *pOBList;     /* The ORDER BY clause */\n<line53>assert( pList!=0 );\n<line54>nArg = pList->nExpr;\n<line55>assert( nArg>0 );\n<line56>assert( pF->pFExpr->pLeft!=0 );\n<line57>assert( pF->pFExpr->pLeft->op==TK_ORDER );\n<line58>assert( ExprUseXList(pF->pFExpr->pLeft) );\n<line59>pOBList = pF->pFExpr->pLeft->x.pList;\n<line60>assert( pOBList!=0 );\n<line61>assert( pOBList->nExpr>0 );\n<line62>regAggSz = pOBList->nExpr;\n<line63>if( !pF->bOBUnique ){\n<line64>regAggSz++;   /* One register for OP_Sequence */\n<line65>}\n<line66>if( pF->bOBPayload ){\n<line67>regAggSz += nArg;\n<line68>}\n<line69>if( pF->bUseSubtype ){\n<line70>regAggSz += nArg;\n<line71>}\n<line72>regAggSz++;  /* One extra register to hold result of MakeRecord */\n<line73>regAgg = sqlite3GetTempRange(pParse, regAggSz);\n<line74>regDistinct = regAgg;\n<line75>sqlite3ExprCodeExprList(pParse, pOBList, regAgg, 0, SQLITE_ECEL_DUP);\n<line76>jj = pOBList->nExpr;\n<line77>if( !pF->bOBUnique ){\n<line78>sqlite3VdbeAddOp2(v, OP_Sequence, pF->iOBTab, regAgg+jj);\n<line79>jj++;\n<line80>}\n<line81>if( pF->bOBPayload ){\n<line82>regDistinct = regAgg+jj;\n<line83>sqlite3ExprCodeExprList(pParse, pList, regDistinct, 0, SQLITE_ECEL_DUP);\n<line84>jj += nArg;\n<line85>}\n<line86>if( pF->bUseSubtype ){\n<line87>int kk;\n<line88>int regBase = pF->bOBPayload ? regDistinct : regAgg;\n<line89>for(kk=0; kk<nArg; kk++, jj++){\n<line90>sqlite3VdbeAddOp2(v, OP_GetSubtype, regBase+kk, regAgg+jj);\n<line91>}\n<line92>}\n<line93>}else if( pList ){\n<line94>nArg = pList->nExpr;\n<line95>regAgg = sqlite3GetTempRange(pParse, nArg);\n<line96>regDistinct = regAgg;\n<line97>sqlite3ExprCodeExprList(pParse, pList, regAgg, 0, SQLITE_ECEL_DUP);\n<line98>}else{\n<line99>nArg = 0;\n<line100>regAgg = 0;\n<line101>}\n<line102>if( pF->iDistinct>=0 && pList ){\n<line103>if( addrNext==0 ){\n<line104>addrNext = sqlite3VdbeMakeLabel(pParse);\n<line105>}\n<line106>pF->iDistinct = codeDistinct(pParse, eDistinctType,\n<line107>pF->iDistinct, addrNext, pList, regDistinct);\n<line108>}\n<line109>if( pF->iOBTab>=0 ){\n<line110>/* Insert a new record into the ORDER BY table */\n<line111>sqlite3VdbeAddOp3(v, OP_MakeRecord, regAgg, regAggSz-1,\n<line112>regAgg+regAggSz-1);\n<line113>sqlite3VdbeAddOp4Int(v, OP_IdxInsert, pF->iOBTab, regAgg+regAggSz-1,\n<line114>regAgg, regAggSz-1);\n<line115>sqlite3ReleaseTempRange(pParse, regAgg, regAggSz);\n<line116>}else{\n<line117>/* Invoke the AggStep function */\n<line118>if( pF->pFunc->funcFlags & SQLITE_FUNC_NEEDCOLL ){\n<line119>CollSeq *pColl = 0;\n<line120>struct ExprList_item *pItem;\n<line121>int j;\n<line122>assert( pList!=0 );  /* pList!=0 if pF->pFunc has NEEDCOLL */\n<line123>for(j=0, pItem=pList->a; !pColl && j<nArg; j++, pItem++){\n<line124>pColl = sqlite3ExprCollSeq(pParse, pItem->pExpr);\n<line125>}\n<line126>if( !pColl ){\n<line127>pColl = pParse->db->pDfltColl;\n<line128>}\n<line129>if( regHit==0 && pAggInfo->nAccumulator ) regHit = ++pParse->nMem;\n<line130>sqlite3VdbeAddOp4(v, OP_CollSeq, regHit, 0, 0,\n<line131>(char *)pColl, P4_COLLSEQ);\n<line132>}\n<line133>sqlite3VdbeAddOp3(v, OP_AggStep, 0, regAgg, AggInfoFuncReg(pAggInfo,i));\n<line134>sqlite3VdbeAppendP4(v, pF->pFunc, P4_FUNCDEF);\n<line135>sqlite3VdbeChangeP5(v, (u16)nArg);\n<line136>sqlite3ReleaseTempRange(pParse, regAgg, nArg);\n<line137>}\n<line138>if( addrNext ){\n<line139>sqlite3VdbeResolveLabel(v, addrNext);\n<line140>}\n<line141>if( pParse->nErr ) return;\n<line142>}\n<line143>if( regHit==0 && pAggInfo->nAccumulator ){\n<line144>regHit = regAcc;\n<line145>}\n<line146>if( regHit ){\n<line147>addrHitTest = sqlite3VdbeAddOp1(v, OP_If, regHit); VdbeCoverage(v);\n<line148>}\n<line149>for(i=0, pC=pAggInfo->aCol; i<pAggInfo->nAccumulator; i++, pC++){\n<line150>sqlite3ExprCode(pParse, pC->pCExpr, AggInfoColumnReg(pAggInfo,i));\n<line151>if( pParse->nErr ) return;\n<line152>}\n<line153>pAggInfo->directMode = 0;\n<line154>if( addrHitTest ){\n<line155>sqlite3VdbeJumpHereOrPopInst(v, addrHitTest);\n<line156>}\n<line157>}
----------------------------------------
Function: explainSimpleCount
Content: <line0>static void explainSimpleCount(\n<line1>Parse *pParse,                  /* Parse context */\n<line2>Table *pTab,                    /* Table being queried */\n<line3>Index *pIdx                     /* Index used to optimize scan, or NULL */\n<line4>){\n<line5>if( pParse->explain==2 ){\n<line6>int bCover = (pIdx!=0 && (HasRowid(pTab) || !IsPrimaryKeyIndex(pIdx)));\n<line7>sqlite3VdbeExplain(pParse, 0, "SCAN %s%s%s",\n<line8>pTab->zName,\n<line9>bCover ? " USING COVERING INDEX " : "",\n<line10>bCover ? pIdx->zName : ""\n<line11>);\n<line12>}\n<line13>}
----------------------------------------
Function: havingToWhereExprCb
Content: <line0>static int havingToWhereExprCb(Walker *pWalker, Expr *pExpr){\n<line1>if( pExpr->op!=TK_AND ){\n<line2>Select *pS = pWalker->u.pSelect;\n<line3>/* This routine is called before the HAVING clause of the current\n<line4>** SELECT is analyzed for aggregates. So if pExpr->pAggInfo is set\n<line5>** here, it indicates that the expression is a correlated reference to a\n<line6>** column from an outer aggregate query, or an aggregate function that\n<line7>** belongs to an outer query. Do not move the expression to the WHERE\n<line8>** clause in this obscure case, as doing so may corrupt the outer Select\n<line9>** statements AggInfo structure.  */\n<line10>if( sqlite3ExprIsConstantOrGroupBy(pWalker->pParse, pExpr, pS->pGroupBy)\n<line11>&& ExprAlwaysFalse(pExpr)==0\n<line12>&& pExpr->pAggInfo==0\n<line13>){\n<line14>sqlite3 *db = pWalker->pParse->db;\n<line15>Expr *pNew = sqlite3Expr(db, TK_INTEGER, "1");\n<line16>if( pNew ){\n<line17>Expr *pWhere = pS->pWhere;\n<line18>SWAP(Expr, *pNew, *pExpr);\n<line19>pNew = sqlite3ExprAnd(pWalker->pParse, pWhere, pNew);\n<line20>pS->pWhere = pNew;\n<line21>pWalker->eCode = 1;\n<line22>}\n<line23>}\n<line24>return WRC_Prune;\n<line25>}\n<line26>return WRC_Continue;\n<line27>}
----------------------------------------
Function: havingToWhere
Content: <line0>static void havingToWhere(Parse *pParse, Select *p){\n<line1>Walker sWalker;\n<line2>memset(&sWalker, 0, sizeof(sWalker));\n<line3>sWalker.pParse = pParse;\n<line4>sWalker.xExprCallback = havingToWhereExprCb;\n<line5>sWalker.u.pSelect = p;\n<line6>sqlite3WalkExpr(&sWalker, p->pHaving);\n<line7>#if TREETRACE_ENABLED\n<line8>if( sWalker.eCode && (sqlite3TreeTrace & 0x100)!=0 ){\n<line9>TREETRACE(0x100,pParse,p,("Move HAVING terms into WHERE:\n"));\n<line10>sqlite3TreeViewSelect(0, p, 0);\n<line11>}\n<line12>#endif\n<line13>}
----------------------------------------
Function: isSelfJoinView
Content: <line0>static SrcItem *isSelfJoinView(\n<line1>SrcList *pTabList,           /* Search for self-joins in this FROM clause */\n<line2>SrcItem *pThis,              /* Search for prior reference to this subquery */\n<line3>int iFirst, int iEnd        /* Range of FROM-clause entries to search. */\n<line4>){\n<line5>SrcItem *pItem;\n<line6>Select *pSel;\n<line7>assert( pThis->fg.isSubquery );\n<line8>pSel = pThis->u4.pSubq->pSelect;\n<line9>assert( pSel!=0 );\n<line10>if( pSel->selFlags & SF_PushDown ) return 0;\n<line11>while( iFirst<iEnd ){\n<line12>Select *pS1;\n<line13>pItem = &pTabList->a[iFirst++];\n<line14>if( !pItem->fg.isSubquery ) continue;\n<line15>if( pItem->fg.viaCoroutine ) continue;\n<line16>if( pItem->zName==0 ) continue;\n<line17>assert( pItem->pSTab!=0 );\n<line18>assert( pThis->pSTab!=0 );\n<line19>if( pItem->pSTab->pSchema!=pThis->pSTab->pSchema ) continue;\n<line20>if( sqlite3_stricmp(pItem->zName, pThis->zName)!=0 ) continue;\n<line21>pS1 = pItem->u4.pSubq->pSelect;\n<line22>if( pItem->pSTab->pSchema==0 && pSel->selId!=pS1->selId ){\n<line23>/* The query flattener left two different CTE tables with identical\n<line24>** names in the same FROM clause. */\n<line25>continue;\n<line26>}\n<line27>if( pS1->selFlags & SF_PushDown ){\n<line28>/* The view was modified by some other optimization such as\n<line29>** pushDownWhereTerms() */\n<line30>continue;\n<line31>}\n<line32>return pItem;\n<line33>}\n<line34>return 0;\n<line35>}
----------------------------------------
Function: agginfoFree
Content: <line0>static void agginfoFree(sqlite3 *db, void *pArg){\n<line1>AggInfo *p = (AggInfo*)pArg;\n<line2>sqlite3DbFree(db, p->aCol);\n<line3>sqlite3DbFree(db, p->aFunc);\n<line4>sqlite3DbFreeNN(db, p);\n<line5>}
----------------------------------------
Function: countOfViewOptimization
Content: <line0>static int countOfViewOptimization(Parse *pParse, Select *p){\n<line1>Select *pSub, *pPrior;\n<line2>Expr *pExpr;\n<line3>Expr *pCount;\n<line4>sqlite3 *db;\n<line5>SrcItem *pFrom;\n<line6>if( (p->selFlags & SF_Aggregate)==0 ) return 0;   /* This is an aggregate */\n<line7>if( p->pEList->nExpr!=1 ) return 0;               /* Single result column */\n<line8>if( p->pWhere ) return 0;\n<line9>if( p->pHaving ) return 0;\n<line10>if( p->pGroupBy ) return 0;\n<line11>if( p->pOrderBy ) return 0;\n<line12>pExpr = p->pEList->a[0].pExpr;\n<line13>if( pExpr->op!=TK_AGG_FUNCTION ) return 0;        /* Result is an aggregate */\n<line14>assert( ExprUseUToken(pExpr) );\n<line15>if( sqlite3_stricmp(pExpr->u.zToken,"count") ) return 0;  /* Is count() */\n<line16>assert( ExprUseXList(pExpr) );\n<line17>if( pExpr->x.pList!=0 ) return 0;                 /* Must be count(*) */\n<line18>if( p->pSrc->nSrc!=1 ) return 0;                  /* One table in FROM  */\n<line19>if( ExprHasProperty(pExpr, EP_WinFunc) ) return 0;/* Not a window function */\n<line20>pFrom = p->pSrc->a;\n<line21>if( pFrom->fg.isSubquery==0 ) return 0;    /* FROM is a subquery */\n<line22>pSub = pFrom->u4.pSubq->pSelect;\n<line23>if( pSub->pPrior==0 ) return 0;                   /* Must be a compound */\n<line24>if( pSub->selFlags & SF_CopyCte ) return 0;       /* Not a CTE */\n<line25>do{\n<line26>if( pSub->op!=TK_ALL && pSub->pPrior ) return 0;  /* Must be UNION ALL */\n<line27>if( pSub->pWhere ) return 0;                      /* No WHERE clause */\n<line28>if( pSub->pLimit ) return 0;                      /* No LIMIT clause */\n<line29>if( pSub->selFlags & (SF_Aggregate|SF_Distinct) ){\n<line30>testcase( pSub->selFlags & SF_Aggregate );\n<line31>testcase( pSub->selFlags & SF_Distinct );\n<line32>return 0;     /* Not an aggregate nor DISTINCT */\n<line33>}\n<line34>assert( pSub->pHaving==0 );  /* Due to the previous */\n<line35>pSub = pSub->pPrior;                              /* Repeat over compound */\n<line36>}while( pSub );\n<line37>/* If we reach this point then it is OK to perform the transformation */\n<line38>db = pParse->db;\n<line39>pCount = pExpr;\n<line40>pExpr = 0;\n<line41>pSub = sqlite3SubqueryDetach(db, pFrom);\n<line42>sqlite3SrcListDelete(db, p->pSrc);\n<line43>p->pSrc = sqlite3DbMallocZero(pParse->db, SZ_SRCLIST_1);\n<line44>while( pSub ){\n<line45>Expr *pTerm;\n<line46>pPrior = pSub->pPrior;\n<line47>pSub->pPrior = 0;\n<line48>pSub->pNext = 0;\n<line49>pSub->selFlags |= SF_Aggregate;\n<line50>pSub->selFlags &= ~(u32)SF_Compound;\n<line51>pSub->nSelectRow = 0;\n<line52>sqlite3ParserAddCleanup(pParse, sqlite3ExprListDeleteGeneric, pSub->pEList);\n<line53>pTerm = pPrior ? sqlite3ExprDup(db, pCount, 0) : pCount;\n<line54>pSub->pEList = sqlite3ExprListAppend(pParse, 0, pTerm);\n<line55>pTerm = sqlite3PExpr(pParse, TK_SELECT, 0, 0);\n<line56>sqlite3PExprAddSelect(pParse, pTerm, pSub);\n<line57>if( pExpr==0 ){\n<line58>pExpr = pTerm;\n<line59>}else{\n<line60>pExpr = sqlite3PExpr(pParse, TK_PLUS, pTerm, pExpr);\n<line61>}\n<line62>pSub = pPrior;\n<line63>}\n<line64>p->pEList->a[0].pExpr = pExpr;\n<line65>p->selFlags &= ~(u32)SF_Aggregate;\n<line66>#if TREETRACE_ENABLED\n<line67>if( sqlite3TreeTrace & 0x200 ){\n<line68>TREETRACE(0x200,pParse,p,("After count-of-view optimization:\n"));\n<line69>sqlite3TreeViewSelect(0, p, 0);\n<line70>}\n<line71>#endif\n<line72>return 1;\n<line73>}
----------------------------------------
Function: sameSrcAlias
Content: <line0>static int sameSrcAlias(SrcItem *p0, SrcList *pSrc){\n<line1>int i;\n<line2>for(i=0; i<pSrc->nSrc; i++){\n<line3>SrcItem *p1 = &pSrc->a[i];\n<line4>if( p1==p0 ) continue;\n<line5>if( p0->pSTab==p1->pSTab && 0==sqlite3_stricmp(p0->zAlias, p1->zAlias) ){\n<line6>return 1;\n<line7>}\n<line8>if( p1->fg.isSubquery\n<line9>&& (p1->u4.pSubq->pSelect->selFlags & SF_NestedFrom)!=0\n<line10>&& sameSrcAlias(p0, p1->u4.pSubq->pSelect->pSrc)\n<line11>){\n<line12>return 1;\n<line13>}\n<line14>}\n<line15>return 0;\n<line16>}
----------------------------------------
Function: fromClauseTermCanBeCoroutine
Content: <line0>static int fromClauseTermCanBeCoroutine(\n<line1>Parse *pParse,          /* Parsing context */\n<line2>SrcList *pTabList,      /* FROM clause */\n<line3>int i,                  /* Which term of the FROM clause holds the subquery */\n<line4>int selFlags            /* Flags on the SELECT statement */\n<line5>){\n<line6>SrcItem *pItem = &pTabList->a[i];\n<line7>if( pItem->fg.isCte ){\n<line8>const CteUse *pCteUse = pItem->u2.pCteUse;\n<line9>if( pCteUse->eM10d==M10d_Yes ) return 0;                          /* (2a) */\n<line10>if( pCteUse->nUse>=2 && pCteUse->eM10d!=M10d_No ) return 0;       /* (2b) */\n<line11>}\n<line12>if( pTabList->a[0].fg.jointype & JT_LTORJ ) return 0;               /* (3)  */\n<line13>if( OptimizationDisabled(pParse->db, SQLITE_Coroutines) ) return 0; /* (4)  */\n<line14>if( isSelfJoinView(pTabList, pItem, i+1, pTabList->nSrc)!=0 ){\n<line15>return 0;                                                          /* (5) */\n<line16>}\n<line17>if( i==0 ){\n<line18>if( pTabList->nSrc==1 ) return 1;                             /* (1a) */\n<line19>if( pTabList->a[1].fg.jointype & JT_CROSS ) return 1;         /* (1b) */\n<line20>if( selFlags & SF_UpdateFrom )              return 0;         /* (1c-iii) */\n<line21>return 1;\n<line22>}\n<line23>if( selFlags & SF_UpdateFrom ) return 0;                        /* (1c-iii) */\n<line24>while( 1 /*exit-by-break*/ ){\n<line25>if( pItem->fg.jointype & (JT_OUTER|JT_CROSS)  ) return 0;     /* (1c-ii) */\n<line26>if( i==0 ) break;\n<line27>i--;\n<line28>pItem--;\n<line29>if( pItem->fg.isSubquery ) return 0;                          /* (1c-i) */\n<line30>}\n<line31>return 1;\n<line32>}
----------------------------------------
Function: existsToJoin
Content: <line0>static SQLITE_NOINLINE void existsToJoin(\n<line1>Parse *pParse,  /* Parsing context */\n<line2>Select *p,      /* The SELECT statement being optimized */\n<line3>Expr *pWhere    /* part of the WHERE clause currently being examined */\n<line4>){\n<line5>if( pParse->nErr==0\n<line6>&& pWhere!=0\n<line7>&& !ExprHasProperty(pWhere, EP_OuterON|EP_InnerON)\n<line8>&& ALWAYS(p->pSrc!=0)\n<line9>&& p->pSrc->nSrc<BMS\n<line10>){\n<line11>if( pWhere->op==TK_AND ){\n<line12>Expr *pRight = pWhere->pRight;\n<line13>existsToJoin(pParse, p, pWhere->pLeft);\n<line14>existsToJoin(pParse, p, pRight);\n<line15>}\n<line16>else if( pWhere->op==TK_EXISTS ){\n<line17>Select *pSub = pWhere->x.pSelect;\n<line18>Expr *pSubWhere = pSub->pWhere;\n<line19>if( pSub->pSrc->nSrc==1\n<line20>&& (pSub->selFlags & SF_Aggregate)==0\n<line21>&& !pSub->pSrc->a[0].fg.isSubquery\n<line22>&& pSub->pLimit==0\n<line23>){\n<line24>memset(pWhere, 0, sizeof(*pWhere));\n<line25>pWhere->op = TK_INTEGER;\n<line26>pWhere->u.iValue = 1;\n<line27>ExprSetProperty(pWhere, EP_IntValue);\n<line28>assert( p->pWhere!=0 );\n<line29>pSub->pSrc->a[0].fg.fromExists = 1;\n<line30>pSub->pSrc->a[0].fg.jointype |= JT_CROSS;\n<line31>p->pSrc = sqlite3SrcListAppendList(pParse, p->pSrc, pSub->pSrc);\n<line32>if( pSubWhere ){\n<line33>p->pWhere = sqlite3PExpr(pParse, TK_AND, p->pWhere, pSubWhere);\n<line34>pSub->pWhere = 0;\n<line35>}\n<line36>pSub->pSrc = 0;\n<line37>sqlite3ParserAddCleanup(pParse, sqlite3SelectDeleteGeneric, pSub);\n<line38>#if TREETRACE_ENABLED\n<line39>if( sqlite3TreeTrace & 0x100000 ){\n<line40>TREETRACE(0x100000,pParse,p,\n<line41>("After EXISTS-to-JOIN optimization:\n"));\n<line42>sqlite3TreeViewSelect(0, p, 0);\n<line43>}\n<line44>#endif\n<line45>existsToJoin(pParse, p, pSubWhere);\n<line46>}\n<line47>}\n<line48>}\n<line49>}
----------------------------------------
Function: selectCheckOnClausesExpr
Content: <line0>static int selectCheckOnClausesExpr(Walker *pWalker, Expr *pExpr){\n<line1>CheckOnCtx *pCtx = pWalker->u.pCheckOnCtx;\n<line2>/* Check if pExpr is root or near-root of an ON clause constraint that needs\n<line3>** to be checked to ensure that it does not refer to tables in its FROM\n<line4>** clause to the right of itself. i.e. it is either:\n<line5>**\n<line6>**   + an ON clause on an OUTER join, or\n<line7>**   + an ON clause on an INNER join within a FROM that features at\n<line8>**     least one RIGHT or FULL join.\n<line9>*/\n<line10>if( (ExprHasProperty(pExpr, EP_OuterON))\n<line11>|| (ExprHasProperty(pExpr, EP_InnerON) && hasRightJoin(pCtx->pSrc))\n<line12>){\n<line13>/* If CheckOnCtx.iJoin is already set, then fall through and process\n<line14>** this expression node as normal. Or, if CheckOnCtx.iJoin is still 0,\n<line15>** set it to the cursor number of the RHS of the join to which this\n<line16>** ON expression was attached and then iterate through the entire\n<line17>** expression.  */\n<line18>assert( pCtx->iJoin==0 || pCtx->iJoin==pExpr->w.iJoin );\n<line19>if( pCtx->iJoin==0 ){\n<line20>pCtx->iJoin = pExpr->w.iJoin;\n<line21>sqlite3WalkExprNN(pWalker, pExpr);\n<line22>pCtx->iJoin = 0;\n<line23>return WRC_Prune;\n<line24>}\n<line25>}\n<line26>if( pExpr->op==TK_COLUMN ){\n<line27>/* A column expression. Find the SrcList (if any) to which it refers.\n<line28>** Then, if CheckOnCtx.iJoin indicates that this expression is part of an\n<line29>** ON clause from that SrcList (i.e. if iJoin is non-zero), check that it\n<line30>** does not refer to a table to the right of CheckOnCtx.iJoin. */\n<line31>do {\n<line32>SrcList *pSrc = pCtx->pSrc;\n<line33>int iTab = pExpr->iTable;\n<line34>if( iTab>=pSrc->a[0].iCursor && iTab<=pSrc->a[pSrc->nSrc-1].iCursor ){\n<line35>if( pCtx->iJoin && iTab>pCtx->iJoin ){\n<line36>sqlite3ErrorMsg(pWalker->pParse,\n<line37>"ON clause references tables to its right");\n<line38>return WRC_Abort;\n<line39>}\n<line40>break;\n<line41>}\n<line42>pCtx = pCtx->pParent;\n<line43>}while( pCtx );\n<line44>}\n<line45>return WRC_Continue;\n<line46>}
----------------------------------------
Function: selectCheckOnClausesSelect
Content: <line0>static int selectCheckOnClausesSelect(Walker *pWalker, Select *pSelect){\n<line1>CheckOnCtx *pCtx = pWalker->u.pCheckOnCtx;\n<line2>if( pSelect->pSrc==pCtx->pSrc || pSelect->pSrc->nSrc==0 ){\n<line3>return WRC_Continue;\n<line4>}else{\n<line5>CheckOnCtx sCtx;\n<line6>memset(&sCtx, 0, sizeof(sCtx));\n<line7>sCtx.pSrc = pSelect->pSrc;\n<line8>sCtx.pParent = pCtx;\n<line9>pWalker->u.pCheckOnCtx = &sCtx;\n<line10>sqlite3WalkSelect(pWalker, pSelect);\n<line11>pWalker->u.pCheckOnCtx = pCtx;\n<line12>pSelect->selFlags &= ~SF_OnToWhere;\n<line13>return WRC_Prune;\n<line14>}\n<line15>}
----------------------------------------
Function: selectCheckOnClauses
Content: <line0>static void selectCheckOnClauses(Parse *pParse, Select *pSelect){\n<line1>Walker w;\n<line2>CheckOnCtx sCtx;\n<line3>assert( pSelect->selFlags & SF_OnToWhere );\n<line4>assert( pSelect->pSrc!=0 && pSelect->pSrc->nSrc>=2 );\n<line5>memset(&w, 0, sizeof(w));\n<line6>w.pParse = pParse;\n<line7>w.xExprCallback = selectCheckOnClausesExpr;\n<line8>w.xSelectCallback = selectCheckOnClausesSelect;\n<line9>w.u.pCheckOnCtx = &sCtx;\n<line10>memset(&sCtx, 0, sizeof(sCtx));\n<line11>sCtx.pSrc = pSelect->pSrc;\n<line12>sqlite3WalkExprNN(&w, pSelect->pWhere);\n<line13>pSelect->selFlags &= ~SF_OnToWhere;\n<line14>}
----------------------------------------
Function: sqlite3_get_table_cb
Content: <line0>static int sqlite3_get_table_cb(void *pArg, int nCol, char **argv, char **colv){\n<line1>TabResult *p = (TabResult*)pArg;  /* Result accumulator */\n<line2>int need;                         /* Slots needed in p->azResult[] */\n<line3>int i;                            /* Loop counter */\n<line4>char *z;                          /* A single column of result */\n<line5>/* Make sure there is enough space in p->azResult to hold everything\n<line6>** we need to remember from this invocation of the callback.\n<line7>*/\n<line8>if( p->nRow==0 && argv!=0 ){\n<line9>need = nCol*2;\n<line10>}else{\n<line11>need = nCol;\n<line12>}\n<line13>if( p->nData + need > p->nAlloc ){\n<line14>char **azNew;\n<line15>p->nAlloc = p->nAlloc*2 + need;\n<line16>azNew = sqlite3Realloc( p->azResult, sizeof(char*)*p->nAlloc );\n<line17>if( azNew==0 ) goto malloc_failed;\n<line18>p->azResult = azNew;\n<line19>}\n<line20>/* If this is the first row, then generate an extra row containing\n<line21>** the names of all columns.\n<line22>*/\n<line23>if( p->nRow==0 ){\n<line24>p->nColumn = nCol;\n<line25>for(i=0; i<nCol; i++){\n<line26>z = sqlite3_mprintf("%s", colv[i]);\n<line27>if( z==0 ) goto malloc_failed;\n<line28>p->azResult[p->nData++] = z;\n<line29>}\n<line30>}else if( (int)p->nColumn!=nCol ){\n<line31>sqlite3_free(p->zErrMsg);\n<line32>p->zErrMsg = sqlite3_mprintf(\n<line33>"sqlite3_get_table() called with two or more incompatible queries"\n<line34>);\n<line35>p->rc = SQLITE_ERROR;\n<line36>return 1;\n<line37>}\n<line38>/* Copy over the row data\n<line39>*/\n<line40>if( argv!=0 ){\n<line41>for(i=0; i<nCol; i++){\n<line42>if( argv[i]==0 ){\n<line43>z = 0;\n<line44>}else{\n<line45>int n = sqlite3Strlen30(argv[i])+1;\n<line46>z = sqlite3_malloc64( n );\n<line47>if( z==0 ) goto malloc_failed;\n<line48>memcpy(z, argv[i], n);\n<line49>}\n<line50>p->azResult[p->nData++] = z;\n<line51>}\n<line52>p->nRow++;\n<line53>}\n<line54>return 0;\n<line55>malloc_failed:\n<line56>p->rc = SQLITE_NOMEM_BKPT;\n<line57>return 1;\n<line58>}
----------------------------------------
Function: sqlite3_get_table
Content: <line0>SQLITE_API int sqlite3_get_table(\n<line1>sqlite3 *db,                /* The database on which the SQL executes */\n<line2>const char *zSql,           /* The SQL to be executed */\n<line3>char ***pazResult,          /* Write the result table here */\n<line4>int *pnRow,                 /* Write the number of rows in the result here */\n<line5>int *pnColumn,              /* Write the number of columns of result here */\n<line6>char **pzErrMsg             /* Write error messages here */\n<line7>){\n<line8>int rc;\n<line9>TabResult res;\n<line10>#ifdef SQLITE_ENABLE_API_ARMOR\n<line11>if( !sqlite3SafetyCheckOk(db) || pazResult==0 ) return SQLITE_MISUSE_BKPT;\n<line12>#endif\n<line13>*pazResult = 0;\n<line14>if( pnColumn ) *pnColumn = 0;\n<line15>if( pnRow ) *pnRow = 0;\n<line16>if( pzErrMsg ) *pzErrMsg = 0;\n<line17>res.zErrMsg = 0;\n<line18>res.nRow = 0;\n<line19>res.nColumn = 0;\n<line20>res.nData = 1;\n<line21>res.nAlloc = 20;\n<line22>res.rc = SQLITE_OK;\n<line23>res.azResult = sqlite3_malloc64(sizeof(char*)*res.nAlloc );\n<line24>if( res.azResult==0 ){\n<line25>db->errCode = SQLITE_NOMEM;\n<line26>return SQLITE_NOMEM_BKPT;\n<line27>}\n<line28>res.azResult[0] = 0;\n<line29>rc = sqlite3_exec(db, zSql, sqlite3_get_table_cb, &res, pzErrMsg);\n<line30>assert( sizeof(res.azResult[0])>= sizeof(res.nData) );\n<line31>res.azResult[0] = SQLITE_INT_TO_PTR(res.nData);\n<line32>if( (rc&0xff)==SQLITE_ABORT ){\n<line33>sqlite3_free_table(&res.azResult[1]);\n<line34>if( res.zErrMsg ){\n<line35>if( pzErrMsg ){\n<line36>sqlite3_free(*pzErrMsg);\n<line37>*pzErrMsg = sqlite3_mprintf("%s",res.zErrMsg);\n<line38>}\n<line39>sqlite3_free(res.zErrMsg);\n<line40>}\n<line41>db->errCode = res.rc;  /* Assume 32-bit assignment is atomic */\n<line42>return res.rc;\n<line43>}\n<line44>sqlite3_free(res.zErrMsg);\n<line45>if( rc!=SQLITE_OK ){\n<line46>sqlite3_free_table(&res.azResult[1]);\n<line47>return rc;\n<line48>}\n<line49>if( res.nAlloc>res.nData ){\n<line50>char **azNew;\n<line51>azNew = sqlite3Realloc( res.azResult, sizeof(char*)*res.nData );\n<line52>if( azNew==0 ){\n<line53>sqlite3_free_table(&res.azResult[1]);\n<line54>db->errCode = SQLITE_NOMEM;\n<line55>return SQLITE_NOMEM_BKPT;\n<line56>}\n<line57>res.azResult = azNew;\n<line58>}\n<line59>*pazResult = &res.azResult[1];\n<line60>if( pnColumn ) *pnColumn = res.nColumn;\n<line61>if( pnRow ) *pnRow = res.nRow;\n<line62>return rc;\n<line63>}
----------------------------------------
Function: sqlite3_free_table
Content: <line0>SQLITE_API void sqlite3_free_table(\n<line1>char **azResult            /* Result returned from sqlite3_get_table() */\n<line2>){\n<line3>if( azResult ){\n<line4>int i, n;\n<line5>azResult--;\n<line6>assert( azResult!=0 );\n<line7>n = SQLITE_PTR_TO_INT(azResult[0]);\n<line8>for(i=1; i<n; i++){ if( azResult[i] ) sqlite3_free(azResult[i]); }\n<line9>sqlite3_free(azResult);\n<line10>}\n<line11>}
----------------------------------------
Function: triggerSpanDup
Content: <line0>static char *triggerSpanDup(sqlite3 *db, const char *zStart, const char *zEnd){\n<line1>char *z = sqlite3DbSpanDup(db, zStart, zEnd);\n<line2>int i;\n<line3>if( z ) for(i=0; z[i]; i++) if( sqlite3Isspace(z[i]) ) z[i] = ' ';\n<line4>return z;\n<line5>}
----------------------------------------
Function: triggerStepAllocate
Content: <line0>static TriggerStep *triggerStepAllocate(\n<line1>Parse *pParse,              /* Parser context */\n<line2>u8 op,                      /* Trigger opcode */\n<line3>Token *pName,               /* The target name */\n<line4>const char *zStart,         /* Start of SQL text */\n<line5>const char *zEnd            /* End of SQL text */\n<line6>){\n<line7>sqlite3 *db = pParse->db;\n<line8>TriggerStep *pTriggerStep;\n<line9>if( pParse->nErr ) return 0;\n<line10>pTriggerStep = sqlite3DbMallocZero(db, sizeof(TriggerStep) + pName->n + 1);\n<line11>if( pTriggerStep ){\n<line12>char *z = (char*)&pTriggerStep[1];\n<line13>memcpy(z, pName->z, pName->n);\n<line14>sqlite3Dequote(z);\n<line15>pTriggerStep->zTarget = z;\n<line16>pTriggerStep->op = op;\n<line17>pTriggerStep->zSpan = triggerSpanDup(db, zStart, zEnd);\n<line18>if( IN_RENAME_OBJECT ){\n<line19>sqlite3RenameTokenMap(pParse, pTriggerStep->zTarget, pName);\n<line20>}\n<line21>}\n<line22>return pTriggerStep;\n<line23>}
----------------------------------------
Function: tableOfTrigger
Content: <line0>static Table *tableOfTrigger(Trigger *pTrigger){\n<line1>return sqlite3HashFind(&pTrigger->pTabSchema->tblHash, pTrigger->table);\n<line2>}
----------------------------------------
Function: checkColumnOverlap
Content: <line0>static int checkColumnOverlap(IdList *pIdList, ExprList *pEList){\n<line1>int e;\n<line2>if( pIdList==0 || NEVER(pEList==0) ) return 1;\n<line3>for(e=0; e<pEList->nExpr; e++){\n<line4>if( sqlite3IdListIndex(pIdList, pEList->a[e].zEName)>=0 ) return 1;\n<line5>}\n<line6>return 0;\n<line7>}
----------------------------------------
Function: tempTriggersExist
Content: <line0>static int tempTriggersExist(sqlite3 *db){\n<line1>if( NEVER(db->aDb[1].pSchema==0) ) return 0;\n<line2>if( sqliteHashFirst(&db->aDb[1].pSchema->trigHash)==0 ) return 0;\n<line3>return 1;\n<line4>}
----------------------------------------
Function: triggersReallyExist
Content: <line0>static SQLITE_NOINLINE Trigger *triggersReallyExist(\n<line1>Parse *pParse,          /* Parse context */\n<line2>Table *pTab,            /* The table the contains the triggers */\n<line3>int op,                 /* one of TK_DELETE, TK_INSERT, TK_UPDATE */\n<line4>ExprList *pChanges,     /* Columns that change in an UPDATE statement */\n<line5>int *pMask              /* OUT: Mask of TRIGGER_BEFORE|TRIGGER_AFTER */\n<line6>){\n<line7>int mask = 0;\n<line8>Trigger *pList = 0;\n<line9>Trigger *p;\n<line10>pList = sqlite3TriggerList(pParse, pTab);\n<line11>assert( pList==0 || IsVirtual(pTab)==0\n<line12>|| (pList->bReturning && pList->pNext==0) );\n<line13>if( pList!=0 ){\n<line14>p = pList;\n<line15>if( (pParse->db->flags & SQLITE_EnableTrigger)==0\n<line16>&& pTab->pTrigger!=0\n<line17>){\n<line18>/* The SQLITE_DBCONFIG_ENABLE_TRIGGER setting is off.  That means that\n<line19>** only TEMP triggers are allowed.  Truncate the pList so that it\n<line20>** includes only TEMP triggers */\n<line21>if( pList==pTab->pTrigger ){\n<line22>pList = 0;\n<line23>goto exit_triggers_exist;\n<line24>}\n<line25>while( ALWAYS(p->pNext) && p->pNext!=pTab->pTrigger ) p = p->pNext;\n<line26>p->pNext = 0;\n<line27>p = pList;\n<line28>}\n<line29>do{\n<line30>if( p->op==op && checkColumnOverlap(p->pColumns, pChanges) ){\n<line31>mask |= p->tr_tm;\n<line32>}else if( p->op==TK_RETURNING ){\n<line33>/* The first time a RETURNING trigger is seen, the "op" value tells\n<line34>** us what time of trigger it should be. */\n<line35>assert( sqlite3IsToplevel(pParse) );\n<line36>p->op = op;\n<line37>if( IsVirtual(pTab) ){\n<line38>if( op!=TK_INSERT ){\n<line39>sqlite3ErrorMsg(pParse,\n<line40>"%s RETURNING is not available on virtual tables",\n<line41>op==TK_DELETE ? "DELETE" : "UPDATE");\n<line42>}\n<line43>p->tr_tm = TRIGGER_BEFORE;\n<line44>}else{\n<line45>p->tr_tm = TRIGGER_AFTER;\n<line46>}\n<line47>mask |= p->tr_tm;\n<line48>}else if( p->bReturning && p->op==TK_INSERT && op==TK_UPDATE\n<line49>&& sqlite3IsToplevel(pParse) ){\n<line50>/* Also fire a RETURNING trigger for an UPSERT */\n<line51>mask |= p->tr_tm;\n<line52>}\n<line53>p = p->pNext;\n<line54>}while( p );\n<line55>}\n<line56>exit_triggers_exist:\n<line57>if( pMask ){\n<line58>*pMask = mask;\n<line59>}\n<line60>return (mask ? pList : 0);\n<line61>}
----------------------------------------
Function: isAsteriskTerm
Content: <line0>static int isAsteriskTerm(\n<line1>Parse *pParse,      /* Parsing context */\n<line2>Expr *pTerm         /* A term in the RETURNING clause */\n<line3>){\n<line4>assert( pTerm!=0 );\n<line5>if( pTerm->op==TK_ASTERISK ) return 1;\n<line6>if( pTerm->op!=TK_DOT ) return 0;\n<line7>assert( pTerm->pRight!=0 );\n<line8>assert( pTerm->pLeft!=0 );\n<line9>if( pTerm->pRight->op!=TK_ASTERISK ) return 0;\n<line10>sqlite3ErrorMsg(pParse, "RETURNING may not use \"TABLE.*\" wildcards");\n<line11>return 1;\n<line12>}
----------------------------------------
Function: sqlite3ExpandReturning
Content: <line0>static ExprList *sqlite3ExpandReturning(\n<line1>Parse *pParse,        /* Parsing context */\n<line2>ExprList *pList,      /* The arguments to RETURNING */\n<line3>Table *pTab           /* The table being updated */\n<line4>){\n<line5>ExprList *pNew = 0;\n<line6>sqlite3 *db = pParse->db;\n<line7>int i;\n<line8>for(i=0; i<pList->nExpr; i++){\n<line9>Expr *pOldExpr = pList->a[i].pExpr;\n<line10>if( NEVER(pOldExpr==0) ) continue;\n<line11>if( isAsteriskTerm(pParse, pOldExpr) ){\n<line12>int jj;\n<line13>for(jj=0; jj<pTab->nCol; jj++){\n<line14>Expr *pNewExpr;\n<line15>if( IsHiddenColumn(pTab->aCol+jj) ) continue;\n<line16>pNewExpr = sqlite3Expr(db, TK_ID, pTab->aCol[jj].zCnName);\n<line17>pNew = sqlite3ExprListAppend(pParse, pNew, pNewExpr);\n<line18>if( !db->mallocFailed ){\n<line19>struct ExprList_item *pItem = &pNew->a[pNew->nExpr-1];\n<line20>pItem->zEName = sqlite3DbStrDup(db, pTab->aCol[jj].zCnName);\n<line21>pItem->fg.eEName = ENAME_NAME;\n<line22>}\n<line23>}\n<line24>}else{\n<line25>Expr *pNewExpr = sqlite3ExprDup(db, pOldExpr, 0);\n<line26>pNew = sqlite3ExprListAppend(pParse, pNew, pNewExpr);\n<line27>if( !db->mallocFailed && ALWAYS(pList->a[i].zEName!=0) ){\n<line28>struct ExprList_item *pItem = &pNew->a[pNew->nExpr-1];\n<line29>pItem->zEName = sqlite3DbStrDup(db, pList->a[i].zEName);\n<line30>pItem->fg.eEName = pList->a[i].fg.eEName;\n<line31>}\n<line32>}\n<line33>}\n<line34>return pNew;\n<line35>}
----------------------------------------
Function: sqlite3ReturningSubqueryVarSelect
Content: <line0>static int sqlite3ReturningSubqueryVarSelect(Walker *NotUsed, Expr *pExpr){\n<line1>UNUSED_PARAMETER(NotUsed);\n<line2>if( ExprUseXSelect(pExpr)\n<line3>&& (pExpr->x.pSelect->selFlags & SF_Correlated)!=0\n<line4>){\n<line5>testcase( ExprHasProperty(pExpr, EP_VarSelect) );\n<line6>ExprSetProperty(pExpr, EP_VarSelect);\n<line7>}\n<line8>return WRC_Continue;\n<line9>}
----------------------------------------
Function: sqlite3ReturningSubqueryCorrelated
Content: <line0>static int sqlite3ReturningSubqueryCorrelated(Walker *pWalker, Select *pSelect){\n<line1>int i;\n<line2>SrcList *pSrc;\n<line3>assert( pSelect!=0 );\n<line4>pSrc = pSelect->pSrc;\n<line5>assert( pSrc!=0 );\n<line6>for(i=0; i<pSrc->nSrc; i++){\n<line7>if( pSrc->a[i].pSTab==pWalker->u.pTab ){\n<line8>testcase( pSelect->selFlags & SF_Correlated );\n<line9>pSelect->selFlags |= SF_Correlated;\n<line10>pWalker->eCode = 1;\n<line11>break;\n<line12>}\n<line13>}\n<line14>return WRC_Continue;\n<line15>}
----------------------------------------
Function: sqlite3ProcessReturningSubqueries
Content: <line0>static void sqlite3ProcessReturningSubqueries(\n<line1>ExprList *pEList,\n<line2>Table *pTab\n<line3>){\n<line4>Walker w;\n<line5>memset(&w, 0, sizeof(w));\n<line6>w.xExprCallback = sqlite3ExprWalkNoop;\n<line7>w.xSelectCallback = sqlite3ReturningSubqueryCorrelated;\n<line8>w.u.pTab = pTab;\n<line9>sqlite3WalkExprList(&w, pEList);\n<line10>if( w.eCode ){\n<line11>w.xExprCallback = sqlite3ReturningSubqueryVarSelect;\n<line12>w.xSelectCallback = sqlite3SelectWalkNoop;\n<line13>sqlite3WalkExprList(&w, pEList);\n<line14>}\n<line15>}
----------------------------------------
Function: codeReturningTrigger
Content: <line0>static void codeReturningTrigger(\n<line1>Parse *pParse,       /* Parse context */\n<line2>Trigger *pTrigger,   /* The trigger step that defines the RETURNING */\n<line3>Table *pTab,         /* The table to code triggers from */\n<line4>int regIn            /* The first in an array of registers */\n<line5>){\n<line6>Vdbe *v = pParse->pVdbe;\n<line7>sqlite3 *db = pParse->db;\n<line8>ExprList *pNew;\n<line9>Returning *pReturning;\n<line10>Select sSelect;\n<line11>SrcList *pFrom;\n<line12>union {\n<line13>SrcList sSrc;\n<line14>u8 fromSpace[SZ_SRCLIST_1];\n<line15>} uSrc;\n<line16>assert( v!=0 );\n<line17>if( !pParse->bReturning ){\n<line18>/* This RETURNING trigger must be for a different statement as\n<line19>** this statement lacks a RETURNING clause. */\n<line20>return;\n<line21>}\n<line22>assert( db->pParse==pParse );\n<line23>assert( !pParse->isCreate );\n<line24>pReturning = pParse->u1.d.pReturning;\n<line25>if( pTrigger != &(pReturning->retTrig) ){\n<line26>/* This RETURNING trigger is for a different statement */\n<line27>return;\n<line28>}\n<line29>memset(&sSelect, 0, sizeof(sSelect));\n<line30>memset(&uSrc, 0, sizeof(uSrc));\n<line31>pFrom = &uSrc.sSrc;\n<line32>sSelect.pEList = sqlite3ExprListDup(db, pReturning->pReturnEL, 0);\n<line33>sSelect.pSrc = pFrom;\n<line34>pFrom->nSrc = 1;\n<line35>pFrom->a[0].pSTab = pTab;\n<line36>pFrom->a[0].zName = pTab->zName; /* tag-20240424-1 */\n<line37>pFrom->a[0].iCursor = -1;\n<line38>sqlite3SelectPrep(pParse, &sSelect, 0);\n<line39>if( pParse->nErr==0 ){\n<line40>assert( db->mallocFailed==0 );\n<line41>sqlite3GenerateColumnNames(pParse, &sSelect);\n<line42>}\n<line43>sqlite3ExprListDelete(db, sSelect.pEList);\n<line44>pNew = sqlite3ExpandReturning(pParse, pReturning->pReturnEL, pTab);\n<line45>if( pParse->nErr==0 ){\n<line46>NameContext sNC;\n<line47>memset(&sNC, 0, sizeof(sNC));\n<line48>if( pReturning->nRetCol==0 ){\n<line49>pReturning->nRetCol = pNew->nExpr;\n<line50>pReturning->iRetCur = pParse->nTab++;\n<line51>}\n<line52>sNC.pParse = pParse;\n<line53>sNC.uNC.iBaseReg = regIn;\n<line54>sNC.ncFlags = NC_UBaseReg;\n<line55>pParse->eTriggerOp = pTrigger->op;\n<line56>pParse->pTriggerTab = pTab;\n<line57>if( sqlite3ResolveExprListNames(&sNC, pNew)==SQLITE_OK\n<line58>&& ALWAYS(!db->mallocFailed)\n<line59>){\n<line60>int i;\n<line61>int nCol = pNew->nExpr;\n<line62>int reg = pParse->nMem+1;\n<line63>sqlite3ProcessReturningSubqueries(pNew, pTab);\n<line64>pParse->nMem += nCol+2;\n<line65>pReturning->iRetReg = reg;\n<line66>for(i=0; i<nCol; i++){\n<line67>Expr *pCol = pNew->a[i].pExpr;\n<line68>assert( pCol!=0 ); /* Due to !db->mallocFailed ~9 lines above */\n<line69>sqlite3ExprCodeFactorable(pParse, pCol, reg+i);\n<line70>if( sqlite3ExprAffinity(pCol)==SQLITE_AFF_REAL ){\n<line71>sqlite3VdbeAddOp1(v, OP_RealAffinity, reg+i);\n<line72>}\n<line73>}\n<line74>sqlite3VdbeAddOp3(v, OP_MakeRecord, reg, i, reg+i);\n<line75>sqlite3VdbeAddOp2(v, OP_NewRowid, pReturning->iRetCur, reg+i+1);\n<line76>sqlite3VdbeAddOp3(v, OP_Insert, pReturning->iRetCur, reg+i, reg+i+1);\n<line77>}\n<line78>}\n<line79>sqlite3ExprListDelete(db, pNew);\n<line80>pParse->eTriggerOp = 0;\n<line81>pParse->pTriggerTab = 0;\n<line82>}
----------------------------------------
Function: codeTriggerProgram
Content: <line0>static int codeTriggerProgram(\n<line1>Parse *pParse,            /* The parser context */\n<line2>TriggerStep *pStepList,   /* List of statements inside the trigger body */\n<line3>int orconf                /* Conflict algorithm. (OE_Abort, etc) */\n<line4>){\n<line5>TriggerStep *pStep;\n<line6>Vdbe *v = pParse->pVdbe;\n<line7>sqlite3 *db = pParse->db;\n<line8>assert( pParse->pTriggerTab && pParse->pToplevel );\n<line9>assert( pStepList );\n<line10>assert( v!=0 );\n<line11>for(pStep=pStepList; pStep; pStep=pStep->pNext){\n<line12>/* Figure out the ON CONFLICT policy that will be used for this step\n<line13>** of the trigger program. If the statement that caused this trigger\n<line14>** to fire had an explicit ON CONFLICT, then use it. Otherwise, use\n<line15>** the ON CONFLICT policy that was specified as part of the trigger\n<line16>** step statement. Example:\n<line17>**\n<line18>**   CREATE TRIGGER AFTER INSERT ON t1 BEGIN;\n<line19>**     INSERT OR REPLACE INTO t2 VALUES(new.a, new.b);\n<line20>**   END;\n<line21>**\n<line22>**   INSERT INTO t1 ... ;            -- insert into t2 uses REPLACE policy\n<line23>**   INSERT OR IGNORE INTO t1 ... ;  -- insert into t2 uses IGNORE policy\n<line24>*/\n<line25>pParse->eOrconf = (orconf==OE_Default)?pStep->orconf:(u8)orconf;\n<line26>assert( pParse->okConstFactor==0 );\n<line27>#ifndef SQLITE_OMIT_TRACE\n<line28>if( pStep->zSpan ){\n<line29>sqlite3VdbeAddOp4(v, OP_Trace, 0x7fffffff, 1, 0,\n<line30>sqlite3MPrintf(db, "-- %s", pStep->zSpan),\n<line31>P4_DYNAMIC);\n<line32>}\n<line33>#endif\n<line34>switch( pStep->op ){\n<line35>case TK_UPDATE: {\n<line36>sqlite3Update(pParse,\n<line37>sqlite3TriggerStepSrc(pParse, pStep),\n<line38>sqlite3ExprListDup(db, pStep->pExprList, 0),\n<line39>sqlite3ExprDup(db, pStep->pWhere, 0),\n<line40>pParse->eOrconf, 0, 0, 0\n<line41>);\n<line42>sqlite3VdbeAddOp0(v, OP_ResetCount);\n<line43>break;\n<line44>}\n<line45>case TK_INSERT: {\n<line46>sqlite3Insert(pParse,\n<line47>sqlite3TriggerStepSrc(pParse, pStep),\n<line48>sqlite3SelectDup(db, pStep->pSelect, 0),\n<line49>sqlite3IdListDup(db, pStep->pIdList),\n<line50>pParse->eOrconf,\n<line51>sqlite3UpsertDup(db, pStep->pUpsert)\n<line52>);\n<line53>sqlite3VdbeAddOp0(v, OP_ResetCount);\n<line54>break;\n<line55>}\n<line56>case TK_DELETE: {\n<line57>sqlite3DeleteFrom(pParse,\n<line58>sqlite3TriggerStepSrc(pParse, pStep),\n<line59>sqlite3ExprDup(db, pStep->pWhere, 0), 0, 0\n<line60>);\n<line61>sqlite3VdbeAddOp0(v, OP_ResetCount);\n<line62>break;\n<line63>}\n<line64>default: assert( pStep->op==TK_SELECT ); {\n<line65>SelectDest sDest;\n<line66>Select *pSelect = sqlite3SelectDup(db, pStep->pSelect, 0);\n<line67>sqlite3SelectDestInit(&sDest, SRT_Discard, 0);\n<line68>sqlite3Select(pParse, pSelect, &sDest);\n<line69>sqlite3SelectDelete(db, pSelect);\n<line70>break;\n<line71>}\n<line72>}\n<line73>}\n<line74>return 0;\n<line75>}
----------------------------------------
Function: transferParseError
Content: <line0>static void transferParseError(Parse *pTo, Parse *pFrom){\n<line1>assert( pFrom->zErrMsg==0 || pFrom->nErr );\n<line2>assert( pTo->zErrMsg==0 || pTo->nErr );\n<line3>if( pTo->nErr==0 ){\n<line4>pTo->zErrMsg = pFrom->zErrMsg;\n<line5>pTo->nErr = pFrom->nErr;\n<line6>pTo->rc = pFrom->rc;\n<line7>}else{\n<line8>sqlite3DbFree(pFrom->db, pFrom->zErrMsg);\n<line9>}\n<line10>}
----------------------------------------
Function: codeRowTrigger
Content: <line0>static TriggerPrg *codeRowTrigger(\n<line1>Parse *pParse,       /* Current parse context */\n<line2>Trigger *pTrigger,   /* Trigger to code */\n<line3>Table *pTab,         /* The table pTrigger is attached to */\n<line4>int orconf           /* ON CONFLICT policy to code trigger program with */\n<line5>){\n<line6>Parse *pTop = sqlite3ParseToplevel(pParse);\n<line7>sqlite3 *db = pParse->db;   /* Database handle */\n<line8>TriggerPrg *pPrg;           /* Value to return */\n<line9>Expr *pWhen = 0;            /* Duplicate of trigger WHEN expression */\n<line10>Vdbe *v;                    /* Temporary VM */\n<line11>NameContext sNC;            /* Name context for sub-vdbe */\n<line12>SubProgram *pProgram = 0;   /* Sub-vdbe for trigger program */\n<line13>int iEndTrigger = 0;        /* Label to jump to if WHEN is false */\n<line14>Parse sSubParse;            /* Parse context for sub-vdbe */\n<line15>assert( pTrigger->zName==0 || pTab==tableOfTrigger(pTrigger) );\n<line16>assert( pTop->pVdbe );\n<line17>/* Allocate the TriggerPrg and SubProgram objects. To ensure that they\n<line18>** are freed if an error occurs, link them into the Parse.pTriggerPrg\n<line19>** list of the top-level Parse object sooner rather than later.  */\n<line20>pPrg = sqlite3DbMallocZero(db, sizeof(TriggerPrg));\n<line21>if( !pPrg ) return 0;\n<line22>pPrg->pNext = pTop->pTriggerPrg;\n<line23>pTop->pTriggerPrg = pPrg;\n<line24>pPrg->pProgram = pProgram = sqlite3DbMallocZero(db, sizeof(SubProgram));\n<line25>if( !pProgram ) return 0;\n<line26>sqlite3VdbeLinkSubProgram(pTop->pVdbe, pProgram);\n<line27>pPrg->pTrigger = pTrigger;\n<line28>pPrg->orconf = orconf;\n<line29>pPrg->aColmask[0] = 0xffffffff;\n<line30>pPrg->aColmask[1] = 0xffffffff;\n<line31>/* Allocate and populate a new Parse context to use for coding the\n<line32>** trigger sub-program.  */\n<line33>sqlite3ParseObjectInit(&sSubParse, db);\n<line34>memset(&sNC, 0, sizeof(sNC));\n<line35>sNC.pParse = &sSubParse;\n<line36>sSubParse.pTriggerTab = pTab;\n<line37>sSubParse.pToplevel = pTop;\n<line38>sSubParse.zAuthContext = pTrigger->zName;\n<line39>sSubParse.eTriggerOp = pTrigger->op;\n<line40>sSubParse.nQueryLoop = pParse->nQueryLoop;\n<line41>sSubParse.prepFlags = pParse->prepFlags;\n<line42>sSubParse.oldmask = 0;\n<line43>sSubParse.newmask = 0;\n<line44>v = sqlite3GetVdbe(&sSubParse);\n<line45>if( v ){\n<line46>VdbeComment((v, "Start: %s.%s (%s %s%s%s ON %s)",\n<line47>pTrigger->zName, onErrorText(orconf),\n<line48>(pTrigger->tr_tm==TRIGGER_BEFORE ? "BEFORE" : "AFTER"),\n<line49>(pTrigger->op==TK_UPDATE ? "UPDATE" : ""),\n<line50>(pTrigger->op==TK_INSERT ? "INSERT" : ""),\n<line51>(pTrigger->op==TK_DELETE ? "DELETE" : ""),\n<line52>pTab->zName\n<line53>));\n<line54>#ifndef SQLITE_OMIT_TRACE\n<line55>if( pTrigger->zName ){\n<line56>sqlite3VdbeChangeP4(v, -1,\n<line57>sqlite3MPrintf(db, "-- TRIGGER %s", pTrigger->zName), P4_DYNAMIC\n<line58>);\n<line59>}\n<line60>#endif\n<line61>/* If one was specified, code the WHEN clause. If it evaluates to false\n<line62>** (or NULL) the sub-vdbe is immediately halted by jumping to the\n<line63>** OP_Halt inserted at the end of the program.  */\n<line64>if( pTrigger->pWhen ){\n<line65>pWhen = sqlite3ExprDup(db, pTrigger->pWhen, 0);\n<line66>if( db->mallocFailed==0\n<line67>&& SQLITE_OK==sqlite3ResolveExprNames(&sNC, pWhen)\n<line68>){\n<line69>iEndTrigger = sqlite3VdbeMakeLabel(&sSubParse);\n<line70>sqlite3ExprIfFalse(&sSubParse, pWhen, iEndTrigger, SQLITE_JUMPIFNULL);\n<line71>}\n<line72>sqlite3ExprDelete(db, pWhen);\n<line73>}\n<line74>/* Code the trigger program into the sub-vdbe. */\n<line75>codeTriggerProgram(&sSubParse, pTrigger->step_list, orconf);\n<line76>/* Insert an OP_Halt at the end of the sub-program. */\n<line77>if( iEndTrigger ){\n<line78>sqlite3VdbeResolveLabel(v, iEndTrigger);\n<line79>}\n<line80>sqlite3VdbeAddOp0(v, OP_Halt);\n<line81>VdbeComment((v, "End: %s.%s", pTrigger->zName, onErrorText(orconf)));\n<line82>transferParseError(pParse, &sSubParse);\n<line83>if( pParse->nErr==0 ){\n<line84>assert( db->mallocFailed==0 );\n<line85>pProgram->aOp = sqlite3VdbeTakeOpArray(v, &pProgram->nOp, &pTop->nMaxArg);\n<line86>}\n<line87>pProgram->nMem = sSubParse.nMem;\n<line88>pProgram->nCsr = sSubParse.nTab;\n<line89>pProgram->token = (void *)pTrigger;\n<line90>pPrg->aColmask[0] = sSubParse.oldmask;\n<line91>pPrg->aColmask[1] = sSubParse.newmask;\n<line92>sqlite3VdbeDelete(v);\n<line93>}else{\n<line94>transferParseError(pParse, &sSubParse);\n<line95>}\n<line96>assert( !sSubParse.pTriggerPrg && !sSubParse.nMaxArg );\n<line97>sqlite3ParseObjectReset(&sSubParse);\n<line98>return pPrg;\n<line99>}
----------------------------------------
Function: getRowTrigger
Content: <line0>static TriggerPrg *getRowTrigger(\n<line1>Parse *pParse,       /* Current parse context */\n<line2>Trigger *pTrigger,   /* Trigger to code */\n<line3>Table *pTab,         /* The table trigger pTrigger is attached to */\n<line4>int orconf           /* ON CONFLICT algorithm. */\n<line5>){\n<line6>Parse *pRoot = sqlite3ParseToplevel(pParse);\n<line7>TriggerPrg *pPrg;\n<line8>assert( pTrigger->zName==0 || pTab==tableOfTrigger(pTrigger) );\n<line9>/* It may be that this trigger has already been coded (or is in the\n<line10>** process of being coded). If this is the case, then an entry with\n<line11>** a matching TriggerPrg.pTrigger field will be present somewhere\n<line12>** in the Parse.pTriggerPrg list. Search for such an entry.  */\n<line13>for(pPrg=pRoot->pTriggerPrg;\n<line14>pPrg && (pPrg->pTrigger!=pTrigger || pPrg->orconf!=orconf);\n<line15>pPrg=pPrg->pNext\n<line16>);\n<line17>/* If an existing TriggerPrg could not be located, create a new one. */\n<line18>if( !pPrg ){\n<line19>pPrg = codeRowTrigger(pParse, pTrigger, pTab, orconf);\n<line20>pParse->db->errByteOffset = -1;\n<line21>}\n<line22>return pPrg;\n<line23>}
----------------------------------------
Function: indexColumnIsBeingUpdated
Content: <line0>static int indexColumnIsBeingUpdated(\n<line1>Index *pIdx,      /* The index to check */\n<line2>int iCol,         /* Which column of the index to check */\n<line3>int *aXRef,       /* aXRef[j]>=0 if column j is being updated */\n<line4>int chngRowid     /* true if the rowid is being updated */\n<line5>){\n<line6>i16 iIdxCol = pIdx->aiColumn[iCol];\n<line7>assert( iIdxCol!=XN_ROWID ); /* Cannot index rowid */\n<line8>if( iIdxCol>=0 ){\n<line9>return aXRef[iIdxCol]>=0;\n<line10>}\n<line11>assert( iIdxCol==XN_EXPR );\n<line12>assert( pIdx->aColExpr!=0 );\n<line13>assert( pIdx->aColExpr->a[iCol].pExpr!=0 );\n<line14>return sqlite3ExprReferencesUpdatedColumn(pIdx->aColExpr->a[iCol].pExpr,\n<line15>aXRef,chngRowid);\n<line16>}
----------------------------------------
Function: indexWhereClauseMightChange
Content: <line0>static int indexWhereClauseMightChange(\n<line1>Index *pIdx,      /* The index to check */\n<line2>int *aXRef,       /* aXRef[j]>=0 if column j is being updated */\n<line3>int chngRowid     /* true if the rowid is being updated */\n<line4>){\n<line5>if( pIdx->pPartIdxWhere==0 ) return 0;\n<line6>return sqlite3ExprReferencesUpdatedColumn(pIdx->pPartIdxWhere,\n<line7>aXRef, chngRowid);\n<line8>}
----------------------------------------
Function: exprRowColumn
Content: <line0>static Expr *exprRowColumn(Parse *pParse, int iCol){\n<line1>Expr *pRet = sqlite3PExpr(pParse, TK_ROW, 0, 0);\n<line2>if( pRet ) pRet->iColumn = iCol+1;\n<line3>return pRet;\n<line4>}
----------------------------------------
Function: updateFromSelect
Content: <line0>static void updateFromSelect(\n<line1>Parse *pParse,                  /* Parse context */\n<line2>int iEph,                       /* Cursor for open eph. table */\n<line3>Index *pPk,                     /* PK if table 0 is WITHOUT ROWID */\n<line4>ExprList *pChanges,             /* List of expressions to return */\n<line5>SrcList *pTabList,              /* List of tables to select from */\n<line6>Expr *pWhere,                   /* WHERE clause for query */\n<line7>ExprList *pOrderBy,             /* ORDER BY clause */\n<line8>Expr *pLimit                    /* LIMIT clause */\n<line9>){\n<line10>int i;\n<line11>SelectDest dest;\n<line12>Select *pSelect = 0;\n<line13>ExprList *pList = 0;\n<line14>ExprList *pGrp = 0;\n<line15>Expr *pLimit2 = 0;\n<line16>ExprList *pOrderBy2 = 0;\n<line17>sqlite3 *db = pParse->db;\n<line18>Table *pTab = pTabList->a[0].pSTab;\n<line19>SrcList *pSrc;\n<line20>Expr *pWhere2;\n<line21>int eDest;\n<line22>#ifdef SQLITE_ENABLE_UPDATE_DELETE_LIMIT\n<line23>if( pOrderBy && pLimit==0 ) {\n<line24>sqlite3ErrorMsg(pParse, "ORDER BY without LIMIT on UPDATE");\n<line25>return;\n<line26>}\n<line27>pOrderBy2 = sqlite3ExprListDup(db, pOrderBy, 0);\n<line28>pLimit2 = sqlite3ExprDup(db, pLimit, 0);\n<line29>#else\n<line30>UNUSED_PARAMETER(pOrderBy);\n<line31>UNUSED_PARAMETER(pLimit);\n<line32>#endif\n<line33>pSrc = sqlite3SrcListDup(db, pTabList, 0);\n<line34>pWhere2 = sqlite3ExprDup(db, pWhere, 0);\n<line35>assert( pTabList->nSrc>1 );\n<line36>if( pSrc ){\n<line37>assert( pSrc->a[0].fg.notCte );\n<line38>pSrc->a[0].iCursor = -1;\n<line39>pSrc->a[0].pSTab->nTabRef--;\n<line40>pSrc->a[0].pSTab = 0;\n<line41>}\n<line42>if( pPk ){\n<line43>for(i=0; i<pPk->nKeyCol; i++){\n<line44>Expr *pNew = exprRowColumn(pParse, pPk->aiColumn[i]);\n<line45>#ifdef SQLITE_ENABLE_UPDATE_DELETE_LIMIT\n<line46>if( pLimit ){\n<line47>pGrp = sqlite3ExprListAppend(pParse, pGrp, sqlite3ExprDup(db, pNew, 0));\n<line48>}\n<line49>#endif\n<line50>pList = sqlite3ExprListAppend(pParse, pList, pNew);\n<line51>}\n<line52>eDest = IsVirtual(pTab) ? SRT_Table : SRT_Upfrom;\n<line53>}else if( IsView(pTab) ){\n<line54>for(i=0; i<pTab->nCol; i++){\n<line55>pList = sqlite3ExprListAppend(pParse, pList, exprRowColumn(pParse, i));\n<line56>}\n<line57>eDest = SRT_Table;\n<line58>}else{\n<line59>eDest = IsVirtual(pTab) ? SRT_Table : SRT_Upfrom;\n<line60>pList = sqlite3ExprListAppend(pParse, 0, sqlite3PExpr(pParse,TK_ROW,0,0));\n<line61>#ifdef SQLITE_ENABLE_UPDATE_DELETE_LIMIT\n<line62>if( pLimit ){\n<line63>pGrp = sqlite3ExprListAppend(pParse, 0, sqlite3PExpr(pParse,TK_ROW,0,0));\n<line64>}\n<line65>#endif\n<line66>}\n<line67>assert( pChanges!=0 || pParse->db->mallocFailed );\n<line68>if( pChanges ){\n<line69>for(i=0; i<pChanges->nExpr; i++){\n<line70>pList = sqlite3ExprListAppend(pParse, pList,\n<line71>sqlite3ExprDup(db, pChanges->a[i].pExpr, 0)\n<line72>);\n<line73>}\n<line74>}\n<line75>pSelect = sqlite3SelectNew(pParse, pList,\n<line76>pSrc, pWhere2, pGrp, 0, pOrderBy2,\n<line77>SF_UFSrcCheck|SF_IncludeHidden|SF_UpdateFrom, pLimit2\n<line78>);\n<line79>if( pSelect ) pSelect->selFlags |= SF_OrderByReqd;\n<line80>sqlite3SelectDestInit(&dest, eDest, iEph);\n<line81>dest.iSDParm2 = (pPk ? pPk->nKeyCol : -1);\n<line82>sqlite3Select(pParse, pSelect, &dest);\n<line83>sqlite3SelectDelete(db, pSelect);\n<line84>}
----------------------------------------
Function: updateVirtualTable
Content: <line0>static void updateVirtualTable(\n<line1>Parse *pParse,       /* The parsing context */\n<line2>SrcList *pSrc,       /* The virtual table to be modified */\n<line3>Table *pTab,         /* The virtual table */\n<line4>ExprList *pChanges,  /* The columns to change in the UPDATE statement */\n<line5>Expr *pRowid,        /* Expression used to recompute the rowid */\n<line6>int *aXRef,          /* Mapping from columns of pTab to entries in pChanges */\n<line7>Expr *pWhere,        /* WHERE clause of the UPDATE statement */\n<line8>int onError          /* ON CONFLICT strategy */\n<line9>){\n<line10>Vdbe *v = pParse->pVdbe;  /* Virtual machine under construction */\n<line11>int ephemTab;             /* Table holding the result of the SELECT */\n<line12>int i;                    /* Loop counter */\n<line13>sqlite3 *db = pParse->db; /* Database connection */\n<line14>const char *pVTab = (const char*)sqlite3GetVTable(db, pTab);\n<line15>WhereInfo *pWInfo = 0;\n<line16>int nArg = 2 + pTab->nCol;      /* Number of arguments to VUpdate */\n<line17>int regArg;                     /* First register in VUpdate arg array */\n<line18>int regRec;                     /* Register in which to assemble record */\n<line19>int regRowid;                   /* Register for ephemeral table rowid */\n<line20>int iCsr = pSrc->a[0].iCursor;  /* Cursor used for virtual table scan */\n<line21>int aDummy[2];                  /* Unused arg for sqlite3WhereOkOnePass() */\n<line22>int eOnePass;                   /* True to use onepass strategy */\n<line23>int addr;                       /* Address of OP_OpenEphemeral */\n<line24>/* Allocate nArg registers in which to gather the arguments for VUpdate. Then\n<line25>** create and open the ephemeral table in which the records created from\n<line26>** these arguments will be temporarily stored. */\n<line27>assert( v );\n<line28>ephemTab = pParse->nTab++;\n<line29>addr= sqlite3VdbeAddOp2(v, OP_OpenEphemeral, ephemTab, nArg);\n<line30>regArg = pParse->nMem + 1;\n<line31>pParse->nMem += nArg;\n<line32>if( pSrc->nSrc>1 ){\n<line33>Index *pPk = 0;\n<line34>Expr *pRow;\n<line35>ExprList *pList;\n<line36>if( HasRowid(pTab) ){\n<line37>if( pRowid ){\n<line38>pRow = sqlite3ExprDup(db, pRowid, 0);\n<line39>}else{\n<line40>pRow = sqlite3PExpr(pParse, TK_ROW, 0, 0);\n<line41>}\n<line42>}else{\n<line43>i16 iPk;      /* PRIMARY KEY column */\n<line44>pPk = sqlite3PrimaryKeyIndex(pTab);\n<line45>assert( pPk!=0 );\n<line46>assert( pPk->nKeyCol==1 );\n<line47>iPk = pPk->aiColumn[0];\n<line48>if( aXRef[iPk]>=0 ){\n<line49>pRow = sqlite3ExprDup(db, pChanges->a[aXRef[iPk]].pExpr, 0);\n<line50>}else{\n<line51>pRow = exprRowColumn(pParse, iPk);\n<line52>}\n<line53>}\n<line54>pList = sqlite3ExprListAppend(pParse, 0, pRow);\n<line55>for(i=0; i<pTab->nCol; i++){\n<line56>if( aXRef[i]>=0 ){\n<line57>pList = sqlite3ExprListAppend(pParse, pList,\n<line58>sqlite3ExprDup(db, pChanges->a[aXRef[i]].pExpr, 0)\n<line59>);\n<line60>}else{\n<line61>Expr *pRowExpr = exprRowColumn(pParse, i);\n<line62>if( pRowExpr ) pRowExpr->op2 = OPFLAG_NOCHNG;\n<line63>pList = sqlite3ExprListAppend(pParse, pList, pRowExpr);\n<line64>}\n<line65>}\n<line66>updateFromSelect(pParse, ephemTab, pPk, pList, pSrc, pWhere, 0, 0);\n<line67>sqlite3ExprListDelete(db, pList);\n<line68>eOnePass = ONEPASS_OFF;\n<line69>}else{\n<line70>regRec = ++pParse->nMem;\n<line71>regRowid = ++pParse->nMem;\n<line72>/* Start scanning the virtual table */\n<line73>pWInfo = sqlite3WhereBegin(\n<line74>pParse, pSrc, pWhere, 0, 0, 0, WHERE_ONEPASS_DESIRED, 0\n<line75>);\n<line76>if( pWInfo==0 ) return;\n<line77>/* Populate the argument registers. */\n<line78>for(i=0; i<pTab->nCol; i++){\n<line79>assert( (pTab->aCol[i].colFlags & COLFLAG_GENERATED)==0 );\n<line80>if( aXRef[i]>=0 ){\n<line81>sqlite3ExprCode(pParse, pChanges->a[aXRef[i]].pExpr, regArg+2+i);\n<line82>}else{\n<line83>sqlite3VdbeAddOp3(v, OP_VColumn, iCsr, i, regArg+2+i);\n<line84>sqlite3VdbeChangeP5(v, OPFLAG_NOCHNG);/* For sqlite3_vtab_nochange() */\n<line85>}\n<line86>}\n<line87>if( HasRowid(pTab) ){\n<line88>sqlite3VdbeAddOp2(v, OP_Rowid, iCsr, regArg);\n<line89>if( pRowid ){\n<line90>sqlite3ExprCode(pParse, pRowid, regArg+1);\n<line91>}else{\n<line92>sqlite3VdbeAddOp2(v, OP_Rowid, iCsr, regArg+1);\n<line93>}\n<line94>}else{\n<line95>Index *pPk;   /* PRIMARY KEY index */\n<line96>i16 iPk;      /* PRIMARY KEY column */\n<line97>pPk = sqlite3PrimaryKeyIndex(pTab);\n<line98>assert( pPk!=0 );\n<line99>assert( pPk->nKeyCol==1 );\n<line100>iPk = pPk->aiColumn[0];\n<line101>sqlite3VdbeAddOp3(v, OP_VColumn, iCsr, iPk, regArg);\n<line102>sqlite3VdbeAddOp2(v, OP_SCopy, regArg+2+iPk, regArg+1);\n<line103>}\n<line104>eOnePass = sqlite3WhereOkOnePass(pWInfo, aDummy);\n<line105>/* There is no ONEPASS_MULTI on virtual tables */\n<line106>assert( eOnePass==ONEPASS_OFF || eOnePass==ONEPASS_SINGLE );\n<line107>if( eOnePass ){\n<line108>/* If using the onepass strategy, no-op out the OP_OpenEphemeral coded\n<line109>** above. */\n<line110>sqlite3VdbeChangeToNoop(v, addr);\n<line111>sqlite3VdbeAddOp1(v, OP_Close, iCsr);\n<line112>}else{\n<line113>/* Create a record from the argument register contents and insert it into\n<line114>** the ephemeral table. */\n<line115>sqlite3MultiWrite(pParse);\n<line116>sqlite3VdbeAddOp3(v, OP_MakeRecord, regArg, nArg, regRec);\n<line117>#if defined(SQLITE_DEBUG) && !defined(SQLITE_ENABLE_NULL_TRIM)\n<line118>/* Signal an assert() within OP_MakeRecord that it is allowed to\n<line119>** accept no-change records with serial_type 10 */\n<line120>sqlite3VdbeChangeP5(v, OPFLAG_NOCHNG_MAGIC);\n<line121>#endif\n<line122>sqlite3VdbeAddOp2(v, OP_NewRowid, ephemTab, regRowid);\n<line123>sqlite3VdbeAddOp3(v, OP_Insert, ephemTab, regRec, regRowid);\n<line124>}\n<line125>}\n<line126>if( eOnePass==ONEPASS_OFF ){\n<line127>/* End the virtual table scan */\n<line128>if( pSrc->nSrc==1 ){\n<line129>sqlite3WhereEnd(pWInfo);\n<line130>}\n<line131>/* Begin scanning through the ephemeral table. */\n<line132>addr = sqlite3VdbeAddOp1(v, OP_Rewind, ephemTab); VdbeCoverage(v);\n<line133>/* Extract arguments from the current row of the ephemeral table and\n<line134>** invoke the VUpdate method.  */\n<line135>for(i=0; i<nArg; i++){\n<line136>sqlite3VdbeAddOp3(v, OP_Column, ephemTab, i, regArg+i);\n<line137>}\n<line138>}\n<line139>sqlite3VtabMakeWritable(pParse, pTab);\n<line140>sqlite3VdbeAddOp4(v, OP_VUpdate, 0, nArg, regArg, pVTab, P4_VTAB);\n<line141>sqlite3VdbeChangeP5(v, onError==OE_Default ? OE_Abort : onError);\n<line142>sqlite3MayAbort(pParse);\n<line143>/* End of the ephemeral table scan. Or, if using the onepass strategy,\n<line144>** jump to here if the scan visited zero rows. */\n<line145>if( eOnePass==ONEPASS_OFF ){\n<line146>sqlite3VdbeAddOp2(v, OP_Next, ephemTab, addr+1); VdbeCoverage(v);\n<line147>sqlite3VdbeJumpHere(v, addr);\n<line148>sqlite3VdbeAddOp2(v, OP_Close, ephemTab, 0);\n<line149>}else{\n<line150>sqlite3WhereEnd(pWInfo);\n<line151>}\n<line152>}
----------------------------------------
Function: upsertDelete
Content: <line0>static void SQLITE_NOINLINE upsertDelete(sqlite3 *db, Upsert *p){\n<line1>do{\n<line2>Upsert *pNext = p->pNextUpsert;\n<line3>sqlite3ExprListDelete(db, p->pUpsertTarget);\n<line4>sqlite3ExprDelete(db, p->pUpsertTargetWhere);\n<line5>sqlite3ExprListDelete(db, p->pUpsertSet);\n<line6>sqlite3ExprDelete(db, p->pUpsertWhere);\n<line7>sqlite3DbFree(db, p->pToFree);\n<line8>sqlite3DbFree(db, p);\n<line9>p = pNext;\n<line10>}while( p );\n<line11>}
----------------------------------------
Function: execSql
Content: <line0>static int execSql(sqlite3 *db, char **pzErrMsg, const char *zSql){\n<line1>sqlite3_stmt *pStmt;\n<line2>int rc;\n<line3>/* printf("SQL: [%s]\n", zSql); fflush(stdout); */\n<line4>rc = sqlite3_prepare_v2(db, zSql, -1, &pStmt, 0);\n<line5>if( rc!=SQLITE_OK ) return rc;\n<line6>while( SQLITE_ROW==(rc = sqlite3_step(pStmt)) ){\n<line7>const char *zSubSql = (const char*)sqlite3_column_text(pStmt,0);\n<line8>assert( sqlite3_strnicmp(zSql,"SELECT",6)==0 );\n<line9>/* The secondary SQL must be one of CREATE TABLE, CREATE INDEX,\n<line10>** or INSERT.  Historically there have been attacks that first\n<line11>** corrupt the sqlite_schema.sql field with other kinds of statements\n<line12>** then run VACUUM to get those statements to execute at inappropriate\n<line13>** times. */\n<line14>if( zSubSql\n<line15>&& (strncmp(zSubSql,"CRE",3)==0 || strncmp(zSubSql,"INS",3)==0)\n<line16>){\n<line17>rc = execSql(db, pzErrMsg, zSubSql);\n<line18>if( rc!=SQLITE_OK ) break;\n<line19>}\n<line20>}\n<line21>assert( rc!=SQLITE_ROW );\n<line22>if( rc==SQLITE_DONE ) rc = SQLITE_OK;\n<line23>if( rc ){\n<line24>sqlite3SetString(pzErrMsg, db, sqlite3_errmsg(db));\n<line25>}\n<line26>(void)sqlite3_finalize(pStmt);\n<line27>return rc;\n<line28>}
----------------------------------------
Function: execSqlF
Content: <line0>static int execSqlF(sqlite3 *db, char **pzErrMsg, const char *zSql, ...){\n<line1>char *z;\n<line2>va_list ap;\n<line3>int rc;\n<line4>va_start(ap, zSql);\n<line5>z = sqlite3VMPrintf(db, zSql, ap);\n<line6>va_end(ap);\n<line7>if( z==0 ) return SQLITE_NOMEM;\n<line8>rc = execSql(db, pzErrMsg, z);\n<line9>sqlite3DbFree(db, z);\n<line10>return rc;\n<line11>}
----------------------------------------
Function: createModule
Content: <line0>static int createModule(\n<line1>sqlite3 *db,                    /* Database in which module is registered */\n<line2>const char *zName,              /* Name assigned to this module */\n<line3>const sqlite3_module *pModule,  /* The definition of the module */\n<line4>void *pAux,                     /* Context pointer for xCreate/xConnect */\n<line5>void (*xDestroy)(void *)        /* Module destructor function */\n<line6>){\n<line7>int rc = SQLITE_OK;\n<line8>sqlite3_mutex_enter(db->mutex);\n<line9>(void)sqlite3VtabCreateModule(db, zName, pModule, pAux, xDestroy);\n<line10>rc = sqlite3ApiExit(db, rc);\n<line11>if( rc!=SQLITE_OK && xDestroy ) xDestroy(pAux);\n<line12>sqlite3_mutex_leave(db->mutex);\n<line13>return rc;\n<line14>}
----------------------------------------
Function: sqlite3_create_module
Content: <line0>SQLITE_API int sqlite3_create_module(\n<line1>sqlite3 *db,                    /* Database in which module is registered */\n<line2>const char *zName,              /* Name assigned to this module */\n<line3>const sqlite3_module *pModule,  /* The definition of the module */\n<line4>void *pAux                      /* Context pointer for xCreate/xConnect */\n<line5>){\n<line6>#ifdef SQLITE_ENABLE_API_ARMOR\n<line7>if( !sqlite3SafetyCheckOk(db) || zName==0 ) return SQLITE_MISUSE_BKPT;\n<line8>#endif\n<line9>return createModule(db, zName, pModule, pAux, 0);\n<line10>}
----------------------------------------
Function: sqlite3_create_module_v2
Content: <line0>SQLITE_API int sqlite3_create_module_v2(\n<line1>sqlite3 *db,                    /* Database in which module is registered */\n<line2>const char *zName,              /* Name assigned to this module */\n<line3>const sqlite3_module *pModule,  /* The definition of the module */\n<line4>void *pAux,                     /* Context pointer for xCreate/xConnect */\n<line5>void (*xDestroy)(void *)        /* Module destructor function */\n<line6>){\n<line7>#ifdef SQLITE_ENABLE_API_ARMOR\n<line8>if( !sqlite3SafetyCheckOk(db) || zName==0 ) return SQLITE_MISUSE_BKPT;\n<line9>#endif\n<line10>return createModule(db, zName, pModule, pAux, xDestroy);\n<line11>}
----------------------------------------
Function: sqlite3_drop_modules
Content: <line0>SQLITE_API int sqlite3_drop_modules(sqlite3 *db, const char** azNames){\n<line1>HashElem *pThis, *pNext;\n<line2>#ifdef SQLITE_ENABLE_API_ARMOR\n<line3>if( !sqlite3SafetyCheckOk(db) ) return SQLITE_MISUSE_BKPT;\n<line4>#endif\n<line5>for(pThis=sqliteHashFirst(&db->aModule); pThis; pThis=pNext){\n<line6>Module *pMod = (Module*)sqliteHashData(pThis);\n<line7>pNext = sqliteHashNext(pThis);\n<line8>if( azNames ){\n<line9>int ii;\n<line10>for(ii=0; azNames[ii]!=0 && strcmp(azNames[ii],pMod->zName)!=0; ii++){}\n<line11>if( azNames[ii]!=0 ) continue;\n<line12>}\n<line13>createModule(db, pMod->zName, 0, 0, 0);\n<line14>}\n<line15>return SQLITE_OK;\n<line16>}
----------------------------------------
Function: vtabDisconnectAll
Content: <line0>static VTable *vtabDisconnectAll(sqlite3 *db, Table *p){\n<line1>VTable *pRet = 0;\n<line2>VTable *pVTable;\n<line3>assert( IsVirtual(p) );\n<line4>pVTable = p->u.vtab.p;\n<line5>p->u.vtab.p = 0;\n<line6>/* Assert that the mutex (if any) associated with the BtShared database\n<line7>** that contains table p is held by the caller. See header comments\n<line8>** above function sqlite3VtabUnlockList() for an explanation of why\n<line9>** this makes it safe to access the sqlite3.pDisconnect list of any\n<line10>** database connection that may have an entry in the p->u.vtab.p list.\n<line11>*/\n<line12>assert( db==0 || sqlite3SchemaMutexHeld(db, 0, p->pSchema) );\n<line13>while( pVTable ){\n<line14>sqlite3 *db2 = pVTable->db;\n<line15>VTable *pNext = pVTable->pNext;\n<line16>assert( db2 );\n<line17>if( db2==db ){\n<line18>pRet = pVTable;\n<line19>p->u.vtab.p = pRet;\n<line20>pRet->pNext = 0;\n<line21>}else{\n<line22>pVTable->pNext = db2->pDisconnect;\n<line23>db2->pDisconnect = pVTable;\n<line24>}\n<line25>pVTable = pNext;\n<line26>}\n<line27>assert( !db || pRet );\n<line28>return pRet;\n<line29>}
----------------------------------------
Function: addModuleArgument
Content: <line0>static void addModuleArgument(Parse *pParse, Table *pTable, char *zArg){\n<line1>sqlite3_int64 nBytes;\n<line2>char **azModuleArg;\n<line3>sqlite3 *db = pParse->db;\n<line4>assert( IsVirtual(pTable) );\n<line5>nBytes = sizeof(char *)*(2+pTable->u.vtab.nArg);\n<line6>if( pTable->u.vtab.nArg+3>=db->aLimit[SQLITE_LIMIT_COLUMN] ){\n<line7>sqlite3ErrorMsg(pParse, "too many columns on %s", pTable->zName);\n<line8>}\n<line9>azModuleArg = sqlite3DbRealloc(db, pTable->u.vtab.azArg, nBytes);\n<line10>if( azModuleArg==0 ){\n<line11>sqlite3DbFree(db, zArg);\n<line12>}else{\n<line13>int i = pTable->u.vtab.nArg++;\n<line14>azModuleArg[i] = zArg;\n<line15>azModuleArg[i+1] = 0;\n<line16>pTable->u.vtab.azArg = azModuleArg;\n<line17>}\n<line18>}
----------------------------------------
Function: addArgumentToVtab
Content: <line0>static void addArgumentToVtab(Parse *pParse){\n<line1>if( pParse->sArg.z && pParse->pNewTable ){\n<line2>const char *z = (const char*)pParse->sArg.z;\n<line3>int n = pParse->sArg.n;\n<line4>sqlite3 *db = pParse->db;\n<line5>addModuleArgument(pParse, pParse->pNewTable, sqlite3DbStrNDup(db, z, n));\n<line6>}\n<line7>}
----------------------------------------
Function: vtabCallConstructor
Content: <line0>static int vtabCallConstructor(\n<line1>sqlite3 *db,\n<line2>Table *pTab,\n<line3>Module *pMod,\n<line4>int (*xConstruct)(sqlite3*,void*,int,const char*const*,sqlite3_vtab**,char**),\n<line5>char **pzErr\n<line6>){\n<line7>VtabCtx sCtx;\n<line8>VTable *pVTable;\n<line9>int rc;\n<line10>const char *const*azArg;\n<line11>int nArg = pTab->u.vtab.nArg;\n<line12>char *zErr = 0;\n<line13>char *zModuleName;\n<line14>int iDb;\n<line15>VtabCtx *pCtx;\n<line16>assert( IsVirtual(pTab) );\n<line17>azArg = (const char *const*)pTab->u.vtab.azArg;\n<line18>/* Check that the virtual-table is not already being initialized */\n<line19>for(pCtx=db->pVtabCtx; pCtx; pCtx=pCtx->pPrior){\n<line20>if( pCtx->pTab==pTab ){\n<line21>*pzErr = sqlite3MPrintf(db,\n<line22>"vtable constructor called recursively: %s", pTab->zName\n<line23>);\n<line24>return SQLITE_LOCKED;\n<line25>}\n<line26>}\n<line27>zModuleName = sqlite3DbStrDup(db, pTab->zName);\n<line28>if( !zModuleName ){\n<line29>return SQLITE_NOMEM_BKPT;\n<line30>}\n<line31>pVTable = sqlite3MallocZero(sizeof(VTable));\n<line32>if( !pVTable ){\n<line33>sqlite3OomFault(db);\n<line34>sqlite3DbFree(db, zModuleName);\n<line35>return SQLITE_NOMEM_BKPT;\n<line36>}\n<line37>pVTable->db = db;\n<line38>pVTable->pMod = pMod;\n<line39>pVTable->eVtabRisk = SQLITE_VTABRISK_Normal;\n<line40>iDb = sqlite3SchemaToIndex(db, pTab->pSchema);\n<line41>pTab->u.vtab.azArg[1] = db->aDb[iDb].zDbSName;\n<line42>/* Invoke the virtual table constructor */\n<line43>assert( &db->pVtabCtx );\n<line44>assert( xConstruct );\n<line45>sCtx.pTab = pTab;\n<line46>sCtx.pVTable = pVTable;\n<line47>sCtx.pPrior = db->pVtabCtx;\n<line48>sCtx.bDeclared = 0;\n<line49>db->pVtabCtx = &sCtx;\n<line50>pTab->nTabRef++;\n<line51>rc = xConstruct(db, pMod->pAux, nArg, azArg, &pVTable->pVtab, &zErr);\n<line52>assert( pTab!=0 );\n<line53>assert( pTab->nTabRef>1 || rc!=SQLITE_OK );\n<line54>sqlite3DeleteTable(db, pTab);\n<line55>db->pVtabCtx = sCtx.pPrior;\n<line56>if( rc==SQLITE_NOMEM ) sqlite3OomFault(db);\n<line57>assert( sCtx.pTab==pTab );\n<line58>if( SQLITE_OK!=rc ){\n<line59>if( zErr==0 ){\n<line60>*pzErr = sqlite3MPrintf(db, "vtable constructor failed: %s", zModuleName);\n<line61>}else {\n<line62>*pzErr = sqlite3MPrintf(db, "%s", zErr);\n<line63>sqlite3_free(zErr);\n<line64>}\n<line65>sqlite3DbFree(db, pVTable);\n<line66>}else if( ALWAYS(pVTable->pVtab) ){\n<line67>/* Justification of ALWAYS():  A correct vtab constructor must allocate\n<line68>** the sqlite3_vtab object if successful.  */\n<line69>memset(pVTable->pVtab, 0, sizeof(pVTable->pVtab[0]));\n<line70>pVTable->pVtab->pModule = pMod->pModule;\n<line71>pMod->nRefModule++;\n<line72>pVTable->nRef = 1;\n<line73>if( sCtx.bDeclared==0 ){\n<line74>const char *zFormat = "vtable constructor did not declare schema: %s";\n<line75>*pzErr = sqlite3MPrintf(db, zFormat, zModuleName);\n<line76>sqlite3VtabUnlock(pVTable);\n<line77>rc = SQLITE_ERROR;\n<line78>}else{\n<line79>int iCol;\n<line80>u16 oooHidden = 0;\n<line81>/* If everything went according to plan, link the new VTable structure\n<line82>** into the linked list headed by pTab->u.vtab.p. Then loop through the\n<line83>** columns of the table to see if any of them contain the token "hidden".\n<line84>** If so, set the Column COLFLAG_HIDDEN flag and remove the token from\n<line85>** the type string.  */\n<line86>pVTable->pNext = pTab->u.vtab.p;\n<line87>pTab->u.vtab.p = pVTable;\n<line88>for(iCol=0; iCol<pTab->nCol; iCol++){\n<line89>char *zType = sqlite3ColumnType(&pTab->aCol[iCol], "");\n<line90>int nType;\n<line91>int i = 0;\n<line92>nType = sqlite3Strlen30(zType);\n<line93>for(i=0; i<nType; i++){\n<line94>if( 0==sqlite3StrNICmp("hidden", &zType[i], 6)\n<line95>&& (i==0 || zType[i-1]==' ')\n<line96>&& (zType[i+6]=='\0' || zType[i+6]==' ')\n<line97>){\n<line98>break;\n<line99>}\n<line100>}\n<line101>if( i<nType ){\n<line102>int j;\n<line103>int nDel = 6 + (zType[i+6] ? 1 : 0);\n<line104>for(j=i; (j+nDel)<=nType; j++){\n<line105>zType[j] = zType[j+nDel];\n<line106>}\n<line107>if( zType[i]=='\0' && i>0 ){\n<line108>assert(zType[i-1]==' ');\n<line109>zType[i-1] = '\0';\n<line110>}\n<line111>pTab->aCol[iCol].colFlags |= COLFLAG_HIDDEN;\n<line112>pTab->tabFlags |= TF_HasHidden;\n<line113>oooHidden = TF_OOOHidden;\n<line114>}else{\n<line115>pTab->tabFlags |= oooHidden;\n<line116>}\n<line117>}\n<line118>}\n<line119>}\n<line120>sqlite3DbFree(db, zModuleName);\n<line121>return rc;\n<line122>}
----------------------------------------
Function: growVTrans
Content: <line0>static int growVTrans(sqlite3 *db){\n<line1>const int ARRAY_INCR = 5;\n<line2>/* Grow the sqlite3.aVTrans array if required */\n<line3>if( (db->nVTrans%ARRAY_INCR)==0 ){\n<line4>VTable **aVTrans;\n<line5>sqlite3_int64 nBytes = sizeof(sqlite3_vtab*)*\n<line6>((sqlite3_int64)db->nVTrans + ARRAY_INCR);\n<line7>aVTrans = sqlite3DbRealloc(db, (void *)db->aVTrans, nBytes);\n<line8>if( !aVTrans ){\n<line9>return SQLITE_NOMEM_BKPT;\n<line10>}\n<line11>memset(&aVTrans[db->nVTrans], 0, sizeof(sqlite3_vtab *)*ARRAY_INCR);\n<line12>db->aVTrans = aVTrans;\n<line13>}\n<line14>return SQLITE_OK;\n<line15>}
----------------------------------------
Function: addToVTrans
Content: <line0>static void addToVTrans(sqlite3 *db, VTable *pVTab){\n<line1>/* Add pVtab to the end of sqlite3.aVTrans */\n<line2>db->aVTrans[db->nVTrans++] = pVTab;\n<line3>sqlite3VtabLock(pVTab);\n<line4>}
----------------------------------------
Function: sqlite3_declare_vtab
Content: <line0>SQLITE_API int sqlite3_declare_vtab(sqlite3 *db, const char *zCreateTable){\n<line1>VtabCtx *pCtx;\n<line2>int rc = SQLITE_OK;\n<line3>Table *pTab;\n<line4>Parse sParse;\n<line5>int initBusy;\n<line6>int i;\n<line7>const unsigned char *z;\n<line8>static const u8 aKeyword[] = { TK_CREATE, TK_TABLE, 0 };\n<line9>#ifdef SQLITE_ENABLE_API_ARMOR\n<line10>if( !sqlite3SafetyCheckOk(db) || zCreateTable==0 ){\n<line11>return SQLITE_MISUSE_BKPT;\n<line12>}\n<line13>#endif\n<line14>/* Verify that the first two keywords in the CREATE TABLE statement\n<line15>** really are "CREATE" and "TABLE".  If this is not the case, then\n<line16>** sqlite3_declare_vtab() is being misused.\n<line17>*/\n<line18>z = (const unsigned char*)zCreateTable;\n<line19>for(i=0; aKeyword[i]; i++){\n<line20>int tokenType = 0;\n<line21>do{\n<line22>z += sqlite3GetToken(z, &tokenType);\n<line23>}while( tokenType==TK_SPACE || tokenType==TK_COMMENT );\n<line24>if( tokenType!=aKeyword[i] ){\n<line25>sqlite3ErrorWithMsg(db, SQLITE_ERROR, "syntax error");\n<line26>return SQLITE_ERROR;\n<line27>}\n<line28>}\n<line29>sqlite3_mutex_enter(db->mutex);\n<line30>pCtx = db->pVtabCtx;\n<line31>if( !pCtx || pCtx->bDeclared ){\n<line32>sqlite3Error(db, SQLITE_MISUSE_BKPT);\n<line33>sqlite3_mutex_leave(db->mutex);\n<line34>return SQLITE_MISUSE_BKPT;\n<line35>}\n<line36>pTab = pCtx->pTab;\n<line37>assert( IsVirtual(pTab) );\n<line38>sqlite3ParseObjectInit(&sParse, db);\n<line39>sParse.eParseMode = PARSE_MODE_DECLARE_VTAB;\n<line40>sParse.disableTriggers = 1;\n<line41>/* We should never be able to reach this point while loading the\n<line42>** schema.  Nevertheless, defend against that (turn off db->init.busy)\n<line43>** in case a bug arises. */\n<line44>assert( db->init.busy==0 );\n<line45>initBusy = db->init.busy;\n<line46>db->init.busy = 0;\n<line47>sParse.nQueryLoop = 1;\n<line48>if( SQLITE_OK==sqlite3RunParser(&sParse, zCreateTable) ){\n<line49>assert( sParse.pNewTable!=0 );\n<line50>assert( !db->mallocFailed );\n<line51>assert( IsOrdinaryTable(sParse.pNewTable) );\n<line52>assert( sParse.zErrMsg==0 );\n<line53>if( !pTab->aCol ){\n<line54>Table *pNew = sParse.pNewTable;\n<line55>Index *pIdx;\n<line56>pTab->aCol = pNew->aCol;\n<line57>assert( IsOrdinaryTable(pNew) );\n<line58>sqlite3ExprListDelete(db, pNew->u.tab.pDfltList);\n<line59>pTab->nNVCol = pTab->nCol = pNew->nCol;\n<line60>pTab->tabFlags |= pNew->tabFlags & (TF_WithoutRowid|TF_NoVisibleRowid);\n<line61>pNew->nCol = 0;\n<line62>pNew->aCol = 0;\n<line63>assert( pTab->pIndex==0 );\n<line64>assert( HasRowid(pNew) || sqlite3PrimaryKeyIndex(pNew)!=0 );\n<line65>if( !HasRowid(pNew)\n<line66>&& pCtx->pVTable->pMod->pModule->xUpdate!=0\n<line67>&& sqlite3PrimaryKeyIndex(pNew)->nKeyCol!=1\n<line68>){\n<line69>/* WITHOUT ROWID virtual tables must either be read-only (xUpdate==0)\n<line70>** or else must have a single-column PRIMARY KEY */\n<line71>rc = SQLITE_ERROR;\n<line72>}\n<line73>pIdx = pNew->pIndex;\n<line74>if( pIdx ){\n<line75>assert( pIdx->pNext==0 );\n<line76>pTab->pIndex = pIdx;\n<line77>pNew->pIndex = 0;\n<line78>pIdx->pTable = pTab;\n<line79>}\n<line80>}\n<line81>pCtx->bDeclared = 1;\n<line82>}else{\n<line83>sqlite3ErrorWithMsg(db, SQLITE_ERROR,\n<line84>(sParse.zErrMsg ? "%s" : 0), sParse.zErrMsg);\n<line85>sqlite3DbFree(db, sParse.zErrMsg);\n<line86>rc = SQLITE_ERROR;\n<line87>}\n<line88>sParse.eParseMode = PARSE_MODE_NORMAL;\n<line89>if( sParse.pVdbe ){\n<line90>sqlite3VdbeFinalize(sParse.pVdbe);\n<line91>}\n<line92>sqlite3DeleteTable(db, sParse.pNewTable);\n<line93>sqlite3ParseObjectReset(&sParse);\n<line94>db->init.busy = initBusy;\n<line95>assert( (rc&0xff)==rc );\n<line96>rc = sqlite3ApiExit(db, rc);\n<line97>sqlite3_mutex_leave(db->mutex);\n<line98>return rc;\n<line99>}
----------------------------------------
Function: callFinaliser
Content: <line0>static void callFinaliser(sqlite3 *db, int offset){\n<line1>int i;\n<line2>if( db->aVTrans ){\n<line3>VTable **aVTrans = db->aVTrans;\n<line4>db->aVTrans = 0;\n<line5>for(i=0; i<db->nVTrans; i++){\n<line6>VTable *pVTab = aVTrans[i];\n<line7>sqlite3_vtab *p = pVTab->pVtab;\n<line8>if( p ){\n<line9>int (*x)(sqlite3_vtab *);\n<line10>x = *(int (**)(sqlite3_vtab *))((char *)p->pModule + offset);\n<line11>if( x ) x(p);\n<line12>}\n<line13>pVTab->iSavepoint = 0;\n<line14>sqlite3VtabUnlock(pVTab);\n<line15>}\n<line16>sqlite3DbFree(db, aVTrans);\n<line17>db->nVTrans = 0;\n<line18>}\n<line19>}
----------------------------------------
Function: sqlite3_vtab_on_conflict
Content: <line0>SQLITE_API int sqlite3_vtab_on_conflict(sqlite3 *db){\n<line1>static const unsigned char aMap[] = {\n<line2>SQLITE_ROLLBACK, SQLITE_ABORT, SQLITE_FAIL, SQLITE_IGNORE, SQLITE_REPLACE\n<line3>};\n<line4>#ifdef SQLITE_ENABLE_API_ARMOR\n<line5>if( !sqlite3SafetyCheckOk(db) ) return SQLITE_MISUSE_BKPT;\n<line6>#endif\n<line7>assert( OE_Rollback==1 && OE_Abort==2 && OE_Fail==3 );\n<line8>assert( OE_Ignore==4 && OE_Replace==5 );\n<line9>assert( db->vtabOnConflict>=1 && db->vtabOnConflict<=5 );\n<line10>return (int)aMap[db->vtabOnConflict-1];\n<line11>}
----------------------------------------
Function: sqlite3_vtab_config
Content: <line0>SQLITE_API int sqlite3_vtab_config(sqlite3 *db, int op, ...){\n<line1>va_list ap;\n<line2>int rc = SQLITE_OK;\n<line3>VtabCtx *p;\n<line4>#ifdef SQLITE_ENABLE_API_ARMOR\n<line5>if( !sqlite3SafetyCheckOk(db) ) return SQLITE_MISUSE_BKPT;\n<line6>#endif\n<line7>sqlite3_mutex_enter(db->mutex);\n<line8>p = db->pVtabCtx;\n<line9>if( !p ){\n<line10>rc = SQLITE_MISUSE_BKPT;\n<line11>}else{\n<line12>assert( p->pTab==0 || IsVirtual(p->pTab) );\n<line13>va_start(ap, op);\n<line14>switch( op ){\n<line15>case SQLITE_VTAB_CONSTRAINT_SUPPORT: {\n<line16>p->pVTable->bConstraint = (u8)va_arg(ap, int);\n<line17>break;\n<line18>}\n<line19>case SQLITE_VTAB_INNOCUOUS: {\n<line20>p->pVTable->eVtabRisk = SQLITE_VTABRISK_Low;\n<line21>break;\n<line22>}\n<line23>case SQLITE_VTAB_DIRECTONLY: {\n<line24>p->pVTable->eVtabRisk = SQLITE_VTABRISK_High;\n<line25>break;\n<line26>}\n<line27>case SQLITE_VTAB_USES_ALL_SCHEMAS: {\n<line28>p->pVTable->bAllSchemas = 1;\n<line29>break;\n<line30>}\n<line31>default: {\n<line32>rc = SQLITE_MISUSE_BKPT;\n<line33>break;\n<line34>}\n<line35>}\n<line36>va_end(ap);\n<line37>}\n<line38>if( rc!=SQLITE_OK ) sqlite3Error(db, rc);\n<line39>sqlite3_mutex_leave(db->mutex);\n<line40>return rc;\n<line41>}
----------------------------------------
Function: explainIndexColumnName
Content: <line0>static const char *explainIndexColumnName(Index *pIdx, int i){\n<line1>i = pIdx->aiColumn[i];\n<line2>if( i==XN_EXPR ) return "<expr>";\n<line3>if( i==XN_ROWID ) return "rowid";\n<line4>return pIdx->pTable->aCol[i].zCnName;\n<line5>}
----------------------------------------
Function: explainAppendTerm
Content: <line0>static void explainAppendTerm(\n<line1>StrAccum *pStr,             /* The text expression being built */\n<line2>Index *pIdx,                /* Index to read column names from */\n<line3>int nTerm,                  /* Number of terms */\n<line4>int iTerm,                  /* Zero-based index of first term. */\n<line5>int bAnd,                   /* Non-zero to append " AND " */\n<line6>const char *zOp             /* Name of the operator */\n<line7>){\n<line8>int i;\n<line9>assert( nTerm>=1 );\n<line10>if( bAnd ) sqlite3_str_append(pStr, " AND ", 5);\n<line11>if( nTerm>1 ) sqlite3_str_append(pStr, "(", 1);\n<line12>for(i=0; i<nTerm; i++){\n<line13>if( i ) sqlite3_str_append(pStr, ",", 1);\n<line14>sqlite3_str_appendall(pStr, explainIndexColumnName(pIdx, iTerm+i));\n<line15>}\n<line16>if( nTerm>1 ) sqlite3_str_append(pStr, ")", 1);\n<line17>sqlite3_str_append(pStr, zOp, 1);\n<line18>if( nTerm>1 ) sqlite3_str_append(pStr, "(", 1);\n<line19>for(i=0; i<nTerm; i++){\n<line20>if( i ) sqlite3_str_append(pStr, ",", 1);\n<line21>sqlite3_str_append(pStr, "?", 1);\n<line22>}\n<line23>if( nTerm>1 ) sqlite3_str_append(pStr, ")", 1);\n<line24>}
----------------------------------------
Function: explainIndexRange
Content: <line0>static void explainIndexRange(StrAccum *pStr, WhereLoop *pLoop){\n<line1>Index *pIndex = pLoop->u.btree.pIndex;\n<line2>u16 nEq = pLoop->u.btree.nEq;\n<line3>u16 nSkip = pLoop->nSkip;\n<line4>int i, j;\n<line5>if( nEq==0 && (pLoop->wsFlags&(WHERE_BTM_LIMIT|WHERE_TOP_LIMIT))==0 ) return;\n<line6>sqlite3_str_append(pStr, " (", 2);\n<line7>for(i=0; i<nEq; i++){\n<line8>const char *z = explainIndexColumnName(pIndex, i);\n<line9>if( i ) sqlite3_str_append(pStr, " AND ", 5);\n<line10>sqlite3_str_appendf(pStr, i>=nSkip ? "%s=?" : "ANY(%s)", z);\n<line11>}\n<line12>j = i;\n<line13>if( pLoop->wsFlags&WHERE_BTM_LIMIT ){\n<line14>explainAppendTerm(pStr, pIndex, pLoop->u.btree.nBtm, j, i, ">");\n<line15>i = 1;\n<line16>}\n<line17>if( pLoop->wsFlags&WHERE_TOP_LIMIT ){\n<line18>explainAppendTerm(pStr, pIndex, pLoop->u.btree.nTop, j, i, "<");\n<line19>}\n<line20>sqlite3_str_append(pStr, ")", 1);\n<line21>}
----------------------------------------
Function: disableTerm
Content: <line0>static void disableTerm(WhereLevel *pLevel, WhereTerm *pTerm){\n<line1>int nLoop = 0;\n<line2>assert( pTerm!=0 );\n<line3>while( (pTerm->wtFlags & TERM_CODED)==0\n<line4>&& (pLevel->iLeftJoin==0 || ExprHasProperty(pTerm->pExpr, EP_OuterON))\n<line5>&& (pLevel->notReady & pTerm->prereqAll)==0\n<line6>){\n<line7>if( nLoop && (pTerm->wtFlags & TERM_LIKE)!=0 ){\n<line8>pTerm->wtFlags |= TERM_LIKECOND;\n<line9>}else{\n<line10>pTerm->wtFlags |= TERM_CODED;\n<line11>}\n<line12>#ifdef WHERETRACE_ENABLED\n<line13>if( (sqlite3WhereTrace & 0x4001)==0x4001 ){\n<line14>sqlite3DebugPrintf("DISABLE-");\n<line15>sqlite3WhereTermPrint(pTerm, (int)(pTerm - (pTerm->pWC->a)));\n<line16>}\n<line17>#endif\n<line18>if( pTerm->iParent<0 ) break;\n<line19>pTerm = &pTerm->pWC->a[pTerm->iParent];\n<line20>assert( pTerm!=0 );\n<line21>pTerm->nChild--;\n<line22>if( pTerm->nChild!=0 ) break;\n<line23>nLoop++;\n<line24>}\n<line25>}
----------------------------------------
Function: codeApplyAffinity
Content: <line0>static void codeApplyAffinity(Parse *pParse, int base, int n, char *zAff){\n<line1>Vdbe *v = pParse->pVdbe;\n<line2>if( zAff==0 ){\n<line3>assert( pParse->db->mallocFailed );\n<line4>return;\n<line5>}\n<line6>assert( v!=0 );\n<line7>/* Adjust base and n to skip over SQLITE_AFF_BLOB and SQLITE_AFF_NONE\n<line8>** entries at the beginning and end of the affinity string.\n<line9>*/\n<line10>assert( SQLITE_AFF_NONE<SQLITE_AFF_BLOB );\n<line11>while( n>0 && zAff[0]<=SQLITE_AFF_BLOB ){\n<line12>n--;\n<line13>base++;\n<line14>zAff++;\n<line15>}\n<line16>while( n>1 && zAff[n-1]<=SQLITE_AFF_BLOB ){\n<line17>n--;\n<line18>}\n<line19>/* Code the OP_Affinity opcode if there is anything left to do. */\n<line20>if( n>0 ){\n<line21>sqlite3VdbeAddOp4(v, OP_Affinity, base, n, 0, zAff, n);\n<line22>}\n<line23>}
----------------------------------------
Function: updateRangeAffinityStr
Content: <line0>static void updateRangeAffinityStr(\n<line1>Expr *pRight,                   /* RHS of comparison */\n<line2>int n,                          /* Number of vector elements in comparison */\n<line3>char *zAff                      /* Affinity string to modify */\n<line4>){\n<line5>int i;\n<line6>for(i=0; i<n; i++){\n<line7>Expr *p = sqlite3VectorFieldSubexpr(pRight, i);\n<line8>if( sqlite3CompareAffinity(p, zAff[i])==SQLITE_AFF_BLOB\n<line9>|| sqlite3ExprNeedsNoAffinityChange(p, zAff[i])\n<line10>){\n<line11>zAff[i] = SQLITE_AFF_BLOB;\n<line12>}\n<line13>}\n<line14>}
----------------------------------------
Function: adjustOrderByCol
Content: <line0>static void adjustOrderByCol(ExprList *pOrderBy, ExprList *pEList){\n<line1>int i, j;\n<line2>if( pOrderBy==0 ) return;\n<line3>for(i=0; i<pOrderBy->nExpr; i++){\n<line4>int t = pOrderBy->a[i].u.x.iOrderByCol;\n<line5>if( t==0 ) continue;\n<line6>for(j=0; j<pEList->nExpr; j++){\n<line7>if( pEList->a[j].u.x.iOrderByCol==t ){\n<line8>pOrderBy->a[i].u.x.iOrderByCol = j+1;\n<line9>break;\n<line10>}\n<line11>}\n<line12>if( j>=pEList->nExpr ){\n<line13>pOrderBy->a[i].u.x.iOrderByCol = 0;\n<line14>}\n<line15>}\n<line16>}
----------------------------------------
Function: removeUnindexableInClauseTerms
Content: <line0>static Expr *removeUnindexableInClauseTerms(\n<line1>Parse *pParse,        /* The parsing context */\n<line2>int iEq,              /* Look at loop terms starting here */\n<line3>WhereLoop *pLoop,     /* The current loop */\n<line4>Expr *pX              /* The IN expression to be reduced */\n<line5>){\n<line6>sqlite3 *db = pParse->db;\n<line7>Select *pSelect;            /* Pointer to the SELECT on the RHS */\n<line8>Expr *pNew;\n<line9>pNew = sqlite3ExprDup(db, pX, 0);\n<line10>if( db->mallocFailed==0 ){\n<line11>for(pSelect=pNew->x.pSelect; pSelect; pSelect=pSelect->pPrior){\n<line12>ExprList *pOrigRhs;         /* Original unmodified RHS */\n<line13>ExprList *pOrigLhs = 0;     /* Original unmodified LHS */\n<line14>ExprList *pRhs = 0;         /* New RHS after modifications */\n<line15>ExprList *pLhs = 0;         /* New LHS after mods */\n<line16>int i;                      /* Loop counter */\n<line17>assert( ExprUseXSelect(pNew) );\n<line18>pOrigRhs = pSelect->pEList;\n<line19>assert( pNew->pLeft!=0 );\n<line20>assert( ExprUseXList(pNew->pLeft) );\n<line21>if( pSelect==pNew->x.pSelect ){\n<line22>pOrigLhs = pNew->pLeft->x.pList;\n<line23>}\n<line24>for(i=iEq; i<pLoop->nLTerm; i++){\n<line25>if( pLoop->aLTerm[i]->pExpr==pX ){\n<line26>int iField;\n<line27>assert( (pLoop->aLTerm[i]->eOperator & (WO_OR|WO_AND))==0 );\n<line28>iField = pLoop->aLTerm[i]->u.x.iField - 1;\n<line29>if( NEVER(pOrigRhs->a[iField].pExpr==0) ){\n<line30>continue; /* Duplicate PK column */\n<line31>}\n<line32>pRhs = sqlite3ExprListAppend(pParse, pRhs, pOrigRhs->a[iField].pExpr);\n<line33>pOrigRhs->a[iField].pExpr = 0;\n<line34>if( pRhs ) pRhs->a[pRhs->nExpr-1].u.x.iOrderByCol = iField+1;\n<line35>if( pOrigLhs ){\n<line36>assert( pOrigLhs->a[iField].pExpr!=0 );\n<line37>pLhs = sqlite3ExprListAppend(pParse,pLhs,pOrigLhs->a[iField].pExpr);\n<line38>pOrigLhs->a[iField].pExpr = 0;\n<line39>}\n<line40>}\n<line41>}\n<line42>sqlite3ExprListDelete(db, pOrigRhs);\n<line43>if( pOrigLhs ){\n<line44>sqlite3ExprListDelete(db, pOrigLhs);\n<line45>pNew->pLeft->x.pList = pLhs;\n<line46>}\n<line47>pSelect->pEList = pRhs;\n<line48>pSelect->selId = ++pParse->nSelect; /* Req'd for SubrtnSig validity */\n<line49>if( pLhs && pLhs->nExpr==1 ){\n<line50>/* Take care here not to generate a TK_VECTOR containing only a\n<line51>** single value. Since the parser never creates such a vector, some\n<line52>** of the subroutines do not handle this case.  */\n<line53>Expr *p = pLhs->a[0].pExpr;\n<line54>pLhs->a[0].pExpr = 0;\n<line55>sqlite3ExprDelete(db, pNew->pLeft);\n<line56>pNew->pLeft = p;\n<line57>}\n<line58>/* If either the ORDER BY clause or the GROUP BY clause contains\n<line59>** references to result-set columns, those references might now be\n<line60>** obsolete.  So fix them up.\n<line61>*/\n<line62>assert( pRhs!=0 || db->mallocFailed );\n<line63>if( pRhs ){\n<line64>adjustOrderByCol(pSelect->pOrderBy, pRhs);\n<line65>adjustOrderByCol(pSelect->pGroupBy, pRhs);\n<line66>for(i=0; i<pRhs->nExpr; i++) pRhs->a[i].u.x.iOrderByCol = 0;\n<line67>}\n<line68>#if 0\n<line69>printf("For indexing, change the IN expr:\n");\n<line70>sqlite3TreeViewExpr(0, pX, 0);\n<line71>printf("Into:\n");\n<line72>sqlite3TreeViewExpr(0, pNew, 0);\n<line73>#endif\n<line74>}\n<line75>}\n<line76>return pNew;\n<line77>}
----------------------------------------
Function: codeINTerm
Content: <line0>static SQLITE_NOINLINE void codeINTerm(\n<line1>Parse *pParse,      /* The parsing context */\n<line2>WhereTerm *pTerm,   /* The term of the WHERE clause to be coded */\n<line3>WhereLevel *pLevel, /* The level of the FROM clause we are working on */\n<line4>int iEq,            /* Index of the equality term within this level */\n<line5>int bRev,           /* True for reverse-order IN operations */\n<line6>int iTarget         /* Attempt to leave results in this register */\n<line7>){\n<line8>Expr *pX = pTerm->pExpr;\n<line9>int eType = IN_INDEX_NOOP;\n<line10>int iTab;\n<line11>struct InLoop *pIn;\n<line12>WhereLoop *pLoop = pLevel->pWLoop;\n<line13>Vdbe *v = pParse->pVdbe;\n<line14>int i;\n<line15>int nEq = 0;\n<line16>int *aiMap = 0;\n<line17>if( (pLoop->wsFlags & WHERE_VIRTUALTABLE)==0\n<line18>&& pLoop->u.btree.pIndex!=0\n<line19>&& pLoop->u.btree.pIndex->aSortOrder[iEq]\n<line20>){\n<line21>testcase( iEq==0 );\n<line22>testcase( bRev );\n<line23>bRev = !bRev;\n<line24>}\n<line25>assert( pX->op==TK_IN );\n<line26>for(i=0; i<iEq; i++){\n<line27>if( pLoop->aLTerm[i] && pLoop->aLTerm[i]->pExpr==pX ){\n<line28>disableTerm(pLevel, pTerm);\n<line29>return;\n<line30>}\n<line31>}\n<line32>for(i=iEq; i<pLoop->nLTerm; i++){\n<line33>assert( pLoop->aLTerm[i]!=0 );\n<line34>if( pLoop->aLTerm[i]->pExpr==pX ) nEq++;\n<line35>}\n<line36>iTab = 0;\n<line37>if( !ExprUseXSelect(pX) || pX->x.pSelect->pEList->nExpr==1 ){\n<line38>eType = sqlite3FindInIndex(pParse, pX, IN_INDEX_LOOP, 0, 0, &iTab);\n<line39>}else{\n<line40>sqlite3 *db = pParse->db;\n<line41>Expr *pXMod = removeUnindexableInClauseTerms(pParse, iEq, pLoop, pX);\n<line42>if( !db->mallocFailed ){\n<line43>aiMap = (int*)sqlite3DbMallocZero(db, sizeof(int)*nEq);\n<line44>eType = sqlite3FindInIndex(pParse, pXMod, IN_INDEX_LOOP, 0, aiMap, &iTab);\n<line45>}\n<line46>sqlite3ExprDelete(db, pXMod);\n<line47>}\n<line48>if( eType==IN_INDEX_INDEX_DESC ){\n<line49>testcase( bRev );\n<line50>bRev = !bRev;\n<line51>}\n<line52>sqlite3VdbeAddOp2(v, bRev ? OP_Last : OP_Rewind, iTab, 0);\n<line53>VdbeCoverageIf(v, bRev);\n<line54>VdbeCoverageIf(v, !bRev);\n<line55>assert( (pLoop->wsFlags & WHERE_MULTI_OR)==0 );\n<line56>pLoop->wsFlags |= WHERE_IN_ABLE;\n<line57>if( pLevel->u.in.nIn==0 ){\n<line58>pLevel->addrNxt = sqlite3VdbeMakeLabel(pParse);\n<line59>}\n<line60>if( iEq>0 && (pLoop->wsFlags & WHERE_IN_SEEKSCAN)==0 ){\n<line61>pLoop->wsFlags |= WHERE_IN_EARLYOUT;\n<line62>}\n<line63>i = pLevel->u.in.nIn;\n<line64>pLevel->u.in.nIn += nEq;\n<line65>pLevel->u.in.aInLoop =\n<line66>sqlite3WhereRealloc(pTerm->pWC->pWInfo,\n<line67>pLevel->u.in.aInLoop,\n<line68>sizeof(pLevel->u.in.aInLoop[0])*pLevel->u.in.nIn);\n<line69>pIn = pLevel->u.in.aInLoop;\n<line70>if( pIn ){\n<line71>int iMap = 0;               /* Index in aiMap[] */\n<line72>pIn += i;\n<line73>for(i=iEq; i<pLoop->nLTerm; i++){\n<line74>if( pLoop->aLTerm[i]->pExpr==pX ){\n<line75>int iOut = iTarget + i - iEq;\n<line76>if( eType==IN_INDEX_ROWID ){\n<line77>pIn->addrInTop = sqlite3VdbeAddOp2(v, OP_Rowid, iTab, iOut);\n<line78>}else{\n<line79>int iCol = aiMap ? aiMap[iMap++] : 0;\n<line80>pIn->addrInTop = sqlite3VdbeAddOp3(v,OP_Column,iTab, iCol, iOut);\n<line81>}\n<line82>sqlite3VdbeAddOp1(v, OP_IsNull, iOut); VdbeCoverage(v);\n<line83>if( i==iEq ){\n<line84>pIn->iCur = iTab;\n<line85>pIn->eEndLoopOp = bRev ? OP_Prev : OP_Next;\n<line86>if( iEq>0 ){\n<line87>pIn->iBase = iTarget - i;\n<line88>pIn->nPrefix = i;\n<line89>}else{\n<line90>pIn->nPrefix = 0;\n<line91>}\n<line92>}else{\n<line93>pIn->eEndLoopOp = OP_Noop;\n<line94>}\n<line95>pIn++;\n<line96>}\n<line97>}\n<line98>testcase( iEq>0\n<line99>&& (pLoop->wsFlags & WHERE_IN_SEEKSCAN)==0\n<line100>&& (pLoop->wsFlags & WHERE_VIRTUALTABLE)!=0 );\n<line101>if( iEq>0\n<line102>&& (pLoop->wsFlags & (WHERE_IN_SEEKSCAN|WHERE_VIRTUALTABLE))==0\n<line103>){\n<line104>sqlite3VdbeAddOp3(v, OP_SeekHit, pLevel->iIdxCur, 0, iEq);\n<line105>}\n<line106>}else{\n<line107>pLevel->u.in.nIn = 0;\n<line108>}\n<line109>sqlite3DbFree(pParse->db, aiMap);\n<line110>}
----------------------------------------
Function: codeEqualityTerm
Content: <line0>static int codeEqualityTerm(\n<line1>Parse *pParse,      /* The parsing context */\n<line2>WhereTerm *pTerm,   /* The term of the WHERE clause to be coded */\n<line3>WhereLevel *pLevel, /* The level of the FROM clause we are working on */\n<line4>int iEq,            /* Index of the equality term within this level */\n<line5>int bRev,           /* True for reverse-order IN operations */\n<line6>int iTarget         /* Attempt to leave results in this register */\n<line7>){\n<line8>Expr *pX = pTerm->pExpr;\n<line9>int iReg;                  /* Register holding results */\n<line10>assert( pLevel->pWLoop->aLTerm[iEq]==pTerm );\n<line11>assert( iTarget>0 );\n<line12>if( pX->op==TK_EQ || pX->op==TK_IS ){\n<line13>iReg = sqlite3ExprCodeTarget(pParse, pX->pRight, iTarget);\n<line14>}else if( pX->op==TK_ISNULL ){\n<line15>iReg = iTarget;\n<line16>sqlite3VdbeAddOp2(pParse->pVdbe, OP_Null, 0, iReg);\n<line17>#ifndef SQLITE_OMIT_SUBQUERY\n<line18>}else{\n<line19>assert( pX->op==TK_IN );\n<line20>iReg = iTarget;\n<line21>codeINTerm(pParse, pTerm, pLevel, iEq, bRev, iTarget);\n<line22>#endif\n<line23>}\n<line24>/* As an optimization, try to disable the WHERE clause term that is\n<line25>** driving the index as it will always be true.  The correct answer is\n<line26>** obtained regardless, but we might get the answer with fewer CPU cycles\n<line27>** by omitting the term.\n<line28>**\n<line29>** But do not disable the term unless we are certain that the term is\n<line30>** not a transitive constraint.  For an example of where that does not\n<line31>** work, see https://sqlite.org/forum/forumpost/eb8613976a (2021-05-04)\n<line32>*/\n<line33>if( (pLevel->pWLoop->wsFlags & WHERE_TRANSCONS)==0\n<line34>|| (pTerm->eOperator & WO_EQUIV)==0\n<line35>){\n<line36>disableTerm(pLevel, pTerm);\n<line37>}\n<line38>return iReg;\n<line39>}
----------------------------------------
Function: codeAllEqualityTerms
Content: <line0>static int codeAllEqualityTerms(\n<line1>Parse *pParse,        /* Parsing context */\n<line2>WhereLevel *pLevel,   /* Which nested loop of the FROM we are coding */\n<line3>int bRev,             /* Reverse the order of IN operators */\n<line4>int nExtraReg,        /* Number of extra registers to allocate */\n<line5>char **pzAff          /* OUT: Set to point to affinity string */\n<line6>){\n<line7>u16 nEq;                      /* The number of == or IN constraints to code */\n<line8>u16 nSkip;                    /* Number of left-most columns to skip */\n<line9>Vdbe *v = pParse->pVdbe;      /* The vm under construction */\n<line10>Index *pIdx;                  /* The index being used for this loop */\n<line11>WhereTerm *pTerm;             /* A single constraint term */\n<line12>WhereLoop *pLoop;             /* The WhereLoop object */\n<line13>int j;                        /* Loop counter */\n<line14>int regBase;                  /* Base register */\n<line15>int nReg;                     /* Number of registers to allocate */\n<line16>char *zAff;                   /* Affinity string to return */\n<line17>/* This module is only called on query plans that use an index. */\n<line18>pLoop = pLevel->pWLoop;\n<line19>assert( (pLoop->wsFlags & WHERE_VIRTUALTABLE)==0 );\n<line20>nEq = pLoop->u.btree.nEq;\n<line21>nSkip = pLoop->nSkip;\n<line22>pIdx = pLoop->u.btree.pIndex;\n<line23>assert( pIdx!=0 );\n<line24>/* Figure out how many memory cells we will need then allocate them.\n<line25>*/\n<line26>regBase = pParse->nMem + 1;\n<line27>nReg = nEq + nExtraReg;\n<line28>pParse->nMem += nReg;\n<line29>zAff = sqlite3DbStrDup(pParse->db,sqlite3IndexAffinityStr(pParse->db,pIdx));\n<line30>assert( zAff!=0 || pParse->db->mallocFailed );\n<line31>if( nSkip ){\n<line32>int iIdxCur = pLevel->iIdxCur;\n<line33>sqlite3VdbeAddOp3(v, OP_Null, 0, regBase, regBase+nSkip-1);\n<line34>sqlite3VdbeAddOp1(v, (bRev?OP_Last:OP_Rewind), iIdxCur);\n<line35>VdbeCoverageIf(v, bRev==0);\n<line36>VdbeCoverageIf(v, bRev!=0);\n<line37>VdbeComment((v, "begin skip-scan on %s", pIdx->zName));\n<line38>j = sqlite3VdbeAddOp0(v, OP_Goto);\n<line39>assert( pLevel->addrSkip==0 );\n<line40>pLevel->addrSkip = sqlite3VdbeAddOp4Int(v, (bRev?OP_SeekLT:OP_SeekGT),\n<line41>iIdxCur, 0, regBase, nSkip);\n<line42>VdbeCoverageIf(v, bRev==0);\n<line43>VdbeCoverageIf(v, bRev!=0);\n<line44>sqlite3VdbeJumpHere(v, j);\n<line45>for(j=0; j<nSkip; j++){\n<line46>sqlite3VdbeAddOp3(v, OP_Column, iIdxCur, j, regBase+j);\n<line47>testcase( pIdx->aiColumn[j]==XN_EXPR );\n<line48>VdbeComment((v, "%s", explainIndexColumnName(pIdx, j)));\n<line49>}\n<line50>}\n<line51>/* Evaluate the equality constraints\n<line52>*/\n<line53>assert( zAff==0 || (int)strlen(zAff)>=nEq );\n<line54>for(j=nSkip; j<nEq; j++){\n<line55>int r1;\n<line56>pTerm = pLoop->aLTerm[j];\n<line57>assert( pTerm!=0 );\n<line58>/* The following testcase is true for indices with redundant columns.\n<line59>** Ex: CREATE INDEX i1 ON t1(a,b,a); SELECT * FROM t1 WHERE a=0 AND b=0; */\n<line60>testcase( (pTerm->wtFlags & TERM_CODED)!=0 );\n<line61>testcase( pTerm->wtFlags & TERM_VIRTUAL );\n<line62>r1 = codeEqualityTerm(pParse, pTerm, pLevel, j, bRev, regBase+j);\n<line63>if( r1!=regBase+j ){\n<line64>if( nReg==1 ){\n<line65>sqlite3ReleaseTempReg(pParse, regBase);\n<line66>regBase = r1;\n<line67>}else{\n<line68>sqlite3VdbeAddOp2(v, OP_Copy, r1, regBase+j);\n<line69>}\n<line70>}\n<line71>if( pTerm->eOperator & WO_IN ){\n<line72>if( pTerm->pExpr->flags & EP_xIsSelect ){\n<line73>/* No affinity ever needs to be (or should be) applied to a value\n<line74>** from the RHS of an "? IN (SELECT ...)" expression. The\n<line75>** sqlite3FindInIndex() routine has already ensured that the\n<line76>** affinity of the comparison has been applied to the value.  */\n<line77>if( zAff ) zAff[j] = SQLITE_AFF_BLOB;\n<line78>}\n<line79>}else if( (pTerm->eOperator & WO_ISNULL)==0 ){\n<line80>Expr *pRight = pTerm->pExpr->pRight;\n<line81>if( (pTerm->wtFlags & TERM_IS)==0 && sqlite3ExprCanBeNull(pRight) ){\n<line82>sqlite3VdbeAddOp2(v, OP_IsNull, regBase+j, pLevel->addrBrk);\n<line83>VdbeCoverage(v);\n<line84>}\n<line85>if( pParse->nErr==0 ){\n<line86>assert( pParse->db->mallocFailed==0 );\n<line87>if( sqlite3CompareAffinity(pRight, zAff[j])==SQLITE_AFF_BLOB ){\n<line88>zAff[j] = SQLITE_AFF_BLOB;\n<line89>}\n<line90>if( sqlite3ExprNeedsNoAffinityChange(pRight, zAff[j]) ){\n<line91>zAff[j] = SQLITE_AFF_BLOB;\n<line92>}\n<line93>}\n<line94>}\n<line95>}\n<line96>*pzAff = zAff;\n<line97>return regBase;\n<line98>}
----------------------------------------
Function: whereLikeOptimizationStringFixup
Content: <line0>static void whereLikeOptimizationStringFixup(\n<line1>Vdbe *v,                /* prepared statement under construction */\n<line2>WhereLevel *pLevel,     /* The loop that contains the LIKE operator */\n<line3>WhereTerm *pTerm        /* The upper or lower bound just coded */\n<line4>){\n<line5>if( pTerm->wtFlags & TERM_LIKEOPT ){\n<line6>VdbeOp *pOp;\n<line7>assert( pLevel->iLikeRepCntr>0 );\n<line8>pOp = sqlite3VdbeGetLastOp(v);\n<line9>assert( pOp!=0 );\n<line10>assert( pOp->opcode==OP_String8\n<line11>|| pTerm->pWC->pWInfo->pParse->db->mallocFailed );\n<line12>pOp->p3 = (int)(pLevel->iLikeRepCntr>>1);  /* Register holding counter */\n<line13>pOp->p5 = (u8)(pLevel->iLikeRepCntr&1);    /* ASC or DESC */\n<line14>}\n<line15>}
----------------------------------------
Function: codeDeferredSeek
Content: <line0>static void codeDeferredSeek(\n<line1>WhereInfo *pWInfo,              /* Where clause context */\n<line2>Index *pIdx,                    /* Index scan is using */\n<line3>int iCur,                       /* Cursor for IPK b-tree */\n<line4>int iIdxCur                     /* Index cursor */\n<line5>){\n<line6>Parse *pParse = pWInfo->pParse; /* Parse context */\n<line7>Vdbe *v = pParse->pVdbe;        /* Vdbe to generate code within */\n<line8>assert( iIdxCur>0 );\n<line9>assert( pIdx->aiColumn[pIdx->nColumn-1]==-1 );\n<line10>pWInfo->bDeferredSeek = 1;\n<line11>sqlite3VdbeAddOp3(v, OP_DeferredSeek, iIdxCur, 0, iCur);\n<line12>if( (pWInfo->wctrlFlags & (WHERE_OR_SUBCLAUSE|WHERE_RIGHT_JOIN))\n<line13>&& DbMaskAllZero(sqlite3ParseToplevel(pParse)->writeMask)\n<line14>){\n<line15>int i;\n<line16>Table *pTab = pIdx->pTable;\n<line17>u32 *ai = (u32*)sqlite3DbMallocZero(pParse->db, sizeof(u32)*(pTab->nCol+1));\n<line18>if( ai ){\n<line19>ai[0] = pTab->nCol;\n<line20>for(i=0; i<pIdx->nColumn-1; i++){\n<line21>int x1, x2;\n<line22>assert( pIdx->aiColumn[i]<pTab->nCol );\n<line23>x1 = pIdx->aiColumn[i];\n<line24>x2 = sqlite3TableColumnToStorage(pTab, x1);\n<line25>testcase( x1!=x2 );\n<line26>if( x1>=0 ) ai[x2+1] = i+1;\n<line27>}\n<line28>sqlite3VdbeChangeP4(v, -1, (char*)ai, P4_INTARRAY);\n<line29>}\n<line30>}\n<line31>}
----------------------------------------
Function: codeExprOrVector
Content: <line0>static void codeExprOrVector(Parse *pParse, Expr *p, int iReg, int nReg){\n<line1>assert( nReg>0 );\n<line2>if( p && sqlite3ExprIsVector(p) ){\n<line3>#ifndef SQLITE_OMIT_SUBQUERY\n<line4>if( ExprUseXSelect(p) ){\n<line5>Vdbe *v = pParse->pVdbe;\n<line6>int iSelect;\n<line7>assert( p->op==TK_SELECT );\n<line8>iSelect = sqlite3CodeSubselect(pParse, p);\n<line9>sqlite3VdbeAddOp3(v, OP_Copy, iSelect, iReg, nReg-1);\n<line10>}else\n<line11>#endif\n<line12>{\n<line13>int i;\n<line14>const ExprList *pList;\n<line15>assert( ExprUseXList(p) );\n<line16>pList = p->x.pList;\n<line17>assert( nReg<=pList->nExpr );\n<line18>for(i=0; i<nReg; i++){\n<line19>sqlite3ExprCode(pParse, pList->a[i].pExpr, iReg+i);\n<line20>}\n<line21>}\n<line22>}else{\n<line23>assert( nReg==1 || pParse->nErr );\n<line24>sqlite3ExprCode(pParse, p, iReg);\n<line25>}\n<line26>}
----------------------------------------
Function: whereApplyPartialIndexConstraints
Content: <line0>static void whereApplyPartialIndexConstraints(\n<line1>Expr *pTruth,\n<line2>int iTabCur,\n<line3>WhereClause *pWC\n<line4>){\n<line5>int i;\n<line6>WhereTerm *pTerm;\n<line7>while( pTruth->op==TK_AND ){\n<line8>whereApplyPartialIndexConstraints(pTruth->pLeft, iTabCur, pWC);\n<line9>pTruth = pTruth->pRight;\n<line10>}\n<line11>for(i=0, pTerm=pWC->a; i<pWC->nTerm; i++, pTerm++){\n<line12>Expr *pExpr;\n<line13>if( pTerm->wtFlags & TERM_CODED ) continue;\n<line14>pExpr = pTerm->pExpr;\n<line15>if( sqlite3ExprCompare(0, pExpr, pTruth, iTabCur)==0 ){\n<line16>pTerm->wtFlags |= TERM_CODED;\n<line17>}\n<line18>}\n<line19>}
----------------------------------------
Function: filterPullDown
Content: <line0>static SQLITE_NOINLINE void filterPullDown(\n<line1>Parse *pParse,       /* Parsing context */\n<line2>WhereInfo *pWInfo,   /* Complete information about the WHERE clause */\n<line3>int iLevel,          /* Which level of pWInfo->a[] should be coded */\n<line4>int addrNxt,         /* Jump here to bypass inner loops */\n<line5>Bitmask notReady     /* Loops that are not ready */\n<line6>){\n<line7>int saved_addrBrk;\n<line8>while( ++iLevel < pWInfo->nLevel ){\n<line9>WhereLevel *pLevel = &pWInfo->a[iLevel];\n<line10>WhereLoop *pLoop = pLevel->pWLoop;\n<line11>if( pLevel->regFilter==0 ) continue;\n<line12>if( pLevel->pWLoop->nSkip ) continue;\n<line13>/*         ,--- Because sqlite3ConstructBloomFilter() has will not have set\n<line14>**  vvvvv--'    pLevel->regFilter if this were true. */\n<line15>if( NEVER(pLoop->prereq & notReady) ) continue;\n<line16>saved_addrBrk = pLevel->addrBrk;\n<line17>pLevel->addrBrk = addrNxt;\n<line18>if( pLoop->wsFlags & WHERE_IPK ){\n<line19>WhereTerm *pTerm = pLoop->aLTerm[0];\n<line20>int regRowid;\n<line21>assert( pTerm!=0 );\n<line22>assert( pTerm->pExpr!=0 );\n<line23>testcase( pTerm->wtFlags & TERM_VIRTUAL );\n<line24>regRowid = sqlite3GetTempReg(pParse);\n<line25>regRowid = codeEqualityTerm(pParse, pTerm, pLevel, 0, 0, regRowid);\n<line26>sqlite3VdbeAddOp2(pParse->pVdbe, OP_MustBeInt, regRowid, addrNxt);\n<line27>VdbeCoverage(pParse->pVdbe);\n<line28>sqlite3VdbeAddOp4Int(pParse->pVdbe, OP_Filter, pLevel->regFilter,\n<line29>addrNxt, regRowid, 1);\n<line30>VdbeCoverage(pParse->pVdbe);\n<line31>}else{\n<line32>u16 nEq = pLoop->u.btree.nEq;\n<line33>int r1;\n<line34>char *zStartAff;\n<line35>assert( pLoop->wsFlags & WHERE_INDEXED );\n<line36>assert( (pLoop->wsFlags & WHERE_COLUMN_IN)==0 );\n<line37>r1 = codeAllEqualityTerms(pParse,pLevel,0,0,&zStartAff);\n<line38>codeApplyAffinity(pParse, r1, nEq, zStartAff);\n<line39>sqlite3DbFree(pParse->db, zStartAff);\n<line40>sqlite3VdbeAddOp4Int(pParse->pVdbe, OP_Filter, pLevel->regFilter,\n<line41>addrNxt, r1, nEq);\n<line42>VdbeCoverage(pParse->pVdbe);\n<line43>}\n<line44>pLevel->regFilter = 0;\n<line45>pLevel->addrBrk = saved_addrBrk;\n<line46>}\n<line47>}
----------------------------------------
Function: whereLoopIsOneRow
Content: <line0>static int whereLoopIsOneRow(WhereLoop *pLoop){\n<line1>if( pLoop->u.btree.pIndex->onError\n<line2>&& pLoop->nSkip==0\n<line3>&& pLoop->u.btree.nEq==pLoop->u.btree.pIndex->nKeyCol\n<line4>){\n<line5>int ii;\n<line6>for(ii=0; ii<pLoop->u.btree.nEq; ii++){\n<line7>if( pLoop->aLTerm[ii]->eOperator & (WO_IS|WO_ISNULL) ){\n<line8>return 0;\n<line9>}\n<line10>}\n<line11>return 1;\n<line12>}\n<line13>return 0;\n<line14>}
----------------------------------------
Function: whereOrInfoDelete
Content: <line0>static void whereOrInfoDelete(sqlite3 *db, WhereOrInfo *p){\n<line1>sqlite3WhereClauseClear(&p->wc);\n<line2>sqlite3DbFree(db, p);\n<line3>}
----------------------------------------
Function: whereAndInfoDelete
Content: <line0>static void whereAndInfoDelete(sqlite3 *db, WhereAndInfo *p){\n<line1>sqlite3WhereClauseClear(&p->wc);\n<line2>sqlite3DbFree(db, p);\n<line3>}
----------------------------------------
Function: whereClauseInsert
Content: <line0>static int whereClauseInsert(WhereClause *pWC, Expr *p, u16 wtFlags){\n<line1>WhereTerm *pTerm;\n<line2>int idx;\n<line3>testcase( wtFlags & TERM_VIRTUAL );\n<line4>if( pWC->nTerm>=pWC->nSlot ){\n<line5>WhereTerm *pOld = pWC->a;\n<line6>sqlite3 *db = pWC->pWInfo->pParse->db;\n<line7>pWC->a = sqlite3WhereMalloc(pWC->pWInfo, sizeof(pWC->a[0])*pWC->nSlot*2 );\n<line8>if( pWC->a==0 ){\n<line9>if( wtFlags & TERM_DYNAMIC ){\n<line10>sqlite3ExprDelete(db, p);\n<line11>}\n<line12>pWC->a = pOld;\n<line13>return 0;\n<line14>}\n<line15>memcpy(pWC->a, pOld, sizeof(pWC->a[0])*pWC->nTerm);\n<line16>pWC->nSlot = pWC->nSlot*2;\n<line17>}\n<line18>pTerm = &pWC->a[idx = pWC->nTerm++];\n<line19>if( (wtFlags & TERM_VIRTUAL)==0 ) pWC->nBase = pWC->nTerm;\n<line20>if( p && ExprHasProperty(p, EP_Unlikely) ){\n<line21>pTerm->truthProb = sqlite3LogEst(p->iTable) - 270;\n<line22>}else{\n<line23>pTerm->truthProb = 1;\n<line24>}\n<line25>pTerm->pExpr = sqlite3ExprSkipCollateAndLikely(p);\n<line26>pTerm->wtFlags = wtFlags;\n<line27>pTerm->pWC = pWC;\n<line28>pTerm->iParent = -1;\n<line29>memset(&pTerm->eOperator, 0,\n<line30>sizeof(WhereTerm) - offsetof(WhereTerm,eOperator));\n<line31>return idx;\n<line32>}
----------------------------------------
Function: allowedOp
Content: <line0>static int allowedOp(int op){\n<line1>assert( TK_GT>TK_EQ && TK_GT<TK_GE );\n<line2>assert( TK_LT>TK_EQ && TK_LT<TK_GE );\n<line3>assert( TK_LE>TK_EQ && TK_LE<TK_GE );\n<line4>assert( TK_GE==TK_EQ+4 );\n<line5>assert( TK_IN<TK_EQ );\n<line6>assert( TK_IS<TK_EQ );\n<line7>assert( TK_ISNULL<TK_EQ );\n<line8>if( op>TK_GE ) return 0;\n<line9>if( op>=TK_EQ ) return 1;\n<line10>return op==TK_IN || op==TK_ISNULL || op==TK_IS;\n<line11>}
----------------------------------------
Function: exprCommute
Content: <line0>static u16 exprCommute(Parse *pParse, Expr *pExpr){\n<line1>if( pExpr->pLeft->op==TK_VECTOR\n<line2>|| pExpr->pRight->op==TK_VECTOR\n<line3>|| sqlite3BinaryCompareCollSeq(pParse, pExpr->pLeft, pExpr->pRight) !=\n<line4>sqlite3BinaryCompareCollSeq(pParse, pExpr->pRight, pExpr->pLeft)\n<line5>){\n<line6>pExpr->flags ^= EP_Commuted;\n<line7>}\n<line8>SWAP(Expr*,pExpr->pRight,pExpr->pLeft);\n<line9>if( pExpr->op>=TK_GT ){\n<line10>assert( TK_LT==TK_GT+2 );\n<line11>assert( TK_GE==TK_LE+2 );\n<line12>assert( TK_GT>TK_EQ );\n<line13>assert( TK_GT<TK_LE );\n<line14>assert( pExpr->op>=TK_GT && pExpr->op<=TK_GE );\n<line15>pExpr->op = ((pExpr->op-TK_GT)^2)+TK_GT;\n<line16>}\n<line17>return 0;\n<line18>}
----------------------------------------
Function: operatorMask
Content: <line0>static u16 operatorMask(int op){\n<line1>u16 c;\n<line2>assert( allowedOp(op) );\n<line3>if( op>=TK_EQ ){\n<line4>assert( (WO_EQ<<(op-TK_EQ)) < 0x7fff );\n<line5>c = (u16)(WO_EQ<<(op-TK_EQ));\n<line6>}else if( op==TK_IN ){\n<line7>c = WO_IN;\n<line8>}else if( op==TK_ISNULL ){\n<line9>c = WO_ISNULL;\n<line10>}else{\n<line11>assert( op==TK_IS );\n<line12>c = WO_IS;\n<line13>}\n<line14>assert( op!=TK_ISNULL || c==WO_ISNULL );\n<line15>assert( op!=TK_IN || c==WO_IN );\n<line16>assert( op!=TK_EQ || c==WO_EQ );\n<line17>assert( op!=TK_LT || c==WO_LT );\n<line18>assert( op!=TK_LE || c==WO_LE );\n<line19>assert( op!=TK_GT || c==WO_GT );\n<line20>assert( op!=TK_GE || c==WO_GE );\n<line21>assert( op!=TK_IS || c==WO_IS );\n<line22>return c;\n<line23>}
----------------------------------------
Function: isLikeOrGlob
Content: <line0>static int isLikeOrGlob(\n<line1>Parse *pParse,    /* Parsing and code generating context */\n<line2>Expr *pExpr,      /* Test this expression */\n<line3>Expr **ppPrefix,  /* Pointer to TK_STRING expression with pattern prefix */\n<line4>int *pisComplete, /* True if the only wildcard is % in the last character */\n<line5>int *pnoCase      /* True if uppercase is equivalent to lowercase */\n<line6>){\n<line7>const u8 *z = 0;           /* String on RHS of LIKE operator */\n<line8>Expr *pRight, *pLeft;      /* Right and left size of LIKE operator */\n<line9>ExprList *pList;           /* List of operands to the LIKE operator */\n<line10>u8 c;                      /* One character in z[] */\n<line11>int cnt;                   /* Number of non-wildcard prefix characters */\n<line12>u8 wc[4];                  /* Wildcard characters */\n<line13>sqlite3 *db = pParse->db;  /* Database connection */\n<line14>sqlite3_value *pVal = 0;\n<line15>int op;                    /* Opcode of pRight */\n<line16>int rc;                    /* Result code to return */\n<line17>if( !sqlite3IsLikeFunction(db, pExpr, pnoCase, (char*)wc) ){\n<line18>return 0;\n<line19>}\n<line20>#ifdef SQLITE_EBCDIC\n<line21>if( *pnoCase ) return 0;\n<line22>#endif\n<line23>assert( ExprUseXList(pExpr) );\n<line24>pList = pExpr->x.pList;\n<line25>pLeft = pList->a[1].pExpr;\n<line26>pRight = sqlite3ExprSkipCollate(pList->a[0].pExpr);\n<line27>op = pRight->op;\n<line28>if( op==TK_VARIABLE && (db->flags & SQLITE_EnableQPSG)==0 ){\n<line29>Vdbe *pReprepare = pParse->pReprepare;\n<line30>int iCol = pRight->iColumn;\n<line31>pVal = sqlite3VdbeGetBoundValue(pReprepare, iCol, SQLITE_AFF_BLOB);\n<line32>if( pVal && sqlite3_value_type(pVal)==SQLITE_TEXT ){\n<line33>z = sqlite3_value_text(pVal);\n<line34>}\n<line35>sqlite3VdbeSetVarmask(pParse->pVdbe, iCol);\n<line36>assert( pRight->op==TK_VARIABLE || pRight->op==TK_REGISTER );\n<line37>}else if( op==TK_STRING ){\n<line38>assert( !ExprHasProperty(pRight, EP_IntValue) );\n<line39>z = (u8*)pRight->u.zToken;\n<line40>}\n<line41>if( z ){\n<line42>/* Count the number of prefix bytes prior to the first wildcard,\n<line43>** U+fffd character, or malformed utf-8. If the underlying database\n<line44>** has a UTF16LE encoding, then only consider ASCII characters.  Note that\n<line45>** the encoding of z[] is UTF8 - we are dealing with only UTF8 here in this\n<line46>** code, but the database engine itself might be processing content using a\n<line47>** different encoding. */\n<line48>cnt = 0;\n<line49>while( (c=z[cnt])!=0 && c!=wc[0] && c!=wc[1] && c!=wc[2] ){\n<line50>cnt++;\n<line51>if( c==wc[3] && z[cnt]>0 && z[cnt]<0x80 ){\n<line52>cnt++;\n<line53>}else if( c>=0x80 ){\n<line54>const u8 *z2 = z+cnt-1;\n<line55>if( c==0xff || sqlite3Utf8Read(&z2)==0xfffd  /* bad utf-8 */\n<line56>|| ENC(db)==SQLITE_UTF16LE\n<line57>){\n<line58>cnt--;\n<line59>break;\n<line60>}else{\n<line61>cnt = (int)(z2-z);\n<line62>}\n<line63>}\n<line64>}\n<line65>/* The optimization is possible only if (1) the pattern does not begin\n<line66>** with a wildcard and if (2) the non-wildcard prefix does not end with\n<line67>** an (illegal 0xff) character, or (3) the pattern does not consist of\n<line68>** a single escape character. The second condition is necessary so\n<line69>** that we can increment the prefix key to find an upper bound for the\n<line70>** range search. The third is because the caller assumes that the pattern\n<line71>** consists of at least one character after all escapes have been\n<line72>** removed.  */\n<line73>if( (cnt>1 || (cnt>0 && z[0]!=wc[3])) && ALWAYS(255!=(u8)z[cnt-1]) ){\n<line74>Expr *pPrefix;\n<line75>/* A "complete" match if the pattern ends with "*" or "%" */\n<line76>*pisComplete = c==wc[0] && z[cnt+1]==0 && ENC(db)!=SQLITE_UTF16LE;\n<line77>/* Get the pattern prefix.  Remove all escapes from the prefix. */\n<line78>pPrefix = sqlite3Expr(db, TK_STRING, (char*)z);\n<line79>if( pPrefix ){\n<line80>int iFrom, iTo;\n<line81>char *zNew;\n<line82>assert( !ExprHasProperty(pPrefix, EP_IntValue) );\n<line83>zNew = pPrefix->u.zToken;\n<line84>zNew[cnt] = 0;\n<line85>for(iFrom=iTo=0; iFrom<cnt; iFrom++){\n<line86>if( zNew[iFrom]==wc[3] ) iFrom++;\n<line87>zNew[iTo++] = zNew[iFrom];\n<line88>}\n<line89>zNew[iTo] = 0;\n<line90>assert( iTo>0 );\n<line91>/* If the LHS is not an ordinary column with TEXT affinity, then the\n<line92>** pattern prefix boundaries (both the start and end boundaries) must\n<line93>** not look like a number.  Otherwise the pattern might be treated as\n<line94>** a number, which will invalidate the LIKE optimization.\n<line95>**\n<line96>** Getting this right has been a persistent source of bugs in the\n<line97>** LIKE optimization.  See, for example:\n<line98>**    2018-09-10 https://sqlite.org/src/info/c94369cae9b561b1\n<line99>**    2019-05-02 https://sqlite.org/src/info/b043a54c3de54b28\n<line100>**    2019-06-10 https://sqlite.org/src/info/fd76310a5e843e07\n<line101>**    2019-06-14 https://sqlite.org/src/info/ce8717f0885af975\n<line102>**    2019-09-03 https://sqlite.org/src/info/0f0428096f17252a\n<line103>*/\n<line104>if( pLeft->op!=TK_COLUMN\n<line105>|| sqlite3ExprAffinity(pLeft)!=SQLITE_AFF_TEXT\n<line106>|| (ALWAYS( ExprUseYTab(pLeft) )\n<line107>&& ALWAYS(pLeft->y.pTab)\n<line108>&& IsVirtual(pLeft->y.pTab))  /* Might be numeric */\n<line109>){\n<line110>int isNum;\n<line111>double rDummy;\n<line112>isNum = sqlite3AtoF(zNew, &rDummy, iTo, SQLITE_UTF8);\n<line113>if( isNum<=0 ){\n<line114>if( iTo==1 && zNew[0]=='-' ){\n<line115>isNum = +1;\n<line116>}else{\n<line117>zNew[iTo-1]++;\n<line118>isNum = sqlite3AtoF(zNew, &rDummy, iTo, SQLITE_UTF8);\n<line119>zNew[iTo-1]--;\n<line120>}\n<line121>}\n<line122>if( isNum>0 ){\n<line123>sqlite3ExprDelete(db, pPrefix);\n<line124>sqlite3ValueFree(pVal);\n<line125>return 0;\n<line126>}\n<line127>}\n<line128>}\n<line129>*ppPrefix = pPrefix;\n<line130>/* If the RHS pattern is a bound parameter, make arrangements to\n<line131>** reprepare the statement when that parameter is rebound */\n<line132>if( op==TK_VARIABLE ){\n<line133>Vdbe *v = pParse->pVdbe;\n<line134>sqlite3VdbeSetVarmask(v, pRight->iColumn);\n<line135>assert( !ExprHasProperty(pRight, EP_IntValue) );\n<line136>if( *pisComplete && pRight->u.zToken[1] ){\n<line137>/* If the rhs of the LIKE expression is a variable, and the current\n<line138>** value of the variable means there is no need to invoke the LIKE\n<line139>** function, then no OP_Variable will be added to the program.\n<line140>** This causes problems for the sqlite3_bind_parameter_name()\n<line141>** API. To work around them, add a dummy OP_Variable here.\n<line142>*/\n<line143>int r1 = sqlite3GetTempReg(pParse);\n<line144>sqlite3ExprCodeTarget(pParse, pRight, r1);\n<line145>sqlite3VdbeChangeP3(v, sqlite3VdbeCurrentAddr(v)-1, 0);\n<line146>sqlite3ReleaseTempReg(pParse, r1);\n<line147>}\n<line148>}\n<line149>}else{\n<line150>z = 0;\n<line151>}\n<line152>}\n<line153>rc = (z!=0);\n<line154>sqlite3ValueFree(pVal);\n<line155>return rc;\n<line156>}
----------------------------------------
Function: isAuxiliaryVtabOperator
Content: <line0>static int isAuxiliaryVtabOperator(\n<line1>sqlite3 *db,                    /* Parsing context */\n<line2>Expr *pExpr,                    /* Test this expression */\n<line3>unsigned char *peOp2,           /* OUT: 0 for MATCH, or else an op2 value */\n<line4>Expr **ppLeft,                  /* Column expression to left of MATCH/op2 */\n<line5>Expr **ppRight                  /* Expression to left of MATCH/op2 */\n<line6>){\n<line7>if( pExpr->op==TK_FUNCTION ){\n<line8>static const struct Op2 {\n<line9>const char *zOp;\n<line10>unsigned char eOp2;\n<line11>} aOp[] = {\n<line12>{ "match",  SQLITE_INDEX_CONSTRAINT_MATCH },\n<line13>{ "glob",   SQLITE_INDEX_CONSTRAINT_GLOB },\n<line14>{ "like",   SQLITE_INDEX_CONSTRAINT_LIKE },\n<line15>{ "regexp", SQLITE_INDEX_CONSTRAINT_REGEXP }\n<line16>};\n<line17>ExprList *pList;\n<line18>Expr *pCol;                     /* Column reference */\n<line19>int i;\n<line20>assert( ExprUseXList(pExpr) );\n<line21>pList = pExpr->x.pList;\n<line22>if( pList==0 || pList->nExpr!=2 ){\n<line23>return 0;\n<line24>}\n<line25>/* Built-in operators MATCH, GLOB, LIKE, and REGEXP attach to a\n<line26>** virtual table on their second argument, which is the same as\n<line27>** the left-hand side operand in their in-fix form.\n<line28>**\n<line29>**       vtab_column MATCH expression\n<line30>**       MATCH(expression,vtab_column)\n<line31>*/\n<line32>pCol = pList->a[1].pExpr;\n<line33>assert( pCol->op!=TK_COLUMN || (ExprUseYTab(pCol) && pCol->y.pTab!=0) );\n<line34>if( ExprIsVtab(pCol) ){\n<line35>for(i=0; i<ArraySize(aOp); i++){\n<line36>assert( !ExprHasProperty(pExpr, EP_IntValue) );\n<line37>if( sqlite3StrICmp(pExpr->u.zToken, aOp[i].zOp)==0 ){\n<line38>*peOp2 = aOp[i].eOp2;\n<line39>*ppRight = pList->a[0].pExpr;\n<line40>*ppLeft = pCol;\n<line41>return 1;\n<line42>}\n<line43>}\n<line44>}\n<line45>/* We can also match against the first column of overloaded\n<line46>** functions where xFindFunction returns a value of at least\n<line47>** SQLITE_INDEX_CONSTRAINT_FUNCTION.\n<line48>**\n<line49>**      OVERLOADED(vtab_column,expression)\n<line50>**\n<line51>** Historically, xFindFunction expected to see lower-case function\n<line52>** names.  But for this use case, xFindFunction is expected to deal\n<line53>** with function names in an arbitrary case.\n<line54>*/\n<line55>pCol = pList->a[0].pExpr;\n<line56>assert( pCol->op!=TK_COLUMN || ExprUseYTab(pCol) );\n<line57>assert( pCol->op!=TK_COLUMN || (ExprUseYTab(pCol) && pCol->y.pTab!=0) );\n<line58>if( ExprIsVtab(pCol) ){\n<line59>sqlite3_vtab *pVtab;\n<line60>sqlite3_module *pMod;\n<line61>void (*xNotUsed)(sqlite3_context*,int,sqlite3_value**);\n<line62>void *pNotUsed;\n<line63>pVtab = sqlite3GetVTable(db, pCol->y.pTab)->pVtab;\n<line64>assert( pVtab!=0 );\n<line65>assert( pVtab->pModule!=0 );\n<line66>assert( !ExprHasProperty(pExpr, EP_IntValue) );\n<line67>pMod = (sqlite3_module *)pVtab->pModule;\n<line68>if( pMod->xFindFunction!=0 ){\n<line69>i = pMod->xFindFunction(pVtab,2, pExpr->u.zToken, &xNotUsed, &pNotUsed);\n<line70>if( i>=SQLITE_INDEX_CONSTRAINT_FUNCTION ){\n<line71>*peOp2 = i;\n<line72>*ppRight = pList->a[1].pExpr;\n<line73>*ppLeft = pCol;\n<line74>return 1;\n<line75>}\n<line76>}\n<line77>}\n<line78>}else if( pExpr->op>=TK_EQ ){\n<line79>/* Comparison operators are a common case.  Save a few comparisons for\n<line80>** that common case by terminating early. */\n<line81>assert( TK_NE < TK_EQ );\n<line82>assert( TK_ISNOT < TK_EQ );\n<line83>assert( TK_NOTNULL < TK_EQ );\n<line84>return 0;\n<line85>}else if( pExpr->op==TK_NE || pExpr->op==TK_ISNOT || pExpr->op==TK_NOTNULL ){\n<line86>int res = 0;\n<line87>Expr *pLeft = pExpr->pLeft;\n<line88>Expr *pRight = pExpr->pRight;\n<line89>assert( pLeft->op!=TK_COLUMN || (ExprUseYTab(pLeft) && pLeft->y.pTab!=0) );\n<line90>if( ExprIsVtab(pLeft) ){\n<line91>res++;\n<line92>}\n<line93>assert( pRight==0 || pRight->op!=TK_COLUMN\n<line94>|| (ExprUseYTab(pRight) && pRight->y.pTab!=0) );\n<line95>if( pRight && ExprIsVtab(pRight) ){\n<line96>res++;\n<line97>SWAP(Expr*, pLeft, pRight);\n<line98>}\n<line99>*ppLeft = pLeft;\n<line100>*ppRight = pRight;\n<line101>if( pExpr->op==TK_NE ) *peOp2 = SQLITE_INDEX_CONSTRAINT_NE;\n<line102>if( pExpr->op==TK_ISNOT ) *peOp2 = SQLITE_INDEX_CONSTRAINT_ISNOT;\n<line103>if( pExpr->op==TK_NOTNULL ) *peOp2 = SQLITE_INDEX_CONSTRAINT_ISNOTNULL;\n<line104>return res;\n<line105>}\n<line106>return 0;\n<line107>}
----------------------------------------
Function: transferJoinMarkings
Content: <line0>static void transferJoinMarkings(Expr *pDerived, Expr *pBase){\n<line1>if( pDerived && ExprHasProperty(pBase, EP_OuterON|EP_InnerON) ){\n<line2>pDerived->flags |= pBase->flags & (EP_OuterON|EP_InnerON);\n<line3>pDerived->w.iJoin = pBase->w.iJoin;\n<line4>}\n<line5>}
----------------------------------------
Function: markTermAsChild
Content: <line0>static void markTermAsChild(WhereClause *pWC, int iChild, int iParent){\n<line1>pWC->a[iChild].iParent = iParent;\n<line2>pWC->a[iChild].truthProb = pWC->a[iParent].truthProb;\n<line3>pWC->a[iParent].nChild++;\n<line4>}
----------------------------------------
Function: whereNthSubterm
Content: <line0>static WhereTerm *whereNthSubterm(WhereTerm *pTerm, int N){\n<line1>if( pTerm->eOperator!=WO_AND ){\n<line2>return N==0 ? pTerm : 0;\n<line3>}\n<line4>if( N<pTerm->u.pAndInfo->wc.nTerm ){\n<line5>return &pTerm->u.pAndInfo->wc.a[N];\n<line6>}\n<line7>return 0;\n<line8>}
----------------------------------------
Function: whereCombineDisjuncts
Content: <line0>static void whereCombineDisjuncts(\n<line1>SrcList *pSrc,         /* the FROM clause */\n<line2>WhereClause *pWC,      /* The complete WHERE clause */\n<line3>WhereTerm *pOne,       /* First disjunct */\n<line4>WhereTerm *pTwo        /* Second disjunct */\n<line5>){\n<line6>u16 eOp = pOne->eOperator | pTwo->eOperator;\n<line7>sqlite3 *db;           /* Database connection (for malloc) */\n<line8>Expr *pNew;            /* New virtual expression */\n<line9>int op;                /* Operator for the combined expression */\n<line10>int idxNew;            /* Index in pWC of the next virtual term */\n<line11>if( (pOne->wtFlags | pTwo->wtFlags) & TERM_VNULL ) return;\n<line12>if( (pOne->eOperator & (WO_EQ|WO_LT|WO_LE|WO_GT|WO_GE))==0 ) return;\n<line13>if( (pTwo->eOperator & (WO_EQ|WO_LT|WO_LE|WO_GT|WO_GE))==0 ) return;\n<line14>if( (eOp & (WO_EQ|WO_LT|WO_LE))!=eOp\n<line15>&& (eOp & (WO_EQ|WO_GT|WO_GE))!=eOp ) return;\n<line16>assert( pOne->pExpr->pLeft!=0 && pOne->pExpr->pRight!=0 );\n<line17>assert( pTwo->pExpr->pLeft!=0 && pTwo->pExpr->pRight!=0 );\n<line18>if( sqlite3ExprCompare(0,pOne->pExpr->pLeft, pTwo->pExpr->pLeft, -1) ) return;\n<line19>if( sqlite3ExprCompare(0,pOne->pExpr->pRight, pTwo->pExpr->pRight,-1) )return;\n<line20>/* If we reach this point, it means the two subterms can be combined */\n<line21>if( (eOp & (eOp-1))!=0 ){\n<line22>if( eOp & (WO_LT|WO_LE) ){\n<line23>eOp = WO_LE;\n<line24>}else{\n<line25>assert( eOp & (WO_GT|WO_GE) );\n<line26>eOp = WO_GE;\n<line27>}\n<line28>}\n<line29>db = pWC->pWInfo->pParse->db;\n<line30>pNew = sqlite3ExprDup(db, pOne->pExpr, 0);\n<line31>if( pNew==0 ) return;\n<line32>for(op=TK_EQ; eOp!=(WO_EQ<<(op-TK_EQ)); op++){ assert( op<TK_GE ); }\n<line33>pNew->op = op;\n<line34>idxNew = whereClauseInsert(pWC, pNew, TERM_VIRTUAL|TERM_DYNAMIC);\n<line35>exprAnalyze(pSrc, pWC, idxNew);\n<line36>}
----------------------------------------
Function: exprAnalyzeOrTerm
Content: <line0>static void exprAnalyzeOrTerm(\n<line1>SrcList *pSrc,            /* the FROM clause */\n<line2>WhereClause *pWC,         /* the complete WHERE clause */\n<line3>int idxTerm               /* Index of the OR-term to be analyzed */\n<line4>){\n<line5>WhereInfo *pWInfo = pWC->pWInfo;        /* WHERE clause processing context */\n<line6>Parse *pParse = pWInfo->pParse;         /* Parser context */\n<line7>sqlite3 *db = pParse->db;               /* Database connection */\n<line8>WhereTerm *pTerm = &pWC->a[idxTerm];    /* The term to be analyzed */\n<line9>Expr *pExpr = pTerm->pExpr;             /* The expression of the term */\n<line10>int i;                                  /* Loop counters */\n<line11>WhereClause *pOrWc;       /* Breakup of pTerm into subterms */\n<line12>WhereTerm *pOrTerm;       /* A Sub-term within the pOrWc */\n<line13>WhereOrInfo *pOrInfo;     /* Additional information associated with pTerm */\n<line14>Bitmask chngToIN;         /* Tables that might satisfy case 1 */\n<line15>Bitmask indexable;        /* Tables that are indexable, satisfying case 2 */\n<line16>/*\n<line17>** Break the OR clause into its separate subterms.  The subterms are\n<line18>** stored in a WhereClause structure containing within the WhereOrInfo\n<line19>** object that is attached to the original OR clause term.\n<line20>*/\n<line21>assert( (pTerm->wtFlags & (TERM_DYNAMIC|TERM_ORINFO|TERM_ANDINFO))==0 );\n<line22>assert( pExpr->op==TK_OR );\n<line23>pTerm->u.pOrInfo = pOrInfo = sqlite3DbMallocZero(db, sizeof(*pOrInfo));\n<line24>if( pOrInfo==0 ) return;\n<line25>pTerm->wtFlags |= TERM_ORINFO;\n<line26>pOrWc = &pOrInfo->wc;\n<line27>memset(pOrWc->aStatic, 0, sizeof(pOrWc->aStatic));\n<line28>sqlite3WhereClauseInit(pOrWc, pWInfo);\n<line29>sqlite3WhereSplit(pOrWc, pExpr, TK_OR);\n<line30>sqlite3WhereExprAnalyze(pSrc, pOrWc);\n<line31>if( db->mallocFailed ) return;\n<line32>assert( pOrWc->nTerm>=2 );\n<line33>/*\n<line34>** Compute the set of tables that might satisfy cases 1 or 3.\n<line35>*/\n<line36>indexable = ~(Bitmask)0;\n<line37>chngToIN = ~(Bitmask)0;\n<line38>for(i=pOrWc->nTerm-1, pOrTerm=pOrWc->a; i>=0 && indexable; i--, pOrTerm++){\n<line39>if( (pOrTerm->eOperator & WO_SINGLE)==0 ){\n<line40>WhereAndInfo *pAndInfo;\n<line41>assert( (pOrTerm->wtFlags & (TERM_ANDINFO|TERM_ORINFO))==0 );\n<line42>chngToIN = 0;\n<line43>pAndInfo = sqlite3DbMallocRawNN(db, sizeof(*pAndInfo));\n<line44>if( pAndInfo ){\n<line45>WhereClause *pAndWC;\n<line46>WhereTerm *pAndTerm;\n<line47>int j;\n<line48>Bitmask b = 0;\n<line49>pOrTerm->u.pAndInfo = pAndInfo;\n<line50>pOrTerm->wtFlags |= TERM_ANDINFO;\n<line51>pOrTerm->eOperator = WO_AND;\n<line52>pOrTerm->leftCursor = -1;\n<line53>pAndWC = &pAndInfo->wc;\n<line54>memset(pAndWC->aStatic, 0, sizeof(pAndWC->aStatic));\n<line55>sqlite3WhereClauseInit(pAndWC, pWC->pWInfo);\n<line56>sqlite3WhereSplit(pAndWC, pOrTerm->pExpr, TK_AND);\n<line57>sqlite3WhereExprAnalyze(pSrc, pAndWC);\n<line58>pAndWC->pOuter = pWC;\n<line59>if( !db->mallocFailed ){\n<line60>for(j=0, pAndTerm=pAndWC->a; j<pAndWC->nTerm; j++, pAndTerm++){\n<line61>assert( pAndTerm->pExpr );\n<line62>if( allowedOp(pAndTerm->pExpr->op)\n<line63>|| pAndTerm->eOperator==WO_AUX\n<line64>){\n<line65>b |= sqlite3WhereGetMask(&pWInfo->sMaskSet, pAndTerm->leftCursor);\n<line66>}\n<line67>}\n<line68>}\n<line69>indexable &= b;\n<line70>}\n<line71>}else if( pOrTerm->wtFlags & TERM_COPIED ){\n<line72>/* Skip this term for now.  We revisit it when we process the\n<line73>** corresponding TERM_VIRTUAL term */\n<line74>}else{\n<line75>Bitmask b;\n<line76>b = sqlite3WhereGetMask(&pWInfo->sMaskSet, pOrTerm->leftCursor);\n<line77>if( pOrTerm->wtFlags & TERM_VIRTUAL ){\n<line78>WhereTerm *pOther = &pOrWc->a[pOrTerm->iParent];\n<line79>b |= sqlite3WhereGetMask(&pWInfo->sMaskSet, pOther->leftCursor);\n<line80>}\n<line81>indexable &= b;\n<line82>if( (pOrTerm->eOperator & WO_EQ)==0 ){\n<line83>chngToIN = 0;\n<line84>}else{\n<line85>chngToIN &= b;\n<line86>}\n<line87>}\n<line88>}\n<line89>/*\n<line90>** Record the set of tables that satisfy case 3.  The set might be\n<line91>** empty.\n<line92>*/\n<line93>pOrInfo->indexable = indexable;\n<line94>pTerm->eOperator = WO_OR;\n<line95>pTerm->leftCursor = -1;\n<line96>if( indexable ){\n<line97>pWC->hasOr = 1;\n<line98>}\n<line99>/* For a two-way OR, attempt to implementation case 2.\n<line100>*/\n<line101>if( indexable && pOrWc->nTerm==2 ){\n<line102>int iOne = 0;\n<line103>WhereTerm *pOne;\n<line104>while( (pOne = whereNthSubterm(&pOrWc->a[0],iOne++))!=0 ){\n<line105>int iTwo = 0;\n<line106>WhereTerm *pTwo;\n<line107>while( (pTwo = whereNthSubterm(&pOrWc->a[1],iTwo++))!=0 ){\n<line108>whereCombineDisjuncts(pSrc, pWC, pOne, pTwo);\n<line109>}\n<line110>}\n<line111>}\n<line112>/*\n<line113>** chngToIN holds a set of tables that *might* satisfy case 1.  But\n<line114>** we have to do some additional checking to see if case 1 really\n<line115>** is satisfied.\n<line116>**\n<line117>** chngToIN will hold either 0, 1, or 2 bits.  The 0-bit case means\n<line118>** that there is no possibility of transforming the OR clause into an\n<line119>** IN operator because one or more terms in the OR clause contain\n<line120>** something other than == on a column in the single table.  The 1-bit\n<line121>** case means that every term of the OR clause is of the form\n<line122>** "table.column=expr" for some single table.  The one bit that is set\n<line123>** will correspond to the common table.  We still need to check to make\n<line124>** sure the same column is used on all terms.  The 2-bit case is when\n<line125>** the all terms are of the form "table1.column=table2.column".  It\n<line126>** might be possible to form an IN operator with either table1.column\n<line127>** or table2.column as the LHS if either is common to every term of\n<line128>** the OR clause.\n<line129>**\n<line130>** Note that terms of the form "table.column1=table.column2" (the\n<line131>** same table on both sizes of the ==) cannot be optimized.\n<line132>*/\n<line133>if( chngToIN ){\n<line134>int okToChngToIN = 0;     /* True if the conversion to IN is valid */\n<line135>int iColumn = -1;         /* Column index on lhs of IN operator */\n<line136>int iCursor = -1;         /* Table cursor common to all terms */\n<line137>int j = 0;                /* Loop counter */\n<line138>/* Search for a table and column that appears on one side or the\n<line139>** other of the == operator in every subterm.  That table and column\n<line140>** will be recorded in iCursor and iColumn.  There might not be any\n<line141>** such table and column.  Set okToChngToIN if an appropriate table\n<line142>** and column is found but leave okToChngToIN false if not found.\n<line143>*/\n<line144>for(j=0; j<2 && !okToChngToIN; j++){\n<line145>Expr *pLeft = 0;\n<line146>pOrTerm = pOrWc->a;\n<line147>for(i=pOrWc->nTerm-1; i>=0; i--, pOrTerm++){\n<line148>assert( pOrTerm->eOperator & WO_EQ );\n<line149>pOrTerm->wtFlags &= ~TERM_OK;\n<line150>if( pOrTerm->leftCursor==iCursor ){\n<line151>/* This is the 2-bit case and we are on the second iteration and\n<line152>** current term is from the first iteration.  So skip this term. */\n<line153>assert( j==1 );\n<line154>continue;\n<line155>}\n<line156>if( (chngToIN & sqlite3WhereGetMask(&pWInfo->sMaskSet,\n<line157>pOrTerm->leftCursor))==0 ){\n<line158>/* This term must be of the form t1.a==t2.b where t2 is in the\n<line159>** chngToIN set but t1 is not.  This term will be either preceded\n<line160>** or followed by an inverted copy (t2.b==t1.a).  Skip this term\n<line161>** and use its inversion. */\n<line162>testcase( pOrTerm->wtFlags & TERM_COPIED );\n<line163>testcase( pOrTerm->wtFlags & TERM_VIRTUAL );\n<line164>assert( pOrTerm->wtFlags & (TERM_COPIED|TERM_VIRTUAL) );\n<line165>continue;\n<line166>}\n<line167>assert( (pOrTerm->eOperator & (WO_OR|WO_AND))==0 );\n<line168>iColumn = pOrTerm->u.x.leftColumn;\n<line169>iCursor = pOrTerm->leftCursor;\n<line170>pLeft = pOrTerm->pExpr->pLeft;\n<line171>break;\n<line172>}\n<line173>if( i<0 ){\n<line174>/* No candidate table+column was found.  This can only occur\n<line175>** on the second iteration */\n<line176>assert( j==1 );\n<line177>assert( IsPowerOfTwo(chngToIN) );\n<line178>assert( chngToIN==sqlite3WhereGetMask(&pWInfo->sMaskSet, iCursor) );\n<line179>break;\n<line180>}\n<line181>testcase( j==1 );\n<line182>/* We have found a candidate table and column.  Check to see if that\n<line183>** table and column is common to every term in the OR clause */\n<line184>okToChngToIN = 1;\n<line185>for(; i>=0 && okToChngToIN; i--, pOrTerm++){\n<line186>assert( pOrTerm->eOperator & WO_EQ );\n<line187>assert( (pOrTerm->eOperator & (WO_OR|WO_AND))==0 );\n<line188>if( pOrTerm->leftCursor!=iCursor ){\n<line189>pOrTerm->wtFlags &= ~TERM_OK;\n<line190>}else if( pOrTerm->u.x.leftColumn!=iColumn || (iColumn==XN_EXPR\n<line191>&& sqlite3ExprCompare(pParse, pOrTerm->pExpr->pLeft, pLeft, -1)\n<line192>)){\n<line193>okToChngToIN = 0;\n<line194>}else{\n<line195>int affLeft, affRight;\n<line196>/* If the right-hand side is also a column, then the affinities\n<line197>** of both right and left sides must be such that no type\n<line198>** conversions are required on the right.  (Ticket #2249)\n<line199>*/\n<line200>affRight = sqlite3ExprAffinity(pOrTerm->pExpr->pRight);\n<line201>affLeft = sqlite3ExprAffinity(pOrTerm->pExpr->pLeft);\n<line202>if( affRight!=0 && affRight!=affLeft ){\n<line203>okToChngToIN = 0;\n<line204>}else{\n<line205>pOrTerm->wtFlags |= TERM_OK;\n<line206>}\n<line207>}\n<line208>}\n<line209>}\n<line210>/* At this point, okToChngToIN is true if original pTerm satisfies\n<line211>** case 1.  In that case, construct a new virtual term that is\n<line212>** pTerm converted into an IN operator.\n<line213>*/\n<line214>if( okToChngToIN ){\n<line215>Expr *pDup;            /* A transient duplicate expression */\n<line216>ExprList *pList = 0;   /* The RHS of the IN operator */\n<line217>Expr *pLeft = 0;       /* The LHS of the IN operator */\n<line218>Expr *pNew;            /* The complete IN operator */\n<line219>for(i=pOrWc->nTerm-1, pOrTerm=pOrWc->a; i>=0; i--, pOrTerm++){\n<line220>if( (pOrTerm->wtFlags & TERM_OK)==0 ) continue;\n<line221>assert( pOrTerm->eOperator & WO_EQ );\n<line222>assert( (pOrTerm->eOperator & (WO_OR|WO_AND))==0 );\n<line223>assert( pOrTerm->leftCursor==iCursor );\n<line224>assert( pOrTerm->u.x.leftColumn==iColumn );\n<line225>pDup = sqlite3ExprDup(db, pOrTerm->pExpr->pRight, 0);\n<line226>pList = sqlite3ExprListAppend(pWInfo->pParse, pList, pDup);\n<line227>pLeft = pOrTerm->pExpr->pLeft;\n<line228>}\n<line229>assert( pLeft!=0 );\n<line230>pDup = sqlite3ExprDup(db, pLeft, 0);\n<line231>pNew = sqlite3PExpr(pParse, TK_IN, pDup, 0);\n<line232>if( pNew ){\n<line233>int idxNew;\n<line234>transferJoinMarkings(pNew, pExpr);\n<line235>assert( ExprUseXList(pNew) );\n<line236>pNew->x.pList = pList;\n<line237>idxNew = whereClauseInsert(pWC, pNew, TERM_VIRTUAL|TERM_DYNAMIC);\n<line238>testcase( idxNew==0 );\n<line239>exprAnalyze(pSrc, pWC, idxNew);\n<line240>/* pTerm = &pWC->a[idxTerm]; // would be needed if pTerm where reused */\n<line241>markTermAsChild(pWC, idxNew, idxTerm);\n<line242>}else{\n<line243>sqlite3ExprListDelete(db, pList);\n<line244>}\n<line245>}\n<line246>}\n<line247>}
----------------------------------------
Function: termIsEquivalence
Content: <line0>static int termIsEquivalence(Parse *pParse, Expr *pExpr, SrcList *pSrc){\n<line1>char aff1, aff2;\n<line2>CollSeq *pColl;\n<line3>if( !OptimizationEnabled(pParse->db, SQLITE_Transitive) ) return 0;  /* (1) */\n<line4>if( pExpr->op!=TK_EQ && pExpr->op!=TK_IS ) return 0;                 /* (2) */\n<line5>if( ExprHasProperty(pExpr, EP_OuterON) ) return 0;                   /* (3) */\n<line6>assert( pSrc!=0 );\n<line7>if( pExpr->op==TK_IS\n<line8>&& pSrc->nSrc>=2\n<line9>&& (pSrc->a[0].fg.jointype & JT_LTORJ)!=0\n<line10>){\n<line11>return 0;                                                          /* (4) */\n<line12>}\n<line13>aff1 = sqlite3ExprAffinity(pExpr->pLeft);\n<line14>aff2 = sqlite3ExprAffinity(pExpr->pRight);\n<line15>if( aff1!=aff2\n<line16>&& (!sqlite3IsNumericAffinity(aff1) || !sqlite3IsNumericAffinity(aff2))\n<line17>){\n<line18>return 0;                                                          /* (5) */\n<line19>}\n<line20>pColl = sqlite3ExprCompareCollSeq(pParse, pExpr);\n<line21>if( !sqlite3IsBinary(pColl)\n<line22>&& !sqlite3ExprCollSeqMatch(pParse, pExpr->pLeft, pExpr->pRight)\n<line23>){\n<line24>return 0;                                                          /* (6) */\n<line25>}\n<line26>return 1;\n<line27>}
----------------------------------------
Function: exprSelectUsage
Content: <line0>static Bitmask exprSelectUsage(WhereMaskSet *pMaskSet, Select *pS){\n<line1>Bitmask mask = 0;\n<line2>while( pS ){\n<line3>SrcList *pSrc = pS->pSrc;\n<line4>mask |= sqlite3WhereExprListUsage(pMaskSet, pS->pEList);\n<line5>mask |= sqlite3WhereExprListUsage(pMaskSet, pS->pGroupBy);\n<line6>mask |= sqlite3WhereExprListUsage(pMaskSet, pS->pOrderBy);\n<line7>mask |= sqlite3WhereExprUsage(pMaskSet, pS->pWhere);\n<line8>mask |= sqlite3WhereExprUsage(pMaskSet, pS->pHaving);\n<line9>if( ALWAYS(pSrc!=0) ){\n<line10>int i;\n<line11>for(i=0; i<pSrc->nSrc; i++){\n<line12>if( pSrc->a[i].fg.isSubquery ){\n<line13>mask |= exprSelectUsage(pMaskSet, pSrc->a[i].u4.pSubq->pSelect);\n<line14>}\n<line15>if( pSrc->a[i].fg.isUsing==0 ){\n<line16>mask |= sqlite3WhereExprUsage(pMaskSet, pSrc->a[i].u3.pOn);\n<line17>}\n<line18>if( pSrc->a[i].fg.isTabFunc ){\n<line19>mask |= sqlite3WhereExprListUsage(pMaskSet, pSrc->a[i].u1.pFuncArg);\n<line20>}\n<line21>}\n<line22>}\n<line23>pS = pS->pPrior;\n<line24>}\n<line25>return mask;\n<line26>}
----------------------------------------
Function: exprMightBeIndexed2
Content: <line0>static SQLITE_NOINLINE int exprMightBeIndexed2(\n<line1>SrcList *pFrom,        /* The FROM clause */\n<line2>int *aiCurCol,         /* Write the referenced table cursor and column here */\n<line3>Expr *pExpr,           /* An operand of a comparison operator */\n<line4>int j                  /* Start looking with the j-th pFrom entry */\n<line5>){\n<line6>Index *pIdx;\n<line7>int i;\n<line8>int iCur;\n<line9>do{\n<line10>iCur = pFrom->a[j].iCursor;\n<line11>for(pIdx=pFrom->a[j].pSTab->pIndex; pIdx; pIdx=pIdx->pNext){\n<line12>if( pIdx->aColExpr==0 ) continue;\n<line13>for(i=0; i<pIdx->nKeyCol; i++){\n<line14>if( pIdx->aiColumn[i]!=XN_EXPR ) continue;\n<line15>assert( pIdx->bHasExpr );\n<line16>if( sqlite3ExprCompareSkip(pExpr,pIdx->aColExpr->a[i].pExpr,iCur)==0\n<line17>&& !sqlite3ExprIsConstant(0,pIdx->aColExpr->a[i].pExpr)\n<line18>){\n<line19>aiCurCol[0] = iCur;\n<line20>aiCurCol[1] = XN_EXPR;\n<line21>return 1;\n<line22>}\n<line23>}\n<line24>}\n<line25>}while( ++j < pFrom->nSrc );\n<line26>return 0;\n<line27>}
----------------------------------------
Function: exprMightBeIndexed
Content: <line0>static int exprMightBeIndexed(\n<line1>SrcList *pFrom,        /* The FROM clause */\n<line2>int *aiCurCol,         /* Write the referenced table cursor & column here */\n<line3>Expr *pExpr,           /* An operand of a comparison operator */\n<line4>int op                 /* The specific comparison operator */\n<line5>){\n<line6>int i;\n<line7>/* If this expression is a vector to the left or right of a\n<line8>** inequality constraint (>, <, >= or <=), perform the processing\n<line9>** on the first element of the vector.  */\n<line10>assert( TK_GT+1==TK_LE && TK_GT+2==TK_LT && TK_GT+3==TK_GE );\n<line11>assert( TK_IS<TK_GE && TK_ISNULL<TK_GE && TK_IN<TK_GE );\n<line12>assert( op<=TK_GE );\n<line13>if( pExpr->op==TK_VECTOR && (op>=TK_GT && ALWAYS(op<=TK_GE)) ){\n<line14>assert( ExprUseXList(pExpr) );\n<line15>pExpr = pExpr->x.pList->a[0].pExpr;\n<line16>}\n<line17>if( pExpr->op==TK_COLUMN ){\n<line18>aiCurCol[0] = pExpr->iTable;\n<line19>aiCurCol[1] = pExpr->iColumn;\n<line20>return 1;\n<line21>}\n<line22>for(i=0; i<pFrom->nSrc; i++){\n<line23>Index *pIdx;\n<line24>for(pIdx=pFrom->a[i].pSTab->pIndex; pIdx; pIdx=pIdx->pNext){\n<line25>if( pIdx->aColExpr ){\n<line26>return exprMightBeIndexed2(pFrom,aiCurCol,pExpr,i);\n<line27>}\n<line28>}\n<line29>}\n<line30>return 0;\n<line31>}
----------------------------------------
Function: exprAnalyze
Content: <line0>static void exprAnalyze(\n<line1>SrcList *pSrc,            /* the FROM clause */\n<line2>WhereClause *pWC,         /* the WHERE clause */\n<line3>int idxTerm               /* Index of the term to be analyzed */\n<line4>){\n<line5>WhereInfo *pWInfo = pWC->pWInfo; /* WHERE clause processing context */\n<line6>WhereTerm *pTerm;                /* The term to be analyzed */\n<line7>WhereMaskSet *pMaskSet;          /* Set of table index masks */\n<line8>Expr *pExpr;                     /* The expression to be analyzed */\n<line9>Bitmask prereqLeft;              /* Prerequisites of the pExpr->pLeft */\n<line10>Bitmask prereqAll;               /* Prerequisites of pExpr */\n<line11>Bitmask extraRight = 0;          /* Extra dependencies on LEFT JOIN */\n<line12>Expr *pStr1 = 0;                 /* RHS of LIKE/GLOB operator */\n<line13>int isComplete = 0;              /* RHS of LIKE/GLOB ends with wildcard */\n<line14>int noCase = 0;                  /* uppercase equivalent to lowercase */\n<line15>int op;                          /* Top-level operator.  pExpr->op */\n<line16>Parse *pParse = pWInfo->pParse;  /* Parsing context */\n<line17>sqlite3 *db = pParse->db;        /* Database connection */\n<line18>unsigned char eOp2 = 0;          /* op2 value for LIKE/REGEXP/GLOB */\n<line19>int nLeft;                       /* Number of elements on left side vector */\n<line20>if( db->mallocFailed ){\n<line21>return;\n<line22>}\n<line23>assert( pWC->nTerm > idxTerm );\n<line24>pTerm = &pWC->a[idxTerm];\n<line25>#ifdef SQLITE_DEBUG\n<line26>pTerm->iTerm = idxTerm;\n<line27>#endif\n<line28>pMaskSet = &pWInfo->sMaskSet;\n<line29>pExpr = pTerm->pExpr;\n<line30>assert( pExpr!=0 ); /* Because malloc() has not failed */\n<line31>assert( pExpr->op!=TK_AS && pExpr->op!=TK_COLLATE );\n<line32>pMaskSet->bVarSelect = 0;\n<line33>prereqLeft = sqlite3WhereExprUsage(pMaskSet, pExpr->pLeft);\n<line34>op = pExpr->op;\n<line35>if( op==TK_IN ){\n<line36>assert( pExpr->pRight==0 );\n<line37>if( sqlite3ExprCheckIN(pParse, pExpr) ) return;\n<line38>if( ExprUseXSelect(pExpr) ){\n<line39>pTerm->prereqRight = exprSelectUsage(pMaskSet, pExpr->x.pSelect);\n<line40>}else{\n<line41>pTerm->prereqRight = sqlite3WhereExprListUsage(pMaskSet, pExpr->x.pList);\n<line42>}\n<line43>prereqAll = prereqLeft | pTerm->prereqRight;\n<line44>}else{\n<line45>pTerm->prereqRight = sqlite3WhereExprUsage(pMaskSet, pExpr->pRight);\n<line46>if( pExpr->pLeft==0\n<line47>|| ExprHasProperty(pExpr, EP_xIsSelect|EP_IfNullRow)\n<line48>|| pExpr->x.pList!=0\n<line49>){\n<line50>prereqAll = sqlite3WhereExprUsageNN(pMaskSet, pExpr);\n<line51>}else{\n<line52>prereqAll = prereqLeft | pTerm->prereqRight;\n<line53>}\n<line54>}\n<line55>if( pMaskSet->bVarSelect ) pTerm->wtFlags |= TERM_VARSELECT;\n<line56>#ifdef SQLITE_DEBUG\n<line57>if( prereqAll!=sqlite3WhereExprUsageNN(pMaskSet, pExpr) ){\n<line58>printf("\n*** Incorrect prereqAll computed for:\n");\n<line59>sqlite3TreeViewExpr(0,pExpr,0);\n<line60>assert( 0 );\n<line61>}\n<line62>#endif\n<line63>if( ExprHasProperty(pExpr, EP_OuterON|EP_InnerON) ){\n<line64>Bitmask x = sqlite3WhereGetMask(pMaskSet, pExpr->w.iJoin);\n<line65>if( ExprHasProperty(pExpr, EP_OuterON) ){\n<line66>prereqAll |= x;\n<line67>extraRight = x-1;  /* ON clause terms may not be used with an index\n<line68>** on left table of a LEFT JOIN.  Ticket #3015 */\n<line69>}else if( (prereqAll>>1)>=x ){\n<line70>ExprClearProperty(pExpr, EP_InnerON);\n<line71>}\n<line72>}\n<line73>pTerm->prereqAll = prereqAll;\n<line74>pTerm->leftCursor = -1;\n<line75>pTerm->iParent = -1;\n<line76>pTerm->eOperator = 0;\n<line77>if( allowedOp(op) ){\n<line78>int aiCurCol[2];\n<line79>Expr *pLeft = sqlite3ExprSkipCollate(pExpr->pLeft);\n<line80>Expr *pRight = sqlite3ExprSkipCollate(pExpr->pRight);\n<line81>u16 opMask = (pTerm->prereqRight & prereqLeft)==0 ? WO_ALL : WO_EQUIV;\n<line82>if( pTerm->u.x.iField>0 ){\n<line83>assert( op==TK_IN );\n<line84>assert( pLeft->op==TK_VECTOR );\n<line85>assert( ExprUseXList(pLeft) );\n<line86>pLeft = pLeft->x.pList->a[pTerm->u.x.iField-1].pExpr;\n<line87>}\n<line88>if( exprMightBeIndexed(pSrc, aiCurCol, pLeft, op) ){\n<line89>pTerm->leftCursor = aiCurCol[0];\n<line90>assert( (pTerm->eOperator & (WO_OR|WO_AND))==0 );\n<line91>pTerm->u.x.leftColumn = aiCurCol[1];\n<line92>pTerm->eOperator = operatorMask(op) & opMask;\n<line93>}\n<line94>if( op==TK_IS ) pTerm->wtFlags |= TERM_IS;\n<line95>if( pRight\n<line96>&& exprMightBeIndexed(pSrc, aiCurCol, pRight, op)\n<line97>&& !ExprHasProperty(pRight, EP_FixedCol)\n<line98>){\n<line99>WhereTerm *pNew;\n<line100>Expr *pDup;\n<line101>u16 eExtraOp = 0;        /* Extra bits for pNew->eOperator */\n<line102>assert( pTerm->u.x.iField==0 );\n<line103>if( pTerm->leftCursor>=0 ){\n<line104>int idxNew;\n<line105>pDup = sqlite3ExprDup(db, pExpr, 0);\n<line106>if( db->mallocFailed ){\n<line107>sqlite3ExprDelete(db, pDup);\n<line108>return;\n<line109>}\n<line110>idxNew = whereClauseInsert(pWC, pDup, TERM_VIRTUAL|TERM_DYNAMIC);\n<line111>if( idxNew==0 ) return;\n<line112>pNew = &pWC->a[idxNew];\n<line113>markTermAsChild(pWC, idxNew, idxTerm);\n<line114>if( op==TK_IS ) pNew->wtFlags |= TERM_IS;\n<line115>pTerm = &pWC->a[idxTerm];\n<line116>pTerm->wtFlags |= TERM_COPIED;\n<line117>assert( pWInfo->pTabList!=0 );\n<line118>if( termIsEquivalence(pParse, pDup, pWInfo->pTabList) ){\n<line119>pTerm->eOperator |= WO_EQUIV;\n<line120>eExtraOp = WO_EQUIV;\n<line121>}\n<line122>}else{\n<line123>pDup = pExpr;\n<line124>pNew = pTerm;\n<line125>}\n<line126>pNew->wtFlags |= exprCommute(pParse, pDup);\n<line127>pNew->leftCursor = aiCurCol[0];\n<line128>assert( (pTerm->eOperator & (WO_OR|WO_AND))==0 );\n<line129>pNew->u.x.leftColumn = aiCurCol[1];\n<line130>testcase( (prereqLeft | extraRight) != prereqLeft );\n<line131>pNew->prereqRight = prereqLeft | extraRight;\n<line132>pNew->prereqAll = prereqAll;\n<line133>pNew->eOperator = (operatorMask(pDup->op) + eExtraOp) & opMask;\n<line134>}else\n<line135>if( op==TK_ISNULL\n<line136>&& !ExprHasProperty(pExpr,EP_OuterON)\n<line137>&& 0==sqlite3ExprCanBeNull(pLeft)\n<line138>){\n<line139>assert( !ExprHasProperty(pExpr, EP_IntValue) );\n<line140>pExpr->op = TK_TRUEFALSE;  /* See tag-20230504-1 */\n<line141>pExpr->u.zToken = "false";\n<line142>ExprSetProperty(pExpr, EP_IsFalse);\n<line143>pTerm->prereqAll = 0;\n<line144>pTerm->eOperator = 0;\n<line145>}\n<line146>}\n<line147>#ifndef SQLITE_OMIT_BETWEEN_OPTIMIZATION\n<line148>/* If a term is the BETWEEN operator, create two new virtual terms\n<line149>** that define the range that the BETWEEN implements.  For example:\n<line150>**\n<line151>**      a BETWEEN b AND c\n<line152>**\n<line153>** is converted into:\n<line154>**\n<line155>**      (a BETWEEN b AND c) AND (a>=b) AND (a<=c)\n<line156>**\n<line157>** The two new terms are added onto the end of the WhereClause object.\n<line158>** The new terms are "dynamic" and are children of the original BETWEEN\n<line159>** term.  That means that if the BETWEEN term is coded, the children are\n<line160>** skipped.  Or, if the children are satisfied by an index, the original\n<line161>** BETWEEN term is skipped.\n<line162>*/\n<line163>else if( pExpr->op==TK_BETWEEN && pWC->op==TK_AND ){\n<line164>ExprList *pList;\n<line165>int i;\n<line166>static const u8 ops[] = {TK_GE, TK_LE};\n<line167>assert( ExprUseXList(pExpr) );\n<line168>pList = pExpr->x.pList;\n<line169>assert( pList!=0 );\n<line170>assert( pList->nExpr==2 );\n<line171>for(i=0; i<2; i++){\n<line172>Expr *pNewExpr;\n<line173>int idxNew;\n<line174>pNewExpr = sqlite3PExpr(pParse, ops[i],\n<line175>sqlite3ExprDup(db, pExpr->pLeft, 0),\n<line176>sqlite3ExprDup(db, pList->a[i].pExpr, 0));\n<line177>transferJoinMarkings(pNewExpr, pExpr);\n<line178>idxNew = whereClauseInsert(pWC, pNewExpr, TERM_VIRTUAL|TERM_DYNAMIC);\n<line179>testcase( idxNew==0 );\n<line180>exprAnalyze(pSrc, pWC, idxNew);\n<line181>pTerm = &pWC->a[idxTerm];\n<line182>markTermAsChild(pWC, idxNew, idxTerm);\n<line183>}\n<line184>}\n<line185>#endif /* SQLITE_OMIT_BETWEEN_OPTIMIZATION */\n<line186>#if !defined(SQLITE_OMIT_OR_OPTIMIZATION) && !defined(SQLITE_OMIT_SUBQUERY)\n<line187>/* Analyze a term that is composed of two or more subterms connected by\n<line188>** an OR operator.\n<line189>*/\n<line190>else if( pExpr->op==TK_OR ){\n<line191>assert( pWC->op==TK_AND );\n<line192>exprAnalyzeOrTerm(pSrc, pWC, idxTerm);\n<line193>pTerm = &pWC->a[idxTerm];\n<line194>}\n<line195>#endif /* SQLITE_OMIT_OR_OPTIMIZATION */\n<line196>/* The form "x IS NOT NULL" can sometimes be evaluated more efficiently\n<line197>** as "x>NULL" if x is not an INTEGER PRIMARY KEY.  So construct a\n<line198>** virtual term of that form.\n<line199>**\n<line200>** The virtual term must be tagged with TERM_VNULL.\n<line201>*/\n<line202>else if( pExpr->op==TK_NOTNULL ){\n<line203>if( pExpr->pLeft->op==TK_COLUMN\n<line204>&& pExpr->pLeft->iColumn>=0\n<line205>&& !ExprHasProperty(pExpr, EP_OuterON)\n<line206>){\n<line207>Expr *pNewExpr;\n<line208>Expr *pLeft = pExpr->pLeft;\n<line209>int idxNew;\n<line210>WhereTerm *pNewTerm;\n<line211>pNewExpr = sqlite3PExpr(pParse, TK_GT,\n<line212>sqlite3ExprDup(db, pLeft, 0),\n<line213>sqlite3ExprAlloc(db, TK_NULL, 0, 0));\n<line214>idxNew = whereClauseInsert(pWC, pNewExpr,\n<line215>TERM_VIRTUAL|TERM_DYNAMIC|TERM_VNULL);\n<line216>if( idxNew ){\n<line217>pNewTerm = &pWC->a[idxNew];\n<line218>pNewTerm->prereqRight = 0;\n<line219>pNewTerm->leftCursor = pLeft->iTable;\n<line220>pNewTerm->u.x.leftColumn = pLeft->iColumn;\n<line221>pNewTerm->eOperator = WO_GT;\n<line222>markTermAsChild(pWC, idxNew, idxTerm);\n<line223>pTerm = &pWC->a[idxTerm];\n<line224>pTerm->wtFlags |= TERM_COPIED;\n<line225>pNewTerm->prereqAll = pTerm->prereqAll;\n<line226>}\n<line227>}\n<line228>}\n<line229>#ifndef SQLITE_OMIT_LIKE_OPTIMIZATION\n<line230>/* Add constraints to reduce the search space on a LIKE or GLOB\n<line231>** operator.\n<line232>**\n<line233>** A like pattern of the form "x LIKE 'aBc%'" is changed into constraints\n<line234>**\n<line235>**          x>='ABC' AND x<'abd' AND x LIKE 'aBc%'\n<line236>**\n<line237>** The last character of the prefix "abc" is incremented to form the\n<line238>** termination condition "abd".  If case is not significant (the default\n<line239>** for LIKE) then the lower-bound is made all uppercase and the upper-\n<line240>** bound is made all lowercase so that the bounds also work when comparing\n<line241>** BLOBs.\n<line242>*/\n<line243>else if( pExpr->op==TK_FUNCTION\n<line244>&& pWC->op==TK_AND\n<line245>&& isLikeOrGlob(pParse, pExpr, &pStr1, &isComplete, &noCase)\n<line246>){\n<line247>Expr *pLeft;       /* LHS of LIKE/GLOB operator */\n<line248>Expr *pStr2;       /* Copy of pStr1 - RHS of LIKE/GLOB operator */\n<line249>Expr *pNewExpr1;\n<line250>Expr *pNewExpr2;\n<line251>int idxNew1;\n<line252>int idxNew2;\n<line253>const char *zCollSeqName;     /* Name of collating sequence */\n<line254>const u16 wtFlags = TERM_LIKEOPT | TERM_VIRTUAL | TERM_DYNAMIC;\n<line255>assert( ExprUseXList(pExpr) );\n<line256>pLeft = pExpr->x.pList->a[1].pExpr;\n<line257>pStr2 = sqlite3ExprDup(db, pStr1, 0);\n<line258>assert( pStr1==0 || !ExprHasProperty(pStr1, EP_IntValue) );\n<line259>assert( pStr2==0 || !ExprHasProperty(pStr2, EP_IntValue) );\n<line260>/* Convert the lower bound to upper-case and the upper bound to\n<line261>** lower-case (upper-case is less than lower-case in ASCII) so that\n<line262>** the range constraints also work for BLOBs\n<line263>*/\n<line264>if( noCase && !pParse->db->mallocFailed ){\n<line265>int i;\n<line266>char c;\n<line267>pTerm->wtFlags |= TERM_LIKE;\n<line268>for(i=0; (c = pStr1->u.zToken[i])!=0; i++){\n<line269>pStr1->u.zToken[i] = sqlite3Toupper(c);\n<line270>pStr2->u.zToken[i] = sqlite3Tolower(c);\n<line271>}\n<line272>}\n<line273>if( !db->mallocFailed ){\n<line274>u8 *pC;       /* Last character before the first wildcard */\n<line275>pC = (u8*)&pStr2->u.zToken[sqlite3Strlen30(pStr2->u.zToken)-1];\n<line276>if( noCase ){\n<line277>/* The point is to increment the last character before the first\n<line278>** wildcard.  But if we increment '@', that will push it into the\n<line279>** alphabetic range where case conversions will mess up the\n<line280>** inequality.  To avoid this, make sure to also run the full\n<line281>** LIKE on all candidate expressions by clearing the isComplete flag\n<line282>*/\n<line283>if( *pC=='A'-1 ) isComplete = 0;\n<line284>*pC = sqlite3UpperToLower[*pC];\n<line285>}\n<line286>/* Increment the value of the last utf8 character in the prefix. */\n<line287>while( *pC==0xBF && pC>(u8*)pStr2->u.zToken ){\n<line288>*pC = 0x80;\n<line289>pC--;\n<line290>}\n<line291>assert( *pC!=0xFF );        /* isLikeOrGlob() guarantees this */\n<line292>(*pC)++;\n<line293>}\n<line294>zCollSeqName = noCase ? "NOCASE" : sqlite3StrBINARY;\n<line295>pNewExpr1 = sqlite3ExprDup(db, pLeft, 0);\n<line296>pNewExpr1 = sqlite3PExpr(pParse, TK_GE,\n<line297>sqlite3ExprAddCollateString(pParse,pNewExpr1,zCollSeqName),\n<line298>pStr1);\n<line299>transferJoinMarkings(pNewExpr1, pExpr);\n<line300>idxNew1 = whereClauseInsert(pWC, pNewExpr1, wtFlags);\n<line301>testcase( idxNew1==0 );\n<line302>pNewExpr2 = sqlite3ExprDup(db, pLeft, 0);\n<line303>pNewExpr2 = sqlite3PExpr(pParse, TK_LT,\n<line304>sqlite3ExprAddCollateString(pParse,pNewExpr2,zCollSeqName),\n<line305>pStr2);\n<line306>transferJoinMarkings(pNewExpr2, pExpr);\n<line307>idxNew2 = whereClauseInsert(pWC, pNewExpr2, wtFlags);\n<line308>testcase( idxNew2==0 );\n<line309>exprAnalyze(pSrc, pWC, idxNew1);\n<line310>exprAnalyze(pSrc, pWC, idxNew2);\n<line311>pTerm = &pWC->a[idxTerm];\n<line312>if( isComplete ){\n<line313>markTermAsChild(pWC, idxNew1, idxTerm);\n<line314>markTermAsChild(pWC, idxNew2, idxTerm);\n<line315>}\n<line316>}\n<line317>#endif /* SQLITE_OMIT_LIKE_OPTIMIZATION */\n<line318>/* If there is a vector == or IS term - e.g. "(a, b) == (?, ?)" - create\n<line319>** new terms for each component comparison - "a = ?" and "b = ?".  The\n<line320>** new terms completely replace the original vector comparison, which is\n<line321>** no longer used.\n<line322>**\n<line323>** This is only required if at least one side of the comparison operation\n<line324>** is not a sub-select.\n<line325>**\n<line326>** tag-20220128a\n<line327>*/\n<line328>if( (pExpr->op==TK_EQ || pExpr->op==TK_IS)\n<line329>&& (nLeft = sqlite3ExprVectorSize(pExpr->pLeft))>1\n<line330>&& sqlite3ExprVectorSize(pExpr->pRight)==nLeft\n<line331>&& ( (pExpr->pLeft->flags & EP_xIsSelect)==0\n<line332>|| (pExpr->pRight->flags & EP_xIsSelect)==0)\n<line333>&& pWC->op==TK_AND\n<line334>){\n<line335>int i;\n<line336>for(i=0; i<nLeft; i++){\n<line337>int idxNew;\n<line338>Expr *pNew;\n<line339>Expr *pLeft = sqlite3ExprForVectorField(pParse, pExpr->pLeft, i, nLeft);\n<line340>Expr *pRight = sqlite3ExprForVectorField(pParse, pExpr->pRight, i, nLeft);\n<line341>pNew = sqlite3PExpr(pParse, pExpr->op, pLeft, pRight);\n<line342>transferJoinMarkings(pNew, pExpr);\n<line343>idxNew = whereClauseInsert(pWC, pNew, TERM_DYNAMIC|TERM_SLICE);\n<line344>exprAnalyze(pSrc, pWC, idxNew);\n<line345>}\n<line346>pTerm = &pWC->a[idxTerm];\n<line347>pTerm->wtFlags |= TERM_CODED|TERM_VIRTUAL;  /* Disable the original */\n<line348>pTerm->eOperator = WO_ROWVAL;\n<line349>}\n<line350>/* If there is a vector IN term - e.g. "(a, b) IN (SELECT ...)" - create\n<line351>** a virtual term for each vector component. The expression object\n<line352>** used by each such virtual term is pExpr (the full vector IN(...)\n<line353>** expression). The WhereTerm.u.x.iField variable identifies the index within\n<line354>** the vector on the LHS that the virtual term represents.\n<line355>**\n<line356>** This only works if the RHS is a simple SELECT (not a compound) that does\n<line357>** not use window functions.\n<line358>*/\n<line359>else if( pExpr->op==TK_IN\n<line360>&& pTerm->u.x.iField==0\n<line361>&& pExpr->pLeft->op==TK_VECTOR\n<line362>&& ALWAYS( ExprUseXSelect(pExpr) )\n<line363>&& (pExpr->x.pSelect->pPrior==0 || (pExpr->x.pSelect->selFlags & SF_Values))\n<line364>#ifndef SQLITE_OMIT_WINDOWFUNC\n<line365>&& pExpr->x.pSelect->pWin==0\n<line366>#endif\n<line367>&& pWC->op==TK_AND\n<line368>){\n<line369>int i;\n<line370>for(i=0; i<sqlite3ExprVectorSize(pExpr->pLeft); i++){\n<line371>int idxNew;\n<line372>idxNew = whereClauseInsert(pWC, pExpr, TERM_VIRTUAL|TERM_SLICE);\n<line373>pWC->a[idxNew].u.x.iField = i+1;\n<line374>exprAnalyze(pSrc, pWC, idxNew);\n<line375>markTermAsChild(pWC, idxNew, idxTerm);\n<line376>}\n<line377>}\n<line378>#ifndef SQLITE_OMIT_VIRTUALTABLE\n<line379>/* Add a WO_AUX auxiliary term to the constraint set if the\n<line380>** current expression is of the form "column OP expr" where OP\n<line381>** is an operator that gets passed into virtual tables but which is\n<line382>** not normally optimized for ordinary tables.  In other words, OP\n<line383>** is one of MATCH, LIKE, GLOB, REGEXP, !=, IS, IS NOT, or NOT NULL.\n<line384>** This information is used by the xBestIndex methods of\n<line385>** virtual tables.  The native query optimizer does not attempt\n<line386>** to do anything with MATCH functions.\n<line387>*/\n<line388>else if( pWC->op==TK_AND ){\n<line389>Expr *pRight = 0, *pLeft = 0;\n<line390>int res = isAuxiliaryVtabOperator(db, pExpr, &eOp2, &pLeft, &pRight);\n<line391>while( res-- > 0 ){\n<line392>int idxNew;\n<line393>WhereTerm *pNewTerm;\n<line394>Bitmask prereqColumn, prereqExpr;\n<line395>prereqExpr = sqlite3WhereExprUsage(pMaskSet, pRight);\n<line396>prereqColumn = sqlite3WhereExprUsage(pMaskSet, pLeft);\n<line397>if( (prereqExpr & prereqColumn)==0 ){\n<line398>Expr *pNewExpr;\n<line399>pNewExpr = sqlite3PExpr(pParse, TK_MATCH,\n<line400>0, sqlite3ExprDup(db, pRight, 0));\n<line401>if( ExprHasProperty(pExpr, EP_OuterON) && pNewExpr ){\n<line402>ExprSetProperty(pNewExpr, EP_OuterON);\n<line403>pNewExpr->w.iJoin = pExpr->w.iJoin;\n<line404>}\n<line405>idxNew = whereClauseInsert(pWC, pNewExpr, TERM_VIRTUAL|TERM_DYNAMIC);\n<line406>testcase( idxNew==0 );\n<line407>pNewTerm = &pWC->a[idxNew];\n<line408>pNewTerm->prereqRight = prereqExpr | extraRight;\n<line409>pNewTerm->leftCursor = pLeft->iTable;\n<line410>pNewTerm->u.x.leftColumn = pLeft->iColumn;\n<line411>pNewTerm->eOperator = WO_AUX;\n<line412>pNewTerm->eMatchOp = eOp2;\n<line413>markTermAsChild(pWC, idxNew, idxTerm);\n<line414>pTerm = &pWC->a[idxTerm];\n<line415>pTerm->wtFlags |= TERM_COPIED;\n<line416>pNewTerm->prereqAll = pTerm->prereqAll;\n<line417>}\n<line418>SWAP(Expr*, pLeft, pRight);\n<line419>}\n<line420>}\n<line421>#endif /* SQLITE_OMIT_VIRTUALTABLE */\n<line422>/* Prevent ON clause terms of a LEFT JOIN from being used to drive\n<line423>** an index for tables to the left of the join.\n<line424>*/\n<line425>testcase( pTerm!=&pWC->a[idxTerm] );\n<line426>pTerm = &pWC->a[idxTerm];\n<line427>pTerm->prereqRight |= extraRight;\n<line428>}
----------------------------------------
Function: whereAddLimitExpr
Content: <line0>static void whereAddLimitExpr(\n<line1>WhereClause *pWC,   /* Add the constraint to this WHERE clause */\n<line2>int iReg,           /* Register that will hold value of the limit/offset */\n<line3>Expr *pExpr,        /* Expression that defines the limit/offset */\n<line4>int iCsr,           /* Cursor to which the constraint applies */\n<line5>int eMatchOp        /* SQLITE_INDEX_CONSTRAINT_LIMIT or _OFFSET */\n<line6>){\n<line7>Parse *pParse = pWC->pWInfo->pParse;\n<line8>sqlite3 *db = pParse->db;\n<line9>Expr *pNew;\n<line10>int iVal = 0;\n<line11>if( sqlite3ExprIsInteger(pExpr, &iVal, pParse) && iVal>=0 ){\n<line12>Expr *pVal = sqlite3Expr(db, TK_INTEGER, 0);\n<line13>if( pVal==0 ) return;\n<line14>ExprSetProperty(pVal, EP_IntValue);\n<line15>pVal->u.iValue = iVal;\n<line16>pNew = sqlite3PExpr(pParse, TK_MATCH, 0, pVal);\n<line17>}else{\n<line18>Expr *pVal = sqlite3Expr(db, TK_REGISTER, 0);\n<line19>if( pVal==0 ) return;\n<line20>pVal->iTable = iReg;\n<line21>pNew = sqlite3PExpr(pParse, TK_MATCH, 0, pVal);\n<line22>}\n<line23>if( pNew ){\n<line24>WhereTerm *pTerm;\n<line25>int idx;\n<line26>idx = whereClauseInsert(pWC, pNew, TERM_DYNAMIC|TERM_VIRTUAL);\n<line27>pTerm = &pWC->a[idx];\n<line28>pTerm->leftCursor = iCsr;\n<line29>pTerm->eOperator = WO_AUX;\n<line30>pTerm->eMatchOp = eMatchOp;\n<line31>}\n<line32>}
----------------------------------------
Function: sqlite3WhereExprUsageFull
Content: <line0>static SQLITE_NOINLINE Bitmask sqlite3WhereExprUsageFull(\n<line1>WhereMaskSet *pMaskSet,\n<line2>Expr *p\n<line3>){\n<line4>Bitmask mask;\n<line5>mask = (p->op==TK_IF_NULL_ROW) ? sqlite3WhereGetMask(pMaskSet, p->iTable) : 0;\n<line6>if( p->pLeft ) mask |= sqlite3WhereExprUsageNN(pMaskSet, p->pLeft);\n<line7>if( p->pRight ){\n<line8>mask |= sqlite3WhereExprUsageNN(pMaskSet, p->pRight);\n<line9>assert( p->x.pList==0 );\n<line10>}else if( ExprUseXSelect(p) ){\n<line11>if( ExprHasProperty(p, EP_VarSelect) ) pMaskSet->bVarSelect = 1;\n<line12>mask |= exprSelectUsage(pMaskSet, p->x.pSelect);\n<line13>}else if( p->x.pList ){\n<line14>mask |= sqlite3WhereExprListUsage(pMaskSet, p->x.pList);\n<line15>}\n<line16>#ifndef SQLITE_OMIT_WINDOWFUNC\n<line17>if( (p->op==TK_FUNCTION || p->op==TK_AGG_FUNCTION) && ExprUseYWin(p) ){\n<line18>assert( p->y.pWin!=0 );\n<line19>mask |= sqlite3WhereExprListUsage(pMaskSet, p->y.pWin->pPartition);\n<line20>mask |= sqlite3WhereExprListUsage(pMaskSet, p->y.pWin->pOrderBy);\n<line21>mask |= sqlite3WhereExprUsage(pMaskSet, p->y.pWin->pFilter);\n<line22>}\n<line23>#endif\n<line24>return mask;\n<line25>}
----------------------------------------
Function: whereOrMove
Content: <line0>static void whereOrMove(WhereOrSet *pDest, WhereOrSet *pSrc){\n<line1>pDest->n = pSrc->n;\n<line2>memcpy(pDest->a, pSrc->a, pDest->n*sizeof(pDest->a[0]));\n<line3>}
----------------------------------------
Function: whereOrInsert
Content: <line0>static int whereOrInsert(\n<line1>WhereOrSet *pSet,      /* The WhereOrSet to be updated */\n<line2>Bitmask prereq,        /* Prerequisites of the new entry */\n<line3>LogEst rRun,           /* Run-cost of the new entry */\n<line4>LogEst nOut            /* Number of outputs for the new entry */\n<line5>){\n<line6>u16 i;\n<line7>WhereOrCost *p;\n<line8>for(i=pSet->n, p=pSet->a; i>0; i--, p++){\n<line9>if( rRun<=p->rRun && (prereq & p->prereq)==prereq ){\n<line10>goto whereOrInsert_done;\n<line11>}\n<line12>if( p->rRun<=rRun && (p->prereq & prereq)==p->prereq ){\n<line13>return 0;\n<line14>}\n<line15>}\n<line16>if( pSet->n<N_OR_COST ){\n<line17>p = &pSet->a[pSet->n++];\n<line18>p->nOut = nOut;\n<line19>}else{\n<line20>p = pSet->a;\n<line21>for(i=1; i<pSet->n; i++){\n<line22>if( p->rRun>pSet->a[i].rRun ) p = pSet->a + i;\n<line23>}\n<line24>if( p->rRun<=rRun ) return 0;\n<line25>}\n<line26>whereOrInsert_done:\n<line27>p->prereq = prereq;\n<line28>p->rRun = rRun;\n<line29>if( p->nOut>nOut ) p->nOut = nOut;\n<line30>return 1;\n<line31>}
----------------------------------------
Function: createMask
Content: <line0>static void createMask(WhereMaskSet *pMaskSet, int iCursor){\n<line1>assert( pMaskSet->n < ArraySize(pMaskSet->ix) );\n<line2>pMaskSet->ix[pMaskSet->n++] = iCursor;\n<line3>}
----------------------------------------
Function: whereRightSubexprIsColumn
Content: <line0>static Expr *whereRightSubexprIsColumn(Expr *p){\n<line1>p = sqlite3ExprSkipCollateAndLikely(p->pRight);\n<line2>if( ALWAYS(p!=0) && p->op==TK_COLUMN && !ExprHasProperty(p, EP_FixedCol) ){\n<line3>return p;\n<line4>}\n<line5>return 0;\n<line6>}
----------------------------------------
Function: indexInAffinityOk
Content: <line0>static SQLITE_NOINLINE const char *indexInAffinityOk(\n<line1>Parse *pParse,\n<line2>WhereTerm *pTerm,\n<line3>u8 idxaff\n<line4>){\n<line5>Expr *pX = pTerm->pExpr;\n<line6>Expr inexpr;\n<line7>assert( pTerm->eOperator & WO_IN );\n<line8>if( sqlite3ExprIsVector(pX->pLeft) ){\n<line9>int iField = pTerm->u.x.iField - 1;\n<line10>inexpr.flags = 0;\n<line11>inexpr.op = TK_EQ;\n<line12>inexpr.pLeft = pX->pLeft->x.pList->a[iField].pExpr;\n<line13>assert( ExprUseXSelect(pX) );\n<line14>inexpr.pRight = pX->x.pSelect->pEList->a[iField].pExpr;\n<line15>pX = &inexpr;\n<line16>}\n<line17>if( sqlite3IndexAffinityOk(pX, idxaff) ){\n<line18>CollSeq *pRet = sqlite3ExprCompareCollSeq(pParse, pX);\n<line19>return pRet ? pRet->zName : sqlite3StrBINARY;\n<line20>}\n<line21>return 0;\n<line22>}
----------------------------------------
Function: whereScanNext
Content: <line0>static WhereTerm *whereScanNext(WhereScan *pScan){\n<line1>int iCur;            /* The cursor on the LHS of the term */\n<line2>i16 iColumn;         /* The column on the LHS of the term.  -1 for IPK */\n<line3>Expr *pX;            /* An expression being tested */\n<line4>WhereClause *pWC;    /* Shorthand for pScan->pWC */\n<line5>WhereTerm *pTerm;    /* The term being tested */\n<line6>int k = pScan->k;    /* Where to start scanning */\n<line7>assert( pScan->iEquiv<=pScan->nEquiv );\n<line8>pWC = pScan->pWC;\n<line9>while(1){\n<line10>iColumn = pScan->aiColumn[pScan->iEquiv-1];\n<line11>iCur = pScan->aiCur[pScan->iEquiv-1];\n<line12>assert( pWC!=0 );\n<line13>assert( iCur>=0 );\n<line14>do{\n<line15>for(pTerm=pWC->a+k; k<pWC->nTerm; k++, pTerm++){\n<line16>assert( (pTerm->eOperator & (WO_OR|WO_AND))==0 || pTerm->leftCursor<0 );\n<line17>if( pTerm->leftCursor==iCur\n<line18>&& pTerm->u.x.leftColumn==iColumn\n<line19>&& (iColumn!=XN_EXPR\n<line20>|| sqlite3ExprCompareSkip(pTerm->pExpr->pLeft,\n<line21>pScan->pIdxExpr,iCur)==0)\n<line22>&& (pScan->iEquiv<=1 || !ExprHasProperty(pTerm->pExpr, EP_OuterON))\n<line23>){\n<line24>if( (pTerm->eOperator & WO_EQUIV)!=0\n<line25>&& pScan->nEquiv<ArraySize(pScan->aiCur)\n<line26>&& (pX = whereRightSubexprIsColumn(pTerm->pExpr))!=0\n<line27>){\n<line28>int j;\n<line29>for(j=0; j<pScan->nEquiv; j++){\n<line30>if( pScan->aiCur[j]==pX->iTable\n<line31>&& pScan->aiColumn[j]==pX->iColumn ){\n<line32>break;\n<line33>}\n<line34>}\n<line35>if( j==pScan->nEquiv ){\n<line36>pScan->aiCur[j] = pX->iTable;\n<line37>pScan->aiColumn[j] = pX->iColumn;\n<line38>pScan->nEquiv++;\n<line39>}\n<line40>}\n<line41>if( (pTerm->eOperator & pScan->opMask)!=0 ){\n<line42>/* Verify the affinity and collating sequence match */\n<line43>if( pScan->zCollName && (pTerm->eOperator & WO_ISNULL)==0 ){\n<line44>const char *zCollName;\n<line45>Parse *pParse = pWC->pWInfo->pParse;\n<line46>pX = pTerm->pExpr;\n<line47>if( (pTerm->eOperator & WO_IN) ){\n<line48>zCollName = indexInAffinityOk(pParse, pTerm, pScan->idxaff);\n<line49>if( !zCollName ) continue;\n<line50>}else{\n<line51>CollSeq *pColl;\n<line52>if( !sqlite3IndexAffinityOk(pX, pScan->idxaff) ){\n<line53>continue;\n<line54>}\n<line55>assert(pX->pLeft);\n<line56>pColl = sqlite3ExprCompareCollSeq(pParse, pX);\n<line57>zCollName = pColl ? pColl->zName : sqlite3StrBINARY;\n<line58>}\n<line59>if( sqlite3StrICmp(zCollName, pScan->zCollName) ){\n<line60>continue;\n<line61>}\n<line62>}\n<line63>if( (pTerm->eOperator & (WO_EQ|WO_IS))!=0\n<line64>&& (pX = pTerm->pExpr->pRight, ALWAYS(pX!=0))\n<line65>&& pX->op==TK_COLUMN\n<line66>&& pX->iTable==pScan->aiCur[0]\n<line67>&& pX->iColumn==pScan->aiColumn[0]\n<line68>){\n<line69>testcase( pTerm->eOperator & WO_IS );\n<line70>continue;\n<line71>}\n<line72>pScan->pWC = pWC;\n<line73>pScan->k = k+1;\n<line74>#ifdef WHERETRACE_ENABLED\n<line75>if( (sqlite3WhereTrace & 0x20000)!=0 && pScan->nEquiv>1 ){\n<line76>int ii;\n<line77>sqlite3DebugPrintf("EQUIVALENT TO {%d:%d} (due to TERM-%d):",\n<line78>pScan->aiCur[0], pScan->aiColumn[0], pTerm->iTerm);\n<line79>for(ii=1; ii<pScan->nEquiv; ii++){\n<line80>sqlite3DebugPrintf(" {%d:%d}",\n<line81>pScan->aiCur[ii], pScan->aiColumn[ii]);\n<line82>}\n<line83>sqlite3DebugPrintf("\n");\n<line84>}\n<line85>#endif\n<line86>return pTerm;\n<line87>}\n<line88>}\n<line89>}\n<line90>pWC = pWC->pOuter;\n<line91>k = 0;\n<line92>}while( pWC!=0 );\n<line93>if( pScan->iEquiv>=pScan->nEquiv ) break;\n<line94>pWC = pScan->pOrigWC;\n<line95>k = 0;\n<line96>pScan->iEquiv++;\n<line97>}\n<line98>return 0;\n<line99>}
----------------------------------------
Function: whereScanInitIndexExpr
Content: <line0>static SQLITE_NOINLINE WhereTerm *whereScanInitIndexExpr(WhereScan *pScan){\n<line1>pScan->idxaff = sqlite3ExprAffinity(pScan->pIdxExpr);\n<line2>return whereScanNext(pScan);\n<line3>}
----------------------------------------
Function: whereScanInit
Content: <line0>static WhereTerm *whereScanInit(\n<line1>WhereScan *pScan,       /* The WhereScan object being initialized */\n<line2>WhereClause *pWC,       /* The WHERE clause to be scanned */\n<line3>int iCur,               /* Cursor to scan for */\n<line4>int iColumn,            /* Column to scan for */\n<line5>u32 opMask,             /* Operator(s) to scan for */\n<line6>Index *pIdx             /* Must be compatible with this index */\n<line7>){\n<line8>pScan->pOrigWC = pWC;\n<line9>pScan->pWC = pWC;\n<line10>pScan->pIdxExpr = 0;\n<line11>pScan->idxaff = 0;\n<line12>pScan->zCollName = 0;\n<line13>pScan->opMask = opMask;\n<line14>pScan->k = 0;\n<line15>pScan->aiCur[0] = iCur;\n<line16>pScan->nEquiv = 1;\n<line17>pScan->iEquiv = 1;\n<line18>if( pIdx ){\n<line19>int j = iColumn;\n<line20>iColumn = pIdx->aiColumn[j];\n<line21>if( iColumn==pIdx->pTable->iPKey ){\n<line22>iColumn = XN_ROWID;\n<line23>}else if( iColumn>=0 ){\n<line24>pScan->idxaff = pIdx->pTable->aCol[iColumn].affinity;\n<line25>pScan->zCollName = pIdx->azColl[j];\n<line26>}else if( iColumn==XN_EXPR ){\n<line27>pScan->pIdxExpr = pIdx->aColExpr->a[j].pExpr;\n<line28>pScan->zCollName = pIdx->azColl[j];\n<line29>pScan->aiColumn[0] = XN_EXPR;\n<line30>return whereScanInitIndexExpr(pScan);\n<line31>}\n<line32>}else if( iColumn==XN_EXPR ){\n<line33>return 0;\n<line34>}\n<line35>pScan->aiColumn[0] = iColumn;\n<line36>return whereScanNext(pScan);\n<line37>}
----------------------------------------
Function: findIndexCol
Content: <line0>static int findIndexCol(\n<line1>Parse *pParse,                  /* Parse context */\n<line2>ExprList *pList,                /* Expression list to search */\n<line3>int iBase,                      /* Cursor for table associated with pIdx */\n<line4>Index *pIdx,                    /* Index to match column of */\n<line5>int iCol                        /* Column of index to match */\n<line6>){\n<line7>int i;\n<line8>const char *zColl = pIdx->azColl[iCol];\n<line9>for(i=0; i<pList->nExpr; i++){\n<line10>Expr *p = sqlite3ExprSkipCollateAndLikely(pList->a[i].pExpr);\n<line11>if( ALWAYS(p!=0)\n<line12>&& (p->op==TK_COLUMN || p->op==TK_AGG_COLUMN)\n<line13>&& p->iColumn==pIdx->aiColumn[iCol]\n<line14>&& p->iTable==iBase\n<line15>){\n<line16>CollSeq *pColl = sqlite3ExprNNCollSeq(pParse, pList->a[i].pExpr);\n<line17>if( 0==sqlite3StrICmp(pColl->zName, zColl) ){\n<line18>return i;\n<line19>}\n<line20>}\n<line21>}\n<line22>return -1;\n<line23>}
----------------------------------------
Function: indexColumnNotNull
Content: <line0>static int indexColumnNotNull(Index *pIdx, int iCol){\n<line1>int j;\n<line2>assert( pIdx!=0 );\n<line3>assert( iCol>=0 && iCol<pIdx->nColumn );\n<line4>j = pIdx->aiColumn[iCol];\n<line5>if( j>=0 ){\n<line6>return pIdx->pTable->aCol[j].notNull;\n<line7>}else if( j==(-1) ){\n<line8>return 1;\n<line9>}else{\n<line10>assert( j==(-2) );\n<line11>return 0;  /* Assume an indexed expression can always yield a NULL */\n<line12>}\n<line13>}
----------------------------------------
Function: isDistinctRedundant
Content: <line0>static int isDistinctRedundant(\n<line1>Parse *pParse,            /* Parsing context */\n<line2>SrcList *pTabList,        /* The FROM clause */\n<line3>WhereClause *pWC,         /* The WHERE clause */\n<line4>ExprList *pDistinct       /* The result set that needs to be DISTINCT */\n<line5>){\n<line6>Table *pTab;\n<line7>Index *pIdx;\n<line8>int i;\n<line9>int iBase;\n<line10>/* If there is more than one table or sub-select in the FROM clause of\n<line11>** this query, then it will not be possible to show that the DISTINCT\n<line12>** clause is redundant. */\n<line13>if( pTabList->nSrc!=1 ) return 0;\n<line14>iBase = pTabList->a[0].iCursor;\n<line15>pTab = pTabList->a[0].pSTab;\n<line16>/* If any of the expressions is an IPK column on table iBase, then return\n<line17>** true. Note: The (p->iTable==iBase) part of this test may be false if the\n<line18>** current SELECT is a correlated sub-query.\n<line19>*/\n<line20>for(i=0; i<pDistinct->nExpr; i++){\n<line21>Expr *p = sqlite3ExprSkipCollateAndLikely(pDistinct->a[i].pExpr);\n<line22>if( NEVER(p==0) ) continue;\n<line23>if( p->op!=TK_COLUMN && p->op!=TK_AGG_COLUMN ) continue;\n<line24>if( p->iTable==iBase && p->iColumn<0 ) return 1;\n<line25>}\n<line26>/* Loop through all indices on the table, checking each to see if it makes\n<line27>** the DISTINCT qualifier redundant. It does so if:\n<line28>**\n<line29>**   1. The index is itself UNIQUE, and\n<line30>**\n<line31>**   2. All of the columns in the index are either part of the pDistinct\n<line32>**      list, or else the WHERE clause contains a term of the form "col=X",\n<line33>**      where X is a constant value. The collation sequences of the\n<line34>**      comparison and select-list expressions must match those of the index.\n<line35>**\n<line36>**   3. All of those index columns for which the WHERE clause does not\n<line37>**      contain a "col=X" term are subject to a NOT NULL constraint.\n<line38>*/\n<line39>for(pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext){\n<line40>if( !IsUniqueIndex(pIdx) ) continue;\n<line41>if( pIdx->pPartIdxWhere ) continue;\n<line42>for(i=0; i<pIdx->nKeyCol; i++){\n<line43>if( 0==sqlite3WhereFindTerm(pWC, iBase, i, ~(Bitmask)0, WO_EQ, pIdx) ){\n<line44>if( findIndexCol(pParse, pDistinct, iBase, pIdx, i)<0 ) break;\n<line45>if( indexColumnNotNull(pIdx, i)==0 ) break;\n<line46>}\n<line47>}\n<line48>if( i==pIdx->nKeyCol ){\n<line49>/* This index implies that the DISTINCT qualifier is redundant. */\n<line50>return 1;\n<line51>}\n<line52>}\n<line53>return 0;\n<line54>}
----------------------------------------
Function: estLog
Content: <line0>static LogEst estLog(LogEst N){\n<line1>return N<=10 ? 0 : sqlite3LogEst(N) - 33;\n<line2>}
----------------------------------------
Function: translateColumnToCopy
Content: <line0>static void translateColumnToCopy(\n<line1>Parse *pParse,      /* Parsing context */\n<line2>int iStart,         /* Translate from this opcode to the end */\n<line3>int iTabCur,        /* OP_Column/OP_Rowid references to this table */\n<line4>int iRegister,      /* The first column is in this register */\n<line5>int iAutoidxCur     /* If non-zero, cursor of autoindex being generated */\n<line6>){\n<line7>Vdbe *v = pParse->pVdbe;\n<line8>VdbeOp *pOp = sqlite3VdbeGetOp(v, iStart);\n<line9>int iEnd = sqlite3VdbeCurrentAddr(v);\n<line10>if( pParse->db->mallocFailed ) return;\n<line11>#ifdef SQLITE_DEBUG\n<line12>if( pParse->db->flags & SQLITE_VdbeAddopTrace ){\n<line13>printf("CHECKING for column-to-copy on cursor %d for %d..%d\n",\n<line14>iTabCur, iStart, iEnd);\n<line15>}\n<line16>#endif\n<line17>for(; iStart<iEnd; iStart++, pOp++){\n<line18>if( pOp->p1!=iTabCur ) continue;\n<line19>if( pOp->opcode==OP_Column ){\n<line20>#ifdef SQLITE_DEBUG\n<line21>if( pParse->db->flags & SQLITE_VdbeAddopTrace ){\n<line22>printf("TRANSLATE OP_Column to OP_Copy at %d\n", iStart);\n<line23>}\n<line24>#endif\n<line25>pOp->opcode = OP_Copy;\n<line26>pOp->p1 = pOp->p2 + iRegister;\n<line27>pOp->p2 = pOp->p3;\n<line28>pOp->p3 = 0;\n<line29>pOp->p5 = 2;  /* Cause the MEM_Subtype flag to be cleared */\n<line30>}else if( pOp->opcode==OP_Rowid ){\n<line31>#ifdef SQLITE_DEBUG\n<line32>if( pParse->db->flags & SQLITE_VdbeAddopTrace ){\n<line33>printf("TRANSLATE OP_Rowid to OP_Sequence at %d\n", iStart);\n<line34>}\n<line35>#endif\n<line36>pOp->opcode = OP_Sequence;\n<line37>pOp->p1 = iAutoidxCur;\n<line38>#ifdef SQLITE_ALLOW_ROWID_IN_VIEW\n<line39>if( iAutoidxCur==0 ){\n<line40>pOp->opcode = OP_Null;\n<line41>pOp->p3 = 0;\n<line42>}\n<line43>#endif\n<line44>}\n<line45>}\n<line46>}
----------------------------------------
Function: constraintCompatibleWithOuterJoin
Content: <line0>static int constraintCompatibleWithOuterJoin(\n<line1>const WhereTerm *pTerm,       /* WHERE clause term to check */\n<line2>const SrcItem *pSrc           /* Table we are trying to access */\n<line3>){\n<line4>assert( (pSrc->fg.jointype&(JT_LEFT|JT_LTORJ|JT_RIGHT))!=0 ); /* By caller */\n<line5>testcase( (pSrc->fg.jointype & (JT_LEFT|JT_LTORJ|JT_RIGHT))==JT_LEFT );\n<line6>testcase( (pSrc->fg.jointype & (JT_LEFT|JT_LTORJ|JT_RIGHT))==JT_LTORJ );\n<line7>testcase( ExprHasProperty(pTerm->pExpr, EP_OuterON) )\n<line8>testcase( ExprHasProperty(pTerm->pExpr, EP_InnerON) );\n<line9>if( !ExprHasProperty(pTerm->pExpr, EP_OuterON|EP_InnerON)\n<line10>|| pTerm->pExpr->w.iJoin != pSrc->iCursor\n<line11>){\n<line12>return 0;\n<line13>}\n<line14>if( (pSrc->fg.jointype & (JT_LEFT|JT_RIGHT))!=0\n<line15>&& NEVER(ExprHasProperty(pTerm->pExpr, EP_InnerON))\n<line16>){\n<line17>return 0;\n<line18>}\n<line19>return 1;\n<line20>}
----------------------------------------
Function: columnIsGoodIndexCandidate
Content: <line0>static SQLITE_NOINLINE int columnIsGoodIndexCandidate(\n<line1>const Table *pTab,\n<line2>int iCol\n<line3>){\n<line4>const Index *pIdx;\n<line5>for(pIdx = pTab->pIndex; pIdx!=0; pIdx=pIdx->pNext){\n<line6>int j;\n<line7>for(j=0; j<pIdx->nKeyCol; j++){\n<line8>if( pIdx->aiColumn[j]==iCol ){\n<line9>if( j==0 ) return 0;\n<line10>if( pIdx->hasStat1 && pIdx->aiRowLogEst[j+1]>20 ) return 0;\n<line11>break;\n<line12>}\n<line13>}\n<line14>}\n<line15>return 1;\n<line16>}
----------------------------------------
Function: termCanDriveIndex
Content: <line0>static int termCanDriveIndex(\n<line1>const WhereTerm *pTerm,        /* WHERE clause term to check */\n<line2>const SrcItem *pSrc,           /* Table we are trying to access */\n<line3>const Bitmask notReady         /* Tables in outer loops of the join */\n<line4>){\n<line5>char aff;\n<line6>int leftCol;\n<line7>if( pTerm->leftCursor!=pSrc->iCursor ) return 0;\n<line8>if( (pTerm->eOperator & (WO_EQ|WO_IS))==0 ) return 0;\n<line9>assert( (pSrc->fg.jointype & JT_RIGHT)==0 );\n<line10>if( (pSrc->fg.jointype & (JT_LEFT|JT_LTORJ|JT_RIGHT))!=0\n<line11>&& !constraintCompatibleWithOuterJoin(pTerm,pSrc)\n<line12>){\n<line13>return 0;  /* See https://sqlite.org/forum/forumpost/51e6959f61 */\n<line14>}\n<line15>if( (pTerm->prereqRight & notReady)!=0 ) return 0;\n<line16>assert( (pTerm->eOperator & (WO_OR|WO_AND))==0 );\n<line17>leftCol = pTerm->u.x.leftColumn;\n<line18>if( leftCol<0 ) return 0;\n<line19>aff = pSrc->pSTab->aCol[leftCol].affinity;\n<line20>if( !sqlite3IndexAffinityOk(pTerm->pExpr, aff) ) return 0;\n<line21>testcase( pTerm->pExpr->op==TK_IS );\n<line22>return columnIsGoodIndexCandidate(pSrc->pSTab, leftCol);\n<line23>}
----------------------------------------
Function: constructAutomaticIndex
Content: <line0>static SQLITE_NOINLINE void constructAutomaticIndex(\n<line1>Parse *pParse,              /* The parsing context */\n<line2>WhereClause *pWC,           /* The WHERE clause */\n<line3>const Bitmask notReady,     /* Mask of cursors that are not available */\n<line4>WhereLevel *pLevel          /* Write new index here */\n<line5>){\n<line6>int nKeyCol;                /* Number of columns in the constructed index */\n<line7>WhereTerm *pTerm;           /* A single term of the WHERE clause */\n<line8>WhereTerm *pWCEnd;          /* End of pWC->a[] */\n<line9>Index *pIdx;                /* Object describing the transient index */\n<line10>Vdbe *v;                    /* Prepared statement under construction */\n<line11>int addrInit;               /* Address of the initialization bypass jump */\n<line12>Table *pTable;              /* The table being indexed */\n<line13>int addrTop;                /* Top of the index fill loop */\n<line14>int regRecord;              /* Register holding an index record */\n<line15>int n;                      /* Column counter */\n<line16>int i;                      /* Loop counter */\n<line17>int mxBitCol;               /* Maximum column in pSrc->colUsed */\n<line18>CollSeq *pColl;             /* Collating sequence to on a column */\n<line19>WhereLoop *pLoop;           /* The Loop object */\n<line20>char *zNotUsed;             /* Extra space on the end of pIdx */\n<line21>Bitmask idxCols;            /* Bitmap of columns used for indexing */\n<line22>Bitmask extraCols;          /* Bitmap of additional columns */\n<line23>u8 sentWarning = 0;         /* True if a warning has been issued */\n<line24>u8 useBloomFilter = 0;      /* True to also add a Bloom filter */\n<line25>Expr *pPartial = 0;         /* Partial Index Expression */\n<line26>int iContinue = 0;          /* Jump here to skip excluded rows */\n<line27>SrcList *pTabList;          /* The complete FROM clause */\n<line28>SrcItem *pSrc;              /* The FROM clause term to get the next index */\n<line29>int addrCounter = 0;        /* Address where integer counter is initialized */\n<line30>int regBase;                /* Array of registers where record is assembled */\n<line31>#ifdef SQLITE_ENABLE_STMT_SCANSTATUS\n<line32>int addrExp = 0;            /* Address of OP_Explain */\n<line33>#endif\n<line34>/* Generate code to skip over the creation and initialization of the\n<line35>** transient index on 2nd and subsequent iterations of the loop. */\n<line36>v = pParse->pVdbe;\n<line37>assert( v!=0 );\n<line38>addrInit = sqlite3VdbeAddOp0(v, OP_Once); VdbeCoverage(v);\n<line39>/* Count the number of columns that will be added to the index\n<line40>** and used to match WHERE clause constraints */\n<line41>nKeyCol = 0;\n<line42>pTabList = pWC->pWInfo->pTabList;\n<line43>pSrc = &pTabList->a[pLevel->iFrom];\n<line44>pTable = pSrc->pSTab;\n<line45>pWCEnd = &pWC->a[pWC->nTerm];\n<line46>pLoop = pLevel->pWLoop;\n<line47>idxCols = 0;\n<line48>for(pTerm=pWC->a; pTerm<pWCEnd; pTerm++){\n<line49>Expr *pExpr = pTerm->pExpr;\n<line50>/* Make the automatic index a partial index if there are terms in the\n<line51>** WHERE clause (or the ON clause of a LEFT join) that constrain which\n<line52>** rows of the target table (pSrc) that can be used. */\n<line53>if( (pTerm->wtFlags & TERM_VIRTUAL)==0\n<line54>&& sqlite3ExprIsSingleTableConstraint(pExpr, pTabList, pLevel->iFrom, 0)\n<line55>){\n<line56>pPartial = sqlite3ExprAnd(pParse, pPartial,\n<line57>sqlite3ExprDup(pParse->db, pExpr, 0));\n<line58>}\n<line59>if( termCanDriveIndex(pTerm, pSrc, notReady) ){\n<line60>int iCol;\n<line61>Bitmask cMask;\n<line62>assert( (pTerm->eOperator & (WO_OR|WO_AND))==0 );\n<line63>iCol = pTerm->u.x.leftColumn;\n<line64>cMask = iCol>=BMS ? MASKBIT(BMS-1) : MASKBIT(iCol);\n<line65>testcase( iCol==BMS );\n<line66>testcase( iCol==BMS-1 );\n<line67>if( !sentWarning ){\n<line68>sqlite3_log(SQLITE_WARNING_AUTOINDEX,\n<line69>"automatic index on %s(%s)", pTable->zName,\n<line70>pTable->aCol[iCol].zCnName);\n<line71>sentWarning = 1;\n<line72>}\n<line73>if( (idxCols & cMask)==0 ){\n<line74>if( whereLoopResize(pParse->db, pLoop, nKeyCol+1) ){\n<line75>goto end_auto_index_create;\n<line76>}\n<line77>pLoop->aLTerm[nKeyCol++] = pTerm;\n<line78>idxCols |= cMask;\n<line79>}\n<line80>}\n<line81>}\n<line82>assert( nKeyCol>0 || pParse->db->mallocFailed );\n<line83>pLoop->u.btree.nEq = pLoop->nLTerm = nKeyCol;\n<line84>pLoop->wsFlags = WHERE_COLUMN_EQ | WHERE_IDX_ONLY | WHERE_INDEXED\n<line85>| WHERE_AUTO_INDEX;\n<line86>/* Count the number of additional columns needed to create a\n<line87>** covering index.  A "covering index" is an index that contains all\n<line88>** columns that are needed by the query.  With a covering index, the\n<line89>** original table never needs to be accessed.  Automatic indices must\n<line90>** be a covering index because the index will not be updated if the\n<line91>** original table changes and the index and table cannot both be used\n<line92>** if they go out of sync.\n<line93>*/\n<line94>if( IsView(pTable) ){\n<line95>extraCols = ALLBITS & ~idxCols;\n<line96>}else{\n<line97>extraCols = pSrc->colUsed & (~idxCols | MASKBIT(BMS-1));\n<line98>}\n<line99>if( !HasRowid(pTable) ){\n<line100>/* For WITHOUT ROWID tables, ensure that all PRIMARY KEY columns are\n<line101>** either in the idxCols mask or in the extraCols mask */\n<line102>for(i=0; i<pTable->nCol; i++){\n<line103>if( (pTable->aCol[i].colFlags & COLFLAG_PRIMKEY)==0 ) continue;\n<line104>if( i>=BMS-1 ){\n<line105>extraCols |= MASKBIT(BMS-1);\n<line106>break;\n<line107>}\n<line108>if( idxCols & MASKBIT(i) ) continue;\n<line109>extraCols |= MASKBIT(i);\n<line110>}\n<line111>}\n<line112>mxBitCol = MIN(BMS-1,pTable->nCol);\n<line113>testcase( pTable->nCol==BMS-1 );\n<line114>testcase( pTable->nCol==BMS-2 );\n<line115>for(i=0; i<mxBitCol; i++){\n<line116>if( extraCols & MASKBIT(i) ) nKeyCol++;\n<line117>}\n<line118>if( pSrc->colUsed & MASKBIT(BMS-1) ){\n<line119>nKeyCol += pTable->nCol - BMS + 1;\n<line120>}\n<line121>/* Construct the Index object to describe this index */\n<line122>assert( nKeyCol <= pTable->nCol + MAX(0, pTable->nCol - BMS + 1) );\n<line123>/* ^-- This guarantees that the number of index columns will fit in the u16 */\n<line124>pIdx = sqlite3AllocateIndexObject(pParse->db, nKeyCol+HasRowid(pTable),\n<line125>0, &zNotUsed);\n<line126>if( pIdx==0 ) goto end_auto_index_create;\n<line127>pLoop->u.btree.pIndex = pIdx;\n<line128>pIdx->zName = "auto-index";\n<line129>pIdx->pTable = pTable;\n<line130>n = 0;\n<line131>idxCols = 0;\n<line132>for(pTerm=pWC->a; pTerm<pWCEnd; pTerm++){\n<line133>if( termCanDriveIndex(pTerm, pSrc, notReady) ){\n<line134>int iCol;\n<line135>Bitmask cMask;\n<line136>assert( (pTerm->eOperator & (WO_OR|WO_AND))==0 );\n<line137>iCol = pTerm->u.x.leftColumn;\n<line138>cMask = iCol>=BMS ? MASKBIT(BMS-1) : MASKBIT(iCol);\n<line139>testcase( iCol==BMS-1 );\n<line140>testcase( iCol==BMS );\n<line141>if( (idxCols & cMask)==0 ){\n<line142>Expr *pX = pTerm->pExpr;\n<line143>idxCols |= cMask;\n<line144>pIdx->aiColumn[n] = pTerm->u.x.leftColumn;\n<line145>pColl = sqlite3ExprCompareCollSeq(pParse, pX);\n<line146>assert( pColl!=0 || pParse->nErr>0 ); /* TH3 collate01.800 */\n<line147>pIdx->azColl[n] = pColl ? pColl->zName : sqlite3StrBINARY;\n<line148>n++;\n<line149>if( ALWAYS(pX->pLeft!=0)\n<line150>&& sqlite3ExprAffinity(pX->pLeft)!=SQLITE_AFF_TEXT\n<line151>){\n<line152>/* TUNING: only use a Bloom filter on an automatic index\n<line153>** if one or more key columns has the ability to hold numeric\n<line154>** values, since strings all have the same hash in the Bloom\n<line155>** filter implementation and hence a Bloom filter on a text column\n<line156>** is not usually helpful. */\n<line157>useBloomFilter = 1;\n<line158>}\n<line159>}\n<line160>}\n<line161>}\n<line162>assert( (u32)n==pLoop->u.btree.nEq );\n<line163>/* Add additional columns needed to make the automatic index into\n<line164>** a covering index */\n<line165>for(i=0; i<mxBitCol; i++){\n<line166>if( extraCols & MASKBIT(i) ){\n<line167>pIdx->aiColumn[n] = i;\n<line168>pIdx->azColl[n] = sqlite3StrBINARY;\n<line169>n++;\n<line170>}\n<line171>}\n<line172>if( pSrc->colUsed & MASKBIT(BMS-1) ){\n<line173>for(i=BMS-1; i<pTable->nCol; i++){\n<line174>pIdx->aiColumn[n] = i;\n<line175>pIdx->azColl[n] = sqlite3StrBINARY;\n<line176>n++;\n<line177>}\n<line178>}\n<line179>assert( n==nKeyCol );\n<line180>if( HasRowid(pTable) ){\n<line181>pIdx->aiColumn[n] = XN_ROWID;\n<line182>pIdx->azColl[n] = sqlite3StrBINARY;\n<line183>}\n<line184>/* Create the automatic index */\n<line185>explainAutomaticIndex(pParse, pIdx, pPartial!=0, &addrExp);\n<line186>assert( pLevel->iIdxCur>=0 );\n<line187>pLevel->iIdxCur = pParse->nTab++;\n<line188>sqlite3VdbeAddOp2(v, OP_OpenAutoindex, pLevel->iIdxCur, nKeyCol+1);\n<line189>sqlite3VdbeSetP4KeyInfo(pParse, pIdx);\n<line190>VdbeComment((v, "for %s", pTable->zName));\n<line191>if( OptimizationEnabled(pParse->db, SQLITE_BloomFilter) && useBloomFilter ){\n<line192>sqlite3WhereExplainBloomFilter(pParse, pWC->pWInfo, pLevel);\n<line193>pLevel->regFilter = ++pParse->nMem;\n<line194>sqlite3VdbeAddOp2(v, OP_Blob, 10000, pLevel->regFilter);\n<line195>}\n<line196>/* Fill the automatic index with content */\n<line197>assert( pSrc == &pWC->pWInfo->pTabList->a[pLevel->iFrom] );\n<line198>if( pSrc->fg.viaCoroutine ){\n<line199>int regYield;\n<line200>Subquery *pSubq;\n<line201>assert( pSrc->fg.isSubquery );\n<line202>pSubq = pSrc->u4.pSubq;\n<line203>assert( pSubq!=0 );\n<line204>regYield = pSubq->regReturn;\n<line205>addrCounter = sqlite3VdbeAddOp2(v, OP_Integer, 0, 0);\n<line206>sqlite3VdbeAddOp3(v, OP_InitCoroutine, regYield, 0, pSubq->addrFillSub);\n<line207>addrTop =  sqlite3VdbeAddOp1(v, OP_Yield, regYield);\n<line208>VdbeCoverage(v);\n<line209>VdbeComment((v, "next row of %s", pSrc->pSTab->zName));\n<line210>}else{\n<line211>assert( pLevel->addrHalt );\n<line212>addrTop = sqlite3VdbeAddOp2(v, OP_Rewind,pLevel->iTabCur,pLevel->addrHalt);\n<line213>VdbeCoverage(v);\n<line214>}\n<line215>if( pPartial ){\n<line216>iContinue = sqlite3VdbeMakeLabel(pParse);\n<line217>sqlite3ExprIfFalse(pParse, pPartial, iContinue, SQLITE_JUMPIFNULL);\n<line218>pLoop->wsFlags |= WHERE_PARTIALIDX;\n<line219>}\n<line220>regRecord = sqlite3GetTempReg(pParse);\n<line221>regBase = sqlite3GenerateIndexKey(\n<line222>pParse, pIdx, pLevel->iTabCur, regRecord, 0, 0, 0, 0\n<line223>);\n<line224>if( pLevel->regFilter ){\n<line225>sqlite3VdbeAddOp4Int(v, OP_FilterAdd, pLevel->regFilter, 0,\n<line226>regBase, pLoop->u.btree.nEq);\n<line227>}\n<line228>sqlite3VdbeScanStatusCounters(v, addrExp, addrExp, sqlite3VdbeCurrentAddr(v));\n<line229>sqlite3VdbeAddOp2(v, OP_IdxInsert, pLevel->iIdxCur, regRecord);\n<line230>sqlite3VdbeChangeP5(v, OPFLAG_USESEEKRESULT);\n<line231>if( pPartial ) sqlite3VdbeResolveLabel(v, iContinue);\n<line232>if( pSrc->fg.viaCoroutine ){\n<line233>assert( pSrc->fg.isSubquery && pSrc->u4.pSubq!=0 );\n<line234>sqlite3VdbeChangeP2(v, addrCounter, regBase+n);\n<line235>testcase( pParse->db->mallocFailed );\n<line236>assert( pLevel->iIdxCur>0 );\n<line237>translateColumnToCopy(pParse, addrTop, pLevel->iTabCur,\n<line238>pSrc->u4.pSubq->regResult, pLevel->iIdxCur);\n<line239>sqlite3VdbeGoto(v, addrTop);\n<line240>pSrc->fg.viaCoroutine = 0;\n<line241>sqlite3VdbeJumpHere(v, addrTop);\n<line242>}else{\n<line243>sqlite3VdbeAddOp2(v, OP_Next, pLevel->iTabCur, addrTop+1); VdbeCoverage(v);\n<line244>sqlite3VdbeChangeP5(v, SQLITE_STMTSTATUS_AUTOINDEX);\n<line245>if( (pSrc->fg.jointype & JT_LEFT)!=0 ){\n<line246>sqlite3VdbeJumpHere(v, addrTop);\n<line247>}\n<line248>}\n<line249>sqlite3ReleaseTempReg(pParse, regRecord);\n<line250>/* Jump here when skipping the initialization */\n<line251>sqlite3VdbeJumpHere(v, addrInit);\n<line252>sqlite3VdbeScanStatusRange(v, addrExp, addrExp, -1);\n<line253>end_auto_index_create:\n<line254>sqlite3ExprDelete(pParse->db, pPartial);\n<line255>}
----------------------------------------
Function: sqlite3ConstructBloomFilter
Content: <line0>static SQLITE_NOINLINE void sqlite3ConstructBloomFilter(\n<line1>WhereInfo *pWInfo,    /* The WHERE clause */\n<line2>int iLevel,           /* Index in pWInfo->a[] that is pLevel */\n<line3>WhereLevel *pLevel,   /* Make a Bloom filter for this FROM term */\n<line4>Bitmask notReady      /* Loops that are not ready */\n<line5>){\n<line6>int addrOnce;                        /* Address of opening OP_Once */\n<line7>int addrTop;                         /* Address of OP_Rewind */\n<line8>int addrCont;                        /* Jump here to skip a row */\n<line9>const WhereTerm *pTerm;              /* For looping over WHERE clause terms */\n<line10>const WhereTerm *pWCEnd;             /* Last WHERE clause term */\n<line11>Parse *pParse = pWInfo->pParse;      /* Parsing context */\n<line12>Vdbe *v = pParse->pVdbe;             /* VDBE under construction */\n<line13>WhereLoop *pLoop = pLevel->pWLoop;   /* The loop being coded */\n<line14>int iCur;                            /* Cursor for table getting the filter */\n<line15>IndexedExpr *saved_pIdxEpr;          /* saved copy of Parse.pIdxEpr */\n<line16>IndexedExpr *saved_pIdxPartExpr;     /* saved copy of Parse.pIdxPartExpr */\n<line17>saved_pIdxEpr = pParse->pIdxEpr;\n<line18>saved_pIdxPartExpr = pParse->pIdxPartExpr;\n<line19>pParse->pIdxEpr = 0;\n<line20>pParse->pIdxPartExpr = 0;\n<line21>assert( pLoop!=0 );\n<line22>assert( v!=0 );\n<line23>assert( pLoop->wsFlags & WHERE_BLOOMFILTER );\n<line24>assert( (pLoop->wsFlags & WHERE_IDX_ONLY)==0 );\n<line25>addrOnce = sqlite3VdbeAddOp0(v, OP_Once); VdbeCoverage(v);\n<line26>do{\n<line27>const SrcList *pTabList;\n<line28>const SrcItem *pItem;\n<line29>const Table *pTab;\n<line30>u64 sz;\n<line31>int iSrc;\n<line32>sqlite3WhereExplainBloomFilter(pParse, pWInfo, pLevel);\n<line33>addrCont = sqlite3VdbeMakeLabel(pParse);\n<line34>iCur = pLevel->iTabCur;\n<line35>pLevel->regFilter = ++pParse->nMem;\n<line36>/* The Bloom filter is a Blob held in a register.  Initialize it\n<line37>** to zero-filled blob of at least 80K bits, but maybe more if the\n<line38>** estimated size of the table is larger.  We could actually\n<line39>** measure the size of the table at run-time using OP_Count with\n<line40>** P3==1 and use that value to initialize the blob.  But that makes\n<line41>** testing complicated.  By basing the blob size on the value in the\n<line42>** sqlite_stat1 table, testing is much easier.\n<line43>*/\n<line44>pTabList = pWInfo->pTabList;\n<line45>iSrc = pLevel->iFrom;\n<line46>pItem = &pTabList->a[iSrc];\n<line47>assert( pItem!=0 );\n<line48>pTab = pItem->pSTab;\n<line49>assert( pTab!=0 );\n<line50>sz = sqlite3LogEstToInt(pTab->nRowLogEst);\n<line51>if( sz<10000 ){\n<line52>sz = 10000;\n<line53>}else if( sz>10000000 ){\n<line54>sz = 10000000;\n<line55>}\n<line56>sqlite3VdbeAddOp2(v, OP_Blob, (int)sz, pLevel->regFilter);\n<line57>addrTop = sqlite3VdbeAddOp1(v, OP_Rewind, iCur); VdbeCoverage(v);\n<line58>pWCEnd = &pWInfo->sWC.a[pWInfo->sWC.nTerm];\n<line59>for(pTerm=pWInfo->sWC.a; pTerm<pWCEnd; pTerm++){\n<line60>Expr *pExpr = pTerm->pExpr;\n<line61>if( (pTerm->wtFlags & TERM_VIRTUAL)==0\n<line62>&& sqlite3ExprIsSingleTableConstraint(pExpr, pTabList, iSrc, 0)\n<line63>){\n<line64>sqlite3ExprIfFalse(pParse, pTerm->pExpr, addrCont, SQLITE_JUMPIFNULL);\n<line65>}\n<line66>}\n<line67>if( pLoop->wsFlags & WHERE_IPK ){\n<line68>int r1 = sqlite3GetTempReg(pParse);\n<line69>sqlite3VdbeAddOp2(v, OP_Rowid, iCur, r1);\n<line70>sqlite3VdbeAddOp4Int(v, OP_FilterAdd, pLevel->regFilter, 0, r1, 1);\n<line71>sqlite3ReleaseTempReg(pParse, r1);\n<line72>}else{\n<line73>Index *pIdx = pLoop->u.btree.pIndex;\n<line74>int n = pLoop->u.btree.nEq;\n<line75>int r1 = sqlite3GetTempRange(pParse, n);\n<line76>int jj;\n<line77>for(jj=0; jj<n; jj++){\n<line78>assert( pIdx->pTable==pItem->pSTab );\n<line79>sqlite3ExprCodeLoadIndexColumn(pParse, pIdx, iCur, jj, r1+jj);\n<line80>}\n<line81>sqlite3VdbeAddOp4Int(v, OP_FilterAdd, pLevel->regFilter, 0, r1, n);\n<line82>sqlite3ReleaseTempRange(pParse, r1, n);\n<line83>}\n<line84>sqlite3VdbeResolveLabel(v, addrCont);\n<line85>sqlite3VdbeAddOp2(v, OP_Next, pLevel->iTabCur, addrTop+1);\n<line86>VdbeCoverage(v);\n<line87>sqlite3VdbeJumpHere(v, addrTop);\n<line88>pLoop->wsFlags &= ~WHERE_BLOOMFILTER;\n<line89>if( OptimizationDisabled(pParse->db, SQLITE_BloomPulldown) ) break;\n<line90>while( ++iLevel < pWInfo->nLevel ){\n<line91>const SrcItem *pTabItem;\n<line92>pLevel = &pWInfo->a[iLevel];\n<line93>pTabItem = &pWInfo->pTabList->a[pLevel->iFrom];\n<line94>if( pTabItem->fg.jointype & (JT_LEFT|JT_LTORJ) ) continue;\n<line95>pLoop = pLevel->pWLoop;\n<line96>if( NEVER(pLoop==0) ) continue;\n<line97>if( pLoop->prereq & notReady ) continue;\n<line98>if( (pLoop->wsFlags & (WHERE_BLOOMFILTER|WHERE_COLUMN_IN))\n<line99>==WHERE_BLOOMFILTER\n<line100>){\n<line101>/* This is a candidate for bloom-filter pull-down (early evaluation).\n<line102>** The test that WHERE_COLUMN_IN is omitted is important, as we are\n<line103>** not able to do early evaluation of bloom filters that make use of\n<line104>** the IN operator */\n<line105>break;\n<line106>}\n<line107>}\n<line108>}while( iLevel < pWInfo->nLevel );\n<line109>sqlite3VdbeJumpHere(v, addrOnce);\n<line110>pParse->pIdxEpr = saved_pIdxEpr;\n<line111>pParse->pIdxPartExpr = saved_pIdxPartExpr;\n<line112>}
----------------------------------------
Function: termFromWhereClause
Content: <line0>static WhereTerm *termFromWhereClause(WhereClause *pWC, int iTerm){\n<line1>WhereClause *p;\n<line2>for(p=pWC; p; p=p->pOuter){\n<line3>if( iTerm<p->nTerm ) return &p->a[iTerm];\n<line4>iTerm -= p->nTerm;\n<line5>}\n<line6>return 0;\n<line7>}
----------------------------------------
Function: allocateIndexInfo
Content: <line0>static sqlite3_index_info *allocateIndexInfo(\n<line1>WhereInfo *pWInfo,              /* The WHERE clause */\n<line2>WhereClause *pWC,               /* The WHERE clause being analyzed */\n<line3>Bitmask mUnusable,              /* Ignore terms with these prereqs */\n<line4>SrcItem *pSrc,                  /* The FROM clause term that is the vtab */\n<line5>u16 *pmNoOmit                   /* Mask of terms not to omit */\n<line6>){\n<line7>int i, j;\n<line8>int nTerm;\n<line9>Parse *pParse = pWInfo->pParse;\n<line10>struct sqlite3_index_constraint *pIdxCons;\n<line11>struct sqlite3_index_orderby *pIdxOrderBy;\n<line12>struct sqlite3_index_constraint_usage *pUsage;\n<line13>struct HiddenIndexInfo *pHidden;\n<line14>WhereTerm *pTerm;\n<line15>int nOrderBy;\n<line16>sqlite3_index_info *pIdxInfo;\n<line17>u16 mNoOmit = 0;\n<line18>const Table *pTab;\n<line19>int eDistinct = 0;\n<line20>ExprList *pOrderBy = pWInfo->pOrderBy;\n<line21>WhereClause *p;\n<line22>assert( pSrc!=0 );\n<line23>pTab = pSrc->pSTab;\n<line24>assert( pTab!=0 );\n<line25>assert( IsVirtual(pTab) );\n<line26>/* Find all WHERE clause constraints referring to this virtual table.\n<line27>** Mark each term with the TERM_OK flag.  Set nTerm to the number of\n<line28>** terms found.\n<line29>*/\n<line30>for(p=pWC, nTerm=0; p; p=p->pOuter){\n<line31>for(i=0, pTerm=p->a; i<p->nTerm; i++, pTerm++){\n<line32>pTerm->wtFlags &= ~TERM_OK;\n<line33>if( pTerm->leftCursor != pSrc->iCursor ) continue;\n<line34>if( pTerm->prereqRight & mUnusable ) continue;\n<line35>assert( IsPowerOfTwo(pTerm->eOperator & ~WO_EQUIV) );\n<line36>testcase( pTerm->eOperator & WO_IN );\n<line37>testcase( pTerm->eOperator & WO_ISNULL );\n<line38>testcase( pTerm->eOperator & WO_IS );\n<line39>testcase( pTerm->eOperator & WO_ALL );\n<line40>if( (pTerm->eOperator & ~(WO_EQUIV))==0 ) continue;\n<line41>if( pTerm->wtFlags & TERM_VNULL ) continue;\n<line42>assert( (pTerm->eOperator & (WO_OR|WO_AND))==0 );\n<line43>assert( pTerm->u.x.leftColumn>=XN_ROWID );\n<line44>assert( pTerm->u.x.leftColumn<pTab->nCol );\n<line45>if( (pSrc->fg.jointype & (JT_LEFT|JT_LTORJ|JT_RIGHT))!=0\n<line46>&& !constraintCompatibleWithOuterJoin(pTerm,pSrc)\n<line47>){\n<line48>continue;\n<line49>}\n<line50>nTerm++;\n<line51>pTerm->wtFlags |= TERM_OK;\n<line52>}\n<line53>}\n<line54>/* If the ORDER BY clause contains only columns in the current\n<line55>** virtual table then allocate space for the aOrderBy part of\n<line56>** the sqlite3_index_info structure.\n<line57>*/\n<line58>nOrderBy = 0;\n<line59>if( pOrderBy ){\n<line60>int n = pOrderBy->nExpr;\n<line61>for(i=0; i<n; i++){\n<line62>Expr *pExpr = pOrderBy->a[i].pExpr;\n<line63>Expr *pE2;\n<line64>/* Skip over constant terms in the ORDER BY clause */\n<line65>if( sqlite3ExprIsConstant(0, pExpr) ){\n<line66>continue;\n<line67>}\n<line68>/* Virtual tables are unable to deal with NULLS FIRST */\n<line69>if( pOrderBy->a[i].fg.sortFlags & KEYINFO_ORDER_BIGNULL ) break;\n<line70>/* First case - a direct column references without a COLLATE operator */\n<line71>if( pExpr->op==TK_COLUMN && pExpr->iTable==pSrc->iCursor ){\n<line72>assert( pExpr->iColumn>=XN_ROWID && pExpr->iColumn<pTab->nCol );\n<line73>continue;\n<line74>}\n<line75>/* 2nd case - a column reference with a COLLATE operator.  Only match\n<line76>** of the COLLATE operator matches the collation of the column. */\n<line77>if( pExpr->op==TK_COLLATE\n<line78>&& (pE2 = pExpr->pLeft)->op==TK_COLUMN\n<line79>&& pE2->iTable==pSrc->iCursor\n<line80>){\n<line81>const char *zColl;  /* The collating sequence name */\n<line82>assert( !ExprHasProperty(pExpr, EP_IntValue) );\n<line83>assert( pExpr->u.zToken!=0 );\n<line84>assert( pE2->iColumn>=XN_ROWID && pE2->iColumn<pTab->nCol );\n<line85>pExpr->iColumn = pE2->iColumn;\n<line86>if( pE2->iColumn<0 ) continue;  /* Collseq does not matter for rowid */\n<line87>zColl = sqlite3ColumnColl(&pTab->aCol[pE2->iColumn]);\n<line88>if( zColl==0 ) zColl = sqlite3StrBINARY;\n<line89>if( sqlite3_stricmp(pExpr->u.zToken, zColl)==0 ) continue;\n<line90>}\n<line91>/* No matches cause a break out of the loop */\n<line92>break;\n<line93>}\n<line94>if( i==n ){\n<line95>nOrderBy = n;\n<line96>if( (pWInfo->wctrlFlags & WHERE_DISTINCTBY) && !pSrc->fg.rowidUsed ){\n<line97>eDistinct = 2 + ((pWInfo->wctrlFlags & WHERE_SORTBYGROUP)!=0);\n<line98>}else if( pWInfo->wctrlFlags & WHERE_GROUPBY ){\n<line99>eDistinct = 1;\n<line100>}\n<line101>}\n<line102>}\n<line103>/* Allocate the sqlite3_index_info structure\n<line104>*/\n<line105>pIdxInfo = sqlite3DbMallocZero(pParse->db, sizeof(*pIdxInfo)\n<line106>+ (sizeof(*pIdxCons) + sizeof(*pUsage))*nTerm\n<line107>+ sizeof(*pIdxOrderBy)*nOrderBy\n<line108>+ SZ_HIDDENINDEXINFO(nTerm) );\n<line109>if( pIdxInfo==0 ){\n<line110>sqlite3ErrorMsg(pParse, "out of memory");\n<line111>return 0;\n<line112>}\n<line113>pHidden = (struct HiddenIndexInfo*)&pIdxInfo[1];\n<line114>pIdxCons = (struct sqlite3_index_constraint*)&pHidden->aRhs[nTerm];\n<line115>pIdxOrderBy = (struct sqlite3_index_orderby*)&pIdxCons[nTerm];\n<line116>pUsage = (struct sqlite3_index_constraint_usage*)&pIdxOrderBy[nOrderBy];\n<line117>pIdxInfo->aConstraint = pIdxCons;\n<line118>pIdxInfo->aOrderBy = pIdxOrderBy;\n<line119>pIdxInfo->aConstraintUsage = pUsage;\n<line120>pIdxInfo->colUsed = (sqlite3_int64)pSrc->colUsed;\n<line121>if( HasRowid(pTab)==0 ){\n<line122>/* Ensure that all bits associated with PK columns are set. This is to\n<line123>** ensure they are available for cases like RIGHT joins or OR loops. */\n<line124>Index *pPk = sqlite3PrimaryKeyIndex((Table*)pTab);\n<line125>assert( pPk!=0 );\n<line126>for(i=0; i<pPk->nKeyCol; i++){\n<line127>int iCol = pPk->aiColumn[i];\n<line128>assert( iCol>=0 );\n<line129>if( iCol>=BMS-1 ) iCol = BMS-1;\n<line130>pIdxInfo->colUsed |= MASKBIT(iCol);\n<line131>}\n<line132>}\n<line133>pHidden->pWC = pWC;\n<line134>pHidden->pParse = pParse;\n<line135>pHidden->eDistinct = eDistinct;\n<line136>pHidden->mIn = 0;\n<line137>for(p=pWC, i=j=0; p; p=p->pOuter){\n<line138>int nLast = i+p->nTerm;;\n<line139>for(pTerm=p->a; i<nLast; i++, pTerm++){\n<line140>u16 op;\n<line141>if( (pTerm->wtFlags & TERM_OK)==0 ) continue;\n<line142>pIdxCons[j].iColumn = pTerm->u.x.leftColumn;\n<line143>pIdxCons[j].iTermOffset = i;\n<line144>op = pTerm->eOperator & WO_ALL;\n<line145>if( op==WO_IN ){\n<line146>if( (pTerm->wtFlags & TERM_SLICE)==0 ){\n<line147>pHidden->mIn |= SMASKBIT32(j);\n<line148>}\n<line149>op = WO_EQ;\n<line150>}\n<line151>if( op==WO_AUX ){\n<line152>pIdxCons[j].op = pTerm->eMatchOp;\n<line153>}else if( op & (WO_ISNULL|WO_IS) ){\n<line154>if( op==WO_ISNULL ){\n<line155>pIdxCons[j].op = SQLITE_INDEX_CONSTRAINT_ISNULL;\n<line156>}else{\n<line157>pIdxCons[j].op = SQLITE_INDEX_CONSTRAINT_IS;\n<line158>}\n<line159>}else{\n<line160>pIdxCons[j].op = (u8)op;\n<line161>/* The direct assignment in the previous line is possible only because\n<line162>** the WO_ and SQLITE_INDEX_CONSTRAINT_ codes are identical.  The\n<line163>** following asserts verify this fact. */\n<line164>assert( WO_EQ==SQLITE_INDEX_CONSTRAINT_EQ );\n<line165>assert( WO_LT==SQLITE_INDEX_CONSTRAINT_LT );\n<line166>assert( WO_LE==SQLITE_INDEX_CONSTRAINT_LE );\n<line167>assert( WO_GT==SQLITE_INDEX_CONSTRAINT_GT );\n<line168>assert( WO_GE==SQLITE_INDEX_CONSTRAINT_GE );\n<line169>assert( pTerm->eOperator&(WO_IN|WO_EQ|WO_LT|WO_LE|WO_GT|WO_GE|WO_AUX) );\n<line170>if( op & (WO_LT|WO_LE|WO_GT|WO_GE)\n<line171>&& sqlite3ExprIsVector(pTerm->pExpr->pRight)\n<line172>){\n<line173>testcase( j!=i );\n<line174>if( j<16 ) mNoOmit |= (1 << j);\n<line175>if( op==WO_LT ) pIdxCons[j].op = WO_LE;\n<line176>if( op==WO_GT ) pIdxCons[j].op = WO_GE;\n<line177>}\n<line178>}\n<line179>j++;\n<line180>}\n<line181>}\n<line182>assert( j==nTerm );\n<line183>pIdxInfo->nConstraint = j;\n<line184>for(i=j=0; i<nOrderBy; i++){\n<line185>Expr *pExpr = pOrderBy->a[i].pExpr;\n<line186>if( sqlite3ExprIsConstant(0, pExpr) ) continue;\n<line187>assert( pExpr->op==TK_COLUMN\n<line188>|| (pExpr->op==TK_COLLATE && pExpr->pLeft->op==TK_COLUMN\n<line189>&& pExpr->iColumn==pExpr->pLeft->iColumn) );\n<line190>pIdxOrderBy[j].iColumn = pExpr->iColumn;\n<line191>pIdxOrderBy[j].desc = pOrderBy->a[i].fg.sortFlags & KEYINFO_ORDER_DESC;\n<line192>j++;\n<line193>}\n<line194>pIdxInfo->nOrderBy = j;\n<line195>*pmNoOmit = mNoOmit;\n<line196>return pIdxInfo;\n<line197>}
----------------------------------------
Function: freeIdxStr
Content: <line0>static void freeIdxStr(sqlite3_index_info *pIdxInfo){\n<line1>if( pIdxInfo->needToFreeIdxStr ){\n<line2>sqlite3_free(pIdxInfo->idxStr);\n<line3>pIdxInfo->idxStr = 0;\n<line4>pIdxInfo->needToFreeIdxStr = 0;\n<line5>}\n<line6>}
----------------------------------------
Function: freeIndexInfo
Content: <line0>static void freeIndexInfo(sqlite3 *db, sqlite3_index_info *pIdxInfo){\n<line1>HiddenIndexInfo *pHidden;\n<line2>int i;\n<line3>assert( pIdxInfo!=0 );\n<line4>pHidden = (HiddenIndexInfo*)&pIdxInfo[1];\n<line5>assert( pHidden->pParse!=0 );\n<line6>assert( pHidden->pParse->db==db );\n<line7>for(i=0; i<pIdxInfo->nConstraint; i++){\n<line8>sqlite3ValueFree(pHidden->aRhs[i]); /* IMP: R-14553-25174 */\n<line9>pHidden->aRhs[i] = 0;\n<line10>}\n<line11>freeIdxStr(pIdxInfo);\n<line12>sqlite3DbFree(db, pIdxInfo);\n<line13>}
----------------------------------------
Function: vtabBestIndex
Content: <line0>static int vtabBestIndex(Parse *pParse, Table *pTab, sqlite3_index_info *p){\n<line1>int rc;\n<line2>sqlite3_vtab *pVtab;\n<line3>assert( IsVirtual(pTab) );\n<line4>pVtab = sqlite3GetVTable(pParse->db, pTab)->pVtab;\n<line5>whereTraceIndexInfoInputs(p, pTab);\n<line6>pParse->db->nSchemaLock++;\n<line7>rc = pVtab->pModule->xBestIndex(pVtab, p);\n<line8>pParse->db->nSchemaLock--;\n<line9>whereTraceIndexInfoOutputs(p, pTab);\n<line10>if( rc!=SQLITE_OK && rc!=SQLITE_CONSTRAINT ){\n<line11>if( rc==SQLITE_NOMEM ){\n<line12>sqlite3OomFault(pParse->db);\n<line13>}else if( !pVtab->zErrMsg ){\n<line14>sqlite3ErrorMsg(pParse, "%s", sqlite3ErrStr(rc));\n<line15>}else{\n<line16>sqlite3ErrorMsg(pParse, "%s", pVtab->zErrMsg);\n<line17>}\n<line18>}\n<line19>if( pTab->u.vtab.p->bAllSchemas ){\n<line20>sqlite3VtabUsesAllSchemas(pParse);\n<line21>}\n<line22>sqlite3_free(pVtab->zErrMsg);\n<line23>pVtab->zErrMsg = 0;\n<line24>return rc;\n<line25>}
----------------------------------------
Function: whereRangeAdjust
Content: <line0>static LogEst whereRangeAdjust(WhereTerm *pTerm, LogEst nNew){\n<line1>LogEst nRet = nNew;\n<line2>if( pTerm ){\n<line3>if( pTerm->truthProb<=0 ){\n<line4>nRet += pTerm->truthProb;\n<line5>}else if( (pTerm->wtFlags & TERM_VNULL)==0 ){\n<line6>nRet -= 20;        assert( 20==sqlite3LogEst(4) );\n<line7>}\n<line8>}\n<line9>return nRet;\n<line10>}
----------------------------------------
Function: whereRangeScanEst
Content: <line0>static int whereRangeScanEst(\n<line1>Parse *pParse,       /* Parsing & code generating context */\n<line2>WhereLoopBuilder *pBuilder,\n<line3>WhereTerm *pLower,   /* Lower bound on the range. ex: "x>123" Might be NULL */\n<line4>WhereTerm *pUpper,   /* Upper bound on the range. ex: "x<455" Might be NULL */\n<line5>WhereLoop *pLoop     /* Modify the .nOut and maybe .rRun fields */\n<line6>){\n<line7>int rc = SQLITE_OK;\n<line8>int nOut = pLoop->nOut;\n<line9>LogEst nNew;\n<line10>#ifdef SQLITE_ENABLE_STAT4\n<line11>Index *p = pLoop->u.btree.pIndex;\n<line12>int nEq = pLoop->u.btree.nEq;\n<line13>if( p->nSample>0 && ALWAYS(nEq<p->nSampleCol)\n<line14>&& OptimizationEnabled(pParse->db, SQLITE_Stat4)\n<line15>){\n<line16>if( nEq==pBuilder->nRecValid ){\n<line17>UnpackedRecord *pRec = pBuilder->pRec;\n<line18>tRowcnt a[2];\n<line19>int nBtm = pLoop->u.btree.nBtm;\n<line20>int nTop = pLoop->u.btree.nTop;\n<line21>/* Variable iLower will be set to the estimate of the number of rows in\n<line22>** the index that are less than the lower bound of the range query. The\n<line23>** lower bound being the concatenation of $P and $L, where $P is the\n<line24>** key-prefix formed by the nEq values matched against the nEq left-most\n<line25>** columns of the index, and $L is the value in pLower.\n<line26>**\n<line27>** Or, if pLower is NULL or $L cannot be extracted from it (because it\n<line28>** is not a simple variable or literal value), the lower bound of the\n<line29>** range is $P. Due to a quirk in the way whereKeyStats() works, even\n<line30>** if $L is available, whereKeyStats() is called for both ($P) and\n<line31>** ($P:$L) and the larger of the two returned values is used.\n<line32>**\n<line33>** Similarly, iUpper is to be set to the estimate of the number of rows\n<line34>** less than the upper bound of the range query. Where the upper bound\n<line35>** is either ($P) or ($P:$U). Again, even if $U is available, both values\n<line36>** of iUpper are requested of whereKeyStats() and the smaller used.\n<line37>**\n<line38>** The number of rows between the two bounds is then just iUpper-iLower.\n<line39>*/\n<line40>tRowcnt iLower;     /* Rows less than the lower bound */\n<line41>tRowcnt iUpper;     /* Rows less than the upper bound */\n<line42>int iLwrIdx = -2;   /* aSample[] for the lower bound */\n<line43>int iUprIdx = -1;   /* aSample[] for the upper bound */\n<line44>if( pRec ){\n<line45>testcase( pRec->nField!=pBuilder->nRecValid );\n<line46>pRec->nField = pBuilder->nRecValid;\n<line47>}\n<line48>/* Determine iLower and iUpper using ($P) only. */\n<line49>if( nEq==0 ){\n<line50>iLower = 0;\n<line51>iUpper = p->nRowEst0;\n<line52>}else{\n<line53>/* Note: this call could be optimized away - since the same values must\n<line54>** have been requested when testing key $P in whereEqualScanEst().  */\n<line55>whereKeyStats(pParse, p, pRec, 0, a);\n<line56>iLower = a[0];\n<line57>iUpper = a[0] + a[1];\n<line58>}\n<line59>assert( pLower==0 || (pLower->eOperator & (WO_GT|WO_GE))!=0 );\n<line60>assert( pUpper==0 || (pUpper->eOperator & (WO_LT|WO_LE))!=0 );\n<line61>assert( p->aSortOrder!=0 );\n<line62>if( p->aSortOrder[nEq] ){\n<line63>/* The roles of pLower and pUpper are swapped for a DESC index */\n<line64>SWAP(WhereTerm*, pLower, pUpper);\n<line65>SWAP(int, nBtm, nTop);\n<line66>}\n<line67>/* If possible, improve on the iLower estimate using ($P:$L). */\n<line68>if( pLower ){\n<line69>int n;                    /* Values extracted from pExpr */\n<line70>Expr *pExpr = pLower->pExpr->pRight;\n<line71>rc = sqlite3Stat4ProbeSetValue(pParse, p, &pRec, pExpr, nBtm, nEq, &n);\n<line72>if( rc==SQLITE_OK && n ){\n<line73>tRowcnt iNew;\n<line74>u16 mask = WO_GT|WO_LE;\n<line75>if( sqlite3ExprVectorSize(pExpr)>n ) mask = (WO_LE|WO_LT);\n<line76>iLwrIdx = whereKeyStats(pParse, p, pRec, 0, a);\n<line77>iNew = a[0] + ((pLower->eOperator & mask) ? a[1] : 0);\n<line78>if( iNew>iLower ) iLower = iNew;\n<line79>nOut--;\n<line80>pLower = 0;\n<line81>}\n<line82>}\n<line83>/* If possible, improve on the iUpper estimate using ($P:$U). */\n<line84>if( pUpper ){\n<line85>int n;                    /* Values extracted from pExpr */\n<line86>Expr *pExpr = pUpper->pExpr->pRight;\n<line87>rc = sqlite3Stat4ProbeSetValue(pParse, p, &pRec, pExpr, nTop, nEq, &n);\n<line88>if( rc==SQLITE_OK && n ){\n<line89>tRowcnt iNew;\n<line90>u16 mask = WO_GT|WO_LE;\n<line91>if( sqlite3ExprVectorSize(pExpr)>n ) mask = (WO_LE|WO_LT);\n<line92>iUprIdx = whereKeyStats(pParse, p, pRec, 1, a);\n<line93>iNew = a[0] + ((pUpper->eOperator & mask) ? a[1] : 0);\n<line94>if( iNew<iUpper ) iUpper = iNew;\n<line95>nOut--;\n<line96>pUpper = 0;\n<line97>}\n<line98>}\n<line99>pBuilder->pRec = pRec;\n<line100>if( rc==SQLITE_OK ){\n<line101>if( iUpper>iLower ){\n<line102>nNew = sqlite3LogEst(iUpper - iLower);\n<line103>/* TUNING:  If both iUpper and iLower are derived from the same\n<line104>** sample, then assume they are 4x more selective.  This brings\n<line105>** the estimated selectivity more in line with what it would be\n<line106>** if estimated without the use of STAT4 tables. */\n<line107>if( iLwrIdx==iUprIdx ){ nNew -= 20; }\n<line108>assert( 20==sqlite3LogEst(4) );\n<line109>}else{\n<line110>nNew = 10;        assert( 10==sqlite3LogEst(2) );\n<line111>}\n<line112>if( nNew<nOut ){\n<line113>nOut = nNew;\n<line114>}\n<line115>WHERETRACE(0x20, ("STAT4 range scan: %u..%u  est=%d\n",\n<line116>(u32)iLower, (u32)iUpper, nOut));\n<line117>}\n<line118>}else{\n<line119>int bDone = 0;\n<line120>rc = whereRangeSkipScanEst(pParse, pLower, pUpper, pLoop, &bDone);\n<line121>if( bDone ) return rc;\n<line122>}\n<line123>}\n<line124>#else\n<line125>UNUSED_PARAMETER(pParse);\n<line126>UNUSED_PARAMETER(pBuilder);\n<line127>assert( pLower || pUpper );\n<line128>#endif\n<line129>assert( pUpper==0 || (pUpper->wtFlags & TERM_VNULL)==0 || pParse->nErr>0 );\n<line130>nNew = whereRangeAdjust(pLower, nOut);\n<line131>nNew = whereRangeAdjust(pUpper, nNew);\n<line132>/* TUNING: If there is both an upper and lower limit and neither limit\n<line133>** has an application-defined likelihood(), assume the range is\n<line134>** reduced by an additional 75%. This means that, by default, an open-ended\n<line135>** range query (e.g. col > ?) is assumed to match 1/4 of the rows in the\n<line136>** index. While a closed range (e.g. col BETWEEN ? AND ?) is estimated to\n<line137>** match 1/64 of the index. */\n<line138>if( pLower && pLower->truthProb>0 && pUpper && pUpper->truthProb>0 ){\n<line139>nNew -= 20;\n<line140>}\n<line141>nOut -= (pLower!=0) + (pUpper!=0);\n<line142>if( nNew<10 ) nNew = 10;\n<line143>if( nNew<nOut ) nOut = nNew;\n<line144>#if defined(WHERETRACE_ENABLED)\n<line145>if( pLoop->nOut>nOut ){\n<line146>WHERETRACE(0x20,("Range scan lowers nOut from %d to %d\n",\n<line147>pLoop->nOut, nOut));\n<line148>}\n<line149>#endif\n<line150>pLoop->nOut = (LogEst)nOut;\n<line151>return rc;\n<line152>}
----------------------------------------
Function: whereLoopInit
Content: <line0>static void whereLoopInit(WhereLoop *p){\n<line1>p->aLTerm = p->aLTermSpace;\n<line2>p->nLTerm = 0;\n<line3>p->nLSlot = ArraySize(p->aLTermSpace);\n<line4>p->wsFlags = 0;\n<line5>}
----------------------------------------
Function: whereLoopClearUnion
Content: <line0>static void whereLoopClearUnion(sqlite3 *db, WhereLoop *p){\n<line1>if( p->wsFlags & (WHERE_VIRTUALTABLE|WHERE_AUTO_INDEX) ){\n<line2>if( (p->wsFlags & WHERE_VIRTUALTABLE)!=0 && p->u.vtab.needFree ){\n<line3>sqlite3_free(p->u.vtab.idxStr);\n<line4>p->u.vtab.needFree = 0;\n<line5>p->u.vtab.idxStr = 0;\n<line6>}else if( (p->wsFlags & WHERE_AUTO_INDEX)!=0 && p->u.btree.pIndex!=0 ){\n<line7>sqlite3DbFree(db, p->u.btree.pIndex->zColAff);\n<line8>sqlite3DbFreeNN(db, p->u.btree.pIndex);\n<line9>p->u.btree.pIndex = 0;\n<line10>}\n<line11>}\n<line12>}
----------------------------------------
Function: whereLoopClear
Content: <line0>static void whereLoopClear(sqlite3 *db, WhereLoop *p){\n<line1>if( p->aLTerm!=p->aLTermSpace ){\n<line2>sqlite3DbFreeNN(db, p->aLTerm);\n<line3>p->aLTerm = p->aLTermSpace;\n<line4>p->nLSlot = ArraySize(p->aLTermSpace);\n<line5>}\n<line6>whereLoopClearUnion(db, p);\n<line7>p->nLTerm = 0;\n<line8>p->wsFlags = 0;\n<line9>}
----------------------------------------
Function: whereLoopResize
Content: <line0>static int whereLoopResize(sqlite3 *db, WhereLoop *p, int n){\n<line1>WhereTerm **paNew;\n<line2>if( p->nLSlot>=n ) return SQLITE_OK;\n<line3>n = (n+7)&~7;\n<line4>paNew = sqlite3DbMallocRawNN(db, sizeof(p->aLTerm[0])*n);\n<line5>if( paNew==0 ) return SQLITE_NOMEM_BKPT;\n<line6>memcpy(paNew, p->aLTerm, sizeof(p->aLTerm[0])*p->nLSlot);\n<line7>if( p->aLTerm!=p->aLTermSpace ) sqlite3DbFreeNN(db, p->aLTerm);\n<line8>p->aLTerm = paNew;\n<line9>p->nLSlot = n;\n<line10>return SQLITE_OK;\n<line11>}
----------------------------------------
Function: whereLoopXfer
Content: <line0>static int whereLoopXfer(sqlite3 *db, WhereLoop *pTo, WhereLoop *pFrom){\n<line1>whereLoopClearUnion(db, pTo);\n<line2>if( pFrom->nLTerm > pTo->nLSlot\n<line3>&& whereLoopResize(db, pTo, pFrom->nLTerm)\n<line4>){\n<line5>memset(pTo, 0, WHERE_LOOP_XFER_SZ);\n<line6>return SQLITE_NOMEM_BKPT;\n<line7>}\n<line8>memcpy(pTo, pFrom, WHERE_LOOP_XFER_SZ);\n<line9>memcpy(pTo->aLTerm, pFrom->aLTerm, pTo->nLTerm*sizeof(pTo->aLTerm[0]));\n<line10>if( pFrom->wsFlags & WHERE_VIRTUALTABLE ){\n<line11>pFrom->u.vtab.needFree = 0;\n<line12>}else if( (pFrom->wsFlags & WHERE_AUTO_INDEX)!=0 ){\n<line13>pFrom->u.btree.pIndex = 0;\n<line14>}\n<line15>return SQLITE_OK;\n<line16>}
----------------------------------------
Function: whereLoopDelete
Content: <line0>static void whereLoopDelete(sqlite3 *db, WhereLoop *p){\n<line1>assert( db!=0 );\n<line2>whereLoopClear(db, p);\n<line3>sqlite3DbNNFreeNN(db, p);\n<line4>}
----------------------------------------
Function: whereInfoFree
Content: <line0>static void whereInfoFree(sqlite3 *db, WhereInfo *pWInfo){\n<line1>assert( pWInfo!=0 );\n<line2>assert( db!=0 );\n<line3>sqlite3WhereClauseClear(&pWInfo->sWC);\n<line4>while( pWInfo->pLoops ){\n<line5>WhereLoop *p = pWInfo->pLoops;\n<line6>pWInfo->pLoops = p->pNextLoop;\n<line7>whereLoopDelete(db, p);\n<line8>}\n<line9>while( pWInfo->pMemToFree ){\n<line10>WhereMemBlock *pNext = pWInfo->pMemToFree->pNext;\n<line11>sqlite3DbNNFreeNN(db, pWInfo->pMemToFree);\n<line12>pWInfo->pMemToFree = pNext;\n<line13>}\n<line14>sqlite3DbNNFreeNN(db, pWInfo);\n<line15>}
----------------------------------------
Function: whereLoopCheaperProperSubset
Content: <line0>static int whereLoopCheaperProperSubset(\n<line1>const WhereLoop *pX,       /* First WhereLoop to compare */\n<line2>const WhereLoop *pY        /* Compare against this WhereLoop */\n<line3>){\n<line4>int i, j;\n<line5>if( pX->rRun>pY->rRun && pX->nOut>pY->nOut ) return 0; /* (1d) and (2a) */\n<line6>assert( (pX->wsFlags & WHERE_VIRTUALTABLE)==0 );\n<line7>assert( (pY->wsFlags & WHERE_VIRTUALTABLE)==0 );\n<line8>if( pX->u.btree.nEq < pY->u.btree.nEq                  /* (1b) */\n<line9>&& pX->u.btree.pIndex==pY->u.btree.pIndex             /* (1a) */\n<line10>&& pX->nSkip==0 && pY->nSkip==0                       /* (1c) */\n<line11>){\n<line12>return 1;  /* Case 1 is true */\n<line13>}\n<line14>if( pX->nLTerm-pX->nSkip >= pY->nLTerm-pY->nSkip ){\n<line15>return 0;                                            /* (2b) */\n<line16>}\n<line17>if( pY->nSkip > pX->nSkip ) return 0;                  /* (2d) */\n<line18>for(i=pX->nLTerm-1; i>=0; i--){\n<line19>if( pX->aLTerm[i]==0 ) continue;\n<line20>for(j=pY->nLTerm-1; j>=0; j--){\n<line21>if( pY->aLTerm[j]==pX->aLTerm[i] ) break;\n<line22>}\n<line23>if( j<0 ) return 0;                                  /* (2c) */\n<line24>}\n<line25>if( (pX->wsFlags&WHERE_IDX_ONLY)!=0\n<line26>&& (pY->wsFlags&WHERE_IDX_ONLY)==0 ){\n<line27>return 0;                                            /* (2e) */\n<line28>}\n<line29>return 1;  /* Case 2 is true */\n<line30>}
----------------------------------------
Function: whereLoopAdjustCost
Content: <line0>static void whereLoopAdjustCost(const WhereLoop *p, WhereLoop *pTemplate){\n<line1>if( (pTemplate->wsFlags & WHERE_INDEXED)==0 ) return;\n<line2>for(; p; p=p->pNextLoop){\n<line3>if( p->iTab!=pTemplate->iTab ) continue;\n<line4>if( (p->wsFlags & WHERE_INDEXED)==0 ) continue;\n<line5>if( whereLoopCheaperProperSubset(p, pTemplate) ){\n<line6>/* Adjust pTemplate cost downward so that it is cheaper than its\n<line7>** subset p. */\n<line8>WHERETRACE(0x80,("subset cost adjustment %d,%d to %d,%d\n",\n<line9>pTemplate->rRun, pTemplate->nOut,\n<line10>MIN(p->rRun, pTemplate->rRun),\n<line11>MIN(p->nOut - 1, pTemplate->nOut)));\n<line12>pTemplate->rRun = MIN(p->rRun, pTemplate->rRun);\n<line13>pTemplate->nOut = MIN(p->nOut - 1, pTemplate->nOut);\n<line14>}else if( whereLoopCheaperProperSubset(pTemplate, p) ){\n<line15>/* Adjust pTemplate cost upward so that it is costlier than p since\n<line16>** pTemplate is a proper subset of p */\n<line17>WHERETRACE(0x80,("subset cost adjustment %d,%d to %d,%d\n",\n<line18>pTemplate->rRun, pTemplate->nOut,\n<line19>MAX(p->rRun, pTemplate->rRun),\n<line20>MAX(p->nOut + 1, pTemplate->nOut)));\n<line21>pTemplate->rRun = MAX(p->rRun, pTemplate->rRun);\n<line22>pTemplate->nOut = MAX(p->nOut + 1, pTemplate->nOut);\n<line23>}\n<line24>}\n<line25>}
----------------------------------------
Function: whereLoopFindLesser
Content: <line0>static WhereLoop **whereLoopFindLesser(\n<line1>WhereLoop **ppPrev,\n<line2>const WhereLoop *pTemplate\n<line3>){\n<line4>WhereLoop *p;\n<line5>for(p=(*ppPrev); p; ppPrev=&p->pNextLoop, p=*ppPrev){\n<line6>if( p->iTab!=pTemplate->iTab || p->iSortIdx!=pTemplate->iSortIdx ){\n<line7>/* If either the iTab or iSortIdx values for two WhereLoop are different\n<line8>** then those WhereLoops need to be considered separately.  Neither is\n<line9>** a candidate to replace the other. */\n<line10>continue;\n<line11>}\n<line12>/* In the current implementation, the rSetup value is either zero\n<line13>** or the cost of building an automatic index (NlogN) and the NlogN\n<line14>** is the same for compatible WhereLoops. */\n<line15>assert( p->rSetup==0 || pTemplate->rSetup==0\n<line16>|| p->rSetup==pTemplate->rSetup );\n<line17>/* whereLoopAddBtree() always generates and inserts the automatic index\n<line18>** case first.  Hence compatible candidate WhereLoops never have a larger\n<line19>** rSetup. Call this SETUP-INVARIANT */\n<line20>assert( p->rSetup>=pTemplate->rSetup );\n<line21>/* Any loop using an application-defined index (or PRIMARY KEY or\n<line22>** UNIQUE constraint) with one or more == constraints is better\n<line23>** than an automatic index. Unless it is a skip-scan. */\n<line24>if( (p->wsFlags & WHERE_AUTO_INDEX)!=0\n<line25>&& (pTemplate->nSkip)==0\n<line26>&& (pTemplate->wsFlags & WHERE_INDEXED)!=0\n<line27>&& (pTemplate->wsFlags & WHERE_COLUMN_EQ)!=0\n<line28>&& (p->prereq & pTemplate->prereq)==pTemplate->prereq\n<line29>){\n<line30>break;\n<line31>}\n<line32>/* If existing WhereLoop p is better than pTemplate, pTemplate can be\n<line33>** discarded.  WhereLoop p is better if:\n<line34>**   (1)  p has no more dependencies than pTemplate, and\n<line35>**   (2)  p has an equal or lower cost than pTemplate\n<line36>*/\n<line37>if( (p->prereq & pTemplate->prereq)==p->prereq    /* (1)  */\n<line38>&& p->rSetup<=pTemplate->rSetup                  /* (2a) */\n<line39>&& p->rRun<=pTemplate->rRun                      /* (2b) */\n<line40>&& p->nOut<=pTemplate->nOut                      /* (2c) */\n<line41>){\n<line42>return 0;  /* Discard pTemplate */\n<line43>}\n<line44>/* If pTemplate is always better than p, then cause p to be overwritten\n<line45>** with pTemplate.  pTemplate is better than p if:\n<line46>**   (1)  pTemplate has no more dependencies than p, and\n<line47>**   (2)  pTemplate has an equal or lower cost than p.\n<line48>*/\n<line49>if( (p->prereq & pTemplate->prereq)==pTemplate->prereq   /* (1)  */\n<line50>&& p->rRun>=pTemplate->rRun                             /* (2a) */\n<line51>&& p->nOut>=pTemplate->nOut                             /* (2b) */\n<line52>){\n<line53>assert( p->rSetup>=pTemplate->rSetup ); /* SETUP-INVARIANT above */\n<line54>break;   /* Cause p to be overwritten by pTemplate */\n<line55>}\n<line56>}\n<line57>return ppPrev;\n<line58>}
----------------------------------------
Function: whereLoopInsert
Content: <line0>static int whereLoopInsert(WhereLoopBuilder *pBuilder, WhereLoop *pTemplate){\n<line1>WhereLoop **ppPrev, *p;\n<line2>WhereInfo *pWInfo = pBuilder->pWInfo;\n<line3>sqlite3 *db = pWInfo->pParse->db;\n<line4>int rc;\n<line5>/* Stop the search once we hit the query planner search limit */\n<line6>if( pBuilder->iPlanLimit==0 ){\n<line7>WHERETRACE(0xffffffff,("=== query planner search limit reached ===\n"));\n<line8>if( pBuilder->pOrSet ) pBuilder->pOrSet->n = 0;\n<line9>return SQLITE_DONE;\n<line10>}\n<line11>pBuilder->iPlanLimit--;\n<line12>whereLoopAdjustCost(pWInfo->pLoops, pTemplate);\n<line13>/* If pBuilder->pOrSet is defined, then only keep track of the costs\n<line14>** and prereqs.\n<line15>*/\n<line16>if( pBuilder->pOrSet!=0 ){\n<line17>if( pTemplate->nLTerm ){\n<line18>#if WHERETRACE_ENABLED\n<line19>u16 n = pBuilder->pOrSet->n;\n<line20>int x =\n<line21>#endif\n<line22>whereOrInsert(pBuilder->pOrSet, pTemplate->prereq, pTemplate->rRun,\n<line23>pTemplate->nOut);\n<line24>#if WHERETRACE_ENABLED /* 0x8 */\n<line25>if( sqlite3WhereTrace & 0x8 ){\n<line26>sqlite3DebugPrintf(x?"   or-%d:  ":"   or-X:  ", n);\n<line27>sqlite3WhereLoopPrint(pTemplate, pBuilder->pWC);\n<line28>}\n<line29>#endif\n<line30>}\n<line31>return SQLITE_OK;\n<line32>}\n<line33>/* Look for an existing WhereLoop to replace with pTemplate\n<line34>*/\n<line35>ppPrev = whereLoopFindLesser(&pWInfo->pLoops, pTemplate);\n<line36>if( ppPrev==0 ){\n<line37>/* There already exists a WhereLoop on the list that is better\n<line38>** than pTemplate, so just ignore pTemplate */\n<line39>#if WHERETRACE_ENABLED /* 0x8 */\n<line40>if( sqlite3WhereTrace & 0x8 ){\n<line41>sqlite3DebugPrintf("   skip: ");\n<line42>sqlite3WhereLoopPrint(pTemplate, pBuilder->pWC);\n<line43>}\n<line44>#endif\n<line45>return SQLITE_OK;\n<line46>}else{\n<line47>p = *ppPrev;\n<line48>}\n<line49>/* If we reach this point it means that either p[] should be overwritten\n<line50>** with pTemplate[] if p[] exists, or if p==NULL then allocate a new\n<line51>** WhereLoop and insert it.\n<line52>*/\n<line53>#if WHERETRACE_ENABLED /* 0x8 */\n<line54>if( sqlite3WhereTrace & 0x8 ){\n<line55>if( p!=0 ){\n<line56>sqlite3DebugPrintf("replace: ");\n<line57>sqlite3WhereLoopPrint(p, pBuilder->pWC);\n<line58>sqlite3DebugPrintf("   with: ");\n<line59>}else{\n<line60>sqlite3DebugPrintf("    add: ");\n<line61>}\n<line62>sqlite3WhereLoopPrint(pTemplate, pBuilder->pWC);\n<line63>}\n<line64>#endif\n<line65>if( p==0 ){\n<line66>/* Allocate a new WhereLoop to add to the end of the list */\n<line67>*ppPrev = p = sqlite3DbMallocRawNN(db, sizeof(WhereLoop));\n<line68>if( p==0 ) return SQLITE_NOMEM_BKPT;\n<line69>whereLoopInit(p);\n<line70>p->pNextLoop = 0;\n<line71>}else{\n<line72>/* We will be overwriting WhereLoop p[].  But before we do, first\n<line73>** go through the rest of the list and delete any other entries besides\n<line74>** p[] that are also supplanted by pTemplate */\n<line75>WhereLoop **ppTail = &p->pNextLoop;\n<line76>WhereLoop *pToDel;\n<line77>while( *ppTail ){\n<line78>ppTail = whereLoopFindLesser(ppTail, pTemplate);\n<line79>if( ppTail==0 ) break;\n<line80>pToDel = *ppTail;\n<line81>if( pToDel==0 ) break;\n<line82>*ppTail = pToDel->pNextLoop;\n<line83>#if WHERETRACE_ENABLED /* 0x8 */\n<line84>if( sqlite3WhereTrace & 0x8 ){\n<line85>sqlite3DebugPrintf(" delete: ");\n<line86>sqlite3WhereLoopPrint(pToDel, pBuilder->pWC);\n<line87>}\n<line88>#endif\n<line89>whereLoopDelete(db, pToDel);\n<line90>}\n<line91>}\n<line92>rc = whereLoopXfer(db, p, pTemplate);\n<line93>if( (p->wsFlags & WHERE_VIRTUALTABLE)==0 ){\n<line94>Index *pIndex = p->u.btree.pIndex;\n<line95>if( pIndex && pIndex->idxType==SQLITE_IDXTYPE_IPK ){\n<line96>p->u.btree.pIndex = 0;\n<line97>}\n<line98>}\n<line99>return rc;\n<line100>}
----------------------------------------
Function: whereLoopOutputAdjust
Content: <line0>static void whereLoopOutputAdjust(\n<line1>WhereClause *pWC,      /* The WHERE clause */\n<line2>WhereLoop *pLoop,      /* The loop to adjust downward */\n<line3>LogEst nRow            /* Number of rows in the entire table */\n<line4>){\n<line5>WhereTerm *pTerm, *pX;\n<line6>Bitmask notAllowed = ~(pLoop->prereq|pLoop->maskSelf);\n<line7>int i, j;\n<line8>LogEst iReduce = 0;    /* pLoop->nOut should not exceed nRow-iReduce */\n<line9>assert( (pLoop->wsFlags & WHERE_AUTO_INDEX)==0 );\n<line10>for(i=pWC->nBase, pTerm=pWC->a; i>0; i--, pTerm++){\n<line11>assert( pTerm!=0 );\n<line12>if( (pTerm->prereqAll & notAllowed)!=0 ) continue;\n<line13>if( (pTerm->prereqAll & pLoop->maskSelf)==0 ) continue;\n<line14>if( (pTerm->wtFlags & TERM_VIRTUAL)!=0 ) continue;\n<line15>for(j=pLoop->nLTerm-1; j>=0; j--){\n<line16>pX = pLoop->aLTerm[j];\n<line17>if( pX==0 ) continue;\n<line18>if( pX==pTerm ) break;\n<line19>if( pX->iParent>=0 && (&pWC->a[pX->iParent])==pTerm ) break;\n<line20>}\n<line21>if( j<0 ){\n<line22>sqlite3ProgressCheck(pWC->pWInfo->pParse);\n<line23>if( pLoop->maskSelf==pTerm->prereqAll ){\n<line24>/* If there are extra terms in the WHERE clause not used by an index\n<line25>** that depend only on the table being scanned, and that will tend to\n<line26>** cause many rows to be omitted, then mark that table as\n<line27>** "self-culling".\n<line28>**\n<line29>** 2022-03-24:  Self-culling only applies if either the extra terms\n<line30>** are straight comparison operators that are non-true with NULL\n<line31>** operand, or if the loop is not an OUTER JOIN.\n<line32>*/\n<line33>if( (pTerm->eOperator & 0x3f)!=0\n<line34>|| (pWC->pWInfo->pTabList->a[pLoop->iTab].fg.jointype\n<line35>& (JT_LEFT|JT_LTORJ))==0\n<line36>){\n<line37>pLoop->wsFlags |= WHERE_SELFCULL;\n<line38>}\n<line39>}\n<line40>if( pTerm->truthProb<=0 ){\n<line41>/* If a truth probability is specified using the likelihood() hints,\n<line42>** then use the probability provided by the application. */\n<line43>pLoop->nOut += pTerm->truthProb;\n<line44>}else{\n<line45>/* In the absence of explicit truth probabilities, use heuristics to\n<line46>** guess a reasonable truth probability. */\n<line47>pLoop->nOut--;\n<line48>if( (pTerm->eOperator&(WO_EQ|WO_IS))!=0\n<line49>&& (pTerm->wtFlags & TERM_HIGHTRUTH)==0  /* tag-20200224-1 */\n<line50>){\n<line51>Expr *pRight = pTerm->pExpr->pRight;\n<line52>int k = 0;\n<line53>testcase( pTerm->pExpr->op==TK_IS );\n<line54>if( sqlite3ExprIsInteger(pRight, &k, 0) && k>=(-1) && k<=1 ){\n<line55>k = 10;\n<line56>}else{\n<line57>k = 20;\n<line58>}\n<line59>if( iReduce<k ){\n<line60>pTerm->wtFlags |= TERM_HEURTRUTH;\n<line61>iReduce = k;\n<line62>}\n<line63>}\n<line64>}\n<line65>}\n<line66>}\n<line67>if( pLoop->nOut > nRow-iReduce ){\n<line68>pLoop->nOut = nRow - iReduce;\n<line69>}\n<line70>}
----------------------------------------
Function: whereRangeVectorLen
Content: <line0>static int whereRangeVectorLen(\n<line1>Parse *pParse,       /* Parsing context */\n<line2>int iCur,            /* Cursor open on pIdx */\n<line3>Index *pIdx,         /* The index to be used for a inequality constraint */\n<line4>int nEq,             /* Number of prior equality constraints on same index */\n<line5>WhereTerm *pTerm     /* The vector inequality constraint */\n<line6>){\n<line7>int nCmp = sqlite3ExprVectorSize(pTerm->pExpr->pLeft);\n<line8>int i;\n<line9>nCmp = MIN(nCmp, (pIdx->nColumn - nEq));\n<line10>for(i=1; i<nCmp; i++){\n<line11>/* Test if comparison i of pTerm is compatible with column (i+nEq)\n<line12>** of the index. If not, exit the loop.  */\n<line13>char aff;                     /* Comparison affinity */\n<line14>char idxaff = 0;              /* Indexed columns affinity */\n<line15>CollSeq *pColl;               /* Comparison collation sequence */\n<line16>Expr *pLhs, *pRhs;\n<line17>assert( ExprUseXList(pTerm->pExpr->pLeft) );\n<line18>pLhs = pTerm->pExpr->pLeft->x.pList->a[i].pExpr;\n<line19>pRhs = pTerm->pExpr->pRight;\n<line20>if( ExprUseXSelect(pRhs) ){\n<line21>pRhs = pRhs->x.pSelect->pEList->a[i].pExpr;\n<line22>}else{\n<line23>pRhs = pRhs->x.pList->a[i].pExpr;\n<line24>}\n<line25>/* Check that the LHS of the comparison is a column reference to\n<line26>** the right column of the right source table. And that the sort\n<line27>** order of the index column is the same as the sort order of the\n<line28>** leftmost index column.  */\n<line29>if( pLhs->op!=TK_COLUMN\n<line30>|| pLhs->iTable!=iCur\n<line31>|| pLhs->iColumn!=pIdx->aiColumn[i+nEq]\n<line32>|| pIdx->aSortOrder[i+nEq]!=pIdx->aSortOrder[nEq]\n<line33>){\n<line34>break;\n<line35>}\n<line36>testcase( pLhs->iColumn==XN_ROWID );\n<line37>aff = sqlite3CompareAffinity(pRhs, sqlite3ExprAffinity(pLhs));\n<line38>idxaff = sqlite3TableColumnAffinity(pIdx->pTable, pLhs->iColumn);\n<line39>if( aff!=idxaff ) break;\n<line40>pColl = sqlite3BinaryCompareCollSeq(pParse, pLhs, pRhs);\n<line41>if( pColl==0 ) break;\n<line42>if( sqlite3StrICmp(pColl->zName, pIdx->azColl[i+nEq]) ) break;\n<line43>}\n<line44>return i;\n<line45>}
----------------------------------------
Function: whereLoopAddBtreeIndex
Content: <line0>static int whereLoopAddBtreeIndex(\n<line1>WhereLoopBuilder *pBuilder,     /* The WhereLoop factory */\n<line2>SrcItem *pSrc,                  /* FROM clause term being analyzed */\n<line3>Index *pProbe,                  /* An index on pSrc */\n<line4>LogEst nInMul                   /* log(Number of iterations due to IN) */\n<line5>){\n<line6>WhereInfo *pWInfo = pBuilder->pWInfo;  /* WHERE analyze context */\n<line7>Parse *pParse = pWInfo->pParse;        /* Parsing context */\n<line8>sqlite3 *db = pParse->db;       /* Database connection malloc context */\n<line9>WhereLoop *pNew;                /* Template WhereLoop under construction */\n<line10>WhereTerm *pTerm;               /* A WhereTerm under consideration */\n<line11>int opMask;                     /* Valid operators for constraints */\n<line12>WhereScan scan;                 /* Iterator for WHERE terms */\n<line13>Bitmask saved_prereq;           /* Original value of pNew->prereq */\n<line14>u16 saved_nLTerm;               /* Original value of pNew->nLTerm */\n<line15>u16 saved_nEq;                  /* Original value of pNew->u.btree.nEq */\n<line16>u16 saved_nBtm;                 /* Original value of pNew->u.btree.nBtm */\n<line17>u16 saved_nTop;                 /* Original value of pNew->u.btree.nTop */\n<line18>u16 saved_nSkip;                /* Original value of pNew->nSkip */\n<line19>u32 saved_wsFlags;              /* Original value of pNew->wsFlags */\n<line20>LogEst saved_nOut;              /* Original value of pNew->nOut */\n<line21>int rc = SQLITE_OK;             /* Return code */\n<line22>LogEst rSize;                   /* Number of rows in the table */\n<line23>LogEst rLogSize;                /* Logarithm of table size */\n<line24>WhereTerm *pTop = 0, *pBtm = 0; /* Top and bottom range constraints */\n<line25>pNew = pBuilder->pNew;\n<line26>assert( db->mallocFailed==0 || pParse->nErr>0 );\n<line27>if( pParse->nErr ){\n<line28>return pParse->rc;\n<line29>}\n<line30>WHERETRACE(0x800, ("BEGIN %s.addBtreeIdx(%s), nEq=%d, nSkip=%d, rRun=%d\n",\n<line31>pProbe->pTable->zName,pProbe->zName,\n<line32>pNew->u.btree.nEq, pNew->nSkip, pNew->rRun));\n<line33>assert( (pNew->wsFlags & WHERE_VIRTUALTABLE)==0 );\n<line34>assert( (pNew->wsFlags & WHERE_TOP_LIMIT)==0 );\n<line35>if( pNew->wsFlags & WHERE_BTM_LIMIT ){\n<line36>opMask = WO_LT|WO_LE;\n<line37>}else{\n<line38>assert( pNew->u.btree.nBtm==0 );\n<line39>opMask = WO_EQ|WO_IN|WO_GT|WO_GE|WO_LT|WO_LE|WO_ISNULL|WO_IS;\n<line40>}\n<line41>if( pProbe->bUnordered ){\n<line42>opMask &= ~(WO_GT|WO_GE|WO_LT|WO_LE);\n<line43>}\n<line44>assert( pNew->u.btree.nEq<pProbe->nColumn );\n<line45>assert( pNew->u.btree.nEq<pProbe->nKeyCol\n<line46>|| pProbe->idxType!=SQLITE_IDXTYPE_PRIMARYKEY );\n<line47>saved_nEq = pNew->u.btree.nEq;\n<line48>saved_nBtm = pNew->u.btree.nBtm;\n<line49>saved_nTop = pNew->u.btree.nTop;\n<line50>saved_nSkip = pNew->nSkip;\n<line51>saved_nLTerm = pNew->nLTerm;\n<line52>saved_wsFlags = pNew->wsFlags;\n<line53>saved_prereq = pNew->prereq;\n<line54>saved_nOut = pNew->nOut;\n<line55>pTerm = whereScanInit(&scan, pBuilder->pWC, pSrc->iCursor, saved_nEq,\n<line56>opMask, pProbe);\n<line57>pNew->rSetup = 0;\n<line58>rSize = pProbe->aiRowLogEst[0];\n<line59>rLogSize = estLog(rSize);\n<line60>for(; rc==SQLITE_OK && pTerm!=0; pTerm = whereScanNext(&scan)){\n<line61>u16 eOp = pTerm->eOperator;   /* Shorthand for pTerm->eOperator */\n<line62>LogEst rCostIdx;\n<line63>LogEst nOutUnadjusted;        /* nOut before IN() and WHERE adjustments */\n<line64>int nIn = 0;\n<line65>#ifdef SQLITE_ENABLE_STAT4\n<line66>int nRecValid = pBuilder->nRecValid;\n<line67>#endif\n<line68>if( (eOp==WO_ISNULL || (pTerm->wtFlags&TERM_VNULL)!=0)\n<line69>&& indexColumnNotNull(pProbe, saved_nEq)\n<line70>){\n<line71>continue; /* ignore IS [NOT] NULL constraints on NOT NULL columns */\n<line72>}\n<line73>if( pTerm->prereqRight & pNew->maskSelf ) continue;\n<line74>/* Do not allow the upper bound of a LIKE optimization range constraint\n<line75>** to mix with a lower range bound from some other source */\n<line76>if( pTerm->wtFlags & TERM_LIKEOPT && pTerm->eOperator==WO_LT ) continue;\n<line77>if( (pSrc->fg.jointype & (JT_LEFT|JT_LTORJ|JT_RIGHT))!=0\n<line78>&& !constraintCompatibleWithOuterJoin(pTerm,pSrc)\n<line79>){\n<line80>continue;\n<line81>}\n<line82>if( IsUniqueIndex(pProbe) && saved_nEq==pProbe->nKeyCol-1 ){\n<line83>pBuilder->bldFlags1 |= SQLITE_BLDF1_UNIQUE;\n<line84>}else{\n<line85>pBuilder->bldFlags1 |= SQLITE_BLDF1_INDEXED;\n<line86>}\n<line87>pNew->wsFlags = saved_wsFlags;\n<line88>pNew->u.btree.nEq = saved_nEq;\n<line89>pNew->u.btree.nBtm = saved_nBtm;\n<line90>pNew->u.btree.nTop = saved_nTop;\n<line91>pNew->nLTerm = saved_nLTerm;\n<line92>if( pNew->nLTerm>=pNew->nLSlot\n<line93>&& whereLoopResize(db, pNew, pNew->nLTerm+1)\n<line94>){\n<line95>break; /* OOM while trying to enlarge the pNew->aLTerm array */\n<line96>}\n<line97>pNew->aLTerm[pNew->nLTerm++] = pTerm;\n<line98>pNew->prereq = (saved_prereq | pTerm->prereqRight) & ~pNew->maskSelf;\n<line99>assert( nInMul==0\n<line100>|| (pNew->wsFlags & WHERE_COLUMN_NULL)!=0\n<line101>|| (pNew->wsFlags & WHERE_COLUMN_IN)!=0\n<line102>|| (pNew->wsFlags & WHERE_SKIPSCAN)!=0\n<line103>);\n<line104>if( eOp & WO_IN ){\n<line105>Expr *pExpr = pTerm->pExpr;\n<line106>if( ExprUseXSelect(pExpr) ){\n<line107>/* "x IN (SELECT ...)":  TUNING: the SELECT returns 25 rows */\n<line108>int i;\n<line109>int bRedundant = 0;\n<line110>nIn = 46;  assert( 46==sqlite3LogEst(25) );\n<line111>/* The expression may actually be of the form (x, y) IN (SELECT...).\n<line112>** In this case there is a separate term for each of (x) and (y).\n<line113>** However, the nIn multiplier should only be applied once, not once\n<line114>** for each such term. The following loop checks that pTerm is the\n<line115>** first such term in use, and sets nIn back to 0 if it is not. */\n<line116>for(i=0; i<pNew->nLTerm-1; i++){\n<line117>if( pNew->aLTerm[i] && pNew->aLTerm[i]->pExpr==pExpr ){\n<line118>nIn = 0;\n<line119>if( pNew->aLTerm[i]->u.x.iField == pTerm->u.x.iField ){\n<line120>/* Detect when two or more columns of an index match the same\n<line121>** column of a vector IN operater, and avoid adding the column\n<line122>** to the WhereLoop more than once.  See tag-20250707-01\n<line123>** in test/rowvalue.test */\n<line124>bRedundant = 1;\n<line125>}\n<line126>}\n<line127>}\n<line128>if( bRedundant ){\n<line129>pNew->nLTerm--;\n<line130>continue;\n<line131>}\n<line132>}else if( ALWAYS(pExpr->x.pList && pExpr->x.pList->nExpr) ){\n<line133>/* "x IN (value, value, ...)" */\n<line134>nIn = sqlite3LogEst(pExpr->x.pList->nExpr);\n<line135>}\n<line136>if( pProbe->hasStat1 && rLogSize>=10 ){\n<line137>LogEst M, logK, x;\n<line138>/* Let:\n<line139>**   N = the total number of rows in the table\n<line140>**   K = the number of entries on the RHS of the IN operator\n<line141>**   M = the number of rows in the table that match terms to the\n<line142>**       to the left in the same index.  If the IN operator is on\n<line143>**       the left-most index column, M==N.\n<line144>**\n<line145>** Given the definitions above, it is better to omit the IN operator\n<line146>** from the index lookup and instead do a scan of the M elements,\n<line147>** testing each scanned row against the IN operator separately, if:\n<line148>**\n<line149>**        M*log(K) < K*log(N)\n<line150>**\n<line151>** Our estimates for M, K, and N might be inaccurate, so we build in\n<line152>** a safety margin of 2 (LogEst: 10) that favors using the IN operator\n<line153>** with the index, as using an index has better worst-case behavior.\n<line154>** If we do not have real sqlite_stat1 data, always prefer to use\n<line155>** the index.  Do not bother with this optimization on very small\n<line156>** tables (less than 2 rows) as it is pointless in that case.\n<line157>*/\n<line158>M = pProbe->aiRowLogEst[saved_nEq];\n<line159>logK = estLog(nIn);\n<line160>/* TUNING      v-----  10 to bias toward indexed IN */\n<line161>x = M + logK + 10 - (nIn + rLogSize);\n<line162>if( x>=0 ){\n<line163>WHERETRACE(0x40,\n<line164>("IN operator (N=%d M=%d logK=%d nIn=%d rLogSize=%d x=%d) "\n<line165>"prefers indexed lookup\n",\n<line166>saved_nEq, M, logK, nIn, rLogSize, x));\n<line167>}else if( nInMul<2 && OptimizationEnabled(db, SQLITE_SeekScan) ){\n<line168>WHERETRACE(0x40,\n<line169>("IN operator (N=%d M=%d logK=%d nIn=%d rLogSize=%d x=%d"\n<line170>" nInMul=%d) prefers skip-scan\n",\n<line171>saved_nEq, M, logK, nIn, rLogSize, x, nInMul));\n<line172>pNew->wsFlags |= WHERE_IN_SEEKSCAN;\n<line173>}else{\n<line174>WHERETRACE(0x40,\n<line175>("IN operator (N=%d M=%d logK=%d nIn=%d rLogSize=%d x=%d"\n<line176>" nInMul=%d) prefers normal scan\n",\n<line177>saved_nEq, M, logK, nIn, rLogSize, x, nInMul));\n<line178>continue;\n<line179>}\n<line180>}\n<line181>pNew->wsFlags |= WHERE_COLUMN_IN;\n<line182>}else if( eOp & (WO_EQ|WO_IS) ){\n<line183>int iCol = pProbe->aiColumn[saved_nEq];\n<line184>pNew->wsFlags |= WHERE_COLUMN_EQ;\n<line185>assert( saved_nEq==pNew->u.btree.nEq );\n<line186>if( iCol==XN_ROWID\n<line187>|| (iCol>=0 && nInMul==0 && saved_nEq==pProbe->nKeyCol-1)\n<line188>){\n<line189>if( iCol==XN_ROWID || pProbe->uniqNotNull\n<line190>|| (pProbe->nKeyCol==1 && pProbe->onError && (eOp & WO_EQ))\n<line191>){\n<line192>pNew->wsFlags |= WHERE_ONEROW;\n<line193>}else{\n<line194>pNew->wsFlags |= WHERE_UNQ_WANTED;\n<line195>}\n<line196>}\n<line197>if( scan.iEquiv>1 ) pNew->wsFlags |= WHERE_TRANSCONS;\n<line198>}else if( eOp & WO_ISNULL ){\n<line199>pNew->wsFlags |= WHERE_COLUMN_NULL;\n<line200>}else{\n<line201>int nVecLen = whereRangeVectorLen(\n<line202>pParse, pSrc->iCursor, pProbe, saved_nEq, pTerm\n<line203>);\n<line204>if( eOp & (WO_GT|WO_GE) ){\n<line205>testcase( eOp & WO_GT );\n<line206>testcase( eOp & WO_GE );\n<line207>pNew->wsFlags |= WHERE_COLUMN_RANGE|WHERE_BTM_LIMIT;\n<line208>pNew->u.btree.nBtm = nVecLen;\n<line209>pBtm = pTerm;\n<line210>pTop = 0;\n<line211>if( pTerm->wtFlags & TERM_LIKEOPT ){\n<line212>/* Range constraints that come from the LIKE optimization are\n<line213>** always used in pairs. */\n<line214>pTop = &pTerm[1];\n<line215>assert( (pTop-(pTerm->pWC->a))<pTerm->pWC->nTerm );\n<line216>assert( pTop->wtFlags & TERM_LIKEOPT );\n<line217>assert( pTop->eOperator==WO_LT );\n<line218>if( whereLoopResize(db, pNew, pNew->nLTerm+1) ) break; /* OOM */\n<line219>pNew->aLTerm[pNew->nLTerm++] = pTop;\n<line220>pNew->wsFlags |= WHERE_TOP_LIMIT;\n<line221>pNew->u.btree.nTop = 1;\n<line222>}\n<line223>}else{\n<line224>assert( eOp & (WO_LT|WO_LE) );\n<line225>testcase( eOp & WO_LT );\n<line226>testcase( eOp & WO_LE );\n<line227>pNew->wsFlags |= WHERE_COLUMN_RANGE|WHERE_TOP_LIMIT;\n<line228>pNew->u.btree.nTop = nVecLen;\n<line229>pTop = pTerm;\n<line230>pBtm = (pNew->wsFlags & WHERE_BTM_LIMIT)!=0 ?\n<line231>pNew->aLTerm[pNew->nLTerm-2] : 0;\n<line232>}\n<line233>}\n<line234>/* At this point pNew->nOut is set to the number of rows expected to\n<line235>** be visited by the index scan before considering term pTerm, or the\n<line236>** values of nIn and nInMul. In other words, assuming that all\n<line237>** "x IN(...)" terms are replaced with "x = ?". This block updates\n<line238>** the value of pNew->nOut to account for pTerm (but not nIn/nInMul).  */\n<line239>assert( pNew->nOut==saved_nOut );\n<line240>if( pNew->wsFlags & WHERE_COLUMN_RANGE ){\n<line241>/* Adjust nOut using stat4 data. Or, if there is no stat4\n<line242>** data, using some other estimate.  */\n<line243>whereRangeScanEst(pParse, pBuilder, pBtm, pTop, pNew);\n<line244>}else{\n<line245>int nEq = ++pNew->u.btree.nEq;\n<line246>assert( eOp & (WO_ISNULL|WO_EQ|WO_IN|WO_IS) );\n<line247>assert( pNew->nOut==saved_nOut );\n<line248>if( pTerm->truthProb<=0 && pProbe->aiColumn[saved_nEq]>=0 ){\n<line249>assert( (eOp & WO_IN) || nIn==0 );\n<line250>testcase( eOp & WO_IN );\n<line251>pNew->nOut += pTerm->truthProb;\n<line252>pNew->nOut -= nIn;\n<line253>}else{\n<line254>#ifdef SQLITE_ENABLE_STAT4\n<line255>tRowcnt nOut = 0;\n<line256>if( nInMul==0\n<line257>&& pProbe->nSample\n<line258>&& ALWAYS(pNew->u.btree.nEq<=pProbe->nSampleCol)\n<line259>&& ((eOp & WO_IN)==0 || ExprUseXList(pTerm->pExpr))\n<line260>&& OptimizationEnabled(db, SQLITE_Stat4)\n<line261>){\n<line262>Expr *pExpr = pTerm->pExpr;\n<line263>if( (eOp & (WO_EQ|WO_ISNULL|WO_IS))!=0 ){\n<line264>testcase( eOp & WO_EQ );\n<line265>testcase( eOp & WO_IS );\n<line266>testcase( eOp & WO_ISNULL );\n<line267>rc = whereEqualScanEst(pParse, pBuilder, pExpr->pRight, &nOut);\n<line268>}else{\n<line269>rc = whereInScanEst(pParse, pBuilder, pExpr->x.pList, &nOut);\n<line270>}\n<line271>if( rc==SQLITE_NOTFOUND ) rc = SQLITE_OK;\n<line272>if( rc!=SQLITE_OK ) break;          /* Jump out of the pTerm loop */\n<line273>if( nOut ){\n<line274>pNew->nOut = sqlite3LogEst(nOut);\n<line275>if( nEq==1\n<line276>/* TUNING: Mark terms as "low selectivity" if they seem likely\n<line277>** to be true for half or more of the rows in the table.\n<line278>** See tag-202002240-1 */\n<line279>&& pNew->nOut+10 > pProbe->aiRowLogEst[0]\n<line280>){\n<line281>#if WHERETRACE_ENABLED /* 0x01 */\n<line282>if( sqlite3WhereTrace & 0x20 ){\n<line283>sqlite3DebugPrintf(\n<line284>"STAT4 determines term has low selectivity:\n");\n<line285>sqlite3WhereTermPrint(pTerm, 999);\n<line286>}\n<line287>#endif\n<line288>pTerm->wtFlags |= TERM_HIGHTRUTH;\n<line289>if( pTerm->wtFlags & TERM_HEURTRUTH ){\n<line290>/* If the term has previously been used with an assumption of\n<line291>** higher selectivity, then set the flag to rerun the\n<line292>** loop computations. */\n<line293>pBuilder->bldFlags2 |= SQLITE_BLDF2_2NDPASS;\n<line294>}\n<line295>}\n<line296>if( pNew->nOut>saved_nOut ) pNew->nOut = saved_nOut;\n<line297>pNew->nOut -= nIn;\n<line298>}\n<line299>}\n<line300>if( nOut==0 )\n<line301>#endif\n<line302>{\n<line303>pNew->nOut += (pProbe->aiRowLogEst[nEq] - pProbe->aiRowLogEst[nEq-1]);\n<line304>if( eOp & WO_ISNULL ){\n<line305>/* TUNING: If there is no likelihood() value, assume that a\n<line306>** "col IS NULL" expression matches twice as many rows\n<line307>** as (col=?). */\n<line308>pNew->nOut += 10;\n<line309>}\n<line310>}\n<line311>}\n<line312>}\n<line313>/* Set rCostIdx to the estimated cost of visiting selected rows in the\n<line314>** index.  The estimate is the sum of two values:\n<line315>**   1.  The cost of doing one search-by-key to find the first matching\n<line316>**       entry\n<line317>**   2.  Stepping forward in the index pNew->nOut times to find all\n<line318>**       additional matching entries.\n<line319>*/\n<line320>assert( pSrc->pSTab->szTabRow>0 );\n<line321>if( pProbe->idxType==SQLITE_IDXTYPE_IPK ){\n<line322>/* The pProbe->szIdxRow is low for an IPK table since the interior\n<line323>** pages are small.  Thus szIdxRow gives a good estimate of seek cost.\n<line324>** But the leaf pages are full-size, so pProbe->szIdxRow would badly\n<line325>** under-estimate the scanning cost. */\n<line326>rCostIdx = pNew->nOut + 16;\n<line327>}else{\n<line328>rCostIdx = pNew->nOut + 1 + (15*pProbe->szIdxRow)/pSrc->pSTab->szTabRow;\n<line329>}\n<line330>rCostIdx = sqlite3LogEstAdd(rLogSize, rCostIdx);\n<line331>/* Estimate the cost of running the loop.  If all data is coming\n<line332>** from the index, then this is just the cost of doing the index\n<line333>** lookup and scan.  But if some data is coming out of the main table,\n<line334>** we also have to add in the cost of doing pNew->nOut searches to\n<line335>** locate the row in the main table that corresponds to the index entry.\n<line336>*/\n<line337>pNew->rRun = rCostIdx;\n<line338>if( (pNew->wsFlags & (WHERE_IDX_ONLY|WHERE_IPK|WHERE_EXPRIDX))==0 ){\n<line339>pNew->rRun = sqlite3LogEstAdd(pNew->rRun, pNew->nOut + 16);\n<line340>}\n<line341>ApplyCostMultiplier(pNew->rRun, pProbe->pTable->costMult);\n<line342>nOutUnadjusted = pNew->nOut;\n<line343>pNew->rRun += nInMul + nIn;\n<line344>pNew->nOut += nInMul + nIn;\n<line345>whereLoopOutputAdjust(pBuilder->pWC, pNew, rSize);\n<line346>rc = whereLoopInsert(pBuilder, pNew);\n<line347>if( pNew->wsFlags & WHERE_COLUMN_RANGE ){\n<line348>pNew->nOut = saved_nOut;\n<line349>}else{\n<line350>pNew->nOut = nOutUnadjusted;\n<line351>}\n<line352>if( (pNew->wsFlags & WHERE_TOP_LIMIT)==0\n<line353>&& pNew->u.btree.nEq<pProbe->nColumn\n<line354>&& (pNew->u.btree.nEq<pProbe->nKeyCol ||\n<line355>pProbe->idxType!=SQLITE_IDXTYPE_PRIMARYKEY)\n<line356>){\n<line357>if( pNew->u.btree.nEq>3 ){\n<line358>sqlite3ProgressCheck(pParse);\n<line359>}\n<line360>whereLoopAddBtreeIndex(pBuilder, pSrc, pProbe, nInMul+nIn);\n<line361>}\n<line362>pNew->nOut = saved_nOut;\n<line363>#ifdef SQLITE_ENABLE_STAT4\n<line364>pBuilder->nRecValid = nRecValid;\n<line365>#endif\n<line366>}\n<line367>pNew->prereq = saved_prereq;\n<line368>pNew->u.btree.nEq = saved_nEq;\n<line369>pNew->u.btree.nBtm = saved_nBtm;\n<line370>pNew->u.btree.nTop = saved_nTop;\n<line371>pNew->nSkip = saved_nSkip;\n<line372>pNew->wsFlags = saved_wsFlags;\n<line373>pNew->nOut = saved_nOut;\n<line374>pNew->nLTerm = saved_nLTerm;\n<line375>/* Consider using a skip-scan if there are no WHERE clause constraints\n<line376>** available for the left-most terms of the index, and if the average\n<line377>** number of repeats in the left-most terms is at least 18.\n<line378>**\n<line379>** The magic number 18 is selected on the basis that scanning 17 rows\n<line380>** is almost always quicker than an index seek (even though if the index\n<line381>** contains fewer than 2^17 rows we assume otherwise in other parts of\n<line382>** the code). And, even if it is not, it should not be too much slower.\n<line383>** On the other hand, the extra seeks could end up being significantly\n<line384>** more expensive.  */\n<line385>assert( 42==sqlite3LogEst(18) );\n<line386>if( saved_nEq==saved_nSkip\n<line387>&& saved_nEq+1<pProbe->nKeyCol\n<line388>&& saved_nEq==pNew->nLTerm\n<line389>&& pProbe->noSkipScan==0\n<line390>&& pProbe->hasStat1!=0\n<line391>&& OptimizationEnabled(db, SQLITE_SkipScan)\n<line392>&& pProbe->aiRowLogEst[saved_nEq+1]>=42  /* TUNING: Minimum for skip-scan */\n<line393>&& pSrc->fg.fromExists==0\n<line394>&& (rc = whereLoopResize(db, pNew, pNew->nLTerm+1))==SQLITE_OK\n<line395>){\n<line396>LogEst nIter;\n<line397>pNew->u.btree.nEq++;\n<line398>pNew->nSkip++;\n<line399>pNew->aLTerm[pNew->nLTerm++] = 0;\n<line400>pNew->wsFlags |= WHERE_SKIPSCAN;\n<line401>nIter = pProbe->aiRowLogEst[saved_nEq] - pProbe->aiRowLogEst[saved_nEq+1];\n<line402>pNew->nOut -= nIter;\n<line403>/* TUNING:  Because uncertainties in the estimates for skip-scan queries,\n<line404>** add a 1.375 fudge factor to make skip-scan slightly less likely. */\n<line405>nIter += 5;\n<line406>whereLoopAddBtreeIndex(pBuilder, pSrc, pProbe, nIter + nInMul);\n<line407>pNew->nOut = saved_nOut;\n<line408>pNew->u.btree.nEq = saved_nEq;\n<line409>pNew->nSkip = saved_nSkip;\n<line410>pNew->wsFlags = saved_wsFlags;\n<line411>}\n<line412>WHERETRACE(0x800, ("END %s.addBtreeIdx(%s), nEq=%d, rc=%d\n",\n<line413>pProbe->pTable->zName, pProbe->zName, saved_nEq, rc));\n<line414>return rc;\n<line415>}
----------------------------------------
Function: indexMightHelpWithOrderBy
Content: <line0>static int indexMightHelpWithOrderBy(\n<line1>WhereLoopBuilder *pBuilder,\n<line2>Index *pIndex,\n<line3>int iCursor\n<line4>){\n<line5>ExprList *pOB;\n<line6>ExprList *aColExpr;\n<line7>int ii, jj;\n<line8>if( pIndex->bUnordered ) return 0;\n<line9>if( (pOB = pBuilder->pWInfo->pOrderBy)==0 ) return 0;\n<line10>for(ii=0; ii<pOB->nExpr; ii++){\n<line11>Expr *pExpr = sqlite3ExprSkipCollateAndLikely(pOB->a[ii].pExpr);\n<line12>if( NEVER(pExpr==0) ) continue;\n<line13>if( (pExpr->op==TK_COLUMN || pExpr->op==TK_AGG_COLUMN)\n<line14>&& pExpr->iTable==iCursor\n<line15>){\n<line16>if( pExpr->iColumn<0 ) return 1;\n<line17>for(jj=0; jj<pIndex->nKeyCol; jj++){\n<line18>if( pExpr->iColumn==pIndex->aiColumn[jj] ) return 1;\n<line19>}\n<line20>}else if( (aColExpr = pIndex->aColExpr)!=0 ){\n<line21>for(jj=0; jj<pIndex->nKeyCol; jj++){\n<line22>if( pIndex->aiColumn[jj]!=XN_EXPR ) continue;\n<line23>if( sqlite3ExprCompareSkip(pExpr,aColExpr->a[jj].pExpr,iCursor)==0 ){\n<line24>return 1;\n<line25>}\n<line26>}\n<line27>}\n<line28>}\n<line29>return 0;\n<line30>}
----------------------------------------
Function: whereUsablePartialIndex
Content: <line0>static int whereUsablePartialIndex(\n<line1>int iTab,             /* The table for which we want an index */\n<line2>u8 jointype,          /* The JT_* flags on the join */\n<line3>WhereClause *pWC,     /* The WHERE clause of the query */\n<line4>Expr *pWhere          /* The WHERE clause from the partial index */\n<line5>){\n<line6>int i;\n<line7>WhereTerm *pTerm;\n<line8>Parse *pParse;\n<line9>if( jointype & JT_LTORJ ) return 0;\n<line10>pParse = pWC->pWInfo->pParse;\n<line11>while( pWhere->op==TK_AND ){\n<line12>if( !whereUsablePartialIndex(iTab,jointype,pWC,pWhere->pLeft) ) return 0;\n<line13>pWhere = pWhere->pRight;\n<line14>}\n<line15>for(i=0, pTerm=pWC->a; i<pWC->nTerm; i++, pTerm++){\n<line16>Expr *pExpr;\n<line17>pExpr = pTerm->pExpr;\n<line18>if( (!ExprHasProperty(pExpr, EP_OuterON) || pExpr->w.iJoin==iTab)\n<line19>&& ((jointype & JT_OUTER)==0 || ExprHasProperty(pExpr, EP_OuterON))\n<line20>&& sqlite3ExprImpliesExpr(pParse, pExpr, pWhere, iTab)\n<line21>&& !sqlite3ExprImpliesExpr(pParse, pExpr, pWhere, -1)\n<line22>&& (pTerm->wtFlags & TERM_VNULL)==0\n<line23>){\n<line24>return 1;\n<line25>}\n<line26>}\n<line27>return 0;\n<line28>}
----------------------------------------
Function: exprIsCoveredByIndex
Content: <line0>static int exprIsCoveredByIndex(\n<line1>const Expr *pExpr,\n<line2>const Index *pIdx,\n<line3>int iTabCur\n<line4>){\n<line5>int i;\n<line6>for(i=0; i<pIdx->nColumn; i++){\n<line7>if( pIdx->aiColumn[i]==XN_EXPR\n<line8>&& sqlite3ExprCompare(0, pExpr, pIdx->aColExpr->a[i].pExpr, iTabCur)==0\n<line9>){\n<line10>return 1;\n<line11>}\n<line12>}\n<line13>return 0;\n<line14>}
----------------------------------------
Function: whereIsCoveringIndexWalkCallback
Content: <line0>static int whereIsCoveringIndexWalkCallback(Walker *pWalk, Expr *pExpr){\n<line1>int i;                    /* Loop counter */\n<line2>const Index *pIdx;        /* The index of interest */\n<line3>const i16 *aiColumn;      /* Columns contained in the index */\n<line4>u16 nColumn;              /* Number of columns in the index */\n<line5>CoveringIndexCheck *pCk;  /* Info about this search */\n<line6>pCk = pWalk->u.pCovIdxCk;\n<line7>pIdx = pCk->pIdx;\n<line8>if( (pExpr->op==TK_COLUMN || pExpr->op==TK_AGG_COLUMN) ){\n<line9>/* if( pExpr->iColumn<(BMS-1) && pIdx->bHasExpr==0 ) return WRC_Continue;*/\n<line10>if( pExpr->iTable!=pCk->iTabCur ) return WRC_Continue;\n<line11>pIdx = pWalk->u.pCovIdxCk->pIdx;\n<line12>aiColumn = pIdx->aiColumn;\n<line13>nColumn = pIdx->nColumn;\n<line14>for(i=0; i<nColumn; i++){\n<line15>if( aiColumn[i]==pExpr->iColumn ) return WRC_Continue;\n<line16>}\n<line17>pCk->bUnidx = 1;\n<line18>return WRC_Abort;\n<line19>}else if( pIdx->bHasExpr\n<line20>&& exprIsCoveredByIndex(pExpr, pIdx, pWalk->u.pCovIdxCk->iTabCur) ){\n<line21>pCk->bExpr = 1;\n<line22>return WRC_Prune;\n<line23>}\n<line24>return WRC_Continue;\n<line25>}
----------------------------------------
Function: whereIsCoveringIndex
Content: <line0>static SQLITE_NOINLINE u32 whereIsCoveringIndex(\n<line1>WhereInfo *pWInfo,     /* The WHERE clause context */\n<line2>Index *pIdx,           /* Index that is being tested */\n<line3>int iTabCur            /* Cursor for the table being indexed */\n<line4>){\n<line5>int i, rc;\n<line6>struct CoveringIndexCheck ck;\n<line7>Walker w;\n<line8>if( pWInfo->pSelect==0 ){\n<line9>/* We don't have access to the full query, so we cannot check to see\n<line10>** if pIdx is covering.  Assume it is not. */\n<line11>return 0;\n<line12>}\n<line13>if( pIdx->bHasExpr==0 ){\n<line14>for(i=0; i<pIdx->nColumn; i++){\n<line15>if( pIdx->aiColumn[i]>=BMS-1 ) break;\n<line16>}\n<line17>if( i>=pIdx->nColumn ){\n<line18>/* pIdx does not index any columns greater than 62, but we know from\n<line19>** colMask that columns greater than 62 are used, so this is not a\n<line20>** covering index */\n<line21>return 0;\n<line22>}\n<line23>}\n<line24>ck.pIdx = pIdx;\n<line25>ck.iTabCur = iTabCur;\n<line26>ck.bExpr = 0;\n<line27>ck.bUnidx = 0;\n<line28>memset(&w, 0, sizeof(w));\n<line29>w.xExprCallback = whereIsCoveringIndexWalkCallback;\n<line30>w.xSelectCallback = sqlite3SelectWalkNoop;\n<line31>w.u.pCovIdxCk = &ck;\n<line32>sqlite3WalkSelect(&w, pWInfo->pSelect);\n<line33>if( ck.bUnidx ){\n<line34>rc = 0;\n<line35>}else if( ck.bExpr ){\n<line36>rc = WHERE_EXPRIDX;\n<line37>}else{\n<line38>rc = WHERE_IDX_ONLY;\n<line39>}\n<line40>return rc;\n<line41>}
----------------------------------------
Function: whereIndexedExprCleanup
Content: <line0>static void whereIndexedExprCleanup(sqlite3 *db, void *pObject){\n<line1>IndexedExpr **pp = (IndexedExpr**)pObject;\n<line2>while( *pp!=0 ){\n<line3>IndexedExpr *p = *pp;\n<line4>*pp = p->pIENext;\n<line5>sqlite3ExprDelete(db, p->pExpr);\n<line6>sqlite3DbFreeNN(db, p);\n<line7>}\n<line8>}
----------------------------------------
Function: wherePartIdxExpr
Content: <line0>static void wherePartIdxExpr(\n<line1>Parse *pParse,                  /* Parse context */\n<line2>Index *pIdx,                    /* Partial index being processed */\n<line3>Expr *pPart,                    /* WHERE clause being processed */\n<line4>Bitmask *pMask,                 /* Mask to clear bits in */\n<line5>int iIdxCur,                    /* Cursor number for index */\n<line6>SrcItem *pItem                  /* The FROM clause entry for the table */\n<line7>){\n<line8>assert( pItem==0 || (pItem->fg.jointype & JT_RIGHT)==0 );\n<line9>assert( (pItem==0 || pMask==0) && (pMask!=0 || pItem!=0) );\n<line10>if( pPart->op==TK_AND ){\n<line11>wherePartIdxExpr(pParse, pIdx, pPart->pRight, pMask, iIdxCur, pItem);\n<line12>pPart = pPart->pLeft;\n<line13>}\n<line14>if( (pPart->op==TK_EQ || pPart->op==TK_IS) ){\n<line15>Expr *pLeft = pPart->pLeft;\n<line16>Expr *pRight = pPart->pRight;\n<line17>u8 aff;\n<line18>if( pLeft->op!=TK_COLUMN ) return;\n<line19>if( !sqlite3ExprIsConstant(0, pRight) ) return;\n<line20>if( !sqlite3IsBinary(sqlite3ExprCompareCollSeq(pParse, pPart)) ) return;\n<line21>if( pLeft->iColumn<0 ) return;\n<line22>aff = pIdx->pTable->aCol[pLeft->iColumn].affinity;\n<line23>if( aff>=SQLITE_AFF_TEXT ){\n<line24>if( pItem ){\n<line25>sqlite3 *db = pParse->db;\n<line26>IndexedExpr *p = (IndexedExpr*)sqlite3DbMallocRaw(db, sizeof(*p));\n<line27>if( p ){\n<line28>int bNullRow = (pItem->fg.jointype&(JT_LEFT|JT_LTORJ))!=0;\n<line29>p->pExpr = sqlite3ExprDup(db, pRight, 0);\n<line30>p->iDataCur = pItem->iCursor;\n<line31>p->iIdxCur = iIdxCur;\n<line32>p->iIdxCol = pLeft->iColumn;\n<line33>p->bMaybeNullRow = bNullRow;\n<line34>p->pIENext = pParse->pIdxPartExpr;\n<line35>p->aff = aff;\n<line36>pParse->pIdxPartExpr = p;\n<line37>if( p->pIENext==0 ){\n<line38>void *pArg = (void*)&pParse->pIdxPartExpr;\n<line39>sqlite3ParserAddCleanup(pParse, whereIndexedExprCleanup, pArg);\n<line40>}\n<line41>}\n<line42>}else if( pLeft->iColumn<(BMS-1) ){\n<line43>*pMask &= ~((Bitmask)1 << pLeft->iColumn);\n<line44>}\n<line45>}\n<line46>}\n<line47>}
----------------------------------------
Function: whereLoopAddBtree
Content: <line0>static int whereLoopAddBtree(\n<line1>WhereLoopBuilder *pBuilder, /* WHERE clause information */\n<line2>Bitmask mPrereq             /* Extra prerequisites for using this table */\n<line3>){\n<line4>WhereInfo *pWInfo;          /* WHERE analysis context */\n<line5>Index *pProbe;              /* An index we are evaluating */\n<line6>Index sPk;                  /* A fake index object for the primary key */\n<line7>LogEst aiRowEstPk[2];       /* The aiRowLogEst[] value for the sPk index */\n<line8>i16 aiColumnPk = -1;        /* The aColumn[] value for the sPk index */\n<line9>SrcList *pTabList;          /* The FROM clause */\n<line10>SrcItem *pSrc;              /* The FROM clause btree term to add */\n<line11>WhereLoop *pNew;            /* Template WhereLoop object */\n<line12>int rc = SQLITE_OK;         /* Return code */\n<line13>int iSortIdx = 1;           /* Index number */\n<line14>int b;                      /* A boolean value */\n<line15>LogEst rSize;               /* number of rows in the table */\n<line16>WhereClause *pWC;           /* The parsed WHERE clause */\n<line17>Table *pTab;                /* Table being queried */\n<line18>pNew = pBuilder->pNew;\n<line19>pWInfo = pBuilder->pWInfo;\n<line20>pTabList = pWInfo->pTabList;\n<line21>pSrc = pTabList->a + pNew->iTab;\n<line22>pTab = pSrc->pSTab;\n<line23>pWC = pBuilder->pWC;\n<line24>assert( !IsVirtual(pSrc->pSTab) );\n<line25>if( pSrc->fg.isIndexedBy ){\n<line26>assert( pSrc->fg.isCte==0 );\n<line27>/* An INDEXED BY clause specifies a particular index to use */\n<line28>pProbe = pSrc->u2.pIBIndex;\n<line29>}else if( !HasRowid(pTab) ){\n<line30>pProbe = pTab->pIndex;\n<line31>}else{\n<line32>/* There is no INDEXED BY clause.  Create a fake Index object in local\n<line33>** variable sPk to represent the rowid primary key index.  Make this\n<line34>** fake index the first in a chain of Index objects with all of the real\n<line35>** indices to follow */\n<line36>Index *pFirst;                  /* First of real indices on the table */\n<line37>memset(&sPk, 0, sizeof(Index));\n<line38>sPk.nKeyCol = 1;\n<line39>sPk.nColumn = 1;\n<line40>sPk.aiColumn = &aiColumnPk;\n<line41>sPk.aiRowLogEst = aiRowEstPk;\n<line42>sPk.onError = OE_Replace;\n<line43>sPk.pTable = pTab;\n<line44>sPk.szIdxRow = 3;  /* TUNING: Interior rows of IPK table are very small */\n<line45>sPk.idxType = SQLITE_IDXTYPE_IPK;\n<line46>aiRowEstPk[0] = pTab->nRowLogEst;\n<line47>aiRowEstPk[1] = 0;\n<line48>pFirst = pSrc->pSTab->pIndex;\n<line49>if( pSrc->fg.notIndexed==0 ){\n<line50>/* The real indices of the table are only considered if the\n<line51>** NOT INDEXED qualifier is omitted from the FROM clause */\n<line52>sPk.pNext = pFirst;\n<line53>}\n<line54>pProbe = &sPk;\n<line55>}\n<line56>rSize = pTab->nRowLogEst;\n<line57>#ifndef SQLITE_OMIT_AUTOMATIC_INDEX\n<line58>/* Automatic indexes */\n<line59>if( !pBuilder->pOrSet      /* Not part of an OR optimization */\n<line60>&& (pWInfo->wctrlFlags & (WHERE_RIGHT_JOIN|WHERE_OR_SUBCLAUSE))==0\n<line61>&& (pWInfo->pParse->db->flags & SQLITE_AutoIndex)!=0\n<line62>&& !pSrc->fg.isIndexedBy  /* Has no INDEXED BY clause */\n<line63>&& !pSrc->fg.notIndexed   /* Has no NOT INDEXED clause */\n<line64>&& !pSrc->fg.isCorrelated /* Not a correlated subquery */\n<line65>&& !pSrc->fg.isRecursive  /* Not a recursive common table expression. */\n<line66>&& (pSrc->fg.jointype & JT_RIGHT)==0 /* Not the right tab of a RIGHT JOIN */\n<line67>){\n<line68>/* Generate auto-index WhereLoops */\n<line69>LogEst rLogSize;         /* Logarithm of the number of rows in the table */\n<line70>WhereTerm *pTerm;\n<line71>WhereTerm *pWCEnd = pWC->a + pWC->nTerm;\n<line72>rLogSize = estLog(rSize);\n<line73>for(pTerm=pWC->a; rc==SQLITE_OK && pTerm<pWCEnd; pTerm++){\n<line74>if( pTerm->prereqRight & pNew->maskSelf ) continue;\n<line75>if( termCanDriveIndex(pTerm, pSrc, 0) ){\n<line76>pNew->u.btree.nEq = 1;\n<line77>pNew->nSkip = 0;\n<line78>pNew->u.btree.pIndex = 0;\n<line79>pNew->nLTerm = 1;\n<line80>pNew->aLTerm[0] = pTerm;\n<line81>/* TUNING: One-time cost for computing the automatic index is\n<line82>** estimated to be X*N*log2(N) where N is the number of rows in\n<line83>** the table being indexed and where X is 7 (LogEst=28) for normal\n<line84>** tables or 0.5 (LogEst=-10) for views and subqueries.  The value\n<line85>** of X is smaller for views and subqueries so that the query planner\n<line86>** will be more aggressive about generating automatic indexes for\n<line87>** those objects, since there is no opportunity to add schema\n<line88>** indexes on subqueries and views. */\n<line89>pNew->rSetup = rLogSize + rSize;\n<line90>if( !IsView(pTab) && (pTab->tabFlags & TF_Ephemeral)==0 ){\n<line91>pNew->rSetup += 28;\n<line92>}else{\n<line93>pNew->rSetup -= 25;  /* Greatly reduced setup cost for auto indexes\n<line94>** on ephemeral materializations of views */\n<line95>}\n<line96>ApplyCostMultiplier(pNew->rSetup, pTab->costMult);\n<line97>if( pNew->rSetup<0 ) pNew->rSetup = 0;\n<line98>/* TUNING: Each index lookup yields 20 rows in the table.  This\n<line99>** is more than the usual guess of 10 rows, since we have no way\n<line100>** of knowing how selective the index will ultimately be.  It would\n<line101>** not be unreasonable to make this value much larger. */\n<line102>pNew->nOut = 43;  assert( 43==sqlite3LogEst(20) );\n<line103>pNew->rRun = sqlite3LogEstAdd(rLogSize,pNew->nOut);\n<line104>pNew->wsFlags = WHERE_AUTO_INDEX;\n<line105>pNew->prereq = mPrereq | pTerm->prereqRight;\n<line106>rc = whereLoopInsert(pBuilder, pNew);\n<line107>}\n<line108>}\n<line109>}\n<line110>#endif /* SQLITE_OMIT_AUTOMATIC_INDEX */\n<line111>/* Loop over all indices. If there was an INDEXED BY clause, then only\n<line112>** consider index pProbe.  */\n<line113>for(; rc==SQLITE_OK && pProbe;\n<line114>pProbe=(pSrc->fg.isIndexedBy ? 0 : pProbe->pNext), iSortIdx++\n<line115>){\n<line116>if( pProbe->pPartIdxWhere!=0\n<line117>&& !whereUsablePartialIndex(pSrc->iCursor, pSrc->fg.jointype, pWC,\n<line118>pProbe->pPartIdxWhere)\n<line119>){\n<line120>testcase( pNew->iTab!=pSrc->iCursor );  /* See ticket [98d973b8f5] */\n<line121>continue;  /* Partial index inappropriate for this query */\n<line122>}\n<line123>if( pProbe->bNoQuery ) continue;\n<line124>rSize = pProbe->aiRowLogEst[0];\n<line125>pNew->u.btree.nEq = 0;\n<line126>pNew->u.btree.nBtm = 0;\n<line127>pNew->u.btree.nTop = 0;\n<line128>pNew->u.btree.nDistinctCol = 0;\n<line129>pNew->nSkip = 0;\n<line130>pNew->nLTerm = 0;\n<line131>pNew->iSortIdx = 0;\n<line132>pNew->rSetup = 0;\n<line133>pNew->prereq = mPrereq;\n<line134>pNew->nOut = rSize;\n<line135>pNew->u.btree.pIndex = pProbe;\n<line136>pNew->u.btree.pOrderBy = 0;\n<line137>b = indexMightHelpWithOrderBy(pBuilder, pProbe, pSrc->iCursor);\n<line138>/* The ONEPASS_DESIRED flags never occurs together with ORDER BY */\n<line139>assert( (pWInfo->wctrlFlags & WHERE_ONEPASS_DESIRED)==0 || b==0 );\n<line140>if( pProbe->idxType==SQLITE_IDXTYPE_IPK ){\n<line141>/* Integer primary key index */\n<line142>pNew->wsFlags = WHERE_IPK;\n<line143>/* Full table scan */\n<line144>pNew->iSortIdx = b ? iSortIdx : 0;\n<line145>/* TUNING: Cost of full table scan is 3.0*N.  The 3.0 factor is an\n<line146>** extra cost designed to discourage the use of full table scans,\n<line147>** since index lookups have better worst-case performance if our\n<line148>** stat guesses are wrong.  Reduce the 3.0 penalty slightly\n<line149>** (to 2.75) if we have valid STAT4 information for the table.\n<line150>** At 2.75, a full table scan is preferred over using an index on\n<line151>** a column with just two distinct values where each value has about\n<line152>** an equal number of appearances.  Without STAT4 data, we still want\n<line153>** to use an index in that case, since the constraint might be for\n<line154>** the scarcer of the two values, and in that case an index lookup is\n<line155>** better.\n<line156>*/\n<line157>#ifdef SQLITE_ENABLE_STAT4\n<line158>pNew->rRun = rSize + 16 - 2*((pTab->tabFlags & TF_HasStat4)!=0);\n<line159>#else\n<line160>pNew->rRun = rSize + 16;\n<line161>#endif\n<line162>ApplyCostMultiplier(pNew->rRun, pTab->costMult);\n<line163>whereLoopOutputAdjust(pWC, pNew, rSize);\n<line164>if( pSrc->fg.isSubquery ){\n<line165>if( pSrc->fg.viaCoroutine ) pNew->wsFlags |= WHERE_COROUTINE;\n<line166>pNew->u.btree.pOrderBy = pSrc->u4.pSubq->pSelect->pOrderBy;\n<line167>}\n<line168>rc = whereLoopInsert(pBuilder, pNew);\n<line169>pNew->nOut = rSize;\n<line170>if( rc ) break;\n<line171>}else{\n<line172>Bitmask m;\n<line173>if( pProbe->isCovering ){\n<line174>m = 0;\n<line175>pNew->wsFlags = WHERE_IDX_ONLY | WHERE_INDEXED;\n<line176>}else{\n<line177>m = pSrc->colUsed & pProbe->colNotIdxed;\n<line178>if( pProbe->pPartIdxWhere ){\n<line179>wherePartIdxExpr(\n<line180>pWInfo->pParse, pProbe, pProbe->pPartIdxWhere, &m, 0, 0\n<line181>);\n<line182>}\n<line183>pNew->wsFlags = WHERE_INDEXED;\n<line184>if( m==TOPBIT || (pProbe->bHasExpr && !pProbe->bHasVCol && m!=0) ){\n<line185>u32 isCov = whereIsCoveringIndex(pWInfo, pProbe, pSrc->iCursor);\n<line186>if( isCov==0 ){\n<line187>WHERETRACE(0x200,\n<line188>("-> %s is not a covering index"\n<line189>" according to whereIsCoveringIndex()\n", pProbe->zName));\n<line190>assert( m!=0 );\n<line191>}else{\n<line192>m = 0;\n<line193>pNew->wsFlags |= isCov;\n<line194>if( isCov & WHERE_IDX_ONLY ){\n<line195>WHERETRACE(0x200,\n<line196>("-> %s is a covering expression index"\n<line197>" according to whereIsCoveringIndex()\n", pProbe->zName));\n<line198>}else{\n<line199>assert( isCov==WHERE_EXPRIDX );\n<line200>WHERETRACE(0x200,\n<line201>("-> %s might be a covering expression index"\n<line202>" according to whereIsCoveringIndex()\n", pProbe->zName));\n<line203>}\n<line204>}\n<line205>}else if( m==0\n<line206>&& (HasRowid(pTab) || pWInfo->pSelect!=0 || sqlite3FaultSim(700))\n<line207>){\n<line208>WHERETRACE(0x200,\n<line209>("-> %s is a covering index according to bitmasks\n",\n<line210>pProbe->zName, m==0 ? "is" : "is not"));\n<line211>pNew->wsFlags = WHERE_IDX_ONLY | WHERE_INDEXED;\n<line212>}\n<line213>}\n<line214>/* Full scan via index */\n<line215>if( b\n<line216>|| !HasRowid(pTab)\n<line217>|| pProbe->pPartIdxWhere!=0\n<line218>|| pSrc->fg.isIndexedBy\n<line219>|| ( m==0\n<line220>&& pProbe->bUnordered==0\n<line221>&& (pProbe->szIdxRow<pTab->szTabRow)\n<line222>&& (pWInfo->wctrlFlags & WHERE_ONEPASS_DESIRED)==0\n<line223>&& sqlite3GlobalConfig.bUseCis\n<line224>&& OptimizationEnabled(pWInfo->pParse->db, SQLITE_CoverIdxScan)\n<line225>)\n<line226>){\n<line227>pNew->iSortIdx = b ? iSortIdx : 0;\n<line228>/* The cost of visiting the index rows is N*K, where K is\n<line229>** between 1.1 and 3.0, depending on the relative sizes of the\n<line230>** index and table rows. */\n<line231>pNew->rRun = rSize + 1 + (15*pProbe->szIdxRow)/pTab->szTabRow;\n<line232>if( m!=0 ){\n<line233>/* If this is a non-covering index scan, add in the cost of\n<line234>** doing table lookups.  The cost will be 3x the number of\n<line235>** lookups.  Take into account WHERE clause terms that can be\n<line236>** satisfied using just the index, and that do not require a\n<line237>** table lookup. */\n<line238>LogEst nLookup = rSize + 16;  /* Base cost:  N*3 */\n<line239>int ii;\n<line240>int iCur = pSrc->iCursor;\n<line241>WhereClause *pWC2 = &pWInfo->sWC;\n<line242>for(ii=0; ii<pWC2->nTerm; ii++){\n<line243>WhereTerm *pTerm = &pWC2->a[ii];\n<line244>if( !sqlite3ExprCoveredByIndex(pTerm->pExpr, iCur, pProbe) ){\n<line245>break;\n<line246>}\n<line247>/* pTerm can be evaluated using just the index.  So reduce\n<line248>** the expected number of table lookups accordingly */\n<line249>if( pTerm->truthProb<=0 ){\n<line250>nLookup += pTerm->truthProb;\n<line251>}else{\n<line252>nLookup--;\n<line253>if( pTerm->eOperator & (WO_EQ|WO_IS) ) nLookup -= 19;\n<line254>}\n<line255>}\n<line256>pNew->rRun = sqlite3LogEstAdd(pNew->rRun, nLookup);\n<line257>}\n<line258>ApplyCostMultiplier(pNew->rRun, pTab->costMult);\n<line259>whereLoopOutputAdjust(pWC, pNew, rSize);\n<line260>if( (pSrc->fg.jointype & JT_RIGHT)!=0 && pProbe->aColExpr ){\n<line261>/* Do not do an SCAN of a index-on-expression in a RIGHT JOIN\n<line262>** because the cursor used to access the index might not be\n<line263>** positioned to the correct row during the right-join no-match\n<line264>** loop. */\n<line265>}else{\n<line266>rc = whereLoopInsert(pBuilder, pNew);\n<line267>}\n<line268>pNew->nOut = rSize;\n<line269>if( rc ) break;\n<line270>}\n<line271>}\n<line272>pBuilder->bldFlags1 = 0;\n<line273>rc = whereLoopAddBtreeIndex(pBuilder, pSrc, pProbe, 0);\n<line274>if( pBuilder->bldFlags1==SQLITE_BLDF1_INDEXED ){\n<line275>/* If a non-unique index is used, or if a prefix of the key for\n<line276>** unique index is used (making the index functionally non-unique)\n<line277>** then the sqlite_stat1 data becomes important for scoring the\n<line278>** plan */\n<line279>pTab->tabFlags |= TF_MaybeReanalyze;\n<line280>}\n<line281>#ifdef SQLITE_ENABLE_STAT4\n<line282>sqlite3Stat4ProbeFree(pBuilder->pRec);\n<line283>pBuilder->nRecValid = 0;\n<line284>pBuilder->pRec = 0;\n<line285>#endif\n<line286>}\n<line287>return rc;\n<line288>}
----------------------------------------
Function: isLimitTerm
Content: <line0>static int isLimitTerm(WhereTerm *pTerm){\n<line1>assert( pTerm->eOperator==WO_AUX || pTerm->eMatchOp==0 );\n<line2>return pTerm->eMatchOp>=SQLITE_INDEX_CONSTRAINT_LIMIT\n<line3>&& pTerm->eMatchOp<=SQLITE_INDEX_CONSTRAINT_OFFSET;\n<line4>}
----------------------------------------
Function: allConstraintsUsed
Content: <line0>static int allConstraintsUsed(\n<line1>struct sqlite3_index_constraint_usage *aUsage,\n<line2>int nCons\n<line3>){\n<line4>int ii;\n<line5>for(ii=0; ii<nCons; ii++){\n<line6>if( aUsage[ii].argvIndex<=0 ) return 0;\n<line7>}\n<line8>return 1;\n<line9>}
----------------------------------------
Function: whereLoopAddVirtualOne
Content: <line0>static int whereLoopAddVirtualOne(\n<line1>WhereLoopBuilder *pBuilder,\n<line2>Bitmask mPrereq,                /* Mask of tables that must be used. */\n<line3>Bitmask mUsable,                /* Mask of usable tables */\n<line4>u16 mExclude,                   /* Exclude terms using these operators */\n<line5>sqlite3_index_info *pIdxInfo,   /* Populated object for xBestIndex */\n<line6>u16 mNoOmit,                    /* Do not omit these constraints */\n<line7>int *pbIn,                      /* OUT: True if plan uses an IN(...) op */\n<line8>int *pbRetryLimit               /* OUT: Retry without LIMIT/OFFSET */\n<line9>){\n<line10>WhereClause *pWC = pBuilder->pWC;\n<line11>HiddenIndexInfo *pHidden = (HiddenIndexInfo*)&pIdxInfo[1];\n<line12>struct sqlite3_index_constraint *pIdxCons;\n<line13>struct sqlite3_index_constraint_usage *pUsage = pIdxInfo->aConstraintUsage;\n<line14>int i;\n<line15>int mxTerm;\n<line16>int rc = SQLITE_OK;\n<line17>WhereLoop *pNew = pBuilder->pNew;\n<line18>Parse *pParse = pBuilder->pWInfo->pParse;\n<line19>SrcItem *pSrc = &pBuilder->pWInfo->pTabList->a[pNew->iTab];\n<line20>int nConstraint = pIdxInfo->nConstraint;\n<line21>assert( (mUsable & mPrereq)==mPrereq );\n<line22>*pbIn = 0;\n<line23>pNew->prereq = mPrereq;\n<line24>/* Set the usable flag on the subset of constraints identified by\n<line25>** arguments mUsable and mExclude. */\n<line26>pIdxCons = *(struct sqlite3_index_constraint**)&pIdxInfo->aConstraint;\n<line27>for(i=0; i<nConstraint; i++, pIdxCons++){\n<line28>WhereTerm *pTerm = termFromWhereClause(pWC, pIdxCons->iTermOffset);\n<line29>pIdxCons->usable = 0;\n<line30>if( (pTerm->prereqRight & mUsable)==pTerm->prereqRight\n<line31>&& (pTerm->eOperator & mExclude)==0\n<line32>&& (pbRetryLimit || !isLimitTerm(pTerm))\n<line33>){\n<line34>pIdxCons->usable = 1;\n<line35>}\n<line36>}\n<line37>/* Initialize the output fields of the sqlite3_index_info structure */\n<line38>memset(pUsage, 0, sizeof(pUsage[0])*nConstraint);\n<line39>assert( pIdxInfo->needToFreeIdxStr==0 );\n<line40>pIdxInfo->idxStr = 0;\n<line41>pIdxInfo->idxNum = 0;\n<line42>pIdxInfo->orderByConsumed = 0;\n<line43>pIdxInfo->estimatedCost = SQLITE_BIG_DBL / (double)2;\n<line44>pIdxInfo->estimatedRows = 25;\n<line45>pIdxInfo->idxFlags = 0;\n<line46>pHidden->mHandleIn = 0;\n<line47>/* Invoke the virtual table xBestIndex() method */\n<line48>rc = vtabBestIndex(pParse, pSrc->pSTab, pIdxInfo);\n<line49>if( rc ){\n<line50>if( rc==SQLITE_CONSTRAINT ){\n<line51>/* If the xBestIndex method returns SQLITE_CONSTRAINT, that means\n<line52>** that the particular combination of parameters provided is unusable.\n<line53>** Make no entries in the loop table.\n<line54>*/\n<line55>WHERETRACE(0xffffffff, ("  ^^^^--- non-viable plan rejected!\n"));\n<line56>freeIdxStr(pIdxInfo);\n<line57>return SQLITE_OK;\n<line58>}\n<line59>return rc;\n<line60>}\n<line61>mxTerm = -1;\n<line62>assert( pNew->nLSlot>=nConstraint );\n<line63>memset(pNew->aLTerm, 0, sizeof(pNew->aLTerm[0])*nConstraint );\n<line64>memset(&pNew->u.vtab, 0, sizeof(pNew->u.vtab));\n<line65>pIdxCons = *(struct sqlite3_index_constraint**)&pIdxInfo->aConstraint;\n<line66>for(i=0; i<nConstraint; i++, pIdxCons++){\n<line67>int iTerm;\n<line68>if( (iTerm = pUsage[i].argvIndex - 1)>=0 ){\n<line69>WhereTerm *pTerm;\n<line70>int j = pIdxCons->iTermOffset;\n<line71>if( iTerm>=nConstraint\n<line72>|| j<0\n<line73>|| (pTerm = termFromWhereClause(pWC, j))==0\n<line74>|| pNew->aLTerm[iTerm]!=0\n<line75>|| pIdxCons->usable==0\n<line76>){\n<line77>sqlite3ErrorMsg(pParse,"%s.xBestIndex malfunction",pSrc->pSTab->zName);\n<line78>freeIdxStr(pIdxInfo);\n<line79>return SQLITE_ERROR;\n<line80>}\n<line81>testcase( iTerm==nConstraint-1 );\n<line82>testcase( j==0 );\n<line83>testcase( j==pWC->nTerm-1 );\n<line84>pNew->prereq |= pTerm->prereqRight;\n<line85>assert( iTerm<pNew->nLSlot );\n<line86>pNew->aLTerm[iTerm] = pTerm;\n<line87>if( iTerm>mxTerm ) mxTerm = iTerm;\n<line88>testcase( iTerm==15 );\n<line89>testcase( iTerm==16 );\n<line90>if( pUsage[i].omit ){\n<line91>if( i<16 && ((1<<i)&mNoOmit)==0 ){\n<line92>testcase( i!=iTerm );\n<line93>pNew->u.vtab.omitMask |= 1<<iTerm;\n<line94>}else{\n<line95>testcase( i!=iTerm );\n<line96>}\n<line97>if( pTerm->eMatchOp==SQLITE_INDEX_CONSTRAINT_OFFSET ){\n<line98>pNew->u.vtab.bOmitOffset = 1;\n<line99>}\n<line100>}\n<line101>if( SMASKBIT32(i) & pHidden->mHandleIn ){\n<line102>pNew->u.vtab.mHandleIn |= MASKBIT32(iTerm);\n<line103>}else if( (pTerm->eOperator & WO_IN)!=0 ){\n<line104>/* A virtual table that is constrained by an IN clause may not\n<line105>** consume the ORDER BY clause because (1) the order of IN terms\n<line106>** is not necessarily related to the order of output terms and\n<line107>** (2) Multiple outputs from a single IN value will not merge\n<line108>** together.  */\n<line109>pIdxInfo->orderByConsumed = 0;\n<line110>pIdxInfo->idxFlags &= ~SQLITE_INDEX_SCAN_UNIQUE;\n<line111>*pbIn = 1; assert( (mExclude & WO_IN)==0 );\n<line112>}\n<line113>/* Unless pbRetryLimit is non-NULL, there should be no LIMIT/OFFSET\n<line114>** terms. And if there are any, they should follow all other terms. */\n<line115>assert( pbRetryLimit || !isLimitTerm(pTerm) );\n<line116>assert( !isLimitTerm(pTerm) || i>=nConstraint-2 );\n<line117>assert( !isLimitTerm(pTerm) || i==nConstraint-1 || isLimitTerm(pTerm+1) );\n<line118>if( isLimitTerm(pTerm) && (*pbIn || !allConstraintsUsed(pUsage, i)) ){\n<line119>/* If there is an IN(...) term handled as an == (separate call to\n<line120>** xFilter for each value on the RHS of the IN) and a LIMIT or\n<line121>** OFFSET term handled as well, the plan is unusable. Similarly,\n<line122>** if there is a LIMIT/OFFSET and there are other unused terms,\n<line123>** the plan cannot be used. In these cases set variable *pbRetryLimit\n<line124>** to true to tell the caller to retry with LIMIT and OFFSET\n<line125>** disabled. */\n<line126>freeIdxStr(pIdxInfo);\n<line127>*pbRetryLimit = 1;\n<line128>return SQLITE_OK;\n<line129>}\n<line130>}\n<line131>}\n<line132>pNew->nLTerm = mxTerm+1;\n<line133>for(i=0; i<=mxTerm; i++){\n<line134>if( pNew->aLTerm[i]==0 ){\n<line135>/* The non-zero argvIdx values must be contiguous.  Raise an\n<line136>** error if they are not */\n<line137>sqlite3ErrorMsg(pParse,"%s.xBestIndex malfunction",pSrc->pSTab->zName);\n<line138>freeIdxStr(pIdxInfo);\n<line139>return SQLITE_ERROR;\n<line140>}\n<line141>}\n<line142>assert( pNew->nLTerm<=pNew->nLSlot );\n<line143>pNew->u.vtab.idxNum = pIdxInfo->idxNum;\n<line144>pNew->u.vtab.needFree = pIdxInfo->needToFreeIdxStr;\n<line145>pIdxInfo->needToFreeIdxStr = 0;\n<line146>pNew->u.vtab.idxStr = pIdxInfo->idxStr;\n<line147>pNew->u.vtab.isOrdered = (i8)(pIdxInfo->orderByConsumed ?\n<line148>pIdxInfo->nOrderBy : 0);\n<line149>pNew->u.vtab.bIdxNumHex = (pIdxInfo->idxFlags&SQLITE_INDEX_SCAN_HEX)!=0;\n<line150>pNew->rSetup = 0;\n<line151>pNew->rRun = sqlite3LogEstFromDouble(pIdxInfo->estimatedCost);\n<line152>pNew->nOut = sqlite3LogEst(pIdxInfo->estimatedRows);\n<line153>/* Set the WHERE_ONEROW flag if the xBestIndex() method indicated\n<line154>** that the scan will visit at most one row. Clear it otherwise. */\n<line155>if( pIdxInfo->idxFlags & SQLITE_INDEX_SCAN_UNIQUE ){\n<line156>pNew->wsFlags |= WHERE_ONEROW;\n<line157>}else{\n<line158>pNew->wsFlags &= ~WHERE_ONEROW;\n<line159>}\n<line160>rc = whereLoopInsert(pBuilder, pNew);\n<line161>if( pNew->u.vtab.needFree ){\n<line162>sqlite3_free(pNew->u.vtab.idxStr);\n<line163>pNew->u.vtab.needFree = 0;\n<line164>}\n<line165>WHERETRACE(0xffffffff, ("  bIn=%d prereqIn=%04llx prereqOut=%04llx\n",\n<line166>*pbIn, (sqlite3_uint64)mPrereq,\n<line167>(sqlite3_uint64)(pNew->prereq & ~mPrereq)));\n<line168>return rc;\n<line169>}
----------------------------------------
Function: sqlite3_vtab_collation
Content: <line0>SQLITE_API const char *sqlite3_vtab_collation(sqlite3_index_info *pIdxInfo, int iCons){\n<line1>HiddenIndexInfo *pHidden = (HiddenIndexInfo*)&pIdxInfo[1];\n<line2>const char *zRet = 0;\n<line3>if( iCons>=0 && iCons<pIdxInfo->nConstraint ){\n<line4>CollSeq *pC = 0;\n<line5>int iTerm = pIdxInfo->aConstraint[iCons].iTermOffset;\n<line6>Expr *pX = termFromWhereClause(pHidden->pWC, iTerm)->pExpr;\n<line7>if( pX->pLeft ){\n<line8>pC = sqlite3ExprCompareCollSeq(pHidden->pParse, pX);\n<line9>}\n<line10>zRet = (pC ? pC->zName : sqlite3StrBINARY);\n<line11>}\n<line12>return zRet;\n<line13>}
----------------------------------------
Function: sqlite3_vtab_in
Content: <line0>SQLITE_API int sqlite3_vtab_in(sqlite3_index_info *pIdxInfo, int iCons, int bHandle){\n<line1>HiddenIndexInfo *pHidden = (HiddenIndexInfo*)&pIdxInfo[1];\n<line2>u32 m = SMASKBIT32(iCons);\n<line3>if( m & pHidden->mIn ){\n<line4>if( bHandle==0 ){\n<line5>pHidden->mHandleIn &= ~m;\n<line6>}else if( bHandle>0 ){\n<line7>pHidden->mHandleIn |= m;\n<line8>}\n<line9>return 1;\n<line10>}\n<line11>return 0;\n<line12>}
----------------------------------------
Function: sqlite3_vtab_rhs_value
Content: <line0>SQLITE_API int sqlite3_vtab_rhs_value(\n<line1>sqlite3_index_info *pIdxInfo,   /* Copy of first argument to xBestIndex */\n<line2>int iCons,                      /* Constraint for which RHS is wanted */\n<line3>sqlite3_value **ppVal           /* Write value extracted here */\n<line4>){\n<line5>HiddenIndexInfo *pH = (HiddenIndexInfo*)&pIdxInfo[1];\n<line6>sqlite3_value *pVal = 0;\n<line7>int rc = SQLITE_OK;\n<line8>if( iCons<0 || iCons>=pIdxInfo->nConstraint ){\n<line9>rc = SQLITE_MISUSE_BKPT; /* EV: R-30545-25046 */\n<line10>}else{\n<line11>if( pH->aRhs[iCons]==0 ){\n<line12>WhereTerm *pTerm = termFromWhereClause(\n<line13>pH->pWC, pIdxInfo->aConstraint[iCons].iTermOffset\n<line14>);\n<line15>rc = sqlite3ValueFromExpr(\n<line16>pH->pParse->db, pTerm->pExpr->pRight, ENC(pH->pParse->db),\n<line17>SQLITE_AFF_BLOB, &pH->aRhs[iCons]\n<line18>);\n<line19>testcase( rc!=SQLITE_OK );\n<line20>}\n<line21>pVal = pH->aRhs[iCons];\n<line22>}\n<line23>*ppVal = pVal;\n<line24>if( rc==SQLITE_OK && pVal==0 ){  /* IMP: R-19933-32160 */\n<line25>rc = SQLITE_NOTFOUND;          /* IMP: R-36424-56542 */\n<line26>}\n<line27>return rc;\n<line28>}
----------------------------------------
Function: sqlite3_vtab_distinct
Content: <line0>SQLITE_API int sqlite3_vtab_distinct(sqlite3_index_info *pIdxInfo){\n<line1>HiddenIndexInfo *pHidden = (HiddenIndexInfo*)&pIdxInfo[1];\n<line2>assert( pHidden->eDistinct>=0 && pHidden->eDistinct<=3 );\n<line3>return pHidden->eDistinct;\n<line4>}
----------------------------------------
Function: whereLoopAddVirtual
Content: <line0>static int whereLoopAddVirtual(\n<line1>WhereLoopBuilder *pBuilder,  /* WHERE clause information */\n<line2>Bitmask mPrereq,             /* Tables that must be scanned before this one */\n<line3>Bitmask mUnusable            /* Tables that must be scanned after this one */\n<line4>){\n<line5>int rc = SQLITE_OK;          /* Return code */\n<line6>WhereInfo *pWInfo;           /* WHERE analysis context */\n<line7>Parse *pParse;               /* The parsing context */\n<line8>WhereClause *pWC;            /* The WHERE clause */\n<line9>SrcItem *pSrc;               /* The FROM clause term to search */\n<line10>sqlite3_index_info *p;       /* Object to pass to xBestIndex() */\n<line11>int nConstraint;             /* Number of constraints in p */\n<line12>int bIn;                     /* True if plan uses IN(...) operator */\n<line13>WhereLoop *pNew;\n<line14>Bitmask mBest;               /* Tables used by best possible plan */\n<line15>u16 mNoOmit;\n<line16>int bRetry = 0;              /* True to retry with LIMIT/OFFSET disabled */\n<line17>assert( (mPrereq & mUnusable)==0 );\n<line18>pWInfo = pBuilder->pWInfo;\n<line19>pParse = pWInfo->pParse;\n<line20>pWC = pBuilder->pWC;\n<line21>pNew = pBuilder->pNew;\n<line22>pSrc = &pWInfo->pTabList->a[pNew->iTab];\n<line23>assert( IsVirtual(pSrc->pSTab) );\n<line24>p = allocateIndexInfo(pWInfo, pWC, mUnusable, pSrc, &mNoOmit);\n<line25>if( p==0 ) return SQLITE_NOMEM_BKPT;\n<line26>pNew->rSetup = 0;\n<line27>pNew->wsFlags = WHERE_VIRTUALTABLE;\n<line28>pNew->nLTerm = 0;\n<line29>pNew->u.vtab.needFree = 0;\n<line30>nConstraint = p->nConstraint;\n<line31>if( whereLoopResize(pParse->db, pNew, nConstraint) ){\n<line32>freeIndexInfo(pParse->db, p);\n<line33>return SQLITE_NOMEM_BKPT;\n<line34>}\n<line35>/* First call xBestIndex() with all constraints usable. */\n<line36>WHERETRACE(0x800, ("BEGIN %s.addVirtual()\n", pSrc->pSTab->zName));\n<line37>WHERETRACE(0x800, ("  VirtualOne: all usable\n"));\n<line38>rc = whereLoopAddVirtualOne(\n<line39>pBuilder, mPrereq, ALLBITS, 0, p, mNoOmit, &bIn, &bRetry\n<line40>);\n<line41>if( bRetry ){\n<line42>assert( rc==SQLITE_OK );\n<line43>rc = whereLoopAddVirtualOne(\n<line44>pBuilder, mPrereq, ALLBITS, 0, p, mNoOmit, &bIn, 0\n<line45>);\n<line46>}\n<line47>/* If the call to xBestIndex() with all terms enabled produced a plan\n<line48>** that does not require any source tables (IOW: a plan with mBest==0)\n<line49>** and does not use an IN(...) operator, then there is no point in making\n<line50>** any further calls to xBestIndex() since they will all return the same\n<line51>** result (if the xBestIndex() implementation is sane). */\n<line52>if( rc==SQLITE_OK && ((mBest = (pNew->prereq & ~mPrereq))!=0 || bIn) ){\n<line53>int seenZero = 0;             /* True if a plan with no prereqs seen */\n<line54>int seenZeroNoIN = 0;         /* Plan with no prereqs and no IN(...) seen */\n<line55>Bitmask mPrev = 0;\n<line56>Bitmask mBestNoIn = 0;\n<line57>/* If the plan produced by the earlier call uses an IN(...) term, call\n<line58>** xBestIndex again, this time with IN(...) terms disabled. */\n<line59>if( bIn ){\n<line60>WHERETRACE(0x800, ("  VirtualOne: all usable w/o IN\n"));\n<line61>rc = whereLoopAddVirtualOne(\n<line62>pBuilder, mPrereq, ALLBITS, WO_IN, p, mNoOmit, &bIn, 0);\n<line63>assert( bIn==0 );\n<line64>mBestNoIn = pNew->prereq & ~mPrereq;\n<line65>if( mBestNoIn==0 ){\n<line66>seenZero = 1;\n<line67>seenZeroNoIN = 1;\n<line68>}\n<line69>}\n<line70>/* Call xBestIndex once for each distinct value of (prereqRight & ~mPrereq)\n<line71>** in the set of terms that apply to the current virtual table.  */\n<line72>while( rc==SQLITE_OK ){\n<line73>int i;\n<line74>Bitmask mNext = ALLBITS;\n<line75>assert( mNext>0 );\n<line76>for(i=0; i<nConstraint; i++){\n<line77>int iTerm = p->aConstraint[i].iTermOffset;\n<line78>Bitmask mThis = termFromWhereClause(pWC, iTerm)->prereqRight & ~mPrereq;\n<line79>if( mThis>mPrev && mThis<mNext ) mNext = mThis;\n<line80>}\n<line81>mPrev = mNext;\n<line82>if( mNext==ALLBITS ) break;\n<line83>if( mNext==mBest || mNext==mBestNoIn ) continue;\n<line84>WHERETRACE(0x800, ("  VirtualOne: mPrev=%04llx mNext=%04llx\n",\n<line85>(sqlite3_uint64)mPrev, (sqlite3_uint64)mNext));\n<line86>rc = whereLoopAddVirtualOne(\n<line87>pBuilder, mPrereq, mNext|mPrereq, 0, p, mNoOmit, &bIn, 0);\n<line88>if( pNew->prereq==mPrereq ){\n<line89>seenZero = 1;\n<line90>if( bIn==0 ) seenZeroNoIN = 1;\n<line91>}\n<line92>}\n<line93>/* If the calls to xBestIndex() in the above loop did not find a plan\n<line94>** that requires no source tables at all (i.e. one guaranteed to be\n<line95>** usable), make a call here with all source tables disabled */\n<line96>if( rc==SQLITE_OK && seenZero==0 ){\n<line97>WHERETRACE(0x800, ("  VirtualOne: all disabled\n"));\n<line98>rc = whereLoopAddVirtualOne(\n<line99>pBuilder, mPrereq, mPrereq, 0, p, mNoOmit, &bIn, 0);\n<line100>if( bIn==0 ) seenZeroNoIN = 1;\n<line101>}\n<line102>/* If the calls to xBestIndex() have so far failed to find a plan\n<line103>** that requires no source tables at all and does not use an IN(...)\n<line104>** operator, make a final call to obtain one here.  */\n<line105>if( rc==SQLITE_OK && seenZeroNoIN==0 ){\n<line106>WHERETRACE(0x800, ("  VirtualOne: all disabled and w/o IN\n"));\n<line107>rc = whereLoopAddVirtualOne(\n<line108>pBuilder, mPrereq, mPrereq, WO_IN, p, mNoOmit, &bIn, 0);\n<line109>}\n<line110>}\n<line111>freeIndexInfo(pParse->db, p);\n<line112>WHERETRACE(0x800, ("END %s.addVirtual(), rc=%d\n", pSrc->pSTab->zName, rc));\n<line113>return rc;\n<line114>}
----------------------------------------
Function: whereLoopAddOr
Content: <line0>static int whereLoopAddOr(\n<line1>WhereLoopBuilder *pBuilder,\n<line2>Bitmask mPrereq,\n<line3>Bitmask mUnusable\n<line4>){\n<line5>WhereInfo *pWInfo = pBuilder->pWInfo;\n<line6>WhereClause *pWC;\n<line7>WhereLoop *pNew;\n<line8>WhereTerm *pTerm, *pWCEnd;\n<line9>int rc = SQLITE_OK;\n<line10>int iCur;\n<line11>WhereClause tempWC;\n<line12>WhereLoopBuilder sSubBuild;\n<line13>WhereOrSet sSum, sCur;\n<line14>SrcItem *pItem;\n<line15>pWC = pBuilder->pWC;\n<line16>pWCEnd = pWC->a + pWC->nTerm;\n<line17>pNew = pBuilder->pNew;\n<line18>memset(&sSum, 0, sizeof(sSum));\n<line19>pItem = pWInfo->pTabList->a + pNew->iTab;\n<line20>iCur = pItem->iCursor;\n<line21>/* The multi-index OR optimization does not work for RIGHT and FULL JOIN */\n<line22>if( pItem->fg.jointype & JT_RIGHT ) return SQLITE_OK;\n<line23>for(pTerm=pWC->a; pTerm<pWCEnd && rc==SQLITE_OK; pTerm++){\n<line24>if( (pTerm->eOperator & WO_OR)!=0\n<line25>&& (pTerm->u.pOrInfo->indexable & pNew->maskSelf)!=0\n<line26>){\n<line27>WhereClause * const pOrWC = &pTerm->u.pOrInfo->wc;\n<line28>WhereTerm * const pOrWCEnd = &pOrWC->a[pOrWC->nTerm];\n<line29>WhereTerm *pOrTerm;\n<line30>int once = 1;\n<line31>int i, j;\n<line32>sSubBuild = *pBuilder;\n<line33>sSubBuild.pOrSet = &sCur;\n<line34>WHERETRACE(0x400, ("Begin processing OR-clause %p\n", pTerm));\n<line35>for(pOrTerm=pOrWC->a; pOrTerm<pOrWCEnd; pOrTerm++){\n<line36>if( (pOrTerm->eOperator & WO_AND)!=0 ){\n<line37>sSubBuild.pWC = &pOrTerm->u.pAndInfo->wc;\n<line38>}else if( pOrTerm->leftCursor==iCur ){\n<line39>tempWC.pWInfo = pWC->pWInfo;\n<line40>tempWC.pOuter = pWC;\n<line41>tempWC.op = TK_AND;\n<line42>tempWC.nTerm = 1;\n<line43>tempWC.nBase = 1;\n<line44>tempWC.a = pOrTerm;\n<line45>sSubBuild.pWC = &tempWC;\n<line46>}else{\n<line47>continue;\n<line48>}\n<line49>sCur.n = 0;\n<line50>#ifdef WHERETRACE_ENABLED\n<line51>WHERETRACE(0x400, ("OR-term %d of %p has %d subterms:\n",\n<line52>(int)(pOrTerm-pOrWC->a), pTerm, sSubBuild.pWC->nTerm));\n<line53>if( sqlite3WhereTrace & 0x20000 ){\n<line54>sqlite3WhereClausePrint(sSubBuild.pWC);\n<line55>}\n<line56>#endif\n<line57>#ifndef SQLITE_OMIT_VIRTUALTABLE\n<line58>if( IsVirtual(pItem->pSTab) ){\n<line59>rc = whereLoopAddVirtual(&sSubBuild, mPrereq, mUnusable);\n<line60>}else\n<line61>#endif\n<line62>{\n<line63>rc = whereLoopAddBtree(&sSubBuild, mPrereq);\n<line64>}\n<line65>if( rc==SQLITE_OK ){\n<line66>rc = whereLoopAddOr(&sSubBuild, mPrereq, mUnusable);\n<line67>}\n<line68>testcase( rc==SQLITE_NOMEM && sCur.n>0 );\n<line69>testcase( rc==SQLITE_DONE );\n<line70>if( sCur.n==0 ){\n<line71>sSum.n = 0;\n<line72>break;\n<line73>}else if( once ){\n<line74>whereOrMove(&sSum, &sCur);\n<line75>once = 0;\n<line76>}else{\n<line77>WhereOrSet sPrev;\n<line78>whereOrMove(&sPrev, &sSum);\n<line79>sSum.n = 0;\n<line80>for(i=0; i<sPrev.n; i++){\n<line81>for(j=0; j<sCur.n; j++){\n<line82>whereOrInsert(&sSum, sPrev.a[i].prereq | sCur.a[j].prereq,\n<line83>sqlite3LogEstAdd(sPrev.a[i].rRun, sCur.a[j].rRun),\n<line84>sqlite3LogEstAdd(sPrev.a[i].nOut, sCur.a[j].nOut));\n<line85>}\n<line86>}\n<line87>}\n<line88>}\n<line89>pNew->nLTerm = 1;\n<line90>pNew->aLTerm[0] = pTerm;\n<line91>pNew->wsFlags = WHERE_MULTI_OR;\n<line92>pNew->rSetup = 0;\n<line93>pNew->iSortIdx = 0;\n<line94>memset(&pNew->u, 0, sizeof(pNew->u));\n<line95>for(i=0; rc==SQLITE_OK && i<sSum.n; i++){\n<line96>/* TUNING: Currently sSum.a[i].rRun is set to the sum of the costs\n<line97>** of all sub-scans required by the OR-scan. However, due to rounding\n<line98>** errors, it may be that the cost of the OR-scan is equal to its\n<line99>** most expensive sub-scan. Add the smallest possible penalty\n<line100>** (equivalent to multiplying the cost by 1.07) to ensure that\n<line101>** this does not happen. Otherwise, for WHERE clauses such as the\n<line102>** following where there is an index on "y":\n<line103>**\n<line104>**     WHERE likelihood(x=?, 0.99) OR y=?\n<line105>**\n<line106>** the planner may elect to "OR" together a full-table scan and an\n<line107>** index lookup. And other similarly odd results.  */\n<line108>pNew->rRun = sSum.a[i].rRun + 1;\n<line109>pNew->nOut = sSum.a[i].nOut;\n<line110>pNew->prereq = sSum.a[i].prereq;\n<line111>rc = whereLoopInsert(pBuilder, pNew);\n<line112>}\n<line113>WHERETRACE(0x400, ("End processing OR-clause %p\n", pTerm));\n<line114>}\n<line115>}\n<line116>return rc;\n<line117>}
----------------------------------------
Function: whereLoopAddAll
Content: <line0>static int whereLoopAddAll(WhereLoopBuilder *pBuilder){\n<line1>WhereInfo *pWInfo = pBuilder->pWInfo;\n<line2>Bitmask mPrereq = 0;\n<line3>Bitmask mPrior = 0;\n<line4>int iTab;\n<line5>SrcList *pTabList = pWInfo->pTabList;\n<line6>SrcItem *pItem;\n<line7>SrcItem *pEnd = &pTabList->a[pWInfo->nLevel];\n<line8>sqlite3 *db = pWInfo->pParse->db;\n<line9>int rc = SQLITE_OK;\n<line10>int bFirstPastRJ = 0;\n<line11>int hasRightJoin = 0;\n<line12>WhereLoop *pNew;\n<line13>/* Loop over the tables in the join, from left to right */\n<line14>pNew = pBuilder->pNew;\n<line15>/* Verify that pNew has already been initialized */\n<line16>assert( pNew->nLTerm==0 );\n<line17>assert( pNew->wsFlags==0 );\n<line18>assert( pNew->nLSlot>=ArraySize(pNew->aLTermSpace) );\n<line19>assert( pNew->aLTerm!=0 );\n<line20>pBuilder->iPlanLimit = SQLITE_QUERY_PLANNER_LIMIT;\n<line21>for(iTab=0, pItem=pTabList->a; pItem<pEnd; iTab++, pItem++){\n<line22>Bitmask mUnusable = 0;\n<line23>pNew->iTab = iTab;\n<line24>pBuilder->iPlanLimit += SQLITE_QUERY_PLANNER_LIMIT_INCR;\n<line25>pNew->maskSelf = sqlite3WhereGetMask(&pWInfo->sMaskSet, pItem->iCursor);\n<line26>if( bFirstPastRJ\n<line27>|| (pItem->fg.jointype & (JT_OUTER|JT_CROSS|JT_LTORJ))!=0\n<line28>){\n<line29>/* Add prerequisites to prevent reordering of FROM clause terms\n<line30>** across CROSS joins and outer joins.  The bFirstPastRJ boolean\n<line31>** prevents the right operand of a RIGHT JOIN from being swapped with\n<line32>** other elements even further to the right.\n<line33>**\n<line34>** The JT_LTORJ case and the hasRightJoin flag work together to\n<line35>** prevent FROM-clause terms from moving from the right side of\n<line36>** a LEFT JOIN over to the left side of that join if the LEFT JOIN\n<line37>** is itself on the left side of a RIGHT JOIN.\n<line38>*/\n<line39>if( pItem->fg.jointype & JT_LTORJ ) hasRightJoin = 1;\n<line40>mPrereq |= mPrior;\n<line41>bFirstPastRJ = (pItem->fg.jointype & JT_RIGHT)!=0;\n<line42>}else if( !hasRightJoin ){\n<line43>mPrereq = 0;\n<line44>}\n<line45>#ifndef SQLITE_OMIT_VIRTUALTABLE\n<line46>if( IsVirtual(pItem->pSTab) ){\n<line47>SrcItem *p;\n<line48>for(p=&pItem[1]; p<pEnd; p++){\n<line49>if( mUnusable || (p->fg.jointype & (JT_OUTER|JT_CROSS)) ){\n<line50>mUnusable |= sqlite3WhereGetMask(&pWInfo->sMaskSet, p->iCursor);\n<line51>}\n<line52>}\n<line53>rc = whereLoopAddVirtual(pBuilder, mPrereq, mUnusable);\n<line54>}else\n<line55>#endif /* SQLITE_OMIT_VIRTUALTABLE */\n<line56>{\n<line57>rc = whereLoopAddBtree(pBuilder, mPrereq);\n<line58>}\n<line59>if( rc==SQLITE_OK && pBuilder->pWC->hasOr ){\n<line60>rc = whereLoopAddOr(pBuilder, mPrereq, mUnusable);\n<line61>}\n<line62>mPrior |= pNew->maskSelf;\n<line63>if( rc || db->mallocFailed ){\n<line64>if( rc==SQLITE_DONE ){\n<line65>/* We hit the query planner search limit set by iPlanLimit */\n<line66>sqlite3_log(SQLITE_WARNING, "abbreviated query algorithm search");\n<line67>rc = SQLITE_OK;\n<line68>}else{\n<line69>break;\n<line70>}\n<line71>}\n<line72>}\n<line73>whereLoopClear(db, pNew);\n<line74>return rc;\n<line75>}
----------------------------------------
Function: wherePathMatchSubqueryOB
Content: <line0>static SQLITE_NOINLINE int wherePathMatchSubqueryOB(\n<line1>WhereInfo *pWInfo,      /* The WHERE clause */\n<line2>WhereLoop *pLoop,       /* The nested loop term that is a subquery */\n<line3>int iLoop,              /* Which level of the nested loop.  0==outermost */\n<line4>int iCur,               /* Cursor used by the this loop */\n<line5>ExprList *pOrderBy,     /* The ORDER BY clause on the whole query */\n<line6>Bitmask *pRevMask,      /* When loops need to go in reverse order */\n<line7>Bitmask *pOBSat         /* Which terms of pOrderBy are satisfied so far */\n<line8>){\n<line9>int iOB;                /* Index into pOrderBy->a[] */\n<line10>int jSub;               /* Index into pSubOB->a[] */\n<line11>u8 rev = 0;             /* True if iOB and jSub sort in opposite directions */\n<line12>u8 revIdx = 0;          /* Sort direction for jSub */\n<line13>Expr *pOBExpr;          /* Current term of outer ORDER BY */\n<line14>ExprList *pSubOB;       /* Complete ORDER BY on the subquery */\n<line15>pSubOB = pLoop->u.btree.pOrderBy;\n<line16>assert( pSubOB!=0 );\n<line17>for(iOB=0; (MASKBIT(iOB) & *pOBSat)!=0; iOB++){}\n<line18>for(jSub=0; jSub<pSubOB->nExpr && iOB<pOrderBy->nExpr; jSub++, iOB++){\n<line19>if( pSubOB->a[jSub].u.x.iOrderByCol==0 ) break;\n<line20>pOBExpr = pOrderBy->a[iOB].pExpr;\n<line21>if( pOBExpr->op!=TK_COLUMN && pOBExpr->op!=TK_AGG_COLUMN ) break;\n<line22>if( pOBExpr->iTable!=iCur ) break;\n<line23>if( pOBExpr->iColumn!=pSubOB->a[jSub].u.x.iOrderByCol-1 ) break;\n<line24>if( (pWInfo->wctrlFlags & WHERE_GROUPBY)==0 ){\n<line25>u8 sfOB = pOrderBy->a[iOB].fg.sortFlags;   /* sortFlags for iOB */\n<line26>u8 sfSub = pSubOB->a[jSub].fg.sortFlags;   /* sortFlags for jSub */\n<line27>if( (sfSub & KEYINFO_ORDER_BIGNULL) != (sfOB & KEYINFO_ORDER_BIGNULL) ){\n<line28>break;\n<line29>}\n<line30>revIdx = sfSub & KEYINFO_ORDER_DESC;\n<line31>if( jSub>0 ){\n<line32>if( (rev^revIdx)!=(sfOB & KEYINFO_ORDER_DESC) ){\n<line33>break;\n<line34>}\n<line35>}else{\n<line36>rev = revIdx ^ (sfOB & KEYINFO_ORDER_DESC);\n<line37>if( rev ){\n<line38>if( (pLoop->wsFlags & WHERE_COROUTINE)!=0 ){\n<line39>/* Cannot run a co-routine in reverse order */\n<line40>break;\n<line41>}\n<line42>*pRevMask |= MASKBIT(iLoop);\n<line43>}\n<line44>}\n<line45>}\n<line46>*pOBSat |= MASKBIT(iOB);\n<line47>}\n<line48>return jSub>0;\n<line49>}
----------------------------------------
Function: wherePathSatisfiesOrderBy
Content: <line0>static i8 wherePathSatisfiesOrderBy(\n<line1>WhereInfo *pWInfo,    /* The WHERE clause */\n<line2>ExprList *pOrderBy,   /* ORDER BY or GROUP BY or DISTINCT clause to check */\n<line3>WherePath *pPath,     /* The WherePath to check */\n<line4>u16 wctrlFlags,       /* WHERE_GROUPBY or _DISTINCTBY or _ORDERBY_LIMIT */\n<line5>u16 nLoop,            /* Number of entries in pPath->aLoop[] */\n<line6>WhereLoop *pLast,     /* Add this WhereLoop to the end of pPath->aLoop[] */\n<line7>Bitmask *pRevMask     /* OUT: Mask of WhereLoops to run in reverse order */\n<line8>){\n<line9>u8 revSet;            /* True if rev is known */\n<line10>u8 rev;               /* Composite sort order */\n<line11>u8 revIdx;            /* Index sort order */\n<line12>u8 isOrderDistinct;   /* All prior WhereLoops are order-distinct */\n<line13>u8 distinctColumns;   /* True if the loop has UNIQUE NOT NULL columns */\n<line14>u8 isMatch;           /* iColumn matches a term of the ORDER BY clause */\n<line15>u16 eqOpMask;         /* Allowed equality operators */\n<line16>u16 nKeyCol;          /* Number of key columns in pIndex */\n<line17>u16 nColumn;          /* Total number of ordered columns in the index */\n<line18>u16 nOrderBy;         /* Number terms in the ORDER BY clause */\n<line19>int iLoop;            /* Index of WhereLoop in pPath being processed */\n<line20>int i, j;             /* Loop counters */\n<line21>int iCur;             /* Cursor number for current WhereLoop */\n<line22>int iColumn;          /* A column number within table iCur */\n<line23>WhereLoop *pLoop = 0; /* Current WhereLoop being processed. */\n<line24>WhereTerm *pTerm;     /* A single term of the WHERE clause */\n<line25>Expr *pOBExpr;        /* An expression from the ORDER BY clause */\n<line26>CollSeq *pColl;       /* COLLATE function from an ORDER BY clause term */\n<line27>Index *pIndex;        /* The index associated with pLoop */\n<line28>sqlite3 *db = pWInfo->pParse->db;  /* Database connection */\n<line29>Bitmask obSat = 0;    /* Mask of ORDER BY terms satisfied so far */\n<line30>Bitmask obDone;       /* Mask of all ORDER BY terms */\n<line31>Bitmask orderDistinctMask;  /* Mask of all well-ordered loops */\n<line32>Bitmask ready;              /* Mask of inner loops */\n<line33>/*\n<line34>** We say the WhereLoop is "one-row" if it generates no more than one\n<line35>** row of output.  A WhereLoop is one-row if all of the following are true:\n<line36>**  (a) All index columns match with WHERE_COLUMN_EQ.\n<line37>**  (b) The index is unique\n<line38>** Any WhereLoop with an WHERE_COLUMN_EQ constraint on the rowid is one-row.\n<line39>** Every one-row WhereLoop will have the WHERE_ONEROW bit set in wsFlags.\n<line40>**\n<line41>** We say the WhereLoop is "order-distinct" if the set of columns from\n<line42>** that WhereLoop that are in the ORDER BY clause are different for every\n<line43>** row of the WhereLoop.  Every one-row WhereLoop is automatically\n<line44>** order-distinct.   A WhereLoop that has no columns in the ORDER BY clause\n<line45>** is not order-distinct. To be order-distinct is not quite the same as being\n<line46>** UNIQUE since a UNIQUE column or index can have multiple rows that\n<line47>** are NULL and NULL values are equivalent for the purpose of order-distinct.\n<line48>** To be order-distinct, the columns must be UNIQUE and NOT NULL.\n<line49>**\n<line50>** The rowid for a table is always UNIQUE and NOT NULL so whenever the\n<line51>** rowid appears in the ORDER BY clause, the corresponding WhereLoop is\n<line52>** automatically order-distinct.\n<line53>*/\n<line54>assert( pOrderBy!=0 );\n<line55>if( nLoop && OptimizationDisabled(db, SQLITE_OrderByIdxJoin) ) return 0;\n<line56>nOrderBy = pOrderBy->nExpr;\n<line57>testcase( nOrderBy==BMS-1 );\n<line58>if( nOrderBy>BMS-1 ) return 0;  /* Cannot optimize overly large ORDER BYs */\n<line59>isOrderDistinct = 1;\n<line60>obDone = MASKBIT(nOrderBy)-1;\n<line61>orderDistinctMask = 0;\n<line62>ready = 0;\n<line63>eqOpMask = WO_EQ | WO_IS | WO_ISNULL;\n<line64>if( wctrlFlags & (WHERE_ORDERBY_LIMIT|WHERE_ORDERBY_MAX|WHERE_ORDERBY_MIN) ){\n<line65>eqOpMask |= WO_IN;\n<line66>}\n<line67>for(iLoop=0; isOrderDistinct && obSat<obDone && iLoop<=nLoop; iLoop++){\n<line68>if( iLoop>0 ) ready |= pLoop->maskSelf;\n<line69>if( iLoop<nLoop ){\n<line70>pLoop = pPath->aLoop[iLoop];\n<line71>if( wctrlFlags & WHERE_ORDERBY_LIMIT ) continue;\n<line72>}else{\n<line73>pLoop = pLast;\n<line74>}\n<line75>if( pLoop->wsFlags & WHERE_VIRTUALTABLE ){\n<line76>if( pLoop->u.vtab.isOrdered\n<line77>&& ((wctrlFlags&(WHERE_DISTINCTBY|WHERE_SORTBYGROUP))!=WHERE_DISTINCTBY)\n<line78>){\n<line79>obSat = obDone;\n<line80>}else{\n<line81>/* No further ORDER BY terms may be matched. So this call should\n<line82>** return >=0, not -1. Clear isOrderDistinct to ensure it does so. */\n<line83>isOrderDistinct = 0;\n<line84>}\n<line85>break;\n<line86>}\n<line87>iCur = pWInfo->pTabList->a[pLoop->iTab].iCursor;\n<line88>/* Mark off any ORDER BY term X that is a column in the table of\n<line89>** the current loop for which there is term in the WHERE\n<line90>** clause of the form X IS NULL or X=? that reference only outer\n<line91>** loops.\n<line92>*/\n<line93>for(i=0; i<nOrderBy; i++){\n<line94>if( MASKBIT(i) & obSat ) continue;\n<line95>pOBExpr = sqlite3ExprSkipCollateAndLikely(pOrderBy->a[i].pExpr);\n<line96>if( NEVER(pOBExpr==0) ) continue;\n<line97>if( pOBExpr->op!=TK_COLUMN && pOBExpr->op!=TK_AGG_COLUMN ) continue;\n<line98>if( pOBExpr->iTable!=iCur ) continue;\n<line99>pTerm = sqlite3WhereFindTerm(&pWInfo->sWC, iCur, pOBExpr->iColumn,\n<line100>~ready, eqOpMask, 0);\n<line101>if( pTerm==0 ) continue;\n<line102>if( pTerm->eOperator==WO_IN ){\n<line103>/* IN terms are only valid for sorting in the ORDER BY LIMIT\n<line104>** optimization, and then only if they are actually used\n<line105>** by the query plan */\n<line106>assert( wctrlFlags &\n<line107>(WHERE_ORDERBY_LIMIT|WHERE_ORDERBY_MIN|WHERE_ORDERBY_MAX) );\n<line108>for(j=0; j<pLoop->nLTerm && pTerm!=pLoop->aLTerm[j]; j++){}\n<line109>if( j>=pLoop->nLTerm ) continue;\n<line110>}\n<line111>if( (pTerm->eOperator&(WO_EQ|WO_IS))!=0 && pOBExpr->iColumn>=0 ){\n<line112>Parse *pParse = pWInfo->pParse;\n<line113>CollSeq *pColl1 = sqlite3ExprNNCollSeq(pParse, pOrderBy->a[i].pExpr);\n<line114>CollSeq *pColl2 = sqlite3ExprCompareCollSeq(pParse, pTerm->pExpr);\n<line115>assert( pColl1 );\n<line116>if( pColl2==0 || sqlite3StrICmp(pColl1->zName, pColl2->zName) ){\n<line117>continue;\n<line118>}\n<line119>testcase( pTerm->pExpr->op==TK_IS );\n<line120>}\n<line121>obSat |= MASKBIT(i);\n<line122>}\n<line123>if( (pLoop->wsFlags & WHERE_ONEROW)==0 ){\n<line124>if( pLoop->wsFlags & WHERE_IPK ){\n<line125>if( pLoop->u.btree.pOrderBy\n<line126>&& OptimizationEnabled(db, SQLITE_OrderBySubq)\n<line127>&&  wherePathMatchSubqueryOB(pWInfo,pLoop,iLoop,iCur,\n<line128>pOrderBy,pRevMask, &obSat)\n<line129>){\n<line130>nColumn = 0;\n<line131>isOrderDistinct = 0;\n<line132>}else{\n<line133>nColumn = 1;\n<line134>}\n<line135>pIndex = 0;\n<line136>nKeyCol = 0;\n<line137>}else if( (pIndex = pLoop->u.btree.pIndex)==0 || pIndex->bUnordered ){\n<line138>return 0;\n<line139>}else{\n<line140>nKeyCol = pIndex->nKeyCol;\n<line141>nColumn = pIndex->nColumn;\n<line142>assert( nColumn==nKeyCol+1 || !HasRowid(pIndex->pTable) );\n<line143>assert( pIndex->aiColumn[nColumn-1]==XN_ROWID\n<line144>|| !HasRowid(pIndex->pTable));\n<line145>/* All relevant terms of the index must also be non-NULL in order\n<line146>** for isOrderDistinct to be true.  So the isOrderDistinct value\n<line147>** computed here might be a false positive.  Corrections will be\n<line148>** made at tag-20210426-1 below */\n<line149>isOrderDistinct = IsUniqueIndex(pIndex)\n<line150>&& (pLoop->wsFlags & WHERE_SKIPSCAN)==0;\n<line151>}\n<line152>/* Loop through all columns of the index and deal with the ones\n<line153>** that are not constrained by == or IN.\n<line154>*/\n<line155>rev = revSet = 0;\n<line156>distinctColumns = 0;\n<line157>for(j=0; j<nColumn; j++){\n<line158>u8 bOnce = 1; /* True to run the ORDER BY search loop */\n<line159>assert( j>=pLoop->u.btree.nEq\n<line160>|| (pLoop->aLTerm[j]==0)==(j<pLoop->nSkip)\n<line161>);\n<line162>if( j<pLoop->u.btree.nEq && j>=pLoop->nSkip ){\n<line163>u16 eOp = pLoop->aLTerm[j]->eOperator;\n<line164>/* Skip over == and IS and ISNULL terms.  (Also skip IN terms when\n<line165>** doing WHERE_ORDERBY_LIMIT processing).  Except, IS and ISNULL\n<line166>** terms imply that the index is not UNIQUE NOT NULL in which case\n<line167>** the loop need to be marked as not order-distinct because it can\n<line168>** have repeated NULL rows.\n<line169>**\n<line170>** If the current term is a column of an ((?,?) IN (SELECT...))\n<line171>** expression for which the SELECT returns more than one column,\n<line172>** check that it is the only column used by this loop. Otherwise,\n<line173>** if it is one of two or more, none of the columns can be\n<line174>** considered to match an ORDER BY term.\n<line175>*/\n<line176>if( (eOp & eqOpMask)!=0 ){\n<line177>if( eOp & (WO_ISNULL|WO_IS) ){\n<line178>testcase( eOp & WO_ISNULL );\n<line179>testcase( eOp & WO_IS );\n<line180>testcase( isOrderDistinct );\n<line181>isOrderDistinct = 0;\n<line182>}\n<line183>continue;\n<line184>}else if( ALWAYS(eOp & WO_IN) ){\n<line185>/* ALWAYS() justification: eOp is an equality operator due to the\n<line186>** j<pLoop->u.btree.nEq constraint above.  Any equality other\n<line187>** than WO_IN is captured by the previous "if".  So this one\n<line188>** always has to be WO_IN. */\n<line189>Expr *pX = pLoop->aLTerm[j]->pExpr;\n<line190>for(i=j+1; i<pLoop->u.btree.nEq; i++){\n<line191>if( pLoop->aLTerm[i]->pExpr==pX ){\n<line192>assert( (pLoop->aLTerm[i]->eOperator & WO_IN) );\n<line193>bOnce = 0;\n<line194>break;\n<line195>}\n<line196>}\n<line197>}\n<line198>}\n<line199>/* Get the column number in the table (iColumn) and sort order\n<line200>** (revIdx) for the j-th column of the index.\n<line201>*/\n<line202>if( pIndex ){\n<line203>iColumn = pIndex->aiColumn[j];\n<line204>revIdx = pIndex->aSortOrder[j] & KEYINFO_ORDER_DESC;\n<line205>if( iColumn==pIndex->pTable->iPKey ) iColumn = XN_ROWID;\n<line206>}else{\n<line207>iColumn = XN_ROWID;\n<line208>revIdx = 0;\n<line209>}\n<line210>/* An unconstrained column that might be NULL means that this\n<line211>** WhereLoop is not well-ordered.  tag-20210426-1\n<line212>*/\n<line213>if( isOrderDistinct ){\n<line214>if( iColumn>=0\n<line215>&& j>=pLoop->u.btree.nEq\n<line216>&& pIndex->pTable->aCol[iColumn].notNull==0\n<line217>){\n<line218>isOrderDistinct = 0;\n<line219>}\n<line220>if( iColumn==XN_EXPR ){\n<line221>isOrderDistinct = 0;\n<line222>}\n<line223>}\n<line224>/* Find the ORDER BY term that corresponds to the j-th column\n<line225>** of the index and mark that ORDER BY term having been satisfied.\n<line226>*/\n<line227>isMatch = 0;\n<line228>for(i=0; bOnce && i<nOrderBy; i++){\n<line229>if( MASKBIT(i) & obSat ) continue;\n<line230>pOBExpr = sqlite3ExprSkipCollateAndLikely(pOrderBy->a[i].pExpr);\n<line231>testcase( wctrlFlags & WHERE_GROUPBY );\n<line232>testcase( wctrlFlags & WHERE_DISTINCTBY );\n<line233>if( NEVER(pOBExpr==0) ) continue;\n<line234>if( (wctrlFlags & (WHERE_GROUPBY|WHERE_DISTINCTBY))==0 ) bOnce = 0;\n<line235>if( iColumn>=XN_ROWID ){\n<line236>if( pOBExpr->op!=TK_COLUMN && pOBExpr->op!=TK_AGG_COLUMN ) continue;\n<line237>if( pOBExpr->iTable!=iCur ) continue;\n<line238>if( pOBExpr->iColumn!=iColumn ) continue;\n<line239>}else{\n<line240>Expr *pIxExpr = pIndex->aColExpr->a[j].pExpr;\n<line241>if( sqlite3ExprCompareSkip(pOBExpr, pIxExpr, iCur) ){\n<line242>continue;\n<line243>}\n<line244>}\n<line245>if( iColumn!=XN_ROWID ){\n<line246>pColl = sqlite3ExprNNCollSeq(pWInfo->pParse, pOrderBy->a[i].pExpr);\n<line247>if( sqlite3StrICmp(pColl->zName, pIndex->azColl[j])!=0 ) continue;\n<line248>}\n<line249>if( wctrlFlags & WHERE_DISTINCTBY ){\n<line250>pLoop->u.btree.nDistinctCol = j+1;\n<line251>}\n<line252>isMatch = 1;\n<line253>break;\n<line254>}\n<line255>if( isMatch && (wctrlFlags & WHERE_GROUPBY)==0 ){\n<line256>/* Make sure the sort order is compatible in an ORDER BY clause.\n<line257>** Sort order is irrelevant for a GROUP BY clause. */\n<line258>if( revSet ){\n<line259>if( (rev ^ revIdx)\n<line260>!= (pOrderBy->a[i].fg.sortFlags&KEYINFO_ORDER_DESC)\n<line261>){\n<line262>isMatch = 0;\n<line263>}\n<line264>}else{\n<line265>rev = revIdx ^ (pOrderBy->a[i].fg.sortFlags & KEYINFO_ORDER_DESC);\n<line266>if( rev ) *pRevMask |= MASKBIT(iLoop);\n<line267>revSet = 1;\n<line268>}\n<line269>}\n<line270>if( isMatch && (pOrderBy->a[i].fg.sortFlags & KEYINFO_ORDER_BIGNULL) ){\n<line271>if( j==pLoop->u.btree.nEq ){\n<line272>pLoop->wsFlags |= WHERE_BIGNULL_SORT;\n<line273>}else{\n<line274>isMatch = 0;\n<line275>}\n<line276>}\n<line277>if( isMatch ){\n<line278>if( iColumn==XN_ROWID ){\n<line279>testcase( distinctColumns==0 );\n<line280>distinctColumns = 1;\n<line281>}\n<line282>obSat |= MASKBIT(i);\n<line283>}else{\n<line284>/* No match found */\n<line285>if( j==0 || j<nKeyCol ){\n<line286>testcase( isOrderDistinct!=0 );\n<line287>isOrderDistinct = 0;\n<line288>}\n<line289>break;\n<line290>}\n<line291>} /* end Loop over all index columns */\n<line292>if( distinctColumns ){\n<line293>testcase( isOrderDistinct==0 );\n<line294>isOrderDistinct = 1;\n<line295>}\n<line296>} /* end-if not one-row */\n<line297>/* Mark off any other ORDER BY terms that reference pLoop */\n<line298>if( isOrderDistinct ){\n<line299>orderDistinctMask |= pLoop->maskSelf;\n<line300>for(i=0; i<nOrderBy; i++){\n<line301>Expr *p;\n<line302>Bitmask mTerm;\n<line303>if( MASKBIT(i) & obSat ) continue;\n<line304>p = pOrderBy->a[i].pExpr;\n<line305>mTerm = sqlite3WhereExprUsage(&pWInfo->sMaskSet,p);\n<line306>if( mTerm==0 && !sqlite3ExprIsConstant(0,p) ) continue;\n<line307>if( (mTerm&~orderDistinctMask)==0 ){\n<line308>obSat |= MASKBIT(i);\n<line309>}\n<line310>}\n<line311>}\n<line312>} /* End the loop over all WhereLoops from outer-most down to inner-most */\n<line313>if( obSat==obDone ) return (i8)nOrderBy;\n<line314>if( !isOrderDistinct ){\n<line315>for(i=nOrderBy-1; i>0; i--){\n<line316>Bitmask m = ALWAYS(i<BMS) ? MASKBIT(i) - 1 : 0;\n<line317>if( (obSat&m)==m ) return i;\n<line318>}\n<line319>return 0;\n<line320>}\n<line321>return -1;\n<line322>}
----------------------------------------
Function: whereSortingCost
Content: <line0>static LogEst whereSortingCost(\n<line1>WhereInfo *pWInfo, /* Query planning context */\n<line2>LogEst nRow,       /* Estimated number of rows to sort */\n<line3>int nOrderBy,      /* Number of ORDER BY clause terms */\n<line4>int nSorted        /* Number of initial ORDER BY terms naturally in order */\n<line5>){\n<line6>/* Estimated cost of a full external sort, where N is\n<line7>** the number of rows to sort is:\n<line8>**\n<line9>**   cost = (K * N * log(N)).\n<line10>**\n<line11>** Or, if the order-by clause has X terms but only the last Y\n<line12>** terms are out of order, then block-sorting will reduce the\n<line13>** sorting cost to:\n<line14>**\n<line15>**   cost = (K * N * log(N)) * (Y/X)\n<line16>**\n<line17>** The constant K is at least 2.0 but will be larger if there are a\n<line18>** large number of columns to be sorted, as the sorting time is\n<line19>** proportional to the amount of content to be sorted.  The algorithm\n<line20>** does not currently distinguish between fat columns (BLOBs and TEXTs)\n<line21>** and skinny columns (INTs).  It just uses the number of columns as\n<line22>** an approximation for the row width.\n<line23>**\n<line24>** And extra factor of 2.0 or 3.0 is added to the sorting cost if the sort\n<line25>** is built using OP_IdxInsert and OP_Sort rather than with OP_SorterInsert.\n<line26>*/\n<line27>LogEst rSortCost, nCol;\n<line28>assert( pWInfo->pSelect!=0 );\n<line29>assert( pWInfo->pSelect->pEList!=0 );\n<line30>/* TUNING: sorting cost proportional to the number of output columns: */\n<line31>nCol = sqlite3LogEst((pWInfo->pSelect->pEList->nExpr+59)/30);\n<line32>rSortCost = nRow + nCol;\n<line33>if( nSorted>0 ){\n<line34>/* Scale the result by (Y/X) */\n<line35>rSortCost += sqlite3LogEst((nOrderBy-nSorted)*100/nOrderBy) - 66;\n<line36>}\n<line37>/* Multiple by log(M) where M is the number of output rows.\n<line38>** Use the LIMIT for M if it is smaller.  Or if this sort is for\n<line39>** a DISTINCT operator, M will be the number of distinct output\n<line40>** rows, so fudge it downwards a bit.\n<line41>*/\n<line42>if( (pWInfo->wctrlFlags & WHERE_USE_LIMIT)!=0 ){\n<line43>rSortCost += 10;       /* TUNING: Extra 2.0x if using LIMIT */\n<line44>if( nSorted!=0 ){\n<line45>rSortCost += 6;      /* TUNING: Extra 1.5x if also using partial sort */\n<line46>}\n<line47>if( pWInfo->iLimit<nRow ){\n<line48>nRow = pWInfo->iLimit;\n<line49>}\n<line50>}else if( (pWInfo->wctrlFlags & WHERE_WANT_DISTINCT) ){\n<line51>/* TUNING: In the sort for a DISTINCT operator, assume that the DISTINCT\n<line52>** reduces the number of output rows by a factor of 2 */\n<line53>if( nRow>10 ){ nRow -= 10;  assert( 10==sqlite3LogEst(2) ); }\n<line54>}\n<line55>rSortCost += estLog(nRow);\n<line56>return rSortCost;\n<line57>}
----------------------------------------
Function: computeMxChoice
Content: <line0>static int computeMxChoice(WhereInfo *pWInfo){\n<line1>int nLoop = pWInfo->nLevel;    /* Number of terms in the join */\n<line2>WhereLoop *pWLoop;             /* For looping over WhereLoops */\n<line3>#ifdef SQLITE_DEBUG\n<line4>/* The star-query detection code below makes use of the following\n<line5>** properties of the WhereLoop list, so verify them before\n<line6>** continuing:\n<line7>**    (1)  .maskSelf is the bitmask corresponding to .iTab\n<line8>**    (2)  The WhereLoop list is in ascending .iTab order\n<line9>*/\n<line10>for(pWLoop=pWInfo->pLoops; pWLoop; pWLoop=pWLoop->pNextLoop){\n<line11>assert( pWLoop->maskSelf==MASKBIT(pWLoop->iTab) );\n<line12>assert( pWLoop->pNextLoop==0 || pWLoop->iTab<=pWLoop->pNextLoop->iTab );\n<line13>}\n<line14>#endif /* SQLITE_DEBUG */\n<line15>if( nLoop>=5\n<line16>&& !pWInfo->bStarDone\n<line17>&& OptimizationEnabled(pWInfo->pParse->db, SQLITE_StarQuery)\n<line18>){\n<line19>SrcItem *aFromTabs;    /* All terms of the FROM clause */\n<line20>int iFromIdx;          /* Term of FROM clause is the candidate fact-table */\n<line21>Bitmask m;             /* Bitmask for candidate fact-table */\n<line22>Bitmask mSelfJoin = 0; /* Tables that cannot be dimension tables */\n<line23>WhereLoop *pStart;     /* Where to start searching for dimension-tables */\n<line24>pWInfo->bStarDone = 1; /* Only do this computation once */\n<line25>/* Look for fact tables with four or more dimensions where the\n<line26>** dimension tables are not separately from the fact tables by an outer\n<line27>** or cross join.  Adjust cost weights if found.\n<line28>*/\n<line29>assert( !pWInfo->bStarUsed );\n<line30>aFromTabs = pWInfo->pTabList->a;\n<line31>pStart = pWInfo->pLoops;\n<line32>for(iFromIdx=0, m=1; iFromIdx<nLoop; iFromIdx++, m<<=1){\n<line33>int nDep = 0;             /* Number of dimension tables */\n<line34>LogEst mxRun;             /* Maximum SCAN cost of a fact table */\n<line35>Bitmask mSeen = 0;        /* Mask of dimension tables */\n<line36>SrcItem *pFactTab;        /* The candidate fact table */\n<line37>pFactTab = aFromTabs + iFromIdx;\n<line38>if( (pFactTab->fg.jointype & (JT_OUTER|JT_CROSS))!=0 ){\n<line39>/* If the candidate fact-table is the right table of an outer join\n<line40>** restrict the search for dimension-tables to be tables to the right\n<line41>** of the fact-table. */\n<line42>if( iFromIdx+4 > nLoop ) break;  /* Impossible to reach nDep>=4 */\n<line43>while( pStart && pStart->iTab<=iFromIdx ){\n<line44>pStart = pStart->pNextLoop;\n<line45>}\n<line46>}\n<line47>for(pWLoop=pStart; pWLoop; pWLoop=pWLoop->pNextLoop){\n<line48>if( (aFromTabs[pWLoop->iTab].fg.jointype & (JT_OUTER|JT_CROSS))!=0 ){\n<line49>/* Fact-tables and dimension-tables cannot be separated by an\n<line50>** outer join (at least for the definition of fact- and dimension-\n<line51>** used by this heuristic). */\n<line52>break;\n<line53>}\n<line54>if( (pWLoop->prereq & m)!=0        /* pWInfo depends on iFromIdx */\n<line55>&& (pWLoop->maskSelf & mSeen)==0  /* pWInfo not already a dependency */\n<line56>&& (pWLoop->maskSelf & mSelfJoin)==0 /* Not a self-join */\n<line57>){\n<line58>if( aFromTabs[pWLoop->iTab].pSTab==pFactTab->pSTab ){\n<line59>mSelfJoin |= m;\n<line60>}else{\n<line61>nDep++;\n<line62>mSeen |= pWLoop->maskSelf;\n<line63>}\n<line64>}\n<line65>}\n<line66>if( nDep<=3 ) continue;\n<line67>/* If we reach this point, it means that pFactTab is a fact table\n<line68>** with four or more dimensions connected by inner joins.  Proceed\n<line69>** to make cost adjustments. */\n<line70>#ifdef WHERETRACE_ENABLED\n<line71>/* Make sure rStarDelta values are initialized */\n<line72>if( !pWInfo->bStarUsed ){\n<line73>for(pWLoop=pWInfo->pLoops; pWLoop; pWLoop=pWLoop->pNextLoop){\n<line74>pWLoop->rStarDelta = 0;\n<line75>}\n<line76>}\n<line77>#endif\n<line78>pWInfo->bStarUsed = 1;\n<line79>/* Compute the maximum cost of any WhereLoop for the\n<line80>** fact table plus one epsilon */\n<line81>mxRun = LOGEST_MIN;\n<line82>for(pWLoop=pStart; pWLoop; pWLoop=pWLoop->pNextLoop){\n<line83>if( pWLoop->iTab<iFromIdx ) continue;\n<line84>if( pWLoop->iTab>iFromIdx ) break;\n<line85>if( pWLoop->rRun>mxRun ) mxRun = pWLoop->rRun;\n<line86>}\n<line87>if( ALWAYS(mxRun<LOGEST_MAX) ) mxRun++;\n<line88>/* Increase the cost of table scans for dimension tables to be\n<line89>** slightly more than the maximum cost of the fact table */\n<line90>for(pWLoop=pStart; pWLoop; pWLoop=pWLoop->pNextLoop){\n<line91>if( (pWLoop->maskSelf & mSeen)==0 ) continue;\n<line92>if( pWLoop->nLTerm ) continue;\n<line93>if( pWLoop->rRun<mxRun ){\n<line94>#ifdef WHERETRACE_ENABLED /* 0x80000 */\n<line95>if( sqlite3WhereTrace & 0x80000 ){\n<line96>SrcItem *pDim = aFromTabs + pWLoop->iTab;\n<line97>sqlite3DebugPrintf(\n<line98>"Increase SCAN cost of dimension %s(%d) of fact %s(%d) to %d\n",\n<line99>pDim->zAlias ? pDim->zAlias: pDim->pSTab->zName, pWLoop->iTab,\n<line100>pFactTab->zAlias ? pFactTab->zAlias : pFactTab->pSTab->zName,\n<line101>iFromIdx, mxRun\n<line102>);\n<line103>}\n<line104>pWLoop->rStarDelta = mxRun - pWLoop->rRun;\n<line105>#endif /* WHERETRACE_ENABLED */\n<line106>pWLoop->rRun = mxRun;\n<line107>}\n<line108>}\n<line109>}\n<line110>#ifdef WHERETRACE_ENABLED /* 0x80000 */\n<line111>if( (sqlite3WhereTrace & 0x80000)!=0 && pWInfo->bStarUsed ){\n<line112>sqlite3DebugPrintf("WhereLoops changed by star-query heuristic:\n");\n<line113>for(pWLoop=pWInfo->pLoops; pWLoop; pWLoop=pWLoop->pNextLoop){\n<line114>if( pWLoop->rStarDelta ){\n<line115>sqlite3WhereLoopPrint(pWLoop, &pWInfo->sWC);\n<line116>}\n<line117>}\n<line118>}\n<line119>#endif\n<line120>}\n<line121>return pWInfo->bStarUsed ? 18 : 12;\n<line122>}
----------------------------------------
Function: whereLoopIsNoBetter
Content: <line0>static SQLITE_NOINLINE int whereLoopIsNoBetter(\n<line1>const WhereLoop *pCandidate,\n<line2>const WhereLoop *pBaseline\n<line3>){\n<line4>if( (pCandidate->wsFlags & WHERE_INDEXED)==0 ) return 1;\n<line5>if( (pBaseline->wsFlags & WHERE_INDEXED)==0 ) return 1;\n<line6>if( pCandidate->u.btree.pIndex->szIdxRow <\n<line7>pBaseline->u.btree.pIndex->szIdxRow ) return 0;\n<line8>return 1;\n<line9>}
----------------------------------------
Function: wherePathSolver
Content: <line0>static int wherePathSolver(WhereInfo *pWInfo, LogEst nRowEst){\n<line1>int mxChoice;             /* Maximum number of simultaneous paths tracked */\n<line2>int nLoop;                /* Number of terms in the join */\n<line3>Parse *pParse;            /* Parsing context */\n<line4>int iLoop;                /* Loop counter over the terms of the join */\n<line5>int ii, jj;               /* Loop counters */\n<line6>int mxI = 0;              /* Index of next entry to replace */\n<line7>int nOrderBy;             /* Number of ORDER BY clause terms */\n<line8>LogEst mxCost = 0;        /* Maximum cost of a set of paths */\n<line9>LogEst mxUnsort = 0;      /* Maximum unsorted cost of a set of path */\n<line10>int nTo, nFrom;           /* Number of valid entries in aTo[] and aFrom[] */\n<line11>WherePath *aFrom;         /* All nFrom paths at the previous level */\n<line12>WherePath *aTo;           /* The nTo best paths at the current level */\n<line13>WherePath *pFrom;         /* An element of aFrom[] that we are working on */\n<line14>WherePath *pTo;           /* An element of aTo[] that we are working on */\n<line15>WhereLoop *pWLoop;        /* One of the WhereLoop objects */\n<line16>WhereLoop **pX;           /* Used to divy up the pSpace memory */\n<line17>LogEst *aSortCost = 0;    /* Sorting and partial sorting costs */\n<line18>char *pSpace;             /* Temporary memory used by this routine */\n<line19>int nSpace;               /* Bytes of space allocated at pSpace */\n<line20>pParse = pWInfo->pParse;\n<line21>nLoop = pWInfo->nLevel;\n<line22>WHERETRACE(0x002, ("---- begin solver.  (nRowEst=%d, nQueryLoop=%d)\n",\n<line23>nRowEst, pParse->nQueryLoop));\n<line24>/* TUNING: mxChoice is the maximum number of possible paths to preserve\n<line25>** at each step.  Based on the number of loops in the FROM clause:\n<line26>**\n<line27>**     nLoop      mxChoice\n<line28>**     -----      --------\n<line29>**       1            1            // the most common case\n<line30>**       2            5\n<line31>**       3+        12 or 18        // see computeMxChoice()\n<line32>*/\n<line33>if( nLoop<=1 ){\n<line34>mxChoice = 1;\n<line35>}else if( nLoop==2 ){\n<line36>mxChoice = 5;\n<line37>}else if( pParse->nErr ){\n<line38>mxChoice = 1;\n<line39>}else{\n<line40>mxChoice = computeMxChoice(pWInfo);\n<line41>}\n<line42>assert( nLoop<=pWInfo->pTabList->nSrc );\n<line43>/* If nRowEst is zero and there is an ORDER BY clause, ignore it. In this\n<line44>** case the purpose of this call is to estimate the number of rows returned\n<line45>** by the overall query. Once this estimate has been obtained, the caller\n<line46>** will invoke this function a second time, passing the estimate as the\n<line47>** nRowEst parameter.  */\n<line48>if( pWInfo->pOrderBy==0 || nRowEst==0 ){\n<line49>nOrderBy = 0;\n<line50>}else{\n<line51>nOrderBy = pWInfo->pOrderBy->nExpr;\n<line52>}\n<line53>/* Allocate and initialize space for aTo, aFrom and aSortCost[] */\n<line54>nSpace = (sizeof(WherePath)+sizeof(WhereLoop*)*nLoop)*mxChoice*2;\n<line55>nSpace += sizeof(LogEst) * nOrderBy;\n<line56>pSpace = sqlite3StackAllocRawNN(pParse->db, nSpace);\n<line57>if( pSpace==0 ) return SQLITE_NOMEM_BKPT;\n<line58>aTo = (WherePath*)pSpace;\n<line59>aFrom = aTo+mxChoice;\n<line60>memset(aFrom, 0, sizeof(aFrom[0]));\n<line61>pX = (WhereLoop**)(aFrom+mxChoice);\n<line62>for(ii=mxChoice*2, pFrom=aTo; ii>0; ii--, pFrom++, pX += nLoop){\n<line63>pFrom->aLoop = pX;\n<line64>}\n<line65>if( nOrderBy ){\n<line66>/* If there is an ORDER BY clause and it is not being ignored, set up\n<line67>** space for the aSortCost[] array. Each element of the aSortCost array\n<line68>** is either zero - meaning it has not yet been initialized - or the\n<line69>** cost of sorting nRowEst rows of data where the first X terms of\n<line70>** the ORDER BY clause are already in order, where X is the array\n<line71>** index.  */\n<line72>aSortCost = (LogEst*)pX;\n<line73>memset(aSortCost, 0, sizeof(LogEst) * nOrderBy);\n<line74>}\n<line75>assert( aSortCost==0 || &pSpace[nSpace]==(char*)&aSortCost[nOrderBy] );\n<line76>assert( aSortCost!=0 || &pSpace[nSpace]==(char*)pX );\n<line77>/* Seed the search with a single WherePath containing zero WhereLoops.\n<line78>**\n<line79>** TUNING: Do not let the number of iterations go above 28.  If the cost\n<line80>** of computing an automatic index is not paid back within the first 28\n<line81>** rows, then do not use the automatic index. */\n<line82>aFrom[0].nRow = MIN(pParse->nQueryLoop, 48);  assert( 48==sqlite3LogEst(28) );\n<line83>nFrom = 1;\n<line84>assert( aFrom[0].isOrdered==0 );\n<line85>if( nOrderBy ){\n<line86>/* If nLoop is zero, then there are no FROM terms in the query. Since\n<line87>** in this case the query may return a maximum of one row, the results\n<line88>** are already in the requested order. Set isOrdered to nOrderBy to\n<line89>** indicate this. Or, if nLoop is greater than zero, set isOrdered to\n<line90>** -1, indicating that the result set may or may not be ordered,\n<line91>** depending on the loops added to the current plan.  */\n<line92>aFrom[0].isOrdered = nLoop>0 ? -1 : nOrderBy;\n<line93>}\n<line94>/* Compute successively longer WherePaths using the previous generation\n<line95>** of WherePaths as the basis for the next.  Keep track of the mxChoice\n<line96>** best paths at each generation */\n<line97>for(iLoop=0; iLoop<nLoop; iLoop++){\n<line98>nTo = 0;\n<line99>for(ii=0, pFrom=aFrom; ii<nFrom; ii++, pFrom++){\n<line100>for(pWLoop=pWInfo->pLoops; pWLoop; pWLoop=pWLoop->pNextLoop){\n<line101>LogEst nOut;                      /* Rows visited by (pFrom+pWLoop) */\n<line102>LogEst rCost;                     /* Cost of path (pFrom+pWLoop) */\n<line103>LogEst rUnsort;                   /* Unsorted cost of (pFrom+pWLoop) */\n<line104>i8 isOrdered;                     /* isOrdered for (pFrom+pWLoop) */\n<line105>Bitmask maskNew;                  /* Mask of src visited by (..) */\n<line106>Bitmask revMask;                  /* Mask of rev-order loops for (..) */\n<line107>if( (pWLoop->prereq & ~pFrom->maskLoop)!=0 ) continue;\n<line108>if( (pWLoop->maskSelf & pFrom->maskLoop)!=0 ) continue;\n<line109>if( (pWLoop->wsFlags & WHERE_AUTO_INDEX)!=0 && pFrom->nRow<3 ){\n<line110>/* Do not use an automatic index if the this loop is expected\n<line111>** to run less than 1.25 times.  It is tempting to also exclude\n<line112>** automatic index usage on an outer loop, but sometimes an automatic\n<line113>** index is useful in the outer loop of a correlated subquery. */\n<line114>assert( 10==sqlite3LogEst(2) );\n<line115>continue;\n<line116>}\n<line117>/* At this point, pWLoop is a candidate to be the next loop.\n<line118>** Compute its cost */\n<line119>rUnsort = pWLoop->rRun + pFrom->nRow;\n<line120>if( pWLoop->rSetup ){\n<line121>rUnsort = sqlite3LogEstAdd(pWLoop->rSetup, rUnsort);\n<line122>}\n<line123>rUnsort = sqlite3LogEstAdd(rUnsort, pFrom->rUnsort);\n<line124>nOut = pFrom->nRow + pWLoop->nOut;\n<line125>maskNew = pFrom->maskLoop | pWLoop->maskSelf;\n<line126>isOrdered = pFrom->isOrdered;\n<line127>if( isOrdered<0 ){\n<line128>revMask = 0;\n<line129>isOrdered = wherePathSatisfiesOrderBy(pWInfo,\n<line130>pWInfo->pOrderBy, pFrom, pWInfo->wctrlFlags,\n<line131>iLoop, pWLoop, &revMask);\n<line132>}else{\n<line133>revMask = pFrom->revLoop;\n<line134>}\n<line135>if( isOrdered>=0 && isOrdered<nOrderBy ){\n<line136>if( aSortCost[isOrdered]==0 ){\n<line137>aSortCost[isOrdered] = whereSortingCost(\n<line138>pWInfo, nRowEst, nOrderBy, isOrdered\n<line139>);\n<line140>}\n<line141>/* TUNING:  Add a small extra penalty (3) to sorting as an\n<line142>** extra encouragement to the query planner to select a plan\n<line143>** where the rows emerge in the correct order without any sorting\n<line144>** required. */\n<line145>rCost = sqlite3LogEstAdd(rUnsort, aSortCost[isOrdered]) + 3;\n<line146>WHERETRACE(0x002,\n<line147>("---- sort cost=%-3d (%d/%d) increases cost %3d to %-3d\n",\n<line148>aSortCost[isOrdered], (nOrderBy-isOrdered), nOrderBy,\n<line149>rUnsort, rCost));\n<line150>}else{\n<line151>rCost = rUnsort;\n<line152>rUnsort -= 2;  /* TUNING:  Slight bias in favor of no-sort plans */\n<line153>}\n<line154>/* Check to see if pWLoop should be added to the set of\n<line155>** mxChoice best-so-far paths.\n<line156>**\n<line157>** First look for an existing path among best-so-far paths\n<line158>** that:\n<line159>**     (1) covers the same set of loops, and\n<line160>**     (2) has a compatible isOrdered value.\n<line161>**\n<line162>** "Compatible isOrdered value" means either\n<line163>**     (A) both have isOrdered==-1, or\n<line164>**     (B) both have isOrder>=0, or\n<line165>**     (C) ordering does not matter because this is the last round\n<line166>**         of the solver.\n<line167>**\n<line168>** The term "((pTo->isOrdered^isOrdered)&0x80)==0" is equivalent\n<line169>** to (pTo->isOrdered==(-1))==(isOrdered==(-1))" for the range\n<line170>** of legal values for isOrdered, -1..64.\n<line171>*/\n<line172>testcase( nTo==0 );\n<line173>for(jj=0, pTo=aTo; jj<nTo; jj++, pTo++){\n<line174>if( pTo->maskLoop==maskNew\n<line175>&& ( ((pTo->isOrdered^isOrdered)&0x80)==0 || iLoop==nLoop-1 )\n<line176>){\n<line177>testcase( jj==nTo-1 );\n<line178>break;\n<line179>}\n<line180>}\n<line181>if( jj>=nTo ){\n<line182>/* None of the existing best-so-far paths match the candidate. */\n<line183>if( nTo>=mxChoice\n<line184>&& (rCost>mxCost || (rCost==mxCost && rUnsort>=mxUnsort))\n<line185>){\n<line186>/* The current candidate is no better than any of the mxChoice\n<line187>** paths currently in the best-so-far buffer.  So discard\n<line188>** this candidate as not viable. */\n<line189>#ifdef WHERETRACE_ENABLED /* 0x4 */\n<line190>if( sqlite3WhereTrace&0x4 ){\n<line191>sqlite3DebugPrintf("Skip   %s cost=%-3d,%3d,%3d order=%c\n",\n<line192>wherePathName(pFrom, iLoop, pWLoop), rCost, nOut, rUnsort,\n<line193>isOrdered>=0 ? isOrdered+'0' : '?');\n<line194>}\n<line195>#endif\n<line196>continue;\n<line197>}\n<line198>/* If we reach this points it means that the new candidate path\n<line199>** needs to be added to the set of best-so-far paths. */\n<line200>if( nTo<mxChoice ){\n<line201>/* Increase the size of the aTo set by one */\n<line202>jj = nTo++;\n<line203>}else{\n<line204>/* New path replaces the prior worst to keep count below mxChoice */\n<line205>jj = mxI;\n<line206>}\n<line207>pTo = &aTo[jj];\n<line208>#ifdef WHERETRACE_ENABLED /* 0x4 */\n<line209>if( sqlite3WhereTrace&0x4 ){\n<line210>sqlite3DebugPrintf("New    %s cost=%-3d,%3d,%3d order=%c\n",\n<line211>wherePathName(pFrom, iLoop, pWLoop), rCost, nOut, rUnsort,\n<line212>isOrdered>=0 ? isOrdered+'0' : '?');\n<line213>}\n<line214>#endif\n<line215>}else{\n<line216>/* Control reaches here if best-so-far path pTo=aTo[jj] covers the\n<line217>** same set of loops and has the same isOrdered setting as the\n<line218>** candidate path.  Check to see if the candidate should replace\n<line219>** pTo or if the candidate should be skipped.\n<line220>**\n<line221>** The conditional is an expanded vector comparison equivalent to:\n<line222>**   (pTo->rCost,pTo->nRow,pTo->rUnsort) <= (rCost,nOut,rUnsort)\n<line223>*/\n<line224>if( (pTo->rCost<rCost)\n<line225>|| (pTo->rCost==rCost && pTo->nRow<nOut)\n<line226>|| (pTo->rCost==rCost && pTo->nRow==nOut && pTo->rUnsort<rUnsort)\n<line227>|| (pTo->rCost==rCost && pTo->nRow==nOut && pTo->rUnsort==rUnsort\n<line228>&& whereLoopIsNoBetter(pWLoop, pTo->aLoop[iLoop]) )\n<line229>){\n<line230>#ifdef WHERETRACE_ENABLED /* 0x4 */\n<line231>if( sqlite3WhereTrace&0x4 ){\n<line232>sqlite3DebugPrintf(\n<line233>"Skip   %s cost=%-3d,%3d,%3d order=%c",\n<line234>wherePathName(pFrom, iLoop, pWLoop), rCost, nOut, rUnsort,\n<line235>isOrdered>=0 ? isOrdered+'0' : '?');\n<line236>sqlite3DebugPrintf("   vs %s cost=%-3d,%3d,%3d order=%c\n",\n<line237>wherePathName(pTo, iLoop+1, 0), pTo->rCost, pTo->nRow,\n<line238>pTo->rUnsort, pTo->isOrdered>=0 ? pTo->isOrdered+'0' : '?');\n<line239>}\n<line240>#endif\n<line241>/* Discard the candidate path from further consideration */\n<line242>testcase( pTo->rCost==rCost );\n<line243>continue;\n<line244>}\n<line245>testcase( pTo->rCost==rCost+1 );\n<line246>/* Control reaches here if the candidate path is better than the\n<line247>** pTo path.  Replace pTo with the candidate. */\n<line248>#ifdef WHERETRACE_ENABLED /* 0x4 */\n<line249>if( sqlite3WhereTrace&0x4 ){\n<line250>sqlite3DebugPrintf(\n<line251>"Update %s cost=%-3d,%3d,%3d order=%c",\n<line252>wherePathName(pFrom, iLoop, pWLoop), rCost, nOut, rUnsort,\n<line253>isOrdered>=0 ? isOrdered+'0' : '?');\n<line254>sqlite3DebugPrintf("  was %s cost=%-3d,%3d,%3d order=%c\n",\n<line255>wherePathName(pTo, iLoop+1, 0), pTo->rCost, pTo->nRow,\n<line256>pTo->rUnsort, pTo->isOrdered>=0 ? pTo->isOrdered+'0' : '?');\n<line257>}\n<line258>#endif\n<line259>}\n<line260>/* pWLoop is a winner.  Add it to the set of best so far */\n<line261>pTo->maskLoop = pFrom->maskLoop | pWLoop->maskSelf;\n<line262>pTo->revLoop = revMask;\n<line263>pTo->nRow = nOut;\n<line264>pTo->rCost = rCost;\n<line265>pTo->rUnsort = rUnsort;\n<line266>pTo->isOrdered = isOrdered;\n<line267>memcpy(pTo->aLoop, pFrom->aLoop, sizeof(WhereLoop*)*iLoop);\n<line268>pTo->aLoop[iLoop] = pWLoop;\n<line269>if( nTo>=mxChoice ){\n<line270>mxI = 0;\n<line271>mxCost = aTo[0].rCost;\n<line272>mxUnsort = aTo[0].nRow;\n<line273>for(jj=1, pTo=&aTo[1]; jj<mxChoice; jj++, pTo++){\n<line274>if( pTo->rCost>mxCost\n<line275>|| (pTo->rCost==mxCost && pTo->rUnsort>mxUnsort)\n<line276>){\n<line277>mxCost = pTo->rCost;\n<line278>mxUnsort = pTo->rUnsort;\n<line279>mxI = jj;\n<line280>}\n<line281>}\n<line282>}\n<line283>}\n<line284>}\n<line285>#ifdef WHERETRACE_ENABLED  /* >=2 */\n<line286>if( sqlite3WhereTrace & 0x02 ){\n<line287>LogEst rMin, rFloor = 0;\n<line288>int nDone = 0;\n<line289>int nProgress;\n<line290>sqlite3DebugPrintf("---- after round %d ----\n", iLoop);\n<line291>do{\n<line292>nProgress = 0;\n<line293>rMin = 0x7fff;\n<line294>for(ii=0, pTo=aTo; ii<nTo; ii++, pTo++){\n<line295>if( pTo->rCost>rFloor && pTo->rCost<rMin ) rMin = pTo->rCost;\n<line296>}\n<line297>for(ii=0, pTo=aTo; ii<nTo; ii++, pTo++){\n<line298>if( pTo->rCost==rMin ){\n<line299>sqlite3DebugPrintf(" %s cost=%-3d nrow=%-3d order=%c",\n<line300>wherePathName(pTo, iLoop+1, 0), pTo->rCost, pTo->nRow,\n<line301>pTo->isOrdered>=0 ? (pTo->isOrdered+'0') : '?');\n<line302>if( pTo->isOrdered>0 ){\n<line303>sqlite3DebugPrintf(" rev=0x%llx\n", pTo->revLoop);\n<line304>}else{\n<line305>sqlite3DebugPrintf("\n");\n<line306>}\n<line307>nDone++;\n<line308>nProgress++;\n<line309>}\n<line310>}\n<line311>rFloor = rMin;\n<line312>}while( nDone<nTo && nProgress>0 );\n<line313>}\n<line314>#endif\n<line315>/* Swap the roles of aFrom and aTo for the next generation */\n<line316>pFrom = aTo;\n<line317>aTo = aFrom;\n<line318>aFrom = pFrom;\n<line319>nFrom = nTo;\n<line320>}\n<line321>if( nFrom==0 ){\n<line322>sqlite3ErrorMsg(pParse, "no query solution");\n<line323>sqlite3StackFreeNN(pParse->db, pSpace);\n<line324>return SQLITE_ERROR;\n<line325>}\n<line326>/* Only one path is available, which is the best path */\n<line327>assert( nFrom==1 );\n<line328>pFrom = aFrom;\n<line329>assert( pWInfo->nLevel==nLoop );\n<line330>/* Load the lowest cost path into pWInfo */\n<line331>for(iLoop=0; iLoop<nLoop; iLoop++){\n<line332>WhereLevel *pLevel = pWInfo->a + iLoop;\n<line333>pLevel->pWLoop = pWLoop = pFrom->aLoop[iLoop];\n<line334>pLevel->iFrom = pWLoop->iTab;\n<line335>pLevel->iTabCur = pWInfo->pTabList->a[pLevel->iFrom].iCursor;\n<line336>}\n<line337>if( (pWInfo->wctrlFlags & WHERE_WANT_DISTINCT)!=0\n<line338>&& (pWInfo->wctrlFlags & WHERE_DISTINCTBY)==0\n<line339>&& pWInfo->eDistinct==WHERE_DISTINCT_NOOP\n<line340>&& nRowEst\n<line341>){\n<line342>Bitmask notUsed;\n<line343>int rc = wherePathSatisfiesOrderBy(pWInfo, pWInfo->pResultSet, pFrom,\n<line344>WHERE_DISTINCTBY, nLoop-1, pFrom->aLoop[nLoop-1], &notUsed);\n<line345>if( rc==pWInfo->pResultSet->nExpr ){\n<line346>pWInfo->eDistinct = WHERE_DISTINCT_ORDERED;\n<line347>}\n<line348>}\n<line349>pWInfo->bOrderedInnerLoop = 0;\n<line350>if( pWInfo->pOrderBy ){\n<line351>pWInfo->nOBSat = pFrom->isOrdered;\n<line352>if( pWInfo->wctrlFlags & WHERE_DISTINCTBY ){\n<line353>if( pFrom->isOrdered==pWInfo->pOrderBy->nExpr ){\n<line354>pWInfo->eDistinct = WHERE_DISTINCT_ORDERED;\n<line355>}\n<line356>/* vvv--- See check-in [12ad822d9b827777] on 2023-03-16 ---vvv */\n<line357>assert( pWInfo->pSelect->pOrderBy==0\n<line358>|| pWInfo->nOBSat <= pWInfo->pSelect->pOrderBy->nExpr );\n<line359>}else{\n<line360>pWInfo->revMask = pFrom->revLoop;\n<line361>if( pWInfo->nOBSat<=0 ){\n<line362>pWInfo->nOBSat = 0;\n<line363>if( nLoop>0 ){\n<line364>u32 wsFlags = pFrom->aLoop[nLoop-1]->wsFlags;\n<line365>if( (wsFlags & WHERE_ONEROW)==0\n<line366>&& (wsFlags&(WHERE_IPK|WHERE_COLUMN_IN))!=(WHERE_IPK|WHERE_COLUMN_IN)\n<line367>){\n<line368>Bitmask m = 0;\n<line369>int rc = wherePathSatisfiesOrderBy(pWInfo, pWInfo->pOrderBy, pFrom,\n<line370>WHERE_ORDERBY_LIMIT, nLoop-1, pFrom->aLoop[nLoop-1], &m);\n<line371>testcase( wsFlags & WHERE_IPK );\n<line372>testcase( wsFlags & WHERE_COLUMN_IN );\n<line373>if( rc==pWInfo->pOrderBy->nExpr ){\n<line374>pWInfo->bOrderedInnerLoop = 1;\n<line375>pWInfo->revMask = m;\n<line376>}\n<line377>}\n<line378>}\n<line379>}else if( nLoop\n<line380>&& pWInfo->nOBSat==1\n<line381>&& (pWInfo->wctrlFlags & (WHERE_ORDERBY_MIN|WHERE_ORDERBY_MAX))!=0\n<line382>){\n<line383>pWInfo->bOrderedInnerLoop = 1;\n<line384>}\n<line385>}\n<line386>if( (pWInfo->wctrlFlags & WHERE_SORTBYGROUP)\n<line387>&& pWInfo->nOBSat==pWInfo->pOrderBy->nExpr && nLoop>0\n<line388>){\n<line389>Bitmask revMask = 0;\n<line390>int nOrder = wherePathSatisfiesOrderBy(pWInfo, pWInfo->pOrderBy,\n<line391>pFrom, 0, nLoop-1, pFrom->aLoop[nLoop-1], &revMask\n<line392>);\n<line393>assert( pWInfo->sorted==0 );\n<line394>if( nOrder==pWInfo->pOrderBy->nExpr ){\n<line395>pWInfo->sorted = 1;\n<line396>pWInfo->revMask = revMask;\n<line397>}\n<line398>}\n<line399>}\n<line400>pWInfo->nRowOut = pFrom->nRow;\n<line401>#ifdef WHERETRACE_ENABLED\n<line402>pWInfo->rTotalCost = pFrom->rCost;\n<line403>#endif\n<line404>/* Free temporary memory and return success */\n<line405>sqlite3StackFreeNN(pParse->db, pSpace);\n<line406>return SQLITE_OK;\n<line407>}
----------------------------------------
Function: whereInterstageHeuristic
Content: <line0>static SQLITE_NOINLINE void whereInterstageHeuristic(WhereInfo *pWInfo){\n<line1>int i;\n<line2>#ifdef WHERETRACE_ENABLED\n<line3>int once = 0;\n<line4>#endif\n<line5>for(i=0; i<pWInfo->nLevel; i++){\n<line6>WhereLoop *p = pWInfo->a[i].pWLoop;\n<line7>if( p==0 ) break;\n<line8>if( (p->wsFlags & WHERE_VIRTUALTABLE)!=0 ){\n<line9>/* Treat a vtab scan as similar to a full-table scan */\n<line10>break;\n<line11>}\n<line12>if( (p->wsFlags & (WHERE_COLUMN_EQ|WHERE_COLUMN_NULL|WHERE_COLUMN_IN))!=0 ){\n<line13>u8 iTab = p->iTab;\n<line14>WhereLoop *pLoop;\n<line15>for(pLoop=pWInfo->pLoops; pLoop; pLoop=pLoop->pNextLoop){\n<line16>if( pLoop->iTab!=iTab ) continue;\n<line17>if( (pLoop->wsFlags & (WHERE_CONSTRAINT|WHERE_AUTO_INDEX))!=0 ){\n<line18>/* Auto-index and index-constrained loops allowed to remain */\n<line19>continue;\n<line20>}\n<line21>#ifdef WHERETRACE_ENABLED\n<line22>if( sqlite3WhereTrace & 0x80 ){\n<line23>if( once==0 ){\n<line24>sqlite3DebugPrintf("Loops disabled by interstage heuristic:\n");\n<line25>once = 1;\n<line26>}\n<line27>sqlite3WhereLoopPrint(pLoop, &pWInfo->sWC);\n<line28>}\n<line29>#endif /* WHERETRACE_ENABLED */\n<line30>pLoop->prereq = ALLBITS;  /* Prevent 2nd solver() from using this one */\n<line31>}\n<line32>}else{\n<line33>break;\n<line34>}\n<line35>}\n<line36>}
----------------------------------------
Function: whereShortCut
Content: <line0>static int whereShortCut(WhereLoopBuilder *pBuilder){\n<line1>WhereInfo *pWInfo;\n<line2>SrcItem *pItem;\n<line3>WhereClause *pWC;\n<line4>WhereTerm *pTerm;\n<line5>WhereLoop *pLoop;\n<line6>int iCur;\n<line7>int j;\n<line8>Table *pTab;\n<line9>Index *pIdx;\n<line10>WhereScan scan;\n<line11>pWInfo = pBuilder->pWInfo;\n<line12>if( pWInfo->wctrlFlags & WHERE_OR_SUBCLAUSE ) return 0;\n<line13>assert( pWInfo->pTabList->nSrc>=1 );\n<line14>pItem = pWInfo->pTabList->a;\n<line15>pTab = pItem->pSTab;\n<line16>if( IsVirtual(pTab) ) return 0;\n<line17>if( pItem->fg.isIndexedBy || pItem->fg.notIndexed ){\n<line18>testcase( pItem->fg.isIndexedBy );\n<line19>testcase( pItem->fg.notIndexed );\n<line20>return 0;\n<line21>}\n<line22>iCur = pItem->iCursor;\n<line23>pWC = &pWInfo->sWC;\n<line24>pLoop = pBuilder->pNew;\n<line25>pLoop->wsFlags = 0;\n<line26>pLoop->nSkip = 0;\n<line27>pTerm = whereScanInit(&scan, pWC, iCur, -1, WO_EQ|WO_IS, 0);\n<line28>while( pTerm && pTerm->prereqRight ) pTerm = whereScanNext(&scan);\n<line29>if( pTerm ){\n<line30>testcase( pTerm->eOperator & WO_IS );\n<line31>pLoop->wsFlags = WHERE_COLUMN_EQ|WHERE_IPK|WHERE_ONEROW;\n<line32>pLoop->aLTerm[0] = pTerm;\n<line33>pLoop->nLTerm = 1;\n<line34>pLoop->u.btree.nEq = 1;\n<line35>/* TUNING: Cost of a rowid lookup is 10 */\n<line36>pLoop->rRun = 33;  /* 33==sqlite3LogEst(10) */\n<line37>}else{\n<line38>for(pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext){\n<line39>int opMask;\n<line40>assert( pLoop->aLTermSpace==pLoop->aLTerm );\n<line41>if( !IsUniqueIndex(pIdx)\n<line42>|| pIdx->pPartIdxWhere!=0\n<line43>|| pIdx->nKeyCol>ArraySize(pLoop->aLTermSpace)\n<line44>) continue;\n<line45>opMask = pIdx->uniqNotNull ? (WO_EQ|WO_IS) : WO_EQ;\n<line46>for(j=0; j<pIdx->nKeyCol; j++){\n<line47>pTerm = whereScanInit(&scan, pWC, iCur, j, opMask, pIdx);\n<line48>while( pTerm && pTerm->prereqRight ) pTerm = whereScanNext(&scan);\n<line49>if( pTerm==0 ) break;\n<line50>testcase( pTerm->eOperator & WO_IS );\n<line51>pLoop->aLTerm[j] = pTerm;\n<line52>}\n<line53>if( j!=pIdx->nKeyCol ) continue;\n<line54>pLoop->wsFlags = WHERE_COLUMN_EQ|WHERE_ONEROW|WHERE_INDEXED;\n<line55>if( pIdx->isCovering || (pItem->colUsed & pIdx->colNotIdxed)==0 ){\n<line56>pLoop->wsFlags |= WHERE_IDX_ONLY;\n<line57>}\n<line58>pLoop->nLTerm = j;\n<line59>pLoop->u.btree.nEq = j;\n<line60>pLoop->u.btree.pIndex = pIdx;\n<line61>/* TUNING: Cost of a unique index lookup is 15 */\n<line62>pLoop->rRun = 39;  /* 39==sqlite3LogEst(15) */\n<line63>break;\n<line64>}\n<line65>}\n<line66>if( pLoop->wsFlags ){\n<line67>pLoop->nOut = (LogEst)1;\n<line68>pWInfo->a[0].pWLoop = pLoop;\n<line69>assert( pWInfo->sMaskSet.n==1 && iCur==pWInfo->sMaskSet.ix[0] );\n<line70>pLoop->maskSelf = 1; /* sqlite3WhereGetMask(&pWInfo->sMaskSet, iCur); */\n<line71>pWInfo->a[0].iTabCur = iCur;\n<line72>pWInfo->nRowOut = 1;\n<line73>if( pWInfo->pOrderBy ) pWInfo->nOBSat =  pWInfo->pOrderBy->nExpr;\n<line74>if( pWInfo->wctrlFlags & WHERE_WANT_DISTINCT ){\n<line75>pWInfo->eDistinct = WHERE_DISTINCT_UNIQUE;\n<line76>}\n<line77>if( scan.iEquiv>1 ) pLoop->wsFlags |= WHERE_TRANSCONS;\n<line78>#ifdef SQLITE_DEBUG\n<line79>pLoop->cId = '0';\n<line80>#endif\n<line81>#ifdef WHERETRACE_ENABLED\n<line82>if( sqlite3WhereTrace & 0x02 ){\n<line83>sqlite3DebugPrintf("whereShortCut() used to compute solution\n");\n<line84>}\n<line85>#endif\n<line86>return 1;\n<line87>}\n<line88>return 0;\n<line89>}
----------------------------------------
Function: exprNodeIsDeterministic
Content: <line0>static int exprNodeIsDeterministic(Walker *pWalker, Expr *pExpr){\n<line1>if( pExpr->op==TK_FUNCTION && ExprHasProperty(pExpr, EP_ConstFunc)==0 ){\n<line2>pWalker->eCode = 0;\n<line3>return WRC_Abort;\n<line4>}\n<line5>return WRC_Continue;\n<line6>}
----------------------------------------
Function: exprIsDeterministic
Content: <line0>static int exprIsDeterministic(Expr *p){\n<line1>Walker w;\n<line2>memset(&w, 0, sizeof(w));\n<line3>w.eCode = 1;\n<line4>w.xExprCallback = exprNodeIsDeterministic;\n<line5>w.xSelectCallback = sqlite3SelectWalkFail;\n<line6>sqlite3WalkExpr(&w, p);\n<line7>return w.eCode;\n<line8>}
----------------------------------------
Function: whereOmitNoopJoin
Content: <line0>static SQLITE_NOINLINE Bitmask whereOmitNoopJoin(\n<line1>WhereInfo *pWInfo,\n<line2>Bitmask notReady\n<line3>){\n<line4>int i;\n<line5>Bitmask tabUsed;\n<line6>int hasRightJoin;\n<line7>/* Preconditions checked by the caller */\n<line8>assert( pWInfo->nLevel>=2 );\n<line9>assert( OptimizationEnabled(pWInfo->pParse->db, SQLITE_OmitNoopJoin) );\n<line10>/* These two preconditions checked by the caller combine to guarantee\n<line11>** condition (1) of the header comment */\n<line12>assert( pWInfo->pResultSet!=0 );\n<line13>assert( 0==(pWInfo->wctrlFlags & WHERE_AGG_DISTINCT) );\n<line14>tabUsed = sqlite3WhereExprListUsage(&pWInfo->sMaskSet, pWInfo->pResultSet);\n<line15>if( pWInfo->pOrderBy ){\n<line16>tabUsed |= sqlite3WhereExprListUsage(&pWInfo->sMaskSet, pWInfo->pOrderBy);\n<line17>}\n<line18>hasRightJoin = (pWInfo->pTabList->a[0].fg.jointype & JT_LTORJ)!=0;\n<line19>for(i=pWInfo->nLevel-1; i>=1; i--){\n<line20>WhereTerm *pTerm, *pEnd;\n<line21>SrcItem *pItem;\n<line22>WhereLoop *pLoop;\n<line23>Bitmask m1;\n<line24>pLoop = pWInfo->a[i].pWLoop;\n<line25>pItem = &pWInfo->pTabList->a[pLoop->iTab];\n<line26>if( (pItem->fg.jointype & (JT_LEFT|JT_RIGHT))!=JT_LEFT ) continue;\n<line27>if( (pWInfo->wctrlFlags & WHERE_WANT_DISTINCT)==0\n<line28>&& (pLoop->wsFlags & WHERE_ONEROW)==0\n<line29>){\n<line30>continue;\n<line31>}\n<line32>if( (tabUsed & pLoop->maskSelf)!=0 ) continue;\n<line33>pEnd = pWInfo->sWC.a + pWInfo->sWC.nTerm;\n<line34>for(pTerm=pWInfo->sWC.a; pTerm<pEnd; pTerm++){\n<line35>if( (pTerm->prereqAll & pLoop->maskSelf)!=0 ){\n<line36>if( !ExprHasProperty(pTerm->pExpr, EP_OuterON)\n<line37>|| pTerm->pExpr->w.iJoin!=pItem->iCursor\n<line38>){\n<line39>break;\n<line40>}\n<line41>}\n<line42>if( hasRightJoin\n<line43>&& ExprHasProperty(pTerm->pExpr, EP_InnerON)\n<line44>&& NEVER(pTerm->pExpr->w.iJoin==pItem->iCursor)\n<line45>){\n<line46>break;  /* restriction (5) */\n<line47>}\n<line48>}\n<line49>if( pTerm<pEnd ) continue;\n<line50>WHERETRACE(0xffffffff,("-> omit unused FROM-clause term %c\n",pLoop->cId));\n<line51>m1 = MASKBIT(i)-1;\n<line52>testcase( ((pWInfo->revMask>>1) & ~m1)!=0 );\n<line53>pWInfo->revMask = (m1 & pWInfo->revMask) | ((pWInfo->revMask>>1) & ~m1);\n<line54>notReady &= ~pLoop->maskSelf;\n<line55>for(pTerm=pWInfo->sWC.a; pTerm<pEnd; pTerm++){\n<line56>if( (pTerm->prereqAll & pLoop->maskSelf)!=0 ){\n<line57>pTerm->wtFlags |= TERM_CODED;\n<line58>}\n<line59>}\n<line60>if( i!=pWInfo->nLevel-1 ){\n<line61>int nByte = (pWInfo->nLevel-1-i) * sizeof(WhereLevel);\n<line62>memmove(&pWInfo->a[i], &pWInfo->a[i+1], nByte);\n<line63>}\n<line64>pWInfo->nLevel--;\n<line65>assert( pWInfo->nLevel>0 );\n<line66>}\n<line67>return notReady;\n<line68>}
----------------------------------------
Function: whereCheckIfBloomFilterIsUseful
Content: <line0>static SQLITE_NOINLINE void whereCheckIfBloomFilterIsUseful(\n<line1>const WhereInfo *pWInfo\n<line2>){\n<line3>int i;\n<line4>LogEst nSearch = 0;\n<line5>assert( pWInfo->nLevel>=2 );\n<line6>assert( OptimizationEnabled(pWInfo->pParse->db, SQLITE_BloomFilter) );\n<line7>for(i=0; i<pWInfo->nLevel; i++){\n<line8>WhereLoop *pLoop = pWInfo->a[i].pWLoop;\n<line9>const unsigned int reqFlags = (WHERE_SELFCULL|WHERE_COLUMN_EQ);\n<line10>SrcItem *pItem = &pWInfo->pTabList->a[pLoop->iTab];\n<line11>Table *pTab = pItem->pSTab;\n<line12>if( (pTab->tabFlags & TF_HasStat1)==0 ) break;\n<line13>pTab->tabFlags |= TF_MaybeReanalyze;\n<line14>if( i>=1\n<line15>&& (pLoop->wsFlags & reqFlags)==reqFlags\n<line16>/* vvvvvv--- Always the case if WHERE_COLUMN_EQ is defined */\n<line17>&& ALWAYS((pLoop->wsFlags & (WHERE_IPK|WHERE_INDEXED))!=0)\n<line18>){\n<line19>if( nSearch > pTab->nRowLogEst ){\n<line20>testcase( pItem->fg.jointype & JT_LEFT );\n<line21>pLoop->wsFlags |= WHERE_BLOOMFILTER;\n<line22>pLoop->wsFlags &= ~WHERE_IDX_ONLY;\n<line23>WHERETRACE(0xffffffff, (\n<line24>"-> use Bloom-filter on loop %c because there are ~%.1e "\n<line25>"lookups into %s which has only ~%.1e rows\n",\n<line26>pLoop->cId, (double)sqlite3LogEstToInt(nSearch), pTab->zName,\n<line27>(double)sqlite3LogEstToInt(pTab->nRowLogEst)));\n<line28>}\n<line29>}\n<line30>nSearch += pLoop->nOut;\n<line31>}\n<line32>}
----------------------------------------
Function: whereAddIndexedExpr
Content: <line0>static SQLITE_NOINLINE void whereAddIndexedExpr(\n<line1>Parse *pParse,     /* Add IndexedExpr entries to pParse->pIdxEpr */\n<line2>Index *pIdx,       /* The index-on-expression that contains the expressions */\n<line3>int iIdxCur,       /* Cursor number for pIdx */\n<line4>SrcItem *pTabItem  /* The FROM clause entry for the table */\n<line5>){\n<line6>int i;\n<line7>IndexedExpr *p;\n<line8>Table *pTab;\n<line9>assert( pIdx->bHasExpr );\n<line10>pTab = pIdx->pTable;\n<line11>for(i=0; i<pIdx->nColumn; i++){\n<line12>Expr *pExpr;\n<line13>int j = pIdx->aiColumn[i];\n<line14>if( j==XN_EXPR ){\n<line15>pExpr = pIdx->aColExpr->a[i].pExpr;\n<line16>}else if( j>=0 && (pTab->aCol[j].colFlags & COLFLAG_VIRTUAL)!=0 ){\n<line17>pExpr = sqlite3ColumnExpr(pTab, &pTab->aCol[j]);\n<line18>}else{\n<line19>continue;\n<line20>}\n<line21>if( sqlite3ExprIsConstant(0,pExpr) ) continue;\n<line22>p = sqlite3DbMallocRaw(pParse->db,  sizeof(IndexedExpr));\n<line23>if( p==0 ) break;\n<line24>p->pIENext = pParse->pIdxEpr;\n<line25>#ifdef WHERETRACE_ENABLED\n<line26>if( sqlite3WhereTrace & 0x200 ){\n<line27>sqlite3DebugPrintf("New pParse->pIdxEpr term {%d,%d}\n", iIdxCur, i);\n<line28>if( sqlite3WhereTrace & 0x5000 ) sqlite3ShowExpr(pExpr);\n<line29>}\n<line30>#endif\n<line31>p->pExpr = sqlite3ExprDup(pParse->db, pExpr, 0);\n<line32>p->iDataCur = pTabItem->iCursor;\n<line33>p->iIdxCur = iIdxCur;\n<line34>p->iIdxCol = i;\n<line35>p->bMaybeNullRow = (pTabItem->fg.jointype & (JT_LEFT|JT_LTORJ|JT_RIGHT))!=0;\n<line36>if( sqlite3IndexAffinityStr(pParse->db, pIdx) ){\n<line37>p->aff = pIdx->zColAff[i];\n<line38>}\n<line39>#ifdef SQLITE_ENABLE_EXPLAIN_COMMENTS\n<line40>p->zIdxName = pIdx->zName;\n<line41>#endif\n<line42>pParse->pIdxEpr = p;\n<line43>if( p->pIENext==0 ){\n<line44>void *pArg = (void*)&pParse->pIdxEpr;\n<line45>sqlite3ParserAddCleanup(pParse, whereIndexedExprCleanup, pArg);\n<line46>}\n<line47>}\n<line48>}
----------------------------------------
Function: whereReverseScanOrder
Content: <line0>static SQLITE_NOINLINE void whereReverseScanOrder(WhereInfo *pWInfo){\n<line1>int ii;\n<line2>for(ii=0; ii<pWInfo->pTabList->nSrc; ii++){\n<line3>SrcItem *pItem = &pWInfo->pTabList->a[ii];\n<line4>if( !pItem->fg.isCte\n<line5>|| pItem->u2.pCteUse->eM10d!=M10d_Yes\n<line6>|| NEVER(pItem->fg.isSubquery==0)\n<line7>|| pItem->u4.pSubq->pSelect->pOrderBy==0\n<line8>){\n<line9>pWInfo->revMask |= MASKBIT(ii);\n<line10>}\n<line11>}\n<line12>}
----------------------------------------
Function: row_numberStepFunc
Content: <line0>static void row_numberStepFunc(\n<line1>sqlite3_context *pCtx,\n<line2>int nArg,\n<line3>sqlite3_value **apArg\n<line4>){\n<line5>i64 *p = (i64*)sqlite3_aggregate_context(pCtx, sizeof(*p));\n<line6>if( p ) (*p)++;\n<line7>UNUSED_PARAMETER(nArg);\n<line8>UNUSED_PARAMETER(apArg);\n<line9>}
----------------------------------------
Function: row_numberValueFunc
Content: <line0>static void row_numberValueFunc(sqlite3_context *pCtx){\n<line1>i64 *p = (i64*)sqlite3_aggregate_context(pCtx, sizeof(*p));\n<line2>sqlite3_result_int64(pCtx, (p ? *p : 0));\n<line3>}
----------------------------------------
Function: dense_rankStepFunc
Content: <line0>static void dense_rankStepFunc(\n<line1>sqlite3_context *pCtx,\n<line2>int nArg,\n<line3>sqlite3_value **apArg\n<line4>){\n<line5>struct CallCount *p;\n<line6>p = (struct CallCount*)sqlite3_aggregate_context(pCtx, sizeof(*p));\n<line7>if( p ) p->nStep = 1;\n<line8>UNUSED_PARAMETER(nArg);\n<line9>UNUSED_PARAMETER(apArg);\n<line10>}
----------------------------------------
Function: dense_rankValueFunc
Content: <line0>static void dense_rankValueFunc(sqlite3_context *pCtx){\n<line1>struct CallCount *p;\n<line2>p = (struct CallCount*)sqlite3_aggregate_context(pCtx, sizeof(*p));\n<line3>if( p ){\n<line4>if( p->nStep ){\n<line5>p->nValue++;\n<line6>p->nStep = 0;\n<line7>}\n<line8>sqlite3_result_int64(pCtx, p->nValue);\n<line9>}\n<line10>}
----------------------------------------
Function: nth_valueStepFunc
Content: <line0>static void nth_valueStepFunc(\n<line1>sqlite3_context *pCtx,\n<line2>int nArg,\n<line3>sqlite3_value **apArg\n<line4>){\n<line5>struct NthValueCtx *p;\n<line6>p = (struct NthValueCtx*)sqlite3_aggregate_context(pCtx, sizeof(*p));\n<line7>if( p ){\n<line8>i64 iVal;\n<line9>switch( sqlite3_value_numeric_type(apArg[1]) ){\n<line10>case SQLITE_INTEGER:\n<line11>iVal = sqlite3_value_int64(apArg[1]);\n<line12>break;\n<line13>case SQLITE_FLOAT: {\n<line14>double fVal = sqlite3_value_double(apArg[1]);\n<line15>if( ((i64)fVal)!=fVal ) goto error_out;\n<line16>iVal = (i64)fVal;\n<line17>break;\n<line18>}\n<line19>default:\n<line20>goto error_out;\n<line21>}\n<line22>if( iVal<=0 ) goto error_out;\n<line23>p->nStep++;\n<line24>if( iVal==p->nStep ){\n<line25>p->pValue = sqlite3_value_dup(apArg[0]);\n<line26>if( !p->pValue ){\n<line27>sqlite3_result_error_nomem(pCtx);\n<line28>}\n<line29>}\n<line30>}\n<line31>UNUSED_PARAMETER(nArg);\n<line32>UNUSED_PARAMETER(apArg);\n<line33>return;\n<line34>error_out:\n<line35>sqlite3_result_error(\n<line36>pCtx, "second argument to nth_value must be a positive integer", -1\n<line37>);\n<line38>}
----------------------------------------
Function: nth_valueFinalizeFunc
Content: <line0>static void nth_valueFinalizeFunc(sqlite3_context *pCtx){\n<line1>struct NthValueCtx *p;\n<line2>p = (struct NthValueCtx*)sqlite3_aggregate_context(pCtx, 0);\n<line3>if( p && p->pValue ){\n<line4>sqlite3_result_value(pCtx, p->pValue);\n<line5>sqlite3_value_free(p->pValue);\n<line6>p->pValue = 0;\n<line7>}\n<line8>}
----------------------------------------
Function: first_valueStepFunc
Content: <line0>static void first_valueStepFunc(\n<line1>sqlite3_context *pCtx,\n<line2>int nArg,\n<line3>sqlite3_value **apArg\n<line4>){\n<line5>struct NthValueCtx *p;\n<line6>p = (struct NthValueCtx*)sqlite3_aggregate_context(pCtx, sizeof(*p));\n<line7>if( p && p->pValue==0 ){\n<line8>p->pValue = sqlite3_value_dup(apArg[0]);\n<line9>if( !p->pValue ){\n<line10>sqlite3_result_error_nomem(pCtx);\n<line11>}\n<line12>}\n<line13>UNUSED_PARAMETER(nArg);\n<line14>UNUSED_PARAMETER(apArg);\n<line15>}
----------------------------------------
Function: first_valueFinalizeFunc
Content: <line0>static void first_valueFinalizeFunc(sqlite3_context *pCtx){\n<line1>struct NthValueCtx *p;\n<line2>p = (struct NthValueCtx*)sqlite3_aggregate_context(pCtx, sizeof(*p));\n<line3>if( p && p->pValue ){\n<line4>sqlite3_result_value(pCtx, p->pValue);\n<line5>sqlite3_value_free(p->pValue);\n<line6>p->pValue = 0;\n<line7>}\n<line8>}
----------------------------------------
Function: rankStepFunc
Content: <line0>static void rankStepFunc(\n<line1>sqlite3_context *pCtx,\n<line2>int nArg,\n<line3>sqlite3_value **apArg\n<line4>){\n<line5>struct CallCount *p;\n<line6>p = (struct CallCount*)sqlite3_aggregate_context(pCtx, sizeof(*p));\n<line7>if( p ){\n<line8>p->nStep++;\n<line9>if( p->nValue==0 ){\n<line10>p->nValue = p->nStep;\n<line11>}\n<line12>}\n<line13>UNUSED_PARAMETER(nArg);\n<line14>UNUSED_PARAMETER(apArg);\n<line15>}
----------------------------------------
Function: rankValueFunc
Content: <line0>static void rankValueFunc(sqlite3_context *pCtx){\n<line1>struct CallCount *p;\n<line2>p = (struct CallCount*)sqlite3_aggregate_context(pCtx, sizeof(*p));\n<line3>if( p ){\n<line4>sqlite3_result_int64(pCtx, p->nValue);\n<line5>p->nValue = 0;\n<line6>}\n<line7>}
----------------------------------------
Function: percent_rankStepFunc
Content: <line0>static void percent_rankStepFunc(\n<line1>sqlite3_context *pCtx,\n<line2>int nArg,\n<line3>sqlite3_value **apArg\n<line4>){\n<line5>struct CallCount *p;\n<line6>UNUSED_PARAMETER(nArg); assert( nArg==0 );\n<line7>UNUSED_PARAMETER(apArg);\n<line8>p = (struct CallCount*)sqlite3_aggregate_context(pCtx, sizeof(*p));\n<line9>if( p ){\n<line10>p->nTotal++;\n<line11>}\n<line12>}
----------------------------------------
Function: percent_rankInvFunc
Content: <line0>static void percent_rankInvFunc(\n<line1>sqlite3_context *pCtx,\n<line2>int nArg,\n<line3>sqlite3_value **apArg\n<line4>){\n<line5>struct CallCount *p;\n<line6>UNUSED_PARAMETER(nArg); assert( nArg==0 );\n<line7>UNUSED_PARAMETER(apArg);\n<line8>p = (struct CallCount*)sqlite3_aggregate_context(pCtx, sizeof(*p));\n<line9>p->nStep++;\n<line10>}
----------------------------------------
Function: percent_rankValueFunc
Content: <line0>static void percent_rankValueFunc(sqlite3_context *pCtx){\n<line1>struct CallCount *p;\n<line2>p = (struct CallCount*)sqlite3_aggregate_context(pCtx, sizeof(*p));\n<line3>if( p ){\n<line4>p->nValue = p->nStep;\n<line5>if( p->nTotal>1 ){\n<line6>double r = (double)p->nValue / (double)(p->nTotal-1);\n<line7>sqlite3_result_double(pCtx, r);\n<line8>}else{\n<line9>sqlite3_result_double(pCtx, 0.0);\n<line10>}\n<line11>}\n<line12>}
----------------------------------------
Function: cume_distStepFunc
Content: <line0>static void cume_distStepFunc(\n<line1>sqlite3_context *pCtx,\n<line2>int nArg,\n<line3>sqlite3_value **apArg\n<line4>){\n<line5>struct CallCount *p;\n<line6>UNUSED_PARAMETER(nArg); assert( nArg==0 );\n<line7>UNUSED_PARAMETER(apArg);\n<line8>p = (struct CallCount*)sqlite3_aggregate_context(pCtx, sizeof(*p));\n<line9>if( p ){\n<line10>p->nTotal++;\n<line11>}\n<line12>}
----------------------------------------
Function: cume_distInvFunc
Content: <line0>static void cume_distInvFunc(\n<line1>sqlite3_context *pCtx,\n<line2>int nArg,\n<line3>sqlite3_value **apArg\n<line4>){\n<line5>struct CallCount *p;\n<line6>UNUSED_PARAMETER(nArg); assert( nArg==0 );\n<line7>UNUSED_PARAMETER(apArg);\n<line8>p = (struct CallCount*)sqlite3_aggregate_context(pCtx, sizeof(*p));\n<line9>p->nStep++;\n<line10>}
----------------------------------------
Function: cume_distValueFunc
Content: <line0>static void cume_distValueFunc(sqlite3_context *pCtx){\n<line1>struct CallCount *p;\n<line2>p = (struct CallCount*)sqlite3_aggregate_context(pCtx, 0);\n<line3>if( p ){\n<line4>double r = (double)(p->nStep) / (double)(p->nTotal);\n<line5>sqlite3_result_double(pCtx, r);\n<line6>}\n<line7>}
----------------------------------------
Function: ntileStepFunc
Content: <line0>static void ntileStepFunc(\n<line1>sqlite3_context *pCtx,\n<line2>int nArg,\n<line3>sqlite3_value **apArg\n<line4>){\n<line5>struct NtileCtx *p;\n<line6>assert( nArg==1 ); UNUSED_PARAMETER(nArg);\n<line7>p = (struct NtileCtx*)sqlite3_aggregate_context(pCtx, sizeof(*p));\n<line8>if( p ){\n<line9>if( p->nTotal==0 ){\n<line10>p->nParam = sqlite3_value_int64(apArg[0]);\n<line11>if( p->nParam<=0 ){\n<line12>sqlite3_result_error(\n<line13>pCtx, "argument of ntile must be a positive integer", -1\n<line14>);\n<line15>}\n<line16>}\n<line17>p->nTotal++;\n<line18>}\n<line19>}
----------------------------------------
Function: ntileInvFunc
Content: <line0>static void ntileInvFunc(\n<line1>sqlite3_context *pCtx,\n<line2>int nArg,\n<line3>sqlite3_value **apArg\n<line4>){\n<line5>struct NtileCtx *p;\n<line6>assert( nArg==1 ); UNUSED_PARAMETER(nArg);\n<line7>UNUSED_PARAMETER(apArg);\n<line8>p = (struct NtileCtx*)sqlite3_aggregate_context(pCtx, sizeof(*p));\n<line9>p->iRow++;\n<line10>}
----------------------------------------
Function: ntileValueFunc
Content: <line0>static void ntileValueFunc(sqlite3_context *pCtx){\n<line1>struct NtileCtx *p;\n<line2>p = (struct NtileCtx*)sqlite3_aggregate_context(pCtx, sizeof(*p));\n<line3>if( p && p->nParam>0 ){\n<line4>int nSize = (p->nTotal / p->nParam);\n<line5>if( nSize==0 ){\n<line6>sqlite3_result_int64(pCtx, p->iRow+1);\n<line7>}else{\n<line8>i64 nLarge = p->nTotal - p->nParam*nSize;\n<line9>i64 iSmall = nLarge*(nSize+1);\n<line10>i64 iRow = p->iRow;\n<line11>assert( (nLarge*(nSize+1) + (p->nParam-nLarge)*nSize)==p->nTotal );\n<line12>if( iRow<iSmall ){\n<line13>sqlite3_result_int64(pCtx, 1 + iRow/(nSize+1));\n<line14>}else{\n<line15>sqlite3_result_int64(pCtx, 1 + nLarge + (iRow-iSmall)/nSize);\n<line16>}\n<line17>}\n<line18>}\n<line19>}
----------------------------------------
Function: last_valueStepFunc
Content: <line0>static void last_valueStepFunc(\n<line1>sqlite3_context *pCtx,\n<line2>int nArg,\n<line3>sqlite3_value **apArg\n<line4>){\n<line5>struct LastValueCtx *p;\n<line6>UNUSED_PARAMETER(nArg);\n<line7>p = (struct LastValueCtx*)sqlite3_aggregate_context(pCtx, sizeof(*p));\n<line8>if( p ){\n<line9>sqlite3_value_free(p->pVal);\n<line10>p->pVal = sqlite3_value_dup(apArg[0]);\n<line11>if( p->pVal==0 ){\n<line12>sqlite3_result_error_nomem(pCtx);\n<line13>}else{\n<line14>p->nVal++;\n<line15>}\n<line16>}\n<line17>}
----------------------------------------
Function: last_valueInvFunc
Content: <line0>static void last_valueInvFunc(\n<line1>sqlite3_context *pCtx,\n<line2>int nArg,\n<line3>sqlite3_value **apArg\n<line4>){\n<line5>struct LastValueCtx *p;\n<line6>UNUSED_PARAMETER(nArg);\n<line7>UNUSED_PARAMETER(apArg);\n<line8>p = (struct LastValueCtx*)sqlite3_aggregate_context(pCtx, sizeof(*p));\n<line9>if( ALWAYS(p) ){\n<line10>p->nVal--;\n<line11>if( p->nVal==0 ){\n<line12>sqlite3_value_free(p->pVal);\n<line13>p->pVal = 0;\n<line14>}\n<line15>}\n<line16>}
----------------------------------------
Function: last_valueValueFunc
Content: <line0>static void last_valueValueFunc(sqlite3_context *pCtx){\n<line1>struct LastValueCtx *p;\n<line2>p = (struct LastValueCtx*)sqlite3_aggregate_context(pCtx, 0);\n<line3>if( p && p->pVal ){\n<line4>sqlite3_result_value(pCtx, p->pVal);\n<line5>}\n<line6>}
----------------------------------------
Function: last_valueFinalizeFunc
Content: <line0>static void last_valueFinalizeFunc(sqlite3_context *pCtx){\n<line1>struct LastValueCtx *p;\n<line2>p = (struct LastValueCtx*)sqlite3_aggregate_context(pCtx, sizeof(*p));\n<line3>if( p && p->pVal ){\n<line4>sqlite3_result_value(pCtx, p->pVal);\n<line5>sqlite3_value_free(p->pVal);\n<line6>p->pVal = 0;\n<line7>}\n<line8>}
----------------------------------------
Function: noopStepFunc
Content: <line0>static void noopStepFunc(    /*NO_TEST*/\n<line1>sqlite3_context *p,        /*NO_TEST*/\n<line2>int n,                     /*NO_TEST*/\n<line3>sqlite3_value **a          /*NO_TEST*/\n<line4>){                           /*NO_TEST*/\n<line5>UNUSED_PARAMETER(p);       /*NO_TEST*/\n<line6>UNUSED_PARAMETER(n);       /*NO_TEST*/\n<line7>UNUSED_PARAMETER(a);       /*NO_TEST*/\n<line8>assert(0);                 /*NO_TEST*/\n<line9>}                            /*NO_TEST*/
----------------------------------------
Function: noopValueFunc
Content: <line0>static void noopValueFunc(sqlite3_context *p){ UNUSED_PARAMETER(p); /*no-op*/ }
----------------------------------------
Function: windowFind
Content: <line0>static Window *windowFind(Parse *pParse, Window *pList, const char *zName){\n<line1>Window *p;\n<line2>for(p=pList; p; p=p->pNextWin){\n<line3>if( sqlite3StrICmp(p->zName, zName)==0 ) break;\n<line4>}\n<line5>if( p==0 ){\n<line6>sqlite3ErrorMsg(pParse, "no such window: %s", zName);\n<line7>}\n<line8>return p;\n<line9>}
----------------------------------------
Function: selectWindowRewriteExprCb
Content: <line0>static int selectWindowRewriteExprCb(Walker *pWalker, Expr *pExpr){\n<line1>struct WindowRewrite *p = pWalker->u.pRewrite;\n<line2>Parse *pParse = pWalker->pParse;\n<line3>assert( p!=0 );\n<line4>assert( p->pWin!=0 );\n<line5>/* If this function is being called from within a scalar sub-select\n<line6>** that used by the SELECT statement being processed, only process\n<line7>** TK_COLUMN expressions that refer to it (the outer SELECT). Do\n<line8>** not process aggregates or window functions at all, as they belong\n<line9>** to the scalar sub-select.  */\n<line10>if( p->pSubSelect ){\n<line11>if( pExpr->op!=TK_COLUMN ){\n<line12>return WRC_Continue;\n<line13>}else{\n<line14>int nSrc = p->pSrc->nSrc;\n<line15>int i;\n<line16>for(i=0; i<nSrc; i++){\n<line17>if( pExpr->iTable==p->pSrc->a[i].iCursor ) break;\n<line18>}\n<line19>if( i==nSrc ) return WRC_Continue;\n<line20>}\n<line21>}\n<line22>switch( pExpr->op ){\n<line23>case TK_FUNCTION:\n<line24>if( !ExprHasProperty(pExpr, EP_WinFunc) ){\n<line25>break;\n<line26>}else{\n<line27>Window *pWin;\n<line28>for(pWin=p->pWin; pWin; pWin=pWin->pNextWin){\n<line29>if( pExpr->y.pWin==pWin ){\n<line30>assert( pWin->pOwner==pExpr );\n<line31>return WRC_Prune;\n<line32>}\n<line33>}\n<line34>}\n<line35>/* no break */ deliberate_fall_through\n<line36>case TK_IF_NULL_ROW:\n<line37>case TK_AGG_FUNCTION:\n<line38>case TK_COLUMN: {\n<line39>int iCol = -1;\n<line40>if( pParse->db->mallocFailed ) return WRC_Abort;\n<line41>if( p->pSub ){\n<line42>int i;\n<line43>for(i=0; i<p->pSub->nExpr; i++){\n<line44>if( 0==sqlite3ExprCompare(0, p->pSub->a[i].pExpr, pExpr, -1) ){\n<line45>iCol = i;\n<line46>break;\n<line47>}\n<line48>}\n<line49>}\n<line50>if( iCol<0 ){\n<line51>Expr *pDup = sqlite3ExprDup(pParse->db, pExpr, 0);\n<line52>if( pDup && pDup->op==TK_AGG_FUNCTION ) pDup->op = TK_FUNCTION;\n<line53>p->pSub = sqlite3ExprListAppend(pParse, p->pSub, pDup);\n<line54>}\n<line55>if( p->pSub ){\n<line56>int f = pExpr->flags & EP_Collate;\n<line57>assert( ExprHasProperty(pExpr, EP_Static)==0 );\n<line58>ExprSetProperty(pExpr, EP_Static);\n<line59>sqlite3ExprDelete(pParse->db, pExpr);\n<line60>ExprClearProperty(pExpr, EP_Static);\n<line61>memset(pExpr, 0, sizeof(Expr));\n<line62>pExpr->op = TK_COLUMN;\n<line63>pExpr->iColumn = (iCol<0 ? p->pSub->nExpr-1: iCol);\n<line64>pExpr->iTable = p->pWin->iEphCsr;\n<line65>pExpr->y.pTab = p->pTab;\n<line66>pExpr->flags = f;\n<line67>}\n<line68>if( pParse->db->mallocFailed ) return WRC_Abort;\n<line69>break;\n<line70>}\n<line71>default: /* no-op */\n<line72>break;\n<line73>}\n<line74>return WRC_Continue;\n<line75>}
----------------------------------------
Function: selectWindowRewriteSelectCb
Content: <line0>static int selectWindowRewriteSelectCb(Walker *pWalker, Select *pSelect){\n<line1>struct WindowRewrite *p = pWalker->u.pRewrite;\n<line2>Select *pSave = p->pSubSelect;\n<line3>if( pSave==pSelect ){\n<line4>return WRC_Continue;\n<line5>}else{\n<line6>p->pSubSelect = pSelect;\n<line7>sqlite3WalkSelect(pWalker, pSelect);\n<line8>p->pSubSelect = pSave;\n<line9>}\n<line10>return WRC_Prune;\n<line11>}
----------------------------------------
Function: selectWindowRewriteEList
Content: <line0>static void selectWindowRewriteEList(\n<line1>Parse *pParse,\n<line2>Window *pWin,\n<line3>SrcList *pSrc,\n<line4>ExprList *pEList,               /* Rewrite expressions in this list */\n<line5>Table *pTab,\n<line6>ExprList **ppSub                /* IN/OUT: Sub-select expression-list */\n<line7>){\n<line8>Walker sWalker;\n<line9>WindowRewrite sRewrite;\n<line10>assert( pWin!=0 );\n<line11>memset(&sWalker, 0, sizeof(Walker));\n<line12>memset(&sRewrite, 0, sizeof(WindowRewrite));\n<line13>sRewrite.pSub = *ppSub;\n<line14>sRewrite.pWin = pWin;\n<line15>sRewrite.pSrc = pSrc;\n<line16>sRewrite.pTab = pTab;\n<line17>sWalker.pParse = pParse;\n<line18>sWalker.xExprCallback = selectWindowRewriteExprCb;\n<line19>sWalker.xSelectCallback = selectWindowRewriteSelectCb;\n<line20>sWalker.u.pRewrite = &sRewrite;\n<line21>(void)sqlite3WalkExprList(&sWalker, pEList);\n<line22>*ppSub = sRewrite.pSub;\n<line23>}
----------------------------------------
Function: exprListAppendList
Content: <line0>static ExprList *exprListAppendList(\n<line1>Parse *pParse,          /* Parsing context */\n<line2>ExprList *pList,        /* List to which to append. Might be NULL */\n<line3>ExprList *pAppend,      /* List of values to append. Might be NULL */\n<line4>int bIntToNull\n<line5>){\n<line6>if( pAppend ){\n<line7>int i;\n<line8>int nInit = pList ? pList->nExpr : 0;\n<line9>for(i=0; i<pAppend->nExpr; i++){\n<line10>sqlite3 *db = pParse->db;\n<line11>Expr *pDup = sqlite3ExprDup(db, pAppend->a[i].pExpr, 0);\n<line12>if( db->mallocFailed ){\n<line13>sqlite3ExprDelete(db, pDup);\n<line14>break;\n<line15>}\n<line16>if( bIntToNull ){\n<line17>int iDummy;\n<line18>Expr *pSub;\n<line19>pSub = sqlite3ExprSkipCollateAndLikely(pDup);\n<line20>if( sqlite3ExprIsInteger(pSub, &iDummy, 0) ){\n<line21>pSub->op = TK_NULL;\n<line22>pSub->flags &= ~(EP_IntValue|EP_IsTrue|EP_IsFalse);\n<line23>pSub->u.zToken = 0;\n<line24>}\n<line25>}\n<line26>pList = sqlite3ExprListAppend(pParse, pList, pDup);\n<line27>if( pList ) pList->a[nInit+i].fg.sortFlags = pAppend->a[i].fg.sortFlags;\n<line28>}\n<line29>}\n<line30>return pList;\n<line31>}
----------------------------------------
Function: sqlite3WindowExtraAggFuncDepth
Content: <line0>static int sqlite3WindowExtraAggFuncDepth(Walker *pWalker, Expr *pExpr){\n<line1>if( pExpr->op==TK_AGG_FUNCTION\n<line2>&& pExpr->op2>=pWalker->walkerDepth\n<line3>){\n<line4>pExpr->op2++;\n<line5>}\n<line6>return WRC_Continue;\n<line7>}
----------------------------------------
Function: disallowAggregatesInOrderByCb
Content: <line0>static int disallowAggregatesInOrderByCb(Walker *pWalker, Expr *pExpr){\n<line1>if( pExpr->op==TK_AGG_FUNCTION && pExpr->pAggInfo==0 ){\n<line2>assert( !ExprHasProperty(pExpr, EP_IntValue) );\n<line3>sqlite3ErrorMsg(pWalker->pParse,\n<line4>"misuse of aggregate: %s()", pExpr->u.zToken);\n<line5>}\n<line6>return WRC_Continue;\n<line7>}
----------------------------------------
Function: sqlite3WindowOffsetExpr
Content: <line0>static Expr *sqlite3WindowOffsetExpr(Parse *pParse, Expr *pExpr){\n<line1>if( 0==sqlite3ExprIsConstant(0,pExpr) ){\n<line2>if( IN_RENAME_OBJECT ) sqlite3RenameExprUnmap(pParse, pExpr);\n<line3>sqlite3ExprDelete(pParse->db, pExpr);\n<line4>pExpr = sqlite3ExprAlloc(pParse->db, TK_NULL, 0, 0);\n<line5>}\n<line6>return pExpr;\n<line7>}
----------------------------------------
Function: windowCheckValue
Content: <line0>static void windowCheckValue(Parse *pParse, int reg, int eCond){\n<line1>static const char *azErr[] = {\n<line2>"frame starting offset must be a non-negative integer",\n<line3>"frame ending offset must be a non-negative integer",\n<line4>"second argument to nth_value must be a positive integer",\n<line5>"frame starting offset must be a non-negative number",\n<line6>"frame ending offset must be a non-negative number",\n<line7>};\n<line8>static int aOp[] = { OP_Ge, OP_Ge, OP_Gt, OP_Ge, OP_Ge };\n<line9>Vdbe *v = sqlite3GetVdbe(pParse);\n<line10>int regZero = sqlite3GetTempReg(pParse);\n<line11>assert( eCond>=0 && eCond<ArraySize(azErr) );\n<line12>sqlite3VdbeAddOp2(v, OP_Integer, 0, regZero);\n<line13>if( eCond>=WINDOW_STARTING_NUM ){\n<line14>int regString = sqlite3GetTempReg(pParse);\n<line15>sqlite3VdbeAddOp4(v, OP_String8, 0, regString, 0, "", P4_STATIC);\n<line16>sqlite3VdbeAddOp3(v, OP_Ge, regString, sqlite3VdbeCurrentAddr(v)+2, reg);\n<line17>sqlite3VdbeChangeP5(v, SQLITE_AFF_NUMERIC|SQLITE_JUMPIFNULL);\n<line18>VdbeCoverage(v);\n<line19>assert( eCond==3 || eCond==4 );\n<line20>VdbeCoverageIf(v, eCond==3);\n<line21>VdbeCoverageIf(v, eCond==4);\n<line22>}else{\n<line23>sqlite3VdbeAddOp2(v, OP_MustBeInt, reg, sqlite3VdbeCurrentAddr(v)+2);\n<line24>VdbeCoverage(v);\n<line25>assert( eCond==0 || eCond==1 || eCond==2 );\n<line26>VdbeCoverageIf(v, eCond==0);\n<line27>VdbeCoverageIf(v, eCond==1);\n<line28>VdbeCoverageIf(v, eCond==2);\n<line29>}\n<line30>sqlite3VdbeAddOp3(v, aOp[eCond], regZero, sqlite3VdbeCurrentAddr(v)+2, reg);\n<line31>sqlite3VdbeChangeP5(v, SQLITE_AFF_NUMERIC);\n<line32>VdbeCoverageNeverNullIf(v, eCond==0); /* NULL case captured by */\n<line33>VdbeCoverageNeverNullIf(v, eCond==1); /*   the OP_MustBeInt */\n<line34>VdbeCoverageNeverNullIf(v, eCond==2);\n<line35>VdbeCoverageNeverNullIf(v, eCond==3); /* NULL case caught by */\n<line36>VdbeCoverageNeverNullIf(v, eCond==4); /*   the OP_Ge */\n<line37>sqlite3MayAbort(pParse);\n<line38>sqlite3VdbeAddOp2(v, OP_Halt, SQLITE_ERROR, OE_Abort);\n<line39>sqlite3VdbeAppendP4(v, (void*)azErr[eCond], P4_STATIC);\n<line40>sqlite3ReleaseTempReg(pParse, regZero);\n<line41>}
----------------------------------------
Function: windowArgCount
Content: <line0>static int windowArgCount(Window *pWin){\n<line1>const ExprList *pList;\n<line2>assert( ExprUseXList(pWin->pOwner) );\n<line3>pList = pWin->pOwner->x.pList;\n<line4>return (pList ? pList->nExpr : 0);\n<line5>}
----------------------------------------
Function: windowReadPeerValues
Content: <line0>static void windowReadPeerValues(\n<line1>WindowCodeArg *p,\n<line2>int csr,\n<line3>int reg\n<line4>){\n<line5>Window *pMWin = p->pMWin;\n<line6>ExprList *pOrderBy = pMWin->pOrderBy;\n<line7>if( pOrderBy ){\n<line8>Vdbe *v = sqlite3GetVdbe(p->pParse);\n<line9>ExprList *pPart = pMWin->pPartition;\n<line10>int iColOff = pMWin->nBufferCol + (pPart ? pPart->nExpr : 0);\n<line11>int i;\n<line12>for(i=0; i<pOrderBy->nExpr; i++){\n<line13>sqlite3VdbeAddOp3(v, OP_Column, csr, iColOff+i, reg+i);\n<line14>}\n<line15>}\n<line16>}
----------------------------------------
Function: windowAggStep
Content: <line0>static void windowAggStep(\n<line1>WindowCodeArg *p,\n<line2>Window *pMWin,                  /* Linked list of window functions */\n<line3>int csr,                        /* Read arguments from this cursor */\n<line4>int bInverse,                   /* True to invoke xInverse instead of xStep */\n<line5>int reg                         /* Array of registers */\n<line6>){\n<line7>Parse *pParse = p->pParse;\n<line8>Vdbe *v = sqlite3GetVdbe(pParse);\n<line9>Window *pWin;\n<line10>for(pWin=pMWin; pWin; pWin=pWin->pNextWin){\n<line11>FuncDef *pFunc = pWin->pWFunc;\n<line12>int regArg;\n<line13>int nArg = pWin->bExprArgs ? 0 : windowArgCount(pWin);\n<line14>int i;\n<line15>int addrIf = 0;\n<line16>assert( bInverse==0 || pWin->eStart!=TK_UNBOUNDED );\n<line17>/* All OVER clauses in the same window function aggregate step must\n<line18>** be the same. */\n<line19>assert( pWin==pMWin || sqlite3WindowCompare(pParse,pWin,pMWin,0)!=1 );\n<line20>for(i=0; i<nArg; i++){\n<line21>if( i!=1 || pFunc->zName!=nth_valueName ){\n<line22>sqlite3VdbeAddOp3(v, OP_Column, csr, pWin->iArgCol+i, reg+i);\n<line23>}else{\n<line24>sqlite3VdbeAddOp3(v, OP_Column, pMWin->iEphCsr, pWin->iArgCol+i, reg+i);\n<line25>}\n<line26>}\n<line27>regArg = reg;\n<line28>if( pWin->pFilter ){\n<line29>int regTmp;\n<line30>assert( ExprUseXList(pWin->pOwner) );\n<line31>assert( pWin->bExprArgs || !nArg ||nArg==pWin->pOwner->x.pList->nExpr );\n<line32>assert( pWin->bExprArgs || nArg  ||pWin->pOwner->x.pList==0 );\n<line33>regTmp = sqlite3GetTempReg(pParse);\n<line34>sqlite3VdbeAddOp3(v, OP_Column, csr, pWin->iArgCol+nArg,regTmp);\n<line35>addrIf = sqlite3VdbeAddOp3(v, OP_IfNot, regTmp, 0, 1);\n<line36>VdbeCoverage(v);\n<line37>sqlite3ReleaseTempReg(pParse, regTmp);\n<line38>}\n<line39>if( pMWin->regStartRowid==0\n<line40>&& (pFunc->funcFlags & SQLITE_FUNC_MINMAX)\n<line41>&& (pWin->eStart!=TK_UNBOUNDED)\n<line42>){\n<line43>int addrIsNull = sqlite3VdbeAddOp1(v, OP_IsNull, regArg);\n<line44>VdbeCoverage(v);\n<line45>if( bInverse==0 ){\n<line46>sqlite3VdbeAddOp2(v, OP_AddImm, pWin->regApp+1, 1);\n<line47>sqlite3VdbeAddOp2(v, OP_SCopy, regArg, pWin->regApp);\n<line48>sqlite3VdbeAddOp3(v, OP_MakeRecord, pWin->regApp, 2, pWin->regApp+2);\n<line49>sqlite3VdbeAddOp2(v, OP_IdxInsert, pWin->csrApp, pWin->regApp+2);\n<line50>}else{\n<line51>sqlite3VdbeAddOp4Int(v, OP_SeekGE, pWin->csrApp, 0, regArg, 1);\n<line52>VdbeCoverageNeverTaken(v);\n<line53>sqlite3VdbeAddOp1(v, OP_Delete, pWin->csrApp);\n<line54>sqlite3VdbeJumpHere(v, sqlite3VdbeCurrentAddr(v)-2);\n<line55>}\n<line56>sqlite3VdbeJumpHere(v, addrIsNull);\n<line57>}else if( pWin->regApp ){\n<line58>assert( pWin->pFilter==0 );\n<line59>assert( pFunc->zName==nth_valueName\n<line60>|| pFunc->zName==first_valueName\n<line61>);\n<line62>assert( bInverse==0 || bInverse==1 );\n<line63>sqlite3VdbeAddOp2(v, OP_AddImm, pWin->regApp+1-bInverse, 1);\n<line64>}else if( pFunc->xSFunc!=noopStepFunc ){\n<line65>if( pWin->bExprArgs ){\n<line66>int iOp = sqlite3VdbeCurrentAddr(v);\n<line67>int iEnd;\n<line68>assert( ExprUseXList(pWin->pOwner) );\n<line69>nArg = pWin->pOwner->x.pList->nExpr;\n<line70>regArg = sqlite3GetTempRange(pParse, nArg);\n<line71>sqlite3ExprCodeExprList(pParse, pWin->pOwner->x.pList, regArg, 0, 0);\n<line72>for(iEnd=sqlite3VdbeCurrentAddr(v); iOp<iEnd; iOp++){\n<line73>VdbeOp *pOp = sqlite3VdbeGetOp(v, iOp);\n<line74>if( pOp->opcode==OP_Column && pOp->p1==pMWin->iEphCsr ){\n<line75>pOp->p1 = csr;\n<line76>}\n<line77>}\n<line78>}\n<line79>if( pFunc->funcFlags & SQLITE_FUNC_NEEDCOLL ){\n<line80>CollSeq *pColl;\n<line81>assert( nArg>0 );\n<line82>assert( ExprUseXList(pWin->pOwner) );\n<line83>pColl = sqlite3ExprNNCollSeq(pParse, pWin->pOwner->x.pList->a[0].pExpr);\n<line84>sqlite3VdbeAddOp4(v, OP_CollSeq, 0,0,0, (const char*)pColl, P4_COLLSEQ);\n<line85>}\n<line86>sqlite3VdbeAddOp3(v, bInverse? OP_AggInverse : OP_AggStep,\n<line87>bInverse, regArg, pWin->regAccum);\n<line88>sqlite3VdbeAppendP4(v, pFunc, P4_FUNCDEF);\n<line89>sqlite3VdbeChangeP5(v, (u16)nArg);\n<line90>if( pWin->bExprArgs ){\n<line91>sqlite3ReleaseTempRange(pParse, regArg, nArg);\n<line92>}\n<line93>}\n<line94>if( addrIf ) sqlite3VdbeJumpHere(v, addrIf);\n<line95>}\n<line96>}
----------------------------------------
Function: windowAggFinal
Content: <line0>static void windowAggFinal(WindowCodeArg *p, int bFin){\n<line1>Parse *pParse = p->pParse;\n<line2>Window *pMWin = p->pMWin;\n<line3>Vdbe *v = sqlite3GetVdbe(pParse);\n<line4>Window *pWin;\n<line5>for(pWin=pMWin; pWin; pWin=pWin->pNextWin){\n<line6>if( pMWin->regStartRowid==0\n<line7>&& (pWin->pWFunc->funcFlags & SQLITE_FUNC_MINMAX)\n<line8>&& (pWin->eStart!=TK_UNBOUNDED)\n<line9>){\n<line10>sqlite3VdbeAddOp2(v, OP_Null, 0, pWin->regResult);\n<line11>sqlite3VdbeAddOp1(v, OP_Last, pWin->csrApp);\n<line12>VdbeCoverage(v);\n<line13>sqlite3VdbeAddOp3(v, OP_Column, pWin->csrApp, 0, pWin->regResult);\n<line14>sqlite3VdbeJumpHere(v, sqlite3VdbeCurrentAddr(v)-2);\n<line15>}else if( pWin->regApp ){\n<line16>assert( pMWin->regStartRowid==0 );\n<line17>}else{\n<line18>int nArg = windowArgCount(pWin);\n<line19>if( bFin ){\n<line20>sqlite3VdbeAddOp2(v, OP_AggFinal, pWin->regAccum, nArg);\n<line21>sqlite3VdbeAppendP4(v, pWin->pWFunc, P4_FUNCDEF);\n<line22>sqlite3VdbeAddOp2(v, OP_Copy, pWin->regAccum, pWin->regResult);\n<line23>sqlite3VdbeAddOp2(v, OP_Null, 0, pWin->regAccum);\n<line24>}else{\n<line25>sqlite3VdbeAddOp3(v, OP_AggValue,pWin->regAccum,nArg,pWin->regResult);\n<line26>sqlite3VdbeAppendP4(v, pWin->pWFunc, P4_FUNCDEF);\n<line27>}\n<line28>}\n<line29>}\n<line30>}
----------------------------------------
Function: windowFullScan
Content: <line0>static void windowFullScan(WindowCodeArg *p){\n<line1>Window *pWin;\n<line2>Parse *pParse = p->pParse;\n<line3>Window *pMWin = p->pMWin;\n<line4>Vdbe *v = p->pVdbe;\n<line5>int regCRowid = 0;              /* Current rowid value */\n<line6>int regCPeer = 0;               /* Current peer values */\n<line7>int regRowid = 0;               /* AggStep rowid value */\n<line8>int regPeer = 0;                /* AggStep peer values */\n<line9>int nPeer;\n<line10>int lblNext;\n<line11>int lblBrk;\n<line12>int addrNext;\n<line13>int csr;\n<line14>VdbeModuleComment((v, "windowFullScan begin"));\n<line15>assert( pMWin!=0 );\n<line16>csr = pMWin->csrApp;\n<line17>nPeer = (pMWin->pOrderBy ? pMWin->pOrderBy->nExpr : 0);\n<line18>lblNext = sqlite3VdbeMakeLabel(pParse);\n<line19>lblBrk = sqlite3VdbeMakeLabel(pParse);\n<line20>regCRowid = sqlite3GetTempReg(pParse);\n<line21>regRowid = sqlite3GetTempReg(pParse);\n<line22>if( nPeer ){\n<line23>regCPeer = sqlite3GetTempRange(pParse, nPeer);\n<line24>regPeer = sqlite3GetTempRange(pParse, nPeer);\n<line25>}\n<line26>sqlite3VdbeAddOp2(v, OP_Rowid, pMWin->iEphCsr, regCRowid);\n<line27>windowReadPeerValues(p, pMWin->iEphCsr, regCPeer);\n<line28>for(pWin=pMWin; pWin; pWin=pWin->pNextWin){\n<line29>sqlite3VdbeAddOp2(v, OP_Null, 0, pWin->regAccum);\n<line30>}\n<line31>sqlite3VdbeAddOp3(v, OP_SeekGE, csr, lblBrk, pMWin->regStartRowid);\n<line32>VdbeCoverage(v);\n<line33>addrNext = sqlite3VdbeCurrentAddr(v);\n<line34>sqlite3VdbeAddOp2(v, OP_Rowid, csr, regRowid);\n<line35>sqlite3VdbeAddOp3(v, OP_Gt, pMWin->regEndRowid, lblBrk, regRowid);\n<line36>VdbeCoverageNeverNull(v);\n<line37>if( pMWin->eExclude==TK_CURRENT ){\n<line38>sqlite3VdbeAddOp3(v, OP_Eq, regCRowid, lblNext, regRowid);\n<line39>VdbeCoverageNeverNull(v);\n<line40>}else if( pMWin->eExclude!=TK_NO ){\n<line41>int addr;\n<line42>int addrEq = 0;\n<line43>KeyInfo *pKeyInfo = 0;\n<line44>if( pMWin->pOrderBy ){\n<line45>pKeyInfo = sqlite3KeyInfoFromExprList(pParse, pMWin->pOrderBy, 0, 0);\n<line46>}\n<line47>if( pMWin->eExclude==TK_TIES ){\n<line48>addrEq = sqlite3VdbeAddOp3(v, OP_Eq, regCRowid, 0, regRowid);\n<line49>VdbeCoverageNeverNull(v);\n<line50>}\n<line51>if( pKeyInfo ){\n<line52>windowReadPeerValues(p, csr, regPeer);\n<line53>sqlite3VdbeAddOp3(v, OP_Compare, regPeer, regCPeer, nPeer);\n<line54>sqlite3VdbeAppendP4(v, (void*)pKeyInfo, P4_KEYINFO);\n<line55>addr = sqlite3VdbeCurrentAddr(v)+1;\n<line56>sqlite3VdbeAddOp3(v, OP_Jump, addr, lblNext, addr);\n<line57>VdbeCoverageEqNe(v);\n<line58>}else{\n<line59>sqlite3VdbeAddOp2(v, OP_Goto, 0, lblNext);\n<line60>}\n<line61>if( addrEq ) sqlite3VdbeJumpHere(v, addrEq);\n<line62>}\n<line63>windowAggStep(p, pMWin, csr, 0, p->regArg);\n<line64>sqlite3VdbeResolveLabel(v, lblNext);\n<line65>sqlite3VdbeAddOp2(v, OP_Next, csr, addrNext);\n<line66>VdbeCoverage(v);\n<line67>sqlite3VdbeJumpHere(v, addrNext-1);\n<line68>sqlite3VdbeJumpHere(v, addrNext+1);\n<line69>sqlite3ReleaseTempReg(pParse, regRowid);\n<line70>sqlite3ReleaseTempReg(pParse, regCRowid);\n<line71>if( nPeer ){\n<line72>sqlite3ReleaseTempRange(pParse, regPeer, nPeer);\n<line73>sqlite3ReleaseTempRange(pParse, regCPeer, nPeer);\n<line74>}\n<line75>windowAggFinal(p, 1);\n<line76>VdbeModuleComment((v, "windowFullScan end"));\n<line77>}
----------------------------------------
Function: windowReturnOneRow
Content: <line0>static void windowReturnOneRow(WindowCodeArg *p){\n<line1>Window *pMWin = p->pMWin;\n<line2>Vdbe *v = p->pVdbe;\n<line3>if( pMWin->regStartRowid ){\n<line4>windowFullScan(p);\n<line5>}else{\n<line6>Parse *pParse = p->pParse;\n<line7>Window *pWin;\n<line8>for(pWin=pMWin; pWin; pWin=pWin->pNextWin){\n<line9>FuncDef *pFunc = pWin->pWFunc;\n<line10>assert( ExprUseXList(pWin->pOwner) );\n<line11>if( pFunc->zName==nth_valueName\n<line12>|| pFunc->zName==first_valueName\n<line13>){\n<line14>int csr = pWin->csrApp;\n<line15>int lbl = sqlite3VdbeMakeLabel(pParse);\n<line16>int tmpReg = sqlite3GetTempReg(pParse);\n<line17>sqlite3VdbeAddOp2(v, OP_Null, 0, pWin->regResult);\n<line18>if( pFunc->zName==nth_valueName ){\n<line19>sqlite3VdbeAddOp3(v, OP_Column,pMWin->iEphCsr,pWin->iArgCol+1,tmpReg);\n<line20>windowCheckValue(pParse, tmpReg, 2);\n<line21>}else{\n<line22>sqlite3VdbeAddOp2(v, OP_Integer, 1, tmpReg);\n<line23>}\n<line24>sqlite3VdbeAddOp3(v, OP_Add, tmpReg, pWin->regApp, tmpReg);\n<line25>sqlite3VdbeAddOp3(v, OP_Gt, pWin->regApp+1, lbl, tmpReg);\n<line26>VdbeCoverageNeverNull(v);\n<line27>sqlite3VdbeAddOp3(v, OP_SeekRowid, csr, 0, tmpReg);\n<line28>VdbeCoverageNeverTaken(v);\n<line29>sqlite3VdbeAddOp3(v, OP_Column, csr, pWin->iArgCol, pWin->regResult);\n<line30>sqlite3VdbeResolveLabel(v, lbl);\n<line31>sqlite3ReleaseTempReg(pParse, tmpReg);\n<line32>}\n<line33>else if( pFunc->zName==leadName || pFunc->zName==lagName ){\n<line34>int nArg = pWin->pOwner->x.pList->nExpr;\n<line35>int csr = pWin->csrApp;\n<line36>int lbl = sqlite3VdbeMakeLabel(pParse);\n<line37>int tmpReg = sqlite3GetTempReg(pParse);\n<line38>int iEph = pMWin->iEphCsr;\n<line39>if( nArg<3 ){\n<line40>sqlite3VdbeAddOp2(v, OP_Null, 0, pWin->regResult);\n<line41>}else{\n<line42>sqlite3VdbeAddOp3(v, OP_Column, iEph,pWin->iArgCol+2,pWin->regResult);\n<line43>}\n<line44>sqlite3VdbeAddOp2(v, OP_Rowid, iEph, tmpReg);\n<line45>if( nArg<2 ){\n<line46>int val = (pFunc->zName==leadName ? 1 : -1);\n<line47>sqlite3VdbeAddOp2(v, OP_AddImm, tmpReg, val);\n<line48>}else{\n<line49>int op = (pFunc->zName==leadName ? OP_Add : OP_Subtract);\n<line50>int tmpReg2 = sqlite3GetTempReg(pParse);\n<line51>sqlite3VdbeAddOp3(v, OP_Column, iEph, pWin->iArgCol+1, tmpReg2);\n<line52>sqlite3VdbeAddOp3(v, op, tmpReg2, tmpReg, tmpReg);\n<line53>sqlite3ReleaseTempReg(pParse, tmpReg2);\n<line54>}\n<line55>sqlite3VdbeAddOp3(v, OP_SeekRowid, csr, lbl, tmpReg);\n<line56>VdbeCoverage(v);\n<line57>sqlite3VdbeAddOp3(v, OP_Column, csr, pWin->iArgCol, pWin->regResult);\n<line58>sqlite3VdbeResolveLabel(v, lbl);\n<line59>sqlite3ReleaseTempReg(pParse, tmpReg);\n<line60>}\n<line61>}\n<line62>}\n<line63>sqlite3VdbeAddOp2(v, OP_Gosub, p->regGosub, p->addrGosub);\n<line64>}
----------------------------------------
Function: windowInitAccum
Content: <line0>static int windowInitAccum(Parse *pParse, Window *pMWin){\n<line1>Vdbe *v = sqlite3GetVdbe(pParse);\n<line2>int regArg;\n<line3>int nArg = 0;\n<line4>Window *pWin;\n<line5>for(pWin=pMWin; pWin; pWin=pWin->pNextWin){\n<line6>FuncDef *pFunc = pWin->pWFunc;\n<line7>assert( pWin->regAccum );\n<line8>sqlite3VdbeAddOp2(v, OP_Null, 0, pWin->regAccum);\n<line9>nArg = MAX(nArg, windowArgCount(pWin));\n<line10>if( pMWin->regStartRowid==0 ){\n<line11>if( pFunc->zName==nth_valueName || pFunc->zName==first_valueName ){\n<line12>sqlite3VdbeAddOp2(v, OP_Integer, 0, pWin->regApp);\n<line13>sqlite3VdbeAddOp2(v, OP_Integer, 0, pWin->regApp+1);\n<line14>}\n<line15>if( (pFunc->funcFlags & SQLITE_FUNC_MINMAX) && pWin->csrApp ){\n<line16>assert( pWin->eStart!=TK_UNBOUNDED );\n<line17>sqlite3VdbeAddOp1(v, OP_ResetSorter, pWin->csrApp);\n<line18>sqlite3VdbeAddOp2(v, OP_Integer, 0, pWin->regApp+1);\n<line19>}\n<line20>}\n<line21>}\n<line22>regArg = pParse->nMem+1;\n<line23>pParse->nMem += nArg;\n<line24>return regArg;\n<line25>}
----------------------------------------
Function: windowCacheFrame
Content: <line0>static int windowCacheFrame(Window *pMWin){\n<line1>Window *pWin;\n<line2>if( pMWin->regStartRowid ) return 1;\n<line3>for(pWin=pMWin; pWin; pWin=pWin->pNextWin){\n<line4>FuncDef *pFunc = pWin->pWFunc;\n<line5>if( (pFunc->zName==nth_valueName)\n<line6>|| (pFunc->zName==first_valueName)\n<line7>|| (pFunc->zName==leadName)\n<line8>|| (pFunc->zName==lagName)\n<line9>){\n<line10>return 1;\n<line11>}\n<line12>}\n<line13>return 0;\n<line14>}
----------------------------------------
Function: windowIfNewPeer
Content: <line0>static void windowIfNewPeer(\n<line1>Parse *pParse,\n<line2>ExprList *pOrderBy,\n<line3>int regNew,                     /* First in array of new values */\n<line4>int regOld,                     /* First in array of old values */\n<line5>int addr                        /* Jump here */\n<line6>){\n<line7>Vdbe *v = sqlite3GetVdbe(pParse);\n<line8>if( pOrderBy ){\n<line9>int nVal = pOrderBy->nExpr;\n<line10>KeyInfo *pKeyInfo = sqlite3KeyInfoFromExprList(pParse, pOrderBy, 0, 0);\n<line11>sqlite3VdbeAddOp3(v, OP_Compare, regOld, regNew, nVal);\n<line12>sqlite3VdbeAppendP4(v, (void*)pKeyInfo, P4_KEYINFO);\n<line13>sqlite3VdbeAddOp3(v, OP_Jump,\n<line14>sqlite3VdbeCurrentAddr(v)+1, addr, sqlite3VdbeCurrentAddr(v)+1\n<line15>);\n<line16>VdbeCoverageEqNe(v);\n<line17>sqlite3VdbeAddOp3(v, OP_Copy, regNew, regOld, nVal-1);\n<line18>}else{\n<line19>sqlite3VdbeAddOp2(v, OP_Goto, 0, addr);\n<line20>}\n<line21>}
----------------------------------------
Function: windowCodeRangeTest
Content: <line0>static void windowCodeRangeTest(\n<line1>WindowCodeArg *p,\n<line2>int op,                         /* OP_Ge, OP_Gt, or OP_Le */\n<line3>int csr1,                       /* Cursor number for cursor 1 */\n<line4>int regVal,                     /* Register containing non-negative number */\n<line5>int csr2,                       /* Cursor number for cursor 2 */\n<line6>int lbl                         /* Jump destination if condition is true */\n<line7>){\n<line8>Parse *pParse = p->pParse;\n<line9>Vdbe *v = sqlite3GetVdbe(pParse);\n<line10>ExprList *pOrderBy = p->pMWin->pOrderBy;  /* ORDER BY clause for window */\n<line11>int reg1 = sqlite3GetTempReg(pParse);     /* Reg. for csr1.peerVal+regVal */\n<line12>int reg2 = sqlite3GetTempReg(pParse);     /* Reg. for csr2.peerVal */\n<line13>int regString = ++pParse->nMem;           /* Reg. for constant value '' */\n<line14>int arith = OP_Add;                       /* OP_Add or OP_Subtract */\n<line15>int addrGe;                               /* Jump destination */\n<line16>int addrDone = sqlite3VdbeMakeLabel(pParse);   /* Address past OP_Ge */\n<line17>CollSeq *pColl;\n<line18>/* Read the peer-value from each cursor into a register */\n<line19>windowReadPeerValues(p, csr1, reg1);\n<line20>windowReadPeerValues(p, csr2, reg2);\n<line21>assert( op==OP_Ge || op==OP_Gt || op==OP_Le );\n<line22>assert( pOrderBy && pOrderBy->nExpr==1 );\n<line23>if( pOrderBy->a[0].fg.sortFlags & KEYINFO_ORDER_DESC ){\n<line24>switch( op ){\n<line25>case OP_Ge: op = OP_Le; break;\n<line26>case OP_Gt: op = OP_Lt; break;\n<line27>default: assert( op==OP_Le ); op = OP_Ge; break;\n<line28>}\n<line29>arith = OP_Subtract;\n<line30>}\n<line31>VdbeModuleComment((v, "CodeRangeTest: if( R%d %s R%d %s R%d ) goto lbl",\n<line32>reg1, (arith==OP_Add ? "+" : "-"), regVal,\n<line33>((op==OP_Ge) ? ">=" : (op==OP_Le) ? "<=" : (op==OP_Gt) ? ">" : "<"), reg2\n<line34>));\n<line35>/* If the BIGNULL flag is set for the ORDER BY, then it is required to\n<line36>** consider NULL values to be larger than all other values, instead of\n<line37>** the usual smaller. The VDBE opcodes OP_Ge and so on do not handle this\n<line38>** (and adding that capability causes a performance regression), so\n<line39>** instead if the BIGNULL flag is set then cases where either reg1 or\n<line40>** reg2 are NULL are handled separately in the following block. The code\n<line41>** generated is equivalent to:\n<line42>**\n<line43>**   if( reg1 IS NULL ){\n<line44>**     if( op==OP_Ge ) goto lbl;\n<line45>**     if( op==OP_Gt && reg2 IS NOT NULL ) goto lbl;\n<line46>**     if( op==OP_Le && reg2 IS NULL ) goto lbl;\n<line47>**   }else if( reg2 IS NULL ){\n<line48>**     if( op==OP_Le ) goto lbl;\n<line49>**   }\n<line50>**\n<line51>** Additionally, if either reg1 or reg2 are NULL but the jump to lbl is\n<line52>** not taken, control jumps over the comparison operator coded below this\n<line53>** block.  */\n<line54>if( pOrderBy->a[0].fg.sortFlags & KEYINFO_ORDER_BIGNULL ){\n<line55>/* This block runs if reg1 contains a NULL. */\n<line56>int addr = sqlite3VdbeAddOp1(v, OP_NotNull, reg1); VdbeCoverage(v);\n<line57>switch( op ){\n<line58>case OP_Ge:\n<line59>sqlite3VdbeAddOp2(v, OP_Goto, 0, lbl);\n<line60>break;\n<line61>case OP_Gt:\n<line62>sqlite3VdbeAddOp2(v, OP_NotNull, reg2, lbl);\n<line63>VdbeCoverage(v);\n<line64>break;\n<line65>case OP_Le:\n<line66>sqlite3VdbeAddOp2(v, OP_IsNull, reg2, lbl);\n<line67>VdbeCoverage(v);\n<line68>break;\n<line69>default: assert( op==OP_Lt ); /* no-op */ break;\n<line70>}\n<line71>sqlite3VdbeAddOp2(v, OP_Goto, 0, addrDone);\n<line72>/* This block runs if reg1 is not NULL, but reg2 is. */\n<line73>sqlite3VdbeJumpHere(v, addr);\n<line74>sqlite3VdbeAddOp2(v, OP_IsNull, reg2,\n<line75>(op==OP_Gt || op==OP_Ge) ? addrDone : lbl);\n<line76>VdbeCoverage(v);\n<line77>}\n<line78>/* Register reg1 currently contains csr1.peerVal (the peer-value from csr1).\n<line79>** This block adds (or subtracts for DESC) the numeric value in regVal\n<line80>** from it. Or, if reg1 is not numeric (it is a NULL, a text value or a blob),\n<line81>** then leave reg1 as it is. In pseudo-code, this is implemented as:\n<line82>**\n<line83>**   if( reg1>='' ) goto addrGe;\n<line84>**   reg1 = reg1 +/- regVal\n<line85>**   addrGe:\n<line86>**\n<line87>** Since all strings and blobs are greater-than-or-equal-to an empty string,\n<line88>** the add/subtract is skipped for these, as required. If reg1 is a NULL,\n<line89>** then the arithmetic is performed, but since adding or subtracting from\n<line90>** NULL is always NULL anyway, this case is handled as required too.  */\n<line91>sqlite3VdbeAddOp4(v, OP_String8, 0, regString, 0, "", P4_STATIC);\n<line92>addrGe = sqlite3VdbeAddOp3(v, OP_Ge, regString, 0, reg1);\n<line93>VdbeCoverage(v);\n<line94>if( (op==OP_Ge && arith==OP_Add) || (op==OP_Le && arith==OP_Subtract) ){\n<line95>sqlite3VdbeAddOp3(v, op, reg2, lbl, reg1); VdbeCoverage(v);\n<line96>}\n<line97>sqlite3VdbeAddOp3(v, arith, regVal, reg1, reg1);\n<line98>sqlite3VdbeJumpHere(v, addrGe);\n<line99>/* Compare registers reg2 and reg1, taking the jump if required. Note that\n<line100>** control skips over this test if the BIGNULL flag is set and either\n<line101>** reg1 or reg2 contain a NULL value.  */\n<line102>sqlite3VdbeAddOp3(v, op, reg2, lbl, reg1); VdbeCoverage(v);\n<line103>pColl = sqlite3ExprNNCollSeq(pParse, pOrderBy->a[0].pExpr);\n<line104>sqlite3VdbeAppendP4(v, (void*)pColl, P4_COLLSEQ);\n<line105>sqlite3VdbeChangeP5(v, SQLITE_NULLEQ);\n<line106>sqlite3VdbeResolveLabel(v, addrDone);\n<line107>assert( op==OP_Ge || op==OP_Gt || op==OP_Lt || op==OP_Le );\n<line108>testcase(op==OP_Ge); VdbeCoverageIf(v, op==OP_Ge);\n<line109>testcase(op==OP_Lt); VdbeCoverageIf(v, op==OP_Lt);\n<line110>testcase(op==OP_Le); VdbeCoverageIf(v, op==OP_Le);\n<line111>testcase(op==OP_Gt); VdbeCoverageIf(v, op==OP_Gt);\n<line112>sqlite3ReleaseTempReg(pParse, reg1);\n<line113>sqlite3ReleaseTempReg(pParse, reg2);\n<line114>VdbeModuleComment((v, "CodeRangeTest: end"));\n<line115>}
----------------------------------------
Function: windowCodeOp
Content: <line0>static int windowCodeOp(\n<line1>WindowCodeArg *p,                /* Context object */\n<line2>int op,                          /* WINDOW_RETURN_ROW, AGGSTEP or AGGINVERSE */\n<line3>int regCountdown,                /* Register for OP_IfPos countdown */\n<line4>int jumpOnEof                    /* Jump here if stepped cursor reaches EOF */\n<line5>){\n<line6>int csr, reg;\n<line7>Parse *pParse = p->pParse;\n<line8>Window *pMWin = p->pMWin;\n<line9>int ret = 0;\n<line10>Vdbe *v = p->pVdbe;\n<line11>int addrContinue = 0;\n<line12>int bPeer = (pMWin->eFrmType!=TK_ROWS);\n<line13>int lblDone = sqlite3VdbeMakeLabel(pParse);\n<line14>int addrNextRange = 0;\n<line15>/* Special case - WINDOW_AGGINVERSE is always a no-op if the frame\n<line16>** starts with UNBOUNDED PRECEDING. */\n<line17>if( op==WINDOW_AGGINVERSE && pMWin->eStart==TK_UNBOUNDED ){\n<line18>assert( regCountdown==0 && jumpOnEof==0 );\n<line19>return 0;\n<line20>}\n<line21>if( regCountdown>0 ){\n<line22>if( pMWin->eFrmType==TK_RANGE ){\n<line23>addrNextRange = sqlite3VdbeCurrentAddr(v);\n<line24>assert( op==WINDOW_AGGINVERSE || op==WINDOW_AGGSTEP );\n<line25>if( op==WINDOW_AGGINVERSE ){\n<line26>if( pMWin->eStart==TK_FOLLOWING ){\n<line27>windowCodeRangeTest(\n<line28>p, OP_Le, p->current.csr, regCountdown, p->start.csr, lblDone\n<line29>);\n<line30>}else{\n<line31>windowCodeRangeTest(\n<line32>p, OP_Ge, p->start.csr, regCountdown, p->current.csr, lblDone\n<line33>);\n<line34>}\n<line35>}else{\n<line36>windowCodeRangeTest(\n<line37>p, OP_Gt, p->end.csr, regCountdown, p->current.csr, lblDone\n<line38>);\n<line39>}\n<line40>}else{\n<line41>sqlite3VdbeAddOp3(v, OP_IfPos, regCountdown, lblDone, 1);\n<line42>VdbeCoverage(v);\n<line43>}\n<line44>}\n<line45>if( op==WINDOW_RETURN_ROW && pMWin->regStartRowid==0 ){\n<line46>windowAggFinal(p, 0);\n<line47>}\n<line48>addrContinue = sqlite3VdbeCurrentAddr(v);\n<line49>/* If this is a (RANGE BETWEEN a FOLLOWING AND b FOLLOWING) or\n<line50>** (RANGE BETWEEN b PRECEDING AND a PRECEDING) frame, ensure the\n<line51>** start cursor does not advance past the end cursor within the\n<line52>** temporary table. It otherwise might, if (a>b). Also ensure that,\n<line53>** if the input cursor is still finding new rows, that the end\n<line54>** cursor does not go past it to EOF. */\n<line55>if( pMWin->eStart==pMWin->eEnd && regCountdown\n<line56>&& pMWin->eFrmType==TK_RANGE\n<line57>){\n<line58>int regRowid1 = sqlite3GetTempReg(pParse);\n<line59>int regRowid2 = sqlite3GetTempReg(pParse);\n<line60>if( op==WINDOW_AGGINVERSE ){\n<line61>sqlite3VdbeAddOp2(v, OP_Rowid, p->start.csr, regRowid1);\n<line62>sqlite3VdbeAddOp2(v, OP_Rowid, p->end.csr, regRowid2);\n<line63>sqlite3VdbeAddOp3(v, OP_Ge, regRowid2, lblDone, regRowid1);\n<line64>VdbeCoverage(v);\n<line65>}else if( p->regRowid ){\n<line66>sqlite3VdbeAddOp2(v, OP_Rowid, p->end.csr, regRowid1);\n<line67>sqlite3VdbeAddOp3(v, OP_Ge, p->regRowid, lblDone, regRowid1);\n<line68>VdbeCoverageNeverNull(v);\n<line69>}\n<line70>sqlite3ReleaseTempReg(pParse, regRowid1);\n<line71>sqlite3ReleaseTempReg(pParse, regRowid2);\n<line72>assert( pMWin->eStart==TK_PRECEDING || pMWin->eStart==TK_FOLLOWING );\n<line73>}\n<line74>switch( op ){\n<line75>case WINDOW_RETURN_ROW:\n<line76>csr = p->current.csr;\n<line77>reg = p->current.reg;\n<line78>windowReturnOneRow(p);\n<line79>break;\n<line80>case WINDOW_AGGINVERSE:\n<line81>csr = p->start.csr;\n<line82>reg = p->start.reg;\n<line83>if( pMWin->regStartRowid ){\n<line84>assert( pMWin->regEndRowid );\n<line85>sqlite3VdbeAddOp2(v, OP_AddImm, pMWin->regStartRowid, 1);\n<line86>}else{\n<line87>windowAggStep(p, pMWin, csr, 1, p->regArg);\n<line88>}\n<line89>break;\n<line90>default:\n<line91>assert( op==WINDOW_AGGSTEP );\n<line92>csr = p->end.csr;\n<line93>reg = p->end.reg;\n<line94>if( pMWin->regStartRowid ){\n<line95>assert( pMWin->regEndRowid );\n<line96>sqlite3VdbeAddOp2(v, OP_AddImm, pMWin->regEndRowid, 1);\n<line97>}else{\n<line98>windowAggStep(p, pMWin, csr, 0, p->regArg);\n<line99>}\n<line100>break;\n<line101>}\n<line102>if( op==p->eDelete ){\n<line103>sqlite3VdbeAddOp1(v, OP_Delete, csr);\n<line104>sqlite3VdbeChangeP5(v, OPFLAG_SAVEPOSITION);\n<line105>}\n<line106>if( jumpOnEof ){\n<line107>sqlite3VdbeAddOp2(v, OP_Next, csr, sqlite3VdbeCurrentAddr(v)+2);\n<line108>VdbeCoverage(v);\n<line109>ret = sqlite3VdbeAddOp0(v, OP_Goto);\n<line110>}else{\n<line111>sqlite3VdbeAddOp2(v, OP_Next, csr, sqlite3VdbeCurrentAddr(v)+1+bPeer);\n<line112>VdbeCoverage(v);\n<line113>if( bPeer ){\n<line114>sqlite3VdbeAddOp2(v, OP_Goto, 0, lblDone);\n<line115>}\n<line116>}\n<line117>if( bPeer ){\n<line118>int nReg = (pMWin->pOrderBy ? pMWin->pOrderBy->nExpr : 0);\n<line119>int regTmp = (nReg ? sqlite3GetTempRange(pParse, nReg) : 0);\n<line120>windowReadPeerValues(p, csr, regTmp);\n<line121>windowIfNewPeer(pParse, pMWin->pOrderBy, regTmp, reg, addrContinue);\n<line122>sqlite3ReleaseTempRange(pParse, regTmp, nReg);\n<line123>}\n<line124>if( addrNextRange ){\n<line125>sqlite3VdbeAddOp2(v, OP_Goto, 0, addrNextRange);\n<line126>}\n<line127>sqlite3VdbeResolveLabel(v, lblDone);\n<line128>return ret;\n<line129>}
----------------------------------------
Function: windowExprGtZero
Content: <line0>static int windowExprGtZero(Parse *pParse, Expr *pExpr){\n<line1>int ret = 0;\n<line2>sqlite3 *db = pParse->db;\n<line3>sqlite3_value *pVal = 0;\n<line4>sqlite3ValueFromExpr(db, pExpr, db->enc, SQLITE_AFF_NUMERIC, &pVal);\n<line5>if( pVal && sqlite3_value_int(pVal)>0 ){\n<line6>ret = 1;\n<line7>}\n<line8>sqlite3ValueFree(pVal);\n<line9>return ret;\n<line10>}
----------------------------------------
Function: parserSyntaxError
Content: <line0>static void parserSyntaxError(Parse *pParse, Token *p){\n<line1>sqlite3ErrorMsg(pParse, "near \"%T\": syntax error", p);\n<line2>}
----------------------------------------
Function: disableLookaside
Content: <line0>static void disableLookaside(Parse *pParse){\n<line1>sqlite3 *db = pParse->db;\n<line2>pParse->disableLookaside++;\n<line3>#ifdef SQLITE_DEBUG\n<line4>pParse->isCreate = 1;\n<line5>#endif\n<line6>memset(&pParse->u1.cr, 0, sizeof(pParse->u1.cr));\n<line7>DisableLookaside;\n<line8>}
----------------------------------------
Function: parserDoubleLinkSelect
Content: <line0>static void parserDoubleLinkSelect(Parse *pParse, Select *p){\n<line1>assert( p!=0 );\n<line2>if( p->pPrior ){\n<line3>Select *pNext = 0, *pLoop = p;\n<line4>int mxSelect, cnt = 1;\n<line5>while(1){\n<line6>pLoop->pNext = pNext;\n<line7>pLoop->selFlags |= SF_Compound;\n<line8>pNext = pLoop;\n<line9>pLoop = pLoop->pPrior;\n<line10>if( pLoop==0 ) break;\n<line11>cnt++;\n<line12>if( pLoop->pOrderBy || pLoop->pLimit ){\n<line13>sqlite3ErrorMsg(pParse,"%s clause should come after %s not before",\n<line14>pLoop->pOrderBy!=0 ? "ORDER BY" : "LIMIT",\n<line15>sqlite3SelectOpName(pNext->op));\n<line16>break;\n<line17>}\n<line18>}\n<line19>if( (p->selFlags & (SF_MultiValue|SF_Values))==0\n<line20>&& (mxSelect = pParse->db->aLimit[SQLITE_LIMIT_COMPOUND_SELECT])>0\n<line21>&& cnt>mxSelect\n<line22>){\n<line23>sqlite3ErrorMsg(pParse, "too many terms in compound SELECT");\n<line24>}\n<line25>}\n<line26>}
----------------------------------------
Function: attachWithToSelect
Content: <line0>static Select *attachWithToSelect(Parse *pParse, Select *pSelect, With *pWith){\n<line1>if( pSelect ){\n<line2>pSelect->pWith = pWith;\n<line3>parserDoubleLinkSelect(pParse, pSelect);\n<line4>}else{\n<line5>sqlite3WithDelete(pParse->db, pWith);\n<line6>}\n<line7>return pSelect;\n<line8>}
----------------------------------------
Function: parserStackRealloc
Content: <line0>static void *parserStackRealloc(void *pOld, sqlite3_uint64 newSize){\n<line1>return sqlite3FaultSim(700) ? 0 : sqlite3_realloc(pOld, newSize);\n<line2>}
----------------------------------------
Function: tokenExpr
Content: <line0>static Expr *tokenExpr(Parse *pParse, int op, Token t){\n<line1>Expr *p = sqlite3DbMallocRawNN(pParse->db, sizeof(Expr)+t.n+1);\n<line2>if( p ){\n<line3>/* memset(p, 0, sizeof(Expr)); */\n<line4>p->op = (u8)op;\n<line5>p->affExpr = 0;\n<line6>p->flags = EP_Leaf;\n<line7>ExprClearVVAProperties(p);\n<line8>/* p->iAgg = -1; // Not required */\n<line9>p->pLeft = p->pRight = 0;\n<line10>p->pAggInfo = 0;\n<line11>memset(&p->x, 0, sizeof(p->x));\n<line12>memset(&p->y, 0, sizeof(p->y));\n<line13>p->op2 = 0;\n<line14>p->iTable = 0;\n<line15>p->iColumn = 0;\n<line16>p->u.zToken = (char*)&p[1];\n<line17>memcpy(p->u.zToken, t.z, t.n);\n<line18>p->u.zToken[t.n] = 0;\n<line19>p->w.iOfst = (int)(t.z - pParse->zTail);\n<line20>if( sqlite3Isquote(p->u.zToken[0]) ){\n<line21>sqlite3DequoteExpr(p);\n<line22>}\n<line23>#if SQLITE_MAX_EXPR_DEPTH>0\n<line24>p->nHeight = 1;\n<line25>#endif\n<line26>if( IN_RENAME_OBJECT ){\n<line27>return (Expr*)sqlite3RenameTokenMap(pParse, (void*)p, &t);\n<line28>}\n<line29>}\n<line30>return p;\n<line31>}
----------------------------------------
Function: binaryToUnaryIfNull
Content: <line0>static void binaryToUnaryIfNull(Parse *pParse, Expr *pY, Expr *pA, int op){\n<line1>sqlite3 *db = pParse->db;\n<line2>if( pA && pY && pY->op==TK_NULL && !IN_RENAME_OBJECT ){\n<line3>pA->op = (u8)op;\n<line4>sqlite3ExprDelete(db, pA->pRight);\n<line5>pA->pRight = 0;\n<line6>}\n<line7>}
----------------------------------------
Function: parserAddExprIdListTerm
Content: <line0>static ExprList *parserAddExprIdListTerm(\n<line1>Parse *pParse,\n<line2>ExprList *pPrior,\n<line3>Token *pIdToken,\n<line4>int hasCollate,\n<line5>int sortOrder\n<line6>){\n<line7>ExprList *p = sqlite3ExprListAppend(pParse, pPrior, 0);\n<line8>if( (hasCollate || sortOrder!=SQLITE_SO_UNDEFINED)\n<line9>&& pParse->db->init.busy==0\n<line10>){\n<line11>sqlite3ErrorMsg(pParse, "syntax error after column name \"%.*s\"",\n<line12>pIdToken->n, pIdToken->z);\n<line13>}\n<line14>sqlite3ExprListSetName(pParse, p, pIdToken, 1);\n<line15>return p;\n<line16>}
----------------------------------------
Function: yyGrowStack
Content: <line0>static int yyGrowStack(yyParser *p){\n<line1>int oldSize = 1 + (int)(p->yystackEnd - p->yystack);\n<line2>int newSize;\n<line3>int idx;\n<line4>yyStackEntry *pNew;\n<line5>newSize = oldSize*2 + 100;\n<line6>idx = (int)(p->yytos - p->yystack);\n<line7>if( p->yystack==p->yystk0 ){\n<line8>pNew = YYREALLOC(0, newSize*sizeof(pNew[0]));\n<line9>if( pNew==0 ) return 1;\n<line10>memcpy(pNew, p->yystack, oldSize*sizeof(pNew[0]));\n<line11>}else{\n<line12>pNew = YYREALLOC(p->yystack, newSize*sizeof(pNew[0]));\n<line13>if( pNew==0 ) return 1;\n<line14>}\n<line15>p->yystack = pNew;\n<line16>p->yytos = &p->yystack[idx];\n<line17>#ifndef NDEBUG\n<line18>if( yyTraceFILE ){\n<line19>fprintf(yyTraceFILE,"%sStack grows from %d to %d entries.\n",\n<line20>yyTracePrompt, oldSize, newSize);\n<line21>}\n<line22>#endif\n<line23>p->yystackEnd = &p->yystack[newSize-1];\n<line24>return 0;\n<line25>}
----------------------------------------
Function: yy_destructor
Content: <line0>static void yy_destructor(\n<line1>yyParser *yypParser,    /* The parser */\n<line2>YYCODETYPE yymajor,     /* Type code for object to destroy */\n<line3>YYMINORTYPE *yypminor   /* The object to be destroyed */\n<line4>){\n<line5>sqlite3ParserARG_FETCH\n<line6>sqlite3ParserCTX_FETCH\n<line7>switch( yymajor ){\n<line8>/* Here is inserted the actions which take place when a\n<line9>** terminal or non-terminal is destroyed.  This can happen\n<line10>** when the symbol is popped from the stack during a\n<line11>** reduce or during error processing or when a parser is\n<line12>** being destroyed before it is finished parsing.\n<line13>**\n<line14>** Note: during a reduce, the only symbols destroyed are those\n<line15>** which appear on the RHS of the rule, but which are *not* used\n<line16>** inside the C code.\n<line17>*/\n<line18>/********* Begin destructor definitions ***************************************/\n<line19>case 206: /* select */\n<line20>case 241: /* selectnowith */\n<line21>case 242: /* oneselect */\n<line22>case 254: /* values */\n<line23>case 256: /* mvalues */\n<line24>{\n<line25>sqlite3SelectDelete(pParse->db, (yypminor->yy637));\n<line26>}\n<line27>break;\n<line28>case 218: /* term */\n<line29>case 219: /* expr */\n<line30>case 248: /* where_opt */\n<line31>case 250: /* having_opt */\n<line32>case 270: /* where_opt_ret */\n<line33>case 281: /* case_operand */\n<line34>case 283: /* case_else */\n<line35>case 286: /* vinto */\n<line36>case 293: /* when_clause */\n<line37>case 298: /* key_opt */\n<line38>case 315: /* filter_clause */\n<line39>{\n<line40>sqlite3ExprDelete(pParse->db, (yypminor->yy590));\n<line41>}\n<line42>break;\n<line43>case 223: /* eidlist_opt */\n<line44>case 233: /* sortlist */\n<line45>case 234: /* eidlist */\n<line46>case 246: /* selcollist */\n<line47>case 249: /* groupby_opt */\n<line48>case 251: /* orderby_opt */\n<line49>case 255: /* nexprlist */\n<line50>case 257: /* sclp */\n<line51>case 264: /* exprlist */\n<line52>case 271: /* setlist */\n<line53>case 280: /* paren_exprlist */\n<line54>case 282: /* case_exprlist */\n<line55>case 314: /* part_opt */\n<line56>{\n<line57>sqlite3ExprListDelete(pParse->db, (yypminor->yy402));\n<line58>}\n<line59>break;\n<line60>case 240: /* fullname */\n<line61>case 247: /* from */\n<line62>case 259: /* seltablist */\n<line63>case 260: /* stl_prefix */\n<line64>case 265: /* xfullname */\n<line65>{\n<line66>sqlite3SrcListDelete(pParse->db, (yypminor->yy563));\n<line67>}\n<line68>break;\n<line69>case 243: /* wqlist */\n<line70>{\n<line71>sqlite3WithDelete(pParse->db, (yypminor->yy125));\n<line72>}\n<line73>break;\n<line74>case 253: /* window_clause */\n<line75>case 310: /* windowdefn_list */\n<line76>{\n<line77>sqlite3WindowListDelete(pParse->db, (yypminor->yy483));\n<line78>}\n<line79>break;\n<line80>case 266: /* idlist */\n<line81>case 273: /* idlist_opt */\n<line82>{\n<line83>sqlite3IdListDelete(pParse->db, (yypminor->yy204));\n<line84>}\n<line85>break;\n<line86>case 276: /* filter_over */\n<line87>case 311: /* windowdefn */\n<line88>case 312: /* window */\n<line89>case 313: /* frame_opt */\n<line90>case 316: /* over_clause */\n<line91>{\n<line92>sqlite3WindowDelete(pParse->db, (yypminor->yy483));\n<line93>}\n<line94>break;\n<line95>case 289: /* trigger_cmd_list */\n<line96>case 294: /* trigger_cmd */\n<line97>{\n<line98>sqlite3DeleteTriggerStep(pParse->db, (yypminor->yy319));\n<line99>}\n<line100>break;\n<line101>case 291: /* trigger_event */\n<line102>{\n<line103>sqlite3IdListDelete(pParse->db, (yypminor->yy28).b);\n<line104>}\n<line105>break;\n<line106>case 318: /* frame_bound */\n<line107>case 319: /* frame_bound_s */\n<line108>case 320: /* frame_bound_e */\n<line109>{\n<line110>sqlite3ExprDelete(pParse->db, (yypminor->yy205).pExpr);\n<line111>}\n<line112>break;\n<line113>/********* End destructor definitions *****************************************/\n<line114>default:  break;   /* If no destructor action specified: do nothing */\n<line115>}\n<line116>}
----------------------------------------
Function: yy_pop_parser_stack
Content: <line0>static void yy_pop_parser_stack(yyParser *pParser){\n<line1>yyStackEntry *yytos;\n<line2>assert( pParser->yytos!=0 );\n<line3>assert( pParser->yytos > pParser->yystack );\n<line4>yytos = pParser->yytos--;\n<line5>#ifndef NDEBUG\n<line6>if( yyTraceFILE ){\n<line7>fprintf(yyTraceFILE,"%sPopping %s\n",\n<line8>yyTracePrompt,\n<line9>yyTokenName[yytos->major]);\n<line10>}\n<line11>#endif\n<line12>yy_destructor(pParser, yytos->major, &yytos->minor);\n<line13>}
----------------------------------------
Function: yy_find_shift_action
Content: <line0>static YYACTIONTYPE yy_find_shift_action(\n<line1>YYCODETYPE iLookAhead,    /* The look-ahead token */\n<line2>YYACTIONTYPE stateno      /* Current state number */\n<line3>){\n<line4>int i;\n<line5>if( stateno>YY_MAX_SHIFT ) return stateno;\n<line6>assert( stateno <= YY_SHIFT_COUNT );\n<line7>#if defined(YYCOVERAGE)\n<line8>yycoverage[stateno][iLookAhead] = 1;\n<line9>#endif\n<line10>do{\n<line11>i = yy_shift_ofst[stateno];\n<line12>assert( i>=0 );\n<line13>assert( i<=YY_ACTTAB_COUNT );\n<line14>assert( i+YYNTOKEN<=(int)YY_NLOOKAHEAD );\n<line15>assert( iLookAhead!=YYNOCODE );\n<line16>assert( iLookAhead < YYNTOKEN );\n<line17>i += iLookAhead;\n<line18>assert( i<(int)YY_NLOOKAHEAD );\n<line19>if( yy_lookahead[i]!=iLookAhead ){\n<line20>#ifdef YYFALLBACK\n<line21>YYCODETYPE iFallback;            /* Fallback token */\n<line22>assert( iLookAhead<sizeof(yyFallback)/sizeof(yyFallback[0]) );\n<line23>iFallback = yyFallback[iLookAhead];\n<line24>if( iFallback!=0 ){\n<line25>#ifndef NDEBUG\n<line26>if( yyTraceFILE ){\n<line27>fprintf(yyTraceFILE, "%sFALLBACK %s => %s\n",\n<line28>yyTracePrompt, yyTokenName[iLookAhead], yyTokenName[iFallback]);\n<line29>}\n<line30>#endif\n<line31>assert( yyFallback[iFallback]==0 ); /* Fallback loop must terminate */\n<line32>iLookAhead = iFallback;\n<line33>continue;\n<line34>}\n<line35>#endif\n<line36>#ifdef YYWILDCARD\n<line37>{\n<line38>int j = i - iLookAhead + YYWILDCARD;\n<line39>assert( j<(int)(sizeof(yy_lookahead)/sizeof(yy_lookahead[0])) );\n<line40>if( yy_lookahead[j]==YYWILDCARD && iLookAhead>0 ){\n<line41>#ifndef NDEBUG\n<line42>if( yyTraceFILE ){\n<line43>fprintf(yyTraceFILE, "%sWILDCARD %s => %s\n",\n<line44>yyTracePrompt, yyTokenName[iLookAhead],\n<line45>yyTokenName[YYWILDCARD]);\n<line46>}\n<line47>#endif /* NDEBUG */\n<line48>return yy_action[j];\n<line49>}\n<line50>}\n<line51>#endif /* YYWILDCARD */\n<line52>return yy_default[stateno];\n<line53>}else{\n<line54>assert( i>=0 && i<(int)(sizeof(yy_action)/sizeof(yy_action[0])) );\n<line55>return yy_action[i];\n<line56>}\n<line57>}while(1);\n<line58>}
----------------------------------------
Function: yy_find_reduce_action
Content: <line0>static YYACTIONTYPE yy_find_reduce_action(\n<line1>YYACTIONTYPE stateno,     /* Current state number */\n<line2>YYCODETYPE iLookAhead     /* The look-ahead token */\n<line3>){\n<line4>int i;\n<line5>#ifdef YYERRORSYMBOL\n<line6>if( stateno>YY_REDUCE_COUNT ){\n<line7>return yy_default[stateno];\n<line8>}\n<line9>#else\n<line10>assert( stateno<=YY_REDUCE_COUNT );\n<line11>#endif\n<line12>i = yy_reduce_ofst[stateno];\n<line13>assert( iLookAhead!=YYNOCODE );\n<line14>i += iLookAhead;\n<line15>#ifdef YYERRORSYMBOL\n<line16>if( i<0 || i>=YY_ACTTAB_COUNT || yy_lookahead[i]!=iLookAhead ){\n<line17>return yy_default[stateno];\n<line18>}\n<line19>#else\n<line20>assert( i>=0 && i<YY_ACTTAB_COUNT );\n<line21>assert( yy_lookahead[i]==iLookAhead );\n<line22>#endif\n<line23>return yy_action[i];\n<line24>}
----------------------------------------
Function: yyStackOverflow
Content: <line0>static void yyStackOverflow(yyParser *yypParser){\n<line1>sqlite3ParserARG_FETCH\n<line2>sqlite3ParserCTX_FETCH\n<line3>#ifndef NDEBUG\n<line4>if( yyTraceFILE ){\n<line5>fprintf(yyTraceFILE,"%sStack Overflow!\n",yyTracePrompt);\n<line6>}\n<line7>#endif\n<line8>while( yypParser->yytos>yypParser->yystack ) yy_pop_parser_stack(yypParser);\n<line9>/* Here code is inserted which will execute if the parser\n<line10>** stack every overflows */\n<line11>/******** Begin %stack_overflow code ******************************************/\n<line12>sqlite3OomFault(pParse->db);\n<line13>/******** End %stack_overflow code ********************************************/\n<line14>sqlite3ParserARG_STORE /* Suppress warning about unused %extra_argument var */\n<line15>sqlite3ParserCTX_STORE\n<line16>}
----------------------------------------
Function: yy_shift
Content: <line0>static void yy_shift(\n<line1>yyParser *yypParser,          /* The parser to be shifted */\n<line2>YYACTIONTYPE yyNewState,      /* The new state to shift in */\n<line3>YYCODETYPE yyMajor,           /* The major token to shift in */\n<line4>sqlite3ParserTOKENTYPE yyMinor        /* The minor token to shift in */\n<line5>){\n<line6>yyStackEntry *yytos;\n<line7>yypParser->yytos++;\n<line8>#ifdef YYTRACKMAXSTACKDEPTH\n<line9>if( (int)(yypParser->yytos - yypParser->yystack)>yypParser->yyhwm ){\n<line10>yypParser->yyhwm++;\n<line11>assert( yypParser->yyhwm == (int)(yypParser->yytos - yypParser->yystack) );\n<line12>}\n<line13>#endif\n<line14>yytos = yypParser->yytos;\n<line15>if( yytos>yypParser->yystackEnd ){\n<line16>if( yyGrowStack(yypParser) ){\n<line17>yypParser->yytos--;\n<line18>yyStackOverflow(yypParser);\n<line19>return;\n<line20>}\n<line21>yytos = yypParser->yytos;\n<line22>assert( yytos <= yypParser->yystackEnd );\n<line23>}\n<line24>if( yyNewState > YY_MAX_SHIFT ){\n<line25>yyNewState += YY_MIN_REDUCE - YY_MIN_SHIFTREDUCE;\n<line26>}\n<line27>yytos->stateno = yyNewState;\n<line28>yytos->major = yyMajor;\n<line29>yytos->minor.yy0 = yyMinor;\n<line30>yyTraceShift(yypParser, yyNewState, "Shift");\n<line31>}
----------------------------------------
Function: yy_reduce
Content: <line0>static YYACTIONTYPE yy_reduce(\n<line1>yyParser *yypParser,         /* The parser */\n<line2>unsigned int yyruleno,       /* Number of the rule by which to reduce */\n<line3>int yyLookahead,             /* Lookahead token, or YYNOCODE if none */\n<line4>sqlite3ParserTOKENTYPE yyLookaheadToken  /* Value of the lookahead token */\n<line5>sqlite3ParserCTX_PDECL                   /* %extra_context */\n<line6>){\n<line7>int yygoto;                     /* The next state */\n<line8>YYACTIONTYPE yyact;             /* The next action */\n<line9>yyStackEntry *yymsp;            /* The top of the parser's stack */\n<line10>int yysize;                     /* Amount to pop the stack */\n<line11>sqlite3ParserARG_FETCH\n<line12>(void)yyLookahead;\n<line13>(void)yyLookaheadToken;\n<line14>yymsp = yypParser->yytos;\n<line15>switch( yyruleno ){\n<line16>/* Beginning here are the reduction cases.  A typical example\n<line17>** follows:\n<line18>**   case 0:\n<line19>**  #line <lineno> <grammarfile>\n<line20>**     { ... }           // User supplied code\n<line21>**  #line <lineno> <thisfile>\n<line22>**     break;\n<line23>*/\n<line24>/********** Begin reduce actions **********************************************/\n<line25>YYMINORTYPE yylhsminor;\n<line26>case 0: /* explain ::= EXPLAIN */\n<line27>{ if( pParse->pReprepare==0 ) pParse->explain = 1; }\n<line28>break;\n<line29>case 1: /* explain ::= EXPLAIN QUERY PLAN */\n<line30>{ if( pParse->pReprepare==0 ) pParse->explain = 2; }\n<line31>break;\n<line32>case 2: /* cmdx ::= cmd */\n<line33>{ sqlite3FinishCoding(pParse); }\n<line34>break;\n<line35>case 3: /* cmd ::= BEGIN transtype trans_opt */\n<line36>{sqlite3BeginTransaction(pParse, yymsp[-1].minor.yy502);}\n<line37>break;\n<line38>case 4: /* transtype ::= */\n<line39>{yymsp[1].minor.yy502 = TK_DEFERRED;}\n<line40>break;\n<line41>case 5: /* transtype ::= DEFERRED */\n<line42>case 6: /* transtype ::= IMMEDIATE */ yytestcase(yyruleno==6);\n<line43>case 7: /* transtype ::= EXCLUSIVE */ yytestcase(yyruleno==7);\n<line44>case 324: /* range_or_rows ::= RANGE|ROWS|GROUPS */ yytestcase(yyruleno==324);\n<line45>{yymsp[0].minor.yy502 = yymsp[0].major; /*A-overwrites-X*/}\n<line46>break;\n<line47>case 8: /* cmd ::= COMMIT|END trans_opt */\n<line48>case 9: /* cmd ::= ROLLBACK trans_opt */ yytestcase(yyruleno==9);\n<line49>{sqlite3EndTransaction(pParse,yymsp[-1].major);}\n<line50>break;\n<line51>case 10: /* cmd ::= SAVEPOINT nm */\n<line52>{\n<line53>sqlite3Savepoint(pParse, SAVEPOINT_BEGIN, &yymsp[0].minor.yy0);\n<line54>}\n<line55>break;\n<line56>case 11: /* cmd ::= RELEASE savepoint_opt nm */\n<line57>{\n<line58>sqlite3Savepoint(pParse, SAVEPOINT_RELEASE, &yymsp[0].minor.yy0);\n<line59>}\n<line60>break;\n<line61>case 12: /* cmd ::= ROLLBACK trans_opt TO savepoint_opt nm */\n<line62>{\n<line63>sqlite3Savepoint(pParse, SAVEPOINT_ROLLBACK, &yymsp[0].minor.yy0);\n<line64>}\n<line65>break;\n<line66>case 13: /* create_table ::= createkw temp TABLE ifnotexists nm dbnm */\n<line67>{\n<line68>sqlite3StartTable(pParse,&yymsp[-1].minor.yy0,&yymsp[0].minor.yy0,yymsp[-4].minor.yy502,0,0,yymsp[-2].minor.yy502);\n<line69>}\n<line70>break;\n<line71>case 14: /* createkw ::= CREATE */\n<line72>{\n<line73>disableLookaside(pParse);\n<line74>}\n<line75>break;\n<line76>case 15: /* ifnotexists ::= */\n<line77>case 18: /* temp ::= */ yytestcase(yyruleno==18);\n<line78>case 47: /* autoinc ::= */ yytestcase(yyruleno==47);\n<line79>case 62: /* init_deferred_pred_opt ::= */ yytestcase(yyruleno==62);\n<line80>case 72: /* defer_subclause_opt ::= */ yytestcase(yyruleno==72);\n<line81>case 81: /* ifexists ::= */ yytestcase(yyruleno==81);\n<line82>case 100: /* distinct ::= */ yytestcase(yyruleno==100);\n<line83>case 246: /* collate ::= */ yytestcase(yyruleno==246);\n<line84>{yymsp[1].minor.yy502 = 0;}\n<line85>break;\n<line86>case 16: /* ifnotexists ::= IF NOT EXISTS */\n<line87>{yymsp[-2].minor.yy502 = 1;}\n<line88>break;\n<line89>case 17: /* temp ::= TEMP */\n<line90>{yymsp[0].minor.yy502 = pParse->db->init.busy==0;}\n<line91>break;\n<line92>case 19: /* create_table_args ::= LP columnlist conslist_opt RP table_option_set */\n<line93>{\n<line94>sqlite3EndTable(pParse,&yymsp[-2].minor.yy0,&yymsp[-1].minor.yy0,yymsp[0].minor.yy9,0);\n<line95>}\n<line96>break;\n<line97>case 20: /* create_table_args ::= AS select */\n<line98>{\n<line99>sqlite3EndTable(pParse,0,0,0,yymsp[0].minor.yy637);\n<line100>sqlite3SelectDelete(pParse->db, yymsp[0].minor.yy637);\n<line101>}\n<line102>break;\n<line103>case 21: /* table_option_set ::= */\n<line104>{yymsp[1].minor.yy9 = 0;}\n<line105>break;\n<line106>case 22: /* table_option_set ::= table_option_set COMMA table_option */\n<line107>{yylhsminor.yy9 = yymsp[-2].minor.yy9|yymsp[0].minor.yy9;}\n<line108>yymsp[-2].minor.yy9 = yylhsminor.yy9;\n<line109>break;\n<line110>case 23: /* table_option ::= WITHOUT nm */\n<line111>{\n<line112>if( yymsp[0].minor.yy0.n==5 && sqlite3_strnicmp(yymsp[0].minor.yy0.z,"rowid",5)==0 ){\n<line113>yymsp[-1].minor.yy9 = TF_WithoutRowid | TF_NoVisibleRowid;\n<line114>}else{\n<line115>yymsp[-1].minor.yy9 = 0;\n<line116>sqlite3ErrorMsg(pParse, "unknown table option: %.*s", yymsp[0].minor.yy0.n, yymsp[0].minor.yy0.z);\n<line117>}\n<line118>}\n<line119>break;\n<line120>case 24: /* table_option ::= nm */\n<line121>{\n<line122>if( yymsp[0].minor.yy0.n==6 && sqlite3_strnicmp(yymsp[0].minor.yy0.z,"strict",6)==0 ){\n<line123>yylhsminor.yy9 = TF_Strict;\n<line124>}else{\n<line125>yylhsminor.yy9 = 0;\n<line126>sqlite3ErrorMsg(pParse, "unknown table option: %.*s", yymsp[0].minor.yy0.n, yymsp[0].minor.yy0.z);\n<line127>}\n<line128>}\n<line129>yymsp[0].minor.yy9 = yylhsminor.yy9;\n<line130>break;\n<line131>case 25: /* columnname ::= nm typetoken */\n<line132>{sqlite3AddColumn(pParse,yymsp[-1].minor.yy0,yymsp[0].minor.yy0);}\n<line133>break;\n<line134>case 26: /* typetoken ::= */\n<line135>case 65: /* conslist_opt ::= */ yytestcase(yyruleno==65);\n<line136>case 106: /* as ::= */ yytestcase(yyruleno==106);\n<line137>{yymsp[1].minor.yy0.n = 0; yymsp[1].minor.yy0.z = 0;}\n<line138>break;\n<line139>case 27: /* typetoken ::= typename LP signed RP */\n<line140>{\n<line141>yymsp[-3].minor.yy0.n = (int)(&yymsp[0].minor.yy0.z[yymsp[0].minor.yy0.n] - yymsp[-3].minor.yy0.z);\n<line142>}\n<line143>break;\n<line144>case 28: /* typetoken ::= typename LP signed COMMA signed RP */\n<line145>{\n<line146>yymsp[-5].minor.yy0.n = (int)(&yymsp[0].minor.yy0.z[yymsp[0].minor.yy0.n] - yymsp[-5].minor.yy0.z);\n<line147>}\n<line148>break;\n<line149>case 29: /* typename ::= typename ID|STRING */\n<line150>{yymsp[-1].minor.yy0.n=yymsp[0].minor.yy0.n+(int)(yymsp[0].minor.yy0.z-yymsp[-1].minor.yy0.z);}\n<line151>break;\n<line152>case 30: /* scanpt ::= */\n<line153>{\n<line154>assert( yyLookahead!=YYNOCODE );\n<line155>yymsp[1].minor.yy342 = yyLookaheadToken.z;\n<line156>}\n<line157>break;\n<line158>case 31: /* scantok ::= */\n<line159>{\n<line160>assert( yyLookahead!=YYNOCODE );\n<line161>yymsp[1].minor.yy0 = yyLookaheadToken;\n<line162>}\n<line163>break;\n<line164>case 32: /* ccons ::= CONSTRAINT nm */\n<line165>case 67: /* tcons ::= CONSTRAINT nm */ yytestcase(yyruleno==67);\n<line166>{ASSERT_IS_CREATE; pParse->u1.cr.constraintName = yymsp[0].minor.yy0;}\n<line167>break;\n<line168>case 33: /* ccons ::= DEFAULT scantok term */\n<line169>{sqlite3AddDefaultValue(pParse,yymsp[0].minor.yy590,yymsp[-1].minor.yy0.z,&yymsp[-1].minor.yy0.z[yymsp[-1].minor.yy0.n]);}\n<line170>break;\n<line171>case 34: /* ccons ::= DEFAULT LP expr RP */\n<line172>{sqlite3AddDefaultValue(pParse,yymsp[-1].minor.yy590,yymsp[-2].minor.yy0.z+1,yymsp[0].minor.yy0.z);}\n<line173>break;\n<line174>case 35: /* ccons ::= DEFAULT PLUS scantok term */\n<line175>{sqlite3AddDefaultValue(pParse,yymsp[0].minor.yy590,yymsp[-2].minor.yy0.z,&yymsp[-1].minor.yy0.z[yymsp[-1].minor.yy0.n]);}\n<line176>break;\n<line177>case 36: /* ccons ::= DEFAULT MINUS scantok term */\n<line178>{\n<line179>Expr *p = sqlite3PExpr(pParse, TK_UMINUS, yymsp[0].minor.yy590, 0);\n<line180>sqlite3AddDefaultValue(pParse,p,yymsp[-2].minor.yy0.z,&yymsp[-1].minor.yy0.z[yymsp[-1].minor.yy0.n]);\n<line181>}\n<line182>break;\n<line183>case 37: /* ccons ::= DEFAULT scantok ID|INDEXED */\n<line184>{\n<line185>Expr *p = tokenExpr(pParse, TK_STRING, yymsp[0].minor.yy0);\n<line186>if( p ){\n<line187>sqlite3ExprIdToTrueFalse(p);\n<line188>testcase( p->op==TK_TRUEFALSE && sqlite3ExprTruthValue(p) );\n<line189>}\n<line190>sqlite3AddDefaultValue(pParse,p,yymsp[0].minor.yy0.z,yymsp[0].minor.yy0.z+yymsp[0].minor.yy0.n);\n<line191>}\n<line192>break;\n<line193>case 38: /* ccons ::= NOT NULL onconf */\n<line194>{sqlite3AddNotNull(pParse, yymsp[0].minor.yy502);}\n<line195>break;\n<line196>case 39: /* ccons ::= PRIMARY KEY sortorder onconf autoinc */\n<line197>{sqlite3AddPrimaryKey(pParse,0,yymsp[-1].minor.yy502,yymsp[0].minor.yy502,yymsp[-2].minor.yy502);}\n<line198>break;\n<line199>case 40: /* ccons ::= UNIQUE onconf */\n<line200>{sqlite3CreateIndex(pParse,0,0,0,0,yymsp[0].minor.yy502,0,0,0,0,\n<line201>SQLITE_IDXTYPE_UNIQUE);}\n<line202>break;\n<line203>case 41: /* ccons ::= CHECK LP expr RP */\n<line204>{sqlite3AddCheckConstraint(pParse,yymsp[-1].minor.yy590,yymsp[-2].minor.yy0.z,yymsp[0].minor.yy0.z);}\n<line205>break;\n<line206>case 42: /* ccons ::= REFERENCES nm eidlist_opt refargs */\n<line207>{sqlite3CreateForeignKey(pParse,0,&yymsp[-2].minor.yy0,yymsp[-1].minor.yy402,yymsp[0].minor.yy502);}\n<line208>break;\n<line209>case 43: /* ccons ::= defer_subclause */\n<line210>{sqlite3DeferForeignKey(pParse,yymsp[0].minor.yy502);}\n<line211>break;\n<line212>case 44: /* ccons ::= COLLATE ID|STRING */\n<line213>{sqlite3AddCollateType(pParse, &yymsp[0].minor.yy0);}\n<line214>break;\n<line215>case 45: /* generated ::= LP expr RP */\n<line216>{sqlite3AddGenerated(pParse,yymsp[-1].minor.yy590,0);}\n<line217>break;\n<line218>case 46: /* generated ::= LP expr RP ID */\n<line219>{sqlite3AddGenerated(pParse,yymsp[-2].minor.yy590,&yymsp[0].minor.yy0);}\n<line220>break;\n<line221>case 48: /* autoinc ::= AUTOINCR */\n<line222>{yymsp[0].minor.yy502 = 1;}\n<line223>break;\n<line224>case 49: /* refargs ::= */\n<line225>{ yymsp[1].minor.yy502 = OE_None*0x0101; /* EV: R-19803-45884 */}\n<line226>break;\n<line227>case 50: /* refargs ::= refargs refarg */\n<line228>{ yymsp[-1].minor.yy502 = (yymsp[-1].minor.yy502 & ~yymsp[0].minor.yy481.mask) | yymsp[0].minor.yy481.value; }\n<line229>break;\n<line230>case 51: /* refarg ::= MATCH nm */\n<line231>{ yymsp[-1].minor.yy481.value = 0;     yymsp[-1].minor.yy481.mask = 0x000000; }\n<line232>break;\n<line233>case 52: /* refarg ::= ON INSERT refact */\n<line234>{ yymsp[-2].minor.yy481.value = 0;     yymsp[-2].minor.yy481.mask = 0x000000; }\n<line235>break;\n<line236>case 53: /* refarg ::= ON DELETE refact */\n<line237>{ yymsp[-2].minor.yy481.value = yymsp[0].minor.yy502;     yymsp[-2].minor.yy481.mask = 0x0000ff; }\n<line238>break;\n<line239>case 54: /* refarg ::= ON UPDATE refact */\n<line240>{ yymsp[-2].minor.yy481.value = yymsp[0].minor.yy502<<8;  yymsp[-2].minor.yy481.mask = 0x00ff00; }\n<line241>break;\n<line242>case 55: /* refact ::= SET NULL */\n<line243>{ yymsp[-1].minor.yy502 = OE_SetNull;  /* EV: R-33326-45252 */}\n<line244>break;\n<line245>case 56: /* refact ::= SET DEFAULT */\n<line246>{ yymsp[-1].minor.yy502 = OE_SetDflt;  /* EV: R-33326-45252 */}\n<line247>break;\n<line248>case 57: /* refact ::= CASCADE */\n<line249>{ yymsp[0].minor.yy502 = OE_Cascade;  /* EV: R-33326-45252 */}\n<line250>break;\n<line251>case 58: /* refact ::= RESTRICT */\n<line252>{ yymsp[0].minor.yy502 = OE_Restrict; /* EV: R-33326-45252 */}\n<line253>break;\n<line254>case 59: /* refact ::= NO ACTION */\n<line255>{ yymsp[-1].minor.yy502 = OE_None;     /* EV: R-33326-45252 */}\n<line256>break;\n<line257>case 60: /* defer_subclause ::= NOT DEFERRABLE init_deferred_pred_opt */\n<line258>{yymsp[-2].minor.yy502 = 0;}\n<line259>break;\n<line260>case 61: /* defer_subclause ::= DEFERRABLE init_deferred_pred_opt */\n<line261>case 76: /* orconf ::= OR resolvetype */ yytestcase(yyruleno==76);\n<line262>case 173: /* insert_cmd ::= INSERT orconf */ yytestcase(yyruleno==173);\n<line263>{yymsp[-1].minor.yy502 = yymsp[0].minor.yy502;}\n<line264>break;\n<line265>case 63: /* init_deferred_pred_opt ::= INITIALLY DEFERRED */\n<line266>case 80: /* ifexists ::= IF EXISTS */ yytestcase(yyruleno==80);\n<line267>case 219: /* between_op ::= NOT BETWEEN */ yytestcase(yyruleno==219);\n<line268>case 222: /* in_op ::= NOT IN */ yytestcase(yyruleno==222);\n<line269>case 247: /* collate ::= COLLATE ID|STRING */ yytestcase(yyruleno==247);\n<line270>{yymsp[-1].minor.yy502 = 1;}\n<line271>break;\n<line272>case 64: /* init_deferred_pred_opt ::= INITIALLY IMMEDIATE */\n<line273>{yymsp[-1].minor.yy502 = 0;}\n<line274>break;\n<line275>case 66: /* tconscomma ::= COMMA */\n<line276>{ASSERT_IS_CREATE; pParse->u1.cr.constraintName.n = 0;}\n<line277>break;\n<line278>case 68: /* tcons ::= PRIMARY KEY LP sortlist autoinc RP onconf */\n<line279>{sqlite3AddPrimaryKey(pParse,yymsp[-3].minor.yy402,yymsp[0].minor.yy502,yymsp[-2].minor.yy502,0);}\n<line280>break;\n<line281>case 69: /* tcons ::= UNIQUE LP sortlist RP onconf */\n<line282>{sqlite3CreateIndex(pParse,0,0,0,yymsp[-2].minor.yy402,yymsp[0].minor.yy502,0,0,0,0,\n<line283>SQLITE_IDXTYPE_UNIQUE);}\n<line284>break;\n<line285>case 70: /* tcons ::= CHECK LP expr RP onconf */\n<line286>{sqlite3AddCheckConstraint(pParse,yymsp[-2].minor.yy590,yymsp[-3].minor.yy0.z,yymsp[-1].minor.yy0.z);}\n<line287>break;\n<line288>case 71: /* tcons ::= FOREIGN KEY LP eidlist RP REFERENCES nm eidlist_opt refargs defer_subclause_opt */\n<line289>{\n<line290>sqlite3CreateForeignKey(pParse, yymsp[-6].minor.yy402, &yymsp[-3].minor.yy0, yymsp[-2].minor.yy402, yymsp[-1].minor.yy502);\n<line291>sqlite3DeferForeignKey(pParse, yymsp[0].minor.yy502);\n<line292>}\n<line293>break;\n<line294>case 73: /* onconf ::= */\n<line295>case 75: /* orconf ::= */ yytestcase(yyruleno==75);\n<line296>{yymsp[1].minor.yy502 = OE_Default;}\n<line297>break;\n<line298>case 74: /* onconf ::= ON CONFLICT resolvetype */\n<line299>{yymsp[-2].minor.yy502 = yymsp[0].minor.yy502;}\n<line300>break;\n<line301>case 77: /* resolvetype ::= IGNORE */\n<line302>{yymsp[0].minor.yy502 = OE_Ignore;}\n<line303>break;\n<line304>case 78: /* resolvetype ::= REPLACE */\n<line305>case 174: /* insert_cmd ::= REPLACE */ yytestcase(yyruleno==174);\n<line306>{yymsp[0].minor.yy502 = OE_Replace;}\n<line307>break;\n<line308>case 79: /* cmd ::= DROP TABLE ifexists fullname */\n<line309>{\n<line310>sqlite3DropTable(pParse, yymsp[0].minor.yy563, 0, yymsp[-1].minor.yy502);\n<line311>}\n<line312>break;\n<line313>case 82: /* cmd ::= createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS select */\n<line314>{\n<line315>sqlite3CreateView(pParse, &yymsp[-8].minor.yy0, &yymsp[-4].minor.yy0, &yymsp[-3].minor.yy0, yymsp[-2].minor.yy402, yymsp[0].minor.yy637, yymsp[-7].minor.yy502, yymsp[-5].minor.yy502);\n<line316>}\n<line317>break;\n<line318>case 83: /* cmd ::= DROP VIEW ifexists fullname */\n<line319>{\n<line320>sqlite3DropTable(pParse, yymsp[0].minor.yy563, 1, yymsp[-1].minor.yy502);\n<line321>}\n<line322>break;\n<line323>case 84: /* cmd ::= select */\n<line324>{\n<line325>SelectDest dest = {SRT_Output, 0, 0, 0, 0, 0, 0};\n<line326>if( (pParse->db->mDbFlags & DBFLAG_EncodingFixed)!=0\n<line327>|| sqlite3ReadSchema(pParse)==SQLITE_OK\n<line328>){\n<line329>sqlite3Select(pParse, yymsp[0].minor.yy637, &dest);\n<line330>}\n<line331>sqlite3SelectDelete(pParse->db, yymsp[0].minor.yy637);\n<line332>}\n<line333>break;\n<line334>case 85: /* select ::= WITH wqlist selectnowith */\n<line335>{yymsp[-2].minor.yy637 = attachWithToSelect(pParse,yymsp[0].minor.yy637,yymsp[-1].minor.yy125);}\n<line336>break;\n<line337>case 86: /* select ::= WITH RECURSIVE wqlist selectnowith */\n<line338>{yymsp[-3].minor.yy637 = attachWithToSelect(pParse,yymsp[0].minor.yy637,yymsp[-1].minor.yy125);}\n<line339>break;\n<line340>case 87: /* select ::= selectnowith */\n<line341>{\n<line342>Select *p = yymsp[0].minor.yy637;\n<line343>if( p ){\n<line344>parserDoubleLinkSelect(pParse, p);\n<line345>}\n<line346>}\n<line347>break;\n<line348>case 88: /* selectnowith ::= selectnowith multiselect_op oneselect */\n<line349>{\n<line350>Select *pRhs = yymsp[0].minor.yy637;\n<line351>Select *pLhs = yymsp[-2].minor.yy637;\n<line352>if( pRhs && pRhs->pPrior ){\n<line353>SrcList *pFrom;\n<line354>Token x;\n<line355>x.n = 0;\n<line356>parserDoubleLinkSelect(pParse, pRhs);\n<line357>pFrom = sqlite3SrcListAppendFromTerm(pParse,0,0,0,&x,pRhs,0);\n<line358>pRhs = sqlite3SelectNew(pParse,0,pFrom,0,0,0,0,0,0);\n<line359>}\n<line360>if( pRhs ){\n<line361>pRhs->op = (u8)yymsp[-1].minor.yy502;\n<line362>pRhs->pPrior = pLhs;\n<line363>if( ALWAYS(pLhs) ) pLhs->selFlags &= ~(u32)SF_MultiValue;\n<line364>pRhs->selFlags &= ~(u32)SF_MultiValue;\n<line365>if( yymsp[-1].minor.yy502!=TK_ALL ) pParse->hasCompound = 1;\n<line366>}else{\n<line367>sqlite3SelectDelete(pParse->db, pLhs);\n<line368>}\n<line369>yymsp[-2].minor.yy637 = pRhs;\n<line370>}\n<line371>break;\n<line372>case 89: /* multiselect_op ::= UNION */\n<line373>case 91: /* multiselect_op ::= EXCEPT|INTERSECT */ yytestcase(yyruleno==91);\n<line374>{yymsp[0].minor.yy502 = yymsp[0].major; /*A-overwrites-OP*/}\n<line375>break;\n<line376>case 90: /* multiselect_op ::= UNION ALL */\n<line377>{yymsp[-1].minor.yy502 = TK_ALL;}\n<line378>break;\n<line379>case 92: /* oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt */\n<line380>{\n<line381>yymsp[-8].minor.yy637 = sqlite3SelectNew(pParse,yymsp[-6].minor.yy402,yymsp[-5].minor.yy563,yymsp[-4].minor.yy590,yymsp[-3].minor.yy402,yymsp[-2].minor.yy590,yymsp[-1].minor.yy402,yymsp[-7].minor.yy502,yymsp[0].minor.yy590);\n<line382>}\n<line383>break;\n<line384>case 93: /* oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt window_clause orderby_opt limit_opt */\n<line385>{\n<line386>yymsp[-9].minor.yy637 = sqlite3SelectNew(pParse,yymsp[-7].minor.yy402,yymsp[-6].minor.yy563,yymsp[-5].minor.yy590,yymsp[-4].minor.yy402,yymsp[-3].minor.yy590,yymsp[-1].minor.yy402,yymsp[-8].minor.yy502,yymsp[0].minor.yy590);\n<line387>if( yymsp[-9].minor.yy637 ){\n<line388>yymsp[-9].minor.yy637->pWinDefn = yymsp[-2].minor.yy483;\n<line389>}else{\n<line390>sqlite3WindowListDelete(pParse->db, yymsp[-2].minor.yy483);\n<line391>}\n<line392>}\n<line393>break;\n<line394>case 94: /* values ::= VALUES LP nexprlist RP */\n<line395>{\n<line396>yymsp[-3].minor.yy637 = sqlite3SelectNew(pParse,yymsp[-1].minor.yy402,0,0,0,0,0,SF_Values,0);\n<line397>}\n<line398>break;\n<line399>case 95: /* oneselect ::= mvalues */\n<line400>{\n<line401>sqlite3MultiValuesEnd(pParse, yymsp[0].minor.yy637);\n<line402>}\n<line403>break;\n<line404>case 96: /* mvalues ::= values COMMA LP nexprlist RP */\n<line405>case 97: /* mvalues ::= mvalues COMMA LP nexprlist RP */ yytestcase(yyruleno==97);\n<line406>{\n<line407>yymsp[-4].minor.yy637 = sqlite3MultiValues(pParse, yymsp[-4].minor.yy637, yymsp[-1].minor.yy402);\n<line408>}\n<line409>break;\n<line410>case 98: /* distinct ::= DISTINCT */\n<line411>{yymsp[0].minor.yy502 = SF_Distinct;}\n<line412>break;\n<line413>case 99: /* distinct ::= ALL */\n<line414>{yymsp[0].minor.yy502 = SF_All;}\n<line415>break;\n<line416>case 101: /* sclp ::= */\n<line417>case 134: /* orderby_opt ::= */ yytestcase(yyruleno==134);\n<line418>case 144: /* groupby_opt ::= */ yytestcase(yyruleno==144);\n<line419>case 234: /* exprlist ::= */ yytestcase(yyruleno==234);\n<line420>case 237: /* paren_exprlist ::= */ yytestcase(yyruleno==237);\n<line421>case 242: /* eidlist_opt ::= */ yytestcase(yyruleno==242);\n<line422>{yymsp[1].minor.yy402 = 0;}\n<line423>break;\n<line424>case 102: /* selcollist ::= sclp scanpt expr scanpt as */\n<line425>{\n<line426>yymsp[-4].minor.yy402 = sqlite3ExprListAppend(pParse, yymsp[-4].minor.yy402, yymsp[-2].minor.yy590);\n<line427>if( yymsp[0].minor.yy0.n>0 ) sqlite3ExprListSetName(pParse, yymsp[-4].minor.yy402, &yymsp[0].minor.yy0, 1);\n<line428>sqlite3ExprListSetSpan(pParse,yymsp[-4].minor.yy402,yymsp[-3].minor.yy342,yymsp[-1].minor.yy342);\n<line429>}\n<line430>break;\n<line431>case 103: /* selcollist ::= sclp scanpt STAR */\n<line432>{\n<line433>Expr *p = sqlite3Expr(pParse->db, TK_ASTERISK, 0);\n<line434>sqlite3ExprSetErrorOffset(p, (int)(yymsp[0].minor.yy0.z - pParse->zTail));\n<line435>yymsp[-2].minor.yy402 = sqlite3ExprListAppend(pParse, yymsp[-2].minor.yy402, p);\n<line436>}\n<line437>break;\n<line438>case 104: /* selcollist ::= sclp scanpt nm DOT STAR */\n<line439>{\n<line440>Expr *pRight, *pLeft, *pDot;\n<line441>pRight = sqlite3PExpr(pParse, TK_ASTERISK, 0, 0);\n<line442>sqlite3ExprSetErrorOffset(pRight, (int)(yymsp[0].minor.yy0.z - pParse->zTail));\n<line443>pLeft = tokenExpr(pParse, TK_ID, yymsp[-2].minor.yy0);\n<line444>pDot = sqlite3PExpr(pParse, TK_DOT, pLeft, pRight);\n<line445>yymsp[-4].minor.yy402 = sqlite3ExprListAppend(pParse,yymsp[-4].minor.yy402, pDot);\n<line446>}\n<line447>break;\n<line448>case 105: /* as ::= AS nm */\n<line449>case 117: /* dbnm ::= DOT nm */ yytestcase(yyruleno==117);\n<line450>case 258: /* plus_num ::= PLUS INTEGER|FLOAT */ yytestcase(yyruleno==258);\n<line451>case 259: /* minus_num ::= MINUS INTEGER|FLOAT */ yytestcase(yyruleno==259);\n<line452>{yymsp[-1].minor.yy0 = yymsp[0].minor.yy0;}\n<line453>break;\n<line454>case 107: /* from ::= */\n<line455>case 110: /* stl_prefix ::= */ yytestcase(yyruleno==110);\n<line456>{yymsp[1].minor.yy563 = 0;}\n<line457>break;\n<line458>case 108: /* from ::= FROM seltablist */\n<line459>{\n<line460>yymsp[-1].minor.yy563 = yymsp[0].minor.yy563;\n<line461>sqlite3SrcListShiftJoinType(pParse,yymsp[-1].minor.yy563);\n<line462>}\n<line463>break;\n<line464>case 109: /* stl_prefix ::= seltablist joinop */\n<line465>{\n<line466>if( ALWAYS(yymsp[-1].minor.yy563 && yymsp[-1].minor.yy563->nSrc>0) ) yymsp[-1].minor.yy563->a[yymsp[-1].minor.yy563->nSrc-1].fg.jointype = (u8)yymsp[0].minor.yy502;\n<line467>}\n<line468>break;\n<line469>case 111: /* seltablist ::= stl_prefix nm dbnm as on_using */\n<line470>{\n<line471>yymsp[-4].minor.yy563 = sqlite3SrcListAppendFromTerm(pParse,yymsp[-4].minor.yy563,&yymsp[-3].minor.yy0,&yymsp[-2].minor.yy0,&yymsp[-1].minor.yy0,0,&yymsp[0].minor.yy421);\n<line472>}\n<line473>break;\n<line474>case 112: /* seltablist ::= stl_prefix nm dbnm as indexed_by on_using */\n<line475>{\n<line476>yymsp[-5].minor.yy563 = sqlite3SrcListAppendFromTerm(pParse,yymsp[-5].minor.yy563,&yymsp[-4].minor.yy0,&yymsp[-3].minor.yy0,&yymsp[-2].minor.yy0,0,&yymsp[0].minor.yy421);\n<line477>sqlite3SrcListIndexedBy(pParse, yymsp[-5].minor.yy563, &yymsp[-1].minor.yy0);\n<line478>}\n<line479>break;\n<line480>case 113: /* seltablist ::= stl_prefix nm dbnm LP exprlist RP as on_using */\n<line481>{\n<line482>yymsp[-7].minor.yy563 = sqlite3SrcListAppendFromTerm(pParse,yymsp[-7].minor.yy563,&yymsp[-6].minor.yy0,&yymsp[-5].minor.yy0,&yymsp[-1].minor.yy0,0,&yymsp[0].minor.yy421);\n<line483>sqlite3SrcListFuncArgs(pParse, yymsp[-7].minor.yy563, yymsp[-3].minor.yy402);\n<line484>}\n<line485>break;\n<line486>case 114: /* seltablist ::= stl_prefix LP select RP as on_using */\n<line487>{\n<line488>yymsp[-5].minor.yy563 = sqlite3SrcListAppendFromTerm(pParse,yymsp[-5].minor.yy563,0,0,&yymsp[-1].minor.yy0,yymsp[-3].minor.yy637,&yymsp[0].minor.yy421);\n<line489>}\n<line490>break;\n<line491>case 115: /* seltablist ::= stl_prefix LP seltablist RP as on_using */\n<line492>{\n<line493>if( yymsp[-5].minor.yy563==0 && yymsp[-1].minor.yy0.n==0 && yymsp[0].minor.yy421.pOn==0 && yymsp[0].minor.yy421.pUsing==0 ){\n<line494>yymsp[-5].minor.yy563 = yymsp[-3].minor.yy563;\n<line495>}else if( ALWAYS(yymsp[-3].minor.yy563!=0) && yymsp[-3].minor.yy563->nSrc==1 ){\n<line496>yymsp[-5].minor.yy563 = sqlite3SrcListAppendFromTerm(pParse,yymsp[-5].minor.yy563,0,0,&yymsp[-1].minor.yy0,0,&yymsp[0].minor.yy421);\n<line497>if( yymsp[-5].minor.yy563 ){\n<line498>SrcItem *pNew = &yymsp[-5].minor.yy563->a[yymsp[-5].minor.yy563->nSrc-1];\n<line499>SrcItem *pOld = yymsp[-3].minor.yy563->a;\n<line500>assert( pOld->fg.fixedSchema==0 );\n<line501>pNew->zName = pOld->zName;\n<line502>assert( pOld->fg.fixedSchema==0 );\n<line503>if( pOld->fg.isSubquery ){\n<line504>pNew->fg.isSubquery = 1;\n<line505>pNew->u4.pSubq = pOld->u4.pSubq;\n<line506>pOld->u4.pSubq = 0;\n<line507>pOld->fg.isSubquery = 0;\n<line508>assert( pNew->u4.pSubq!=0 && pNew->u4.pSubq->pSelect!=0 );\n<line509>if( (pNew->u4.pSubq->pSelect->selFlags & SF_NestedFrom)!=0 ){\n<line510>pNew->fg.isNestedFrom = 1;\n<line511>}\n<line512>}else{\n<line513>pNew->u4.zDatabase = pOld->u4.zDatabase;\n<line514>pOld->u4.zDatabase = 0;\n<line515>}\n<line516>if( pOld->fg.isTabFunc ){\n<line517>pNew->u1.pFuncArg = pOld->u1.pFuncArg;\n<line518>pOld->u1.pFuncArg = 0;\n<line519>pOld->fg.isTabFunc = 0;\n<line520>pNew->fg.isTabFunc = 1;\n<line521>}\n<line522>pOld->zName = 0;\n<line523>}\n<line524>sqlite3SrcListDelete(pParse->db, yymsp[-3].minor.yy563);\n<line525>}else{\n<line526>Select *pSubquery;\n<line527>sqlite3SrcListShiftJoinType(pParse,yymsp[-3].minor.yy563);\n<line528>pSubquery = sqlite3SelectNew(pParse,0,yymsp[-3].minor.yy563,0,0,0,0,SF_NestedFrom,0);\n<line529>yymsp[-5].minor.yy563 = sqlite3SrcListAppendFromTerm(pParse,yymsp[-5].minor.yy563,0,0,&yymsp[-1].minor.yy0,pSubquery,&yymsp[0].minor.yy421);\n<line530>}\n<line531>}\n<line532>break;\n<line533>case 116: /* dbnm ::= */\n<line534>case 131: /* indexed_opt ::= */ yytestcase(yyruleno==131);\n<line535>{yymsp[1].minor.yy0.z=0; yymsp[1].minor.yy0.n=0;}\n<line536>break;\n<line537>case 118: /* fullname ::= nm */\n<line538>{\n<line539>yylhsminor.yy563 = sqlite3SrcListAppend(pParse,0,&yymsp[0].minor.yy0,0);\n<line540>if( IN_RENAME_OBJECT && yylhsminor.yy563 ) sqlite3RenameTokenMap(pParse, yylhsminor.yy563->a[0].zName, &yymsp[0].minor.yy0);\n<line541>}\n<line542>yymsp[0].minor.yy563 = yylhsminor.yy563;\n<line543>break;\n<line544>case 119: /* fullname ::= nm DOT nm */\n<line545>{\n<line546>yylhsminor.yy563 = sqlite3SrcListAppend(pParse,0,&yymsp[-2].minor.yy0,&yymsp[0].minor.yy0);\n<line547>if( IN_RENAME_OBJECT && yylhsminor.yy563 ) sqlite3RenameTokenMap(pParse, yylhsminor.yy563->a[0].zName, &yymsp[0].minor.yy0);\n<line548>}\n<line549>yymsp[-2].minor.yy563 = yylhsminor.yy563;\n<line550>break;\n<line551>case 120: /* xfullname ::= nm */\n<line552>{yymsp[0].minor.yy563 = sqlite3SrcListAppend(pParse,0,&yymsp[0].minor.yy0,0); /*A-overwrites-X*/}\n<line553>break;\n<line554>case 121: /* xfullname ::= nm DOT nm */\n<line555>{yymsp[-2].minor.yy563 = sqlite3SrcListAppend(pParse,0,&yymsp[-2].minor.yy0,&yymsp[0].minor.yy0); /*A-overwrites-X*/}\n<line556>break;\n<line557>case 122: /* xfullname ::= nm DOT nm AS nm */\n<line558>{\n<line559>yymsp[-4].minor.yy563 = sqlite3SrcListAppend(pParse,0,&yymsp[-4].minor.yy0,&yymsp[-2].minor.yy0); /*A-overwrites-X*/\n<line560>if( yymsp[-4].minor.yy563 ) yymsp[-4].minor.yy563->a[0].zAlias = sqlite3NameFromToken(pParse->db, &yymsp[0].minor.yy0);\n<line561>}\n<line562>break;\n<line563>case 123: /* xfullname ::= nm AS nm */\n<line564>{\n<line565>yymsp[-2].minor.yy563 = sqlite3SrcListAppend(pParse,0,&yymsp[-2].minor.yy0,0); /*A-overwrites-X*/\n<line566>if( yymsp[-2].minor.yy563 ) yymsp[-2].minor.yy563->a[0].zAlias = sqlite3NameFromToken(pParse->db, &yymsp[0].minor.yy0);\n<line567>}\n<line568>break;\n<line569>case 124: /* joinop ::= COMMA|JOIN */\n<line570>{ yymsp[0].minor.yy502 = JT_INNER; }\n<line571>break;\n<line572>case 125: /* joinop ::= JOIN_KW JOIN */\n<line573>{yymsp[-1].minor.yy502 = sqlite3JoinType(pParse,&yymsp[-1].minor.yy0,0,0);  /*X-overwrites-A*/}\n<line574>break;\n<line575>case 126: /* joinop ::= JOIN_KW nm JOIN */\n<line576>{yymsp[-2].minor.yy502 = sqlite3JoinType(pParse,&yymsp[-2].minor.yy0,&yymsp[-1].minor.yy0,0); /*X-overwrites-A*/}\n<line577>break;\n<line578>case 127: /* joinop ::= JOIN_KW nm nm JOIN */\n<line579>{yymsp[-3].minor.yy502 = sqlite3JoinType(pParse,&yymsp[-3].minor.yy0,&yymsp[-2].minor.yy0,&yymsp[-1].minor.yy0);/*X-overwrites-A*/}\n<line580>break;\n<line581>case 128: /* on_using ::= ON expr */\n<line582>{yymsp[-1].minor.yy421.pOn = yymsp[0].minor.yy590; yymsp[-1].minor.yy421.pUsing = 0;}\n<line583>break;\n<line584>case 129: /* on_using ::= USING LP idlist RP */\n<line585>{yymsp[-3].minor.yy421.pOn = 0; yymsp[-3].minor.yy421.pUsing = yymsp[-1].minor.yy204;}\n<line586>break;\n<line587>case 130: /* on_using ::= */\n<line588>{yymsp[1].minor.yy421.pOn = 0; yymsp[1].minor.yy421.pUsing = 0;}\n<line589>break;\n<line590>case 132: /* indexed_by ::= INDEXED BY nm */\n<line591>{yymsp[-2].minor.yy0 = yymsp[0].minor.yy0;}\n<line592>break;\n<line593>case 133: /* indexed_by ::= NOT INDEXED */\n<line594>{yymsp[-1].minor.yy0.z=0; yymsp[-1].minor.yy0.n=1;}\n<line595>break;\n<line596>case 135: /* orderby_opt ::= ORDER BY sortlist */\n<line597>case 145: /* groupby_opt ::= GROUP BY nexprlist */ yytestcase(yyruleno==145);\n<line598>{yymsp[-2].minor.yy402 = yymsp[0].minor.yy402;}\n<line599>break;\n<line600>case 136: /* sortlist ::= sortlist COMMA expr sortorder nulls */\n<line601>{\n<line602>yymsp[-4].minor.yy402 = sqlite3ExprListAppend(pParse,yymsp[-4].minor.yy402,yymsp[-2].minor.yy590);\n<line603>sqlite3ExprListSetSortOrder(yymsp[-4].minor.yy402,yymsp[-1].minor.yy502,yymsp[0].minor.yy502);\n<line604>}\n<line605>break;\n<line606>case 137: /* sortlist ::= expr sortorder nulls */\n<line607>{\n<line608>yymsp[-2].minor.yy402 = sqlite3ExprListAppend(pParse,0,yymsp[-2].minor.yy590); /*A-overwrites-Y*/\n<line609>sqlite3ExprListSetSortOrder(yymsp[-2].minor.yy402,yymsp[-1].minor.yy502,yymsp[0].minor.yy502);\n<line610>}\n<line611>break;\n<line612>case 138: /* sortorder ::= ASC */\n<line613>{yymsp[0].minor.yy502 = SQLITE_SO_ASC;}\n<line614>break;\n<line615>case 139: /* sortorder ::= DESC */\n<line616>{yymsp[0].minor.yy502 = SQLITE_SO_DESC;}\n<line617>break;\n<line618>case 140: /* sortorder ::= */\n<line619>case 143: /* nulls ::= */ yytestcase(yyruleno==143);\n<line620>{yymsp[1].minor.yy502 = SQLITE_SO_UNDEFINED;}\n<line621>break;\n<line622>case 141: /* nulls ::= NULLS FIRST */\n<line623>{yymsp[-1].minor.yy502 = SQLITE_SO_ASC;}\n<line624>break;\n<line625>case 142: /* nulls ::= NULLS LAST */\n<line626>{yymsp[-1].minor.yy502 = SQLITE_SO_DESC;}\n<line627>break;\n<line628>case 146: /* having_opt ::= */\n<line629>case 148: /* limit_opt ::= */ yytestcase(yyruleno==148);\n<line630>case 153: /* where_opt ::= */ yytestcase(yyruleno==153);\n<line631>case 155: /* where_opt_ret ::= */ yytestcase(yyruleno==155);\n<line632>case 232: /* case_else ::= */ yytestcase(yyruleno==232);\n<line633>case 233: /* case_operand ::= */ yytestcase(yyruleno==233);\n<line634>case 252: /* vinto ::= */ yytestcase(yyruleno==252);\n<line635>{yymsp[1].minor.yy590 = 0;}\n<line636>break;\n<line637>case 147: /* having_opt ::= HAVING expr */\n<line638>case 154: /* where_opt ::= WHERE expr */ yytestcase(yyruleno==154);\n<line639>case 156: /* where_opt_ret ::= WHERE expr */ yytestcase(yyruleno==156);\n<line640>case 231: /* case_else ::= ELSE expr */ yytestcase(yyruleno==231);\n<line641>case 251: /* vinto ::= INTO expr */ yytestcase(yyruleno==251);\n<line642>{yymsp[-1].minor.yy590 = yymsp[0].minor.yy590;}\n<line643>break;\n<line644>case 149: /* limit_opt ::= LIMIT expr */\n<line645>{yymsp[-1].minor.yy590 = sqlite3PExpr(pParse,TK_LIMIT,yymsp[0].minor.yy590,0);}\n<line646>break;\n<line647>case 150: /* limit_opt ::= LIMIT expr OFFSET expr */\n<line648>{yymsp[-3].minor.yy590 = sqlite3PExpr(pParse,TK_LIMIT,yymsp[-2].minor.yy590,yymsp[0].minor.yy590);}\n<line649>break;\n<line650>case 151: /* limit_opt ::= LIMIT expr COMMA expr */\n<line651>{yymsp[-3].minor.yy590 = sqlite3PExpr(pParse,TK_LIMIT,yymsp[0].minor.yy590,yymsp[-2].minor.yy590);}\n<line652>break;\n<line653>case 152: /* cmd ::= with DELETE FROM xfullname indexed_opt where_opt_ret */\n<line654>{\n<line655>sqlite3SrcListIndexedBy(pParse, yymsp[-2].minor.yy563, &yymsp[-1].minor.yy0);\n<line656>sqlite3DeleteFrom(pParse,yymsp[-2].minor.yy563,yymsp[0].minor.yy590,0,0);\n<line657>}\n<line658>break;\n<line659>case 157: /* where_opt_ret ::= RETURNING selcollist */\n<line660>{sqlite3AddReturning(pParse,yymsp[0].minor.yy402); yymsp[-1].minor.yy590 = 0;}\n<line661>break;\n<line662>case 158: /* where_opt_ret ::= WHERE expr RETURNING selcollist */\n<line663>{sqlite3AddReturning(pParse,yymsp[0].minor.yy402); yymsp[-3].minor.yy590 = yymsp[-2].minor.yy590;}\n<line664>break;\n<line665>case 159: /* cmd ::= with UPDATE orconf xfullname indexed_opt SET setlist from where_opt_ret */\n<line666>{\n<line667>sqlite3SrcListIndexedBy(pParse, yymsp[-5].minor.yy563, &yymsp[-4].minor.yy0);\n<line668>sqlite3ExprListCheckLength(pParse,yymsp[-2].minor.yy402,"set list");\n<line669>if( yymsp[-1].minor.yy563 ){\n<line670>SrcList *pFromClause = yymsp[-1].minor.yy563;\n<line671>if( pFromClause->nSrc>1 ){\n<line672>Select *pSubquery;\n<line673>Token as;\n<line674>pSubquery = sqlite3SelectNew(pParse,0,pFromClause,0,0,0,0,SF_NestedFrom,0);\n<line675>as.n = 0;\n<line676>as.z = 0;\n<line677>pFromClause = sqlite3SrcListAppendFromTerm(pParse,0,0,0,&as,pSubquery,0);\n<line678>}\n<line679>yymsp[-5].minor.yy563 = sqlite3SrcListAppendList(pParse, yymsp[-5].minor.yy563, pFromClause);\n<line680>}\n<line681>sqlite3Update(pParse,yymsp[-5].minor.yy563,yymsp[-2].minor.yy402,yymsp[0].minor.yy590,yymsp[-6].minor.yy502,0,0,0);\n<line682>}\n<line683>break;\n<line684>case 160: /* setlist ::= setlist COMMA nm EQ expr */\n<line685>{\n<line686>yymsp[-4].minor.yy402 = sqlite3ExprListAppend(pParse, yymsp[-4].minor.yy402, yymsp[0].minor.yy590);\n<line687>sqlite3ExprListSetName(pParse, yymsp[-4].minor.yy402, &yymsp[-2].minor.yy0, 1);\n<line688>}\n<line689>break;\n<line690>case 161: /* setlist ::= setlist COMMA LP idlist RP EQ expr */\n<line691>{\n<line692>yymsp[-6].minor.yy402 = sqlite3ExprListAppendVector(pParse, yymsp[-6].minor.yy402, yymsp[-3].minor.yy204, yymsp[0].minor.yy590);\n<line693>}\n<line694>break;\n<line695>case 162: /* setlist ::= nm EQ expr */\n<line696>{\n<line697>yylhsminor.yy402 = sqlite3ExprListAppend(pParse, 0, yymsp[0].minor.yy590);\n<line698>sqlite3ExprListSetName(pParse, yylhsminor.yy402, &yymsp[-2].minor.yy0, 1);\n<line699>}\n<line700>yymsp[-2].minor.yy402 = yylhsminor.yy402;\n<line701>break;\n<line702>case 163: /* setlist ::= LP idlist RP EQ expr */\n<line703>{\n<line704>yymsp[-4].minor.yy402 = sqlite3ExprListAppendVector(pParse, 0, yymsp[-3].minor.yy204, yymsp[0].minor.yy590);\n<line705>}\n<line706>break;\n<line707>case 164: /* cmd ::= with insert_cmd INTO xfullname idlist_opt select upsert */\n<line708>{\n<line709>sqlite3Insert(pParse, yymsp[-3].minor.yy563, yymsp[-1].minor.yy637, yymsp[-2].minor.yy204, yymsp[-5].minor.yy502, yymsp[0].minor.yy403);\n<line710>}\n<line711>break;\n<line712>case 165: /* cmd ::= with insert_cmd INTO xfullname idlist_opt DEFAULT VALUES returning */\n<line713>{\n<line714>sqlite3Insert(pParse, yymsp[-4].minor.yy563, 0, yymsp[-3].minor.yy204, yymsp[-6].minor.yy502, 0);\n<line715>}\n<line716>break;\n<line717>case 166: /* upsert ::= */\n<line718>{ yymsp[1].minor.yy403 = 0; }\n<line719>break;\n<line720>case 167: /* upsert ::= RETURNING selcollist */\n<line721>{ yymsp[-1].minor.yy403 = 0; sqlite3AddReturning(pParse,yymsp[0].minor.yy402); }\n<line722>break;\n<line723>case 168: /* upsert ::= ON CONFLICT LP sortlist RP where_opt DO UPDATE SET setlist where_opt upsert */\n<line724>{ yymsp[-11].minor.yy403 = sqlite3UpsertNew(pParse->db,yymsp[-8].minor.yy402,yymsp[-6].minor.yy590,yymsp[-2].minor.yy402,yymsp[-1].minor.yy590,yymsp[0].minor.yy403);}\n<line725>break;\n<line726>case 169: /* upsert ::= ON CONFLICT LP sortlist RP where_opt DO NOTHING upsert */\n<line727>{ yymsp[-8].minor.yy403 = sqlite3UpsertNew(pParse->db,yymsp[-5].minor.yy402,yymsp[-3].minor.yy590,0,0,yymsp[0].minor.yy403); }\n<line728>break;\n<line729>case 170: /* upsert ::= ON CONFLICT DO NOTHING returning */\n<line730>{ yymsp[-4].minor.yy403 = sqlite3UpsertNew(pParse->db,0,0,0,0,0); }\n<line731>break;\n<line732>case 171: /* upsert ::= ON CONFLICT DO UPDATE SET setlist where_opt returning */\n<line733>{ yymsp[-7].minor.yy403 = sqlite3UpsertNew(pParse->db,0,0,yymsp[-2].minor.yy402,yymsp[-1].minor.yy590,0);}\n<line734>break;\n<line735>case 172: /* returning ::= RETURNING selcollist */\n<line736>{sqlite3AddReturning(pParse,yymsp[0].minor.yy402);}\n<line737>break;\n<line738>case 175: /* idlist_opt ::= */\n<line739>{yymsp[1].minor.yy204 = 0;}\n<line740>break;\n<line741>case 176: /* idlist_opt ::= LP idlist RP */\n<line742>{yymsp[-2].minor.yy204 = yymsp[-1].minor.yy204;}\n<line743>break;\n<line744>case 177: /* idlist ::= idlist COMMA nm */\n<line745>{yymsp[-2].minor.yy204 = sqlite3IdListAppend(pParse,yymsp[-2].minor.yy204,&yymsp[0].minor.yy0);}\n<line746>break;\n<line747>case 178: /* idlist ::= nm */\n<line748>{yymsp[0].minor.yy204 = sqlite3IdListAppend(pParse,0,&yymsp[0].minor.yy0); /*A-overwrites-Y*/}\n<line749>break;\n<line750>case 179: /* expr ::= LP expr RP */\n<line751>{yymsp[-2].minor.yy590 = yymsp[-1].minor.yy590;}\n<line752>break;\n<line753>case 180: /* expr ::= ID|INDEXED|JOIN_KW */\n<line754>{yymsp[0].minor.yy590=tokenExpr(pParse,TK_ID,yymsp[0].minor.yy0); /*A-overwrites-X*/}\n<line755>break;\n<line756>case 181: /* expr ::= nm DOT nm */\n<line757>{\n<line758>Expr *temp1 = tokenExpr(pParse,TK_ID,yymsp[-2].minor.yy0);\n<line759>Expr *temp2 = tokenExpr(pParse,TK_ID,yymsp[0].minor.yy0);\n<line760>yylhsminor.yy590 = sqlite3PExpr(pParse, TK_DOT, temp1, temp2);\n<line761>}\n<line762>yymsp[-2].minor.yy590 = yylhsminor.yy590;\n<line763>break;\n<line764>case 182: /* expr ::= nm DOT nm DOT nm */\n<line765>{\n<line766>Expr *temp1 = tokenExpr(pParse,TK_ID,yymsp[-4].minor.yy0);\n<line767>Expr *temp2 = tokenExpr(pParse,TK_ID,yymsp[-2].minor.yy0);\n<line768>Expr *temp3 = tokenExpr(pParse,TK_ID,yymsp[0].minor.yy0);\n<line769>Expr *temp4 = sqlite3PExpr(pParse, TK_DOT, temp2, temp3);\n<line770>if( IN_RENAME_OBJECT ){\n<line771>sqlite3RenameTokenRemap(pParse, 0, temp1);\n<line772>}\n<line773>yylhsminor.yy590 = sqlite3PExpr(pParse, TK_DOT, temp1, temp4);\n<line774>}\n<line775>yymsp[-4].minor.yy590 = yylhsminor.yy590;\n<line776>break;\n<line777>case 183: /* term ::= NULL|FLOAT|BLOB */\n<line778>case 184: /* term ::= STRING */ yytestcase(yyruleno==184);\n<line779>{yymsp[0].minor.yy590=tokenExpr(pParse,yymsp[0].major,yymsp[0].minor.yy0); /*A-overwrites-X*/}\n<line780>break;\n<line781>case 185: /* term ::= INTEGER */\n<line782>{\n<line783>yylhsminor.yy590 = sqlite3ExprAlloc(pParse->db, TK_INTEGER, &yymsp[0].minor.yy0, 1);\n<line784>if( yylhsminor.yy590 ) yylhsminor.yy590->w.iOfst = (int)(yymsp[0].minor.yy0.z - pParse->zTail);\n<line785>}\n<line786>yymsp[0].minor.yy590 = yylhsminor.yy590;\n<line787>break;\n<line788>case 186: /* expr ::= VARIABLE */\n<line789>{\n<line790>if( !(yymsp[0].minor.yy0.z[0]=='#' && sqlite3Isdigit(yymsp[0].minor.yy0.z[1])) ){\n<line791>u32 n = yymsp[0].minor.yy0.n;\n<line792>yymsp[0].minor.yy590 = tokenExpr(pParse, TK_VARIABLE, yymsp[0].minor.yy0);\n<line793>sqlite3ExprAssignVarNumber(pParse, yymsp[0].minor.yy590, n);\n<line794>}else{\n<line795>/* When doing a nested parse, one can include terms in an expression\n<line796>** that look like this:   #1 #2 ...  These terms refer to registers\n<line797>** in the virtual machine.  #N is the N-th register. */\n<line798>Token t = yymsp[0].minor.yy0; /*A-overwrites-X*/\n<line799>assert( t.n>=2 );\n<line800>if( pParse->nested==0 ){\n<line801>parserSyntaxError(pParse, &t);\n<line802>yymsp[0].minor.yy590 = 0;\n<line803>}else{\n<line804>yymsp[0].minor.yy590 = sqlite3PExpr(pParse, TK_REGISTER, 0, 0);\n<line805>if( yymsp[0].minor.yy590 ) sqlite3GetInt32(&t.z[1], &yymsp[0].minor.yy590->iTable);\n<line806>}\n<line807>}\n<line808>}\n<line809>break;\n<line810>case 187: /* expr ::= expr COLLATE ID|STRING */\n<line811>{\n<line812>yymsp[-2].minor.yy590 = sqlite3ExprAddCollateToken(pParse, yymsp[-2].minor.yy590, &yymsp[0].minor.yy0, 1);\n<line813>}\n<line814>break;\n<line815>case 188: /* expr ::= CAST LP expr AS typetoken RP */\n<line816>{\n<line817>yymsp[-5].minor.yy590 = sqlite3ExprAlloc(pParse->db, TK_CAST, &yymsp[-1].minor.yy0, 1);\n<line818>sqlite3ExprAttachSubtrees(pParse->db, yymsp[-5].minor.yy590, yymsp[-3].minor.yy590, 0);\n<line819>}\n<line820>break;\n<line821>case 189: /* expr ::= ID|INDEXED|JOIN_KW LP distinct exprlist RP */\n<line822>{\n<line823>yylhsminor.yy590 = sqlite3ExprFunction(pParse, yymsp[-1].minor.yy402, &yymsp[-4].minor.yy0, yymsp[-2].minor.yy502);\n<line824>}\n<line825>yymsp[-4].minor.yy590 = yylhsminor.yy590;\n<line826>break;\n<line827>case 190: /* expr ::= ID|INDEXED|JOIN_KW LP distinct exprlist ORDER BY sortlist RP */\n<line828>{\n<line829>yylhsminor.yy590 = sqlite3ExprFunction(pParse, yymsp[-4].minor.yy402, &yymsp[-7].minor.yy0, yymsp[-5].minor.yy502);\n<line830>sqlite3ExprAddFunctionOrderBy(pParse, yylhsminor.yy590, yymsp[-1].minor.yy402);\n<line831>}\n<line832>yymsp[-7].minor.yy590 = yylhsminor.yy590;\n<line833>break;\n<line834>case 191: /* expr ::= ID|INDEXED|JOIN_KW LP STAR RP */\n<line835>{\n<line836>yylhsminor.yy590 = sqlite3ExprFunction(pParse, 0, &yymsp[-3].minor.yy0, 0);\n<line837>}\n<line838>yymsp[-3].minor.yy590 = yylhsminor.yy590;\n<line839>break;\n<line840>case 192: /* expr ::= ID|INDEXED|JOIN_KW LP distinct exprlist RP filter_over */\n<line841>{\n<line842>yylhsminor.yy590 = sqlite3ExprFunction(pParse, yymsp[-2].minor.yy402, &yymsp[-5].minor.yy0, yymsp[-3].minor.yy502);\n<line843>sqlite3WindowAttach(pParse, yylhsminor.yy590, yymsp[0].minor.yy483);\n<line844>}\n<line845>yymsp[-5].minor.yy590 = yylhsminor.yy590;\n<line846>break;\n<line847>case 193: /* expr ::= ID|INDEXED|JOIN_KW LP distinct exprlist ORDER BY sortlist RP filter_over */\n<line848>{\n<line849>yylhsminor.yy590 = sqlite3ExprFunction(pParse, yymsp[-5].minor.yy402, &yymsp[-8].minor.yy0, yymsp[-6].minor.yy502);\n<line850>sqlite3WindowAttach(pParse, yylhsminor.yy590, yymsp[0].minor.yy483);\n<line851>sqlite3ExprAddFunctionOrderBy(pParse, yylhsminor.yy590, yymsp[-2].minor.yy402);\n<line852>}\n<line853>yymsp[-8].minor.yy590 = yylhsminor.yy590;\n<line854>break;\n<line855>case 194: /* expr ::= ID|INDEXED|JOIN_KW LP STAR RP filter_over */\n<line856>{\n<line857>yylhsminor.yy590 = sqlite3ExprFunction(pParse, 0, &yymsp[-4].minor.yy0, 0);\n<line858>sqlite3WindowAttach(pParse, yylhsminor.yy590, yymsp[0].minor.yy483);\n<line859>}\n<line860>yymsp[-4].minor.yy590 = yylhsminor.yy590;\n<line861>break;\n<line862>case 195: /* term ::= CTIME_KW */\n<line863>{\n<line864>yylhsminor.yy590 = sqlite3ExprFunction(pParse, 0, &yymsp[0].minor.yy0, 0);\n<line865>}\n<line866>yymsp[0].minor.yy590 = yylhsminor.yy590;\n<line867>break;\n<line868>case 196: /* expr ::= LP nexprlist COMMA expr RP */\n<line869>{\n<line870>ExprList *pList = sqlite3ExprListAppend(pParse, yymsp[-3].minor.yy402, yymsp[-1].minor.yy590);\n<line871>yymsp[-4].minor.yy590 = sqlite3PExpr(pParse, TK_VECTOR, 0, 0);\n<line872>if( yymsp[-4].minor.yy590 ){\n<line873>yymsp[-4].minor.yy590->x.pList = pList;\n<line874>if( ALWAYS(pList->nExpr) ){\n<line875>yymsp[-4].minor.yy590->flags |= pList->a[0].pExpr->flags & EP_Propagate;\n<line876>}\n<line877>}else{\n<line878>sqlite3ExprListDelete(pParse->db, pList);\n<line879>}\n<line880>}\n<line881>break;\n<line882>case 197: /* expr ::= expr AND expr */\n<line883>{yymsp[-2].minor.yy590=sqlite3ExprAnd(pParse,yymsp[-2].minor.yy590,yymsp[0].minor.yy590);}\n<line884>break;\n<line885>case 198: /* expr ::= expr OR expr */\n<line886>case 199: /* expr ::= expr LT|GT|GE|LE expr */ yytestcase(yyruleno==199);\n<line887>case 200: /* expr ::= expr EQ|NE expr */ yytestcase(yyruleno==200);\n<line888>case 201: /* expr ::= expr BITAND|BITOR|LSHIFT|RSHIFT expr */ yytestcase(yyruleno==201);\n<line889>case 202: /* expr ::= expr PLUS|MINUS expr */ yytestcase(yyruleno==202);\n<line890>case 203: /* expr ::= expr STAR|SLASH|REM expr */ yytestcase(yyruleno==203);\n<line891>case 204: /* expr ::= expr CONCAT expr */ yytestcase(yyruleno==204);\n<line892>{yymsp[-2].minor.yy590=sqlite3PExpr(pParse,yymsp[-1].major,yymsp[-2].minor.yy590,yymsp[0].minor.yy590);}\n<line893>break;\n<line894>case 205: /* likeop ::= NOT LIKE_KW|MATCH */\n<line895>{yymsp[-1].minor.yy0=yymsp[0].minor.yy0; yymsp[-1].minor.yy0.n|=0x80000000; /*yymsp[-1].minor.yy0-overwrite-yymsp[0].minor.yy0*/}\n<line896>break;\n<line897>case 206: /* expr ::= expr likeop expr */\n<line898>{\n<line899>ExprList *pList;\n<line900>int bNot = yymsp[-1].minor.yy0.n & 0x80000000;\n<line901>yymsp[-1].minor.yy0.n &= 0x7fffffff;\n<line902>pList = sqlite3ExprListAppend(pParse,0, yymsp[0].minor.yy590);\n<line903>pList = sqlite3ExprListAppend(pParse,pList, yymsp[-2].minor.yy590);\n<line904>yymsp[-2].minor.yy590 = sqlite3ExprFunction(pParse, pList, &yymsp[-1].minor.yy0, 0);\n<line905>if( bNot ) yymsp[-2].minor.yy590 = sqlite3PExpr(pParse, TK_NOT, yymsp[-2].minor.yy590, 0);\n<line906>if( yymsp[-2].minor.yy590 ) yymsp[-2].minor.yy590->flags |= EP_InfixFunc;\n<line907>}\n<line908>break;\n<line909>case 207: /* expr ::= expr likeop expr ESCAPE expr */\n<line910>{\n<line911>ExprList *pList;\n<line912>int bNot = yymsp[-3].minor.yy0.n & 0x80000000;\n<line913>yymsp[-3].minor.yy0.n &= 0x7fffffff;\n<line914>pList = sqlite3ExprListAppend(pParse,0, yymsp[-2].minor.yy590);\n<line915>pList = sqlite3ExprListAppend(pParse,pList, yymsp[-4].minor.yy590);\n<line916>pList = sqlite3ExprListAppend(pParse,pList, yymsp[0].minor.yy590);\n<line917>yymsp[-4].minor.yy590 = sqlite3ExprFunction(pParse, pList, &yymsp[-3].minor.yy0, 0);\n<line918>if( bNot ) yymsp[-4].minor.yy590 = sqlite3PExpr(pParse, TK_NOT, yymsp[-4].minor.yy590, 0);\n<line919>if( yymsp[-4].minor.yy590 ) yymsp[-4].minor.yy590->flags |= EP_InfixFunc;\n<line920>}\n<line921>break;\n<line922>case 208: /* expr ::= expr ISNULL|NOTNULL */\n<line923>{yymsp[-1].minor.yy590 = sqlite3PExpr(pParse,yymsp[0].major,yymsp[-1].minor.yy590,0);}\n<line924>break;\n<line925>case 209: /* expr ::= expr NOT NULL */\n<line926>{yymsp[-2].minor.yy590 = sqlite3PExpr(pParse,TK_NOTNULL,yymsp[-2].minor.yy590,0);}\n<line927>break;\n<line928>case 210: /* expr ::= expr IS expr */\n<line929>{\n<line930>yymsp[-2].minor.yy590 = sqlite3PExpr(pParse,TK_IS,yymsp[-2].minor.yy590,yymsp[0].minor.yy590);\n<line931>binaryToUnaryIfNull(pParse, yymsp[0].minor.yy590, yymsp[-2].minor.yy590, TK_ISNULL);\n<line932>}\n<line933>break;\n<line934>case 211: /* expr ::= expr IS NOT expr */\n<line935>{\n<line936>yymsp[-3].minor.yy590 = sqlite3PExpr(pParse,TK_ISNOT,yymsp[-3].minor.yy590,yymsp[0].minor.yy590);\n<line937>binaryToUnaryIfNull(pParse, yymsp[0].minor.yy590, yymsp[-3].minor.yy590, TK_NOTNULL);\n<line938>}\n<line939>break;\n<line940>case 212: /* expr ::= expr IS NOT DISTINCT FROM expr */\n<line941>{\n<line942>yymsp[-5].minor.yy590 = sqlite3PExpr(pParse,TK_IS,yymsp[-5].minor.yy590,yymsp[0].minor.yy590);\n<line943>binaryToUnaryIfNull(pParse, yymsp[0].minor.yy590, yymsp[-5].minor.yy590, TK_ISNULL);\n<line944>}\n<line945>break;\n<line946>case 213: /* expr ::= expr IS DISTINCT FROM expr */\n<line947>{\n<line948>yymsp[-4].minor.yy590 = sqlite3PExpr(pParse,TK_ISNOT,yymsp[-4].minor.yy590,yymsp[0].minor.yy590);\n<line949>binaryToUnaryIfNull(pParse, yymsp[0].minor.yy590, yymsp[-4].minor.yy590, TK_NOTNULL);\n<line950>}\n<line951>break;\n<line952>case 214: /* expr ::= NOT expr */\n<line953>case 215: /* expr ::= BITNOT expr */ yytestcase(yyruleno==215);\n<line954>{yymsp[-1].minor.yy590 = sqlite3PExpr(pParse, yymsp[-1].major, yymsp[0].minor.yy590, 0);/*A-overwrites-B*/}\n<line955>break;\n<line956>case 216: /* expr ::= PLUS|MINUS expr */\n<line957>{\n<line958>Expr *p = yymsp[0].minor.yy590;\n<line959>u8 op = yymsp[-1].major + (TK_UPLUS-TK_PLUS);\n<line960>assert( TK_UPLUS>TK_PLUS );\n<line961>assert( TK_UMINUS == TK_MINUS + (TK_UPLUS - TK_PLUS) );\n<line962>if( p && p->op==TK_UPLUS ){\n<line963>p->op = op;\n<line964>yymsp[-1].minor.yy590 = p;\n<line965>}else{\n<line966>yymsp[-1].minor.yy590 = sqlite3PExpr(pParse, op, p, 0);\n<line967>/*A-overwrites-B*/\n<line968>}\n<line969>}\n<line970>break;\n<line971>case 217: /* expr ::= expr PTR expr */\n<line972>{\n<line973>ExprList *pList = sqlite3ExprListAppend(pParse, 0, yymsp[-2].minor.yy590);\n<line974>pList = sqlite3ExprListAppend(pParse, pList, yymsp[0].minor.yy590);\n<line975>yylhsminor.yy590 = sqlite3ExprFunction(pParse, pList, &yymsp[-1].minor.yy0, 0);\n<line976>}\n<line977>yymsp[-2].minor.yy590 = yylhsminor.yy590;\n<line978>break;\n<line979>case 218: /* between_op ::= BETWEEN */\n<line980>case 221: /* in_op ::= IN */ yytestcase(yyruleno==221);\n<line981>{yymsp[0].minor.yy502 = 0;}\n<line982>break;\n<line983>case 220: /* expr ::= expr between_op expr AND expr */\n<line984>{\n<line985>ExprList *pList = sqlite3ExprListAppend(pParse,0, yymsp[-2].minor.yy590);\n<line986>pList = sqlite3ExprListAppend(pParse,pList, yymsp[0].minor.yy590);\n<line987>yymsp[-4].minor.yy590 = sqlite3PExpr(pParse, TK_BETWEEN, yymsp[-4].minor.yy590, 0);\n<line988>if( yymsp[-4].minor.yy590 ){\n<line989>yymsp[-4].minor.yy590->x.pList = pList;\n<line990>}else{\n<line991>sqlite3ExprListDelete(pParse->db, pList);\n<line992>}\n<line993>if( yymsp[-3].minor.yy502 ) yymsp[-4].minor.yy590 = sqlite3PExpr(pParse, TK_NOT, yymsp[-4].minor.yy590, 0);\n<line994>}\n<line995>break;\n<line996>case 223: /* expr ::= expr in_op LP exprlist RP */\n<line997>{\n<line998>if( yymsp[-1].minor.yy402==0 ){\n<line999>/* Expressions of the form\n<line1000>**\n<line1001>**      expr1 IN ()\n<line1002>**      expr1 NOT IN ()\n<line1003>**\n<line1004>** simplify to constants 0 (false) and 1 (true), respectively.\n<line1005>**\n<line1006>** Except, do not apply this optimization if expr1 contains a function\n<line1007>** because that function might be an aggregate (we don't know yet whether\n<line1008>** it is or not) and if it is an aggregate, that could change the meaning\n<line1009>** of the whole query.\n<line1010>*/\n<line1011>Expr *pB = sqlite3Expr(pParse->db, TK_STRING, yymsp[-3].minor.yy502 ? "true" : "false");\n<line1012>if( pB ) sqlite3ExprIdToTrueFalse(pB);\n<line1013>if( !ExprHasProperty(yymsp[-4].minor.yy590, EP_HasFunc) ){\n<line1014>sqlite3ExprUnmapAndDelete(pParse, yymsp[-4].minor.yy590);\n<line1015>yymsp[-4].minor.yy590 = pB;\n<line1016>}else{\n<line1017>yymsp[-4].minor.yy590 = sqlite3PExpr(pParse, yymsp[-3].minor.yy502 ? TK_OR : TK_AND, pB, yymsp[-4].minor.yy590);\n<line1018>}\n<line1019>}else{\n<line1020>Expr *pRHS = yymsp[-1].minor.yy402->a[0].pExpr;\n<line1021>if( yymsp[-1].minor.yy402->nExpr==1 && sqlite3ExprIsConstant(pParse,pRHS) && yymsp[-4].minor.yy590->op!=TK_VECTOR ){\n<line1022>yymsp[-1].minor.yy402->a[0].pExpr = 0;\n<line1023>sqlite3ExprListDelete(pParse->db, yymsp[-1].minor.yy402);\n<line1024>pRHS = sqlite3PExpr(pParse, TK_UPLUS, pRHS, 0);\n<line1025>yymsp[-4].minor.yy590 = sqlite3PExpr(pParse, TK_EQ, yymsp[-4].minor.yy590, pRHS);\n<line1026>}else if( yymsp[-1].minor.yy402->nExpr==1 && pRHS->op==TK_SELECT ){\n<line1027>yymsp[-4].minor.yy590 = sqlite3PExpr(pParse, TK_IN, yymsp[-4].minor.yy590, 0);\n<line1028>sqlite3PExprAddSelect(pParse, yymsp[-4].minor.yy590, pRHS->x.pSelect);\n<line1029>pRHS->x.pSelect = 0;\n<line1030>sqlite3ExprListDelete(pParse->db, yymsp[-1].minor.yy402);\n<line1031>}else{\n<line1032>yymsp[-4].minor.yy590 = sqlite3PExpr(pParse, TK_IN, yymsp[-4].minor.yy590, 0);\n<line1033>if( yymsp[-4].minor.yy590==0 ){\n<line1034>sqlite3ExprListDelete(pParse->db, yymsp[-1].minor.yy402);\n<line1035>}else if( yymsp[-4].minor.yy590->pLeft->op==TK_VECTOR ){\n<line1036>int nExpr = yymsp[-4].minor.yy590->pLeft->x.pList->nExpr;\n<line1037>Select *pSelectRHS = sqlite3ExprListToValues(pParse, nExpr, yymsp[-1].minor.yy402);\n<line1038>if( pSelectRHS ){\n<line1039>parserDoubleLinkSelect(pParse, pSelectRHS);\n<line1040>sqlite3PExprAddSelect(pParse, yymsp[-4].minor.yy590, pSelectRHS);\n<line1041>}\n<line1042>}else{\n<line1043>yymsp[-4].minor.yy590->x.pList = yymsp[-1].minor.yy402;\n<line1044>sqlite3ExprSetHeightAndFlags(pParse, yymsp[-4].minor.yy590);\n<line1045>}\n<line1046>}\n<line1047>if( yymsp[-3].minor.yy502 ) yymsp[-4].minor.yy590 = sqlite3PExpr(pParse, TK_NOT, yymsp[-4].minor.yy590, 0);\n<line1048>}\n<line1049>}\n<line1050>break;\n<line1051>case 224: /* expr ::= LP select RP */\n<line1052>{\n<line1053>yymsp[-2].minor.yy590 = sqlite3PExpr(pParse, TK_SELECT, 0, 0);\n<line1054>sqlite3PExprAddSelect(pParse, yymsp[-2].minor.yy590, yymsp[-1].minor.yy637);\n<line1055>}\n<line1056>break;\n<line1057>case 225: /* expr ::= expr in_op LP select RP */\n<line1058>{\n<line1059>yymsp[-4].minor.yy590 = sqlite3PExpr(pParse, TK_IN, yymsp[-4].minor.yy590, 0);\n<line1060>sqlite3PExprAddSelect(pParse, yymsp[-4].minor.yy590, yymsp[-1].minor.yy637);\n<line1061>if( yymsp[-3].minor.yy502 ) yymsp[-4].minor.yy590 = sqlite3PExpr(pParse, TK_NOT, yymsp[-4].minor.yy590, 0);\n<line1062>}\n<line1063>break;\n<line1064>case 226: /* expr ::= expr in_op nm dbnm paren_exprlist */\n<line1065>{\n<line1066>SrcList *pSrc = sqlite3SrcListAppend(pParse, 0,&yymsp[-2].minor.yy0,&yymsp[-1].minor.yy0);\n<line1067>Select *pSelect = sqlite3SelectNew(pParse, 0,pSrc,0,0,0,0,0,0);\n<line1068>if( yymsp[0].minor.yy402 )  sqlite3SrcListFuncArgs(pParse, pSelect ? pSrc : 0, yymsp[0].minor.yy402);\n<line1069>yymsp[-4].minor.yy590 = sqlite3PExpr(pParse, TK_IN, yymsp[-4].minor.yy590, 0);\n<line1070>sqlite3PExprAddSelect(pParse, yymsp[-4].minor.yy590, pSelect);\n<line1071>if( yymsp[-3].minor.yy502 ) yymsp[-4].minor.yy590 = sqlite3PExpr(pParse, TK_NOT, yymsp[-4].minor.yy590, 0);\n<line1072>}\n<line1073>break;\n<line1074>case 227: /* expr ::= EXISTS LP select RP */\n<line1075>{\n<line1076>Expr *p;\n<line1077>p = yymsp[-3].minor.yy590 = sqlite3PExpr(pParse, TK_EXISTS, 0, 0);\n<line1078>sqlite3PExprAddSelect(pParse, p, yymsp[-1].minor.yy637);\n<line1079>}\n<line1080>break;\n<line1081>case 228: /* expr ::= CASE case_operand case_exprlist case_else END */\n<line1082>{\n<line1083>yymsp[-4].minor.yy590 = sqlite3PExpr(pParse, TK_CASE, yymsp[-3].minor.yy590, 0);\n<line1084>if( yymsp[-4].minor.yy590 ){\n<line1085>yymsp[-4].minor.yy590->x.pList = yymsp[-1].minor.yy590 ? sqlite3ExprListAppend(pParse,yymsp[-2].minor.yy402,yymsp[-1].minor.yy590) : yymsp[-2].minor.yy402;\n<line1086>sqlite3ExprSetHeightAndFlags(pParse, yymsp[-4].minor.yy590);\n<line1087>}else{\n<line1088>sqlite3ExprListDelete(pParse->db, yymsp[-2].minor.yy402);\n<line1089>sqlite3ExprDelete(pParse->db, yymsp[-1].minor.yy590);\n<line1090>}\n<line1091>}\n<line1092>break;\n<line1093>case 229: /* case_exprlist ::= case_exprlist WHEN expr THEN expr */\n<line1094>{\n<line1095>yymsp[-4].minor.yy402 = sqlite3ExprListAppend(pParse,yymsp[-4].minor.yy402, yymsp[-2].minor.yy590);\n<line1096>yymsp[-4].minor.yy402 = sqlite3ExprListAppend(pParse,yymsp[-4].minor.yy402, yymsp[0].minor.yy590);\n<line1097>}\n<line1098>break;\n<line1099>case 230: /* case_exprlist ::= WHEN expr THEN expr */\n<line1100>{\n<line1101>yymsp[-3].minor.yy402 = sqlite3ExprListAppend(pParse,0, yymsp[-2].minor.yy590);\n<line1102>yymsp[-3].minor.yy402 = sqlite3ExprListAppend(pParse,yymsp[-3].minor.yy402, yymsp[0].minor.yy590);\n<line1103>}\n<line1104>break;\n<line1105>case 235: /* nexprlist ::= nexprlist COMMA expr */\n<line1106>{yymsp[-2].minor.yy402 = sqlite3ExprListAppend(pParse,yymsp[-2].minor.yy402,yymsp[0].minor.yy590);}\n<line1107>break;\n<line1108>case 236: /* nexprlist ::= expr */\n<line1109>{yymsp[0].minor.yy402 = sqlite3ExprListAppend(pParse,0,yymsp[0].minor.yy590); /*A-overwrites-Y*/}\n<line1110>break;\n<line1111>case 238: /* paren_exprlist ::= LP exprlist RP */\n<line1112>case 243: /* eidlist_opt ::= LP eidlist RP */ yytestcase(yyruleno==243);\n<line1113>{yymsp[-2].minor.yy402 = yymsp[-1].minor.yy402;}\n<line1114>break;\n<line1115>case 239: /* cmd ::= createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP sortlist RP where_opt */\n<line1116>{\n<line1117>sqlite3CreateIndex(pParse, &yymsp[-7].minor.yy0, &yymsp[-6].minor.yy0,\n<line1118>sqlite3SrcListAppend(pParse,0,&yymsp[-4].minor.yy0,0), yymsp[-2].minor.yy402, yymsp[-10].minor.yy502,\n<line1119>&yymsp[-11].minor.yy0, yymsp[0].minor.yy590, SQLITE_SO_ASC, yymsp[-8].minor.yy502, SQLITE_IDXTYPE_APPDEF);\n<line1120>if( IN_RENAME_OBJECT && pParse->pNewIndex ){\n<line1121>sqlite3RenameTokenMap(pParse, pParse->pNewIndex->zName, &yymsp[-4].minor.yy0);\n<line1122>}\n<line1123>}\n<line1124>break;\n<line1125>case 240: /* uniqueflag ::= UNIQUE */\n<line1126>case 282: /* raisetype ::= ABORT */ yytestcase(yyruleno==282);\n<line1127>{yymsp[0].minor.yy502 = OE_Abort;}\n<line1128>break;\n<line1129>case 241: /* uniqueflag ::= */\n<line1130>{yymsp[1].minor.yy502 = OE_None;}\n<line1131>break;\n<line1132>case 244: /* eidlist ::= eidlist COMMA nm collate sortorder */\n<line1133>{\n<line1134>yymsp[-4].minor.yy402 = parserAddExprIdListTerm(pParse, yymsp[-4].minor.yy402, &yymsp[-2].minor.yy0, yymsp[-1].minor.yy502, yymsp[0].minor.yy502);\n<line1135>}\n<line1136>break;\n<line1137>case 245: /* eidlist ::= nm collate sortorder */\n<line1138>{\n<line1139>yymsp[-2].minor.yy402 = parserAddExprIdListTerm(pParse, 0, &yymsp[-2].minor.yy0, yymsp[-1].minor.yy502, yymsp[0].minor.yy502); /*A-overwrites-Y*/\n<line1140>}\n<line1141>break;\n<line1142>case 248: /* cmd ::= DROP INDEX ifexists fullname */\n<line1143>{sqlite3DropIndex(pParse, yymsp[0].minor.yy563, yymsp[-1].minor.yy502);}\n<line1144>break;\n<line1145>case 249: /* cmd ::= VACUUM vinto */\n<line1146>{sqlite3Vacuum(pParse,0,yymsp[0].minor.yy590);}\n<line1147>break;\n<line1148>case 250: /* cmd ::= VACUUM nm vinto */\n<line1149>{sqlite3Vacuum(pParse,&yymsp[-1].minor.yy0,yymsp[0].minor.yy590);}\n<line1150>break;\n<line1151>case 253: /* cmd ::= PRAGMA nm dbnm */\n<line1152>{sqlite3Pragma(pParse,&yymsp[-1].minor.yy0,&yymsp[0].minor.yy0,0,0);}\n<line1153>break;\n<line1154>case 254: /* cmd ::= PRAGMA nm dbnm EQ nmnum */\n<line1155>{sqlite3Pragma(pParse,&yymsp[-3].minor.yy0,&yymsp[-2].minor.yy0,&yymsp[0].minor.yy0,0);}\n<line1156>break;\n<line1157>case 255: /* cmd ::= PRAGMA nm dbnm LP nmnum RP */\n<line1158>{sqlite3Pragma(pParse,&yymsp[-4].minor.yy0,&yymsp[-3].minor.yy0,&yymsp[-1].minor.yy0,0);}\n<line1159>break;\n<line1160>case 256: /* cmd ::= PRAGMA nm dbnm EQ minus_num */\n<line1161>{sqlite3Pragma(pParse,&yymsp[-3].minor.yy0,&yymsp[-2].minor.yy0,&yymsp[0].minor.yy0,1);}\n<line1162>break;\n<line1163>case 257: /* cmd ::= PRAGMA nm dbnm LP minus_num RP */\n<line1164>{sqlite3Pragma(pParse,&yymsp[-4].minor.yy0,&yymsp[-3].minor.yy0,&yymsp[-1].minor.yy0,1);}\n<line1165>break;\n<line1166>case 260: /* cmd ::= createkw trigger_decl BEGIN trigger_cmd_list END */\n<line1167>{\n<line1168>Token all;\n<line1169>all.z = yymsp[-3].minor.yy0.z;\n<line1170>all.n = (int)(yymsp[0].minor.yy0.z - yymsp[-3].minor.yy0.z) + yymsp[0].minor.yy0.n;\n<line1171>sqlite3FinishTrigger(pParse, yymsp[-1].minor.yy319, &all);\n<line1172>}\n<line1173>break;\n<line1174>case 261: /* trigger_decl ::= temp TRIGGER ifnotexists nm dbnm trigger_time trigger_event ON fullname foreach_clause when_clause */\n<line1175>{\n<line1176>sqlite3BeginTrigger(pParse, &yymsp[-7].minor.yy0, &yymsp[-6].minor.yy0, yymsp[-5].minor.yy502, yymsp[-4].minor.yy28.a, yymsp[-4].minor.yy28.b, yymsp[-2].minor.yy563, yymsp[0].minor.yy590, yymsp[-10].minor.yy502, yymsp[-8].minor.yy502);\n<line1177>yymsp[-10].minor.yy0 = (yymsp[-6].minor.yy0.n==0?yymsp[-7].minor.yy0:yymsp[-6].minor.yy0); /*A-overwrites-T*/\n<line1178>#ifdef SQLITE_DEBUG\n<line1179>assert( pParse->isCreate ); /* Set by createkw reduce action */\n<line1180>pParse->isCreate = 0;       /* But, should not be set for CREATE TRIGGER */\n<line1181>#endif\n<line1182>}\n<line1183>break;\n<line1184>case 262: /* trigger_time ::= BEFORE|AFTER */\n<line1185>{ yymsp[0].minor.yy502 = yymsp[0].major; /*A-overwrites-X*/ }\n<line1186>break;\n<line1187>case 263: /* trigger_time ::= INSTEAD OF */\n<line1188>{ yymsp[-1].minor.yy502 = TK_INSTEAD;}\n<line1189>break;\n<line1190>case 264: /* trigger_time ::= */\n<line1191>{ yymsp[1].minor.yy502 = TK_BEFORE; }\n<line1192>break;\n<line1193>case 265: /* trigger_event ::= DELETE|INSERT */\n<line1194>case 266: /* trigger_event ::= UPDATE */ yytestcase(yyruleno==266);\n<line1195>{yymsp[0].minor.yy28.a = yymsp[0].major; /*A-overwrites-X*/ yymsp[0].minor.yy28.b = 0;}\n<line1196>break;\n<line1197>case 267: /* trigger_event ::= UPDATE OF idlist */\n<line1198>{yymsp[-2].minor.yy28.a = TK_UPDATE; yymsp[-2].minor.yy28.b = yymsp[0].minor.yy204;}\n<line1199>break;\n<line1200>case 268: /* when_clause ::= */\n<line1201>case 287: /* key_opt ::= */ yytestcase(yyruleno==287);\n<line1202>{ yymsp[1].minor.yy590 = 0; }\n<line1203>break;\n<line1204>case 269: /* when_clause ::= WHEN expr */\n<line1205>case 288: /* key_opt ::= KEY expr */ yytestcase(yyruleno==288);\n<line1206>{ yymsp[-1].minor.yy590 = yymsp[0].minor.yy590; }\n<line1207>break;\n<line1208>case 270: /* trigger_cmd_list ::= trigger_cmd_list trigger_cmd SEMI */\n<line1209>{\n<line1210>assert( yymsp[-2].minor.yy319!=0 );\n<line1211>yymsp[-2].minor.yy319->pLast->pNext = yymsp[-1].minor.yy319;\n<line1212>yymsp[-2].minor.yy319->pLast = yymsp[-1].minor.yy319;\n<line1213>}\n<line1214>break;\n<line1215>case 271: /* trigger_cmd_list ::= trigger_cmd SEMI */\n<line1216>{\n<line1217>assert( yymsp[-1].minor.yy319!=0 );\n<line1218>yymsp[-1].minor.yy319->pLast = yymsp[-1].minor.yy319;\n<line1219>}\n<line1220>break;\n<line1221>case 272: /* trnm ::= nm DOT nm */\n<line1222>{\n<line1223>yymsp[-2].minor.yy0 = yymsp[0].minor.yy0;\n<line1224>sqlite3ErrorMsg(pParse,\n<line1225>"qualified table names are not allowed on INSERT, UPDATE, and DELETE "\n<line1226>"statements within triggers");\n<line1227>}\n<line1228>break;\n<line1229>case 273: /* tridxby ::= INDEXED BY nm */\n<line1230>{\n<line1231>sqlite3ErrorMsg(pParse,\n<line1232>"the INDEXED BY clause is not allowed on UPDATE or DELETE statements "\n<line1233>"within triggers");\n<line1234>}\n<line1235>break;\n<line1236>case 274: /* tridxby ::= NOT INDEXED */\n<line1237>{\n<line1238>sqlite3ErrorMsg(pParse,\n<line1239>"the NOT INDEXED clause is not allowed on UPDATE or DELETE statements "\n<line1240>"within triggers");\n<line1241>}\n<line1242>break;\n<line1243>case 275: /* trigger_cmd ::= UPDATE orconf trnm tridxby SET setlist from where_opt scanpt */\n<line1244>{yylhsminor.yy319 = sqlite3TriggerUpdateStep(pParse, &yymsp[-6].minor.yy0, yymsp[-2].minor.yy563, yymsp[-3].minor.yy402, yymsp[-1].minor.yy590, yymsp[-7].minor.yy502, yymsp[-8].minor.yy0.z, yymsp[0].minor.yy342);}\n<line1245>yymsp[-8].minor.yy319 = yylhsminor.yy319;\n<line1246>break;\n<line1247>case 276: /* trigger_cmd ::= scanpt insert_cmd INTO trnm idlist_opt select upsert scanpt */\n<line1248>{\n<line1249>yylhsminor.yy319 = sqlite3TriggerInsertStep(pParse,&yymsp[-4].minor.yy0,yymsp[-3].minor.yy204,yymsp[-2].minor.yy637,yymsp[-6].minor.yy502,yymsp[-1].minor.yy403,yymsp[-7].minor.yy342,yymsp[0].minor.yy342);/*yylhsminor.yy319-overwrites-yymsp[-6].minor.yy502*/\n<line1250>}\n<line1251>yymsp[-7].minor.yy319 = yylhsminor.yy319;\n<line1252>break;\n<line1253>case 277: /* trigger_cmd ::= DELETE FROM trnm tridxby where_opt scanpt */\n<line1254>{yylhsminor.yy319 = sqlite3TriggerDeleteStep(pParse, &yymsp[-3].minor.yy0, yymsp[-1].minor.yy590, yymsp[-5].minor.yy0.z, yymsp[0].minor.yy342);}\n<line1255>yymsp[-5].minor.yy319 = yylhsminor.yy319;\n<line1256>break;\n<line1257>case 278: /* trigger_cmd ::= scanpt select scanpt */\n<line1258>{yylhsminor.yy319 = sqlite3TriggerSelectStep(pParse->db, yymsp[-1].minor.yy637, yymsp[-2].minor.yy342, yymsp[0].minor.yy342); /*yylhsminor.yy319-overwrites-yymsp[-1].minor.yy637*/}\n<line1259>yymsp[-2].minor.yy319 = yylhsminor.yy319;\n<line1260>break;\n<line1261>case 279: /* expr ::= RAISE LP IGNORE RP */\n<line1262>{\n<line1263>yymsp[-3].minor.yy590 = sqlite3PExpr(pParse, TK_RAISE, 0, 0);\n<line1264>if( yymsp[-3].minor.yy590 ){\n<line1265>yymsp[-3].minor.yy590->affExpr = OE_Ignore;\n<line1266>}\n<line1267>}\n<line1268>break;\n<line1269>case 280: /* expr ::= RAISE LP raisetype COMMA expr RP */\n<line1270>{\n<line1271>yymsp[-5].minor.yy590 = sqlite3PExpr(pParse, TK_RAISE, yymsp[-1].minor.yy590, 0);\n<line1272>if( yymsp[-5].minor.yy590 ) {\n<line1273>yymsp[-5].minor.yy590->affExpr = (char)yymsp[-3].minor.yy502;\n<line1274>}\n<line1275>}\n<line1276>break;\n<line1277>case 281: /* raisetype ::= ROLLBACK */\n<line1278>{yymsp[0].minor.yy502 = OE_Rollback;}\n<line1279>break;\n<line1280>case 283: /* raisetype ::= FAIL */\n<line1281>{yymsp[0].minor.yy502 = OE_Fail;}\n<line1282>break;\n<line1283>case 284: /* cmd ::= DROP TRIGGER ifexists fullname */\n<line1284>{\n<line1285>sqlite3DropTrigger(pParse,yymsp[0].minor.yy563,yymsp[-1].minor.yy502);\n<line1286>}\n<line1287>break;\n<line1288>case 285: /* cmd ::= ATTACH database_kw_opt expr AS expr key_opt */\n<line1289>{\n<line1290>sqlite3Attach(pParse, yymsp[-3].minor.yy590, yymsp[-1].minor.yy590, yymsp[0].minor.yy590);\n<line1291>}\n<line1292>break;\n<line1293>case 286: /* cmd ::= DETACH database_kw_opt expr */\n<line1294>{\n<line1295>sqlite3Detach(pParse, yymsp[0].minor.yy590);\n<line1296>}\n<line1297>break;\n<line1298>case 289: /* cmd ::= REINDEX */\n<line1299>{sqlite3Reindex(pParse, 0, 0);}\n<line1300>break;\n<line1301>case 290: /* cmd ::= REINDEX nm dbnm */\n<line1302>{sqlite3Reindex(pParse, &yymsp[-1].minor.yy0, &yymsp[0].minor.yy0);}\n<line1303>break;\n<line1304>case 291: /* cmd ::= ANALYZE */\n<line1305>{sqlite3Analyze(pParse, 0, 0);}\n<line1306>break;\n<line1307>case 292: /* cmd ::= ANALYZE nm dbnm */\n<line1308>{sqlite3Analyze(pParse, &yymsp[-1].minor.yy0, &yymsp[0].minor.yy0);}\n<line1309>break;\n<line1310>case 293: /* cmd ::= ALTER TABLE fullname RENAME TO nm */\n<line1311>{\n<line1312>sqlite3AlterRenameTable(pParse,yymsp[-3].minor.yy563,&yymsp[0].minor.yy0);\n<line1313>}\n<line1314>break;\n<line1315>case 294: /* cmd ::= ALTER TABLE add_column_fullname ADD kwcolumn_opt columnname carglist */\n<line1316>{\n<line1317>yymsp[-1].minor.yy0.n = (int)(pParse->sLastToken.z-yymsp[-1].minor.yy0.z) + pParse->sLastToken.n;\n<line1318>sqlite3AlterFinishAddColumn(pParse, &yymsp[-1].minor.yy0);\n<line1319>}\n<line1320>break;\n<line1321>case 295: /* cmd ::= ALTER TABLE fullname DROP kwcolumn_opt nm */\n<line1322>{\n<line1323>sqlite3AlterDropColumn(pParse, yymsp[-3].minor.yy563, &yymsp[0].minor.yy0);\n<line1324>}\n<line1325>break;\n<line1326>case 296: /* add_column_fullname ::= fullname */\n<line1327>{\n<line1328>disableLookaside(pParse);\n<line1329>sqlite3AlterBeginAddColumn(pParse, yymsp[0].minor.yy563);\n<line1330>}\n<line1331>break;\n<line1332>case 297: /* cmd ::= ALTER TABLE fullname RENAME kwcolumn_opt nm TO nm */\n<line1333>{\n<line1334>sqlite3AlterRenameColumn(pParse, yymsp[-5].minor.yy563, &yymsp[-2].minor.yy0, &yymsp[0].minor.yy0);\n<line1335>}\n<line1336>break;\n<line1337>case 298: /* cmd ::= create_vtab */\n<line1338>{sqlite3VtabFinishParse(pParse,0);}\n<line1339>break;\n<line1340>case 299: /* cmd ::= create_vtab LP vtabarglist RP */\n<line1341>{sqlite3VtabFinishParse(pParse,&yymsp[0].minor.yy0);}\n<line1342>break;\n<line1343>case 300: /* create_vtab ::= createkw VIRTUAL TABLE ifnotexists nm dbnm USING nm */\n<line1344>{\n<line1345>sqlite3VtabBeginParse(pParse, &yymsp[-3].minor.yy0, &yymsp[-2].minor.yy0, &yymsp[0].minor.yy0, yymsp[-4].minor.yy502);\n<line1346>}\n<line1347>break;\n<line1348>case 301: /* vtabarg ::= */\n<line1349>{sqlite3VtabArgInit(pParse);}\n<line1350>break;\n<line1351>case 302: /* vtabargtoken ::= ANY */\n<line1352>case 303: /* vtabargtoken ::= lp anylist RP */ yytestcase(yyruleno==303);\n<line1353>case 304: /* lp ::= LP */ yytestcase(yyruleno==304);\n<line1354>{sqlite3VtabArgExtend(pParse,&yymsp[0].minor.yy0);}\n<line1355>break;\n<line1356>case 305: /* with ::= WITH wqlist */\n<line1357>case 306: /* with ::= WITH RECURSIVE wqlist */ yytestcase(yyruleno==306);\n<line1358>{ sqlite3WithPush(pParse, yymsp[0].minor.yy125, 1); }\n<line1359>break;\n<line1360>case 307: /* wqas ::= AS */\n<line1361>{yymsp[0].minor.yy444 = M10d_Any;}\n<line1362>break;\n<line1363>case 308: /* wqas ::= AS MATERIALIZED */\n<line1364>{yymsp[-1].minor.yy444 = M10d_Yes;}\n<line1365>break;\n<line1366>case 309: /* wqas ::= AS NOT MATERIALIZED */\n<line1367>{yymsp[-2].minor.yy444 = M10d_No;}\n<line1368>break;\n<line1369>case 310: /* wqitem ::= withnm eidlist_opt wqas LP select RP */\n<line1370>{\n<line1371>yymsp[-5].minor.yy361 = sqlite3CteNew(pParse, &yymsp[-5].minor.yy0, yymsp[-4].minor.yy402, yymsp[-1].minor.yy637, yymsp[-3].minor.yy444); /*A-overwrites-X*/\n<line1372>}\n<line1373>break;\n<line1374>case 311: /* withnm ::= nm */\n<line1375>{pParse->bHasWith = 1;}\n<line1376>break;\n<line1377>case 312: /* wqlist ::= wqitem */\n<line1378>{\n<line1379>yymsp[0].minor.yy125 = sqlite3WithAdd(pParse, 0, yymsp[0].minor.yy361); /*A-overwrites-X*/\n<line1380>}\n<line1381>break;\n<line1382>case 313: /* wqlist ::= wqlist COMMA wqitem */\n<line1383>{\n<line1384>yymsp[-2].minor.yy125 = sqlite3WithAdd(pParse, yymsp[-2].minor.yy125, yymsp[0].minor.yy361);\n<line1385>}\n<line1386>break;\n<line1387>case 314: /* windowdefn_list ::= windowdefn_list COMMA windowdefn */\n<line1388>{\n<line1389>assert( yymsp[0].minor.yy483!=0 );\n<line1390>sqlite3WindowChain(pParse, yymsp[0].minor.yy483, yymsp[-2].minor.yy483);\n<line1391>yymsp[0].minor.yy483->pNextWin = yymsp[-2].minor.yy483;\n<line1392>yylhsminor.yy483 = yymsp[0].minor.yy483;\n<line1393>}\n<line1394>yymsp[-2].minor.yy483 = yylhsminor.yy483;\n<line1395>break;\n<line1396>case 315: /* windowdefn ::= nm AS LP window RP */\n<line1397>{\n<line1398>if( ALWAYS(yymsp[-1].minor.yy483) ){\n<line1399>yymsp[-1].minor.yy483->zName = sqlite3DbStrNDup(pParse->db, yymsp[-4].minor.yy0.z, yymsp[-4].minor.yy0.n);\n<line1400>}\n<line1401>yylhsminor.yy483 = yymsp[-1].minor.yy483;\n<line1402>}\n<line1403>yymsp[-4].minor.yy483 = yylhsminor.yy483;\n<line1404>break;\n<line1405>case 316: /* window ::= PARTITION BY nexprlist orderby_opt frame_opt */\n<line1406>{\n<line1407>yymsp[-4].minor.yy483 = sqlite3WindowAssemble(pParse, yymsp[0].minor.yy483, yymsp[-2].minor.yy402, yymsp[-1].minor.yy402, 0);\n<line1408>}\n<line1409>break;\n<line1410>case 317: /* window ::= nm PARTITION BY nexprlist orderby_opt frame_opt */\n<line1411>{\n<line1412>yylhsminor.yy483 = sqlite3WindowAssemble(pParse, yymsp[0].minor.yy483, yymsp[-2].minor.yy402, yymsp[-1].minor.yy402, &yymsp[-5].minor.yy0);\n<line1413>}\n<line1414>yymsp[-5].minor.yy483 = yylhsminor.yy483;\n<line1415>break;\n<line1416>case 318: /* window ::= ORDER BY sortlist frame_opt */\n<line1417>{\n<line1418>yymsp[-3].minor.yy483 = sqlite3WindowAssemble(pParse, yymsp[0].minor.yy483, 0, yymsp[-1].minor.yy402, 0);\n<line1419>}\n<line1420>break;\n<line1421>case 319: /* window ::= nm ORDER BY sortlist frame_opt */\n<line1422>{\n<line1423>yylhsminor.yy483 = sqlite3WindowAssemble(pParse, yymsp[0].minor.yy483, 0, yymsp[-1].minor.yy402, &yymsp[-4].minor.yy0);\n<line1424>}\n<line1425>yymsp[-4].minor.yy483 = yylhsminor.yy483;\n<line1426>break;\n<line1427>case 320: /* window ::= nm frame_opt */\n<line1428>{\n<line1429>yylhsminor.yy483 = sqlite3WindowAssemble(pParse, yymsp[0].minor.yy483, 0, 0, &yymsp[-1].minor.yy0);\n<line1430>}\n<line1431>yymsp[-1].minor.yy483 = yylhsminor.yy483;\n<line1432>break;\n<line1433>case 321: /* frame_opt ::= */\n<line1434>{\n<line1435>yymsp[1].minor.yy483 = sqlite3WindowAlloc(pParse, 0, TK_UNBOUNDED, 0, TK_CURRENT, 0, 0);\n<line1436>}\n<line1437>break;\n<line1438>case 322: /* frame_opt ::= range_or_rows frame_bound_s frame_exclude_opt */\n<line1439>{\n<line1440>yylhsminor.yy483 = sqlite3WindowAlloc(pParse, yymsp[-2].minor.yy502, yymsp[-1].minor.yy205.eType, yymsp[-1].minor.yy205.pExpr, TK_CURRENT, 0, yymsp[0].minor.yy444);\n<line1441>}\n<line1442>yymsp[-2].minor.yy483 = yylhsminor.yy483;\n<line1443>break;\n<line1444>case 323: /* frame_opt ::= range_or_rows BETWEEN frame_bound_s AND frame_bound_e frame_exclude_opt */\n<line1445>{\n<line1446>yylhsminor.yy483 = sqlite3WindowAlloc(pParse, yymsp[-5].minor.yy502, yymsp[-3].minor.yy205.eType, yymsp[-3].minor.yy205.pExpr, yymsp[-1].minor.yy205.eType, yymsp[-1].minor.yy205.pExpr, yymsp[0].minor.yy444);\n<line1447>}\n<line1448>yymsp[-5].minor.yy483 = yylhsminor.yy483;\n<line1449>break;\n<line1450>case 325: /* frame_bound_s ::= frame_bound */\n<line1451>case 327: /* frame_bound_e ::= frame_bound */ yytestcase(yyruleno==327);\n<line1452>{yylhsminor.yy205 = yymsp[0].minor.yy205;}\n<line1453>yymsp[0].minor.yy205 = yylhsminor.yy205;\n<line1454>break;\n<line1455>case 326: /* frame_bound_s ::= UNBOUNDED PRECEDING */\n<line1456>case 328: /* frame_bound_e ::= UNBOUNDED FOLLOWING */ yytestcase(yyruleno==328);\n<line1457>case 330: /* frame_bound ::= CURRENT ROW */ yytestcase(yyruleno==330);\n<line1458>{yylhsminor.yy205.eType = yymsp[-1].major; yylhsminor.yy205.pExpr = 0;}\n<line1459>yymsp[-1].minor.yy205 = yylhsminor.yy205;\n<line1460>break;\n<line1461>case 329: /* frame_bound ::= expr PRECEDING|FOLLOWING */\n<line1462>{yylhsminor.yy205.eType = yymsp[0].major; yylhsminor.yy205.pExpr = yymsp[-1].minor.yy590;}\n<line1463>yymsp[-1].minor.yy205 = yylhsminor.yy205;\n<line1464>break;\n<line1465>case 331: /* frame_exclude_opt ::= */\n<line1466>{yymsp[1].minor.yy444 = 0;}\n<line1467>break;\n<line1468>case 332: /* frame_exclude_opt ::= EXCLUDE frame_exclude */\n<line1469>{yymsp[-1].minor.yy444 = yymsp[0].minor.yy444;}\n<line1470>break;\n<line1471>case 333: /* frame_exclude ::= NO OTHERS */\n<line1472>case 334: /* frame_exclude ::= CURRENT ROW */ yytestcase(yyruleno==334);\n<line1473>{yymsp[-1].minor.yy444 = yymsp[-1].major; /*A-overwrites-X*/}\n<line1474>break;\n<line1475>case 335: /* frame_exclude ::= GROUP|TIES */\n<line1476>{yymsp[0].minor.yy444 = yymsp[0].major; /*A-overwrites-X*/}\n<line1477>break;\n<line1478>case 336: /* window_clause ::= WINDOW windowdefn_list */\n<line1479>{ yymsp[-1].minor.yy483 = yymsp[0].minor.yy483; }\n<line1480>break;\n<line1481>case 337: /* filter_over ::= filter_clause over_clause */\n<line1482>{\n<line1483>if( yymsp[0].minor.yy483 ){\n<line1484>yymsp[0].minor.yy483->pFilter = yymsp[-1].minor.yy590;\n<line1485>}else{\n<line1486>sqlite3ExprDelete(pParse->db, yymsp[-1].minor.yy590);\n<line1487>}\n<line1488>yylhsminor.yy483 = yymsp[0].minor.yy483;\n<line1489>}\n<line1490>yymsp[-1].minor.yy483 = yylhsminor.yy483;\n<line1491>break;\n<line1492>case 338: /* filter_over ::= over_clause */\n<line1493>{\n<line1494>yylhsminor.yy483 = yymsp[0].minor.yy483;\n<line1495>}\n<line1496>yymsp[0].minor.yy483 = yylhsminor.yy483;\n<line1497>break;\n<line1498>case 339: /* filter_over ::= filter_clause */\n<line1499>{\n<line1500>yylhsminor.yy483 = (Window*)sqlite3DbMallocZero(pParse->db, sizeof(Window));\n<line1501>if( yylhsminor.yy483 ){\n<line1502>yylhsminor.yy483->eFrmType = TK_FILTER;\n<line1503>yylhsminor.yy483->pFilter = yymsp[0].minor.yy590;\n<line1504>}else{\n<line1505>sqlite3ExprDelete(pParse->db, yymsp[0].minor.yy590);\n<line1506>}\n<line1507>}\n<line1508>yymsp[0].minor.yy483 = yylhsminor.yy483;\n<line1509>break;\n<line1510>case 340: /* over_clause ::= OVER LP window RP */\n<line1511>{\n<line1512>yymsp[-3].minor.yy483 = yymsp[-1].minor.yy483;\n<line1513>assert( yymsp[-3].minor.yy483!=0 );\n<line1514>}\n<line1515>break;\n<line1516>case 341: /* over_clause ::= OVER nm */\n<line1517>{\n<line1518>yymsp[-1].minor.yy483 = (Window*)sqlite3DbMallocZero(pParse->db, sizeof(Window));\n<line1519>if( yymsp[-1].minor.yy483 ){\n<line1520>yymsp[-1].minor.yy483->zName = sqlite3DbStrNDup(pParse->db, yymsp[0].minor.yy0.z, yymsp[0].minor.yy0.n);\n<line1521>}\n<line1522>}\n<line1523>break;\n<line1524>case 342: /* filter_clause ::= FILTER LP WHERE expr RP */\n<line1525>{ yymsp[-4].minor.yy590 = yymsp[-1].minor.yy590; }\n<line1526>break;\n<line1527>case 343: /* term ::= QNUMBER */\n<line1528>{\n<line1529>yylhsminor.yy590=tokenExpr(pParse,yymsp[0].major,yymsp[0].minor.yy0);\n<line1530>sqlite3DequoteNumber(pParse, yylhsminor.yy590);\n<line1531>}\n<line1532>yymsp[0].minor.yy590 = yylhsminor.yy590;\n<line1533>break;\n<line1534>default:\n<line1535>/* (344) input ::= cmdlist */ yytestcase(yyruleno==344);\n<line1536>/* (345) cmdlist ::= cmdlist ecmd */ yytestcase(yyruleno==345);\n<line1537>/* (346) cmdlist ::= ecmd (OPTIMIZED OUT) */ assert(yyruleno!=346);\n<line1538>/* (347) ecmd ::= SEMI */ yytestcase(yyruleno==347);\n<line1539>/* (348) ecmd ::= cmdx SEMI */ yytestcase(yyruleno==348);\n<line1540>/* (349) ecmd ::= explain cmdx SEMI (NEVER REDUCES) */ assert(yyruleno!=349);\n<line1541>/* (350) trans_opt ::= */ yytestcase(yyruleno==350);\n<line1542>/* (351) trans_opt ::= TRANSACTION */ yytestcase(yyruleno==351);\n<line1543>/* (352) trans_opt ::= TRANSACTION nm */ yytestcase(yyruleno==352);\n<line1544>/* (353) savepoint_opt ::= SAVEPOINT */ yytestcase(yyruleno==353);\n<line1545>/* (354) savepoint_opt ::= */ yytestcase(yyruleno==354);\n<line1546>/* (355) cmd ::= create_table create_table_args */ yytestcase(yyruleno==355);\n<line1547>/* (356) table_option_set ::= table_option (OPTIMIZED OUT) */ assert(yyruleno!=356);\n<line1548>/* (357) columnlist ::= columnlist COMMA columnname carglist */ yytestcase(yyruleno==357);\n<line1549>/* (358) columnlist ::= columnname carglist */ yytestcase(yyruleno==358);\n<line1550>/* (359) nm ::= ID|INDEXED|JOIN_KW */ yytestcase(yyruleno==359);\n<line1551>/* (360) nm ::= STRING */ yytestcase(yyruleno==360);\n<line1552>/* (361) typetoken ::= typename */ yytestcase(yyruleno==361);\n<line1553>/* (362) typename ::= ID|STRING */ yytestcase(yyruleno==362);\n<line1554>/* (363) signed ::= plus_num (OPTIMIZED OUT) */ assert(yyruleno!=363);\n<line1555>/* (364) signed ::= minus_num (OPTIMIZED OUT) */ assert(yyruleno!=364);\n<line1556>/* (365) carglist ::= carglist ccons */ yytestcase(yyruleno==365);\n<line1557>/* (366) carglist ::= */ yytestcase(yyruleno==366);\n<line1558>/* (367) ccons ::= NULL onconf */ yytestcase(yyruleno==367);\n<line1559>/* (368) ccons ::= GENERATED ALWAYS AS generated */ yytestcase(yyruleno==368);\n<line1560>/* (369) ccons ::= AS generated */ yytestcase(yyruleno==369);\n<line1561>/* (370) conslist_opt ::= COMMA conslist */ yytestcase(yyruleno==370);\n<line1562>/* (371) conslist ::= conslist tconscomma tcons */ yytestcase(yyruleno==371);\n<line1563>/* (372) conslist ::= tcons (OPTIMIZED OUT) */ assert(yyruleno!=372);\n<line1564>/* (373) tconscomma ::= */ yytestcase(yyruleno==373);\n<line1565>/* (374) defer_subclause_opt ::= defer_subclause (OPTIMIZED OUT) */ assert(yyruleno!=374);\n<line1566>/* (375) resolvetype ::= raisetype (OPTIMIZED OUT) */ assert(yyruleno!=375);\n<line1567>/* (376) selectnowith ::= oneselect (OPTIMIZED OUT) */ assert(yyruleno!=376);\n<line1568>/* (377) oneselect ::= values */ yytestcase(yyruleno==377);\n<line1569>/* (378) sclp ::= selcollist COMMA */ yytestcase(yyruleno==378);\n<line1570>/* (379) as ::= ID|STRING */ yytestcase(yyruleno==379);\n<line1571>/* (380) indexed_opt ::= indexed_by (OPTIMIZED OUT) */ assert(yyruleno!=380);\n<line1572>/* (381) returning ::= */ yytestcase(yyruleno==381);\n<line1573>/* (382) expr ::= term (OPTIMIZED OUT) */ assert(yyruleno!=382);\n<line1574>/* (383) likeop ::= LIKE_KW|MATCH */ yytestcase(yyruleno==383);\n<line1575>/* (384) case_operand ::= expr */ yytestcase(yyruleno==384);\n<line1576>/* (385) exprlist ::= nexprlist */ yytestcase(yyruleno==385);\n<line1577>/* (386) nmnum ::= plus_num (OPTIMIZED OUT) */ assert(yyruleno!=386);\n<line1578>/* (387) nmnum ::= nm (OPTIMIZED OUT) */ assert(yyruleno!=387);\n<line1579>/* (388) nmnum ::= ON */ yytestcase(yyruleno==388);\n<line1580>/* (389) nmnum ::= DELETE */ yytestcase(yyruleno==389);\n<line1581>/* (390) nmnum ::= DEFAULT */ yytestcase(yyruleno==390);\n<line1582>/* (391) plus_num ::= INTEGER|FLOAT */ yytestcase(yyruleno==391);\n<line1583>/* (392) foreach_clause ::= */ yytestcase(yyruleno==392);\n<line1584>/* (393) foreach_clause ::= FOR EACH ROW */ yytestcase(yyruleno==393);\n<line1585>/* (394) trnm ::= nm */ yytestcase(yyruleno==394);\n<line1586>/* (395) tridxby ::= */ yytestcase(yyruleno==395);\n<line1587>/* (396) database_kw_opt ::= DATABASE */ yytestcase(yyruleno==396);\n<line1588>/* (397) database_kw_opt ::= */ yytestcase(yyruleno==397);\n<line1589>/* (398) kwcolumn_opt ::= */ yytestcase(yyruleno==398);\n<line1590>/* (399) kwcolumn_opt ::= COLUMNKW */ yytestcase(yyruleno==399);\n<line1591>/* (400) vtabarglist ::= vtabarg */ yytestcase(yyruleno==400);\n<line1592>/* (401) vtabarglist ::= vtabarglist COMMA vtabarg */ yytestcase(yyruleno==401);\n<line1593>/* (402) vtabarg ::= vtabarg vtabargtoken */ yytestcase(yyruleno==402);\n<line1594>/* (403) anylist ::= */ yytestcase(yyruleno==403);\n<line1595>/* (404) anylist ::= anylist LP anylist RP */ yytestcase(yyruleno==404);\n<line1596>/* (405) anylist ::= anylist ANY */ yytestcase(yyruleno==405);\n<line1597>/* (406) with ::= */ yytestcase(yyruleno==406);\n<line1598>/* (407) windowdefn_list ::= windowdefn (OPTIMIZED OUT) */ assert(yyruleno!=407);\n<line1599>/* (408) window ::= frame_opt (OPTIMIZED OUT) */ assert(yyruleno!=408);\n<line1600>break;\n<line1601>/********** End reduce actions ************************************************/\n<line1602>};\n<line1603>assert( yyruleno<sizeof(yyRuleInfoLhs)/sizeof(yyRuleInfoLhs[0]) );\n<line1604>yygoto = yyRuleInfoLhs[yyruleno];\n<line1605>yysize = yyRuleInfoNRhs[yyruleno];\n<line1606>yyact = yy_find_reduce_action(yymsp[yysize].stateno,(YYCODETYPE)yygoto);\n<line1607>/* There are no SHIFTREDUCE actions on nonterminals because the table\n<line1608>** generator has simplified them to pure REDUCE actions. */\n<line1609>assert( !(yyact>YY_MAX_SHIFT && yyact<=YY_MAX_SHIFTREDUCE) );\n<line1610>/* It is not possible for a REDUCE to be followed by an error */\n<line1611>assert( yyact!=YY_ERROR_ACTION );\n<line1612>yymsp += yysize+1;\n<line1613>yypParser->yytos = yymsp;\n<line1614>yymsp->stateno = (YYACTIONTYPE)yyact;\n<line1615>yymsp->major = (YYCODETYPE)yygoto;\n<line1616>yyTraceShift(yypParser, yyact, "... then shift");\n<line1617>return yyact;\n<line1618>}
----------------------------------------
Function: yy_syntax_error
Content: <line0>static void yy_syntax_error(\n<line1>yyParser *yypParser,           /* The parser */\n<line2>int yymajor,                   /* The major type of the error token */\n<line3>sqlite3ParserTOKENTYPE yyminor         /* The minor type of the error token */\n<line4>){\n<line5>sqlite3ParserARG_FETCH\n<line6>sqlite3ParserCTX_FETCH\n<line7>#define TOKEN yyminor\n<line8>/************ Begin %syntax_error code ****************************************/\n<line9>UNUSED_PARAMETER(yymajor);  /* Silence some compiler warnings */\n<line10>if( TOKEN.z[0] ){\n<line11>parserSyntaxError(pParse, &TOKEN);\n<line12>}else{\n<line13>sqlite3ErrorMsg(pParse, "incomplete input");\n<line14>}\n<line15>/************ End %syntax_error code ******************************************/\n<line16>sqlite3ParserARG_STORE /* Suppress warning about unused %extra_argument variable */\n<line17>sqlite3ParserCTX_STORE\n<line18>}
----------------------------------------
Function: yy_accept
Content: <line0>static void yy_accept(\n<line1>yyParser *yypParser           /* The parser */\n<line2>){\n<line3>sqlite3ParserARG_FETCH\n<line4>sqlite3ParserCTX_FETCH\n<line5>#ifndef NDEBUG\n<line6>if( yyTraceFILE ){\n<line7>fprintf(yyTraceFILE,"%sAccept!\n",yyTracePrompt);\n<line8>}\n<line9>#endif\n<line10>#ifndef YYNOERRORRECOVERY\n<line11>yypParser->yyerrcnt = -1;\n<line12>#endif\n<line13>assert( yypParser->yytos==yypParser->yystack );\n<line14>/* Here code is inserted which will be executed whenever the\n<line15>** parser accepts */\n<line16>/*********** Begin %parse_accept code *****************************************/\n<line17>/*********** End %parse_accept code *******************************************/\n<line18>sqlite3ParserARG_STORE /* Suppress warning about unused %extra_argument variable */\n<line19>sqlite3ParserCTX_STORE\n<line20>}
----------------------------------------
Function: keywordCode
Content: <line0>static int keywordCode(const char *z, int n, int *pType){\n<line1>int i, j;\n<line2>const char *zKW;\n<line3>assert( n>=2 );\n<line4>i = ((charMap(z[0])*4) ^ (charMap(z[n-1])*3) ^ n*1) % 127;\n<line5>for(i=(int)aKWHash[i]; i>0; i=aKWNext[i]){\n<line6>if( aKWLen[i]!=n ) continue;\n<line7>zKW = &zKWText[aKWOffset[i]];\n<line8>#ifdef SQLITE_ASCII\n<line9>if( (z[0]&~0x20)!=zKW[0] ) continue;\n<line10>if( (z[1]&~0x20)!=zKW[1] ) continue;\n<line11>j = 2;\n<line12>while( j<n && (z[j]&~0x20)==zKW[j] ){ j++; }\n<line13>#endif\n<line14>#ifdef SQLITE_EBCDIC\n<line15>if( toupper(z[0])!=zKW[0] ) continue;\n<line16>if( toupper(z[1])!=zKW[1] ) continue;\n<line17>j = 2;\n<line18>while( j<n && toupper(z[j])==zKW[j] ){ j++; }\n<line19>#endif\n<line20>if( j<n ) continue;\n<line21>testcase( i==1 ); /* REINDEX */\n<line22>testcase( i==2 ); /* INDEXED */\n<line23>testcase( i==3 ); /* INDEX */\n<line24>testcase( i==4 ); /* DESC */\n<line25>testcase( i==5 ); /* ESCAPE */\n<line26>testcase( i==6 ); /* EACH */\n<line27>testcase( i==7 ); /* CHECK */\n<line28>testcase( i==8 ); /* KEY */\n<line29>testcase( i==9 ); /* BEFORE */\n<line30>testcase( i==10 ); /* FOREIGN */\n<line31>testcase( i==11 ); /* FOR */\n<line32>testcase( i==12 ); /* IGNORE */\n<line33>testcase( i==13 ); /* REGEXP */\n<line34>testcase( i==14 ); /* EXPLAIN */\n<line35>testcase( i==15 ); /* INSTEAD */\n<line36>testcase( i==16 ); /* ADD */\n<line37>testcase( i==17 ); /* DATABASE */\n<line38>testcase( i==18 ); /* AS */\n<line39>testcase( i==19 ); /* SELECT */\n<line40>testcase( i==20 ); /* TABLE */\n<line41>testcase( i==21 ); /* LEFT */\n<line42>testcase( i==22 ); /* THEN */\n<line43>testcase( i==23 ); /* END */\n<line44>testcase( i==24 ); /* DEFERRABLE */\n<line45>testcase( i==25 ); /* ELSE */\n<line46>testcase( i==26 ); /* EXCLUDE */\n<line47>testcase( i==27 ); /* DELETE */\n<line48>testcase( i==28 ); /* TEMPORARY */\n<line49>testcase( i==29 ); /* TEMP */\n<line50>testcase( i==30 ); /* OR */\n<line51>testcase( i==31 ); /* ISNULL */\n<line52>testcase( i==32 ); /* NULLS */\n<line53>testcase( i==33 ); /* SAVEPOINT */\n<line54>testcase( i==34 ); /* INTERSECT */\n<line55>testcase( i==35 ); /* TIES */\n<line56>testcase( i==36 ); /* NOTNULL */\n<line57>testcase( i==37 ); /* NOT */\n<line58>testcase( i==38 ); /* NO */\n<line59>testcase( i==39 ); /* NULL */\n<line60>testcase( i==40 ); /* LIKE */\n<line61>testcase( i==41 ); /* EXCEPT */\n<line62>testcase( i==42 ); /* TRANSACTION */\n<line63>testcase( i==43 ); /* ACTION */\n<line64>testcase( i==44 ); /* ON */\n<line65>testcase( i==45 ); /* NATURAL */\n<line66>testcase( i==46 ); /* ALTER */\n<line67>testcase( i==47 ); /* RAISE */\n<line68>testcase( i==48 ); /* EXCLUSIVE */\n<line69>testcase( i==49 ); /* EXISTS */\n<line70>testcase( i==50 ); /* CONSTRAINT */\n<line71>testcase( i==51 ); /* INTO */\n<line72>testcase( i==52 ); /* OFFSET */\n<line73>testcase( i==53 ); /* OF */\n<line74>testcase( i==54 ); /* SET */\n<line75>testcase( i==55 ); /* TRIGGER */\n<line76>testcase( i==56 ); /* RANGE */\n<line77>testcase( i==57 ); /* GENERATED */\n<line78>testcase( i==58 ); /* DETACH */\n<line79>testcase( i==59 ); /* HAVING */\n<line80>testcase( i==60 ); /* GLOB */\n<line81>testcase( i==61 ); /* BEGIN */\n<line82>testcase( i==62 ); /* INNER */\n<line83>testcase( i==63 ); /* REFERENCES */\n<line84>testcase( i==64 ); /* UNIQUE */\n<line85>testcase( i==65 ); /* QUERY */\n<line86>testcase( i==66 ); /* WITHOUT */\n<line87>testcase( i==67 ); /* WITH */\n<line88>testcase( i==68 ); /* OUTER */\n<line89>testcase( i==69 ); /* RELEASE */\n<line90>testcase( i==70 ); /* ATTACH */\n<line91>testcase( i==71 ); /* BETWEEN */\n<line92>testcase( i==72 ); /* NOTHING */\n<line93>testcase( i==73 ); /* GROUPS */\n<line94>testcase( i==74 ); /* GROUP */\n<line95>testcase( i==75 ); /* CASCADE */\n<line96>testcase( i==76 ); /* ASC */\n<line97>testcase( i==77 ); /* DEFAULT */\n<line98>testcase( i==78 ); /* CASE */\n<line99>testcase( i==79 ); /* COLLATE */\n<line100>testcase( i==80 ); /* CREATE */\n<line101>testcase( i==81 ); /* CURRENT_DATE */\n<line102>testcase( i==82 ); /* IMMEDIATE */\n<line103>testcase( i==83 ); /* JOIN */\n<line104>testcase( i==84 ); /* INSERT */\n<line105>testcase( i==85 ); /* MATCH */\n<line106>testcase( i==86 ); /* PLAN */\n<line107>testcase( i==87 ); /* ANALYZE */\n<line108>testcase( i==88 ); /* PRAGMA */\n<line109>testcase( i==89 ); /* MATERIALIZED */\n<line110>testcase( i==90 ); /* DEFERRED */\n<line111>testcase( i==91 ); /* DISTINCT */\n<line112>testcase( i==92 ); /* IS */\n<line113>testcase( i==93 ); /* UPDATE */\n<line114>testcase( i==94 ); /* VALUES */\n<line115>testcase( i==95 ); /* VIRTUAL */\n<line116>testcase( i==96 ); /* ALWAYS */\n<line117>testcase( i==97 ); /* WHEN */\n<line118>testcase( i==98 ); /* WHERE */\n<line119>testcase( i==99 ); /* RECURSIVE */\n<line120>testcase( i==100 ); /* ABORT */\n<line121>testcase( i==101 ); /* AFTER */\n<line122>testcase( i==102 ); /* RENAME */\n<line123>testcase( i==103 ); /* AND */\n<line124>testcase( i==104 ); /* DROP */\n<line125>testcase( i==105 ); /* PARTITION */\n<line126>testcase( i==106 ); /* AUTOINCREMENT */\n<line127>testcase( i==107 ); /* TO */\n<line128>testcase( i==108 ); /* IN */\n<line129>testcase( i==109 ); /* CAST */\n<line130>testcase( i==110 ); /* COLUMN */\n<line131>testcase( i==111 ); /* COMMIT */\n<line132>testcase( i==112 ); /* CONFLICT */\n<line133>testcase( i==113 ); /* CROSS */\n<line134>testcase( i==114 ); /* CURRENT_TIMESTAMP */\n<line135>testcase( i==115 ); /* CURRENT_TIME */\n<line136>testcase( i==116 ); /* CURRENT */\n<line137>testcase( i==117 ); /* PRECEDING */\n<line138>testcase( i==118 ); /* FAIL */\n<line139>testcase( i==119 ); /* LAST */\n<line140>testcase( i==120 ); /* FILTER */\n<line141>testcase( i==121 ); /* REPLACE */\n<line142>testcase( i==122 ); /* FIRST */\n<line143>testcase( i==123 ); /* FOLLOWING */\n<line144>testcase( i==124 ); /* FROM */\n<line145>testcase( i==125 ); /* FULL */\n<line146>testcase( i==126 ); /* LIMIT */\n<line147>testcase( i==127 ); /* IF */\n<line148>testcase( i==128 ); /* ORDER */\n<line149>testcase( i==129 ); /* RESTRICT */\n<line150>testcase( i==130 ); /* OTHERS */\n<line151>testcase( i==131 ); /* OVER */\n<line152>testcase( i==132 ); /* RETURNING */\n<line153>testcase( i==133 ); /* RIGHT */\n<line154>testcase( i==134 ); /* ROLLBACK */\n<line155>testcase( i==135 ); /* ROWS */\n<line156>testcase( i==136 ); /* ROW */\n<line157>testcase( i==137 ); /* UNBOUNDED */\n<line158>testcase( i==138 ); /* UNION */\n<line159>testcase( i==139 ); /* USING */\n<line160>testcase( i==140 ); /* VACUUM */\n<line161>testcase( i==141 ); /* VIEW */\n<line162>testcase( i==142 ); /* WINDOW */\n<line163>testcase( i==143 ); /* DO */\n<line164>testcase( i==144 ); /* BY */\n<line165>testcase( i==145 ); /* INITIALLY */\n<line166>testcase( i==146 ); /* ALL */\n<line167>testcase( i==147 ); /* PRIMARY */\n<line168>*pType = aKWCode[i];\n<line169>break;\n<line170>}\n<line171>return n;\n<line172>}
----------------------------------------
Function: sqlite3_keyword_name
Content: <line0>SQLITE_API int sqlite3_keyword_name(int i,const char **pzName,int *pnName){\n<line1>if( i<0 || i>=SQLITE_N_KEYWORD ) return SQLITE_ERROR;\n<line2>i++;\n<line3>*pzName = zKWText + aKWOffset[i];\n<line4>*pnName = aKWLen[i];\n<line5>return SQLITE_OK;\n<line6>}
----------------------------------------
Function: sqlite3_keyword_count
Content: <line0>SQLITE_API int sqlite3_keyword_count(void){ return SQLITE_N_KEYWORD; }
----------------------------------------
Function: sqlite3_keyword_check
Content: <line0>SQLITE_API int sqlite3_keyword_check(const char *zName, int nName){\n<line1>return TK_ID!=sqlite3KeywordCode((const u8*)zName, nName);\n<line2>}
----------------------------------------
Function: getToken
Content: <line0>static int getToken(const unsigned char **pz){\n<line1>const unsigned char *z = *pz;\n<line2>int t;                          /* Token type to return */\n<line3>do {\n<line4>z += sqlite3GetToken(z, &t);\n<line5>}while( t==TK_SPACE || t==TK_COMMENT );\n<line6>if( t==TK_ID\n<line7>|| t==TK_STRING\n<line8>|| t==TK_JOIN_KW\n<line9>|| t==TK_WINDOW\n<line10>|| t==TK_OVER\n<line11>|| sqlite3ParserFallback(t)==TK_ID\n<line12>){\n<line13>t = TK_ID;\n<line14>}\n<line15>*pz = z;\n<line16>return t;\n<line17>}
----------------------------------------
Function: analyzeWindowKeyword
Content: <line0>static int analyzeWindowKeyword(const unsigned char *z){\n<line1>int t;\n<line2>t = getToken(&z);\n<line3>if( t!=TK_ID ) return TK_ID;\n<line4>t = getToken(&z);\n<line5>if( t!=TK_AS ) return TK_ID;\n<line6>return TK_WINDOW;\n<line7>}
----------------------------------------
Function: analyzeOverKeyword
Content: <line0>static int analyzeOverKeyword(const unsigned char *z, int lastToken){\n<line1>if( lastToken==TK_RP ){\n<line2>int t = getToken(&z);\n<line3>if( t==TK_LP || t==TK_ID ) return TK_OVER;\n<line4>}\n<line5>return TK_ID;\n<line6>}
----------------------------------------
Function: analyzeFilterKeyword
Content: <line0>static int analyzeFilterKeyword(const unsigned char *z, int lastToken){\n<line1>if( lastToken==TK_RP && getToken(&z)==TK_LP ){\n<line2>return TK_FILTER;\n<line3>}\n<line4>return TK_ID;\n<line5>}
----------------------------------------
Function: sqlite3_complete
Content: <line0>SQLITE_API int sqlite3_complete(const char *zSql){\n<line1>u8 state = 0;   /* Current state, using numbers defined in header comment */\n<line2>u8 token;       /* Value of the next token */\n<line3>#ifndef SQLITE_OMIT_TRIGGER\n<line4>/* A complex statement machine used to detect the end of a CREATE TRIGGER\n<line5>** statement.  This is the normal case.\n<line6>*/\n<line7>static const u8 trans[8][8] = {\n<line8>/* Token:                                                */\n<line9>/* State:       **  SEMI  WS  OTHER  EXPLAIN  CREATE  TEMP  TRIGGER  END */\n<line10>/* 0 INVALID: */ {    1,  0,     2,       3,      4,    2,       2,   2, },\n<line11>/* 1   START: */ {    1,  1,     2,       3,      4,    2,       2,   2, },\n<line12>/* 2  NORMAL: */ {    1,  2,     2,       2,      2,    2,       2,   2, },\n<line13>/* 3 EXPLAIN: */ {    1,  3,     3,       2,      4,    2,       2,   2, },\n<line14>/* 4  CREATE: */ {    1,  4,     2,       2,      2,    4,       5,   2, },\n<line15>/* 5 TRIGGER: */ {    6,  5,     5,       5,      5,    5,       5,   5, },\n<line16>/* 6    SEMI: */ {    6,  6,     5,       5,      5,    5,       5,   7, },\n<line17>/* 7     END: */ {    1,  7,     5,       5,      5,    5,       5,   5, },\n<line18>};\n<line19>#else\n<line20>/* If triggers are not supported by this compile then the statement machine\n<line21>** used to detect the end of a statement is much simpler\n<line22>*/\n<line23>static const u8 trans[3][3] = {\n<line24>/* Token:           */\n<line25>/* State:       **  SEMI  WS  OTHER */\n<line26>/* 0 INVALID: */ {    1,  0,     2, },\n<line27>/* 1   START: */ {    1,  1,     2, },\n<line28>/* 2  NORMAL: */ {    1,  2,     2, },\n<line29>};\n<line30>#endif /* SQLITE_OMIT_TRIGGER */\n<line31>#ifdef SQLITE_ENABLE_API_ARMOR\n<line32>if( zSql==0 ){\n<line33>(void)SQLITE_MISUSE_BKPT;\n<line34>return 0;\n<line35>}\n<line36>#endif\n<line37>while( *zSql ){\n<line38>switch( *zSql ){\n<line39>case ';': {  /* A semicolon */\n<line40>token = tkSEMI;\n<line41>break;\n<line42>}\n<line43>case ' ':\n<line44>case '\r':\n<line45>case '\t':\n<line46>case '\n':\n<line47>case '\f': {  /* White space is ignored */\n<line48>token = tkWS;\n<line49>break;\n<line50>}\n<line51>case '/': {   /* C-style comments */\n<line52>if( zSql[1]!='*' ){\n<line53>token = tkOTHER;\n<line54>break;\n<line55>}\n<line56>zSql += 2;\n<line57>while( zSql[0] && (zSql[0]!='*' || zSql[1]!='/') ){ zSql++; }\n<line58>if( zSql[0]==0 ) return 0;\n<line59>zSql++;\n<line60>token = tkWS;\n<line61>break;\n<line62>}\n<line63>case '-': {   /* SQL-style comments from "--" to end of line */\n<line64>if( zSql[1]!='-' ){\n<line65>token = tkOTHER;\n<line66>break;\n<line67>}\n<line68>while( *zSql && *zSql!='\n' ){ zSql++; }\n<line69>if( *zSql==0 ) return state==1;\n<line70>token = tkWS;\n<line71>break;\n<line72>}\n<line73>case '[': {   /* Microsoft-style identifiers in [...] */\n<line74>zSql++;\n<line75>while( *zSql && *zSql!=']' ){ zSql++; }\n<line76>if( *zSql==0 ) return 0;\n<line77>token = tkOTHER;\n<line78>break;\n<line79>}\n<line80>case '`':     /* Grave-accent quoted symbols used by MySQL */\n<line81>case '"':     /* single- and double-quoted strings */\n<line82>case '\'': {\n<line83>int c = *zSql;\n<line84>zSql++;\n<line85>while( *zSql && *zSql!=c ){ zSql++; }\n<line86>if( *zSql==0 ) return 0;\n<line87>token = tkOTHER;\n<line88>break;\n<line89>}\n<line90>default: {\n<line91>#ifdef SQLITE_EBCDIC\n<line92>unsigned char c;\n<line93>#endif\n<line94>if( IdChar((u8)*zSql) ){\n<line95>/* Keywords and unquoted identifiers */\n<line96>int nId;\n<line97>for(nId=1; IdChar(zSql[nId]); nId++){}\n<line98>#ifdef SQLITE_OMIT_TRIGGER\n<line99>token = tkOTHER;\n<line100>#else\n<line101>switch( *zSql ){\n<line102>case 'c': case 'C': {\n<line103>if( nId==6 && sqlite3StrNICmp(zSql, "create", 6)==0 ){\n<line104>token = tkCREATE;\n<line105>}else{\n<line106>token = tkOTHER;\n<line107>}\n<line108>break;\n<line109>}\n<line110>case 't': case 'T': {\n<line111>if( nId==7 && sqlite3StrNICmp(zSql, "trigger", 7)==0 ){\n<line112>token = tkTRIGGER;\n<line113>}else if( nId==4 && sqlite3StrNICmp(zSql, "temp", 4)==0 ){\n<line114>token = tkTEMP;\n<line115>}else if( nId==9 && sqlite3StrNICmp(zSql, "temporary", 9)==0 ){\n<line116>token = tkTEMP;\n<line117>}else{\n<line118>token = tkOTHER;\n<line119>}\n<line120>break;\n<line121>}\n<line122>case 'e':  case 'E': {\n<line123>if( nId==3 && sqlite3StrNICmp(zSql, "end", 3)==0 ){\n<line124>token = tkEND;\n<line125>}else\n<line126>#ifndef SQLITE_OMIT_EXPLAIN\n<line127>if( nId==7 && sqlite3StrNICmp(zSql, "explain", 7)==0 ){\n<line128>token = tkEXPLAIN;\n<line129>}else\n<line130>#endif\n<line131>{\n<line132>token = tkOTHER;\n<line133>}\n<line134>break;\n<line135>}\n<line136>default: {\n<line137>token = tkOTHER;\n<line138>break;\n<line139>}\n<line140>}\n<line141>#endif /* SQLITE_OMIT_TRIGGER */\n<line142>zSql += nId-1;\n<line143>}else{\n<line144>/* Operators and special symbols */\n<line145>token = tkOTHER;\n<line146>}\n<line147>break;\n<line148>}\n<line149>}\n<line150>state = trans[state][token];\n<line151>zSql++;\n<line152>}\n<line153>return state==1;\n<line154>}
----------------------------------------
Function: sqlite3_complete16
Content: <line0>SQLITE_API int sqlite3_complete16(const void *zSql){\n<line1>sqlite3_value *pVal;\n<line2>char const *zSql8;\n<line3>int rc;\n<line4>#ifndef SQLITE_OMIT_AUTOINIT\n<line5>rc = sqlite3_initialize();\n<line6>if( rc ) return rc;\n<line7>#endif\n<line8>pVal = sqlite3ValueNew(0);\n<line9>sqlite3ValueSetStr(pVal, -1, zSql, SQLITE_UTF16NATIVE, SQLITE_STATIC);\n<line10>zSql8 = sqlite3ValueText(pVal, SQLITE_UTF8);\n<line11>if( zSql8 ){\n<line12>rc = sqlite3_complete(zSql8);\n<line13>}else{\n<line14>rc = SQLITE_NOMEM_BKPT;\n<line15>}\n<line16>sqlite3ValueFree(pVal);\n<line17>return rc & 0xff;\n<line18>}
----------------------------------------
Function: sqlite3TestExtInit
Content: <line0>static int sqlite3TestExtInit(sqlite3 *db){\n<line1>(void)db;\n<line2>return sqlite3FaultSim(500);\n<line3>}
----------------------------------------
Function: sqlite3_libversion
Content: <line0>SQLITE_API const char *sqlite3_libversion(void){ return sqlite3_version; }
----------------------------------------
Function: sqlite3_libversion_number
Content: <line0>SQLITE_API int sqlite3_libversion_number(void){ return SQLITE_VERSION_NUMBER; }
----------------------------------------
Function: sqlite3_threadsafe
Content: <line0>SQLITE_API int sqlite3_threadsafe(void){ return SQLITE_THREADSAFE; }
----------------------------------------
Function: sqlite3_initialize
Content: <line0>SQLITE_API int sqlite3_initialize(void){\n<line1>MUTEX_LOGIC( sqlite3_mutex *pMainMtx; )      /* The main static mutex */\n<line2>int rc;                                      /* Result code */\n<line3>#ifdef SQLITE_EXTRA_INIT\n<line4>int bRunExtraInit = 0;                       /* Extra initialization needed */\n<line5>#endif\n<line6>#ifdef SQLITE_OMIT_WSD\n<line7>rc = sqlite3_wsd_init(4096, 24);\n<line8>if( rc!=SQLITE_OK ){\n<line9>return rc;\n<line10>}\n<line11>#endif\n<line12>/* If the following assert() fails on some obscure processor/compiler\n<line13>** combination, the work-around is to set the correct pointer\n<line14>** size at compile-time using -DSQLITE_PTRSIZE=n compile-time option */\n<line15>assert( SQLITE_PTRSIZE==sizeof(char*) );\n<line16>/* If SQLite is already completely initialized, then this call\n<line17>** to sqlite3_initialize() should be a no-op.  But the initialization\n<line18>** must be complete.  So isInit must not be set until the very end\n<line19>** of this routine.\n<line20>*/\n<line21>if( sqlite3GlobalConfig.isInit ){\n<line22>sqlite3MemoryBarrier();\n<line23>return SQLITE_OK;\n<line24>}\n<line25>/* Make sure the mutex subsystem is initialized.  If unable to\n<line26>** initialize the mutex subsystem, return early with the error.\n<line27>** If the system is so sick that we are unable to allocate a mutex,\n<line28>** there is not much SQLite is going to be able to do.\n<line29>**\n<line30>** The mutex subsystem must take care of serializing its own\n<line31>** initialization.\n<line32>*/\n<line33>rc = sqlite3MutexInit();\n<line34>if( rc ) return rc;\n<line35>/* Initialize the malloc() system and the recursive pInitMutex mutex.\n<line36>** This operation is protected by the STATIC_MAIN mutex.  Note that\n<line37>** MutexAlloc() is called for a static mutex prior to initializing the\n<line38>** malloc subsystem - this implies that the allocation of a static\n<line39>** mutex must not require support from the malloc subsystem.\n<line40>*/\n<line41>MUTEX_LOGIC( pMainMtx = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MAIN); )\n<line42>sqlite3_mutex_enter(pMainMtx);\n<line43>sqlite3GlobalConfig.isMutexInit = 1;\n<line44>if( !sqlite3GlobalConfig.isMallocInit ){\n<line45>rc = sqlite3MallocInit();\n<line46>}\n<line47>if( rc==SQLITE_OK ){\n<line48>sqlite3GlobalConfig.isMallocInit = 1;\n<line49>if( !sqlite3GlobalConfig.pInitMutex ){\n<line50>sqlite3GlobalConfig.pInitMutex =\n<line51>sqlite3MutexAlloc(SQLITE_MUTEX_RECURSIVE);\n<line52>if( sqlite3GlobalConfig.bCoreMutex && !sqlite3GlobalConfig.pInitMutex ){\n<line53>rc = SQLITE_NOMEM_BKPT;\n<line54>}\n<line55>}\n<line56>}\n<line57>if( rc==SQLITE_OK ){\n<line58>sqlite3GlobalConfig.nRefInitMutex++;\n<line59>}\n<line60>sqlite3_mutex_leave(pMainMtx);\n<line61>/* If rc is not SQLITE_OK at this point, then either the malloc\n<line62>** subsystem could not be initialized or the system failed to allocate\n<line63>** the pInitMutex mutex. Return an error in either case.  */\n<line64>if( rc!=SQLITE_OK ){\n<line65>return rc;\n<line66>}\n<line67>/* Do the rest of the initialization under the recursive mutex so\n<line68>** that we will be able to handle recursive calls into\n<line69>** sqlite3_initialize().  The recursive calls normally come through\n<line70>** sqlite3_os_init() when it invokes sqlite3_vfs_register(), but other\n<line71>** recursive calls might also be possible.\n<line72>**\n<line73>** IMPLEMENTATION-OF: R-00140-37445 SQLite automatically serializes calls\n<line74>** to the xInit method, so the xInit method need not be threadsafe.\n<line75>**\n<line76>** The following mutex is what serializes access to the appdef pcache xInit\n<line77>** methods.  The sqlite3_pcache_methods.xInit() all is embedded in the\n<line78>** call to sqlite3PcacheInitialize().\n<line79>*/\n<line80>sqlite3_mutex_enter(sqlite3GlobalConfig.pInitMutex);\n<line81>if( sqlite3GlobalConfig.isInit==0 && sqlite3GlobalConfig.inProgress==0 ){\n<line82>sqlite3GlobalConfig.inProgress = 1;\n<line83>#ifdef SQLITE_ENABLE_SQLLOG\n<line84>{\n<line85>extern void sqlite3_init_sqllog(void);\n<line86>sqlite3_init_sqllog();\n<line87>}\n<line88>#endif\n<line89>memset(&sqlite3BuiltinFunctions, 0, sizeof(sqlite3BuiltinFunctions));\n<line90>sqlite3RegisterBuiltinFunctions();\n<line91>if( sqlite3GlobalConfig.isPCacheInit==0 ){\n<line92>rc = sqlite3PcacheInitialize();\n<line93>}\n<line94>if( rc==SQLITE_OK ){\n<line95>sqlite3GlobalConfig.isPCacheInit = 1;\n<line96>rc = sqlite3OsInit();\n<line97>}\n<line98>#ifndef SQLITE_OMIT_DESERIALIZE\n<line99>if( rc==SQLITE_OK ){\n<line100>rc = sqlite3MemdbInit();\n<line101>}\n<line102>#endif\n<line103>if( rc==SQLITE_OK ){\n<line104>sqlite3PCacheBufferSetup( sqlite3GlobalConfig.pPage,\n<line105>sqlite3GlobalConfig.szPage, sqlite3GlobalConfig.nPage);\n<line106>#ifdef SQLITE_EXTRA_INIT_MUTEXED\n<line107>{\n<line108>int SQLITE_EXTRA_INIT_MUTEXED(const char*);\n<line109>rc = SQLITE_EXTRA_INIT_MUTEXED(0);\n<line110>}\n<line111>#endif\n<line112>}\n<line113>if( rc==SQLITE_OK ){\n<line114>sqlite3MemoryBarrier();\n<line115>sqlite3GlobalConfig.isInit = 1;\n<line116>#ifdef SQLITE_EXTRA_INIT\n<line117>bRunExtraInit = 1;\n<line118>#endif\n<line119>}\n<line120>sqlite3GlobalConfig.inProgress = 0;\n<line121>}\n<line122>sqlite3_mutex_leave(sqlite3GlobalConfig.pInitMutex);\n<line123>/* Go back under the static mutex and clean up the recursive\n<line124>** mutex to prevent a resource leak.\n<line125>*/\n<line126>sqlite3_mutex_enter(pMainMtx);\n<line127>sqlite3GlobalConfig.nRefInitMutex--;\n<line128>if( sqlite3GlobalConfig.nRefInitMutex<=0 ){\n<line129>assert( sqlite3GlobalConfig.nRefInitMutex==0 );\n<line130>sqlite3_mutex_free(sqlite3GlobalConfig.pInitMutex);\n<line131>sqlite3GlobalConfig.pInitMutex = 0;\n<line132>}\n<line133>sqlite3_mutex_leave(pMainMtx);\n<line134>/* The following is just a sanity check to make sure SQLite has\n<line135>** been compiled correctly.  It is important to run this code, but\n<line136>** we don't want to run it too often and soak up CPU cycles for no\n<line137>** reason.  So we run it once during initialization.\n<line138>*/\n<line139>#ifndef NDEBUG\n<line140>#ifndef SQLITE_OMIT_FLOATING_POINT\n<line141>/* This section of code's only "output" is via assert() statements. */\n<line142>if( rc==SQLITE_OK ){\n<line143>u64 x = (((u64)1)<<63)-1;\n<line144>double y;\n<line145>assert(sizeof(x)==8);\n<line146>assert(sizeof(x)==sizeof(y));\n<line147>memcpy(&y, &x, 8);\n<line148>assert( sqlite3IsNaN(y) );\n<line149>}\n<line150>#endif\n<line151>#endif\n<line152>/* Do extra initialization steps requested by the SQLITE_EXTRA_INIT\n<line153>** compile-time option.\n<line154>*/\n<line155>#ifdef SQLITE_EXTRA_INIT\n<line156>if( bRunExtraInit ){\n<line157>int SQLITE_EXTRA_INIT(const char*);\n<line158>rc = SQLITE_EXTRA_INIT(0);\n<line159>}\n<line160>#endif\n<line161>return rc;\n<line162>}
----------------------------------------
Function: sqlite3_shutdown
Content: <line0>SQLITE_API int sqlite3_shutdown(void){\n<line1>#ifdef SQLITE_OMIT_WSD\n<line2>int rc = sqlite3_wsd_init(4096, 24);\n<line3>if( rc!=SQLITE_OK ){\n<line4>return rc;\n<line5>}\n<line6>#endif\n<line7>if( sqlite3GlobalConfig.isInit ){\n<line8>#ifdef SQLITE_EXTRA_SHUTDOWN\n<line9>void SQLITE_EXTRA_SHUTDOWN(void);\n<line10>SQLITE_EXTRA_SHUTDOWN();\n<line11>#endif\n<line12>sqlite3_os_end();\n<line13>sqlite3_reset_auto_extension();\n<line14>sqlite3GlobalConfig.isInit = 0;\n<line15>}\n<line16>if( sqlite3GlobalConfig.isPCacheInit ){\n<line17>sqlite3PcacheShutdown();\n<line18>sqlite3GlobalConfig.isPCacheInit = 0;\n<line19>}\n<line20>if( sqlite3GlobalConfig.isMallocInit ){\n<line21>sqlite3MallocEnd();\n<line22>sqlite3GlobalConfig.isMallocInit = 0;\n<line23>#ifndef SQLITE_OMIT_SHUTDOWN_DIRECTORIES\n<line24>/* The heap subsystem has now been shutdown and these values are supposed\n<line25>** to be NULL or point to memory that was obtained from sqlite3_malloc(),\n<line26>** which would rely on that heap subsystem; therefore, make sure these\n<line27>** values cannot refer to heap memory that was just invalidated when the\n<line28>** heap subsystem was shutdown.  This is only done if the current call to\n<line29>** this function resulted in the heap subsystem actually being shutdown.\n<line30>*/\n<line31>sqlite3_data_directory = 0;\n<line32>sqlite3_temp_directory = 0;\n<line33>#endif\n<line34>}\n<line35>if( sqlite3GlobalConfig.isMutexInit ){\n<line36>sqlite3MutexEnd();\n<line37>sqlite3GlobalConfig.isMutexInit = 0;\n<line38>}\n<line39>return SQLITE_OK;\n<line40>}
----------------------------------------
Function: sqlite3_config
Content: <line0>SQLITE_API int sqlite3_config(int op, ...){\n<line1>va_list ap;\n<line2>int rc = SQLITE_OK;\n<line3>/* sqlite3_config() normally returns SQLITE_MISUSE if it is invoked while\n<line4>** the SQLite library is in use.  Except, a few selected opcodes\n<line5>** are allowed.\n<line6>*/\n<line7>if( sqlite3GlobalConfig.isInit ){\n<line8>static const u64 mAnytimeConfigOption = 0\n<line9>| MASKBIT64( SQLITE_CONFIG_LOG )\n<line10>| MASKBIT64( SQLITE_CONFIG_PCACHE_HDRSZ )\n<line11>;\n<line12>if( op<0 || op>63 || (MASKBIT64(op) & mAnytimeConfigOption)==0 ){\n<line13>return SQLITE_MISUSE_BKPT;\n<line14>}\n<line15>testcase( op==SQLITE_CONFIG_LOG );\n<line16>testcase( op==SQLITE_CONFIG_PCACHE_HDRSZ );\n<line17>}\n<line18>va_start(ap, op);\n<line19>switch( op ){\n<line20>/* Mutex configuration options are only available in a threadsafe\n<line21>** compile.\n<line22>*/\n<line23>#if defined(SQLITE_THREADSAFE) && SQLITE_THREADSAFE>0  /* IMP: R-54466-46756 */\n<line24>case SQLITE_CONFIG_SINGLETHREAD: {\n<line25>/* EVIDENCE-OF: R-02748-19096 This option sets the threading mode to\n<line26>** Single-thread. */\n<line27>sqlite3GlobalConfig.bCoreMutex = 0;  /* Disable mutex on core */\n<line28>sqlite3GlobalConfig.bFullMutex = 0;  /* Disable mutex on connections */\n<line29>break;\n<line30>}\n<line31>#endif\n<line32>#if defined(SQLITE_THREADSAFE) && SQLITE_THREADSAFE>0 /* IMP: R-20520-54086 */\n<line33>case SQLITE_CONFIG_MULTITHREAD: {\n<line34>/* EVIDENCE-OF: R-14374-42468 This option sets the threading mode to\n<line35>** Multi-thread. */\n<line36>sqlite3GlobalConfig.bCoreMutex = 1;  /* Enable mutex on core */\n<line37>sqlite3GlobalConfig.bFullMutex = 0;  /* Disable mutex on connections */\n<line38>break;\n<line39>}\n<line40>#endif\n<line41>#if defined(SQLITE_THREADSAFE) && SQLITE_THREADSAFE>0 /* IMP: R-59593-21810 */\n<line42>case SQLITE_CONFIG_SERIALIZED: {\n<line43>/* EVIDENCE-OF: R-41220-51800 This option sets the threading mode to\n<line44>** Serialized. */\n<line45>sqlite3GlobalConfig.bCoreMutex = 1;  /* Enable mutex on core */\n<line46>sqlite3GlobalConfig.bFullMutex = 1;  /* Enable mutex on connections */\n<line47>break;\n<line48>}\n<line49>#endif\n<line50>#if defined(SQLITE_THREADSAFE) && SQLITE_THREADSAFE>0 /* IMP: R-63666-48755 */\n<line51>case SQLITE_CONFIG_MUTEX: {\n<line52>/* Specify an alternative mutex implementation */\n<line53>sqlite3GlobalConfig.mutex = *va_arg(ap, sqlite3_mutex_methods*);\n<line54>break;\n<line55>}\n<line56>#endif\n<line57>#if defined(SQLITE_THREADSAFE) && SQLITE_THREADSAFE>0 /* IMP: R-14450-37597 */\n<line58>case SQLITE_CONFIG_GETMUTEX: {\n<line59>/* Retrieve the current mutex implementation */\n<line60>*va_arg(ap, sqlite3_mutex_methods*) = sqlite3GlobalConfig.mutex;\n<line61>break;\n<line62>}\n<line63>#endif\n<line64>case SQLITE_CONFIG_MALLOC: {\n<line65>/* EVIDENCE-OF: R-55594-21030 The SQLITE_CONFIG_MALLOC option takes a\n<line66>** single argument which is a pointer to an instance of the\n<line67>** sqlite3_mem_methods structure. The argument specifies alternative\n<line68>** low-level memory allocation routines to be used in place of the memory\n<line69>** allocation routines built into SQLite. */\n<line70>sqlite3GlobalConfig.m = *va_arg(ap, sqlite3_mem_methods*);\n<line71>break;\n<line72>}\n<line73>case SQLITE_CONFIG_GETMALLOC: {\n<line74>/* EVIDENCE-OF: R-51213-46414 The SQLITE_CONFIG_GETMALLOC option takes a\n<line75>** single argument which is a pointer to an instance of the\n<line76>** sqlite3_mem_methods structure. The sqlite3_mem_methods structure is\n<line77>** filled with the currently defined memory allocation routines. */\n<line78>if( sqlite3GlobalConfig.m.xMalloc==0 ) sqlite3MemSetDefault();\n<line79>*va_arg(ap, sqlite3_mem_methods*) = sqlite3GlobalConfig.m;\n<line80>break;\n<line81>}\n<line82>case SQLITE_CONFIG_MEMSTATUS: {\n<line83>assert( !sqlite3GlobalConfig.isInit );  /* Cannot change at runtime */\n<line84>/* EVIDENCE-OF: R-61275-35157 The SQLITE_CONFIG_MEMSTATUS option takes\n<line85>** single argument of type int, interpreted as a boolean, which enables\n<line86>** or disables the collection of memory allocation statistics. */\n<line87>sqlite3GlobalConfig.bMemstat = va_arg(ap, int);\n<line88>break;\n<line89>}\n<line90>case SQLITE_CONFIG_SMALL_MALLOC: {\n<line91>sqlite3GlobalConfig.bSmallMalloc = va_arg(ap, int);\n<line92>break;\n<line93>}\n<line94>case SQLITE_CONFIG_PAGECACHE: {\n<line95>/* EVIDENCE-OF: R-18761-36601 There are three arguments to\n<line96>** SQLITE_CONFIG_PAGECACHE: A pointer to 8-byte aligned memory (pMem),\n<line97>** the size of each page cache line (sz), and the number of cache lines\n<line98>** (N). */\n<line99>sqlite3GlobalConfig.pPage = va_arg(ap, void*);\n<line100>sqlite3GlobalConfig.szPage = va_arg(ap, int);\n<line101>sqlite3GlobalConfig.nPage = va_arg(ap, int);\n<line102>break;\n<line103>}\n<line104>case SQLITE_CONFIG_PCACHE_HDRSZ: {\n<line105>/* EVIDENCE-OF: R-39100-27317 The SQLITE_CONFIG_PCACHE_HDRSZ option takes\n<line106>** a single parameter which is a pointer to an integer and writes into\n<line107>** that integer the number of extra bytes per page required for each page\n<line108>** in SQLITE_CONFIG_PAGECACHE. */\n<line109>*va_arg(ap, int*) =\n<line110>sqlite3HeaderSizeBtree() +\n<line111>sqlite3HeaderSizePcache() +\n<line112>sqlite3HeaderSizePcache1();\n<line113>break;\n<line114>}\n<line115>case SQLITE_CONFIG_PCACHE: {\n<line116>/* no-op */\n<line117>break;\n<line118>}\n<line119>case SQLITE_CONFIG_GETPCACHE: {\n<line120>/* now an error */\n<line121>rc = SQLITE_ERROR;\n<line122>break;\n<line123>}\n<line124>case SQLITE_CONFIG_PCACHE2: {\n<line125>/* EVIDENCE-OF: R-63325-48378 The SQLITE_CONFIG_PCACHE2 option takes a\n<line126>** single argument which is a pointer to an sqlite3_pcache_methods2\n<line127>** object. This object specifies the interface to a custom page cache\n<line128>** implementation. */\n<line129>sqlite3GlobalConfig.pcache2 = *va_arg(ap, sqlite3_pcache_methods2*);\n<line130>break;\n<line131>}\n<line132>case SQLITE_CONFIG_GETPCACHE2: {\n<line133>/* EVIDENCE-OF: R-22035-46182 The SQLITE_CONFIG_GETPCACHE2 option takes a\n<line134>** single argument which is a pointer to an sqlite3_pcache_methods2\n<line135>** object. SQLite copies of the current page cache implementation into\n<line136>** that object. */\n<line137>if( sqlite3GlobalConfig.pcache2.xInit==0 ){\n<line138>sqlite3PCacheSetDefault();\n<line139>}\n<line140>*va_arg(ap, sqlite3_pcache_methods2*) = sqlite3GlobalConfig.pcache2;\n<line141>break;\n<line142>}\n<line143>/* EVIDENCE-OF: R-06626-12911 The SQLITE_CONFIG_HEAP option is only\n<line144>** available if SQLite is compiled with either SQLITE_ENABLE_MEMSYS3 or\n<line145>** SQLITE_ENABLE_MEMSYS5 and returns SQLITE_ERROR if invoked otherwise. */\n<line146>#if defined(SQLITE_ENABLE_MEMSYS3) || defined(SQLITE_ENABLE_MEMSYS5)\n<line147>case SQLITE_CONFIG_HEAP: {\n<line148>/* EVIDENCE-OF: R-19854-42126 There are three arguments to\n<line149>** SQLITE_CONFIG_HEAP: An 8-byte aligned pointer to the memory, the\n<line150>** number of bytes in the memory buffer, and the minimum allocation size.\n<line151>*/\n<line152>sqlite3GlobalConfig.pHeap = va_arg(ap, void*);\n<line153>sqlite3GlobalConfig.nHeap = va_arg(ap, int);\n<line154>sqlite3GlobalConfig.mnReq = va_arg(ap, int);\n<line155>if( sqlite3GlobalConfig.mnReq<1 ){\n<line156>sqlite3GlobalConfig.mnReq = 1;\n<line157>}else if( sqlite3GlobalConfig.mnReq>(1<<12) ){\n<line158>/* cap min request size at 2^12 */\n<line159>sqlite3GlobalConfig.mnReq = (1<<12);\n<line160>}\n<line161>if( sqlite3GlobalConfig.pHeap==0 ){\n<line162>/* EVIDENCE-OF: R-49920-60189 If the first pointer (the memory pointer)\n<line163>** is NULL, then SQLite reverts to using its default memory allocator\n<line164>** (the system malloc() implementation), undoing any prior invocation of\n<line165>** SQLITE_CONFIG_MALLOC.\n<line166>**\n<line167>** Setting sqlite3GlobalConfig.m to all zeros will cause malloc to\n<line168>** revert to its default implementation when sqlite3_initialize() is run\n<line169>*/\n<line170>memset(&sqlite3GlobalConfig.m, 0, sizeof(sqlite3GlobalConfig.m));\n<line171>}else{\n<line172>/* EVIDENCE-OF: R-61006-08918 If the memory pointer is not NULL then the\n<line173>** alternative memory allocator is engaged to handle all of SQLites\n<line174>** memory allocation needs. */\n<line175>#ifdef SQLITE_ENABLE_MEMSYS3\n<line176>sqlite3GlobalConfig.m = *sqlite3MemGetMemsys3();\n<line177>#endif\n<line178>#ifdef SQLITE_ENABLE_MEMSYS5\n<line179>sqlite3GlobalConfig.m = *sqlite3MemGetMemsys5();\n<line180>#endif\n<line181>}\n<line182>break;\n<line183>}\n<line184>#endif\n<line185>case SQLITE_CONFIG_LOOKASIDE: {\n<line186>sqlite3GlobalConfig.szLookaside = va_arg(ap, int);\n<line187>sqlite3GlobalConfig.nLookaside = va_arg(ap, int);\n<line188>break;\n<line189>}\n<line190>/* Record a pointer to the logger function and its first argument.\n<line191>** The default is NULL.  Logging is disabled if the function pointer is\n<line192>** NULL.\n<line193>*/\n<line194>case SQLITE_CONFIG_LOG: {\n<line195>/* MSVC is picky about pulling func ptrs from va lists.\n<line196>** http://support.microsoft.com/kb/47961\n<line197>** sqlite3GlobalConfig.xLog = va_arg(ap, void(*)(void*,int,const char*));\n<line198>*/\n<line199>typedef void(*LOGFUNC_t)(void*,int,const char*);\n<line200>LOGFUNC_t xLog = va_arg(ap, LOGFUNC_t);\n<line201>void *pLogArg = va_arg(ap, void*);\n<line202>AtomicStore(&sqlite3GlobalConfig.xLog, xLog);\n<line203>AtomicStore(&sqlite3GlobalConfig.pLogArg, pLogArg);\n<line204>break;\n<line205>}\n<line206>/* EVIDENCE-OF: R-55548-33817 The compile-time setting for URI filenames\n<line207>** can be changed at start-time using the\n<line208>** sqlite3_config(SQLITE_CONFIG_URI,1) or\n<line209>** sqlite3_config(SQLITE_CONFIG_URI,0) configuration calls.\n<line210>*/\n<line211>case SQLITE_CONFIG_URI: {\n<line212>/* EVIDENCE-OF: R-25451-61125 The SQLITE_CONFIG_URI option takes a single\n<line213>** argument of type int. If non-zero, then URI handling is globally\n<line214>** enabled. If the parameter is zero, then URI handling is globally\n<line215>** disabled. */\n<line216>int bOpenUri = va_arg(ap, int);\n<line217>AtomicStore(&sqlite3GlobalConfig.bOpenUri, bOpenUri);\n<line218>break;\n<line219>}\n<line220>case SQLITE_CONFIG_COVERING_INDEX_SCAN: {\n<line221>/* EVIDENCE-OF: R-36592-02772 The SQLITE_CONFIG_COVERING_INDEX_SCAN\n<line222>** option takes a single integer argument which is interpreted as a\n<line223>** boolean in order to enable or disable the use of covering indices for\n<line224>** full table scans in the query optimizer. */\n<line225>sqlite3GlobalConfig.bUseCis = va_arg(ap, int);\n<line226>break;\n<line227>}\n<line228>#ifdef SQLITE_ENABLE_SQLLOG\n<line229>case SQLITE_CONFIG_SQLLOG: {\n<line230>typedef void(*SQLLOGFUNC_t)(void*, sqlite3*, const char*, int);\n<line231>sqlite3GlobalConfig.xSqllog = va_arg(ap, SQLLOGFUNC_t);\n<line232>sqlite3GlobalConfig.pSqllogArg = va_arg(ap, void *);\n<line233>break;\n<line234>}\n<line235>#endif\n<line236>case SQLITE_CONFIG_MMAP_SIZE: {\n<line237>/* EVIDENCE-OF: R-58063-38258 SQLITE_CONFIG_MMAP_SIZE takes two 64-bit\n<line238>** integer (sqlite3_int64) values that are the default mmap size limit\n<line239>** (the default setting for PRAGMA mmap_size) and the maximum allowed\n<line240>** mmap size limit. */\n<line241>sqlite3_int64 szMmap = va_arg(ap, sqlite3_int64);\n<line242>sqlite3_int64 mxMmap = va_arg(ap, sqlite3_int64);\n<line243>/* EVIDENCE-OF: R-53367-43190 If either argument to this option is\n<line244>** negative, then that argument is changed to its compile-time default.\n<line245>**\n<line246>** EVIDENCE-OF: R-34993-45031 The maximum allowed mmap size will be\n<line247>** silently truncated if necessary so that it does not exceed the\n<line248>** compile-time maximum mmap size set by the SQLITE_MAX_MMAP_SIZE\n<line249>** compile-time option.\n<line250>*/\n<line251>if( mxMmap<0 || mxMmap>SQLITE_MAX_MMAP_SIZE ){\n<line252>mxMmap = SQLITE_MAX_MMAP_SIZE;\n<line253>}\n<line254>if( szMmap<0 ) szMmap = SQLITE_DEFAULT_MMAP_SIZE;\n<line255>if( szMmap>mxMmap) szMmap = mxMmap;\n<line256>sqlite3GlobalConfig.mxMmap = mxMmap;\n<line257>sqlite3GlobalConfig.szMmap = szMmap;\n<line258>break;\n<line259>}\n<line260>#if SQLITE_OS_WIN && defined(SQLITE_WIN32_MALLOC) /* IMP: R-04780-55815 */\n<line261>case SQLITE_CONFIG_WIN32_HEAPSIZE: {\n<line262>/* EVIDENCE-OF: R-34926-03360 SQLITE_CONFIG_WIN32_HEAPSIZE takes a 32-bit\n<line263>** unsigned integer value that specifies the maximum size of the created\n<line264>** heap. */\n<line265>sqlite3GlobalConfig.nHeap = va_arg(ap, int);\n<line266>break;\n<line267>}\n<line268>#endif\n<line269>case SQLITE_CONFIG_PMASZ: {\n<line270>sqlite3GlobalConfig.szPma = va_arg(ap, unsigned int);\n<line271>break;\n<line272>}\n<line273>case SQLITE_CONFIG_STMTJRNL_SPILL: {\n<line274>sqlite3GlobalConfig.nStmtSpill = va_arg(ap, int);\n<line275>break;\n<line276>}\n<line277>#ifdef SQLITE_ENABLE_SORTER_REFERENCES\n<line278>case SQLITE_CONFIG_SORTERREF_SIZE: {\n<line279>int iVal = va_arg(ap, int);\n<line280>if( iVal<0 ){\n<line281>iVal = SQLITE_DEFAULT_SORTERREF_SIZE;\n<line282>}\n<line283>sqlite3GlobalConfig.szSorterRef = (u32)iVal;\n<line284>break;\n<line285>}\n<line286>#endif /* SQLITE_ENABLE_SORTER_REFERENCES */\n<line287>#ifndef SQLITE_OMIT_DESERIALIZE\n<line288>case SQLITE_CONFIG_MEMDB_MAXSIZE: {\n<line289>sqlite3GlobalConfig.mxMemdbSize = va_arg(ap, sqlite3_int64);\n<line290>break;\n<line291>}\n<line292>#endif /* SQLITE_OMIT_DESERIALIZE */\n<line293>case SQLITE_CONFIG_ROWID_IN_VIEW: {\n<line294>int *pVal = va_arg(ap,int*);\n<line295>#ifdef SQLITE_ALLOW_ROWID_IN_VIEW\n<line296>if( 0==*pVal ) sqlite3GlobalConfig.mNoVisibleRowid = TF_NoVisibleRowid;\n<line297>if( 1==*pVal ) sqlite3GlobalConfig.mNoVisibleRowid = 0;\n<line298>*pVal = (sqlite3GlobalConfig.mNoVisibleRowid==0);\n<line299>#else\n<line300>*pVal = 0;\n<line301>#endif\n<line302>break;\n<line303>}\n<line304>default: {\n<line305>rc = SQLITE_ERROR;\n<line306>break;\n<line307>}\n<line308>}\n<line309>va_end(ap);\n<line310>return rc;\n<line311>}
----------------------------------------
Function: setupLookaside
Content: <line0>static int setupLookaside(\n<line1>sqlite3 *db,    /* Database connection being configured */\n<line2>void *pBuf,     /* Memory to use for lookaside.  May be NULL */\n<line3>int sz,         /* Desired size of each lookaside memory slot */\n<line4>int cnt         /* Number of slots to allocate */\n<line5>){\n<line6>#ifndef SQLITE_OMIT_LOOKASIDE\n<line7>void *pStart;          /* Start of the lookaside buffer */\n<line8>sqlite3_int64 szAlloc; /* Total space set aside for lookaside memory */\n<line9>int nBig;              /* Number of full-size slots */\n<line10>int nSm;               /* Number smaller LOOKASIDE_SMALL-byte slots */\n<line11>if( sqlite3LookasideUsed(db,0)>0 ){\n<line12>return SQLITE_BUSY;\n<line13>}\n<line14>/* Free any existing lookaside buffer for this handle before\n<line15>** allocating a new one so we don't have to have space for\n<line16>** both at the same time.\n<line17>*/\n<line18>if( db->lookaside.bMalloced ){\n<line19>sqlite3_free(db->lookaside.pStart);\n<line20>}\n<line21>/* The size of a lookaside slot after ROUNDDOWN8 needs to be larger\n<line22>** than a pointer and small enough to fit in a u16.\n<line23>*/\n<line24>sz = ROUNDDOWN8(sz);\n<line25>if( sz<=(int)sizeof(LookasideSlot*) ) sz = 0;\n<line26>if( sz>65528 ) sz = 65528;\n<line27>/* Count must be at least 1 to be useful, but not so large as to use\n<line28>** more than 0x7fff0000 total bytes for lookaside. */\n<line29>if( cnt<1 ) cnt = 0;\n<line30>if( sz>0 && cnt>(0x7fff0000/sz) ) cnt = 0x7fff0000/sz;\n<line31>szAlloc = (i64)sz*(i64)cnt;\n<line32>if( szAlloc==0 ){\n<line33>sz = 0;\n<line34>pStart = 0;\n<line35>}else if( pBuf==0 ){\n<line36>sqlite3BeginBenignMalloc();\n<line37>pStart = sqlite3Malloc( szAlloc );\n<line38>sqlite3EndBenignMalloc();\n<line39>if( pStart ) szAlloc = sqlite3MallocSize(pStart);\n<line40>}else{\n<line41>pStart = pBuf;\n<line42>}\n<line43>#ifndef SQLITE_OMIT_TWOSIZE_LOOKASIDE\n<line44>if( sz>=LOOKASIDE_SMALL*3 ){\n<line45>nBig = szAlloc/(3*LOOKASIDE_SMALL+sz);\n<line46>nSm = (szAlloc - (i64)sz*(i64)nBig)/LOOKASIDE_SMALL;\n<line47>}else if( sz>=LOOKASIDE_SMALL*2 ){\n<line48>nBig = szAlloc/(LOOKASIDE_SMALL+sz);\n<line49>nSm = (szAlloc - (i64)sz*(i64)nBig)/LOOKASIDE_SMALL;\n<line50>}else\n<line51>#endif /* SQLITE_OMIT_TWOSIZE_LOOKASIDE */\n<line52>if( sz>0 ){\n<line53>nBig = szAlloc/sz;\n<line54>nSm = 0;\n<line55>}else{\n<line56>nBig = nSm = 0;\n<line57>}\n<line58>db->lookaside.pStart = pStart;\n<line59>db->lookaside.pInit = 0;\n<line60>db->lookaside.pFree = 0;\n<line61>db->lookaside.sz = (u16)sz;\n<line62>db->lookaside.szTrue = (u16)sz;\n<line63>if( pStart ){\n<line64>int i;\n<line65>LookasideSlot *p;\n<line66>assert( sz > (int)sizeof(LookasideSlot*) );\n<line67>p = (LookasideSlot*)pStart;\n<line68>for(i=0; i<nBig; i++){\n<line69>p->pNext = db->lookaside.pInit;\n<line70>db->lookaside.pInit = p;\n<line71>p = (LookasideSlot*)&((u8*)p)[sz];\n<line72>}\n<line73>#ifndef SQLITE_OMIT_TWOSIZE_LOOKASIDE\n<line74>db->lookaside.pSmallInit = 0;\n<line75>db->lookaside.pSmallFree = 0;\n<line76>db->lookaside.pMiddle = p;\n<line77>for(i=0; i<nSm; i++){\n<line78>p->pNext = db->lookaside.pSmallInit;\n<line79>db->lookaside.pSmallInit = p;\n<line80>p = (LookasideSlot*)&((u8*)p)[LOOKASIDE_SMALL];\n<line81>}\n<line82>#endif /* SQLITE_OMIT_TWOSIZE_LOOKASIDE */\n<line83>assert( ((uptr)p)<=szAlloc + (uptr)pStart );\n<line84>db->lookaside.pEnd = p;\n<line85>db->lookaside.bDisable = 0;\n<line86>db->lookaside.bMalloced = pBuf==0 ?1:0;\n<line87>db->lookaside.nSlot = nBig+nSm;\n<line88>}else{\n<line89>db->lookaside.pStart = 0;\n<line90>#ifndef SQLITE_OMIT_TWOSIZE_LOOKASIDE\n<line91>db->lookaside.pSmallInit = 0;\n<line92>db->lookaside.pSmallFree = 0;\n<line93>db->lookaside.pMiddle = 0;\n<line94>#endif /* SQLITE_OMIT_TWOSIZE_LOOKASIDE */\n<line95>db->lookaside.pEnd = 0;\n<line96>db->lookaside.bDisable = 1;\n<line97>db->lookaside.sz = 0;\n<line98>db->lookaside.bMalloced = 0;\n<line99>db->lookaside.nSlot = 0;\n<line100>}\n<line101>db->lookaside.pTrueEnd = db->lookaside.pEnd;\n<line102>assert( sqlite3LookasideUsed(db,0)==0 );\n<line103>#endif /* SQLITE_OMIT_LOOKASIDE */\n<line104>return SQLITE_OK;\n<line105>}
----------------------------------------
Function: sqlite3_db_mutex
Content: <line0>SQLITE_API sqlite3_mutex *sqlite3_db_mutex(sqlite3 *db){\n<line1>#ifdef SQLITE_ENABLE_API_ARMOR\n<line2>if( !sqlite3SafetyCheckOk(db) ){\n<line3>(void)SQLITE_MISUSE_BKPT;\n<line4>return 0;\n<line5>}\n<line6>#endif\n<line7>return db->mutex;\n<line8>}
----------------------------------------
Function: sqlite3_db_release_memory
Content: <line0>SQLITE_API int sqlite3_db_release_memory(sqlite3 *db){\n<line1>int i;\n<line2>#ifdef SQLITE_ENABLE_API_ARMOR\n<line3>if( !sqlite3SafetyCheckOk(db) ) return SQLITE_MISUSE_BKPT;\n<line4>#endif\n<line5>sqlite3_mutex_enter(db->mutex);\n<line6>sqlite3BtreeEnterAll(db);\n<line7>for(i=0; i<db->nDb; i++){\n<line8>Btree *pBt = db->aDb[i].pBt;\n<line9>if( pBt ){\n<line10>Pager *pPager = sqlite3BtreePager(pBt);\n<line11>sqlite3PagerShrink(pPager);\n<line12>}\n<line13>}\n<line14>sqlite3BtreeLeaveAll(db);\n<line15>sqlite3_mutex_leave(db->mutex);\n<line16>return SQLITE_OK;\n<line17>}
----------------------------------------
Function: sqlite3_db_cacheflush
Content: <line0>SQLITE_API int sqlite3_db_cacheflush(sqlite3 *db){\n<line1>int i;\n<line2>int rc = SQLITE_OK;\n<line3>int bSeenBusy = 0;\n<line4>#ifdef SQLITE_ENABLE_API_ARMOR\n<line5>if( !sqlite3SafetyCheckOk(db) ) return SQLITE_MISUSE_BKPT;\n<line6>#endif\n<line7>sqlite3_mutex_enter(db->mutex);\n<line8>sqlite3BtreeEnterAll(db);\n<line9>for(i=0; rc==SQLITE_OK && i<db->nDb; i++){\n<line10>Btree *pBt = db->aDb[i].pBt;\n<line11>if( pBt && sqlite3BtreeTxnState(pBt)==SQLITE_TXN_WRITE ){\n<line12>Pager *pPager = sqlite3BtreePager(pBt);\n<line13>rc = sqlite3PagerFlush(pPager);\n<line14>if( rc==SQLITE_BUSY ){\n<line15>bSeenBusy = 1;\n<line16>rc = SQLITE_OK;\n<line17>}\n<line18>}\n<line19>}\n<line20>sqlite3BtreeLeaveAll(db);\n<line21>sqlite3_mutex_leave(db->mutex);\n<line22>return ((rc==SQLITE_OK && bSeenBusy) ? SQLITE_BUSY : rc);\n<line23>}
----------------------------------------
Function: sqlite3_db_config
Content: <line0>SQLITE_API int sqlite3_db_config(sqlite3 *db, int op, ...){\n<line1>va_list ap;\n<line2>int rc;\n<line3>#ifdef SQLITE_ENABLE_API_ARMOR\n<line4>if( !sqlite3SafetyCheckOk(db) ) return SQLITE_MISUSE_BKPT;\n<line5>#endif\n<line6>sqlite3_mutex_enter(db->mutex);\n<line7>va_start(ap, op);\n<line8>switch( op ){\n<line9>case SQLITE_DBCONFIG_MAINDBNAME: {\n<line10>/* IMP: R-06824-28531 */\n<line11>/* IMP: R-36257-52125 */\n<line12>db->aDb[0].zDbSName = va_arg(ap,char*);\n<line13>rc = SQLITE_OK;\n<line14>break;\n<line15>}\n<line16>case SQLITE_DBCONFIG_LOOKASIDE: {\n<line17>void *pBuf = va_arg(ap, void*); /* IMP: R-26835-10964 */\n<line18>int sz = va_arg(ap, int);       /* IMP: R-47871-25994 */\n<line19>int cnt = va_arg(ap, int);      /* IMP: R-04460-53386 */\n<line20>rc = setupLookaside(db, pBuf, sz, cnt);\n<line21>break;\n<line22>}\n<line23>default: {\n<line24>static const struct {\n<line25>int op;      /* The opcode */\n<line26>u64 mask;    /* Mask of the bit in sqlite3.flags to set/clear */\n<line27>} aFlagOp[] = {\n<line28>{ SQLITE_DBCONFIG_ENABLE_FKEY,           SQLITE_ForeignKeys    },\n<line29>{ SQLITE_DBCONFIG_ENABLE_TRIGGER,        SQLITE_EnableTrigger  },\n<line30>{ SQLITE_DBCONFIG_ENABLE_VIEW,           SQLITE_EnableView     },\n<line31>{ SQLITE_DBCONFIG_ENABLE_FTS3_TOKENIZER, SQLITE_Fts3Tokenizer  },\n<line32>{ SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION, SQLITE_LoadExtension  },\n<line33>{ SQLITE_DBCONFIG_NO_CKPT_ON_CLOSE,      SQLITE_NoCkptOnClose  },\n<line34>{ SQLITE_DBCONFIG_ENABLE_QPSG,           SQLITE_EnableQPSG     },\n<line35>{ SQLITE_DBCONFIG_TRIGGER_EQP,           SQLITE_TriggerEQP     },\n<line36>{ SQLITE_DBCONFIG_RESET_DATABASE,        SQLITE_ResetDatabase  },\n<line37>{ SQLITE_DBCONFIG_DEFENSIVE,             SQLITE_Defensive      },\n<line38>{ SQLITE_DBCONFIG_WRITABLE_SCHEMA,       SQLITE_WriteSchema|\n<line39>SQLITE_NoSchemaError  },\n<line40>{ SQLITE_DBCONFIG_LEGACY_ALTER_TABLE,    SQLITE_LegacyAlter    },\n<line41>{ SQLITE_DBCONFIG_DQS_DDL,               SQLITE_DqsDDL         },\n<line42>{ SQLITE_DBCONFIG_DQS_DML,               SQLITE_DqsDML         },\n<line43>{ SQLITE_DBCONFIG_LEGACY_FILE_FORMAT,    SQLITE_LegacyFileFmt  },\n<line44>{ SQLITE_DBCONFIG_TRUSTED_SCHEMA,        SQLITE_TrustedSchema  },\n<line45>{ SQLITE_DBCONFIG_STMT_SCANSTATUS,       SQLITE_StmtScanStatus },\n<line46>{ SQLITE_DBCONFIG_REVERSE_SCANORDER,     SQLITE_ReverseOrder   },\n<line47>{ SQLITE_DBCONFIG_ENABLE_ATTACH_CREATE,  SQLITE_AttachCreate   },\n<line48>{ SQLITE_DBCONFIG_ENABLE_ATTACH_WRITE,   SQLITE_AttachWrite    },\n<line49>{ SQLITE_DBCONFIG_ENABLE_COMMENTS,       SQLITE_Comments       },\n<line50>};\n<line51>unsigned int i;\n<line52>rc = SQLITE_ERROR; /* IMP: R-42790-23372 */\n<line53>for(i=0; i<ArraySize(aFlagOp); i++){\n<line54>if( aFlagOp[i].op==op ){\n<line55>int onoff = va_arg(ap, int);\n<line56>int *pRes = va_arg(ap, int*);\n<line57>u64 oldFlags = db->flags;\n<line58>if( onoff>0 ){\n<line59>db->flags |= aFlagOp[i].mask;\n<line60>}else if( onoff==0 ){\n<line61>db->flags &= ~(u64)aFlagOp[i].mask;\n<line62>}\n<line63>if( oldFlags!=db->flags ){\n<line64>sqlite3ExpirePreparedStatements(db, 0);\n<line65>}\n<line66>if( pRes ){\n<line67>*pRes = (db->flags & aFlagOp[i].mask)!=0;\n<line68>}\n<line69>rc = SQLITE_OK;\n<line70>break;\n<line71>}\n<line72>}\n<line73>break;\n<line74>}\n<line75>}\n<line76>va_end(ap);\n<line77>sqlite3_mutex_leave(db->mutex);\n<line78>return rc;\n<line79>}
----------------------------------------
Function: binCollFunc
Content: <line0>static int binCollFunc(\n<line1>void *NotUsed,\n<line2>int nKey1, const void *pKey1,\n<line3>int nKey2, const void *pKey2\n<line4>){\n<line5>int rc, n;\n<line6>UNUSED_PARAMETER(NotUsed);\n<line7>n = nKey1<nKey2 ? nKey1 : nKey2;\n<line8>/* EVIDENCE-OF: R-65033-28449 The built-in BINARY collation compares\n<line9>** strings byte by byte using the memcmp() function from the standard C\n<line10>** library. */\n<line11>assert( pKey1 && pKey2 );\n<line12>rc = memcmp(pKey1, pKey2, n);\n<line13>if( rc==0 ){\n<line14>rc = nKey1 - nKey2;\n<line15>}\n<line16>return rc;\n<line17>}
----------------------------------------
Function: rtrimCollFunc
Content: <line0>static int rtrimCollFunc(\n<line1>void *pUser,\n<line2>int nKey1, const void *pKey1,\n<line3>int nKey2, const void *pKey2\n<line4>){\n<line5>const u8 *pK1 = (const u8*)pKey1;\n<line6>const u8 *pK2 = (const u8*)pKey2;\n<line7>while( nKey1 && pK1[nKey1-1]==' ' ) nKey1--;\n<line8>while( nKey2 && pK2[nKey2-1]==' ' ) nKey2--;\n<line9>return binCollFunc(pUser, nKey1, pKey1, nKey2, pKey2);\n<line10>}
----------------------------------------
Function: nocaseCollatingFunc
Content: <line0>static int nocaseCollatingFunc(\n<line1>void *NotUsed,\n<line2>int nKey1, const void *pKey1,\n<line3>int nKey2, const void *pKey2\n<line4>){\n<line5>int r = sqlite3StrNICmp(\n<line6>(const char *)pKey1, (const char *)pKey2, (nKey1<nKey2)?nKey1:nKey2);\n<line7>UNUSED_PARAMETER(NotUsed);\n<line8>if( 0==r ){\n<line9>r = nKey1-nKey2;\n<line10>}\n<line11>return r;\n<line12>}
----------------------------------------
Function: sqlite3_last_insert_rowid
Content: <line0>SQLITE_API sqlite_int64 sqlite3_last_insert_rowid(sqlite3 *db){\n<line1>#ifdef SQLITE_ENABLE_API_ARMOR\n<line2>if( !sqlite3SafetyCheckOk(db) ){\n<line3>(void)SQLITE_MISUSE_BKPT;\n<line4>return 0;\n<line5>}\n<line6>#endif\n<line7>return db->lastRowid;\n<line8>}
----------------------------------------
Function: sqlite3_set_last_insert_rowid
Content: <line0>SQLITE_API void sqlite3_set_last_insert_rowid(sqlite3 *db, sqlite3_int64 iRowid){\n<line1>#ifdef SQLITE_ENABLE_API_ARMOR\n<line2>if( !sqlite3SafetyCheckOk(db) ){\n<line3>(void)SQLITE_MISUSE_BKPT;\n<line4>return;\n<line5>}\n<line6>#endif\n<line7>sqlite3_mutex_enter(db->mutex);\n<line8>db->lastRowid = iRowid;\n<line9>sqlite3_mutex_leave(db->mutex);\n<line10>}
----------------------------------------
Function: sqlite3_changes64
Content: <line0>SQLITE_API sqlite3_int64 sqlite3_changes64(sqlite3 *db){\n<line1>#ifdef SQLITE_ENABLE_API_ARMOR\n<line2>if( !sqlite3SafetyCheckOk(db) ){\n<line3>(void)SQLITE_MISUSE_BKPT;\n<line4>return 0;\n<line5>}\n<line6>#endif\n<line7>return db->nChange;\n<line8>}
----------------------------------------
Function: sqlite3_changes
Content: <line0>SQLITE_API int sqlite3_changes(sqlite3 *db){\n<line1>return (int)sqlite3_changes64(db);\n<line2>}
----------------------------------------
Function: sqlite3_total_changes64
Content: <line0>SQLITE_API sqlite3_int64 sqlite3_total_changes64(sqlite3 *db){\n<line1>#ifdef SQLITE_ENABLE_API_ARMOR\n<line2>if( !sqlite3SafetyCheckOk(db) ){\n<line3>(void)SQLITE_MISUSE_BKPT;\n<line4>return 0;\n<line5>}\n<line6>#endif\n<line7>return db->nTotalChange;\n<line8>}
----------------------------------------
Function: sqlite3_total_changes
Content: <line0>SQLITE_API int sqlite3_total_changes(sqlite3 *db){\n<line1>return (int)sqlite3_total_changes64(db);\n<line2>}
----------------------------------------
Function: functionDestroy
Content: <line0>static void functionDestroy(sqlite3 *db, FuncDef *p){\n<line1>FuncDestructor *pDestructor;\n<line2>assert( (p->funcFlags & SQLITE_FUNC_BUILTIN)==0 );\n<line3>pDestructor = p->u.pDestructor;\n<line4>if( pDestructor ){\n<line5>pDestructor->nRef--;\n<line6>if( pDestructor->nRef==0 ){\n<line7>pDestructor->xDestroy(pDestructor->pUserData);\n<line8>sqlite3DbFree(db, pDestructor);\n<line9>}\n<line10>}\n<line11>}
----------------------------------------
Function: disconnectAllVtab
Content: <line0>static void disconnectAllVtab(sqlite3 *db){\n<line1>#ifndef SQLITE_OMIT_VIRTUALTABLE\n<line2>int i;\n<line3>HashElem *p;\n<line4>sqlite3BtreeEnterAll(db);\n<line5>for(i=0; i<db->nDb; i++){\n<line6>Schema *pSchema = db->aDb[i].pSchema;\n<line7>if( pSchema ){\n<line8>for(p=sqliteHashFirst(&pSchema->tblHash); p; p=sqliteHashNext(p)){\n<line9>Table *pTab = (Table *)sqliteHashData(p);\n<line10>if( IsVirtual(pTab) ) sqlite3VtabDisconnect(db, pTab);\n<line11>}\n<line12>}\n<line13>}\n<line14>for(p=sqliteHashFirst(&db->aModule); p; p=sqliteHashNext(p)){\n<line15>Module *pMod = (Module *)sqliteHashData(p);\n<line16>if( pMod->pEpoTab ){\n<line17>sqlite3VtabDisconnect(db, pMod->pEpoTab);\n<line18>}\n<line19>}\n<line20>sqlite3VtabUnlockList(db);\n<line21>sqlite3BtreeLeaveAll(db);\n<line22>#else\n<line23>UNUSED_PARAMETER(db);\n<line24>#endif\n<line25>}
----------------------------------------
Function: connectionIsBusy
Content: <line0>static int connectionIsBusy(sqlite3 *db){\n<line1>int j;\n<line2>assert( sqlite3_mutex_held(db->mutex) );\n<line3>if( db->pVdbe ) return 1;\n<line4>for(j=0; j<db->nDb; j++){\n<line5>Btree *pBt = db->aDb[j].pBt;\n<line6>if( pBt && sqlite3BtreeIsInBackup(pBt) ) return 1;\n<line7>}\n<line8>return 0;\n<line9>}
----------------------------------------
Function: sqlite3Close
Content: <line0>static int sqlite3Close(sqlite3 *db, int forceZombie){\n<line1>if( !db ){\n<line2>/* EVIDENCE-OF: R-63257-11740 Calling sqlite3_close() or\n<line3>** sqlite3_close_v2() with a NULL pointer argument is a harmless no-op. */\n<line4>return SQLITE_OK;\n<line5>}\n<line6>if( !sqlite3SafetyCheckSickOrOk(db) ){\n<line7>return SQLITE_MISUSE_BKPT;\n<line8>}\n<line9>sqlite3_mutex_enter(db->mutex);\n<line10>if( db->mTrace & SQLITE_TRACE_CLOSE ){\n<line11>db->trace.xV2(SQLITE_TRACE_CLOSE, db->pTraceArg, db, 0);\n<line12>}\n<line13>/* Force xDisconnect calls on all virtual tables */\n<line14>disconnectAllVtab(db);\n<line15>/* If a transaction is open, the disconnectAllVtab() call above\n<line16>** will not have called the xDisconnect() method on any virtual\n<line17>** tables in the db->aVTrans[] array. The following sqlite3VtabRollback()\n<line18>** call will do so. We need to do this before the check for active\n<line19>** SQL statements below, as the v-table implementation may be storing\n<line20>** some prepared statements internally.\n<line21>*/\n<line22>sqlite3VtabRollback(db);\n<line23>/* Legacy behavior (sqlite3_close() behavior) is to return\n<line24>** SQLITE_BUSY if the connection can not be closed immediately.\n<line25>*/\n<line26>if( !forceZombie && connectionIsBusy(db) ){\n<line27>sqlite3ErrorWithMsg(db, SQLITE_BUSY, "unable to close due to unfinalized "\n<line28>"statements or unfinished backups");\n<line29>sqlite3_mutex_leave(db->mutex);\n<line30>return SQLITE_BUSY;\n<line31>}\n<line32>#ifdef SQLITE_ENABLE_SQLLOG\n<line33>if( sqlite3GlobalConfig.xSqllog ){\n<line34>/* Closing the handle. Fourth parameter is passed the value 2. */\n<line35>sqlite3GlobalConfig.xSqllog(sqlite3GlobalConfig.pSqllogArg, db, 0, 2);\n<line36>}\n<line37>#endif\n<line38>while( db->pDbData ){\n<line39>DbClientData *p = db->pDbData;\n<line40>db->pDbData = p->pNext;\n<line41>assert( p->pData!=0 );\n<line42>if( p->xDestructor ) p->xDestructor(p->pData);\n<line43>sqlite3_free(p);\n<line44>}\n<line45>/* Convert the connection into a zombie and then close it.\n<line46>*/\n<line47>db->eOpenState = SQLITE_STATE_ZOMBIE;\n<line48>sqlite3LeaveMutexAndCloseZombie(db);\n<line49>return SQLITE_OK;\n<line50>}
----------------------------------------
Function: sqlite3_txn_state
Content: <line0>SQLITE_API int sqlite3_txn_state(sqlite3 *db, const char *zSchema){\n<line1>int iDb, nDb;\n<line2>int iTxn = -1;\n<line3>#ifdef SQLITE_ENABLE_API_ARMOR\n<line4>if( !sqlite3SafetyCheckOk(db) ){\n<line5>(void)SQLITE_MISUSE_BKPT;\n<line6>return -1;\n<line7>}\n<line8>#endif\n<line9>sqlite3_mutex_enter(db->mutex);\n<line10>if( zSchema ){\n<line11>nDb = iDb = sqlite3FindDbName(db, zSchema);\n<line12>if( iDb<0 ) nDb--;\n<line13>}else{\n<line14>iDb = 0;\n<line15>nDb = db->nDb-1;\n<line16>}\n<line17>for(; iDb<=nDb; iDb++){\n<line18>Btree *pBt = db->aDb[iDb].pBt;\n<line19>int x = pBt!=0 ? sqlite3BtreeTxnState(pBt) : SQLITE_TXN_NONE;\n<line20>if( x>iTxn ) iTxn = x;\n<line21>}\n<line22>sqlite3_mutex_leave(db->mutex);\n<line23>return iTxn;\n<line24>}
----------------------------------------
Function: sqlite3_close
Content: <line0>SQLITE_API int sqlite3_close(sqlite3 *db){ return sqlite3Close(db,0); }
----------------------------------------
Function: sqlite3_close_v2
Content: <line0>SQLITE_API int sqlite3_close_v2(sqlite3 *db){ return sqlite3Close(db,1); }
----------------------------------------
Function: sqliteDefaultBusyCallback
Content: <line0>static int sqliteDefaultBusyCallback(\n<line1>void *ptr,               /* Database connection */\n<line2>int count                /* Number of times table has been busy */\n<line3>){\n<line4>#if SQLITE_OS_WIN || !defined(HAVE_NANOSLEEP) || HAVE_NANOSLEEP\n<line5>/* This case is for systems that have support for sleeping for fractions of\n<line6>** a second.  Examples:  All windows systems, unix systems with nanosleep() */\n<line7>static const u8 delays[] =\n<line8>{ 1, 2, 5, 10, 15, 20, 25, 25,  25,  50,  50, 100 };\n<line9>static const u8 totals[] =\n<line10>{ 0, 1, 3,  8, 18, 33, 53, 78, 103, 128, 178, 228 };\n<line11># define NDELAY ArraySize(delays)\n<line12>sqlite3 *db = (sqlite3 *)ptr;\n<line13>int tmout = db->busyTimeout;\n<line14>int delay, prior;\n<line15>assert( count>=0 );\n<line16>if( count < NDELAY ){\n<line17>delay = delays[count];\n<line18>prior = totals[count];\n<line19>}else{\n<line20>delay = delays[NDELAY-1];\n<line21>prior = totals[NDELAY-1] + delay*(count-(NDELAY-1));\n<line22>}\n<line23>if( prior + delay > tmout ){\n<line24>delay = tmout - prior;\n<line25>if( delay<=0 ) return 0;\n<line26>}\n<line27>sqlite3OsSleep(db->pVfs, delay*1000);\n<line28>return 1;\n<line29>#else\n<line30>/* This case for unix systems that lack usleep() support.  Sleeping\n<line31>** must be done in increments of whole seconds */\n<line32>sqlite3 *db = (sqlite3 *)ptr;\n<line33>int tmout = ((sqlite3 *)ptr)->busyTimeout;\n<line34>if( (count+1)*1000 > tmout ){\n<line35>return 0;\n<line36>}\n<line37>sqlite3OsSleep(db->pVfs, 1000000);\n<line38>return 1;\n<line39>#endif\n<line40>}
----------------------------------------
Function: sqlite3_busy_handler
Content: <line0>SQLITE_API int sqlite3_busy_handler(\n<line1>sqlite3 *db,\n<line2>int (*xBusy)(void*,int),\n<line3>void *pArg\n<line4>){\n<line5>#ifdef SQLITE_ENABLE_API_ARMOR\n<line6>if( !sqlite3SafetyCheckOk(db) ) return SQLITE_MISUSE_BKPT;\n<line7>#endif\n<line8>sqlite3_mutex_enter(db->mutex);\n<line9>db->busyHandler.xBusyHandler = xBusy;\n<line10>db->busyHandler.pBusyArg = pArg;\n<line11>db->busyHandler.nBusy = 0;\n<line12>db->busyTimeout = 0;\n<line13>#ifdef SQLITE_ENABLE_SETLK_TIMEOUT\n<line14>db->setlkTimeout = 0;\n<line15>#endif\n<line16>sqlite3_mutex_leave(db->mutex);\n<line17>return SQLITE_OK;\n<line18>}
----------------------------------------
Function: sqlite3_progress_handler
Content: <line0>SQLITE_API void sqlite3_progress_handler(\n<line1>sqlite3 *db,\n<line2>int nOps,\n<line3>int (*xProgress)(void*),\n<line4>void *pArg\n<line5>){\n<line6>#ifdef SQLITE_ENABLE_API_ARMOR\n<line7>if( !sqlite3SafetyCheckOk(db) ){\n<line8>(void)SQLITE_MISUSE_BKPT;\n<line9>return;\n<line10>}\n<line11>#endif\n<line12>sqlite3_mutex_enter(db->mutex);\n<line13>if( nOps>0 ){\n<line14>db->xProgress = xProgress;\n<line15>db->nProgressOps = (unsigned)nOps;\n<line16>db->pProgressArg = pArg;\n<line17>}else{\n<line18>db->xProgress = 0;\n<line19>db->nProgressOps = 0;\n<line20>db->pProgressArg = 0;\n<line21>}\n<line22>sqlite3_mutex_leave(db->mutex);\n<line23>}
----------------------------------------
Function: sqlite3_busy_timeout
Content: <line0>SQLITE_API int sqlite3_busy_timeout(sqlite3 *db, int ms){\n<line1>#ifdef SQLITE_ENABLE_API_ARMOR\n<line2>if( !sqlite3SafetyCheckOk(db) ) return SQLITE_MISUSE_BKPT;\n<line3>#endif\n<line4>if( ms>0 ){\n<line5>sqlite3_busy_handler(db, (int(*)(void*,int))sqliteDefaultBusyCallback,\n<line6>(void*)db);\n<line7>db->busyTimeout = ms;\n<line8>#ifdef SQLITE_ENABLE_SETLK_TIMEOUT\n<line9>db->setlkTimeout = ms;\n<line10>#endif\n<line11>}else{\n<line12>sqlite3_busy_handler(db, 0, 0);\n<line13>}\n<line14>return SQLITE_OK;\n<line15>}
----------------------------------------
Function: sqlite3_setlk_timeout
Content: <line0>SQLITE_API int sqlite3_setlk_timeout(sqlite3 *db, int ms, int flags){\n<line1>#ifdef SQLITE_ENABLE_SETLK_TIMEOUT\n<line2>int iDb;\n<line3>int bBOC = ((flags & SQLITE_SETLK_BLOCK_ON_CONNECT) ? 1 : 0);\n<line4>#endif\n<line5>#ifdef SQLITE_ENABLE_API_ARMOR\n<line6>if( !sqlite3SafetyCheckOk(db) ) return SQLITE_MISUSE_BKPT;\n<line7>#endif\n<line8>if( ms<-1 ) return SQLITE_RANGE;\n<line9>#ifdef SQLITE_ENABLE_SETLK_TIMEOUT\n<line10>sqlite3_mutex_enter(db->mutex);\n<line11>db->setlkTimeout = ms;\n<line12>db->setlkFlags = flags;\n<line13>sqlite3BtreeEnterAll(db);\n<line14>for(iDb=0; iDb<db->nDb; iDb++){\n<line15>Btree *pBt = db->aDb[iDb].pBt;\n<line16>if( pBt ){\n<line17>sqlite3_file *fd = sqlite3PagerFile(sqlite3BtreePager(pBt));\n<line18>sqlite3OsFileControlHint(fd, SQLITE_FCNTL_BLOCK_ON_CONNECT, (void*)&bBOC);\n<line19>}\n<line20>}\n<line21>sqlite3BtreeLeaveAll(db);\n<line22>sqlite3_mutex_leave(db->mutex);\n<line23>#endif\n<line24>#if !defined(SQLITE_ENABLE_API_ARMOR) && !defined(SQLITE_ENABLE_SETLK_TIMEOUT)\n<line25>UNUSED_PARAMETER(db);\n<line26>UNUSED_PARAMETER(flags);\n<line27>#endif\n<line28>return SQLITE_OK;\n<line29>}
----------------------------------------
Function: sqlite3_interrupt
Content: <line0>SQLITE_API void sqlite3_interrupt(sqlite3 *db){\n<line1>#ifdef SQLITE_ENABLE_API_ARMOR\n<line2>if( !sqlite3SafetyCheckOk(db)\n<line3>&& (db==0 || db->eOpenState!=SQLITE_STATE_ZOMBIE)\n<line4>){\n<line5>(void)SQLITE_MISUSE_BKPT;\n<line6>return;\n<line7>}\n<line8>#endif\n<line9>AtomicStore(&db->u1.isInterrupted, 1);\n<line10>}
----------------------------------------
Function: sqlite3_is_interrupted
Content: <line0>SQLITE_API int sqlite3_is_interrupted(sqlite3 *db){\n<line1>#ifdef SQLITE_ENABLE_API_ARMOR\n<line2>if( !sqlite3SafetyCheckOk(db)\n<line3>&& (db==0 || db->eOpenState!=SQLITE_STATE_ZOMBIE)\n<line4>){\n<line5>(void)SQLITE_MISUSE_BKPT;\n<line6>return 0;\n<line7>}\n<line8>#endif\n<line9>return AtomicLoad(&db->u1.isInterrupted)!=0;\n<line10>}
----------------------------------------
Function: createFunctionApi
Content: <line0>static int createFunctionApi(\n<line1>sqlite3 *db,\n<line2>const char *zFunc,\n<line3>int nArg,\n<line4>int enc,\n<line5>void *p,\n<line6>void (*xSFunc)(sqlite3_context*,int,sqlite3_value**),\n<line7>void (*xStep)(sqlite3_context*,int,sqlite3_value**),\n<line8>void (*xFinal)(sqlite3_context*),\n<line9>void (*xValue)(sqlite3_context*),\n<line10>void (*xInverse)(sqlite3_context*,int,sqlite3_value**),\n<line11>void(*xDestroy)(void*)\n<line12>){\n<line13>int rc = SQLITE_ERROR;\n<line14>FuncDestructor *pArg = 0;\n<line15>#ifdef SQLITE_ENABLE_API_ARMOR\n<line16>if( !sqlite3SafetyCheckOk(db) ){\n<line17>return SQLITE_MISUSE_BKPT;\n<line18>}\n<line19>#endif\n<line20>sqlite3_mutex_enter(db->mutex);\n<line21>if( xDestroy ){\n<line22>pArg = (FuncDestructor *)sqlite3Malloc(sizeof(FuncDestructor));\n<line23>if( !pArg ){\n<line24>sqlite3OomFault(db);\n<line25>xDestroy(p);\n<line26>goto out;\n<line27>}\n<line28>pArg->nRef = 0;\n<line29>pArg->xDestroy = xDestroy;\n<line30>pArg->pUserData = p;\n<line31>}\n<line32>rc = sqlite3CreateFunc(db, zFunc, nArg, enc, p,\n<line33>xSFunc, xStep, xFinal, xValue, xInverse, pArg\n<line34>);\n<line35>if( pArg && pArg->nRef==0 ){\n<line36>assert( rc!=SQLITE_OK || (xStep==0 && xFinal==0) );\n<line37>xDestroy(p);\n<line38>sqlite3_free(pArg);\n<line39>}\n<line40>out:\n<line41>rc = sqlite3ApiExit(db, rc);\n<line42>sqlite3_mutex_leave(db->mutex);\n<line43>return rc;\n<line44>}
----------------------------------------
Function: sqlite3_create_function
Content: <line0>SQLITE_API int sqlite3_create_function(\n<line1>sqlite3 *db,\n<line2>const char *zFunc,\n<line3>int nArg,\n<line4>int enc,\n<line5>void *p,\n<line6>void (*xSFunc)(sqlite3_context*,int,sqlite3_value **),\n<line7>void (*xStep)(sqlite3_context*,int,sqlite3_value **),\n<line8>void (*xFinal)(sqlite3_context*)\n<line9>){\n<line10>return createFunctionApi(db, zFunc, nArg, enc, p, xSFunc, xStep,\n<line11>xFinal, 0, 0, 0);\n<line12>}
----------------------------------------
Function: sqlite3_create_function_v2
Content: <line0>SQLITE_API int sqlite3_create_function_v2(\n<line1>sqlite3 *db,\n<line2>const char *zFunc,\n<line3>int nArg,\n<line4>int enc,\n<line5>void *p,\n<line6>void (*xSFunc)(sqlite3_context*,int,sqlite3_value **),\n<line7>void (*xStep)(sqlite3_context*,int,sqlite3_value **),\n<line8>void (*xFinal)(sqlite3_context*),\n<line9>void (*xDestroy)(void *)\n<line10>){\n<line11>return createFunctionApi(db, zFunc, nArg, enc, p, xSFunc, xStep,\n<line12>xFinal, 0, 0, xDestroy);\n<line13>}
----------------------------------------
Function: sqlite3_create_window_function
Content: <line0>SQLITE_API int sqlite3_create_window_function(\n<line1>sqlite3 *db,\n<line2>const char *zFunc,\n<line3>int nArg,\n<line4>int enc,\n<line5>void *p,\n<line6>void (*xStep)(sqlite3_context*,int,sqlite3_value **),\n<line7>void (*xFinal)(sqlite3_context*),\n<line8>void (*xValue)(sqlite3_context*),\n<line9>void (*xInverse)(sqlite3_context*,int,sqlite3_value **),\n<line10>void (*xDestroy)(void *)\n<line11>){\n<line12>return createFunctionApi(db, zFunc, nArg, enc, p, 0, xStep,\n<line13>xFinal, xValue, xInverse, xDestroy);\n<line14>}
----------------------------------------
Function: sqlite3_create_function16
Content: <line0>SQLITE_API int sqlite3_create_function16(\n<line1>sqlite3 *db,\n<line2>const void *zFunctionName,\n<line3>int nArg,\n<line4>int eTextRep,\n<line5>void *p,\n<line6>void (*xSFunc)(sqlite3_context*,int,sqlite3_value**),\n<line7>void (*xStep)(sqlite3_context*,int,sqlite3_value**),\n<line8>void (*xFinal)(sqlite3_context*)\n<line9>){\n<line10>int rc;\n<line11>char *zFunc8;\n<line12>#ifdef SQLITE_ENABLE_API_ARMOR\n<line13>if( !sqlite3SafetyCheckOk(db) || zFunctionName==0 ) return SQLITE_MISUSE_BKPT;\n<line14>#endif\n<line15>sqlite3_mutex_enter(db->mutex);\n<line16>assert( !db->mallocFailed );\n<line17>zFunc8 = sqlite3Utf16to8(db, zFunctionName, -1, SQLITE_UTF16NATIVE);\n<line18>rc = sqlite3CreateFunc(db, zFunc8, nArg, eTextRep, p, xSFunc,xStep,xFinal,0,0,0);\n<line19>sqlite3DbFree(db, zFunc8);\n<line20>rc = sqlite3ApiExit(db, rc);\n<line21>sqlite3_mutex_leave(db->mutex);\n<line22>return rc;\n<line23>}
----------------------------------------
Function: sqlite3InvalidFunction
Content: <line0>static void sqlite3InvalidFunction(\n<line1>sqlite3_context *context,  /* The function calling context */\n<line2>int NotUsed,               /* Number of arguments to the function */\n<line3>sqlite3_value **NotUsed2   /* Value of each argument */\n<line4>){\n<line5>const char *zName = (const char*)sqlite3_user_data(context);\n<line6>char *zErr;\n<line7>UNUSED_PARAMETER2(NotUsed, NotUsed2);\n<line8>zErr = sqlite3_mprintf(\n<line9>"unable to use function %s in the requested context", zName);\n<line10>sqlite3_result_error(context, zErr, -1);\n<line11>sqlite3_free(zErr);\n<line12>}
----------------------------------------
Function: sqlite3_overload_function
Content: <line0>SQLITE_API int sqlite3_overload_function(\n<line1>sqlite3 *db,\n<line2>const char *zName,\n<line3>int nArg\n<line4>){\n<line5>int rc;\n<line6>char *zCopy;\n<line7>#ifdef SQLITE_ENABLE_API_ARMOR\n<line8>if( !sqlite3SafetyCheckOk(db) || zName==0 || nArg<-2 ){\n<line9>return SQLITE_MISUSE_BKPT;\n<line10>}\n<line11>#endif\n<line12>sqlite3_mutex_enter(db->mutex);\n<line13>rc = sqlite3FindFunction(db, zName, nArg, SQLITE_UTF8, 0)!=0;\n<line14>sqlite3_mutex_leave(db->mutex);\n<line15>if( rc ) return SQLITE_OK;\n<line16>zCopy = sqlite3_mprintf("%s", zName);\n<line17>if( zCopy==0 ) return SQLITE_NOMEM;\n<line18>return sqlite3_create_function_v2(db, zName, nArg, SQLITE_UTF8,\n<line19>zCopy, sqlite3InvalidFunction, 0, 0, sqlite3_free);\n<line20>}
----------------------------------------
Function: sqlite3_trace
Content: <line0>SQLITE_API void *sqlite3_trace(sqlite3 *db, void(*xTrace)(void*,const char*), void *pArg){\n<line1>void *pOld;\n<line2>#ifdef SQLITE_ENABLE_API_ARMOR\n<line3>if( !sqlite3SafetyCheckOk(db) ){\n<line4>(void)SQLITE_MISUSE_BKPT;\n<line5>return 0;\n<line6>}\n<line7>#endif\n<line8>sqlite3_mutex_enter(db->mutex);\n<line9>pOld = db->pTraceArg;\n<line10>db->mTrace = xTrace ? SQLITE_TRACE_LEGACY : 0;\n<line11>db->trace.xLegacy = xTrace;\n<line12>db->pTraceArg = pArg;\n<line13>sqlite3_mutex_leave(db->mutex);\n<line14>return pOld;\n<line15>}
----------------------------------------
Function: sqlite3_trace_v2
Content: <line0>SQLITE_API int sqlite3_trace_v2(\n<line1>sqlite3 *db,                               /* Trace this connection */\n<line2>unsigned mTrace,                           /* Mask of events to be traced */\n<line3>int(*xTrace)(unsigned,void*,void*,void*),  /* Callback to invoke */\n<line4>void *pArg                                 /* Context */\n<line5>){\n<line6>#ifdef SQLITE_ENABLE_API_ARMOR\n<line7>if( !sqlite3SafetyCheckOk(db) ){\n<line8>return SQLITE_MISUSE_BKPT;\n<line9>}\n<line10>#endif\n<line11>sqlite3_mutex_enter(db->mutex);\n<line12>if( mTrace==0 ) xTrace = 0;\n<line13>if( xTrace==0 ) mTrace = 0;\n<line14>db->mTrace = mTrace;\n<line15>db->trace.xV2 = xTrace;\n<line16>db->pTraceArg = pArg;\n<line17>sqlite3_mutex_leave(db->mutex);\n<line18>return SQLITE_OK;\n<line19>}
----------------------------------------
Function: sqlite3_profile
Content: <line0>SQLITE_API void *sqlite3_profile(\n<line1>sqlite3 *db,\n<line2>void (*xProfile)(void*,const char*,sqlite_uint64),\n<line3>void *pArg\n<line4>){\n<line5>void *pOld;\n<line6>#ifdef SQLITE_ENABLE_API_ARMOR\n<line7>if( !sqlite3SafetyCheckOk(db) ){\n<line8>(void)SQLITE_MISUSE_BKPT;\n<line9>return 0;\n<line10>}\n<line11>#endif\n<line12>sqlite3_mutex_enter(db->mutex);\n<line13>pOld = db->pProfileArg;\n<line14>db->xProfile = xProfile;\n<line15>db->pProfileArg = pArg;\n<line16>db->mTrace &= SQLITE_TRACE_NONLEGACY_MASK;\n<line17>if( db->xProfile ) db->mTrace |= SQLITE_TRACE_XPROFILE;\n<line18>sqlite3_mutex_leave(db->mutex);\n<line19>return pOld;\n<line20>}
----------------------------------------
Function: sqlite3_commit_hook
Content: <line0>SQLITE_API void *sqlite3_commit_hook(\n<line1>sqlite3 *db,              /* Attach the hook to this database */\n<line2>int (*xCallback)(void*),  /* Function to invoke on each commit */\n<line3>void *pArg                /* Argument to the function */\n<line4>){\n<line5>void *pOld;\n<line6>#ifdef SQLITE_ENABLE_API_ARMOR\n<line7>if( !sqlite3SafetyCheckOk(db) ){\n<line8>(void)SQLITE_MISUSE_BKPT;\n<line9>return 0;\n<line10>}\n<line11>#endif\n<line12>sqlite3_mutex_enter(db->mutex);\n<line13>pOld = db->pCommitArg;\n<line14>db->xCommitCallback = xCallback;\n<line15>db->pCommitArg = pArg;\n<line16>sqlite3_mutex_leave(db->mutex);\n<line17>return pOld;\n<line18>}
----------------------------------------
Function: sqlite3_update_hook
Content: <line0>SQLITE_API void *sqlite3_update_hook(\n<line1>sqlite3 *db,              /* Attach the hook to this database */\n<line2>void (*xCallback)(void*,int,char const *,char const *,sqlite_int64),\n<line3>void *pArg                /* Argument to the function */\n<line4>){\n<line5>void *pRet;\n<line6>#ifdef SQLITE_ENABLE_API_ARMOR\n<line7>if( !sqlite3SafetyCheckOk(db) ){\n<line8>(void)SQLITE_MISUSE_BKPT;\n<line9>return 0;\n<line10>}\n<line11>#endif\n<line12>sqlite3_mutex_enter(db->mutex);\n<line13>pRet = db->pUpdateArg;\n<line14>db->xUpdateCallback = xCallback;\n<line15>db->pUpdateArg = pArg;\n<line16>sqlite3_mutex_leave(db->mutex);\n<line17>return pRet;\n<line18>}
----------------------------------------
Function: sqlite3_rollback_hook
Content: <line0>SQLITE_API void *sqlite3_rollback_hook(\n<line1>sqlite3 *db,              /* Attach the hook to this database */\n<line2>void (*xCallback)(void*), /* Callback function */\n<line3>void *pArg                /* Argument to the function */\n<line4>){\n<line5>void *pRet;\n<line6>#ifdef SQLITE_ENABLE_API_ARMOR\n<line7>if( !sqlite3SafetyCheckOk(db) ){\n<line8>(void)SQLITE_MISUSE_BKPT;\n<line9>return 0;\n<line10>}\n<line11>#endif\n<line12>sqlite3_mutex_enter(db->mutex);\n<line13>pRet = db->pRollbackArg;\n<line14>db->xRollbackCallback = xCallback;\n<line15>db->pRollbackArg = pArg;\n<line16>sqlite3_mutex_leave(db->mutex);\n<line17>return pRet;\n<line18>}
----------------------------------------
Function: sqlite3_autovacuum_pages
Content: <line0>SQLITE_API int sqlite3_autovacuum_pages(\n<line1>sqlite3 *db,                 /* Attach the hook to this database */\n<line2>unsigned int (*xCallback)(void*,const char*,u32,u32,u32),\n<line3>void *pArg,                  /* Argument to the function */\n<line4>void (*xDestructor)(void*)   /* Destructor for pArg */\n<line5>){\n<line6>#ifdef SQLITE_ENABLE_API_ARMOR\n<line7>if( !sqlite3SafetyCheckOk(db) ){\n<line8>if( xDestructor ) xDestructor(pArg);\n<line9>return SQLITE_MISUSE_BKPT;\n<line10>}\n<line11>#endif\n<line12>sqlite3_mutex_enter(db->mutex);\n<line13>if( db->xAutovacDestr ){\n<line14>db->xAutovacDestr(db->pAutovacPagesArg);\n<line15>}\n<line16>db->xAutovacPages = xCallback;\n<line17>db->pAutovacPagesArg = pArg;\n<line18>db->xAutovacDestr = xDestructor;\n<line19>sqlite3_mutex_leave(db->mutex);\n<line20>return SQLITE_OK;\n<line21>}
----------------------------------------
Function: sqlite3_wal_autocheckpoint
Content: <line0>SQLITE_API int sqlite3_wal_autocheckpoint(sqlite3 *db, int nFrame){\n<line1>#ifdef SQLITE_OMIT_WAL\n<line2>UNUSED_PARAMETER(db);\n<line3>UNUSED_PARAMETER(nFrame);\n<line4>#else\n<line5>#ifdef SQLITE_ENABLE_API_ARMOR\n<line6>if( !sqlite3SafetyCheckOk(db) ) return SQLITE_MISUSE_BKPT;\n<line7>#endif\n<line8>if( nFrame>0 ){\n<line9>sqlite3_wal_hook(db, sqlite3WalDefaultHook, SQLITE_INT_TO_PTR(nFrame));\n<line10>}else{\n<line11>sqlite3_wal_hook(db, 0, 0);\n<line12>}\n<line13>#endif\n<line14>return SQLITE_OK;\n<line15>}
----------------------------------------
Function: sqlite3_wal_hook
Content: <line0>SQLITE_API void *sqlite3_wal_hook(\n<line1>sqlite3 *db,                    /* Attach the hook to this db handle */\n<line2>int(*xCallback)(void *, sqlite3*, const char*, int),\n<line3>void *pArg                      /* First argument passed to xCallback() */\n<line4>){\n<line5>#ifndef SQLITE_OMIT_WAL\n<line6>void *pRet;\n<line7>#ifdef SQLITE_ENABLE_API_ARMOR\n<line8>if( !sqlite3SafetyCheckOk(db) ){\n<line9>(void)SQLITE_MISUSE_BKPT;\n<line10>return 0;\n<line11>}\n<line12>#endif\n<line13>sqlite3_mutex_enter(db->mutex);\n<line14>pRet = db->pWalArg;\n<line15>db->xWalCallback = xCallback;\n<line16>db->pWalArg = pArg;\n<line17>sqlite3_mutex_leave(db->mutex);\n<line18>return pRet;\n<line19>#else\n<line20>return 0;\n<line21>#endif\n<line22>}
----------------------------------------
Function: sqlite3_wal_checkpoint_v2
Content: <line0>SQLITE_API int sqlite3_wal_checkpoint_v2(\n<line1>sqlite3 *db,                    /* Database handle */\n<line2>const char *zDb,                /* Name of attached database (or NULL) */\n<line3>int eMode,                      /* SQLITE_CHECKPOINT_* value */\n<line4>int *pnLog,                     /* OUT: Size of WAL log in frames */\n<line5>int *pnCkpt                     /* OUT: Total number of frames checkpointed */\n<line6>){\n<line7>#ifdef SQLITE_OMIT_WAL\n<line8>return SQLITE_OK;\n<line9>#else\n<line10>int rc;                         /* Return code */\n<line11>int iDb;                        /* Schema to checkpoint */\n<line12>#ifdef SQLITE_ENABLE_API_ARMOR\n<line13>if( !sqlite3SafetyCheckOk(db) ) return SQLITE_MISUSE_BKPT;\n<line14>#endif\n<line15>/* Initialize the output variables to -1 in case an error occurs. */\n<line16>if( pnLog ) *pnLog = -1;\n<line17>if( pnCkpt ) *pnCkpt = -1;\n<line18>assert( SQLITE_CHECKPOINT_PASSIVE==0 );\n<line19>assert( SQLITE_CHECKPOINT_FULL==1 );\n<line20>assert( SQLITE_CHECKPOINT_RESTART==2 );\n<line21>assert( SQLITE_CHECKPOINT_TRUNCATE==3 );\n<line22>if( eMode<SQLITE_CHECKPOINT_PASSIVE || eMode>SQLITE_CHECKPOINT_TRUNCATE ){\n<line23>/* EVIDENCE-OF: R-03996-12088 The M parameter must be a valid checkpoint\n<line24>** mode: */\n<line25>return SQLITE_MISUSE_BKPT;\n<line26>}\n<line27>sqlite3_mutex_enter(db->mutex);\n<line28>if( zDb && zDb[0] ){\n<line29>iDb = sqlite3FindDbName(db, zDb);\n<line30>}else{\n<line31>iDb = SQLITE_MAX_DB;   /* This means process all schemas */\n<line32>}\n<line33>if( iDb<0 ){\n<line34>rc = SQLITE_ERROR;\n<line35>sqlite3ErrorWithMsg(db, SQLITE_ERROR, "unknown database: %s", zDb);\n<line36>}else{\n<line37>db->busyHandler.nBusy = 0;\n<line38>rc = sqlite3Checkpoint(db, iDb, eMode, pnLog, pnCkpt);\n<line39>sqlite3Error(db, rc);\n<line40>}\n<line41>rc = sqlite3ApiExit(db, rc);\n<line42>/* If there are no active statements, clear the interrupt flag at this\n<line43>** point.  */\n<line44>if( db->nVdbeActive==0 ){\n<line45>AtomicStore(&db->u1.isInterrupted, 0);\n<line46>}\n<line47>sqlite3_mutex_leave(db->mutex);\n<line48>return rc;\n<line49>#endif\n<line50>}
----------------------------------------
Function: sqlite3_wal_checkpoint
Content: <line0>SQLITE_API int sqlite3_wal_checkpoint(sqlite3 *db, const char *zDb){\n<line1>/* EVIDENCE-OF: R-41613-20553 The sqlite3_wal_checkpoint(D,X) is equivalent to\n<line2>** sqlite3_wal_checkpoint_v2(D,X,SQLITE_CHECKPOINT_PASSIVE,0,0). */\n<line3>return sqlite3_wal_checkpoint_v2(db,zDb,SQLITE_CHECKPOINT_PASSIVE,0,0);\n<line4>}
----------------------------------------
Function: sqlite3_errmsg
Content: <line0>SQLITE_API const char *sqlite3_errmsg(sqlite3 *db){\n<line1>const char *z;\n<line2>if( !db ){\n<line3>return sqlite3ErrStr(SQLITE_NOMEM_BKPT);\n<line4>}\n<line5>if( !sqlite3SafetyCheckSickOrOk(db) ){\n<line6>return sqlite3ErrStr(SQLITE_MISUSE_BKPT);\n<line7>}\n<line8>sqlite3_mutex_enter(db->mutex);\n<line9>if( db->mallocFailed ){\n<line10>z = sqlite3ErrStr(SQLITE_NOMEM_BKPT);\n<line11>}else{\n<line12>testcase( db->pErr==0 );\n<line13>z = db->errCode ? (char*)sqlite3_value_text(db->pErr) : 0;\n<line14>assert( !db->mallocFailed );\n<line15>if( z==0 ){\n<line16>z = sqlite3ErrStr(db->errCode);\n<line17>}\n<line18>}\n<line19>sqlite3_mutex_leave(db->mutex);\n<line20>return z;\n<line21>}
----------------------------------------
Function: sqlite3_set_errmsg
Content: <line0>SQLITE_API int sqlite3_set_errmsg(sqlite3 *db, int errcode, const char *zMsg){\n<line1>int rc = SQLITE_OK;\n<line2>if( !sqlite3SafetyCheckSickOrOk(db) ){\n<line3>return SQLITE_MISUSE_BKPT;\n<line4>}\n<line5>sqlite3_mutex_enter(db->mutex);\n<line6>if( zMsg ){\n<line7>sqlite3ErrorWithMsg(db, errcode, "%s", zMsg);\n<line8>}else{\n<line9>sqlite3Error(db, errcode);\n<line10>}\n<line11>rc = sqlite3ApiExit(db, rc);\n<line12>sqlite3_mutex_leave(db->mutex);\n<line13>return rc;\n<line14>}
----------------------------------------
Function: sqlite3_error_offset
Content: <line0>SQLITE_API int sqlite3_error_offset(sqlite3 *db){\n<line1>int iOffset = -1;\n<line2>if( db && sqlite3SafetyCheckSickOrOk(db) && db->errCode ){\n<line3>sqlite3_mutex_enter(db->mutex);\n<line4>iOffset = db->errByteOffset;\n<line5>sqlite3_mutex_leave(db->mutex);\n<line6>}\n<line7>return iOffset;\n<line8>}
----------------------------------------
Function: sqlite3_errmsg16
Content: <line0>SQLITE_API const void *sqlite3_errmsg16(sqlite3 *db){\n<line1>static const u16 outOfMem[] = {\n<line2>'o', 'u', 't', ' ', 'o', 'f', ' ', 'm', 'e', 'm', 'o', 'r', 'y', 0\n<line3>};\n<line4>static const u16 misuse[] = {\n<line5>'b', 'a', 'd', ' ', 'p', 'a', 'r', 'a', 'm', 'e', 't', 'e', 'r', ' ',\n<line6>'o', 'r', ' ', 'o', 't', 'h', 'e', 'r', ' ', 'A', 'P', 'I', ' ',\n<line7>'m', 'i', 's', 'u', 's', 'e', 0\n<line8>};\n<line9>const void *z;\n<line10>if( !db ){\n<line11>return (void *)outOfMem;\n<line12>}\n<line13>if( !sqlite3SafetyCheckSickOrOk(db) ){\n<line14>return (void *)misuse;\n<line15>}\n<line16>sqlite3_mutex_enter(db->mutex);\n<line17>if( db->mallocFailed ){\n<line18>z = (void *)outOfMem;\n<line19>}else{\n<line20>z = sqlite3_value_text16(db->pErr);\n<line21>if( z==0 ){\n<line22>sqlite3ErrorWithMsg(db, db->errCode, sqlite3ErrStr(db->errCode));\n<line23>z = sqlite3_value_text16(db->pErr);\n<line24>}\n<line25>/* A malloc() may have failed within the call to sqlite3_value_text16()\n<line26>** above. If this is the case, then the db->mallocFailed flag needs to\n<line27>** be cleared before returning. Do this directly, instead of via\n<line28>** sqlite3ApiExit(), to avoid setting the database handle error message.\n<line29>*/\n<line30>sqlite3OomClear(db);\n<line31>}\n<line32>sqlite3_mutex_leave(db->mutex);\n<line33>return z;\n<line34>}
----------------------------------------
Function: sqlite3_errcode
Content: <line0>SQLITE_API int sqlite3_errcode(sqlite3 *db){\n<line1>if( db && !sqlite3SafetyCheckSickOrOk(db) ){\n<line2>return SQLITE_MISUSE_BKPT;\n<line3>}\n<line4>if( !db || db->mallocFailed ){\n<line5>return SQLITE_NOMEM_BKPT;\n<line6>}\n<line7>return db->errCode & db->errMask;\n<line8>}
----------------------------------------
Function: sqlite3_extended_errcode
Content: <line0>SQLITE_API int sqlite3_extended_errcode(sqlite3 *db){\n<line1>if( db && !sqlite3SafetyCheckSickOrOk(db) ){\n<line2>return SQLITE_MISUSE_BKPT;\n<line3>}\n<line4>if( !db || db->mallocFailed ){\n<line5>return SQLITE_NOMEM_BKPT;\n<line6>}\n<line7>return db->errCode;\n<line8>}
----------------------------------------
Function: sqlite3_system_errno
Content: <line0>SQLITE_API int sqlite3_system_errno(sqlite3 *db){\n<line1>return db ? db->iSysErrno : 0;\n<line2>}
----------------------------------------
Function: sqlite3_errstr
Content: <line0>SQLITE_API const char *sqlite3_errstr(int rc){\n<line1>return sqlite3ErrStr(rc);\n<line2>}
----------------------------------------
Function: createCollation
Content: <line0>static int createCollation(\n<line1>sqlite3* db,\n<line2>const char *zName,\n<line3>u8 enc,\n<line4>void* pCtx,\n<line5>int(*xCompare)(void*,int,const void*,int,const void*),\n<line6>void(*xDel)(void*)\n<line7>){\n<line8>CollSeq *pColl;\n<line9>int enc2;\n<line10>assert( sqlite3_mutex_held(db->mutex) );\n<line11>/* If SQLITE_UTF16 is specified as the encoding type, transform this\n<line12>** to one of SQLITE_UTF16LE or SQLITE_UTF16BE using the\n<line13>** SQLITE_UTF16NATIVE macro. SQLITE_UTF16 is not used internally.\n<line14>*/\n<line15>enc2 = enc;\n<line16>testcase( enc2==SQLITE_UTF16 );\n<line17>testcase( enc2==SQLITE_UTF16_ALIGNED );\n<line18>if( enc2==SQLITE_UTF16 || enc2==SQLITE_UTF16_ALIGNED ){\n<line19>enc2 = SQLITE_UTF16NATIVE;\n<line20>}\n<line21>if( enc2<SQLITE_UTF8 || enc2>SQLITE_UTF16BE ){\n<line22>return SQLITE_MISUSE_BKPT;\n<line23>}\n<line24>/* Check if this call is removing or replacing an existing collation\n<line25>** sequence. If so, and there are active VMs, return busy. If there\n<line26>** are no active VMs, invalidate any pre-compiled statements.\n<line27>*/\n<line28>pColl = sqlite3FindCollSeq(db, (u8)enc2, zName, 0);\n<line29>if( pColl && pColl->xCmp ){\n<line30>if( db->nVdbeActive ){\n<line31>sqlite3ErrorWithMsg(db, SQLITE_BUSY,\n<line32>"unable to delete/modify collation sequence due to active statements");\n<line33>return SQLITE_BUSY;\n<line34>}\n<line35>sqlite3ExpirePreparedStatements(db, 0);\n<line36>/* If collation sequence pColl was created directly by a call to\n<line37>** sqlite3_create_collation, and not generated by synthCollSeq(),\n<line38>** then any copies made by synthCollSeq() need to be invalidated.\n<line39>** Also, collation destructor - CollSeq.xDel() - function may need\n<line40>** to be called.\n<line41>*/\n<line42>if( (pColl->enc & ~SQLITE_UTF16_ALIGNED)==enc2 ){\n<line43>CollSeq *aColl = sqlite3HashFind(&db->aCollSeq, zName);\n<line44>int j;\n<line45>for(j=0; j<3; j++){\n<line46>CollSeq *p = &aColl[j];\n<line47>if( p->enc==pColl->enc ){\n<line48>if( p->xDel ){\n<line49>p->xDel(p->pUser);\n<line50>}\n<line51>p->xCmp = 0;\n<line52>}\n<line53>}\n<line54>}\n<line55>}\n<line56>pColl = sqlite3FindCollSeq(db, (u8)enc2, zName, 1);\n<line57>if( pColl==0 ) return SQLITE_NOMEM_BKPT;\n<line58>pColl->xCmp = xCompare;\n<line59>pColl->pUser = pCtx;\n<line60>pColl->xDel = xDel;\n<line61>pColl->enc = (u8)(enc2 | (enc & SQLITE_UTF16_ALIGNED));\n<line62>sqlite3Error(db, SQLITE_OK);\n<line63>return SQLITE_OK;\n<line64>}
----------------------------------------
Function: sqlite3_limit
Content: <line0>SQLITE_API int sqlite3_limit(sqlite3 *db, int limitId, int newLimit){\n<line1>int oldLimit;\n<line2>#ifdef SQLITE_ENABLE_API_ARMOR\n<line3>if( !sqlite3SafetyCheckOk(db) ){\n<line4>(void)SQLITE_MISUSE_BKPT;\n<line5>return -1;\n<line6>}\n<line7>#endif\n<line8>/* EVIDENCE-OF: R-30189-54097 For each limit category SQLITE_LIMIT_NAME\n<line9>** there is a hard upper bound set at compile-time by a C preprocessor\n<line10>** macro called SQLITE_MAX_NAME. (The "_LIMIT_" in the name is changed to\n<line11>** "_MAX_".)\n<line12>*/\n<line13>assert( aHardLimit[SQLITE_LIMIT_LENGTH]==SQLITE_MAX_LENGTH );\n<line14>assert( aHardLimit[SQLITE_LIMIT_SQL_LENGTH]==SQLITE_MAX_SQL_LENGTH );\n<line15>assert( aHardLimit[SQLITE_LIMIT_COLUMN]==SQLITE_MAX_COLUMN );\n<line16>assert( aHardLimit[SQLITE_LIMIT_EXPR_DEPTH]==SQLITE_MAX_EXPR_DEPTH );\n<line17>assert( aHardLimit[SQLITE_LIMIT_COMPOUND_SELECT]==SQLITE_MAX_COMPOUND_SELECT);\n<line18>assert( aHardLimit[SQLITE_LIMIT_VDBE_OP]==SQLITE_MAX_VDBE_OP );\n<line19>assert( aHardLimit[SQLITE_LIMIT_FUNCTION_ARG]==SQLITE_MAX_FUNCTION_ARG );\n<line20>assert( aHardLimit[SQLITE_LIMIT_ATTACHED]==SQLITE_MAX_ATTACHED );\n<line21>assert( aHardLimit[SQLITE_LIMIT_LIKE_PATTERN_LENGTH]==\n<line22>SQLITE_MAX_LIKE_PATTERN_LENGTH );\n<line23>assert( aHardLimit[SQLITE_LIMIT_VARIABLE_NUMBER]==SQLITE_MAX_VARIABLE_NUMBER);\n<line24>assert( aHardLimit[SQLITE_LIMIT_TRIGGER_DEPTH]==SQLITE_MAX_TRIGGER_DEPTH );\n<line25>assert( aHardLimit[SQLITE_LIMIT_WORKER_THREADS]==SQLITE_MAX_WORKER_THREADS );\n<line26>assert( SQLITE_LIMIT_WORKER_THREADS==(SQLITE_N_LIMIT-1) );\n<line27>if( limitId<0 || limitId>=SQLITE_N_LIMIT ){\n<line28>return -1;\n<line29>}\n<line30>oldLimit = db->aLimit[limitId];\n<line31>if( newLimit>=0 ){                   /* IMP: R-52476-28732 */\n<line32>if( newLimit>aHardLimit[limitId] ){\n<line33>newLimit = aHardLimit[limitId];  /* IMP: R-51463-25634 */\n<line34>}else if( newLimit<SQLITE_MIN_LENGTH && limitId==SQLITE_LIMIT_LENGTH ){\n<line35>newLimit = SQLITE_MIN_LENGTH;\n<line36>}\n<line37>db->aLimit[limitId] = newLimit;\n<line38>}\n<line39>return oldLimit;                     /* IMP: R-53341-35419 */\n<line40>}
----------------------------------------
Function: uriParameter
Content: <line0>static const char *uriParameter(const char *zFilename, const char *zParam){\n<line1>zFilename += sqlite3Strlen30(zFilename) + 1;\n<line2>while( ALWAYS(zFilename!=0) && zFilename[0] ){\n<line3>int x = strcmp(zFilename, zParam);\n<line4>zFilename += sqlite3Strlen30(zFilename) + 1;\n<line5>if( x==0 ) return zFilename;\n<line6>zFilename += sqlite3Strlen30(zFilename) + 1;\n<line7>}\n<line8>return 0;\n<line9>}
----------------------------------------
Function: openDatabase
Content: <line0>static int openDatabase(\n<line1>const char *zFilename, /* Database filename UTF-8 encoded */\n<line2>sqlite3 **ppDb,        /* OUT: Returned database handle */\n<line3>unsigned int flags,    /* Operational flags */\n<line4>const char *zVfs       /* Name of the VFS to use */\n<line5>){\n<line6>sqlite3 *db;                    /* Store allocated handle here */\n<line7>int rc;                         /* Return code */\n<line8>int isThreadsafe;               /* True for threadsafe connections */\n<line9>char *zOpen = 0;                /* Filename argument to pass to BtreeOpen() */\n<line10>char *zErrMsg = 0;              /* Error message from sqlite3ParseUri() */\n<line11>int i;                          /* Loop counter */\n<line12>#ifdef SQLITE_ENABLE_API_ARMOR\n<line13>if( ppDb==0 ) return SQLITE_MISUSE_BKPT;\n<line14>#endif\n<line15>*ppDb = 0;\n<line16>#ifndef SQLITE_OMIT_AUTOINIT\n<line17>rc = sqlite3_initialize();\n<line18>if( rc ) return rc;\n<line19>#endif\n<line20>if( sqlite3GlobalConfig.bCoreMutex==0 ){\n<line21>isThreadsafe = 0;\n<line22>}else if( flags & SQLITE_OPEN_NOMUTEX ){\n<line23>isThreadsafe = 0;\n<line24>}else if( flags & SQLITE_OPEN_FULLMUTEX ){\n<line25>isThreadsafe = 1;\n<line26>}else{\n<line27>isThreadsafe = sqlite3GlobalConfig.bFullMutex;\n<line28>}\n<line29>if( flags & SQLITE_OPEN_PRIVATECACHE ){\n<line30>flags &= ~SQLITE_OPEN_SHAREDCACHE;\n<line31>}else if( sqlite3GlobalConfig.sharedCacheEnabled ){\n<line32>flags |= SQLITE_OPEN_SHAREDCACHE;\n<line33>}\n<line34>/* Remove harmful bits from the flags parameter\n<line35>**\n<line36>** The SQLITE_OPEN_NOMUTEX and SQLITE_OPEN_FULLMUTEX flags were\n<line37>** dealt with in the previous code block.  Besides these, the only\n<line38>** valid input flags for sqlite3_open_v2() are SQLITE_OPEN_READONLY,\n<line39>** SQLITE_OPEN_READWRITE, SQLITE_OPEN_CREATE, SQLITE_OPEN_SHAREDCACHE,\n<line40>** SQLITE_OPEN_PRIVATECACHE, SQLITE_OPEN_EXRESCODE, and some reserved\n<line41>** bits.  Silently mask off all other flags.\n<line42>*/\n<line43>flags &=  ~( SQLITE_OPEN_DELETEONCLOSE |\n<line44>SQLITE_OPEN_EXCLUSIVE |\n<line45>SQLITE_OPEN_MAIN_DB |\n<line46>SQLITE_OPEN_TEMP_DB |\n<line47>SQLITE_OPEN_TRANSIENT_DB |\n<line48>SQLITE_OPEN_MAIN_JOURNAL |\n<line49>SQLITE_OPEN_TEMP_JOURNAL |\n<line50>SQLITE_OPEN_SUBJOURNAL |\n<line51>SQLITE_OPEN_SUPER_JOURNAL |\n<line52>SQLITE_OPEN_NOMUTEX |\n<line53>SQLITE_OPEN_FULLMUTEX |\n<line54>SQLITE_OPEN_WAL\n<line55>);\n<line56>/* Allocate the sqlite data structure */\n<line57>db = sqlite3MallocZero( sizeof(sqlite3) );\n<line58>if( db==0 ) goto opendb_out;\n<line59>if( isThreadsafe\n<line60>#ifdef SQLITE_ENABLE_MULTITHREADED_CHECKS\n<line61>|| sqlite3GlobalConfig.bCoreMutex\n<line62>#endif\n<line63>){\n<line64>db->mutex = sqlite3MutexAlloc(SQLITE_MUTEX_RECURSIVE);\n<line65>if( db->mutex==0 ){\n<line66>sqlite3_free(db);\n<line67>db = 0;\n<line68>goto opendb_out;\n<line69>}\n<line70>if( isThreadsafe==0 ){\n<line71>sqlite3MutexWarnOnContention(db->mutex);\n<line72>}\n<line73>}\n<line74>sqlite3_mutex_enter(db->mutex);\n<line75>db->errMask = (flags & SQLITE_OPEN_EXRESCODE)!=0 ? 0xffffffff : 0xff;\n<line76>db->nDb = 2;\n<line77>db->eOpenState = SQLITE_STATE_BUSY;\n<line78>db->aDb = db->aDbStatic;\n<line79>db->lookaside.bDisable = 1;\n<line80>db->lookaside.sz = 0;\n<line81>assert( sizeof(db->aLimit)==sizeof(aHardLimit) );\n<line82>memcpy(db->aLimit, aHardLimit, sizeof(db->aLimit));\n<line83>db->aLimit[SQLITE_LIMIT_WORKER_THREADS] = SQLITE_DEFAULT_WORKER_THREADS;\n<line84>db->autoCommit = 1;\n<line85>db->nextAutovac = -1;\n<line86>db->szMmap = sqlite3GlobalConfig.szMmap;\n<line87>db->nextPagesize = 0;\n<line88>db->init.azInit = sqlite3StdType; /* Any array of string ptrs will do */\n<line89>#ifdef SQLITE_ENABLE_SORTER_MMAP\n<line90>/* Beginning with version 3.37.0, using the VFS xFetch() API to memory-map\n<line91>** the temporary files used to do external sorts (see code in vdbesort.c)\n<line92>** is disabled. It can still be used either by defining\n<line93>** SQLITE_ENABLE_SORTER_MMAP at compile time or by using the\n<line94>** SQLITE_TESTCTRL_SORTER_MMAP test-control at runtime. */\n<line95>db->nMaxSorterMmap = 0x7FFFFFFF;\n<line96>#endif\n<line97>db->flags |= SQLITE_ShortColNames\n<line98>| SQLITE_EnableTrigger\n<line99>| SQLITE_EnableView\n<line100>| SQLITE_CacheSpill\n<line101>| SQLITE_AttachCreate\n<line102>| SQLITE_AttachWrite\n<line103>| SQLITE_Comments\n<line104>#if !defined(SQLITE_TRUSTED_SCHEMA) || SQLITE_TRUSTED_SCHEMA+0!=0\n<line105>| SQLITE_TrustedSchema\n<line106>#endif\n<line107>/* The SQLITE_DQS compile-time option determines the default settings\n<line108>** for SQLITE_DBCONFIG_DQS_DDL and SQLITE_DBCONFIG_DQS_DML.\n<line109>**\n<line110>**    SQLITE_DQS     SQLITE_DBCONFIG_DQS_DDL    SQLITE_DBCONFIG_DQS_DML\n<line111>**    ----------     -----------------------    -----------------------\n<line112>**     undefined               on                          on\n<line113>**         3                   on                          on\n<line114>**         2                   on                         off\n<line115>**         1                  off                          on\n<line116>**         0                  off                         off\n<line117>**\n<line118>** Legacy behavior is 3 (double-quoted string literals are allowed anywhere)\n<line119>** and so that is the default.  But developers are encouraged to use\n<line120>** -DSQLITE_DQS=0 (best) or -DSQLITE_DQS=1 (second choice) if possible.\n<line121>*/\n<line122>#if !defined(SQLITE_DQS)\n<line123># define SQLITE_DQS 3\n<line124>#endif\n<line125>#if (SQLITE_DQS&1)==1\n<line126>| SQLITE_DqsDML\n<line127>#endif\n<line128>#if (SQLITE_DQS&2)==2\n<line129>| SQLITE_DqsDDL\n<line130>#endif\n<line131>#if !defined(SQLITE_DEFAULT_AUTOMATIC_INDEX) || SQLITE_DEFAULT_AUTOMATIC_INDEX\n<line132>| SQLITE_AutoIndex\n<line133>#endif\n<line134>#if SQLITE_DEFAULT_CKPTFULLFSYNC\n<line135>| SQLITE_CkptFullFSync\n<line136>#endif\n<line137>#if SQLITE_DEFAULT_FILE_FORMAT<4\n<line138>| SQLITE_LegacyFileFmt\n<line139>#endif\n<line140>#ifdef SQLITE_ENABLE_LOAD_EXTENSION\n<line141>| SQLITE_LoadExtension\n<line142>#endif\n<line143>#if SQLITE_DEFAULT_RECURSIVE_TRIGGERS\n<line144>| SQLITE_RecTriggers\n<line145>#endif\n<line146>#if defined(SQLITE_DEFAULT_FOREIGN_KEYS) && SQLITE_DEFAULT_FOREIGN_KEYS\n<line147>| SQLITE_ForeignKeys\n<line148>#endif\n<line149>#if defined(SQLITE_REVERSE_UNORDERED_SELECTS)\n<line150>| SQLITE_ReverseOrder\n<line151>#endif\n<line152>#if defined(SQLITE_ENABLE_OVERSIZE_CELL_CHECK)\n<line153>| SQLITE_CellSizeCk\n<line154>#endif\n<line155>#if defined(SQLITE_ENABLE_FTS3_TOKENIZER)\n<line156>| SQLITE_Fts3Tokenizer\n<line157>#endif\n<line158>#if defined(SQLITE_ENABLE_QPSG)\n<line159>| SQLITE_EnableQPSG\n<line160>#endif\n<line161>#if defined(SQLITE_DEFAULT_DEFENSIVE)\n<line162>| SQLITE_Defensive\n<line163>#endif\n<line164>#if defined(SQLITE_DEFAULT_LEGACY_ALTER_TABLE)\n<line165>| SQLITE_LegacyAlter\n<line166>#endif\n<line167>#if defined(SQLITE_ENABLE_STMT_SCANSTATUS)\n<line168>| SQLITE_StmtScanStatus\n<line169>#endif\n<line170>;\n<line171>sqlite3HashInit(&db->aCollSeq);\n<line172>#ifndef SQLITE_OMIT_VIRTUALTABLE\n<line173>sqlite3HashInit(&db->aModule);\n<line174>#endif\n<line175>/* Add the default collation sequence BINARY. BINARY works for both UTF-8\n<line176>** and UTF-16, so add a version for each to avoid any unnecessary\n<line177>** conversions. The only error that can occur here is a malloc() failure.\n<line178>**\n<line179>** EVIDENCE-OF: R-52786-44878 SQLite defines three built-in collating\n<line180>** functions:\n<line181>*/\n<line182>createCollation(db, sqlite3StrBINARY, SQLITE_UTF8, 0, binCollFunc, 0);\n<line183>createCollation(db, sqlite3StrBINARY, SQLITE_UTF16BE, 0, binCollFunc, 0);\n<line184>createCollation(db, sqlite3StrBINARY, SQLITE_UTF16LE, 0, binCollFunc, 0);\n<line185>createCollation(db, "NOCASE", SQLITE_UTF8, 0, nocaseCollatingFunc, 0);\n<line186>createCollation(db, "RTRIM", SQLITE_UTF8, 0, rtrimCollFunc, 0);\n<line187>if( db->mallocFailed ){\n<line188>goto opendb_out;\n<line189>}\n<line190>#if SQLITE_OS_UNIX && defined(SQLITE_OS_KV_OPTIONAL)\n<line191>/* Process magic filenames ":localStorage:" and ":sessionStorage:" */\n<line192>if( zFilename && zFilename[0]==':' ){\n<line193>if( strcmp(zFilename, ":localStorage:")==0 ){\n<line194>zFilename = "file:local?vfs=kvvfs";\n<line195>flags |= SQLITE_OPEN_URI;\n<line196>}else if( strcmp(zFilename, ":sessionStorage:")==0 ){\n<line197>zFilename = "file:session?vfs=kvvfs";\n<line198>flags |= SQLITE_OPEN_URI;\n<line199>}\n<line200>}\n<line201>#endif /* SQLITE_OS_UNIX && defined(SQLITE_OS_KV_OPTIONAL) */\n<line202>/* Parse the filename/URI argument\n<line203>**\n<line204>** Only allow sensible combinations of bits in the flags argument.\n<line205>** Throw an error if any non-sense combination is used.  If we\n<line206>** do not block illegal combinations here, it could trigger\n<line207>** assert() statements in deeper layers.  Sensible combinations\n<line208>** are:\n<line209>**\n<line210>**  1:  SQLITE_OPEN_READONLY\n<line211>**  2:  SQLITE_OPEN_READWRITE\n<line212>**  6:  SQLITE_OPEN_READWRITE | SQLITE_OPEN_CREATE\n<line213>*/\n<line214>db->openFlags = flags;\n<line215>assert( SQLITE_OPEN_READONLY  == 0x01 );\n<line216>assert( SQLITE_OPEN_READWRITE == 0x02 );\n<line217>assert( SQLITE_OPEN_CREATE    == 0x04 );\n<line218>testcase( (1<<(flags&7))==0x02 ); /* READONLY */\n<line219>testcase( (1<<(flags&7))==0x04 ); /* READWRITE */\n<line220>testcase( (1<<(flags&7))==0x40 ); /* READWRITE | CREATE */\n<line221>if( ((1<<(flags&7)) & 0x46)==0 ){\n<line222>rc = SQLITE_MISUSE_BKPT;  /* IMP: R-18321-05872 */\n<line223>}else{\n<line224>if( zFilename==0 ) zFilename = ":memory:";\n<line225>rc = sqlite3ParseUri(zVfs, zFilename, &flags, &db->pVfs, &zOpen, &zErrMsg);\n<line226>}\n<line227>if( rc!=SQLITE_OK ){\n<line228>if( rc==SQLITE_NOMEM ) sqlite3OomFault(db);\n<line229>sqlite3ErrorWithMsg(db, rc, zErrMsg ? "%s" : 0, zErrMsg);\n<line230>sqlite3_free(zErrMsg);\n<line231>goto opendb_out;\n<line232>}\n<line233>assert( db->pVfs!=0 );\n<line234>#if SQLITE_OS_KV || defined(SQLITE_OS_KV_OPTIONAL)\n<line235>if( sqlite3_stricmp(db->pVfs->zName, "kvvfs")==0 ){\n<line236>db->temp_store = 2;\n<line237>}\n<line238>#endif\n<line239>/* Open the backend database driver */\n<line240>rc = sqlite3BtreeOpen(db->pVfs, zOpen, db, &db->aDb[0].pBt, 0,\n<line241>flags | SQLITE_OPEN_MAIN_DB);\n<line242>if( rc!=SQLITE_OK ){\n<line243>if( rc==SQLITE_IOERR_NOMEM ){\n<line244>rc = SQLITE_NOMEM_BKPT;\n<line245>}\n<line246>sqlite3Error(db, rc);\n<line247>goto opendb_out;\n<line248>}\n<line249>sqlite3BtreeEnter(db->aDb[0].pBt);\n<line250>db->aDb[0].pSchema = sqlite3SchemaGet(db, db->aDb[0].pBt);\n<line251>if( !db->mallocFailed ){\n<line252>sqlite3SetTextEncoding(db, SCHEMA_ENC(db));\n<line253>}\n<line254>sqlite3BtreeLeave(db->aDb[0].pBt);\n<line255>db->aDb[1].pSchema = sqlite3SchemaGet(db, 0);\n<line256>/* The default safety_level for the main database is FULL; for the temp\n<line257>** database it is OFF. This matches the pager layer defaults.\n<line258>*/\n<line259>db->aDb[0].zDbSName = "main";\n<line260>db->aDb[0].safety_level = SQLITE_DEFAULT_SYNCHRONOUS+1;\n<line261>db->aDb[1].zDbSName = "temp";\n<line262>db->aDb[1].safety_level = PAGER_SYNCHRONOUS_OFF;\n<line263>db->eOpenState = SQLITE_STATE_OPEN;\n<line264>if( db->mallocFailed ){\n<line265>goto opendb_out;\n<line266>}\n<line267>/* Register all built-in functions, but do not attempt to read the\n<line268>** database schema yet. This is delayed until the first time the database\n<line269>** is accessed.\n<line270>*/\n<line271>sqlite3Error(db, SQLITE_OK);\n<line272>sqlite3RegisterPerConnectionBuiltinFunctions(db);\n<line273>rc = sqlite3_errcode(db);\n<line274>/* Load compiled-in extensions */\n<line275>for(i=0; rc==SQLITE_OK && i<ArraySize(sqlite3BuiltinExtensions); i++){\n<line276>rc = sqlite3BuiltinExtensions[i](db);\n<line277>}\n<line278>/* Load automatic extensions - extensions that have been registered\n<line279>** using the sqlite3_automatic_extension() API.\n<line280>*/\n<line281>if( rc==SQLITE_OK ){\n<line282>sqlite3AutoLoadExtensions(db);\n<line283>rc = sqlite3_errcode(db);\n<line284>if( rc!=SQLITE_OK ){\n<line285>goto opendb_out;\n<line286>}\n<line287>}\n<line288>#ifdef SQLITE_ENABLE_INTERNAL_FUNCTIONS\n<line289>/* Testing use only!!! The -DSQLITE_ENABLE_INTERNAL_FUNCTIONS=1 compile-time\n<line290>** option gives access to internal functions by default.\n<line291>** Testing use only!!! */\n<line292>db->mDbFlags |= DBFLAG_InternalFunc;\n<line293>#endif\n<line294>/* -DSQLITE_DEFAULT_LOCKING_MODE=1 makes EXCLUSIVE the default locking\n<line295>** mode.  -DSQLITE_DEFAULT_LOCKING_MODE=0 make NORMAL the default locking\n<line296>** mode.  Doing nothing at all also makes NORMAL the default.\n<line297>*/\n<line298>#ifdef SQLITE_DEFAULT_LOCKING_MODE\n<line299>db->dfltLockMode = SQLITE_DEFAULT_LOCKING_MODE;\n<line300>sqlite3PagerLockingMode(sqlite3BtreePager(db->aDb[0].pBt),\n<line301>SQLITE_DEFAULT_LOCKING_MODE);\n<line302>#endif\n<line303>if( rc ) sqlite3Error(db, rc);\n<line304>/* Enable the lookaside-malloc subsystem */\n<line305>setupLookaside(db, 0, sqlite3GlobalConfig.szLookaside,\n<line306>sqlite3GlobalConfig.nLookaside);\n<line307>sqlite3_wal_autocheckpoint(db, SQLITE_DEFAULT_WAL_AUTOCHECKPOINT);\n<line308>opendb_out:\n<line309>if( db ){\n<line310>assert( db->mutex!=0 || isThreadsafe==0\n<line311>|| sqlite3GlobalConfig.bFullMutex==0 );\n<line312>sqlite3_mutex_leave(db->mutex);\n<line313>}\n<line314>rc = sqlite3_errcode(db);\n<line315>assert( db!=0 || (rc&0xff)==SQLITE_NOMEM );\n<line316>if( (rc&0xff)==SQLITE_NOMEM ){\n<line317>sqlite3_close(db);\n<line318>db = 0;\n<line319>}else if( rc!=SQLITE_OK ){\n<line320>db->eOpenState = SQLITE_STATE_SICK;\n<line321>}\n<line322>*ppDb = db;\n<line323>#ifdef SQLITE_ENABLE_SQLLOG\n<line324>if( sqlite3GlobalConfig.xSqllog ){\n<line325>/* Opening a db handle. Fourth parameter is passed 0. */\n<line326>void *pArg = sqlite3GlobalConfig.pSqllogArg;\n<line327>sqlite3GlobalConfig.xSqllog(pArg, db, zFilename, 0);\n<line328>}\n<line329>#endif\n<line330>sqlite3_free_filename(zOpen);\n<line331>return rc;\n<line332>}
----------------------------------------
Function: sqlite3_open
Content: <line0>SQLITE_API int sqlite3_open(\n<line1>const char *zFilename,\n<line2>sqlite3 **ppDb\n<line3>){\n<line4>return openDatabase(zFilename, ppDb,\n<line5>SQLITE_OPEN_READWRITE | SQLITE_OPEN_CREATE, 0);\n<line6>}
----------------------------------------
Function: sqlite3_open_v2
Content: <line0>SQLITE_API int sqlite3_open_v2(\n<line1>const char *filename,   /* Database filename (UTF-8) */\n<line2>sqlite3 **ppDb,         /* OUT: SQLite db handle */\n<line3>int flags,              /* Flags */\n<line4>const char *zVfs        /* Name of VFS module to use */\n<line5>){\n<line6>return openDatabase(filename, ppDb, (unsigned int)flags, zVfs);\n<line7>}
----------------------------------------
Function: sqlite3_open16
Content: <line0>SQLITE_API int sqlite3_open16(\n<line1>const void *zFilename,\n<line2>sqlite3 **ppDb\n<line3>){\n<line4>char const *zFilename8;   /* zFilename encoded in UTF-8 instead of UTF-16 */\n<line5>sqlite3_value *pVal;\n<line6>int rc;\n<line7>#ifdef SQLITE_ENABLE_API_ARMOR\n<line8>if( ppDb==0 ) return SQLITE_MISUSE_BKPT;\n<line9>#endif\n<line10>*ppDb = 0;\n<line11>#ifndef SQLITE_OMIT_AUTOINIT\n<line12>rc = sqlite3_initialize();\n<line13>if( rc ) return rc;\n<line14>#endif\n<line15>if( zFilename==0 ) zFilename = "\000\000";\n<line16>pVal = sqlite3ValueNew(0);\n<line17>sqlite3ValueSetStr(pVal, -1, zFilename, SQLITE_UTF16NATIVE, SQLITE_STATIC);\n<line18>zFilename8 = sqlite3ValueText(pVal, SQLITE_UTF8);\n<line19>if( zFilename8 ){\n<line20>rc = openDatabase(zFilename8, ppDb,\n<line21>SQLITE_OPEN_READWRITE | SQLITE_OPEN_CREATE, 0);\n<line22>assert( *ppDb || rc==SQLITE_NOMEM );\n<line23>if( rc==SQLITE_OK && !DbHasProperty(*ppDb, 0, DB_SchemaLoaded) ){\n<line24>SCHEMA_ENC(*ppDb) = ENC(*ppDb) = SQLITE_UTF16NATIVE;\n<line25>}\n<line26>}else{\n<line27>rc = SQLITE_NOMEM_BKPT;\n<line28>}\n<line29>sqlite3ValueFree(pVal);\n<line30>return rc & 0xff;\n<line31>}
----------------------------------------
Function: sqlite3_create_collation
Content: <line0>SQLITE_API int sqlite3_create_collation(\n<line1>sqlite3* db,\n<line2>const char *zName,\n<line3>int enc,\n<line4>void* pCtx,\n<line5>int(*xCompare)(void*,int,const void*,int,const void*)\n<line6>){\n<line7>return sqlite3_create_collation_v2(db, zName, enc, pCtx, xCompare, 0);\n<line8>}
----------------------------------------
Function: sqlite3_create_collation_v2
Content: <line0>SQLITE_API int sqlite3_create_collation_v2(\n<line1>sqlite3* db,\n<line2>const char *zName,\n<line3>int enc,\n<line4>void* pCtx,\n<line5>int(*xCompare)(void*,int,const void*,int,const void*),\n<line6>void(*xDel)(void*)\n<line7>){\n<line8>int rc;\n<line9>#ifdef SQLITE_ENABLE_API_ARMOR\n<line10>if( !sqlite3SafetyCheckOk(db) || zName==0 ) return SQLITE_MISUSE_BKPT;\n<line11>#endif\n<line12>sqlite3_mutex_enter(db->mutex);\n<line13>assert( !db->mallocFailed );\n<line14>rc = createCollation(db, zName, (u8)enc, pCtx, xCompare, xDel);\n<line15>rc = sqlite3ApiExit(db, rc);\n<line16>sqlite3_mutex_leave(db->mutex);\n<line17>return rc;\n<line18>}
----------------------------------------
Function: sqlite3_create_collation16
Content: <line0>SQLITE_API int sqlite3_create_collation16(\n<line1>sqlite3* db,\n<line2>const void *zName,\n<line3>int enc,\n<line4>void* pCtx,\n<line5>int(*xCompare)(void*,int,const void*,int,const void*)\n<line6>){\n<line7>int rc = SQLITE_OK;\n<line8>char *zName8;\n<line9>#ifdef SQLITE_ENABLE_API_ARMOR\n<line10>if( !sqlite3SafetyCheckOk(db) || zName==0 ) return SQLITE_MISUSE_BKPT;\n<line11>#endif\n<line12>sqlite3_mutex_enter(db->mutex);\n<line13>assert( !db->mallocFailed );\n<line14>zName8 = sqlite3Utf16to8(db, zName, -1, SQLITE_UTF16NATIVE);\n<line15>if( zName8 ){\n<line16>rc = createCollation(db, zName8, (u8)enc, pCtx, xCompare, 0);\n<line17>sqlite3DbFree(db, zName8);\n<line18>}\n<line19>rc = sqlite3ApiExit(db, rc);\n<line20>sqlite3_mutex_leave(db->mutex);\n<line21>return rc;\n<line22>}
----------------------------------------
Function: sqlite3_collation_needed
Content: <line0>SQLITE_API int sqlite3_collation_needed(\n<line1>sqlite3 *db,\n<line2>void *pCollNeededArg,\n<line3>void(*xCollNeeded)(void*,sqlite3*,int eTextRep,const char*)\n<line4>){\n<line5>#ifdef SQLITE_ENABLE_API_ARMOR\n<line6>if( !sqlite3SafetyCheckOk(db) ) return SQLITE_MISUSE_BKPT;\n<line7>#endif\n<line8>sqlite3_mutex_enter(db->mutex);\n<line9>db->xCollNeeded = xCollNeeded;\n<line10>db->xCollNeeded16 = 0;\n<line11>db->pCollNeededArg = pCollNeededArg;\n<line12>sqlite3_mutex_leave(db->mutex);\n<line13>return SQLITE_OK;\n<line14>}
----------------------------------------
Function: sqlite3_collation_needed16
Content: <line0>SQLITE_API int sqlite3_collation_needed16(\n<line1>sqlite3 *db,\n<line2>void *pCollNeededArg,\n<line3>void(*xCollNeeded16)(void*,sqlite3*,int eTextRep,const void*)\n<line4>){\n<line5>#ifdef SQLITE_ENABLE_API_ARMOR\n<line6>if( !sqlite3SafetyCheckOk(db) ) return SQLITE_MISUSE_BKPT;\n<line7>#endif\n<line8>sqlite3_mutex_enter(db->mutex);\n<line9>db->xCollNeeded = 0;\n<line10>db->xCollNeeded16 = xCollNeeded16;\n<line11>db->pCollNeededArg = pCollNeededArg;\n<line12>sqlite3_mutex_leave(db->mutex);\n<line13>return SQLITE_OK;\n<line14>}
----------------------------------------
Function: sqlite3_get_clientdata
Content: <line0>SQLITE_API void *sqlite3_get_clientdata(sqlite3 *db, const char *zName){\n<line1>DbClientData *p;\n<line2>sqlite3_mutex_enter(db->mutex);\n<line3>for(p=db->pDbData; p; p=p->pNext){\n<line4>if( strcmp(p->zName, zName)==0 ){\n<line5>void *pResult = p->pData;\n<line6>sqlite3_mutex_leave(db->mutex);\n<line7>return pResult;\n<line8>}\n<line9>}\n<line10>sqlite3_mutex_leave(db->mutex);\n<line11>return 0;\n<line12>}
----------------------------------------
Function: sqlite3_set_clientdata
Content: <line0>SQLITE_API int sqlite3_set_clientdata(\n<line1>sqlite3 *db,                   /* Attach client data to this connection */\n<line2>const char *zName,             /* Name of the client data */\n<line3>void *pData,                   /* The client data itself */\n<line4>void (*xDestructor)(void*)     /* Destructor */\n<line5>){\n<line6>DbClientData *p, **pp;\n<line7>sqlite3_mutex_enter(db->mutex);\n<line8>pp = &db->pDbData;\n<line9>for(p=db->pDbData; p && strcmp(p->zName,zName); p=p->pNext){\n<line10>pp = &p->pNext;\n<line11>}\n<line12>if( p ){\n<line13>assert( p->pData!=0 );\n<line14>if( p->xDestructor ) p->xDestructor(p->pData);\n<line15>if( pData==0 ){\n<line16>*pp = p->pNext;\n<line17>sqlite3_free(p);\n<line18>sqlite3_mutex_leave(db->mutex);\n<line19>return SQLITE_OK;\n<line20>}\n<line21>}else if( pData==0 ){\n<line22>sqlite3_mutex_leave(db->mutex);\n<line23>return SQLITE_OK;\n<line24>}else{\n<line25>size_t n = strlen(zName);\n<line26>p = sqlite3_malloc64( SZ_DBCLIENTDATA(n+1) );\n<line27>if( p==0 ){\n<line28>if( xDestructor ) xDestructor(pData);\n<line29>sqlite3_mutex_leave(db->mutex);\n<line30>return SQLITE_NOMEM;\n<line31>}\n<line32>memcpy(p->zName, zName, n+1);\n<line33>p->pNext = db->pDbData;\n<line34>db->pDbData = p;\n<line35>}\n<line36>p->pData = pData;\n<line37>p->xDestructor = xDestructor;\n<line38>sqlite3_mutex_leave(db->mutex);\n<line39>return SQLITE_OK;\n<line40>}
----------------------------------------
Function: sqlite3_global_recover
Content: <line0>SQLITE_API int sqlite3_global_recover(void){\n<line1>return SQLITE_OK;\n<line2>}
----------------------------------------
Function: sqlite3_get_autocommit
Content: <line0>SQLITE_API int sqlite3_get_autocommit(sqlite3 *db){\n<line1>#ifdef SQLITE_ENABLE_API_ARMOR\n<line2>if( !sqlite3SafetyCheckOk(db) ){\n<line3>(void)SQLITE_MISUSE_BKPT;\n<line4>return 0;\n<line5>}\n<line6>#endif\n<line7>return db->autoCommit;\n<line8>}
----------------------------------------
Function: sqlite3_thread_cleanup
Content: <line0>SQLITE_API void sqlite3_thread_cleanup(void){\n<line1>}
----------------------------------------
Function: sqlite3_table_column_metadata
Content: <line0>SQLITE_API int sqlite3_table_column_metadata(\n<line1>sqlite3 *db,                /* Connection handle */\n<line2>const char *zDbName,        /* Database name or NULL */\n<line3>const char *zTableName,     /* Table name */\n<line4>const char *zColumnName,    /* Column name */\n<line5>char const **pzDataType,    /* OUTPUT: Declared data type */\n<line6>char const **pzCollSeq,     /* OUTPUT: Collation sequence name */\n<line7>int *pNotNull,              /* OUTPUT: True if NOT NULL constraint exists */\n<line8>int *pPrimaryKey,           /* OUTPUT: True if column part of PK */\n<line9>int *pAutoinc               /* OUTPUT: True if column is auto-increment */\n<line10>){\n<line11>int rc;\n<line12>char *zErrMsg = 0;\n<line13>Table *pTab = 0;\n<line14>Column *pCol = 0;\n<line15>int iCol = 0;\n<line16>char const *zDataType = 0;\n<line17>char const *zCollSeq = 0;\n<line18>int notnull = 0;\n<line19>int primarykey = 0;\n<line20>int autoinc = 0;\n<line21>#ifdef SQLITE_ENABLE_API_ARMOR\n<line22>if( !sqlite3SafetyCheckOk(db) || zTableName==0 ){\n<line23>return SQLITE_MISUSE_BKPT;\n<line24>}\n<line25>#endif\n<line26>/* Ensure the database schema has been loaded */\n<line27>sqlite3_mutex_enter(db->mutex);\n<line28>sqlite3BtreeEnterAll(db);\n<line29>rc = sqlite3Init(db, &zErrMsg);\n<line30>if( SQLITE_OK!=rc ){\n<line31>goto error_out;\n<line32>}\n<line33>/* Locate the table in question */\n<line34>pTab = sqlite3FindTable(db, zTableName, zDbName);\n<line35>if( !pTab || IsView(pTab) ){\n<line36>pTab = 0;\n<line37>goto error_out;\n<line38>}\n<line39>/* Find the column for which info is requested */\n<line40>if( zColumnName==0 ){\n<line41>/* Query for existence of table only */\n<line42>}else{\n<line43>iCol = sqlite3ColumnIndex(pTab, zColumnName);\n<line44>if( iCol>=0 ){\n<line45>pCol = &pTab->aCol[iCol];\n<line46>}else{\n<line47>if( HasRowid(pTab) && sqlite3IsRowid(zColumnName) ){\n<line48>iCol = pTab->iPKey;\n<line49>pCol = iCol>=0 ? &pTab->aCol[iCol] : 0;\n<line50>}else{\n<line51>pTab = 0;\n<line52>goto error_out;\n<line53>}\n<line54>}\n<line55>}\n<line56>/* The following block stores the meta information that will be returned\n<line57>** to the caller in local variables zDataType, zCollSeq, notnull, primarykey\n<line58>** and autoinc. At this point there are two possibilities:\n<line59>**\n<line60>**     1. The specified column name was rowid", "oid" or "_rowid_"\n<line61>**        and there is no explicitly declared IPK column.\n<line62>**\n<line63>**     2. The table is not a view and the column name identified an\n<line64>**        explicitly declared column. Copy meta information from *pCol.\n<line65>*/\n<line66>if( pCol ){\n<line67>zDataType = sqlite3ColumnType(pCol,0);\n<line68>zCollSeq = sqlite3ColumnColl(pCol);\n<line69>notnull = pCol->notNull!=0;\n<line70>primarykey  = (pCol->colFlags & COLFLAG_PRIMKEY)!=0;\n<line71>autoinc = pTab->iPKey==iCol && (pTab->tabFlags & TF_Autoincrement)!=0;\n<line72>}else{\n<line73>zDataType = "INTEGER";\n<line74>primarykey = 1;\n<line75>}\n<line76>if( !zCollSeq ){\n<line77>zCollSeq = sqlite3StrBINARY;\n<line78>}\n<line79>error_out:\n<line80>sqlite3BtreeLeaveAll(db);\n<line81>/* Whether the function call succeeded or failed, set the output parameters\n<line82>** to whatever their local counterparts contain. If an error did occur,\n<line83>** this has the effect of zeroing all output parameters.\n<line84>*/\n<line85>if( pzDataType ) *pzDataType = zDataType;\n<line86>if( pzCollSeq ) *pzCollSeq = zCollSeq;\n<line87>if( pNotNull ) *pNotNull = notnull;\n<line88>if( pPrimaryKey ) *pPrimaryKey = primarykey;\n<line89>if( pAutoinc ) *pAutoinc = autoinc;\n<line90>if( SQLITE_OK==rc && !pTab ){\n<line91>sqlite3DbFree(db, zErrMsg);\n<line92>zErrMsg = sqlite3MPrintf(db, "no such table column: %s.%s", zTableName,\n<line93>zColumnName);\n<line94>rc = SQLITE_ERROR;\n<line95>}\n<line96>sqlite3ErrorWithMsg(db, rc, (zErrMsg?"%s":0), zErrMsg);\n<line97>sqlite3DbFree(db, zErrMsg);\n<line98>rc = sqlite3ApiExit(db, rc);\n<line99>sqlite3_mutex_leave(db->mutex);\n<line100>return rc;\n<line101>}
----------------------------------------
Function: sqlite3_sleep
Content: <line0>SQLITE_API int sqlite3_sleep(int ms){\n<line1>sqlite3_vfs *pVfs;\n<line2>int rc;\n<line3>pVfs = sqlite3_vfs_find(0);\n<line4>if( pVfs==0 ) return 0;\n<line5>/* This function works in milliseconds, but the underlying OsSleep()\n<line6>** API uses microseconds. Hence the 1000's.\n<line7>*/\n<line8>rc = (sqlite3OsSleep(pVfs, ms<0 ? 0 : 1000*ms)/1000);\n<line9>return rc;\n<line10>}
----------------------------------------
Function: sqlite3_extended_result_codes
Content: <line0>SQLITE_API int sqlite3_extended_result_codes(sqlite3 *db, int onoff){\n<line1>#ifdef SQLITE_ENABLE_API_ARMOR\n<line2>if( !sqlite3SafetyCheckOk(db) ) return SQLITE_MISUSE_BKPT;\n<line3>#endif\n<line4>sqlite3_mutex_enter(db->mutex);\n<line5>db->errMask = onoff ? 0xffffffff : 0xff;\n<line6>sqlite3_mutex_leave(db->mutex);\n<line7>return SQLITE_OK;\n<line8>}
----------------------------------------
Function: sqlite3_file_control
Content: <line0>SQLITE_API int sqlite3_file_control(sqlite3 *db, const char *zDbName, int op, void *pArg){\n<line1>int rc = SQLITE_ERROR;\n<line2>Btree *pBtree;\n<line3>#ifdef SQLITE_ENABLE_API_ARMOR\n<line4>if( !sqlite3SafetyCheckOk(db) ) return SQLITE_MISUSE_BKPT;\n<line5>#endif\n<line6>sqlite3_mutex_enter(db->mutex);\n<line7>pBtree = sqlite3DbNameToBtree(db, zDbName);\n<line8>if( pBtree ){\n<line9>Pager *pPager;\n<line10>sqlite3_file *fd;\n<line11>sqlite3BtreeEnter(pBtree);\n<line12>pPager = sqlite3BtreePager(pBtree);\n<line13>assert( pPager!=0 );\n<line14>fd = sqlite3PagerFile(pPager);\n<line15>assert( fd!=0 );\n<line16>if( op==SQLITE_FCNTL_FILE_POINTER ){\n<line17>*(sqlite3_file**)pArg = fd;\n<line18>rc = SQLITE_OK;\n<line19>}else if( op==SQLITE_FCNTL_VFS_POINTER ){\n<line20>*(sqlite3_vfs**)pArg = sqlite3PagerVfs(pPager);\n<line21>rc = SQLITE_OK;\n<line22>}else if( op==SQLITE_FCNTL_JOURNAL_POINTER ){\n<line23>*(sqlite3_file**)pArg = sqlite3PagerJrnlFile(pPager);\n<line24>rc = SQLITE_OK;\n<line25>}else if( op==SQLITE_FCNTL_DATA_VERSION ){\n<line26>*(unsigned int*)pArg = sqlite3PagerDataVersion(pPager);\n<line27>rc = SQLITE_OK;\n<line28>}else if( op==SQLITE_FCNTL_RESERVE_BYTES ){\n<line29>int iNew = *(int*)pArg;\n<line30>*(int*)pArg = sqlite3BtreeGetRequestedReserve(pBtree);\n<line31>if( iNew>=0 && iNew<=255 ){\n<line32>sqlite3BtreeSetPageSize(pBtree, 0, iNew, 0);\n<line33>}\n<line34>rc = SQLITE_OK;\n<line35>}else if( op==SQLITE_FCNTL_RESET_CACHE ){\n<line36>sqlite3BtreeClearCache(pBtree);\n<line37>rc = SQLITE_OK;\n<line38>}else{\n<line39>int nSave = db->busyHandler.nBusy;\n<line40>rc = sqlite3OsFileControl(fd, op, pArg);\n<line41>db->busyHandler.nBusy = nSave;\n<line42>}\n<line43>sqlite3BtreeLeave(pBtree);\n<line44>}\n<line45>sqlite3_mutex_leave(db->mutex);\n<line46>return rc;\n<line47>}
----------------------------------------
Function: sqlite3_test_control
Content: <line0>SQLITE_API int sqlite3_test_control(int op, ...){\n<line1>int rc = 0;\n<line2>#ifdef SQLITE_UNTESTABLE\n<line3>UNUSED_PARAMETER(op);\n<line4>#else\n<line5>va_list ap;\n<line6>va_start(ap, op);\n<line7>switch( op ){\n<line8>/*\n<line9>** Save the current state of the PRNG.\n<line10>*/\n<line11>case SQLITE_TESTCTRL_PRNG_SAVE: {\n<line12>sqlite3PrngSaveState();\n<line13>break;\n<line14>}\n<line15>/*\n<line16>** Restore the state of the PRNG to the last state saved using\n<line17>** PRNG_SAVE.  If PRNG_SAVE has never before been called, then\n<line18>** this verb acts like PRNG_RESET.\n<line19>*/\n<line20>case SQLITE_TESTCTRL_PRNG_RESTORE: {\n<line21>sqlite3PrngRestoreState();\n<line22>break;\n<line23>}\n<line24>/*  sqlite3_test_control(SQLITE_TESTCTRL_PRNG_SEED, int x, sqlite3 *db);\n<line25>**\n<line26>** Control the seed for the pseudo-random number generator (PRNG) that\n<line27>** is built into SQLite.  Cases:\n<line28>**\n<line29>**    x!=0 && db!=0       Seed the PRNG to the current value of the\n<line30>**                        schema cookie in the main database for db, or\n<line31>**                        x if the schema cookie is zero.  This case\n<line32>**                        is convenient to use with database fuzzers\n<line33>**                        as it allows the fuzzer some control over the\n<line34>**                        the PRNG seed.\n<line35>**\n<line36>**    x!=0 && db==0       Seed the PRNG to the value of x.\n<line37>**\n<line38>**    x==0 && db==0       Revert to default behavior of using the\n<line39>**                        xRandomness method on the primary VFS.\n<line40>**\n<line41>** This test-control also resets the PRNG so that the new seed will\n<line42>** be used for the next call to sqlite3_randomness().\n<line43>*/\n<line44>#ifndef SQLITE_OMIT_WSD\n<line45>case SQLITE_TESTCTRL_PRNG_SEED: {\n<line46>int x = va_arg(ap, int);\n<line47>int y;\n<line48>sqlite3 *db = va_arg(ap, sqlite3*);\n<line49>assert( db==0 || db->aDb[0].pSchema!=0 );\n<line50>if( db && (y = db->aDb[0].pSchema->schema_cookie)!=0 ){ x = y; }\n<line51>sqlite3Config.iPrngSeed = x;\n<line52>sqlite3_randomness(0,0);\n<line53>break;\n<line54>}\n<line55>#endif\n<line56>/*  sqlite3_test_control(SQLITE_TESTCTRL_FK_NO_ACTION, sqlite3 *db, int b);\n<line57>**\n<line58>** If b is true, then activate the SQLITE_FkNoAction setting.  If b is\n<line59>** false then clear that setting.  If the SQLITE_FkNoAction setting is\n<line60>** enabled, all foreign key ON DELETE and ON UPDATE actions behave as if\n<line61>** they were NO ACTION, regardless of how they are defined.\n<line62>**\n<line63>** NB:  One must usually run "PRAGMA writable_schema=RESET" after\n<line64>** using this test-control, before it will take full effect.  failing\n<line65>** to reset the schema can result in some unexpected behavior.\n<line66>*/\n<line67>case SQLITE_TESTCTRL_FK_NO_ACTION: {\n<line68>sqlite3 *db = va_arg(ap, sqlite3*);\n<line69>int b = va_arg(ap, int);\n<line70>if( b ){\n<line71>db->flags |= SQLITE_FkNoAction;\n<line72>}else{\n<line73>db->flags &= ~SQLITE_FkNoAction;\n<line74>}\n<line75>break;\n<line76>}\n<line77>/*\n<line78>**  sqlite3_test_control(BITVEC_TEST, size, program)\n<line79>**\n<line80>** Run a test against a Bitvec object of size.  The program argument\n<line81>** is an array of integers that defines the test.  Return -1 on a\n<line82>** memory allocation error, 0 on success, or non-zero for an error.\n<line83>** See the sqlite3BitvecBuiltinTest() for additional information.\n<line84>*/\n<line85>case SQLITE_TESTCTRL_BITVEC_TEST: {\n<line86>int sz = va_arg(ap, int);\n<line87>int *aProg = va_arg(ap, int*);\n<line88>rc = sqlite3BitvecBuiltinTest(sz, aProg);\n<line89>break;\n<line90>}\n<line91>/*\n<line92>**  sqlite3_test_control(FAULT_INSTALL, xCallback)\n<line93>**\n<line94>** Arrange to invoke xCallback() whenever sqlite3FaultSim() is called,\n<line95>** if xCallback is not NULL.\n<line96>**\n<line97>** As a test of the fault simulator mechanism itself, sqlite3FaultSim(0)\n<line98>** is called immediately after installing the new callback and the return\n<line99>** value from sqlite3FaultSim(0) becomes the return from\n<line100>** sqlite3_test_control().\n<line101>*/\n<line102>case SQLITE_TESTCTRL_FAULT_INSTALL: {\n<line103>/* A bug in MSVC prevents it from understanding pointers to functions\n<line104>** types in the second argument to va_arg().  Work around the problem\n<line105>** using a typedef.\n<line106>** http://support.microsoft.com/kb/47961  <-- dead hyperlink\n<line107>** Search at http://web.archive.org/ to find the 2015-03-16 archive\n<line108>** of the link above to see the original text.\n<line109>** sqlite3GlobalConfig.xTestCallback = va_arg(ap, int(*)(int));\n<line110>*/\n<line111>typedef int(*sqlite3FaultFuncType)(int);\n<line112>sqlite3GlobalConfig.xTestCallback = va_arg(ap, sqlite3FaultFuncType);\n<line113>rc = sqlite3FaultSim(0);\n<line114>break;\n<line115>}\n<line116>/*\n<line117>**  sqlite3_test_control(BENIGN_MALLOC_HOOKS, xBegin, xEnd)\n<line118>**\n<line119>** Register hooks to call to indicate which malloc() failures\n<line120>** are benign.\n<line121>*/\n<line122>case SQLITE_TESTCTRL_BENIGN_MALLOC_HOOKS: {\n<line123>typedef void (*void_function)(void);\n<line124>void_function xBenignBegin;\n<line125>void_function xBenignEnd;\n<line126>xBenignBegin = va_arg(ap, void_function);\n<line127>xBenignEnd = va_arg(ap, void_function);\n<line128>sqlite3BenignMallocHooks(xBenignBegin, xBenignEnd);\n<line129>break;\n<line130>}\n<line131>/*\n<line132>**  sqlite3_test_control(SQLITE_TESTCTRL_PENDING_BYTE, unsigned int X)\n<line133>**\n<line134>** Set the PENDING byte to the value in the argument, if X>0.\n<line135>** Make no changes if X==0.  Return the value of the pending byte\n<line136>** as it existing before this routine was called.\n<line137>**\n<line138>** IMPORTANT:  Changing the PENDING byte from 0x40000000 results in\n<line139>** an incompatible database file format.  Changing the PENDING byte\n<line140>** while any database connection is open results in undefined and\n<line141>** deleterious behavior.\n<line142>*/\n<line143>case SQLITE_TESTCTRL_PENDING_BYTE: {\n<line144>rc = PENDING_BYTE;\n<line145>#ifndef SQLITE_OMIT_WSD\n<line146>{\n<line147>unsigned int newVal = va_arg(ap, unsigned int);\n<line148>if( newVal ) sqlite3PendingByte = newVal;\n<line149>}\n<line150>#endif\n<line151>break;\n<line152>}\n<line153>/*\n<line154>**  sqlite3_test_control(SQLITE_TESTCTRL_ASSERT, int X)\n<line155>**\n<line156>** This action provides a run-time test to see whether or not\n<line157>** assert() was enabled at compile-time.  If X is true and assert()\n<line158>** is enabled, then the return value is true.  If X is true and\n<line159>** assert() is disabled, then the return value is zero.  If X is\n<line160>** false and assert() is enabled, then the assertion fires and the\n<line161>** process aborts.  If X is false and assert() is disabled, then the\n<line162>** return value is zero.\n<line163>*/\n<line164>case SQLITE_TESTCTRL_ASSERT: {\n<line165>volatile int x = 0;\n<line166>assert( /*side-effects-ok*/ (x = va_arg(ap,int))!=0 );\n<line167>rc = x;\n<line168>#if defined(SQLITE_DEBUG)\n<line169>/* Invoke these debugging routines so that the compiler does not\n<line170>** issue "defined but not used" warnings. */\n<line171>if( x==9999 ){\n<line172>sqlite3ShowExpr(0);\n<line173>sqlite3ShowExprList(0);\n<line174>sqlite3ShowIdList(0);\n<line175>sqlite3ShowSrcList(0);\n<line176>sqlite3ShowWith(0);\n<line177>sqlite3ShowUpsert(0);\n<line178>#ifndef SQLITE_OMIT_TRIGGER\n<line179>sqlite3ShowTriggerStep(0);\n<line180>sqlite3ShowTriggerStepList(0);\n<line181>sqlite3ShowTrigger(0);\n<line182>sqlite3ShowTriggerList(0);\n<line183>#endif\n<line184>#ifndef SQLITE_OMIT_WINDOWFUNC\n<line185>sqlite3ShowWindow(0);\n<line186>sqlite3ShowWinFunc(0);\n<line187>#endif\n<line188>sqlite3ShowSelect(0);\n<line189>}\n<line190>#endif\n<line191>break;\n<line192>}\n<line193>/*\n<line194>**  sqlite3_test_control(SQLITE_TESTCTRL_ALWAYS, int X)\n<line195>**\n<line196>** This action provides a run-time test to see how the ALWAYS and\n<line197>** NEVER macros were defined at compile-time.\n<line198>**\n<line199>** The return value is ALWAYS(X) if X is true, or 0 if X is false.\n<line200>**\n<line201>** The recommended test is X==2.  If the return value is 2, that means\n<line202>** ALWAYS() and NEVER() are both no-op pass-through macros, which is the\n<line203>** default setting.  If the return value is 1, then ALWAYS() is either\n<line204>** hard-coded to true or else it asserts if its argument is false.\n<line205>** The first behavior (hard-coded to true) is the case if\n<line206>** SQLITE_TESTCTRL_ASSERT shows that assert() is disabled and the second\n<line207>** behavior (assert if the argument to ALWAYS() is false) is the case if\n<line208>** SQLITE_TESTCTRL_ASSERT shows that assert() is enabled.\n<line209>**\n<line210>** The run-time test procedure might look something like this:\n<line211>**\n<line212>**    if( sqlite3_test_control(SQLITE_TESTCTRL_ALWAYS, 2)==2 ){\n<line213>**      // ALWAYS() and NEVER() are no-op pass-through macros\n<line214>**    }else if( sqlite3_test_control(SQLITE_TESTCTRL_ASSERT, 1) ){\n<line215>**      // ALWAYS(x) asserts that x is true. NEVER(x) asserts x is false.\n<line216>**    }else{\n<line217>**      // ALWAYS(x) is a constant 1.  NEVER(x) is a constant 0.\n<line218>**    }\n<line219>*/\n<line220>case SQLITE_TESTCTRL_ALWAYS: {\n<line221>int x = va_arg(ap,int);\n<line222>rc = x ? ALWAYS(x) : 0;\n<line223>break;\n<line224>}\n<line225>/*\n<line226>**   sqlite3_test_control(SQLITE_TESTCTRL_BYTEORDER);\n<line227>**\n<line228>** The integer returned reveals the byte-order of the computer on which\n<line229>** SQLite is running:\n<line230>**\n<line231>**       1     big-endian,    determined at run-time\n<line232>**      10     little-endian, determined at run-time\n<line233>**  432101     big-endian,    determined at compile-time\n<line234>**  123410     little-endian, determined at compile-time\n<line235>*/\n<line236>case SQLITE_TESTCTRL_BYTEORDER: {\n<line237>rc = SQLITE_BYTEORDER*100 + SQLITE_LITTLEENDIAN*10 + SQLITE_BIGENDIAN;\n<line238>break;\n<line239>}\n<line240>/*  sqlite3_test_control(SQLITE_TESTCTRL_OPTIMIZATIONS, sqlite3 *db, int N)\n<line241>**\n<line242>** Enable or disable various optimizations for testing purposes.  The\n<line243>** argument N is a bitmask of optimizations to be disabled.  For normal\n<line244>** operation N should be 0.  The idea is that a test program (like the\n<line245>** SQL Logic Test or SLT test module) can run the same SQL multiple times\n<line246>** with various optimizations disabled to verify that the same answer\n<line247>** is obtained in every case.\n<line248>*/\n<line249>case SQLITE_TESTCTRL_OPTIMIZATIONS: {\n<line250>sqlite3 *db = va_arg(ap, sqlite3*);\n<line251>db->dbOptFlags = va_arg(ap, u32);\n<line252>break;\n<line253>}\n<line254>/*  sqlite3_test_control(SQLITE_TESTCTRL_GETOPT, sqlite3 *db, int *N)\n<line255>**\n<line256>** Write the current optimization settings into *N.  A zero bit means that\n<line257>** the optimization is on, and a 1 bit means that the optimization is off.\n<line258>*/\n<line259>case SQLITE_TESTCTRL_GETOPT: {\n<line260>sqlite3 *db = va_arg(ap, sqlite3*);\n<line261>int *pN = va_arg(ap, int*);\n<line262>*pN = db->dbOptFlags;\n<line263>break;\n<line264>}\n<line265>/*   sqlite3_test_control(SQLITE_TESTCTRL_LOCALTIME_FAULT, onoff, xAlt);\n<line266>**\n<line267>** If parameter onoff is 1, subsequent calls to localtime() fail.\n<line268>** If 2, then invoke xAlt() instead of localtime().  If 0, normal\n<line269>** processing.\n<line270>**\n<line271>** xAlt arguments are void pointers, but they really want to be:\n<line272>**\n<line273>**    int xAlt(const time_t*, struct tm*);\n<line274>**\n<line275>** xAlt should write results in to struct tm object of its 2nd argument\n<line276>** and return zero on success, or return non-zero on failure.\n<line277>*/\n<line278>case SQLITE_TESTCTRL_LOCALTIME_FAULT: {\n<line279>sqlite3GlobalConfig.bLocaltimeFault = va_arg(ap, int);\n<line280>if( sqlite3GlobalConfig.bLocaltimeFault==2 ){\n<line281>typedef int(*sqlite3LocaltimeType)(const void*,void*);\n<line282>sqlite3GlobalConfig.xAltLocaltime = va_arg(ap, sqlite3LocaltimeType);\n<line283>}else{\n<line284>sqlite3GlobalConfig.xAltLocaltime = 0;\n<line285>}\n<line286>break;\n<line287>}\n<line288>/*   sqlite3_test_control(SQLITE_TESTCTRL_INTERNAL_FUNCTIONS, sqlite3*);\n<line289>**\n<line290>** Toggle the ability to use internal functions on or off for\n<line291>** the database connection given in the argument.\n<line292>*/\n<line293>case SQLITE_TESTCTRL_INTERNAL_FUNCTIONS: {\n<line294>sqlite3 *db = va_arg(ap, sqlite3*);\n<line295>db->mDbFlags ^= DBFLAG_InternalFunc;\n<line296>break;\n<line297>}\n<line298>/*   sqlite3_test_control(SQLITE_TESTCTRL_NEVER_CORRUPT, int);\n<line299>**\n<line300>** Set or clear a flag that indicates that the database file is always well-\n<line301>** formed and never corrupt.  This flag is clear by default, indicating that\n<line302>** database files might have arbitrary corruption.  Setting the flag during\n<line303>** testing causes certain assert() statements in the code to be activated\n<line304>** that demonstrate invariants on well-formed database files.\n<line305>*/\n<line306>case SQLITE_TESTCTRL_NEVER_CORRUPT: {\n<line307>sqlite3GlobalConfig.neverCorrupt = va_arg(ap, int);\n<line308>break;\n<line309>}\n<line310>/*   sqlite3_test_control(SQLITE_TESTCTRL_EXTRA_SCHEMA_CHECKS, int);\n<line311>**\n<line312>** Set or clear a flag that causes SQLite to verify that type, name,\n<line313>** and tbl_name fields of the sqlite_schema table.  This is normally\n<line314>** on, but it is sometimes useful to turn it off for testing.\n<line315>**\n<line316>** 2020-07-22:  Disabling EXTRA_SCHEMA_CHECKS also disables the\n<line317>** verification of rootpage numbers when parsing the schema.  This\n<line318>** is useful to make it easier to reach strange internal error states\n<line319>** during testing.  The EXTRA_SCHEMA_CHECKS setting is always enabled\n<line320>** in production.\n<line321>*/\n<line322>case SQLITE_TESTCTRL_EXTRA_SCHEMA_CHECKS: {\n<line323>sqlite3GlobalConfig.bExtraSchemaChecks = va_arg(ap, int);\n<line324>break;\n<line325>}\n<line326>/* Set the threshold at which OP_Once counters reset back to zero.\n<line327>** By default this is 0x7ffffffe (over 2 billion), but that value is\n<line328>** too big to test in a reasonable amount of time, so this control is\n<line329>** provided to set a small and easily reachable reset value.\n<line330>*/\n<line331>case SQLITE_TESTCTRL_ONCE_RESET_THRESHOLD: {\n<line332>sqlite3GlobalConfig.iOnceResetThreshold = va_arg(ap, int);\n<line333>break;\n<line334>}\n<line335>/*   sqlite3_test_control(SQLITE_TESTCTRL_VDBE_COVERAGE, xCallback, ptr);\n<line336>**\n<line337>** Set the VDBE coverage callback function to xCallback with context\n<line338>** pointer ptr.\n<line339>*/\n<line340>case SQLITE_TESTCTRL_VDBE_COVERAGE: {\n<line341>#ifdef SQLITE_VDBE_COVERAGE\n<line342>typedef void (*branch_callback)(void*,unsigned int,\n<line343>unsigned char,unsigned char);\n<line344>sqlite3GlobalConfig.xVdbeBranch = va_arg(ap,branch_callback);\n<line345>sqlite3GlobalConfig.pVdbeBranchArg = va_arg(ap,void*);\n<line346>#endif\n<line347>break;\n<line348>}\n<line349>/*   sqlite3_test_control(SQLITE_TESTCTRL_SORTER_MMAP, db, nMax); */\n<line350>case SQLITE_TESTCTRL_SORTER_MMAP: {\n<line351>sqlite3 *db = va_arg(ap, sqlite3*);\n<line352>db->nMaxSorterMmap = va_arg(ap, int);\n<line353>break;\n<line354>}\n<line355>/*   sqlite3_test_control(SQLITE_TESTCTRL_ISINIT);\n<line356>**\n<line357>** Return SQLITE_OK if SQLite has been initialized and SQLITE_ERROR if\n<line358>** not.\n<line359>*/\n<line360>case SQLITE_TESTCTRL_ISINIT: {\n<line361>if( sqlite3GlobalConfig.isInit==0 ) rc = SQLITE_ERROR;\n<line362>break;\n<line363>}\n<line364>/*  sqlite3_test_control(SQLITE_TESTCTRL_IMPOSTER, db, dbName, mode, tnum);\n<line365>**\n<line366>** This test control is used to create imposter tables.  "db" is a pointer\n<line367>** to the database connection.  dbName is the database name (ex: "main" or\n<line368>** "temp") which will receive the imposter.  "mode" turns imposter mode on\n<line369>** or off.  mode==0 means imposter mode is off.  mode==1 means imposter mode\n<line370>** is on.  mode==2 means imposter mode is on but results in an imposter\n<line371>** table that is read-only unless writable_schema is on.  "tnum" is the\n<line372>** root page of the b-tree to which the imposter table should connect.\n<line373>**\n<line374>** Enable imposter mode only when the schema has already been parsed.  Then\n<line375>** run a single CREATE TABLE statement to construct the imposter table in\n<line376>** the parsed schema.  Then turn imposter mode back off again.\n<line377>**\n<line378>** If onOff==0 and tnum>0 then reset the schema for all databases, causing\n<line379>** the schema to be reparsed the next time it is needed.  This has the\n<line380>** effect of erasing all imposter tables.\n<line381>*/\n<line382>case SQLITE_TESTCTRL_IMPOSTER: {\n<line383>sqlite3 *db = va_arg(ap, sqlite3*);\n<line384>int iDb;\n<line385>sqlite3_mutex_enter(db->mutex);\n<line386>iDb = sqlite3FindDbName(db, va_arg(ap,const char*));\n<line387>if( iDb>=0 ){\n<line388>db->init.iDb = iDb;\n<line389>db->init.busy = db->init.imposterTable = va_arg(ap,int);\n<line390>db->init.newTnum = va_arg(ap,int);\n<line391>if( db->init.busy==0 && db->init.newTnum>0 ){\n<line392>sqlite3ResetAllSchemasOfConnection(db);\n<line393>}\n<line394>}\n<line395>sqlite3_mutex_leave(db->mutex);\n<line396>break;\n<line397>}\n<line398>#if defined(YYCOVERAGE)\n<line399>/*  sqlite3_test_control(SQLITE_TESTCTRL_PARSER_COVERAGE, FILE *out)\n<line400>**\n<line401>** This test control (only available when SQLite is compiled with\n<line402>** -DYYCOVERAGE) writes a report onto "out" that shows all\n<line403>** state/lookahead combinations in the parser state machine\n<line404>** which are never exercised.  If any state is missed, make the\n<line405>** return code SQLITE_ERROR.\n<line406>*/\n<line407>case SQLITE_TESTCTRL_PARSER_COVERAGE: {\n<line408>FILE *out = va_arg(ap, FILE*);\n<line409>if( sqlite3ParserCoverage(out) ) rc = SQLITE_ERROR;\n<line410>break;\n<line411>}\n<line412>#endif /* defined(YYCOVERAGE) */\n<line413>/*  sqlite3_test_control(SQLITE_TESTCTRL_RESULT_INTREAL, sqlite3_context*);\n<line414>**\n<line415>** This test-control causes the most recent sqlite3_result_int64() value\n<line416>** to be interpreted as a MEM_IntReal instead of as an MEM_Int.  Normally,\n<line417>** MEM_IntReal values only arise during an INSERT operation of integer\n<line418>** values into a REAL column, so they can be challenging to test.  This\n<line419>** test-control enables us to write an intreal() SQL function that can\n<line420>** inject an intreal() value at arbitrary places in an SQL statement,\n<line421>** for testing purposes.\n<line422>*/\n<line423>case SQLITE_TESTCTRL_RESULT_INTREAL: {\n<line424>sqlite3_context *pCtx = va_arg(ap, sqlite3_context*);\n<line425>sqlite3ResultIntReal(pCtx);\n<line426>break;\n<line427>}\n<line428>/*  sqlite3_test_control(SQLITE_TESTCTRL_SEEK_COUNT,\n<line429>**    sqlite3 *db,    // Database connection\n<line430>**    u64 *pnSeek     // Write seek count here\n<line431>**  );\n<line432>**\n<line433>** This test-control queries the seek-counter on the "main" database\n<line434>** file.  The seek-counter is written into *pnSeek and is then reset.\n<line435>** The seek-count is only available if compiled with SQLITE_DEBUG.\n<line436>*/\n<line437>case SQLITE_TESTCTRL_SEEK_COUNT: {\n<line438>sqlite3 *db = va_arg(ap, sqlite3*);\n<line439>u64 *pn = va_arg(ap, sqlite3_uint64*);\n<line440>*pn = sqlite3BtreeSeekCount(db->aDb->pBt);\n<line441>(void)db;  /* Silence harmless unused variable warning */\n<line442>break;\n<line443>}\n<line444>/*  sqlite3_test_control(SQLITE_TESTCTRL_TRACEFLAGS, op, ptr)\n<line445>**\n<line446>**  "ptr" is a pointer to a u32.\n<line447>**\n<line448>**   op==0       Store the current sqlite3TreeTrace in *ptr\n<line449>**   op==1       Set sqlite3TreeTrace to the value *ptr\n<line450>**   op==2       Store the current sqlite3WhereTrace in *ptr\n<line451>**   op==3       Set sqlite3WhereTrace to the value *ptr\n<line452>*/\n<line453>case SQLITE_TESTCTRL_TRACEFLAGS: {\n<line454>int opTrace = va_arg(ap, int);\n<line455>u32 *ptr = va_arg(ap, u32*);\n<line456>switch( opTrace ){\n<line457>case 0:   *ptr = sqlite3TreeTrace;      break;\n<line458>case 1:   sqlite3TreeTrace = *ptr;      break;\n<line459>case 2:   *ptr = sqlite3WhereTrace;     break;\n<line460>case 3:   sqlite3WhereTrace = *ptr;     break;\n<line461>}\n<line462>break;\n<line463>}\n<line464>/* sqlite3_test_control(SQLITE_TESTCTRL_LOGEST,\n<line465>**      double fIn,     // Input value\n<line466>**      int *pLogEst,   // sqlite3LogEstFromDouble(fIn)\n<line467>**      u64 *pInt,      // sqlite3LogEstToInt(*pLogEst)\n<line468>**      int *pLogEst2   // sqlite3LogEst(*pInt)\n<line469>** );\n<line470>**\n<line471>** Test access for the LogEst conversion routines.\n<line472>*/\n<line473>case SQLITE_TESTCTRL_LOGEST: {\n<line474>double rIn = va_arg(ap, double);\n<line475>LogEst rLogEst = sqlite3LogEstFromDouble(rIn);\n<line476>int *pI1 = va_arg(ap,int*);\n<line477>u64 *pU64 = va_arg(ap,u64*);\n<line478>int *pI2 = va_arg(ap,int*);\n<line479>*pI1 = rLogEst;\n<line480>*pU64 = sqlite3LogEstToInt(rLogEst);\n<line481>*pI2 = sqlite3LogEst(*pU64);\n<line482>break;\n<line483>}\n<line484>#if defined(SQLITE_DEBUG) && !defined(SQLITE_OMIT_WSD)\n<line485>/* sqlite3_test_control(SQLITE_TESTCTRL_TUNE, id, *piValue)\n<line486>**\n<line487>** If "id" is an integer between 1 and SQLITE_NTUNE then set the value\n<line488>** of the id-th tuning parameter to *piValue.  If "id" is between -1\n<line489>** and -SQLITE_NTUNE, then write the current value of the (-id)-th\n<line490>** tuning parameter into *piValue.\n<line491>**\n<line492>** Tuning parameters are for use during transient development builds,\n<line493>** to help find the best values for constants in the query planner.\n<line494>** Access tuning parameters using the Tuning(ID) macro.  Set the\n<line495>** parameters in the CLI using ".testctrl tune ID VALUE".\n<line496>**\n<line497>** Transient use only.  Tuning parameters should not be used in\n<line498>** checked-in code.\n<line499>*/\n<line500>case SQLITE_TESTCTRL_TUNE: {\n<line501>int id = va_arg(ap, int);\n<line502>int *piValue = va_arg(ap, int*);\n<line503>if( id>0 && id<=SQLITE_NTUNE ){\n<line504>Tuning(id) = *piValue;\n<line505>}else if( id<0 && id>=-SQLITE_NTUNE ){\n<line506>*piValue = Tuning(-id);\n<line507>}else{\n<line508>rc = SQLITE_NOTFOUND;\n<line509>}\n<line510>break;\n<line511>}\n<line512>#endif\n<line513>/* sqlite3_test_control(SQLITE_TESTCTRL_JSON_SELFCHECK, &onOff);\n<line514>**\n<line515>** Activate or deactivate validation of JSONB that is generated from\n<line516>** text.  Off by default, as the validation is slow.  Validation is\n<line517>** only available if compiled using SQLITE_DEBUG.\n<line518>**\n<line519>** If onOff is initially 1, then turn it on.  If onOff is initially\n<line520>** off, turn it off.  If onOff is initially -1, then change onOff\n<line521>** to be the current setting.\n<line522>*/\n<line523>case SQLITE_TESTCTRL_JSON_SELFCHECK: {\n<line524>#if defined(SQLITE_DEBUG) && !defined(SQLITE_OMIT_WSD)\n<line525>int *pOnOff = va_arg(ap, int*);\n<line526>if( *pOnOff<0 ){\n<line527>*pOnOff = sqlite3Config.bJsonSelfcheck;\n<line528>}else{\n<line529>sqlite3Config.bJsonSelfcheck = (u8)((*pOnOff)&0xff);\n<line530>}\n<line531>#endif\n<line532>break;\n<line533>}\n<line534>}\n<line535>va_end(ap);\n<line536>#endif /* SQLITE_UNTESTABLE */\n<line537>return rc;\n<line538>}
----------------------------------------
Function: databaseName
Content: <line0>static const char *databaseName(const char *zName){\n<line1>while( zName[-1]!=0 || zName[-2]!=0 || zName[-3]!=0 || zName[-4]!=0 ){\n<line2>zName--;\n<line3>}\n<line4>return zName;\n<line5>}
----------------------------------------
Function: appendText
Content: <line0>static char *appendText(char *p, const char *z){\n<line1>size_t n = strlen(z);\n<line2>memcpy(p, z, n+1);\n<line3>return p+n+1;\n<line4>}
----------------------------------------
Function: sqlite3_create_filename
Content: <line0>SQLITE_API const char *sqlite3_create_filename(\n<line1>const char *zDatabase,\n<line2>const char *zJournal,\n<line3>const char *zWal,\n<line4>int nParam,\n<line5>const char **azParam\n<line6>){\n<line7>sqlite3_int64 nByte;\n<line8>int i;\n<line9>char *pResult, *p;\n<line10>nByte = strlen(zDatabase) + strlen(zJournal) + strlen(zWal) + 10;\n<line11>for(i=0; i<nParam*2; i++){\n<line12>nByte += strlen(azParam[i])+1;\n<line13>}\n<line14>pResult = p = sqlite3_malloc64( nByte );\n<line15>if( p==0 ) return 0;\n<line16>memset(p, 0, 4);\n<line17>p += 4;\n<line18>p = appendText(p, zDatabase);\n<line19>for(i=0; i<nParam*2; i++){\n<line20>p = appendText(p, azParam[i]);\n<line21>}\n<line22>*(p++) = 0;\n<line23>p = appendText(p, zJournal);\n<line24>p = appendText(p, zWal);\n<line25>*(p++) = 0;\n<line26>*(p++) = 0;\n<line27>assert( (sqlite3_int64)(p - pResult)==nByte );\n<line28>return pResult + 4;\n<line29>}
----------------------------------------
Function: sqlite3_free_filename
Content: <line0>SQLITE_API void sqlite3_free_filename(const char *p){\n<line1>if( p==0 ) return;\n<line2>p = databaseName(p);\n<line3>sqlite3_free((char*)p - 4);\n<line4>}
----------------------------------------
Function: sqlite3_uri_parameter
Content: <line0>SQLITE_API const char *sqlite3_uri_parameter(const char *zFilename, const char *zParam){\n<line1>if( zFilename==0 || zParam==0 ) return 0;\n<line2>zFilename = databaseName(zFilename);\n<line3>return uriParameter(zFilename, zParam);\n<line4>}
----------------------------------------
Function: sqlite3_uri_key
Content: <line0>SQLITE_API const char *sqlite3_uri_key(const char *zFilename, int N){\n<line1>if( zFilename==0 || N<0 ) return 0;\n<line2>zFilename = databaseName(zFilename);\n<line3>zFilename += sqlite3Strlen30(zFilename) + 1;\n<line4>while( ALWAYS(zFilename) && zFilename[0] && (N--)>0 ){\n<line5>zFilename += sqlite3Strlen30(zFilename) + 1;\n<line6>zFilename += sqlite3Strlen30(zFilename) + 1;\n<line7>}\n<line8>return zFilename[0] ? zFilename : 0;\n<line9>}
----------------------------------------
Function: sqlite3_uri_boolean
Content: <line0>SQLITE_API int sqlite3_uri_boolean(const char *zFilename, const char *zParam, int bDflt){\n<line1>const char *z = sqlite3_uri_parameter(zFilename, zParam);\n<line2>bDflt = bDflt!=0;\n<line3>return z ? sqlite3GetBoolean(z, bDflt) : bDflt;\n<line4>}
----------------------------------------
Function: sqlite3_uri_int64
Content: <line0>SQLITE_API sqlite3_int64 sqlite3_uri_int64(\n<line1>const char *zFilename,    /* Filename as passed to xOpen */\n<line2>const char *zParam,       /* URI parameter sought */\n<line3>sqlite3_int64 bDflt       /* return if parameter is missing */\n<line4>){\n<line5>const char *z = sqlite3_uri_parameter(zFilename, zParam);\n<line6>sqlite3_int64 v;\n<line7>if( z && sqlite3DecOrHexToI64(z, &v)==0 ){\n<line8>bDflt = v;\n<line9>}\n<line10>return bDflt;\n<line11>}
----------------------------------------
Function: sqlite3_filename_database
Content: <line0>SQLITE_API const char *sqlite3_filename_database(const char *zFilename){\n<line1>if( zFilename==0 ) return 0;\n<line2>return databaseName(zFilename);\n<line3>}
----------------------------------------
Function: sqlite3_filename_journal
Content: <line0>SQLITE_API const char *sqlite3_filename_journal(const char *zFilename){\n<line1>if( zFilename==0 ) return 0;\n<line2>zFilename = databaseName(zFilename);\n<line3>zFilename += sqlite3Strlen30(zFilename) + 1;\n<line4>while( ALWAYS(zFilename) && zFilename[0] ){\n<line5>zFilename += sqlite3Strlen30(zFilename) + 1;\n<line6>zFilename += sqlite3Strlen30(zFilename) + 1;\n<line7>}\n<line8>return zFilename + 1;\n<line9>}
----------------------------------------
Function: sqlite3_filename_wal
Content: <line0>SQLITE_API const char *sqlite3_filename_wal(const char *zFilename){\n<line1>#ifdef SQLITE_OMIT_WAL\n<line2>return 0;\n<line3>#else\n<line4>zFilename = sqlite3_filename_journal(zFilename);\n<line5>if( zFilename ) zFilename += sqlite3Strlen30(zFilename) + 1;\n<line6>return zFilename;\n<line7>#endif\n<line8>}
----------------------------------------
Function: sqlite3_db_name
Content: <line0>SQLITE_API const char *sqlite3_db_name(sqlite3 *db, int N){\n<line1>#ifdef SQLITE_ENABLE_API_ARMOR\n<line2>if( !sqlite3SafetyCheckOk(db) ){\n<line3>(void)SQLITE_MISUSE_BKPT;\n<line4>return 0;\n<line5>}\n<line6>#endif\n<line7>if( N<0 || N>=db->nDb ){\n<line8>return 0;\n<line9>}else{\n<line10>return db->aDb[N].zDbSName;\n<line11>}\n<line12>}
----------------------------------------
Function: sqlite3_db_filename
Content: <line0>SQLITE_API const char *sqlite3_db_filename(sqlite3 *db, const char *zDbName){\n<line1>Btree *pBt;\n<line2>#ifdef SQLITE_ENABLE_API_ARMOR\n<line3>if( !sqlite3SafetyCheckOk(db) ){\n<line4>(void)SQLITE_MISUSE_BKPT;\n<line5>return 0;\n<line6>}\n<line7>#endif\n<line8>pBt = sqlite3DbNameToBtree(db, zDbName);\n<line9>return pBt ? sqlite3BtreeGetFilename(pBt) : 0;\n<line10>}
----------------------------------------
Function: sqlite3_db_readonly
Content: <line0>SQLITE_API int sqlite3_db_readonly(sqlite3 *db, const char *zDbName){\n<line1>Btree *pBt;\n<line2>#ifdef SQLITE_ENABLE_API_ARMOR\n<line3>if( !sqlite3SafetyCheckOk(db) ){\n<line4>(void)SQLITE_MISUSE_BKPT;\n<line5>return -1;\n<line6>}\n<line7>#endif\n<line8>pBt = sqlite3DbNameToBtree(db, zDbName);\n<line9>return pBt ? sqlite3BtreeIsReadonly(pBt) : -1;\n<line10>}
----------------------------------------
Function: sqlite3_compileoption_used
Content: <line0>SQLITE_API int sqlite3_compileoption_used(const char *zOptName){\n<line1>int i, n;\n<line2>int nOpt;\n<line3>const char **azCompileOpt;\n<line4>#ifdef SQLITE_ENABLE_API_ARMOR\n<line5>if( zOptName==0 ){\n<line6>(void)SQLITE_MISUSE_BKPT;\n<line7>return 0;\n<line8>}\n<line9>#endif\n<line10>azCompileOpt = sqlite3CompileOptions(&nOpt);\n<line11>if( sqlite3StrNICmp(zOptName, "SQLITE_", 7)==0 ) zOptName += 7;\n<line12>n = sqlite3Strlen30(zOptName);\n<line13>/* Since nOpt is normally in single digits, a linear search is\n<line14>** adequate. No need for a binary search. */\n<line15>for(i=0; i<nOpt; i++){\n<line16>if( sqlite3StrNICmp(zOptName, azCompileOpt[i], n)==0\n<line17>&& sqlite3IsIdChar((unsigned char)azCompileOpt[i][n])==0\n<line18>){\n<line19>return 1;\n<line20>}\n<line21>}\n<line22>return 0;\n<line23>}
----------------------------------------
Function: sqlite3_compileoption_get
Content: <line0>SQLITE_API const char *sqlite3_compileoption_get(int N){\n<line1>int nOpt;\n<line2>const char **azCompileOpt;\n<line3>azCompileOpt = sqlite3CompileOptions(&nOpt);\n<line4>if( N>=0 && N<nOpt ){\n<line5>return azCompileOpt[N];\n<line6>}\n<line7>return 0;\n<line8>}
----------------------------------------
Function: jsonCacheDelete
Content: <line0>static void jsonCacheDelete(JsonCache *p){\n<line1>int i;\n<line2>for(i=0; i<p->nUsed; i++){\n<line3>jsonParseFree(p->a[i]);\n<line4>}\n<line5>sqlite3DbFree(p->db, p);\n<line6>}
----------------------------------------
Function: jsonCacheDeleteGeneric
Content: <line0>static void jsonCacheDeleteGeneric(void *p){\n<line1>jsonCacheDelete((JsonCache*)p);\n<line2>}
----------------------------------------
Function: jsonCacheInsert
Content: <line0>static int jsonCacheInsert(\n<line1>sqlite3_context *ctx,   /* The SQL statement context holding the cache */\n<line2>JsonParse *pParse       /* The parse object to be added to the cache */\n<line3>){\n<line4>JsonCache *p;\n<line5>assert( pParse->zJson!=0 );\n<line6>assert( pParse->bJsonIsRCStr );\n<line7>assert( pParse->delta==0 );\n<line8>p = sqlite3_get_auxdata(ctx, JSON_CACHE_ID);\n<line9>if( p==0 ){\n<line10>sqlite3 *db = sqlite3_context_db_handle(ctx);\n<line11>p = sqlite3DbMallocZero(db, sizeof(*p));\n<line12>if( p==0 ) return SQLITE_NOMEM;\n<line13>p->db = db;\n<line14>sqlite3_set_auxdata(ctx, JSON_CACHE_ID, p, jsonCacheDeleteGeneric);\n<line15>p = sqlite3_get_auxdata(ctx, JSON_CACHE_ID);\n<line16>if( p==0 ) return SQLITE_NOMEM;\n<line17>}\n<line18>if( p->nUsed >= JSON_CACHE_SIZE ){\n<line19>jsonParseFree(p->a[0]);\n<line20>memmove(p->a, &p->a[1], (JSON_CACHE_SIZE-1)*sizeof(p->a[0]));\n<line21>p->nUsed = JSON_CACHE_SIZE-1;\n<line22>}\n<line23>assert( pParse->nBlobAlloc>0 );\n<line24>pParse->eEdit = 0;\n<line25>pParse->nJPRef++;\n<line26>pParse->bReadOnly = 1;\n<line27>p->a[p->nUsed] = pParse;\n<line28>p->nUsed++;\n<line29>return SQLITE_OK;\n<line30>}
----------------------------------------
Function: jsonCacheSearch
Content: <line0>static JsonParse *jsonCacheSearch(\n<line1>sqlite3_context *ctx,    /* The SQL statement context holding the cache */\n<line2>sqlite3_value *pArg      /* Function argument containing SQL text */\n<line3>){\n<line4>JsonCache *p;\n<line5>int i;\n<line6>const char *zJson;\n<line7>int nJson;\n<line8>if( sqlite3_value_type(pArg)!=SQLITE_TEXT ){\n<line9>return 0;\n<line10>}\n<line11>zJson = (const char*)sqlite3_value_text(pArg);\n<line12>if( zJson==0 ) return 0;\n<line13>nJson = sqlite3_value_bytes(pArg);\n<line14>p = sqlite3_get_auxdata(ctx, JSON_CACHE_ID);\n<line15>if( p==0 ){\n<line16>return 0;\n<line17>}\n<line18>for(i=0; i<p->nUsed; i++){\n<line19>if( p->a[i]->zJson==zJson ) break;\n<line20>}\n<line21>if( i>=p->nUsed ){\n<line22>for(i=0; i<p->nUsed; i++){\n<line23>if( p->a[i]->nJson!=nJson ) continue;\n<line24>if( memcmp(p->a[i]->zJson, zJson, nJson)==0 ) break;\n<line25>}\n<line26>}\n<line27>if( i<p->nUsed ){\n<line28>if( i<p->nUsed-1 ){\n<line29>/* Make the matching entry the most recently used entry */\n<line30>JsonParse *tmp = p->a[i];\n<line31>memmove(&p->a[i], &p->a[i+1], (p->nUsed-i-1)*sizeof(tmp));\n<line32>p->a[p->nUsed-1] = tmp;\n<line33>i = p->nUsed - 1;\n<line34>}\n<line35>assert( p->a[i]->delta==0 );\n<line36>return p->a[i];\n<line37>}else{\n<line38>return 0;\n<line39>}\n<line40>}
----------------------------------------
Function: jsonStringZero
Content: <line0>static void jsonStringZero(JsonString *p){\n<line1>p->zBuf = p->zSpace;\n<line2>p->nAlloc = sizeof(p->zSpace);\n<line3>p->nUsed = 0;\n<line4>p->bStatic = 1;\n<line5>}
----------------------------------------
Function: jsonStringInit
Content: <line0>static void jsonStringInit(JsonString *p, sqlite3_context *pCtx){\n<line1>p->pCtx = pCtx;\n<line2>p->eErr = 0;\n<line3>jsonStringZero(p);\n<line4>}
----------------------------------------
Function: jsonStringReset
Content: <line0>static void jsonStringReset(JsonString *p){\n<line1>if( !p->bStatic ) sqlite3RCStrUnref(p->zBuf);\n<line2>jsonStringZero(p);\n<line3>}
----------------------------------------
Function: jsonStringOom
Content: <line0>static void jsonStringOom(JsonString *p){\n<line1>p->eErr |= JSTRING_OOM;\n<line2>if( p->pCtx ) sqlite3_result_error_nomem(p->pCtx);\n<line3>jsonStringReset(p);\n<line4>}
----------------------------------------
Function: jsonStringGrow
Content: <line0>static int jsonStringGrow(JsonString *p, u32 N){\n<line1>u64 nTotal = N<p->nAlloc ? p->nAlloc*2 : p->nAlloc+N+10;\n<line2>char *zNew;\n<line3>if( p->bStatic ){\n<line4>if( p->eErr ) return 1;\n<line5>zNew = sqlite3RCStrNew(nTotal);\n<line6>if( zNew==0 ){\n<line7>jsonStringOom(p);\n<line8>return SQLITE_NOMEM;\n<line9>}\n<line10>memcpy(zNew, p->zBuf, (size_t)p->nUsed);\n<line11>p->zBuf = zNew;\n<line12>p->bStatic = 0;\n<line13>}else{\n<line14>p->zBuf = sqlite3RCStrResize(p->zBuf, nTotal);\n<line15>if( p->zBuf==0 ){\n<line16>p->eErr |= JSTRING_OOM;\n<line17>jsonStringZero(p);\n<line18>return SQLITE_NOMEM;\n<line19>}\n<line20>}\n<line21>p->nAlloc = nTotal;\n<line22>return SQLITE_OK;\n<line23>}
----------------------------------------
Function: jsonStringExpandAndAppend
Content: <line0>static SQLITE_NOINLINE void jsonStringExpandAndAppend(\n<line1>JsonString *p,\n<line2>const char *zIn,\n<line3>u32 N\n<line4>){\n<line5>assert( N>0 );\n<line6>if( jsonStringGrow(p,N) ) return;\n<line7>memcpy(p->zBuf+p->nUsed, zIn, N);\n<line8>p->nUsed += N;\n<line9>}
----------------------------------------
Function: jsonAppendRaw
Content: <line0>static void jsonAppendRaw(JsonString *p, const char *zIn, u32 N){\n<line1>if( N==0 ) return;\n<line2>if( N+p->nUsed >= p->nAlloc ){\n<line3>jsonStringExpandAndAppend(p,zIn,N);\n<line4>}else{\n<line5>memcpy(p->zBuf+p->nUsed, zIn, N);\n<line6>p->nUsed += N;\n<line7>}\n<line8>}
----------------------------------------
Function: jsonAppendRawNZ
Content: <line0>static void jsonAppendRawNZ(JsonString *p, const char *zIn, u32 N){\n<line1>assert( N>0 );\n<line2>if( N+p->nUsed >= p->nAlloc ){\n<line3>jsonStringExpandAndAppend(p,zIn,N);\n<line4>}else{\n<line5>memcpy(p->zBuf+p->nUsed, zIn, N);\n<line6>p->nUsed += N;\n<line7>}\n<line8>}
----------------------------------------
Function: jsonPrintf
Content: <line0>static void jsonPrintf(int N, JsonString *p, const char *zFormat, ...){\n<line1>va_list ap;\n<line2>if( (p->nUsed + N >= p->nAlloc) && jsonStringGrow(p, N) ) return;\n<line3>va_start(ap, zFormat);\n<line4>sqlite3_vsnprintf(N, p->zBuf+p->nUsed, zFormat, ap);\n<line5>va_end(ap);\n<line6>p->nUsed += (int)strlen(p->zBuf+p->nUsed);\n<line7>}
----------------------------------------
Function: jsonAppendCharExpand
Content: <line0>static SQLITE_NOINLINE void jsonAppendCharExpand(JsonString *p, char c){\n<line1>if( jsonStringGrow(p,1) ) return;\n<line2>p->zBuf[p->nUsed++] = c;\n<line3>}
----------------------------------------
Function: jsonAppendChar
Content: <line0>static void jsonAppendChar(JsonString *p, char c){\n<line1>if( p->nUsed>=p->nAlloc ){\n<line2>jsonAppendCharExpand(p,c);\n<line3>}else{\n<line4>p->zBuf[p->nUsed++] = c;\n<line5>}\n<line6>}
----------------------------------------
Function: jsonStringTrimOneChar
Content: <line0>static void jsonStringTrimOneChar(JsonString *p){\n<line1>if( p->eErr==0 ){\n<line2>assert( p->nUsed>0 );\n<line3>p->nUsed--;\n<line4>}\n<line5>}
----------------------------------------
Function: jsonStringTerminate
Content: <line0>static int jsonStringTerminate(JsonString *p){\n<line1>jsonAppendChar(p, 0);\n<line2>jsonStringTrimOneChar(p);\n<line3>return p->eErr==0;\n<line4>}
----------------------------------------
Function: jsonAppendSeparator
Content: <line0>static void jsonAppendSeparator(JsonString *p){\n<line1>char c;\n<line2>if( p->nUsed==0 ) return;\n<line3>c = p->zBuf[p->nUsed-1];\n<line4>if( c=='[' || c=='{' ) return;\n<line5>jsonAppendChar(p, ',');\n<line6>}
----------------------------------------
Function: jsonAppendControlChar
Content: <line0>static void jsonAppendControlChar(JsonString *p, u8 c){\n<line1>static const char aSpecial[] = {\n<line2>0, 0, 0, 0, 0, 0, 0, 0, 'b', 't', 'n', 0, 'f', 'r', 0, 0,\n<line3>0, 0, 0, 0, 0, 0, 0, 0,   0,   0,   0, 0,   0,   0, 0, 0\n<line4>};\n<line5>assert( sizeof(aSpecial)==32 );\n<line6>assert( aSpecial['\b']=='b' );\n<line7>assert( aSpecial['\f']=='f' );\n<line8>assert( aSpecial['\n']=='n' );\n<line9>assert( aSpecial['\r']=='r' );\n<line10>assert( aSpecial['\t']=='t' );\n<line11>assert( c>=0 && c<sizeof(aSpecial) );\n<line12>assert( p->nUsed+7 <= p->nAlloc );\n<line13>if( aSpecial[c] ){\n<line14>p->zBuf[p->nUsed] = '\\';\n<line15>p->zBuf[p->nUsed+1] = aSpecial[c];\n<line16>p->nUsed += 2;\n<line17>}else{\n<line18>p->zBuf[p->nUsed] = '\\';\n<line19>p->zBuf[p->nUsed+1] = 'u';\n<line20>p->zBuf[p->nUsed+2] = '0';\n<line21>p->zBuf[p->nUsed+3] = '0';\n<line22>p->zBuf[p->nUsed+4] = "0123456789abcdef"[c>>4];\n<line23>p->zBuf[p->nUsed+5] = "0123456789abcdef"[c&0xf];\n<line24>p->nUsed += 6;\n<line25>}\n<line26>}
----------------------------------------
Function: jsonAppendString
Content: <line0>static void jsonAppendString(JsonString *p, const char *zIn, u32 N){\n<line1>u32 k;\n<line2>u8 c;\n<line3>const u8 *z = (const u8*)zIn;\n<line4>if( z==0 ) return;\n<line5>if( (N+p->nUsed+2 >= p->nAlloc) && jsonStringGrow(p,N+2)!=0 ) return;\n<line6>p->zBuf[p->nUsed++] = '"';\n<line7>while( 1 /*exit-by-break*/ ){\n<line8>k = 0;\n<line9>/* The following while() is the 4-way unwound equivalent of\n<line10>**\n<line11>**     while( k<N && jsonIsOk[z[k]] ){ k++; }\n<line12>*/\n<line13>while( 1 /* Exit by break */ ){\n<line14>if( k+3>=N ){\n<line15>while( k<N && jsonIsOk[z[k]] ){ k++; }\n<line16>break;\n<line17>}\n<line18>if( !jsonIsOk[z[k]] ){\n<line19>break;\n<line20>}\n<line21>if( !jsonIsOk[z[k+1]] ){\n<line22>k += 1;\n<line23>break;\n<line24>}\n<line25>if( !jsonIsOk[z[k+2]] ){\n<line26>k += 2;\n<line27>break;\n<line28>}\n<line29>if( !jsonIsOk[z[k+3]] ){\n<line30>k += 3;\n<line31>break;\n<line32>}else{\n<line33>k += 4;\n<line34>}\n<line35>}\n<line36>if( k>=N ){\n<line37>if( k>0 ){\n<line38>memcpy(&p->zBuf[p->nUsed], z, k);\n<line39>p->nUsed += k;\n<line40>}\n<line41>break;\n<line42>}\n<line43>if( k>0 ){\n<line44>memcpy(&p->zBuf[p->nUsed], z, k);\n<line45>p->nUsed += k;\n<line46>z += k;\n<line47>N -= k;\n<line48>}\n<line49>c = z[0];\n<line50>if( c=='"' || c=='\\' ){\n<line51>if( (p->nUsed+N+3 > p->nAlloc) && jsonStringGrow(p,N+3)!=0 ) return;\n<line52>p->zBuf[p->nUsed++] = '\\';\n<line53>p->zBuf[p->nUsed++] = c;\n<line54>}else if( c=='\'' ){\n<line55>p->zBuf[p->nUsed++] = c;\n<line56>}else{\n<line57>if( (p->nUsed+N+7 > p->nAlloc) && jsonStringGrow(p,N+7)!=0 ) return;\n<line58>jsonAppendControlChar(p, c);\n<line59>}\n<line60>z++;\n<line61>N--;\n<line62>}\n<line63>p->zBuf[p->nUsed++] = '"';\n<line64>assert( p->nUsed<p->nAlloc );\n<line65>}
----------------------------------------
Function: jsonAppendSqlValue
Content: <line0>static void jsonAppendSqlValue(\n<line1>JsonString *p,                 /* Append to this JSON string */\n<line2>sqlite3_value *pValue          /* Value to append */\n<line3>){\n<line4>switch( sqlite3_value_type(pValue) ){\n<line5>case SQLITE_NULL: {\n<line6>jsonAppendRawNZ(p, "null", 4);\n<line7>break;\n<line8>}\n<line9>case SQLITE_FLOAT: {\n<line10>jsonPrintf(100, p, "%!0.15g", sqlite3_value_double(pValue));\n<line11>break;\n<line12>}\n<line13>case SQLITE_INTEGER: {\n<line14>const char *z = (const char*)sqlite3_value_text(pValue);\n<line15>u32 n = (u32)sqlite3_value_bytes(pValue);\n<line16>jsonAppendRaw(p, z, n);\n<line17>break;\n<line18>}\n<line19>case SQLITE_TEXT: {\n<line20>const char *z = (const char*)sqlite3_value_text(pValue);\n<line21>u32 n = (u32)sqlite3_value_bytes(pValue);\n<line22>if( sqlite3_value_subtype(pValue)==JSON_SUBTYPE ){\n<line23>jsonAppendRaw(p, z, n);\n<line24>}else{\n<line25>jsonAppendString(p, z, n);\n<line26>}\n<line27>break;\n<line28>}\n<line29>default: {\n<line30>JsonParse px;\n<line31>memset(&px, 0, sizeof(px));\n<line32>if( jsonArgIsJsonb(pValue, &px) ){\n<line33>jsonTranslateBlobToText(&px, 0, p);\n<line34>}else if( p->eErr==0 ){\n<line35>sqlite3_result_error(p->pCtx, "JSON cannot hold BLOB values", -1);\n<line36>p->eErr = JSTRING_ERR;\n<line37>jsonStringReset(p);\n<line38>}\n<line39>break;\n<line40>}\n<line41>}\n<line42>}
----------------------------------------
Function: jsonReturnString
Content: <line0>static void jsonReturnString(\n<line1>JsonString *p,            /* String to return */\n<line2>JsonParse *pParse,        /* JSONB source or NULL */\n<line3>sqlite3_context *ctx      /* Where to cache */\n<line4>){\n<line5>assert( (pParse!=0)==(ctx!=0) );\n<line6>assert( ctx==0 || ctx==p->pCtx );\n<line7>if( p->eErr==0 ){\n<line8>int flags = SQLITE_PTR_TO_INT(sqlite3_user_data(p->pCtx));\n<line9>if( flags & JSON_BLOB ){\n<line10>jsonReturnStringAsBlob(p);\n<line11>}else if( p->bStatic ){\n<line12>sqlite3_result_text64(p->pCtx, p->zBuf, p->nUsed,\n<line13>SQLITE_TRANSIENT, SQLITE_UTF8);\n<line14>}else if( jsonStringTerminate(p) ){\n<line15>if( pParse && pParse->bJsonIsRCStr==0 && pParse->nBlobAlloc>0 ){\n<line16>int rc;\n<line17>pParse->zJson = sqlite3RCStrRef(p->zBuf);\n<line18>pParse->nJson = p->nUsed;\n<line19>pParse->bJsonIsRCStr = 1;\n<line20>rc = jsonCacheInsert(ctx, pParse);\n<line21>if( rc==SQLITE_NOMEM ){\n<line22>sqlite3_result_error_nomem(ctx);\n<line23>jsonStringReset(p);\n<line24>return;\n<line25>}\n<line26>}\n<line27>sqlite3_result_text64(p->pCtx, sqlite3RCStrRef(p->zBuf), p->nUsed,\n<line28>sqlite3RCStrUnref,\n<line29>SQLITE_UTF8);\n<line30>}else{\n<line31>sqlite3_result_error_nomem(p->pCtx);\n<line32>}\n<line33>}else if( p->eErr & JSTRING_OOM ){\n<line34>sqlite3_result_error_nomem(p->pCtx);\n<line35>}else if( p->eErr & JSTRING_MALFORMED ){\n<line36>sqlite3_result_error(p->pCtx, "malformed JSON", -1);\n<line37>}\n<line38>jsonStringReset(p);\n<line39>}
----------------------------------------
Function: jsonParseReset
Content: <line0>static void jsonParseReset(JsonParse *pParse){\n<line1>assert( pParse->nJPRef<=1 );\n<line2>if( pParse->bJsonIsRCStr ){\n<line3>sqlite3RCStrUnref(pParse->zJson);\n<line4>pParse->zJson = 0;\n<line5>pParse->nJson = 0;\n<line6>pParse->bJsonIsRCStr = 0;\n<line7>}\n<line8>if( pParse->nBlobAlloc ){\n<line9>sqlite3DbFree(pParse->db, pParse->aBlob);\n<line10>pParse->aBlob = 0;\n<line11>pParse->nBlob = 0;\n<line12>pParse->nBlobAlloc = 0;\n<line13>}\n<line14>}
----------------------------------------
Function: jsonParseFree
Content: <line0>static void jsonParseFree(JsonParse *pParse){\n<line1>if( pParse ){\n<line2>if( pParse->nJPRef>1 ){\n<line3>pParse->nJPRef--;\n<line4>}else{\n<line5>jsonParseReset(pParse);\n<line6>sqlite3DbFree(pParse->db, pParse);\n<line7>}\n<line8>}\n<line9>}
----------------------------------------
Function: jsonHexToInt
Content: <line0>static u8 jsonHexToInt(int h){\n<line1>#ifdef SQLITE_ASCII\n<line2>h += 9*(1&(h>>6));\n<line3>#endif\n<line4>#ifdef SQLITE_EBCDIC\n<line5>h += 9*(1&~(h>>4));\n<line6>#endif\n<line7>return (u8)(h & 0xf);\n<line8>}
----------------------------------------
Function: jsonHexToInt4
Content: <line0>static u32 jsonHexToInt4(const char *z){\n<line1>u32 v;\n<line2>v = (jsonHexToInt(z[0])<<12)\n<line3>+ (jsonHexToInt(z[1])<<8)\n<line4>+ (jsonHexToInt(z[2])<<4)\n<line5>+ jsonHexToInt(z[3]);\n<line6>return v;\n<line7>}
----------------------------------------
Function: jsonIs2Hex
Content: <line0>static int jsonIs2Hex(const char *z){\n<line1>return sqlite3Isxdigit(z[0]) && sqlite3Isxdigit(z[1]);\n<line2>}
----------------------------------------
Function: jsonIs4Hex
Content: <line0>static int jsonIs4Hex(const char *z){\n<line1>return jsonIs2Hex(z) && jsonIs2Hex(&z[2]);\n<line2>}
----------------------------------------
Function: json5Whitespace
Content: <line0>static int json5Whitespace(const char *zIn){\n<line1>int n = 0;\n<line2>const u8 *z = (u8*)zIn;\n<line3>while( 1 /*exit by "goto whitespace_done"*/ ){\n<line4>switch( z[n] ){\n<line5>case 0x09:\n<line6>case 0x0a:\n<line7>case 0x0b:\n<line8>case 0x0c:\n<line9>case 0x0d:\n<line10>case 0x20: {\n<line11>n++;\n<line12>break;\n<line13>}\n<line14>case '/': {\n<line15>if( z[n+1]=='*' && z[n+2]!=0 ){\n<line16>int j;\n<line17>for(j=n+3; z[j]!='/' || z[j-1]!='*'; j++){\n<line18>if( z[j]==0 ) goto whitespace_done;\n<line19>}\n<line20>n = j+1;\n<line21>break;\n<line22>}else if( z[n+1]=='/' ){\n<line23>int j;\n<line24>char c;\n<line25>for(j=n+2; (c = z[j])!=0; j++){\n<line26>if( c=='\n' || c=='\r' ) break;\n<line27>if( 0xe2==(u8)c && 0x80==(u8)z[j+1]\n<line28>&& (0xa8==(u8)z[j+2] || 0xa9==(u8)z[j+2])\n<line29>){\n<line30>j += 2;\n<line31>break;\n<line32>}\n<line33>}\n<line34>n = j;\n<line35>if( z[n] ) n++;\n<line36>break;\n<line37>}\n<line38>goto whitespace_done;\n<line39>}\n<line40>case 0xc2: {\n<line41>if( z[n+1]==0xa0 ){\n<line42>n += 2;\n<line43>break;\n<line44>}\n<line45>goto whitespace_done;\n<line46>}\n<line47>case 0xe1: {\n<line48>if( z[n+1]==0x9a && z[n+2]==0x80 ){\n<line49>n += 3;\n<line50>break;\n<line51>}\n<line52>goto whitespace_done;\n<line53>}\n<line54>case 0xe2: {\n<line55>if( z[n+1]==0x80 ){\n<line56>u8 c = z[n+2];\n<line57>if( c<0x80 ) goto whitespace_done;\n<line58>if( c<=0x8a || c==0xa8 || c==0xa9 || c==0xaf ){\n<line59>n += 3;\n<line60>break;\n<line61>}\n<line62>}else if( z[n+1]==0x81 && z[n+2]==0x9f ){\n<line63>n += 3;\n<line64>break;\n<line65>}\n<line66>goto whitespace_done;\n<line67>}\n<line68>case 0xe3: {\n<line69>if( z[n+1]==0x80 && z[n+2]==0x80 ){\n<line70>n += 3;\n<line71>break;\n<line72>}\n<line73>goto whitespace_done;\n<line74>}\n<line75>case 0xef: {\n<line76>if( z[n+1]==0xbb && z[n+2]==0xbf ){\n<line77>n += 3;\n<line78>break;\n<line79>}\n<line80>goto whitespace_done;\n<line81>}\n<line82>default: {\n<line83>goto whitespace_done;\n<line84>}\n<line85>}\n<line86>}\n<line87>whitespace_done:\n<line88>return n;\n<line89>}
----------------------------------------
Function: jsonWrongNumArgs
Content: <line0>static void jsonWrongNumArgs(\n<line1>sqlite3_context *pCtx,\n<line2>const char *zFuncName\n<line3>){\n<line4>char *zMsg = sqlite3_mprintf("json_%s() needs an odd number of arguments",\n<line5>zFuncName);\n<line6>sqlite3_result_error(pCtx, zMsg, -1);\n<line7>sqlite3_free(zMsg);\n<line8>}
----------------------------------------
Function: jsonBlobExpand
Content: <line0>static int jsonBlobExpand(JsonParse *pParse, u32 N){\n<line1>u8 *aNew;\n<line2>u64 t;\n<line3>assert( N>pParse->nBlobAlloc );\n<line4>if( pParse->nBlobAlloc==0 ){\n<line5>t = 100;\n<line6>}else{\n<line7>t = pParse->nBlobAlloc*2;\n<line8>}\n<line9>if( t<N ) t = N+100;\n<line10>aNew = sqlite3DbRealloc(pParse->db, pParse->aBlob, t);\n<line11>if( aNew==0 ){ pParse->oom = 1; return 1; }\n<line12>assert( t<0x7fffffff );\n<line13>pParse->aBlob = aNew;\n<line14>pParse->nBlobAlloc = (u32)t;\n<line15>return 0;\n<line16>}
----------------------------------------
Function: jsonBlobMakeEditable
Content: <line0>static int jsonBlobMakeEditable(JsonParse *pParse, u32 nExtra){\n<line1>u8 *aOld;\n<line2>u32 nSize;\n<line3>assert( !pParse->bReadOnly );\n<line4>if( pParse->oom ) return 0;\n<line5>if( pParse->nBlobAlloc>0 ) return 1;\n<line6>aOld = pParse->aBlob;\n<line7>nSize = pParse->nBlob + nExtra;\n<line8>pParse->aBlob = 0;\n<line9>if( jsonBlobExpand(pParse, nSize) ){\n<line10>return 0;\n<line11>}\n<line12>assert( pParse->nBlobAlloc >= pParse->nBlob + nExtra );\n<line13>memcpy(pParse->aBlob, aOld, pParse->nBlob);\n<line14>return 1;\n<line15>}
----------------------------------------
Function: jsonBlobExpandAndAppendOneByte
Content: <line0>static SQLITE_NOINLINE void jsonBlobExpandAndAppendOneByte(\n<line1>JsonParse *pParse,\n<line2>u8 c\n<line3>){\n<line4>jsonBlobExpand(pParse, pParse->nBlob+1);\n<line5>if( pParse->oom==0 ){\n<line6>assert( pParse->nBlob+1<=pParse->nBlobAlloc );\n<line7>pParse->aBlob[pParse->nBlob++] = c;\n<line8>}\n<line9>}
----------------------------------------
Function: jsonBlobAppendOneByte
Content: <line0>static void jsonBlobAppendOneByte(JsonParse *pParse, u8 c){\n<line1>if( pParse->nBlob >= pParse->nBlobAlloc ){\n<line2>jsonBlobExpandAndAppendOneByte(pParse, c);\n<line3>}else{\n<line4>pParse->aBlob[pParse->nBlob++] = c;\n<line5>}\n<line6>}
----------------------------------------
Function: jsonBlobExpandAndAppendNode
Content: <line0>static SQLITE_NOINLINE void jsonBlobExpandAndAppendNode(\n<line1>JsonParse *pParse,\n<line2>u8 eType,\n<line3>u32 szPayload,\n<line4>const void *aPayload\n<line5>){\n<line6>if( jsonBlobExpand(pParse, pParse->nBlob+szPayload+9) ) return;\n<line7>jsonBlobAppendNode(pParse, eType, szPayload, aPayload);\n<line8>}
----------------------------------------
Function: jsonBlobAppendNode
Content: <line0>static void jsonBlobAppendNode(\n<line1>JsonParse *pParse,          /* The JsonParse object under construction */\n<line2>u8 eType,                   /* Node type.  One of JSONB_* */\n<line3>u32 szPayload,              /* Number of bytes of payload */\n<line4>const void *aPayload        /* The payload.  Might be NULL */\n<line5>){\n<line6>u8 *a;\n<line7>if( pParse->nBlob+szPayload+9 > pParse->nBlobAlloc ){\n<line8>jsonBlobExpandAndAppendNode(pParse,eType,szPayload,aPayload);\n<line9>return;\n<line10>}\n<line11>assert( pParse->aBlob!=0 );\n<line12>a = &pParse->aBlob[pParse->nBlob];\n<line13>if( szPayload<=11 ){\n<line14>a[0] = eType | (szPayload<<4);\n<line15>pParse->nBlob += 1;\n<line16>}else if( szPayload<=0xff ){\n<line17>a[0] = eType | 0xc0;\n<line18>a[1] = szPayload & 0xff;\n<line19>pParse->nBlob += 2;\n<line20>}else if( szPayload<=0xffff ){\n<line21>a[0] = eType | 0xd0;\n<line22>a[1] = (szPayload >> 8) & 0xff;\n<line23>a[2] = szPayload & 0xff;\n<line24>pParse->nBlob += 3;\n<line25>}else{\n<line26>a[0] = eType | 0xe0;\n<line27>a[1] = (szPayload >> 24) & 0xff;\n<line28>a[2] = (szPayload >> 16) & 0xff;\n<line29>a[3] = (szPayload >> 8) & 0xff;\n<line30>a[4] = szPayload & 0xff;\n<line31>pParse->nBlob += 5;\n<line32>}\n<line33>if( aPayload ){\n<line34>pParse->nBlob += szPayload;\n<line35>memcpy(&pParse->aBlob[pParse->nBlob-szPayload], aPayload, szPayload);\n<line36>}\n<line37>}
----------------------------------------
Function: jsonBlobChangePayloadSize
Content: <line0>static int jsonBlobChangePayloadSize(\n<line1>JsonParse *pParse,\n<line2>u32 i,\n<line3>u32 szPayload\n<line4>){\n<line5>u8 *a;\n<line6>u8 szType;\n<line7>u8 nExtra;\n<line8>u8 nNeeded;\n<line9>int delta;\n<line10>if( pParse->oom ) return 0;\n<line11>a = &pParse->aBlob[i];\n<line12>szType = a[0]>>4;\n<line13>if( szType<=11 ){\n<line14>nExtra = 0;\n<line15>}else if( szType==12 ){\n<line16>nExtra = 1;\n<line17>}else if( szType==13 ){\n<line18>nExtra = 2;\n<line19>}else if( szType==14 ){\n<line20>nExtra = 4;\n<line21>}else{\n<line22>nExtra = 8;\n<line23>}\n<line24>if( szPayload<=11 ){\n<line25>nNeeded = 0;\n<line26>}else if( szPayload<=0xff ){\n<line27>nNeeded = 1;\n<line28>}else if( szPayload<=0xffff ){\n<line29>nNeeded = 2;\n<line30>}else{\n<line31>nNeeded = 4;\n<line32>}\n<line33>delta = nNeeded - nExtra;\n<line34>if( delta ){\n<line35>u32 newSize = pParse->nBlob + delta;\n<line36>if( delta>0 ){\n<line37>if( newSize>pParse->nBlobAlloc && jsonBlobExpand(pParse, newSize) ){\n<line38>return 0;  /* OOM error.  Error state recorded in pParse->oom. */\n<line39>}\n<line40>a = &pParse->aBlob[i];\n<line41>memmove(&a[1+delta], &a[1], pParse->nBlob - (i+1));\n<line42>}else{\n<line43>memmove(&a[1], &a[1-delta], pParse->nBlob - (i+1-delta));\n<line44>}\n<line45>pParse->nBlob = newSize;\n<line46>}\n<line47>if( nNeeded==0 ){\n<line48>a[0] = (a[0] & 0x0f) | (szPayload<<4);\n<line49>}else if( nNeeded==1 ){\n<line50>a[0] = (a[0] & 0x0f) | 0xc0;\n<line51>a[1] = szPayload & 0xff;\n<line52>}else if( nNeeded==2 ){\n<line53>a[0] = (a[0] & 0x0f) | 0xd0;\n<line54>a[1] = (szPayload >> 8) & 0xff;\n<line55>a[2] = szPayload & 0xff;\n<line56>}else{\n<line57>a[0] = (a[0] & 0x0f) | 0xe0;\n<line58>a[1] = (szPayload >> 24) & 0xff;\n<line59>a[2] = (szPayload >> 16) & 0xff;\n<line60>a[3] = (szPayload >> 8) & 0xff;\n<line61>a[4] = szPayload & 0xff;\n<line62>}\n<line63>return delta;\n<line64>}
----------------------------------------
Function: jsonIs4HexB
Content: <line0>static int jsonIs4HexB(const char *z, int *pOp){\n<line1>if( z[0]!='u' ) return 0;\n<line2>if( !jsonIs4Hex(&z[1]) ) return 0;\n<line3>*pOp = JSONB_TEXTJ;\n<line4>return 1;\n<line5>}
----------------------------------------
Function: jsonbValidityCheck
Content: <line0>static u32 jsonbValidityCheck(\n<line1>const JsonParse *pParse,    /* Input JSONB.  Only aBlob and nBlob are used */\n<line2>u32 i,                      /* Start of element as pParse->aBlob[i] */\n<line3>u32 iEnd,                   /* One more than the last byte of the element */\n<line4>u32 iDepth                  /* Current nesting depth */\n<line5>){\n<line6>u32 n, sz, j, k;\n<line7>const u8 *z;\n<line8>u8 x;\n<line9>if( iDepth>JSON_MAX_DEPTH ) return i+1;\n<line10>sz = 0;\n<line11>n = jsonbPayloadSize(pParse, i, &sz);\n<line12>if( NEVER(n==0) ) return i+1;          /* Checked by caller */\n<line13>if( NEVER(i+n+sz!=iEnd) ) return i+1;  /* Checked by caller */\n<line14>z = pParse->aBlob;\n<line15>x = z[i] & 0x0f;\n<line16>switch( x ){\n<line17>case JSONB_NULL:\n<line18>case JSONB_TRUE:\n<line19>case JSONB_FALSE: {\n<line20>return n+sz==1 ? 0 : i+1;\n<line21>}\n<line22>case JSONB_INT: {\n<line23>if( sz<1 ) return i+1;\n<line24>j = i+n;\n<line25>if( z[j]=='-' ){\n<line26>j++;\n<line27>if( sz<2 ) return i+1;\n<line28>}\n<line29>k = i+n+sz;\n<line30>while( j<k ){\n<line31>if( sqlite3Isdigit(z[j]) ){\n<line32>j++;\n<line33>}else{\n<line34>return j+1;\n<line35>}\n<line36>}\n<line37>return 0;\n<line38>}\n<line39>case JSONB_INT5: {\n<line40>if( sz<3 ) return i+1;\n<line41>j = i+n;\n<line42>if( z[j]=='-' ){\n<line43>if( sz<4 ) return i+1;\n<line44>j++;\n<line45>}\n<line46>if( z[j]!='0' ) return i+1;\n<line47>if( z[j+1]!='x' && z[j+1]!='X' ) return j+2;\n<line48>j += 2;\n<line49>k = i+n+sz;\n<line50>while( j<k ){\n<line51>if( sqlite3Isxdigit(z[j]) ){\n<line52>j++;\n<line53>}else{\n<line54>return j+1;\n<line55>}\n<line56>}\n<line57>return 0;\n<line58>}\n<line59>case JSONB_FLOAT:\n<line60>case JSONB_FLOAT5: {\n<line61>u8 seen = 0;   /* 0: initial.  1: '.' seen  2: 'e' seen */\n<line62>if( sz<2 ) return i+1;\n<line63>j = i+n;\n<line64>k = j+sz;\n<line65>if( z[j]=='-' ){\n<line66>j++;\n<line67>if( sz<3 ) return i+1;\n<line68>}\n<line69>if( z[j]=='.' ){\n<line70>if( x==JSONB_FLOAT ) return j+1;\n<line71>if( !sqlite3Isdigit(z[j+1]) ) return j+1;\n<line72>j += 2;\n<line73>seen = 1;\n<line74>}else if( z[j]=='0' && x==JSONB_FLOAT ){\n<line75>if( j+3>k ) return j+1;\n<line76>if( z[j+1]!='.' && z[j+1]!='e' && z[j+1]!='E' ) return j+1;\n<line77>j++;\n<line78>}\n<line79>for(; j<k; j++){\n<line80>if( sqlite3Isdigit(z[j]) ) continue;\n<line81>if( z[j]=='.' ){\n<line82>if( seen>0 ) return j+1;\n<line83>if( x==JSONB_FLOAT && (j==k-1 || !sqlite3Isdigit(z[j+1])) ){\n<line84>return j+1;\n<line85>}\n<line86>seen = 1;\n<line87>continue;\n<line88>}\n<line89>if( z[j]=='e' || z[j]=='E' ){\n<line90>if( seen==2 ) return j+1;\n<line91>if( j==k-1 ) return j+1;\n<line92>if( z[j+1]=='+' || z[j+1]=='-' ){\n<line93>j++;\n<line94>if( j==k-1 ) return j+1;\n<line95>}\n<line96>seen = 2;\n<line97>continue;\n<line98>}\n<line99>return j+1;\n<line100>}\n<line101>if( seen==0 ) return i+1;\n<line102>return 0;\n<line103>}\n<line104>case JSONB_TEXT: {\n<line105>j = i+n;\n<line106>k = j+sz;\n<line107>while( j<k ){\n<line108>if( !jsonIsOk[z[j]] && z[j]!='\'' ) return j+1;\n<line109>j++;\n<line110>}\n<line111>return 0;\n<line112>}\n<line113>case JSONB_TEXTJ:\n<line114>case JSONB_TEXT5: {\n<line115>j = i+n;\n<line116>k = j+sz;\n<line117>while( j<k ){\n<line118>if( !jsonIsOk[z[j]] && z[j]!='\'' ){\n<line119>if( z[j]=='"' ){\n<line120>if( x==JSONB_TEXTJ ) return j+1;\n<line121>}else if( z[j]<=0x1f ){\n<line122>/* Control characters in JSON5 string literals are ok */\n<line123>if( x==JSONB_TEXTJ ) return j+1;\n<line124>}else if( NEVER(z[j]!='\\') || j+1>=k ){\n<line125>return j+1;\n<line126>}else if( strchr("\"\\/bfnrt",z[j+1])!=0 ){\n<line127>j++;\n<line128>}else if( z[j+1]=='u' ){\n<line129>if( j+5>=k ) return j+1;\n<line130>if( !jsonIs4Hex((const char*)&z[j+2]) ) return j+1;\n<line131>j++;\n<line132>}else if( x!=JSONB_TEXT5 ){\n<line133>return j+1;\n<line134>}else{\n<line135>u32 c = 0;\n<line136>u32 szC = jsonUnescapeOneChar((const char*)&z[j], k-j, &c);\n<line137>if( c==JSON_INVALID_CHAR ) return j+1;\n<line138>j += szC - 1;\n<line139>}\n<line140>}\n<line141>j++;\n<line142>}\n<line143>return 0;\n<line144>}\n<line145>case JSONB_TEXTRAW: {\n<line146>return 0;\n<line147>}\n<line148>case JSONB_ARRAY: {\n<line149>u32 sub;\n<line150>j = i+n;\n<line151>k = j+sz;\n<line152>while( j<k ){\n<line153>sz = 0;\n<line154>n = jsonbPayloadSize(pParse, j, &sz);\n<line155>if( n==0 ) return j+1;\n<line156>if( j+n+sz>k ) return j+1;\n<line157>sub = jsonbValidityCheck(pParse, j, j+n+sz, iDepth+1);\n<line158>if( sub ) return sub;\n<line159>j += n + sz;\n<line160>}\n<line161>assert( j==k );\n<line162>return 0;\n<line163>}\n<line164>case JSONB_OBJECT: {\n<line165>u32 cnt = 0;\n<line166>u32 sub;\n<line167>j = i+n;\n<line168>k = j+sz;\n<line169>while( j<k ){\n<line170>sz = 0;\n<line171>n = jsonbPayloadSize(pParse, j, &sz);\n<line172>if( n==0 ) return j+1;\n<line173>if( j+n+sz>k ) return j+1;\n<line174>if( (cnt & 1)==0 ){\n<line175>x = z[j] & 0x0f;\n<line176>if( x<JSONB_TEXT || x>JSONB_TEXTRAW ) return j+1;\n<line177>}\n<line178>sub = jsonbValidityCheck(pParse, j, j+n+sz, iDepth+1);\n<line179>if( sub ) return sub;\n<line180>cnt++;\n<line181>j += n + sz;\n<line182>}\n<line183>assert( j==k );\n<line184>if( (cnt & 1)!=0 ) return j+1;\n<line185>return 0;\n<line186>}\n<line187>default: {\n<line188>return i+1;\n<line189>}\n<line190>}\n<line191>}
----------------------------------------
Function: jsonTranslateTextToBlob
Content: <line0>static int jsonTranslateTextToBlob(JsonParse *pParse, u32 i){\n<line1>char c;\n<line2>u32 j;\n<line3>u32 iThis, iStart;\n<line4>int x;\n<line5>u8 t;\n<line6>const char *z = pParse->zJson;\n<line7>json_parse_restart:\n<line8>switch( (u8)z[i] ){\n<line9>case '{': {\n<line10>/* Parse object */\n<line11>iThis = pParse->nBlob;\n<line12>jsonBlobAppendNode(pParse, JSONB_OBJECT, pParse->nJson-i, 0);\n<line13>if( ++pParse->iDepth > JSON_MAX_DEPTH ){\n<line14>pParse->iErr = i;\n<line15>return -1;\n<line16>}\n<line17>iStart = pParse->nBlob;\n<line18>for(j=i+1;;j++){\n<line19>u32 iBlob = pParse->nBlob;\n<line20>x = jsonTranslateTextToBlob(pParse, j);\n<line21>if( x<=0 ){\n<line22>int op;\n<line23>if( x==(-2) ){\n<line24>j = pParse->iErr;\n<line25>if( pParse->nBlob!=(u32)iStart ) pParse->hasNonstd = 1;\n<line26>break;\n<line27>}\n<line28>j += json5Whitespace(&z[j]);\n<line29>op = JSONB_TEXT;\n<line30>if( sqlite3JsonId1(z[j])\n<line31>|| (z[j]=='\\' && jsonIs4HexB(&z[j+1], &op))\n<line32>){\n<line33>int k = j+1;\n<line34>while( (sqlite3JsonId2(z[k]) && json5Whitespace(&z[k])==0)\n<line35>|| (z[k]=='\\' && jsonIs4HexB(&z[k+1], &op))\n<line36>){\n<line37>k++;\n<line38>}\n<line39>assert( iBlob==pParse->nBlob );\n<line40>jsonBlobAppendNode(pParse, op, k-j, &z[j]);\n<line41>pParse->hasNonstd = 1;\n<line42>x = k;\n<line43>}else{\n<line44>if( x!=-1 ) pParse->iErr = j;\n<line45>return -1;\n<line46>}\n<line47>}\n<line48>if( pParse->oom ) return -1;\n<line49>t = pParse->aBlob[iBlob] & 0x0f;\n<line50>if( t<JSONB_TEXT || t>JSONB_TEXTRAW ){\n<line51>pParse->iErr = j;\n<line52>return -1;\n<line53>}\n<line54>j = x;\n<line55>if( z[j]==':' ){\n<line56>j++;\n<line57>}else{\n<line58>if( jsonIsspace(z[j]) ){\n<line59>/* strspn() is not helpful here */\n<line60>do{ j++; }while( jsonIsspace(z[j]) );\n<line61>if( z[j]==':' ){\n<line62>j++;\n<line63>goto parse_object_value;\n<line64>}\n<line65>}\n<line66>x = jsonTranslateTextToBlob(pParse, j);\n<line67>if( x!=(-5) ){\n<line68>if( x!=(-1) ) pParse->iErr = j;\n<line69>return -1;\n<line70>}\n<line71>j = pParse->iErr+1;\n<line72>}\n<line73>parse_object_value:\n<line74>x = jsonTranslateTextToBlob(pParse, j);\n<line75>if( x<=0 ){\n<line76>if( x!=(-1) ) pParse->iErr = j;\n<line77>return -1;\n<line78>}\n<line79>j = x;\n<line80>if( z[j]==',' ){\n<line81>continue;\n<line82>}else if( z[j]=='}' ){\n<line83>break;\n<line84>}else{\n<line85>if( jsonIsspace(z[j]) ){\n<line86>j += 1 + (u32)strspn(&z[j+1], jsonSpaces);\n<line87>if( z[j]==',' ){\n<line88>continue;\n<line89>}else if( z[j]=='}' ){\n<line90>break;\n<line91>}\n<line92>}\n<line93>x = jsonTranslateTextToBlob(pParse, j);\n<line94>if( x==(-4) ){\n<line95>j = pParse->iErr;\n<line96>continue;\n<line97>}\n<line98>if( x==(-2) ){\n<line99>j = pParse->iErr;\n<line100>break;\n<line101>}\n<line102>}\n<line103>pParse->iErr = j;\n<line104>return -1;\n<line105>}\n<line106>jsonBlobChangePayloadSize(pParse, iThis, pParse->nBlob - iStart);\n<line107>pParse->iDepth--;\n<line108>return j+1;\n<line109>}\n<line110>case '[': {\n<line111>/* Parse array */\n<line112>iThis = pParse->nBlob;\n<line113>assert( i<=(u32)pParse->nJson );\n<line114>jsonBlobAppendNode(pParse, JSONB_ARRAY, pParse->nJson - i, 0);\n<line115>iStart = pParse->nBlob;\n<line116>if( pParse->oom ) return -1;\n<line117>if( ++pParse->iDepth > JSON_MAX_DEPTH ){\n<line118>pParse->iErr = i;\n<line119>return -1;\n<line120>}\n<line121>for(j=i+1;;j++){\n<line122>x = jsonTranslateTextToBlob(pParse, j);\n<line123>if( x<=0 ){\n<line124>if( x==(-3) ){\n<line125>j = pParse->iErr;\n<line126>if( pParse->nBlob!=iStart ) pParse->hasNonstd = 1;\n<line127>break;\n<line128>}\n<line129>if( x!=(-1) ) pParse->iErr = j;\n<line130>return -1;\n<line131>}\n<line132>j = x;\n<line133>if( z[j]==',' ){\n<line134>continue;\n<line135>}else if( z[j]==']' ){\n<line136>break;\n<line137>}else{\n<line138>if( jsonIsspace(z[j]) ){\n<line139>j += 1 + (u32)strspn(&z[j+1], jsonSpaces);\n<line140>if( z[j]==',' ){\n<line141>continue;\n<line142>}else if( z[j]==']' ){\n<line143>break;\n<line144>}\n<line145>}\n<line146>x = jsonTranslateTextToBlob(pParse, j);\n<line147>if( x==(-4) ){\n<line148>j = pParse->iErr;\n<line149>continue;\n<line150>}\n<line151>if( x==(-3) ){\n<line152>j = pParse->iErr;\n<line153>break;\n<line154>}\n<line155>}\n<line156>pParse->iErr = j;\n<line157>return -1;\n<line158>}\n<line159>jsonBlobChangePayloadSize(pParse, iThis, pParse->nBlob - iStart);\n<line160>pParse->iDepth--;\n<line161>return j+1;\n<line162>}\n<line163>case '\'': {\n<line164>u8 opcode;\n<line165>char cDelim;\n<line166>pParse->hasNonstd = 1;\n<line167>opcode = JSONB_TEXT;\n<line168>goto parse_string;\n<line169>case '"':\n<line170>/* Parse string */\n<line171>opcode = JSONB_TEXT;\n<line172>parse_string:\n<line173>cDelim = z[i];\n<line174>j = i+1;\n<line175>while( 1 /*exit-by-break*/ ){\n<line176>if( jsonIsOk[(u8)z[j]] ){\n<line177>if( !jsonIsOk[(u8)z[j+1]] ){\n<line178>j += 1;\n<line179>}else if( !jsonIsOk[(u8)z[j+2]] ){\n<line180>j += 2;\n<line181>}else{\n<line182>j += 3;\n<line183>continue;\n<line184>}\n<line185>}\n<line186>c = z[j];\n<line187>if( c==cDelim ){\n<line188>break;\n<line189>}else if( c=='\\' ){\n<line190>c = z[++j];\n<line191>if( c=='"' || c=='\\' || c=='/' || c=='b' || c=='f'\n<line192>|| c=='n' || c=='r' || c=='t'\n<line193>|| (c=='u' && jsonIs4Hex(&z[j+1])) ){\n<line194>if( opcode==JSONB_TEXT ) opcode = JSONB_TEXTJ;\n<line195>}else if( c=='\'' ||  c=='v' || c=='\n'\n<line196>#ifdef SQLITE_BUG_COMPATIBLE_20250510\n<line197>|| (c=='0')                            /* Legacy bug compatible */\n<line198>#else\n<line199>|| (c=='0' && !sqlite3Isdigit(z[j+1])) /* Correct implementation */\n<line200>#endif\n<line201>|| (0xe2==(u8)c && 0x80==(u8)z[j+1]\n<line202>&& (0xa8==(u8)z[j+2] || 0xa9==(u8)z[j+2]))\n<line203>|| (c=='x' && jsonIs2Hex(&z[j+1])) ){\n<line204>opcode = JSONB_TEXT5;\n<line205>pParse->hasNonstd = 1;\n<line206>}else if( c=='\r' ){\n<line207>if( z[j+1]=='\n' ) j++;\n<line208>opcode = JSONB_TEXT5;\n<line209>pParse->hasNonstd = 1;\n<line210>}else{\n<line211>pParse->iErr = j;\n<line212>return -1;\n<line213>}\n<line214>}else if( c<=0x1f ){\n<line215>if( c==0 ){\n<line216>pParse->iErr = j;\n<line217>return -1;\n<line218>}\n<line219>/* Control characters are not allowed in canonical JSON string\n<line220>** literals, but are allowed in JSON5 string literals. */\n<line221>opcode = JSONB_TEXT5;\n<line222>pParse->hasNonstd = 1;\n<line223>}else if( c=='"' ){\n<line224>opcode = JSONB_TEXT5;\n<line225>}\n<line226>j++;\n<line227>}\n<line228>jsonBlobAppendNode(pParse, opcode, j-1-i, &z[i+1]);\n<line229>return j+1;\n<line230>}\n<line231>case 't': {\n<line232>if( strncmp(z+i,"true",4)==0 && !sqlite3Isalnum(z[i+4]) ){\n<line233>jsonBlobAppendOneByte(pParse, JSONB_TRUE);\n<line234>return i+4;\n<line235>}\n<line236>pParse->iErr = i;\n<line237>return -1;\n<line238>}\n<line239>case 'f': {\n<line240>if( strncmp(z+i,"false",5)==0 && !sqlite3Isalnum(z[i+5]) ){\n<line241>jsonBlobAppendOneByte(pParse, JSONB_FALSE);\n<line242>return i+5;\n<line243>}\n<line244>pParse->iErr = i;\n<line245>return -1;\n<line246>}\n<line247>case '+': {\n<line248>u8 seenE;\n<line249>pParse->hasNonstd = 1;\n<line250>t = 0x00;            /* Bit 0x01:  JSON5.   Bit 0x02:  FLOAT */\n<line251>goto parse_number;\n<line252>case '.':\n<line253>if( sqlite3Isdigit(z[i+1]) ){\n<line254>pParse->hasNonstd = 1;\n<line255>t = 0x03;          /* Bit 0x01:  JSON5.   Bit 0x02:  FLOAT */\n<line256>seenE = 0;\n<line257>goto parse_number_2;\n<line258>}\n<line259>pParse->iErr = i;\n<line260>return -1;\n<line261>case '-':\n<line262>case '0':\n<line263>case '1':\n<line264>case '2':\n<line265>case '3':\n<line266>case '4':\n<line267>case '5':\n<line268>case '6':\n<line269>case '7':\n<line270>case '8':\n<line271>case '9':\n<line272>/* Parse number */\n<line273>t = 0x00;            /* Bit 0x01:  JSON5.   Bit 0x02:  FLOAT */\n<line274>parse_number:\n<line275>seenE = 0;\n<line276>assert( '-' < '0' );\n<line277>assert( '+' < '0' );\n<line278>assert( '.' < '0' );\n<line279>c = z[i];\n<line280>if( c<='0' ){\n<line281>if( c=='0' ){\n<line282>if( (z[i+1]=='x' || z[i+1]=='X') && sqlite3Isxdigit(z[i+2]) ){\n<line283>assert( t==0x00 );\n<line284>pParse->hasNonstd = 1;\n<line285>t = 0x01;\n<line286>for(j=i+3; sqlite3Isxdigit(z[j]); j++){}\n<line287>goto parse_number_finish;\n<line288>}else if( sqlite3Isdigit(z[i+1]) ){\n<line289>pParse->iErr = i+1;\n<line290>return -1;\n<line291>}\n<line292>}else{\n<line293>if( !sqlite3Isdigit(z[i+1]) ){\n<line294>/* JSON5 allows for "+Infinity" and "-Infinity" using exactly\n<line295>** that case.  SQLite also allows these in any case and it allows\n<line296>** "+inf" and "-inf". */\n<line297>if( (z[i+1]=='I' || z[i+1]=='i')\n<line298>&& sqlite3StrNICmp(&z[i+1], "inf",3)==0\n<line299>){\n<line300>pParse->hasNonstd = 1;\n<line301>if( z[i]=='-' ){\n<line302>jsonBlobAppendNode(pParse, JSONB_FLOAT, 6, "-9e999");\n<line303>}else{\n<line304>jsonBlobAppendNode(pParse, JSONB_FLOAT, 5, "9e999");\n<line305>}\n<line306>return i + (sqlite3StrNICmp(&z[i+4],"inity",5)==0 ? 9 : 4);\n<line307>}\n<line308>if( z[i+1]=='.' ){\n<line309>pParse->hasNonstd = 1;\n<line310>t |= 0x01;\n<line311>goto parse_number_2;\n<line312>}\n<line313>pParse->iErr = i;\n<line314>return -1;\n<line315>}\n<line316>if( z[i+1]=='0' ){\n<line317>if( sqlite3Isdigit(z[i+2]) ){\n<line318>pParse->iErr = i+1;\n<line319>return -1;\n<line320>}else if( (z[i+2]=='x' || z[i+2]=='X') && sqlite3Isxdigit(z[i+3]) ){\n<line321>pParse->hasNonstd = 1;\n<line322>t |= 0x01;\n<line323>for(j=i+4; sqlite3Isxdigit(z[j]); j++){}\n<line324>goto parse_number_finish;\n<line325>}\n<line326>}\n<line327>}\n<line328>}\n<line329>parse_number_2:\n<line330>for(j=i+1;; j++){\n<line331>c = z[j];\n<line332>if( sqlite3Isdigit(c) ) continue;\n<line333>if( c=='.' ){\n<line334>if( (t & 0x02)!=0 ){\n<line335>pParse->iErr = j;\n<line336>return -1;\n<line337>}\n<line338>t |= 0x02;\n<line339>continue;\n<line340>}\n<line341>if( c=='e' || c=='E' ){\n<line342>if( z[j-1]<'0' ){\n<line343>if( ALWAYS(z[j-1]=='.') && ALWAYS(j-2>=i) && sqlite3Isdigit(z[j-2]) ){\n<line344>pParse->hasNonstd = 1;\n<line345>t |= 0x01;\n<line346>}else{\n<line347>pParse->iErr = j;\n<line348>return -1;\n<line349>}\n<line350>}\n<line351>if( seenE ){\n<line352>pParse->iErr = j;\n<line353>return -1;\n<line354>}\n<line355>t |= 0x02;\n<line356>seenE = 1;\n<line357>c = z[j+1];\n<line358>if( c=='+' || c=='-' ){\n<line359>j++;\n<line360>c = z[j+1];\n<line361>}\n<line362>if( c<'0' || c>'9' ){\n<line363>pParse->iErr = j;\n<line364>return -1;\n<line365>}\n<line366>continue;\n<line367>}\n<line368>break;\n<line369>}\n<line370>if( z[j-1]<'0' ){\n<line371>if( ALWAYS(z[j-1]=='.') && ALWAYS(j-2>=i) && sqlite3Isdigit(z[j-2]) ){\n<line372>pParse->hasNonstd = 1;\n<line373>t |= 0x01;\n<line374>}else{\n<line375>pParse->iErr = j;\n<line376>return -1;\n<line377>}\n<line378>}\n<line379>parse_number_finish:\n<line380>assert( JSONB_INT+0x01==JSONB_INT5 );\n<line381>assert( JSONB_FLOAT+0x01==JSONB_FLOAT5 );\n<line382>assert( JSONB_INT+0x02==JSONB_FLOAT );\n<line383>if( z[i]=='+' ) i++;\n<line384>jsonBlobAppendNode(pParse, JSONB_INT+t, j-i, &z[i]);\n<line385>return j;\n<line386>}\n<line387>case '}': {\n<line388>pParse->iErr = i;\n<line389>return -2;  /* End of {...} */\n<line390>}\n<line391>case ']': {\n<line392>pParse->iErr = i;\n<line393>return -3;  /* End of [...] */\n<line394>}\n<line395>case ',': {\n<line396>pParse->iErr = i;\n<line397>return -4;  /* List separator */\n<line398>}\n<line399>case ':': {\n<line400>pParse->iErr = i;\n<line401>return -5;  /* Object label/value separator */\n<line402>}\n<line403>case 0: {\n<line404>return 0;   /* End of file */\n<line405>}\n<line406>case 0x09:\n<line407>case 0x0a:\n<line408>case 0x0d:\n<line409>case 0x20: {\n<line410>i += 1 + (u32)strspn(&z[i+1], jsonSpaces);\n<line411>goto json_parse_restart;\n<line412>}\n<line413>case 0x0b:\n<line414>case 0x0c:\n<line415>case '/':\n<line416>case 0xc2:\n<line417>case 0xe1:\n<line418>case 0xe2:\n<line419>case 0xe3:\n<line420>case 0xef: {\n<line421>j = json5Whitespace(&z[i]);\n<line422>if( j>0 ){\n<line423>i += j;\n<line424>pParse->hasNonstd = 1;\n<line425>goto json_parse_restart;\n<line426>}\n<line427>pParse->iErr = i;\n<line428>return -1;\n<line429>}\n<line430>case 'n': {\n<line431>if( strncmp(z+i,"null",4)==0 && !sqlite3Isalnum(z[i+4]) ){\n<line432>jsonBlobAppendOneByte(pParse, JSONB_NULL);\n<line433>return i+4;\n<line434>}\n<line435>/* fall-through into the default case that checks for NaN */\n<line436>/* no break */ deliberate_fall_through\n<line437>}\n<line438>default: {\n<line439>u32 k;\n<line440>int nn;\n<line441>c = z[i];\n<line442>for(k=0; k<sizeof(aNanInfName)/sizeof(aNanInfName[0]); k++){\n<line443>if( c!=aNanInfName[k].c1 && c!=aNanInfName[k].c2 ) continue;\n<line444>nn = aNanInfName[k].n;\n<line445>if( sqlite3StrNICmp(&z[i], aNanInfName[k].zMatch, nn)!=0 ){\n<line446>continue;\n<line447>}\n<line448>if( sqlite3Isalnum(z[i+nn]) ) continue;\n<line449>if( aNanInfName[k].eType==JSONB_FLOAT ){\n<line450>jsonBlobAppendNode(pParse, JSONB_FLOAT, 5, "9e999");\n<line451>}else{\n<line452>jsonBlobAppendOneByte(pParse, JSONB_NULL);\n<line453>}\n<line454>pParse->hasNonstd = 1;\n<line455>return i + nn;\n<line456>}\n<line457>pParse->iErr = i;\n<line458>return -1;  /* Syntax error */\n<line459>}\n<line460>} /* End switch(z[i]) */\n<line461>}
----------------------------------------
Function: jsonConvertTextToBlob
Content: <line0>static int jsonConvertTextToBlob(\n<line1>JsonParse *pParse,           /* Initialize and fill this JsonParse object */\n<line2>sqlite3_context *pCtx        /* Report errors here */\n<line3>){\n<line4>int i;\n<line5>const char *zJson = pParse->zJson;\n<line6>i = jsonTranslateTextToBlob(pParse, 0);\n<line7>if( pParse->oom ) i = -1;\n<line8>if( i>0 ){\n<line9>#ifdef SQLITE_DEBUG\n<line10>assert( pParse->iDepth==0 );\n<line11>if( sqlite3Config.bJsonSelfcheck ){\n<line12>assert( jsonbValidityCheck(pParse, 0, pParse->nBlob, 0)==0 );\n<line13>}\n<line14>#endif\n<line15>while( jsonIsspace(zJson[i]) ) i++;\n<line16>if( zJson[i] ){\n<line17>i += json5Whitespace(&zJson[i]);\n<line18>if( zJson[i] ){\n<line19>if( pCtx ) sqlite3_result_error(pCtx, "malformed JSON", -1);\n<line20>jsonParseReset(pParse);\n<line21>return 1;\n<line22>}\n<line23>pParse->hasNonstd = 1;\n<line24>}\n<line25>}\n<line26>if( i<=0 ){\n<line27>if( pCtx!=0 ){\n<line28>if( pParse->oom ){\n<line29>sqlite3_result_error_nomem(pCtx);\n<line30>}else{\n<line31>sqlite3_result_error(pCtx, "malformed JSON", -1);\n<line32>}\n<line33>}\n<line34>jsonParseReset(pParse);\n<line35>return 1;\n<line36>}\n<line37>return 0;\n<line38>}
----------------------------------------
Function: jsonReturnStringAsBlob
Content: <line0>static void jsonReturnStringAsBlob(JsonString *pStr){\n<line1>JsonParse px;\n<line2>memset(&px, 0, sizeof(px));\n<line3>jsonStringTerminate(pStr);\n<line4>if( pStr->eErr ){\n<line5>sqlite3_result_error_nomem(pStr->pCtx);\n<line6>return;\n<line7>}\n<line8>px.zJson = pStr->zBuf;\n<line9>px.nJson = pStr->nUsed;\n<line10>px.db = sqlite3_context_db_handle(pStr->pCtx);\n<line11>(void)jsonTranslateTextToBlob(&px, 0);\n<line12>if( px.oom ){\n<line13>sqlite3DbFree(px.db, px.aBlob);\n<line14>sqlite3_result_error_nomem(pStr->pCtx);\n<line15>}else{\n<line16>assert( px.nBlobAlloc>0 );\n<line17>assert( !px.bReadOnly );\n<line18>sqlite3_result_blob(pStr->pCtx, px.aBlob, px.nBlob, SQLITE_DYNAMIC);\n<line19>}\n<line20>}
----------------------------------------
Function: jsonbPayloadSize
Content: <line0>static u32 jsonbPayloadSize(const JsonParse *pParse, u32 i, u32 *pSz){\n<line1>u8 x;\n<line2>u32 sz;\n<line3>u32 n;\n<line4>assert( i<=pParse->nBlob );\n<line5>x = pParse->aBlob[i]>>4;\n<line6>if( x<=11 ){\n<line7>sz = x;\n<line8>n = 1;\n<line9>}else if( x==12 ){\n<line10>if( i+1>=pParse->nBlob ){\n<line11>*pSz = 0;\n<line12>return 0;\n<line13>}\n<line14>sz = pParse->aBlob[i+1];\n<line15>n = 2;\n<line16>}else if( x==13 ){\n<line17>if( i+2>=pParse->nBlob ){\n<line18>*pSz = 0;\n<line19>return 0;\n<line20>}\n<line21>sz = (pParse->aBlob[i+1]<<8) + pParse->aBlob[i+2];\n<line22>n = 3;\n<line23>}else if( x==14 ){\n<line24>if( i+4>=pParse->nBlob ){\n<line25>*pSz = 0;\n<line26>return 0;\n<line27>}\n<line28>sz = ((u32)pParse->aBlob[i+1]<<24) + (pParse->aBlob[i+2]<<16) +\n<line29>(pParse->aBlob[i+3]<<8) + pParse->aBlob[i+4];\n<line30>n = 5;\n<line31>}else{\n<line32>if( i+8>=pParse->nBlob\n<line33>|| pParse->aBlob[i+1]!=0\n<line34>|| pParse->aBlob[i+2]!=0\n<line35>|| pParse->aBlob[i+3]!=0\n<line36>|| pParse->aBlob[i+4]!=0\n<line37>){\n<line38>*pSz = 0;\n<line39>return 0;\n<line40>}\n<line41>sz = ((u32)pParse->aBlob[i+5]<<24) + (pParse->aBlob[i+6]<<16) +\n<line42>(pParse->aBlob[i+7]<<8) + pParse->aBlob[i+8];\n<line43>n = 9;\n<line44>}\n<line45>if( (i64)i+sz+n > pParse->nBlob\n<line46>&& (i64)i+sz+n > pParse->nBlob-pParse->delta\n<line47>){\n<line48>*pSz = 0;\n<line49>return 0;\n<line50>}\n<line51>*pSz = sz;\n<line52>return n;\n<line53>}
----------------------------------------
Function: jsonTranslateBlobToText
Content: <line0>static u32 jsonTranslateBlobToText(\n<line1>const JsonParse *pParse,       /* the complete parse of the JSON */\n<line2>u32 i,                         /* Start rendering at this index */\n<line3>JsonString *pOut               /* Write JSON here */\n<line4>){\n<line5>u32 sz, n, j, iEnd;\n<line6>n = jsonbPayloadSize(pParse, i, &sz);\n<line7>if( n==0 ){\n<line8>pOut->eErr |= JSTRING_MALFORMED;\n<line9>return pParse->nBlob+1;\n<line10>}\n<line11>switch( pParse->aBlob[i] & 0x0f ){\n<line12>case JSONB_NULL: {\n<line13>jsonAppendRawNZ(pOut, "null", 4);\n<line14>return i+1;\n<line15>}\n<line16>case JSONB_TRUE: {\n<line17>jsonAppendRawNZ(pOut, "true", 4);\n<line18>return i+1;\n<line19>}\n<line20>case JSONB_FALSE: {\n<line21>jsonAppendRawNZ(pOut, "false", 5);\n<line22>return i+1;\n<line23>}\n<line24>case JSONB_INT:\n<line25>case JSONB_FLOAT: {\n<line26>if( sz==0 ) goto malformed_jsonb;\n<line27>jsonAppendRaw(pOut, (const char*)&pParse->aBlob[i+n], sz);\n<line28>break;\n<line29>}\n<line30>case JSONB_INT5: {  /* Integer literal in hexadecimal notation */\n<line31>u32 k = 2;\n<line32>sqlite3_uint64 u = 0;\n<line33>const char *zIn = (const char*)&pParse->aBlob[i+n];\n<line34>int bOverflow = 0;\n<line35>if( sz==0 ) goto malformed_jsonb;\n<line36>if( zIn[0]=='-' ){\n<line37>jsonAppendChar(pOut, '-');\n<line38>k++;\n<line39>}else if( zIn[0]=='+' ){\n<line40>k++;\n<line41>}\n<line42>for(; k<sz; k++){\n<line43>if( !sqlite3Isxdigit(zIn[k]) ){\n<line44>pOut->eErr |= JSTRING_MALFORMED;\n<line45>break;\n<line46>}else if( (u>>60)!=0 ){\n<line47>bOverflow = 1;\n<line48>}else{\n<line49>u = u*16 + sqlite3HexToInt(zIn[k]);\n<line50>}\n<line51>}\n<line52>jsonPrintf(100,pOut,bOverflow?"9.0e999":"%llu", u);\n<line53>break;\n<line54>}\n<line55>case JSONB_FLOAT5: { /* Float literal missing digits beside "." */\n<line56>u32 k = 0;\n<line57>const char *zIn = (const char*)&pParse->aBlob[i+n];\n<line58>if( sz==0 ) goto malformed_jsonb;\n<line59>if( zIn[0]=='-' ){\n<line60>jsonAppendChar(pOut, '-');\n<line61>k++;\n<line62>}\n<line63>if( zIn[k]=='.' ){\n<line64>jsonAppendChar(pOut, '0');\n<line65>}\n<line66>for(; k<sz; k++){\n<line67>jsonAppendChar(pOut, zIn[k]);\n<line68>if( zIn[k]=='.' && (k+1==sz || !sqlite3Isdigit(zIn[k+1])) ){\n<line69>jsonAppendChar(pOut, '0');\n<line70>}\n<line71>}\n<line72>break;\n<line73>}\n<line74>case JSONB_TEXT:\n<line75>case JSONB_TEXTJ: {\n<line76>if( pOut->nUsed+sz+2<=pOut->nAlloc || jsonStringGrow(pOut, sz+2)==0 ){\n<line77>pOut->zBuf[pOut->nUsed] = '"';\n<line78>memcpy(pOut->zBuf+pOut->nUsed+1,(const char*)&pParse->aBlob[i+n],sz);\n<line79>pOut->zBuf[pOut->nUsed+sz+1] = '"';\n<line80>pOut->nUsed += sz+2;\n<line81>}\n<line82>break;\n<line83>}\n<line84>case JSONB_TEXT5: {\n<line85>const char *zIn;\n<line86>u32 k;\n<line87>u32 sz2 = sz;\n<line88>zIn = (const char*)&pParse->aBlob[i+n];\n<line89>jsonAppendChar(pOut, '"');\n<line90>while( sz2>0 ){\n<line91>for(k=0; k<sz2 && (jsonIsOk[(u8)zIn[k]] || zIn[k]=='\''); k++){}\n<line92>if( k>0 ){\n<line93>jsonAppendRawNZ(pOut, zIn, k);\n<line94>if( k>=sz2 ){\n<line95>break;\n<line96>}\n<line97>zIn += k;\n<line98>sz2 -= k;\n<line99>}\n<line100>if( zIn[0]=='"' ){\n<line101>jsonAppendRawNZ(pOut, "\\\"", 2);\n<line102>zIn++;\n<line103>sz2--;\n<line104>continue;\n<line105>}\n<line106>if( zIn[0]<=0x1f ){\n<line107>if( pOut->nUsed+7>pOut->nAlloc && jsonStringGrow(pOut,7) ) break;\n<line108>jsonAppendControlChar(pOut, zIn[0]);\n<line109>zIn++;\n<line110>sz2--;\n<line111>continue;\n<line112>}\n<line113>assert( zIn[0]=='\\' );\n<line114>assert( sz2>=1 );\n<line115>if( sz2<2 ){\n<line116>pOut->eErr |= JSTRING_MALFORMED;\n<line117>break;\n<line118>}\n<line119>switch( (u8)zIn[1] ){\n<line120>case '\'':\n<line121>jsonAppendChar(pOut, '\'');\n<line122>break;\n<line123>case 'v':\n<line124>jsonAppendRawNZ(pOut, "\\u000b", 6);\n<line125>break;\n<line126>case 'x':\n<line127>if( sz2<4 ){\n<line128>pOut->eErr |= JSTRING_MALFORMED;\n<line129>sz2 = 2;\n<line130>break;\n<line131>}\n<line132>jsonAppendRawNZ(pOut, "\\u00", 4);\n<line133>jsonAppendRawNZ(pOut, &zIn[2], 2);\n<line134>zIn += 2;\n<line135>sz2 -= 2;\n<line136>break;\n<line137>case '0':\n<line138>jsonAppendRawNZ(pOut, "\\u0000", 6);\n<line139>break;\n<line140>case '\r':\n<line141>if( sz2>2 && zIn[2]=='\n' ){\n<line142>zIn++;\n<line143>sz2--;\n<line144>}\n<line145>break;\n<line146>case '\n':\n<line147>break;\n<line148>case 0xe2:\n<line149>/* '\' followed by either U+2028 or U+2029 is ignored as\n<line150>** whitespace.  Not that in UTF8, U+2028 is 0xe2 0x80 0x29.\n<line151>** U+2029 is the same except for the last byte */\n<line152>if( sz2<4\n<line153>|| 0x80!=(u8)zIn[2]\n<line154>|| (0xa8!=(u8)zIn[3] && 0xa9!=(u8)zIn[3])\n<line155>){\n<line156>pOut->eErr |= JSTRING_MALFORMED;\n<line157>sz2 = 2;\n<line158>break;\n<line159>}\n<line160>zIn += 2;\n<line161>sz2 -= 2;\n<line162>break;\n<line163>default:\n<line164>jsonAppendRawNZ(pOut, zIn, 2);\n<line165>break;\n<line166>}\n<line167>assert( sz2>=2 );\n<line168>zIn += 2;\n<line169>sz2 -= 2;\n<line170>}\n<line171>jsonAppendChar(pOut, '"');\n<line172>break;\n<line173>}\n<line174>case JSONB_TEXTRAW: {\n<line175>jsonAppendString(pOut, (const char*)&pParse->aBlob[i+n], sz);\n<line176>break;\n<line177>}\n<line178>case JSONB_ARRAY: {\n<line179>jsonAppendChar(pOut, '[');\n<line180>j = i+n;\n<line181>iEnd = j+sz;\n<line182>while( j<iEnd && pOut->eErr==0 ){\n<line183>j = jsonTranslateBlobToText(pParse, j, pOut);\n<line184>jsonAppendChar(pOut, ',');\n<line185>}\n<line186>if( j>iEnd ) pOut->eErr |= JSTRING_MALFORMED;\n<line187>if( sz>0 ) jsonStringTrimOneChar(pOut);\n<line188>jsonAppendChar(pOut, ']');\n<line189>break;\n<line190>}\n<line191>case JSONB_OBJECT: {\n<line192>int x = 0;\n<line193>jsonAppendChar(pOut, '{');\n<line194>j = i+n;\n<line195>iEnd = j+sz;\n<line196>while( j<iEnd && pOut->eErr==0 ){\n<line197>j = jsonTranslateBlobToText(pParse, j, pOut);\n<line198>jsonAppendChar(pOut, (x++ & 1) ? ',' : ':');\n<line199>}\n<line200>if( (x & 1)!=0 || j>iEnd ) pOut->eErr |= JSTRING_MALFORMED;\n<line201>if( sz>0 ) jsonStringTrimOneChar(pOut);\n<line202>jsonAppendChar(pOut, '}');\n<line203>break;\n<line204>}\n<line205>default: {\n<line206>malformed_jsonb:\n<line207>pOut->eErr |= JSTRING_MALFORMED;\n<line208>break;\n<line209>}\n<line210>}\n<line211>return i+n+sz;\n<line212>}
----------------------------------------
Function: jsonPrettyIndent
Content: <line0>static void jsonPrettyIndent(JsonPretty *pPretty){\n<line1>u32 jj;\n<line2>for(jj=0; jj<pPretty->nIndent; jj++){\n<line3>jsonAppendRaw(pPretty->pOut, pPretty->zIndent, pPretty->szIndent);\n<line4>}\n<line5>}
----------------------------------------
Function: jsonTranslateBlobToPrettyText
Content: <line0>static u32 jsonTranslateBlobToPrettyText(\n<line1>JsonPretty *pPretty,       /* Pretty-printing context */\n<line2>u32 i                      /* Start rendering at this index */\n<line3>){\n<line4>u32 sz, n, j, iEnd;\n<line5>const JsonParse *pParse = pPretty->pParse;\n<line6>JsonString *pOut = pPretty->pOut;\n<line7>n = jsonbPayloadSize(pParse, i, &sz);\n<line8>if( n==0 ){\n<line9>pOut->eErr |= JSTRING_MALFORMED;\n<line10>return pParse->nBlob+1;\n<line11>}\n<line12>switch( pParse->aBlob[i] & 0x0f ){\n<line13>case JSONB_ARRAY: {\n<line14>j = i+n;\n<line15>iEnd = j+sz;\n<line16>jsonAppendChar(pOut, '[');\n<line17>if( j<iEnd ){\n<line18>jsonAppendChar(pOut, '\n');\n<line19>pPretty->nIndent++;\n<line20>while( pOut->eErr==0 ){\n<line21>jsonPrettyIndent(pPretty);\n<line22>j = jsonTranslateBlobToPrettyText(pPretty, j);\n<line23>if( j>=iEnd ) break;\n<line24>jsonAppendRawNZ(pOut, ",\n", 2);\n<line25>}\n<line26>jsonAppendChar(pOut, '\n');\n<line27>pPretty->nIndent--;\n<line28>jsonPrettyIndent(pPretty);\n<line29>}\n<line30>jsonAppendChar(pOut, ']');\n<line31>i = iEnd;\n<line32>break;\n<line33>}\n<line34>case JSONB_OBJECT: {\n<line35>j = i+n;\n<line36>iEnd = j+sz;\n<line37>jsonAppendChar(pOut, '{');\n<line38>if( j<iEnd ){\n<line39>jsonAppendChar(pOut, '\n');\n<line40>pPretty->nIndent++;\n<line41>while( pOut->eErr==0 ){\n<line42>jsonPrettyIndent(pPretty);\n<line43>j = jsonTranslateBlobToText(pParse, j, pOut);\n<line44>if( j>iEnd ){\n<line45>pOut->eErr |= JSTRING_MALFORMED;\n<line46>break;\n<line47>}\n<line48>jsonAppendRawNZ(pOut, ": ", 2);\n<line49>j = jsonTranslateBlobToPrettyText(pPretty, j);\n<line50>if( j>=iEnd ) break;\n<line51>jsonAppendRawNZ(pOut, ",\n", 2);\n<line52>}\n<line53>jsonAppendChar(pOut, '\n');\n<line54>pPretty->nIndent--;\n<line55>jsonPrettyIndent(pPretty);\n<line56>}\n<line57>jsonAppendChar(pOut, '}');\n<line58>i = iEnd;\n<line59>break;\n<line60>}\n<line61>default: {\n<line62>i = jsonTranslateBlobToText(pParse, i, pOut);\n<line63>break;\n<line64>}\n<line65>}\n<line66>return i;\n<line67>}
----------------------------------------
Function: jsonbArrayCount
Content: <line0>static u32 jsonbArrayCount(JsonParse *pParse, u32 iRoot){\n<line1>u32 n, sz, i, iEnd;\n<line2>u32 k = 0;\n<line3>n = jsonbPayloadSize(pParse, iRoot, &sz);\n<line4>iEnd = iRoot+n+sz;\n<line5>for(i=iRoot+n; n>0 && i<iEnd; i+=sz+n, k++){\n<line6>n = jsonbPayloadSize(pParse, i, &sz);\n<line7>}\n<line8>return k;\n<line9>}
----------------------------------------
Function: jsonAfterEditSizeAdjust
Content: <line0>static void jsonAfterEditSizeAdjust(JsonParse *pParse, u32 iRoot){\n<line1>u32 sz = 0;\n<line2>u32 nBlob;\n<line3>assert( pParse->delta!=0 );\n<line4>assert( pParse->nBlobAlloc >= pParse->nBlob );\n<line5>nBlob = pParse->nBlob;\n<line6>pParse->nBlob = pParse->nBlobAlloc;\n<line7>(void)jsonbPayloadSize(pParse, iRoot, &sz);\n<line8>pParse->nBlob = nBlob;\n<line9>sz += pParse->delta;\n<line10>pParse->delta += jsonBlobChangePayloadSize(pParse, iRoot, sz);\n<line11>}
----------------------------------------
Function: jsonBlobOverwrite
Content: <line0>static int jsonBlobOverwrite(\n<line1>u8 *aOut,                 /* Overwrite here */\n<line2>const u8 *aIns,           /* New content */\n<line3>u32 nIns,                 /* Bytes of new content */\n<line4>u32 d                     /* Need to expand new content by this much */\n<line5>){\n<line6>u32 szPayload;       /* Bytes of payload */\n<line7>u32 i;               /* New header size, after expansion & a loop counter */\n<line8>u8 szHdr;            /* Size of header before expansion */\n<line9>/* Lookup table for finding the upper 4 bits of the first byte of the\n<line10>** expanded aIns[], based on the size of the expanded aIns[] header:\n<line11>**\n<line12>**                             2     3  4     5  6  7  8     9 */\n<line13>static const u8 aType[] = { 0xc0, 0xd0, 0, 0xe0, 0, 0, 0, 0xf0 };\n<line14>if( (aIns[0]&0x0f)<=2 ) return 0;    /* Cannot enlarge NULL, true, false */\n<line15>switch( aIns[0]>>4 ){\n<line16>default: {                         /* aIns[] header size 1 */\n<line17>if( ((1<<d)&0x116)==0 ) return 0;  /* d must be 1, 2, 4, or 8 */\n<line18>i = d + 1;                         /* New hdr sz: 2, 3, 5, or 9 */\n<line19>szHdr = 1;\n<line20>break;\n<line21>}\n<line22>case 12: {                         /* aIns[] header size is 2 */\n<line23>if( ((1<<d)&0x8a)==0) return 0;    /* d must be 1, 3, or 7 */\n<line24>i = d + 2;                         /* New hdr sz: 2, 5, or 9 */\n<line25>szHdr = 2;\n<line26>break;\n<line27>}\n<line28>case 13: {                         /* aIns[] header size is 3 */\n<line29>if( d!=2 && d!=6 ) return 0;       /* d must be 2 or 6 */\n<line30>i = d + 3;                         /* New hdr sz: 5 or 9 */\n<line31>szHdr = 3;\n<line32>break;\n<line33>}\n<line34>case 14: {                         /* aIns[] header size is 5 */\n<line35>if( d!=4 ) return 0;               /* d must be 4 */\n<line36>i = 9;                             /* New hdr sz: 9 */\n<line37>szHdr = 5;\n<line38>break;\n<line39>}\n<line40>case 15: {                         /* aIns[] header size is 9 */\n<line41>return 0;                          /* No solution */\n<line42>}\n<line43>}\n<line44>assert( i>=2 && i<=9 && aType[i-2]!=0 );\n<line45>aOut[0] = (aIns[0] & 0x0f) | aType[i-2];\n<line46>memcpy(&aOut[i], &aIns[szHdr], nIns-szHdr);\n<line47>szPayload = nIns - szHdr;\n<line48>while( 1/*edit-by-break*/ ){\n<line49>i--;\n<line50>aOut[i] = szPayload & 0xff;\n<line51>if( i==1 ) break;\n<line52>szPayload >>= 8;\n<line53>}\n<line54>assert( (szPayload>>8)==0 );\n<line55>return 1;\n<line56>}
----------------------------------------
Function: jsonBlobEdit
Content: <line0>static void jsonBlobEdit(\n<line1>JsonParse *pParse,     /* The JSONB to be modified is in pParse->aBlob */\n<line2>u32 iDel,              /* First byte to be removed */\n<line3>u32 nDel,              /* Number of bytes to remove */\n<line4>const u8 *aIns,        /* Content to insert */\n<line5>u32 nIns               /* Bytes of content to insert */\n<line6>){\n<line7>i64 d = (i64)nIns - (i64)nDel;\n<line8>if( d<0 && d>=(-8) && aIns!=0\n<line9>&& jsonBlobOverwrite(&pParse->aBlob[iDel], aIns, nIns, (int)-d)\n<line10>){\n<line11>return;\n<line12>}\n<line13>if( d!=0 ){\n<line14>if( pParse->nBlob + d > pParse->nBlobAlloc ){\n<line15>jsonBlobExpand(pParse, pParse->nBlob+d);\n<line16>if( pParse->oom ) return;\n<line17>}\n<line18>memmove(&pParse->aBlob[iDel+nIns],\n<line19>&pParse->aBlob[iDel+nDel],\n<line20>pParse->nBlob - (iDel+nDel));\n<line21>pParse->nBlob += d;\n<line22>pParse->delta += d;\n<line23>}\n<line24>if( nIns && aIns ){\n<line25>memcpy(&pParse->aBlob[iDel], aIns, nIns);\n<line26>}\n<line27>}
----------------------------------------
Function: jsonBytesToBypass
Content: <line0>static u32 jsonBytesToBypass(const char *z, u32 n){\n<line1>u32 i = 0;\n<line2>while( i+1<n ){\n<line3>if( z[i]!='\\' ) return i;\n<line4>if( z[i+1]=='\n' ){\n<line5>i += 2;\n<line6>continue;\n<line7>}\n<line8>if( z[i+1]=='\r' ){\n<line9>if( i+2<n && z[i+2]=='\n' ){\n<line10>i += 3;\n<line11>}else{\n<line12>i += 2;\n<line13>}\n<line14>continue;\n<line15>}\n<line16>if( 0xe2==(u8)z[i+1]\n<line17>&& i+3<n\n<line18>&& 0x80==(u8)z[i+2]\n<line19>&& (0xa8==(u8)z[i+3] || 0xa9==(u8)z[i+3])\n<line20>){\n<line21>i += 4;\n<line22>continue;\n<line23>}\n<line24>break;\n<line25>}\n<line26>return i;\n<line27>}
----------------------------------------
Function: jsonUnescapeOneChar
Content: <line0>static u32 jsonUnescapeOneChar(const char *z, u32 n, u32 *piOut){\n<line1>assert( n>0 );\n<line2>assert( z[0]=='\\' );\n<line3>if( n<2 ){\n<line4>*piOut = JSON_INVALID_CHAR;\n<line5>return n;\n<line6>}\n<line7>switch( (u8)z[1] ){\n<line8>case 'u': {\n<line9>u32 v, vlo;\n<line10>if( n<6 ){\n<line11>*piOut = JSON_INVALID_CHAR;\n<line12>return n;\n<line13>}\n<line14>v = jsonHexToInt4(&z[2]);\n<line15>if( (v & 0xfc00)==0xd800\n<line16>&& n>=12\n<line17>&& z[6]=='\\'\n<line18>&& z[7]=='u'\n<line19>&& ((vlo = jsonHexToInt4(&z[8]))&0xfc00)==0xdc00\n<line20>){\n<line21>*piOut = ((v&0x3ff)<<10) + (vlo&0x3ff) + 0x10000;\n<line22>return 12;\n<line23>}else{\n<line24>*piOut = v;\n<line25>return 6;\n<line26>}\n<line27>}\n<line28>case 'b': {   *piOut = '\b';  return 2; }\n<line29>case 'f': {   *piOut = '\f';  return 2; }\n<line30>case 'n': {   *piOut = '\n';  return 2; }\n<line31>case 'r': {   *piOut = '\r';  return 2; }\n<line32>case 't': {   *piOut = '\t';  return 2; }\n<line33>case 'v': {   *piOut = '\v';  return 2; }\n<line34>case '0': {\n<line35>/* JSON5 requires that the \0 escape not be followed by a digit.\n<line36>** But SQLite did not enforce this restriction in versions 3.42.0\n<line37>** through 3.49.2.  That was a bug.  But some applications might have\n<line38>** come to depend on that bug.  Use the SQLITE_BUG_COMPATIBLE_20250510\n<line39>** option to restore the old buggy behavior. */\n<line40>#ifdef SQLITE_BUG_COMPATIBLE_20250510\n<line41>/* Legacy bug-compatible behavior */\n<line42>*piOut = 0;\n<line43>#else\n<line44>/* Correct behavior */\n<line45>*piOut = (n>2 && sqlite3Isdigit(z[2])) ? JSON_INVALID_CHAR : 0;\n<line46>#endif\n<line47>return 2;\n<line48>}\n<line49>case '\'':\n<line50>case '"':\n<line51>case '/':\n<line52>case '\\':{   *piOut = z[1];  return 2; }\n<line53>case 'x': {\n<line54>if( n<4 ){\n<line55>*piOut = JSON_INVALID_CHAR;\n<line56>return n;\n<line57>}\n<line58>*piOut = (jsonHexToInt(z[2])<<4) | jsonHexToInt(z[3]);\n<line59>return 4;\n<line60>}\n<line61>case 0xe2:\n<line62>case '\r':\n<line63>case '\n': {\n<line64>u32 nSkip = jsonBytesToBypass(z, n);\n<line65>if( nSkip==0 ){\n<line66>*piOut = JSON_INVALID_CHAR;\n<line67>return n;\n<line68>}else if( nSkip==n ){\n<line69>*piOut = 0;\n<line70>return n;\n<line71>}else if( z[nSkip]=='\\' ){\n<line72>return nSkip + jsonUnescapeOneChar(&z[nSkip], n-nSkip, piOut);\n<line73>}else{\n<line74>int sz = sqlite3Utf8ReadLimited((u8*)&z[nSkip], n-nSkip, piOut);\n<line75>return nSkip + sz;\n<line76>}\n<line77>}\n<line78>default: {\n<line79>*piOut = JSON_INVALID_CHAR;\n<line80>return 2;\n<line81>}\n<line82>}\n<line83>}
----------------------------------------
Function: jsonLabelCompareEscaped
Content: <line0>static SQLITE_NOINLINE int jsonLabelCompareEscaped(\n<line1>const char *zLeft,          /* The left label */\n<line2>u32 nLeft,                  /* Size of the left label in bytes */\n<line3>int rawLeft,                /* True if zLeft contains no escapes */\n<line4>const char *zRight,         /* The right label */\n<line5>u32 nRight,                 /* Size of the right label in bytes */\n<line6>int rawRight                /* True if zRight is escape-free */\n<line7>){\n<line8>u32 cLeft, cRight;\n<line9>assert( rawLeft==0 || rawRight==0 );\n<line10>while( 1 /*exit-by-return*/ ){\n<line11>if( nLeft==0 ){\n<line12>cLeft = 0;\n<line13>}else if( rawLeft || zLeft[0]!='\\' ){\n<line14>cLeft = ((u8*)zLeft)[0];\n<line15>if( cLeft>=0xc0 ){\n<line16>int sz = sqlite3Utf8ReadLimited((u8*)zLeft, nLeft, &cLeft);\n<line17>zLeft += sz;\n<line18>nLeft -= sz;\n<line19>}else{\n<line20>zLeft++;\n<line21>nLeft--;\n<line22>}\n<line23>}else{\n<line24>u32 n = jsonUnescapeOneChar(zLeft, nLeft, &cLeft);\n<line25>zLeft += n;\n<line26>assert( n<=nLeft );\n<line27>nLeft -= n;\n<line28>}\n<line29>if( nRight==0 ){\n<line30>cRight = 0;\n<line31>}else if( rawRight || zRight[0]!='\\' ){\n<line32>cRight = ((u8*)zRight)[0];\n<line33>if( cRight>=0xc0 ){\n<line34>int sz = sqlite3Utf8ReadLimited((u8*)zRight, nRight, &cRight);\n<line35>zRight += sz;\n<line36>nRight -= sz;\n<line37>}else{\n<line38>zRight++;\n<line39>nRight--;\n<line40>}\n<line41>}else{\n<line42>u32 n = jsonUnescapeOneChar(zRight, nRight, &cRight);\n<line43>zRight += n;\n<line44>assert( n<=nRight );\n<line45>nRight -= n;\n<line46>}\n<line47>if( cLeft!=cRight ) return 0;\n<line48>if( cLeft==0 ) return 1;\n<line49>}\n<line50>}
----------------------------------------
Function: jsonLabelCompare
Content: <line0>static int jsonLabelCompare(\n<line1>const char *zLeft,          /* The left label */\n<line2>u32 nLeft,                  /* Size of the left label in bytes */\n<line3>int rawLeft,                /* True if zLeft contains no escapes */\n<line4>const char *zRight,         /* The right label */\n<line5>u32 nRight,                 /* Size of the right label in bytes */\n<line6>int rawRight                /* True if zRight is escape-free */\n<line7>){\n<line8>if( rawLeft && rawRight ){\n<line9>/* Simpliest case:  Neither label contains escapes.  A simple\n<line10>** memcmp() is sufficient. */\n<line11>if( nLeft!=nRight ) return 0;\n<line12>return memcmp(zLeft, zRight, nLeft)==0;\n<line13>}else{\n<line14>return jsonLabelCompareEscaped(zLeft, nLeft, rawLeft,\n<line15>zRight, nRight, rawRight);\n<line16>}\n<line17>}
----------------------------------------
Function: jsonCreateEditSubstructure
Content: <line0>static u32 jsonCreateEditSubstructure(\n<line1>JsonParse *pParse,  /* The original JSONB that is being edited */\n<line2>JsonParse *pIns,    /* Populate this with the blob data to insert */\n<line3>const char *zTail   /* Tail of the path that determins substructure */\n<line4>){\n<line5>static const u8 emptyObject[] = { JSONB_ARRAY, JSONB_OBJECT };\n<line6>int rc;\n<line7>memset(pIns, 0, sizeof(*pIns));\n<line8>pIns->db = pParse->db;\n<line9>if( zTail[0]==0 ){\n<line10>/* No substructure.  Just insert what is given in pParse. */\n<line11>pIns->aBlob = pParse->aIns;\n<line12>pIns->nBlob = pParse->nIns;\n<line13>rc = 0;\n<line14>}else{\n<line15>/* Construct the binary substructure */\n<line16>pIns->nBlob = 1;\n<line17>pIns->aBlob = (u8*)&emptyObject[zTail[0]=='.'];\n<line18>pIns->eEdit = pParse->eEdit;\n<line19>pIns->nIns = pParse->nIns;\n<line20>pIns->aIns = pParse->aIns;\n<line21>rc = jsonLookupStep(pIns, 0, zTail, 0);\n<line22>pParse->oom |= pIns->oom;\n<line23>}\n<line24>return rc;  /* Error code only */\n<line25>}
----------------------------------------
Function: jsonLookupStep
Content: <line0>static u32 jsonLookupStep(\n<line1>JsonParse *pParse,      /* The JSON to search */\n<line2>u32 iRoot,              /* Begin the search at this element of aBlob[] */\n<line3>const char *zPath,      /* The path to search */\n<line4>u32 iLabel              /* Label if iRoot is a value of in an object */\n<line5>){\n<line6>u32 i, j, k, nKey, sz, n, iEnd, rc;\n<line7>const char *zKey;\n<line8>u8 x;\n<line9>if( zPath[0]==0 ){\n<line10>if( pParse->eEdit && jsonBlobMakeEditable(pParse, pParse->nIns) ){\n<line11>n = jsonbPayloadSize(pParse, iRoot, &sz);\n<line12>sz += n;\n<line13>if( pParse->eEdit==JEDIT_DEL ){\n<line14>if( iLabel>0 ){\n<line15>sz += iRoot - iLabel;\n<line16>iRoot = iLabel;\n<line17>}\n<line18>jsonBlobEdit(pParse, iRoot, sz, 0, 0);\n<line19>}else if( pParse->eEdit==JEDIT_INS ){\n<line20>/* Already exists, so json_insert() is a no-op */\n<line21>}else{\n<line22>/* json_set() or json_replace() */\n<line23>jsonBlobEdit(pParse, iRoot, sz, pParse->aIns, pParse->nIns);\n<line24>}\n<line25>}\n<line26>pParse->iLabel = iLabel;\n<line27>return iRoot;\n<line28>}\n<line29>if( zPath[0]=='.' ){\n<line30>int rawKey = 1;\n<line31>x = pParse->aBlob[iRoot];\n<line32>zPath++;\n<line33>if( zPath[0]=='"' ){\n<line34>zKey = zPath + 1;\n<line35>for(i=1; zPath[i] && zPath[i]!='"'; i++){\n<line36>if( zPath[i]=='\\' && zPath[i+1]!=0 ) i++;\n<line37>}\n<line38>nKey = i-1;\n<line39>if( zPath[i] ){\n<line40>i++;\n<line41>}else{\n<line42>return JSON_LOOKUP_PATHERROR;\n<line43>}\n<line44>testcase( nKey==0 );\n<line45>rawKey = memchr(zKey, '\\', nKey)==0;\n<line46>}else{\n<line47>zKey = zPath;\n<line48>for(i=0; zPath[i] && zPath[i]!='.' && zPath[i]!='['; i++){}\n<line49>nKey = i;\n<line50>if( nKey==0 ){\n<line51>return JSON_LOOKUP_PATHERROR;\n<line52>}\n<line53>}\n<line54>if( (x & 0x0f)!=JSONB_OBJECT ) return JSON_LOOKUP_NOTFOUND;\n<line55>n = jsonbPayloadSize(pParse, iRoot, &sz);\n<line56>j = iRoot + n;  /* j is the index of a label */\n<line57>iEnd = j+sz;\n<line58>while( j<iEnd ){\n<line59>int rawLabel;\n<line60>const char *zLabel;\n<line61>x = pParse->aBlob[j] & 0x0f;\n<line62>if( x<JSONB_TEXT || x>JSONB_TEXTRAW ) return JSON_LOOKUP_ERROR;\n<line63>n = jsonbPayloadSize(pParse, j, &sz);\n<line64>if( n==0 ) return JSON_LOOKUP_ERROR;\n<line65>k = j+n;  /* k is the index of the label text */\n<line66>if( k+sz>=iEnd ) return JSON_LOOKUP_ERROR;\n<line67>zLabel = (const char*)&pParse->aBlob[k];\n<line68>rawLabel = x==JSONB_TEXT || x==JSONB_TEXTRAW;\n<line69>if( jsonLabelCompare(zKey, nKey, rawKey, zLabel, sz, rawLabel) ){\n<line70>u32 v = k+sz;  /* v is the index of the value */\n<line71>if( ((pParse->aBlob[v])&0x0f)>JSONB_OBJECT ) return JSON_LOOKUP_ERROR;\n<line72>n = jsonbPayloadSize(pParse, v, &sz);\n<line73>if( n==0 || v+n+sz>iEnd ) return JSON_LOOKUP_ERROR;\n<line74>assert( j>0 );\n<line75>rc = jsonLookupStep(pParse, v, &zPath[i], j);\n<line76>if( pParse->delta ) jsonAfterEditSizeAdjust(pParse, iRoot);\n<line77>return rc;\n<line78>}\n<line79>j = k+sz;\n<line80>if( ((pParse->aBlob[j])&0x0f)>JSONB_OBJECT ) return JSON_LOOKUP_ERROR;\n<line81>n = jsonbPayloadSize(pParse, j, &sz);\n<line82>if( n==0 ) return JSON_LOOKUP_ERROR;\n<line83>j += n+sz;\n<line84>}\n<line85>if( j>iEnd ) return JSON_LOOKUP_ERROR;\n<line86>if( pParse->eEdit>=JEDIT_INS ){\n<line87>u32 nIns;          /* Total bytes to insert (label+value) */\n<line88>JsonParse v;       /* BLOB encoding of the value to be inserted */\n<line89>JsonParse ix;      /* Header of the label to be inserted */\n<line90>testcase( pParse->eEdit==JEDIT_INS );\n<line91>testcase( pParse->eEdit==JEDIT_SET );\n<line92>memset(&ix, 0, sizeof(ix));\n<line93>ix.db = pParse->db;\n<line94>jsonBlobAppendNode(&ix, rawKey?JSONB_TEXTRAW:JSONB_TEXT5, nKey, 0);\n<line95>pParse->oom |= ix.oom;\n<line96>rc = jsonCreateEditSubstructure(pParse, &v, &zPath[i]);\n<line97>if( !JSON_LOOKUP_ISERROR(rc)\n<line98>&& jsonBlobMakeEditable(pParse, ix.nBlob+nKey+v.nBlob)\n<line99>){\n<line100>assert( !pParse->oom );\n<line101>nIns = ix.nBlob + nKey + v.nBlob;\n<line102>jsonBlobEdit(pParse, j, 0, 0, nIns);\n<line103>if( !pParse->oom ){\n<line104>assert( pParse->aBlob!=0 ); /* Because pParse->oom!=0 */\n<line105>assert( ix.aBlob!=0 );      /* Because pPasre->oom!=0 */\n<line106>memcpy(&pParse->aBlob[j], ix.aBlob, ix.nBlob);\n<line107>k = j + ix.nBlob;\n<line108>memcpy(&pParse->aBlob[k], zKey, nKey);\n<line109>k += nKey;\n<line110>memcpy(&pParse->aBlob[k], v.aBlob, v.nBlob);\n<line111>if( ALWAYS(pParse->delta) ) jsonAfterEditSizeAdjust(pParse, iRoot);\n<line112>}\n<line113>}\n<line114>jsonParseReset(&v);\n<line115>jsonParseReset(&ix);\n<line116>return rc;\n<line117>}\n<line118>}else if( zPath[0]=='[' ){\n<line119>x = pParse->aBlob[iRoot] & 0x0f;\n<line120>if( x!=JSONB_ARRAY )  return JSON_LOOKUP_NOTFOUND;\n<line121>n = jsonbPayloadSize(pParse, iRoot, &sz);\n<line122>k = 0;\n<line123>i = 1;\n<line124>while( sqlite3Isdigit(zPath[i]) ){\n<line125>k = k*10 + zPath[i] - '0';\n<line126>i++;\n<line127>}\n<line128>if( i<2 || zPath[i]!=']' ){\n<line129>if( zPath[1]=='#' ){\n<line130>k = jsonbArrayCount(pParse, iRoot);\n<line131>i = 2;\n<line132>if( zPath[2]=='-' && sqlite3Isdigit(zPath[3]) ){\n<line133>unsigned int nn = 0;\n<line134>i = 3;\n<line135>do{\n<line136>nn = nn*10 + zPath[i] - '0';\n<line137>i++;\n<line138>}while( sqlite3Isdigit(zPath[i]) );\n<line139>if( nn>k ) return JSON_LOOKUP_NOTFOUND;\n<line140>k -= nn;\n<line141>}\n<line142>if( zPath[i]!=']' ){\n<line143>return JSON_LOOKUP_PATHERROR;\n<line144>}\n<line145>}else{\n<line146>return JSON_LOOKUP_PATHERROR;\n<line147>}\n<line148>}\n<line149>j = iRoot+n;\n<line150>iEnd = j+sz;\n<line151>while( j<iEnd ){\n<line152>if( k==0 ){\n<line153>rc = jsonLookupStep(pParse, j, &zPath[i+1], 0);\n<line154>if( pParse->delta ) jsonAfterEditSizeAdjust(pParse, iRoot);\n<line155>return rc;\n<line156>}\n<line157>k--;\n<line158>n = jsonbPayloadSize(pParse, j, &sz);\n<line159>if( n==0 ) return JSON_LOOKUP_ERROR;\n<line160>j += n+sz;\n<line161>}\n<line162>if( j>iEnd ) return JSON_LOOKUP_ERROR;\n<line163>if( k>0 ) return JSON_LOOKUP_NOTFOUND;\n<line164>if( pParse->eEdit>=JEDIT_INS ){\n<line165>JsonParse v;\n<line166>testcase( pParse->eEdit==JEDIT_INS );\n<line167>testcase( pParse->eEdit==JEDIT_SET );\n<line168>rc = jsonCreateEditSubstructure(pParse, &v, &zPath[i+1]);\n<line169>if( !JSON_LOOKUP_ISERROR(rc)\n<line170>&& jsonBlobMakeEditable(pParse, v.nBlob)\n<line171>){\n<line172>assert( !pParse->oom );\n<line173>jsonBlobEdit(pParse, j, 0, v.aBlob, v.nBlob);\n<line174>}\n<line175>jsonParseReset(&v);\n<line176>if( pParse->delta ) jsonAfterEditSizeAdjust(pParse, iRoot);\n<line177>return rc;\n<line178>}\n<line179>}else{\n<line180>return JSON_LOOKUP_PATHERROR;\n<line181>}\n<line182>return JSON_LOOKUP_NOTFOUND;\n<line183>}
----------------------------------------
Function: jsonReturnTextJsonFromBlob
Content: <line0>static void jsonReturnTextJsonFromBlob(\n<line1>sqlite3_context *ctx,\n<line2>const u8 *aBlob,\n<line3>u32 nBlob\n<line4>){\n<line5>JsonParse x;\n<line6>JsonString s;\n<line7>if( NEVER(aBlob==0) ) return;\n<line8>memset(&x, 0, sizeof(x));\n<line9>x.aBlob = (u8*)aBlob;\n<line10>x.nBlob = nBlob;\n<line11>jsonStringInit(&s, ctx);\n<line12>jsonTranslateBlobToText(&x, 0, &s);\n<line13>jsonReturnString(&s, 0, 0);\n<line14>}
----------------------------------------
Function: jsonReturnFromBlob
Content: <line0>static void jsonReturnFromBlob(\n<line1>JsonParse *pParse,          /* Complete JSON parse tree */\n<line2>u32 i,                      /* Index of the node */\n<line3>sqlite3_context *pCtx,      /* Return value for this function */\n<line4>int eMode                   /* Format of return: text of JSONB */\n<line5>){\n<line6>u32 n, sz;\n<line7>int rc;\n<line8>sqlite3 *db = sqlite3_context_db_handle(pCtx);\n<line9>assert( eMode>=0 && eMode<=2 );\n<line10>n = jsonbPayloadSize(pParse, i, &sz);\n<line11>if( n==0 ){\n<line12>sqlite3_result_error(pCtx, "malformed JSON", -1);\n<line13>return;\n<line14>}\n<line15>switch( pParse->aBlob[i] & 0x0f ){\n<line16>case JSONB_NULL: {\n<line17>if( sz ) goto returnfromblob_malformed;\n<line18>sqlite3_result_null(pCtx);\n<line19>break;\n<line20>}\n<line21>case JSONB_TRUE: {\n<line22>if( sz ) goto returnfromblob_malformed;\n<line23>sqlite3_result_int(pCtx, 1);\n<line24>break;\n<line25>}\n<line26>case JSONB_FALSE: {\n<line27>if( sz ) goto returnfromblob_malformed;\n<line28>sqlite3_result_int(pCtx, 0);\n<line29>break;\n<line30>}\n<line31>case JSONB_INT5:\n<line32>case JSONB_INT: {\n<line33>sqlite3_int64 iRes = 0;\n<line34>char *z;\n<line35>int bNeg = 0;\n<line36>char x;\n<line37>if( sz==0 ) goto returnfromblob_malformed;\n<line38>x = (char)pParse->aBlob[i+n];\n<line39>if( x=='-' ){\n<line40>if( sz<2 ) goto returnfromblob_malformed;\n<line41>n++;\n<line42>sz--;\n<line43>bNeg = 1;\n<line44>}\n<line45>z = sqlite3DbStrNDup(db, (const char*)&pParse->aBlob[i+n], (int)sz);\n<line46>if( z==0 ) goto returnfromblob_oom;\n<line47>rc = sqlite3DecOrHexToI64(z, &iRes);\n<line48>sqlite3DbFree(db, z);\n<line49>if( rc==0 ){\n<line50>if( iRes<0 ){\n<line51>/* A hexadecimal literal with 16 significant digits and with the\n<line52>** high-order bit set is a negative integer in SQLite (and hence\n<line53>** iRes comes back as negative) but should be interpreted as a\n<line54>** positive value if it occurs within JSON.  The value is too\n<line55>** large to appear as an SQLite integer so it must be converted\n<line56>** into floating point. */\n<line57>double r;\n<line58>r = (double)*(sqlite3_uint64*)&iRes;\n<line59>sqlite3_result_double(pCtx, bNeg ? -r : r);\n<line60>}else{\n<line61>sqlite3_result_int64(pCtx, bNeg ? -iRes : iRes);\n<line62>}\n<line63>}else if( rc==3 && bNeg ){\n<line64>sqlite3_result_int64(pCtx, SMALLEST_INT64);\n<line65>}else if( rc==1 ){\n<line66>goto returnfromblob_malformed;\n<line67>}else{\n<line68>if( bNeg ){ n--; sz++; }\n<line69>goto to_double;\n<line70>}\n<line71>break;\n<line72>}\n<line73>case JSONB_FLOAT5:\n<line74>case JSONB_FLOAT: {\n<line75>double r;\n<line76>char *z;\n<line77>if( sz==0 ) goto returnfromblob_malformed;\n<line78>to_double:\n<line79>z = sqlite3DbStrNDup(db, (const char*)&pParse->aBlob[i+n], (int)sz);\n<line80>if( z==0 ) goto returnfromblob_oom;\n<line81>rc = sqlite3AtoF(z, &r, sqlite3Strlen30(z), SQLITE_UTF8);\n<line82>sqlite3DbFree(db, z);\n<line83>if( rc<=0 ) goto returnfromblob_malformed;\n<line84>sqlite3_result_double(pCtx, r);\n<line85>break;\n<line86>}\n<line87>case JSONB_TEXTRAW:\n<line88>case JSONB_TEXT: {\n<line89>sqlite3_result_text(pCtx, (char*)&pParse->aBlob[i+n], sz,\n<line90>SQLITE_TRANSIENT);\n<line91>break;\n<line92>}\n<line93>case JSONB_TEXT5:\n<line94>case JSONB_TEXTJ: {\n<line95>/* Translate JSON formatted string into raw text */\n<line96>u32 iIn, iOut;\n<line97>const char *z;\n<line98>char *zOut;\n<line99>u32 nOut = sz;\n<line100>z = (const char*)&pParse->aBlob[i+n];\n<line101>zOut = sqlite3DbMallocRaw(db, ((u64)nOut)+1);\n<line102>if( zOut==0 ) goto returnfromblob_oom;\n<line103>for(iIn=iOut=0; iIn<sz; iIn++){\n<line104>char c = z[iIn];\n<line105>if( c=='\\' ){\n<line106>u32 v;\n<line107>u32 szEscape = jsonUnescapeOneChar(&z[iIn], sz-iIn, &v);\n<line108>if( v<=0x7f ){\n<line109>zOut[iOut++] = (char)v;\n<line110>}else if( v<=0x7ff ){\n<line111>assert( szEscape>=2 );\n<line112>zOut[iOut++] = (char)(0xc0 | (v>>6));\n<line113>zOut[iOut++] = 0x80 | (v&0x3f);\n<line114>}else if( v<0x10000 ){\n<line115>assert( szEscape>=3 );\n<line116>zOut[iOut++] = 0xe0 | (v>>12);\n<line117>zOut[iOut++] = 0x80 | ((v>>6)&0x3f);\n<line118>zOut[iOut++] = 0x80 | (v&0x3f);\n<line119>}else if( v==JSON_INVALID_CHAR ){\n<line120>/* Silently ignore illegal unicode */\n<line121>}else{\n<line122>assert( szEscape>=4 );\n<line123>zOut[iOut++] = 0xf0 | (v>>18);\n<line124>zOut[iOut++] = 0x80 | ((v>>12)&0x3f);\n<line125>zOut[iOut++] = 0x80 | ((v>>6)&0x3f);\n<line126>zOut[iOut++] = 0x80 | (v&0x3f);\n<line127>}\n<line128>iIn += szEscape - 1;\n<line129>}else{\n<line130>zOut[iOut++] = c;\n<line131>}\n<line132>} /* end for() */\n<line133>assert( iOut<=nOut );\n<line134>zOut[iOut] = 0;\n<line135>sqlite3_result_text(pCtx, zOut, iOut, SQLITE_DYNAMIC);\n<line136>break;\n<line137>}\n<line138>case JSONB_ARRAY:\n<line139>case JSONB_OBJECT: {\n<line140>if( eMode==0 ){\n<line141>if( (SQLITE_PTR_TO_INT(sqlite3_user_data(pCtx)) & JSON_BLOB)!=0 ){\n<line142>eMode = 2;\n<line143>}else{\n<line144>eMode = 1;\n<line145>}\n<line146>}\n<line147>if( eMode==2 ){\n<line148>sqlite3_result_blob(pCtx, &pParse->aBlob[i], sz+n, SQLITE_TRANSIENT);\n<line149>}else{\n<line150>jsonReturnTextJsonFromBlob(pCtx, &pParse->aBlob[i], sz+n);\n<line151>}\n<line152>break;\n<line153>}\n<line154>default: {\n<line155>goto returnfromblob_malformed;\n<line156>}\n<line157>}\n<line158>return;\n<line159>returnfromblob_oom:\n<line160>sqlite3_result_error_nomem(pCtx);\n<line161>return;\n<line162>returnfromblob_malformed:\n<line163>sqlite3_result_error(pCtx, "malformed JSON", -1);\n<line164>return;\n<line165>}
----------------------------------------
Function: jsonFunctionArgToBlob
Content: <line0>static int jsonFunctionArgToBlob(\n<line1>sqlite3_context *ctx,\n<line2>sqlite3_value *pArg,\n<line3>JsonParse *pParse\n<line4>){\n<line5>int eType = sqlite3_value_type(pArg);\n<line6>static u8 aNull[] = { 0x00 };\n<line7>memset(pParse, 0, sizeof(pParse[0]));\n<line8>pParse->db = sqlite3_context_db_handle(ctx);\n<line9>switch( eType ){\n<line10>default: {\n<line11>pParse->aBlob = aNull;\n<line12>pParse->nBlob = 1;\n<line13>return 0;\n<line14>}\n<line15>case SQLITE_BLOB: {\n<line16>if( !jsonArgIsJsonb(pArg, pParse) ){\n<line17>sqlite3_result_error(ctx, "JSON cannot hold BLOB values", -1);\n<line18>return 1;\n<line19>}\n<line20>break;\n<line21>}\n<line22>case SQLITE_TEXT: {\n<line23>const char *zJson = (const char*)sqlite3_value_text(pArg);\n<line24>int nJson = sqlite3_value_bytes(pArg);\n<line25>if( zJson==0 ) return 1;\n<line26>if( sqlite3_value_subtype(pArg)==JSON_SUBTYPE ){\n<line27>pParse->zJson = (char*)zJson;\n<line28>pParse->nJson = nJson;\n<line29>if( jsonConvertTextToBlob(pParse, ctx) ){\n<line30>sqlite3_result_error(ctx, "malformed JSON", -1);\n<line31>sqlite3DbFree(pParse->db, pParse->aBlob);\n<line32>memset(pParse, 0, sizeof(pParse[0]));\n<line33>return 1;\n<line34>}\n<line35>}else{\n<line36>jsonBlobAppendNode(pParse, JSONB_TEXTRAW, nJson, zJson);\n<line37>}\n<line38>break;\n<line39>}\n<line40>case SQLITE_FLOAT: {\n<line41>double r = sqlite3_value_double(pArg);\n<line42>if( NEVER(sqlite3IsNaN(r)) ){\n<line43>jsonBlobAppendNode(pParse, JSONB_NULL, 0, 0);\n<line44>}else{\n<line45>int n = sqlite3_value_bytes(pArg);\n<line46>const char *z = (const char*)sqlite3_value_text(pArg);\n<line47>if( z==0 ) return 1;\n<line48>if( z[0]=='I' ){\n<line49>jsonBlobAppendNode(pParse, JSONB_FLOAT, 5, "9e999");\n<line50>}else if( z[0]=='-' && z[1]=='I' ){\n<line51>jsonBlobAppendNode(pParse, JSONB_FLOAT, 6, "-9e999");\n<line52>}else{\n<line53>jsonBlobAppendNode(pParse, JSONB_FLOAT, n, z);\n<line54>}\n<line55>}\n<line56>break;\n<line57>}\n<line58>case SQLITE_INTEGER: {\n<line59>int n = sqlite3_value_bytes(pArg);\n<line60>const char *z = (const char*)sqlite3_value_text(pArg);\n<line61>if( z==0 ) return 1;\n<line62>jsonBlobAppendNode(pParse, JSONB_INT, n, z);\n<line63>break;\n<line64>}\n<line65>}\n<line66>if( pParse->oom ){\n<line67>sqlite3_result_error_nomem(ctx);\n<line68>return 1;\n<line69>}else{\n<line70>return 0;\n<line71>}\n<line72>}
----------------------------------------
Function: jsonBadPathError
Content: <line0>static char *jsonBadPathError(\n<line1>sqlite3_context *ctx,     /* The function call containing the error */\n<line2>const char *zPath         /* The path with the problem */\n<line3>){\n<line4>char *zMsg = sqlite3_mprintf("bad JSON path: %Q", zPath);\n<line5>if( ctx==0 ) return zMsg;\n<line6>if( zMsg ){\n<line7>sqlite3_result_error(ctx, zMsg, -1);\n<line8>sqlite3_free(zMsg);\n<line9>}else{\n<line10>sqlite3_result_error_nomem(ctx);\n<line11>}\n<line12>return 0;\n<line13>}
----------------------------------------
Function: jsonInsertIntoBlob
Content: <line0>static void jsonInsertIntoBlob(\n<line1>sqlite3_context *ctx,\n<line2>int argc,\n<line3>sqlite3_value **argv,\n<line4>int eEdit                /* JEDIT_INS, JEDIT_REPL, or JEDIT_SET */\n<line5>){\n<line6>int i;\n<line7>u32 rc = 0;\n<line8>const char *zPath = 0;\n<line9>int flgs;\n<line10>JsonParse *p;\n<line11>JsonParse ax;\n<line12>assert( (argc&1)==1 );\n<line13>flgs = argc==1 ? 0 : JSON_EDITABLE;\n<line14>p = jsonParseFuncArg(ctx, argv[0], flgs);\n<line15>if( p==0 ) return;\n<line16>for(i=1; i<argc-1; i+=2){\n<line17>if( sqlite3_value_type(argv[i])==SQLITE_NULL ) continue;\n<line18>zPath = (const char*)sqlite3_value_text(argv[i]);\n<line19>if( zPath==0 ){\n<line20>sqlite3_result_error_nomem(ctx);\n<line21>jsonParseFree(p);\n<line22>return;\n<line23>}\n<line24>if( zPath[0]!='$' ) goto jsonInsertIntoBlob_patherror;\n<line25>if( jsonFunctionArgToBlob(ctx, argv[i+1], &ax) ){\n<line26>jsonParseReset(&ax);\n<line27>jsonParseFree(p);\n<line28>return;\n<line29>}\n<line30>if( zPath[1]==0 ){\n<line31>if( eEdit==JEDIT_REPL || eEdit==JEDIT_SET ){\n<line32>jsonBlobEdit(p, 0, p->nBlob, ax.aBlob, ax.nBlob);\n<line33>}\n<line34>rc = 0;\n<line35>}else{\n<line36>p->eEdit = eEdit;\n<line37>p->nIns = ax.nBlob;\n<line38>p->aIns = ax.aBlob;\n<line39>p->delta = 0;\n<line40>rc = jsonLookupStep(p, 0, zPath+1, 0);\n<line41>}\n<line42>jsonParseReset(&ax);\n<line43>if( rc==JSON_LOOKUP_NOTFOUND ) continue;\n<line44>if( JSON_LOOKUP_ISERROR(rc) ) goto jsonInsertIntoBlob_patherror;\n<line45>}\n<line46>jsonReturnParse(ctx, p);\n<line47>jsonParseFree(p);\n<line48>return;\n<line49>jsonInsertIntoBlob_patherror:\n<line50>jsonParseFree(p);\n<line51>if( rc==JSON_LOOKUP_ERROR ){\n<line52>sqlite3_result_error(ctx, "malformed JSON", -1);\n<line53>}else{\n<line54>jsonBadPathError(ctx, zPath);\n<line55>}\n<line56>return;\n<line57>}
----------------------------------------
Function: jsonArgIsJsonb
Content: <line0>static int jsonArgIsJsonb(sqlite3_value *pArg, JsonParse *p){\n<line1>u32 n, sz = 0;\n<line2>u8 c;\n<line3>if( sqlite3_value_type(pArg)!=SQLITE_BLOB ) return 0;\n<line4>p->aBlob = (u8*)sqlite3_value_blob(pArg);\n<line5>p->nBlob = (u32)sqlite3_value_bytes(pArg);\n<line6>if( p->nBlob>0\n<line7>&& ALWAYS(p->aBlob!=0)\n<line8>&& ((c = p->aBlob[0]) & 0x0f)<=JSONB_OBJECT\n<line9>&& (n = jsonbPayloadSize(p, 0, &sz))>0\n<line10>&& sz+n==p->nBlob\n<line11>&& ((c & 0x0f)>JSONB_FALSE || sz==0)\n<line12>&& (sz>7\n<line13>|| (c!=0x7b && c!=0x5b && !sqlite3Isdigit(c))\n<line14>|| jsonbValidityCheck(p, 0, p->nBlob, 1)==0)\n<line15>){\n<line16>return 1;\n<line17>}\n<line18>p->aBlob = 0;\n<line19>p->nBlob = 0;\n<line20>return 0;\n<line21>}
----------------------------------------
Function: jsonParseFuncArg
Content: <line0>static JsonParse *jsonParseFuncArg(\n<line1>sqlite3_context *ctx,\n<line2>sqlite3_value *pArg,\n<line3>u32 flgs\n<line4>){\n<line5>int eType;                   /* Datatype of pArg */\n<line6>JsonParse *p = 0;            /* Value to be returned */\n<line7>JsonParse *pFromCache = 0;   /* Value taken from cache */\n<line8>sqlite3 *db;                 /* The database connection */\n<line9>assert( ctx!=0 );\n<line10>eType = sqlite3_value_type(pArg);\n<line11>if( eType==SQLITE_NULL ){\n<line12>return 0;\n<line13>}\n<line14>pFromCache = jsonCacheSearch(ctx, pArg);\n<line15>if( pFromCache ){\n<line16>pFromCache->nJPRef++;\n<line17>if( (flgs & JSON_EDITABLE)==0 ){\n<line18>return pFromCache;\n<line19>}\n<line20>}\n<line21>db = sqlite3_context_db_handle(ctx);\n<line22>rebuild_from_cache:\n<line23>p = sqlite3DbMallocZero(db, sizeof(*p));\n<line24>if( p==0 ) goto json_pfa_oom;\n<line25>memset(p, 0, sizeof(*p));\n<line26>p->db = db;\n<line27>p->nJPRef = 1;\n<line28>if( pFromCache!=0 ){\n<line29>u32 nBlob = pFromCache->nBlob;\n<line30>p->aBlob = sqlite3DbMallocRaw(db, nBlob);\n<line31>if( p->aBlob==0 ) goto json_pfa_oom;\n<line32>memcpy(p->aBlob, pFromCache->aBlob, nBlob);\n<line33>p->nBlobAlloc = p->nBlob = nBlob;\n<line34>p->hasNonstd = pFromCache->hasNonstd;\n<line35>jsonParseFree(pFromCache);\n<line36>return p;\n<line37>}\n<line38>if( eType==SQLITE_BLOB ){\n<line39>if( jsonArgIsJsonb(pArg,p) ){\n<line40>if( (flgs & JSON_EDITABLE)!=0 && jsonBlobMakeEditable(p, 0)==0 ){\n<line41>goto json_pfa_oom;\n<line42>}\n<line43>return p;\n<line44>}\n<line45>/* If the blob is not valid JSONB, fall through into trying to cast\n<line46>** the blob into text which is then interpreted as JSON.  (tag-20240123-a)\n<line47>**\n<line48>** This goes against all historical documentation about how the SQLite\n<line49>** JSON functions were suppose to work.  From the beginning, blob was\n<line50>** reserved for expansion and a blob value should have raised an error.\n<line51>** But it did not, due to a bug.  And many applications came to depend\n<line52>** upon this buggy behavior, especially when using the CLI and reading\n<line53>** JSON text using readfile(), which returns a blob.  For this reason\n<line54>** we will continue to support the bug moving forward.\n<line55>** See for example https://sqlite.org/forum/forumpost/012136abd5292b8d\n<line56>*/\n<line57>}\n<line58>p->zJson = (char*)sqlite3_value_text(pArg);\n<line59>p->nJson = sqlite3_value_bytes(pArg);\n<line60>if( db->mallocFailed ) goto json_pfa_oom;\n<line61>if( p->nJson==0 ) goto json_pfa_malformed;\n<line62>assert( p->zJson!=0 );\n<line63>if( jsonConvertTextToBlob(p, (flgs & JSON_KEEPERROR) ? 0 : ctx) ){\n<line64>if( flgs & JSON_KEEPERROR ){\n<line65>p->nErr = 1;\n<line66>return p;\n<line67>}else{\n<line68>jsonParseFree(p);\n<line69>return 0;\n<line70>}\n<line71>}else{\n<line72>int isRCStr = sqlite3ValueIsOfClass(pArg, sqlite3RCStrUnref);\n<line73>int rc;\n<line74>if( !isRCStr ){\n<line75>char *zNew = sqlite3RCStrNew( p->nJson );\n<line76>if( zNew==0 ) goto json_pfa_oom;\n<line77>memcpy(zNew, p->zJson, p->nJson);\n<line78>p->zJson = zNew;\n<line79>p->zJson[p->nJson] = 0;\n<line80>}else{\n<line81>sqlite3RCStrRef(p->zJson);\n<line82>}\n<line83>p->bJsonIsRCStr = 1;\n<line84>rc = jsonCacheInsert(ctx, p);\n<line85>if( rc==SQLITE_NOMEM ) goto json_pfa_oom;\n<line86>if( flgs & JSON_EDITABLE ){\n<line87>pFromCache = p;\n<line88>p = 0;\n<line89>goto rebuild_from_cache;\n<line90>}\n<line91>}\n<line92>return p;\n<line93>json_pfa_malformed:\n<line94>if( flgs & JSON_KEEPERROR ){\n<line95>p->nErr = 1;\n<line96>return p;\n<line97>}else{\n<line98>jsonParseFree(p);\n<line99>sqlite3_result_error(ctx, "malformed JSON", -1);\n<line100>return 0;\n<line101>}\n<line102>json_pfa_oom:\n<line103>jsonParseFree(pFromCache);\n<line104>jsonParseFree(p);\n<line105>sqlite3_result_error_nomem(ctx);\n<line106>return 0;\n<line107>}
----------------------------------------
Function: jsonReturnParse
Content: <line0>static void jsonReturnParse(\n<line1>sqlite3_context *ctx,\n<line2>JsonParse *p\n<line3>){\n<line4>int flgs;\n<line5>if( p->oom ){\n<line6>sqlite3_result_error_nomem(ctx);\n<line7>return;\n<line8>}\n<line9>flgs = SQLITE_PTR_TO_INT(sqlite3_user_data(ctx));\n<line10>if( flgs & JSON_BLOB ){\n<line11>if( p->nBlobAlloc>0 && !p->bReadOnly ){\n<line12>sqlite3_result_blob(ctx, p->aBlob, p->nBlob, SQLITE_DYNAMIC);\n<line13>p->nBlobAlloc = 0;\n<line14>}else{\n<line15>sqlite3_result_blob(ctx, p->aBlob, p->nBlob, SQLITE_TRANSIENT);\n<line16>}\n<line17>}else{\n<line18>JsonString s;\n<line19>jsonStringInit(&s, ctx);\n<line20>p->delta = 0;\n<line21>jsonTranslateBlobToText(p, 0, &s);\n<line22>jsonReturnString(&s, p, ctx);\n<line23>sqlite3_result_subtype(ctx, JSON_SUBTYPE);\n<line24>}\n<line25>}
----------------------------------------
Function: jsonQuoteFunc
Content: <line0>static void jsonQuoteFunc(\n<line1>sqlite3_context *ctx,\n<line2>int argc,\n<line3>sqlite3_value **argv\n<line4>){\n<line5>JsonString jx;\n<line6>UNUSED_PARAMETER(argc);\n<line7>jsonStringInit(&jx, ctx);\n<line8>jsonAppendSqlValue(&jx, argv[0]);\n<line9>jsonReturnString(&jx, 0, 0);\n<line10>sqlite3_result_subtype(ctx, JSON_SUBTYPE);\n<line11>}
----------------------------------------
Function: jsonArrayFunc
Content: <line0>static void jsonArrayFunc(\n<line1>sqlite3_context *ctx,\n<line2>int argc,\n<line3>sqlite3_value **argv\n<line4>){\n<line5>int i;\n<line6>JsonString jx;\n<line7>jsonStringInit(&jx, ctx);\n<line8>jsonAppendChar(&jx, '[');\n<line9>for(i=0; i<argc; i++){\n<line10>jsonAppendSeparator(&jx);\n<line11>jsonAppendSqlValue(&jx, argv[i]);\n<line12>}\n<line13>jsonAppendChar(&jx, ']');\n<line14>jsonReturnString(&jx, 0, 0);\n<line15>sqlite3_result_subtype(ctx, JSON_SUBTYPE);\n<line16>}
----------------------------------------
Function: jsonArrayLengthFunc
Content: <line0>static void jsonArrayLengthFunc(\n<line1>sqlite3_context *ctx,\n<line2>int argc,\n<line3>sqlite3_value **argv\n<line4>){\n<line5>JsonParse *p;          /* The parse */\n<line6>sqlite3_int64 cnt = 0;\n<line7>u32 i;\n<line8>u8 eErr = 0;\n<line9>p = jsonParseFuncArg(ctx, argv[0], 0);\n<line10>if( p==0 ) return;\n<line11>if( argc==2 ){\n<line12>const char *zPath = (const char*)sqlite3_value_text(argv[1]);\n<line13>if( zPath==0 ){\n<line14>jsonParseFree(p);\n<line15>return;\n<line16>}\n<line17>i = jsonLookupStep(p, 0, zPath[0]=='$' ? zPath+1 : "@", 0);\n<line18>if( JSON_LOOKUP_ISERROR(i) ){\n<line19>if( i==JSON_LOOKUP_NOTFOUND ){\n<line20>/* no-op */\n<line21>}else if( i==JSON_LOOKUP_PATHERROR ){\n<line22>jsonBadPathError(ctx, zPath);\n<line23>}else{\n<line24>sqlite3_result_error(ctx, "malformed JSON", -1);\n<line25>}\n<line26>eErr = 1;\n<line27>i = 0;\n<line28>}\n<line29>}else{\n<line30>i = 0;\n<line31>}\n<line32>if( (p->aBlob[i] & 0x0f)==JSONB_ARRAY ){\n<line33>cnt = jsonbArrayCount(p, i);\n<line34>}\n<line35>if( !eErr ) sqlite3_result_int64(ctx, cnt);\n<line36>jsonParseFree(p);\n<line37>}
----------------------------------------
Function: jsonAllAlphanum
Content: <line0>static int jsonAllAlphanum(const char *z, int n){\n<line1>int i;\n<line2>for(i=0; i<n && (sqlite3Isalnum(z[i]) || z[i]=='_'); i++){}\n<line3>return i==n;\n<line4>}
----------------------------------------
Function: jsonExtractFunc
Content: <line0>static void jsonExtractFunc(\n<line1>sqlite3_context *ctx,\n<line2>int argc,\n<line3>sqlite3_value **argv\n<line4>){\n<line5>JsonParse *p = 0;      /* The parse */\n<line6>int flags;             /* Flags associated with the function */\n<line7>int i;                 /* Loop counter */\n<line8>JsonString jx;         /* String for array result */\n<line9>if( argc<2 ) return;\n<line10>p = jsonParseFuncArg(ctx, argv[0], 0);\n<line11>if( p==0 ) return;\n<line12>flags = SQLITE_PTR_TO_INT(sqlite3_user_data(ctx));\n<line13>jsonStringInit(&jx, ctx);\n<line14>if( argc>2 ){\n<line15>jsonAppendChar(&jx, '[');\n<line16>}\n<line17>for(i=1; i<argc; i++){\n<line18>/* With a single PATH argument */\n<line19>const char *zPath = (const char*)sqlite3_value_text(argv[i]);\n<line20>int nPath;\n<line21>u32 j;\n<line22>if( zPath==0 ) goto json_extract_error;\n<line23>nPath = sqlite3Strlen30(zPath);\n<line24>if( zPath[0]=='$' ){\n<line25>j = jsonLookupStep(p, 0, zPath+1, 0);\n<line26>}else if( (flags & JSON_ABPATH) ){\n<line27>/* The -> and ->> operators accept abbreviated PATH arguments.  This\n<line28>** is mostly for compatibility with PostgreSQL, but also for\n<line29>** convenience.\n<line30>**\n<line31>**     NUMBER   ==>  $[NUMBER]     // PG compatible\n<line32>**     LABEL    ==>  $.LABEL       // PG compatible\n<line33>**     [NUMBER] ==>  $[NUMBER]     // Not PG.  Purely for convenience\n<line34>**\n<line35>** Updated 2024-05-27:  If the NUMBER is negative, then PG counts from\n<line36>** the right of the array.  Hence for negative NUMBER:\n<line37>**\n<line38>**     NUMBER   ==>  $[#NUMBER]    // PG compatible\n<line39>*/\n<line40>jsonStringInit(&jx, ctx);\n<line41>if( sqlite3_value_type(argv[i])==SQLITE_INTEGER ){\n<line42>jsonAppendRawNZ(&jx, "[", 1);\n<line43>if( zPath[0]=='-' ) jsonAppendRawNZ(&jx,"#",1);\n<line44>jsonAppendRaw(&jx, zPath, nPath);\n<line45>jsonAppendRawNZ(&jx, "]", 2);\n<line46>}else if( jsonAllAlphanum(zPath, nPath) ){\n<line47>jsonAppendRawNZ(&jx, ".", 1);\n<line48>jsonAppendRaw(&jx, zPath, nPath);\n<line49>}else if( zPath[0]=='[' && nPath>=3 && zPath[nPath-1]==']' ){\n<line50>jsonAppendRaw(&jx, zPath, nPath);\n<line51>}else{\n<line52>jsonAppendRawNZ(&jx, ".\"", 2);\n<line53>jsonAppendRaw(&jx, zPath, nPath);\n<line54>jsonAppendRawNZ(&jx, "\"", 1);\n<line55>}\n<line56>jsonStringTerminate(&jx);\n<line57>j = jsonLookupStep(p, 0, jx.zBuf, 0);\n<line58>jsonStringReset(&jx);\n<line59>}else{\n<line60>jsonBadPathError(ctx, zPath);\n<line61>goto json_extract_error;\n<line62>}\n<line63>if( j<p->nBlob ){\n<line64>if( argc==2 ){\n<line65>if( flags & JSON_JSON ){\n<line66>jsonStringInit(&jx, ctx);\n<line67>jsonTranslateBlobToText(p, j, &jx);\n<line68>jsonReturnString(&jx, 0, 0);\n<line69>jsonStringReset(&jx);\n<line70>assert( (flags & JSON_BLOB)==0 );\n<line71>sqlite3_result_subtype(ctx, JSON_SUBTYPE);\n<line72>}else{\n<line73>jsonReturnFromBlob(p, j, ctx, 0);\n<line74>if( (flags & (JSON_SQL|JSON_BLOB))==0\n<line75>&& (p->aBlob[j]&0x0f)>=JSONB_ARRAY\n<line76>){\n<line77>sqlite3_result_subtype(ctx, JSON_SUBTYPE);\n<line78>}\n<line79>}\n<line80>}else{\n<line81>jsonAppendSeparator(&jx);\n<line82>jsonTranslateBlobToText(p, j, &jx);\n<line83>}\n<line84>}else if( j==JSON_LOOKUP_NOTFOUND ){\n<line85>if( argc==2 ){\n<line86>goto json_extract_error;  /* Return NULL if not found */\n<line87>}else{\n<line88>jsonAppendSeparator(&jx);\n<line89>jsonAppendRawNZ(&jx, "null", 4);\n<line90>}\n<line91>}else if( j==JSON_LOOKUP_ERROR ){\n<line92>sqlite3_result_error(ctx, "malformed JSON", -1);\n<line93>goto json_extract_error;\n<line94>}else{\n<line95>jsonBadPathError(ctx, zPath);\n<line96>goto json_extract_error;\n<line97>}\n<line98>}\n<line99>if( argc>2 ){\n<line100>jsonAppendChar(&jx, ']');\n<line101>jsonReturnString(&jx, 0, 0);\n<line102>if( (flags & JSON_BLOB)==0 ){\n<line103>sqlite3_result_subtype(ctx, JSON_SUBTYPE);\n<line104>}\n<line105>}\n<line106>json_extract_error:\n<line107>jsonStringReset(&jx);\n<line108>jsonParseFree(p);\n<line109>return;\n<line110>}
----------------------------------------
Function: jsonMergePatch
Content: <line0>static int jsonMergePatch(\n<line1>JsonParse *pTarget,      /* The JSON parser that contains the TARGET */\n<line2>u32 iTarget,             /* Index of TARGET in pTarget->aBlob[] */\n<line3>const JsonParse *pPatch, /* The PATCH */\n<line4>u32 iPatch               /* Index of PATCH in pPatch->aBlob[] */\n<line5>){\n<line6>u8 x;             /* Type of a single node */\n<line7>u32 n, sz=0;      /* Return values from jsonbPayloadSize() */\n<line8>u32 iTCursor;     /* Cursor position while scanning the target object */\n<line9>u32 iTStart;      /* First label in the target object */\n<line10>u32 iTEndBE;      /* Original first byte past end of target, before edit */\n<line11>u32 iTEnd;        /* Current first byte past end of target */\n<line12>u8 eTLabel;       /* Node type of the target label */\n<line13>u32 iTLabel = 0;  /* Index of the label */\n<line14>u32 nTLabel = 0;  /* Header size in bytes for the target label */\n<line15>u32 szTLabel = 0; /* Size of the target label payload */\n<line16>u32 iTValue = 0;  /* Index of the target value */\n<line17>u32 nTValue = 0;  /* Header size of the target value */\n<line18>u32 szTValue = 0; /* Payload size for the target value */\n<line19>u32 iPCursor;     /* Cursor position while scanning the patch */\n<line20>u32 iPEnd;        /* First byte past the end of the patch */\n<line21>u8 ePLabel;       /* Node type of the patch label */\n<line22>u32 iPLabel;      /* Start of patch label */\n<line23>u32 nPLabel;      /* Size of header on the patch label */\n<line24>u32 szPLabel;     /* Payload size of the patch label */\n<line25>u32 iPValue;      /* Start of patch value */\n<line26>u32 nPValue;      /* Header size for the patch value */\n<line27>u32 szPValue;     /* Payload size of the patch value */\n<line28>assert( iTarget>=0 && iTarget<pTarget->nBlob );\n<line29>assert( iPatch>=0 && iPatch<pPatch->nBlob );\n<line30>x = pPatch->aBlob[iPatch] & 0x0f;\n<line31>if( x!=JSONB_OBJECT ){  /* Algorithm line 02 */\n<line32>u32 szPatch;        /* Total size of the patch, header+payload */\n<line33>u32 szTarget;       /* Total size of the target, header+payload */\n<line34>n = jsonbPayloadSize(pPatch, iPatch, &sz);\n<line35>szPatch = n+sz;\n<line36>sz = 0;\n<line37>n = jsonbPayloadSize(pTarget, iTarget, &sz);\n<line38>szTarget = n+sz;\n<line39>jsonBlobEdit(pTarget, iTarget, szTarget, pPatch->aBlob+iPatch, szPatch);\n<line40>return pTarget->oom ? JSON_MERGE_OOM : JSON_MERGE_OK;  /* Line 03 */\n<line41>}\n<line42>x = pTarget->aBlob[iTarget] & 0x0f;\n<line43>if( x!=JSONB_OBJECT ){  /* Algorithm line 05 */\n<line44>n = jsonbPayloadSize(pTarget, iTarget, &sz);\n<line45>jsonBlobEdit(pTarget, iTarget+n, sz, 0, 0);\n<line46>x = pTarget->aBlob[iTarget];\n<line47>pTarget->aBlob[iTarget] = (x & 0xf0) | JSONB_OBJECT;\n<line48>}\n<line49>n = jsonbPayloadSize(pPatch, iPatch, &sz);\n<line50>if( NEVER(n==0) ) return JSON_MERGE_BADPATCH;\n<line51>iPCursor = iPatch+n;\n<line52>iPEnd = iPCursor+sz;\n<line53>n = jsonbPayloadSize(pTarget, iTarget, &sz);\n<line54>if( NEVER(n==0) ) return JSON_MERGE_BADTARGET;\n<line55>iTStart = iTarget+n;\n<line56>iTEndBE = iTStart+sz;\n<line57>while( iPCursor<iPEnd ){  /* Algorithm line 07 */\n<line58>iPLabel = iPCursor;\n<line59>ePLabel = pPatch->aBlob[iPCursor] & 0x0f;\n<line60>if( ePLabel<JSONB_TEXT || ePLabel>JSONB_TEXTRAW ){\n<line61>return JSON_MERGE_BADPATCH;\n<line62>}\n<line63>nPLabel = jsonbPayloadSize(pPatch, iPCursor, &szPLabel);\n<line64>if( nPLabel==0 ) return JSON_MERGE_BADPATCH;\n<line65>iPValue = iPCursor + nPLabel + szPLabel;\n<line66>if( iPValue>=iPEnd ) return JSON_MERGE_BADPATCH;\n<line67>nPValue = jsonbPayloadSize(pPatch, iPValue, &szPValue);\n<line68>if( nPValue==0 ) return JSON_MERGE_BADPATCH;\n<line69>iPCursor = iPValue + nPValue + szPValue;\n<line70>if( iPCursor>iPEnd ) return JSON_MERGE_BADPATCH;\n<line71>iTCursor = iTStart;\n<line72>iTEnd = iTEndBE + pTarget->delta;\n<line73>while( iTCursor<iTEnd ){\n<line74>int isEqual;   /* true if the patch and target labels match */\n<line75>iTLabel = iTCursor;\n<line76>eTLabel = pTarget->aBlob[iTCursor] & 0x0f;\n<line77>if( eTLabel<JSONB_TEXT || eTLabel>JSONB_TEXTRAW ){\n<line78>return JSON_MERGE_BADTARGET;\n<line79>}\n<line80>nTLabel = jsonbPayloadSize(pTarget, iTCursor, &szTLabel);\n<line81>if( nTLabel==0 ) return JSON_MERGE_BADTARGET;\n<line82>iTValue = iTLabel + nTLabel + szTLabel;\n<line83>if( iTValue>=iTEnd ) return JSON_MERGE_BADTARGET;\n<line84>nTValue = jsonbPayloadSize(pTarget, iTValue, &szTValue);\n<line85>if( nTValue==0 ) return JSON_MERGE_BADTARGET;\n<line86>if( iTValue + nTValue + szTValue > iTEnd ) return JSON_MERGE_BADTARGET;\n<line87>isEqual = jsonLabelCompare(\n<line88>(const char*)&pPatch->aBlob[iPLabel+nPLabel],\n<line89>szPLabel,\n<line90>(ePLabel==JSONB_TEXT || ePLabel==JSONB_TEXTRAW),\n<line91>(const char*)&pTarget->aBlob[iTLabel+nTLabel],\n<line92>szTLabel,\n<line93>(eTLabel==JSONB_TEXT || eTLabel==JSONB_TEXTRAW));\n<line94>if( isEqual ) break;\n<line95>iTCursor = iTValue + nTValue + szTValue;\n<line96>}\n<line97>x = pPatch->aBlob[iPValue] & 0x0f;\n<line98>if( iTCursor<iTEnd ){\n<line99>/* A match was found.  Algorithm line 08 */\n<line100>if( x==0 ){\n<line101>/* Patch value is NULL.  Algorithm line 09 */\n<line102>jsonBlobEdit(pTarget, iTLabel, nTLabel+szTLabel+nTValue+szTValue, 0,0);\n<line103>/*  vvvvvv----- No OOM on a delete-only edit */\n<line104>if( NEVER(pTarget->oom) ) return JSON_MERGE_OOM;\n<line105>}else{\n<line106>/* Algorithm line 12 */\n<line107>int rc, savedDelta = pTarget->delta;\n<line108>pTarget->delta = 0;\n<line109>rc = jsonMergePatch(pTarget, iTValue, pPatch, iPValue);\n<line110>if( rc ) return rc;\n<line111>pTarget->delta += savedDelta;\n<line112>}\n<line113>}else if( x>0 ){  /* Algorithm line 13 */\n<line114>/* No match and patch value is not NULL */\n<line115>u32 szNew = szPLabel+nPLabel;\n<line116>if( (pPatch->aBlob[iPValue] & 0x0f)!=JSONB_OBJECT ){  /* Line 14 */\n<line117>jsonBlobEdit(pTarget, iTEnd, 0, 0, szPValue+nPValue+szNew);\n<line118>if( pTarget->oom ) return JSON_MERGE_OOM;\n<line119>memcpy(&pTarget->aBlob[iTEnd], &pPatch->aBlob[iPLabel], szNew);\n<line120>memcpy(&pTarget->aBlob[iTEnd+szNew],\n<line121>&pPatch->aBlob[iPValue], szPValue+nPValue);\n<line122>}else{\n<line123>int rc, savedDelta;\n<line124>jsonBlobEdit(pTarget, iTEnd, 0, 0, szNew+1);\n<line125>if( pTarget->oom ) return JSON_MERGE_OOM;\n<line126>memcpy(&pTarget->aBlob[iTEnd], &pPatch->aBlob[iPLabel], szNew);\n<line127>pTarget->aBlob[iTEnd+szNew] = 0x00;\n<line128>savedDelta = pTarget->delta;\n<line129>pTarget->delta = 0;\n<line130>rc = jsonMergePatch(pTarget, iTEnd+szNew,pPatch,iPValue);\n<line131>if( rc ) return rc;\n<line132>pTarget->delta += savedDelta;\n<line133>}\n<line134>}\n<line135>}\n<line136>if( pTarget->delta ) jsonAfterEditSizeAdjust(pTarget, iTarget);\n<line137>return pTarget->oom ? JSON_MERGE_OOM : JSON_MERGE_OK;\n<line138>}
----------------------------------------
Function: jsonPatchFunc
Content: <line0>static void jsonPatchFunc(\n<line1>sqlite3_context *ctx,\n<line2>int argc,\n<line3>sqlite3_value **argv\n<line4>){\n<line5>JsonParse *pTarget;    /* The TARGET */\n<line6>JsonParse *pPatch;     /* The PATCH */\n<line7>int rc;                /* Result code */\n<line8>UNUSED_PARAMETER(argc);\n<line9>assert( argc==2 );\n<line10>pTarget = jsonParseFuncArg(ctx, argv[0], JSON_EDITABLE);\n<line11>if( pTarget==0 ) return;\n<line12>pPatch = jsonParseFuncArg(ctx, argv[1], 0);\n<line13>if( pPatch ){\n<line14>rc = jsonMergePatch(pTarget, 0, pPatch, 0);\n<line15>if( rc==JSON_MERGE_OK ){\n<line16>jsonReturnParse(ctx, pTarget);\n<line17>}else if( rc==JSON_MERGE_OOM ){\n<line18>sqlite3_result_error_nomem(ctx);\n<line19>}else{\n<line20>sqlite3_result_error(ctx, "malformed JSON", -1);\n<line21>}\n<line22>jsonParseFree(pPatch);\n<line23>}\n<line24>jsonParseFree(pTarget);\n<line25>}
----------------------------------------
Function: jsonObjectFunc
Content: <line0>static void jsonObjectFunc(\n<line1>sqlite3_context *ctx,\n<line2>int argc,\n<line3>sqlite3_value **argv\n<line4>){\n<line5>int i;\n<line6>JsonString jx;\n<line7>const char *z;\n<line8>u32 n;\n<line9>if( argc&1 ){\n<line10>sqlite3_result_error(ctx, "json_object() requires an even number "\n<line11>"of arguments", -1);\n<line12>return;\n<line13>}\n<line14>jsonStringInit(&jx, ctx);\n<line15>jsonAppendChar(&jx, '{');\n<line16>for(i=0; i<argc; i+=2){\n<line17>if( sqlite3_value_type(argv[i])!=SQLITE_TEXT ){\n<line18>sqlite3_result_error(ctx, "json_object() labels must be TEXT", -1);\n<line19>jsonStringReset(&jx);\n<line20>return;\n<line21>}\n<line22>jsonAppendSeparator(&jx);\n<line23>z = (const char*)sqlite3_value_text(argv[i]);\n<line24>n = sqlite3_value_bytes(argv[i]);\n<line25>jsonAppendString(&jx, z, n);\n<line26>jsonAppendChar(&jx, ':');\n<line27>jsonAppendSqlValue(&jx, argv[i+1]);\n<line28>}\n<line29>jsonAppendChar(&jx, '}');\n<line30>jsonReturnString(&jx, 0, 0);\n<line31>sqlite3_result_subtype(ctx, JSON_SUBTYPE);\n<line32>}
----------------------------------------
Function: jsonRemoveFunc
Content: <line0>static void jsonRemoveFunc(\n<line1>sqlite3_context *ctx,\n<line2>int argc,\n<line3>sqlite3_value **argv\n<line4>){\n<line5>JsonParse *p;          /* The parse */\n<line6>const char *zPath = 0; /* Path of element to be removed */\n<line7>int i;                 /* Loop counter */\n<line8>u32 rc;                /* Subroutine return code */\n<line9>if( argc<1 ) return;\n<line10>p = jsonParseFuncArg(ctx, argv[0], argc>1 ? JSON_EDITABLE : 0);\n<line11>if( p==0 ) return;\n<line12>for(i=1; i<argc; i++){\n<line13>zPath = (const char*)sqlite3_value_text(argv[i]);\n<line14>if( zPath==0 ){\n<line15>goto json_remove_done;\n<line16>}\n<line17>if( zPath[0]!='$' ){\n<line18>goto json_remove_patherror;\n<line19>}\n<line20>if( zPath[1]==0 ){\n<line21>/* json_remove(j,'$') returns NULL */\n<line22>goto json_remove_done;\n<line23>}\n<line24>p->eEdit = JEDIT_DEL;\n<line25>p->delta = 0;\n<line26>rc = jsonLookupStep(p, 0, zPath+1, 0);\n<line27>if( JSON_LOOKUP_ISERROR(rc) ){\n<line28>if( rc==JSON_LOOKUP_NOTFOUND ){\n<line29>continue;  /* No-op */\n<line30>}else if( rc==JSON_LOOKUP_PATHERROR ){\n<line31>jsonBadPathError(ctx, zPath);\n<line32>}else{\n<line33>sqlite3_result_error(ctx, "malformed JSON", -1);\n<line34>}\n<line35>goto json_remove_done;\n<line36>}\n<line37>}\n<line38>jsonReturnParse(ctx, p);\n<line39>jsonParseFree(p);\n<line40>return;\n<line41>json_remove_patherror:\n<line42>jsonBadPathError(ctx, zPath);\n<line43>json_remove_done:\n<line44>jsonParseFree(p);\n<line45>return;\n<line46>}
----------------------------------------
Function: jsonReplaceFunc
Content: <line0>static void jsonReplaceFunc(\n<line1>sqlite3_context *ctx,\n<line2>int argc,\n<line3>sqlite3_value **argv\n<line4>){\n<line5>if( argc<1 ) return;\n<line6>if( (argc&1)==0 ) {\n<line7>jsonWrongNumArgs(ctx, "replace");\n<line8>return;\n<line9>}\n<line10>jsonInsertIntoBlob(ctx, argc, argv, JEDIT_REPL);\n<line11>}
----------------------------------------
Function: jsonSetFunc
Content: <line0>static void jsonSetFunc(\n<line1>sqlite3_context *ctx,\n<line2>int argc,\n<line3>sqlite3_value **argv\n<line4>){\n<line5>int flags = SQLITE_PTR_TO_INT(sqlite3_user_data(ctx));\n<line6>int bIsSet = (flags&JSON_ISSET)!=0;\n<line7>if( argc<1 ) return;\n<line8>if( (argc&1)==0 ) {\n<line9>jsonWrongNumArgs(ctx, bIsSet ? "set" : "insert");\n<line10>return;\n<line11>}\n<line12>jsonInsertIntoBlob(ctx, argc, argv, bIsSet ? JEDIT_SET : JEDIT_INS);\n<line13>}
----------------------------------------
Function: jsonTypeFunc
Content: <line0>static void jsonTypeFunc(\n<line1>sqlite3_context *ctx,\n<line2>int argc,\n<line3>sqlite3_value **argv\n<line4>){\n<line5>JsonParse *p;          /* The parse */\n<line6>const char *zPath = 0;\n<line7>u32 i;\n<line8>p = jsonParseFuncArg(ctx, argv[0], 0);\n<line9>if( p==0 ) return;\n<line10>if( argc==2 ){\n<line11>zPath = (const char*)sqlite3_value_text(argv[1]);\n<line12>if( zPath==0 ) goto json_type_done;\n<line13>if( zPath[0]!='$' ){\n<line14>jsonBadPathError(ctx, zPath);\n<line15>goto json_type_done;\n<line16>}\n<line17>i = jsonLookupStep(p, 0, zPath+1, 0);\n<line18>if( JSON_LOOKUP_ISERROR(i) ){\n<line19>if( i==JSON_LOOKUP_NOTFOUND ){\n<line20>/* no-op */\n<line21>}else if( i==JSON_LOOKUP_PATHERROR ){\n<line22>jsonBadPathError(ctx, zPath);\n<line23>}else{\n<line24>sqlite3_result_error(ctx, "malformed JSON", -1);\n<line25>}\n<line26>goto json_type_done;\n<line27>}\n<line28>}else{\n<line29>i = 0;\n<line30>}\n<line31>sqlite3_result_text(ctx, jsonbType[p->aBlob[i]&0x0f], -1, SQLITE_STATIC);\n<line32>json_type_done:\n<line33>jsonParseFree(p);\n<line34>}
----------------------------------------
Function: jsonPrettyFunc
Content: <line0>static void jsonPrettyFunc(\n<line1>sqlite3_context *ctx,\n<line2>int argc,\n<line3>sqlite3_value **argv\n<line4>){\n<line5>JsonString s;          /* The output string */\n<line6>JsonPretty x;          /* Pretty printing context */\n<line7>memset(&x, 0, sizeof(x));\n<line8>x.pParse = jsonParseFuncArg(ctx, argv[0], 0);\n<line9>if( x.pParse==0 ) return;\n<line10>x.pOut = &s;\n<line11>jsonStringInit(&s, ctx);\n<line12>if( argc==1 || (x.zIndent = (const char*)sqlite3_value_text(argv[1]))==0 ){\n<line13>x.zIndent = "    ";\n<line14>x.szIndent = 4;\n<line15>}else{\n<line16>x.szIndent = (u32)strlen(x.zIndent);\n<line17>}\n<line18>jsonTranslateBlobToPrettyText(&x, 0);\n<line19>jsonReturnString(&s, 0, 0);\n<line20>jsonParseFree(x.pParse);\n<line21>}
----------------------------------------
Function: jsonValidFunc
Content: <line0>static void jsonValidFunc(\n<line1>sqlite3_context *ctx,\n<line2>int argc,\n<line3>sqlite3_value **argv\n<line4>){\n<line5>JsonParse *p;          /* The parse */\n<line6>u8 flags = 1;\n<line7>u8 res = 0;\n<line8>if( argc==2 ){\n<line9>i64 f = sqlite3_value_int64(argv[1]);\n<line10>if( f<1 || f>15 ){\n<line11>sqlite3_result_error(ctx, "FLAGS parameter to json_valid() must be"\n<line12>" between 1 and 15", -1);\n<line13>return;\n<line14>}\n<line15>flags = f & 0x0f;\n<line16>}\n<line17>switch( sqlite3_value_type(argv[0]) ){\n<line18>case SQLITE_NULL: {\n<line19>#ifdef SQLITE_LEGACY_JSON_VALID\n<line20>/* Incorrect legacy behavior was to return FALSE for a NULL input */\n<line21>sqlite3_result_int(ctx, 0);\n<line22>#endif\n<line23>return;\n<line24>}\n<line25>case SQLITE_BLOB: {\n<line26>JsonParse py;\n<line27>memset(&py, 0, sizeof(py));\n<line28>if( jsonArgIsJsonb(argv[0], &py) ){\n<line29>if( flags & 0x04 ){\n<line30>/* Superficial checking only - accomplished by the\n<line31>** jsonArgIsJsonb() call above. */\n<line32>res = 1;\n<line33>}else if( flags & 0x08 ){\n<line34>/* Strict checking.  Check by translating BLOB->TEXT->BLOB.  If\n<line35>** no errors occur, call that a "strict check". */\n<line36>res = 0==jsonbValidityCheck(&py, 0, py.nBlob, 1);\n<line37>}\n<line38>break;\n<line39>}\n<line40>/* Fall through into interpreting the input as text.  See note\n<line41>** above at tag-20240123-a. */\n<line42>/* no break */ deliberate_fall_through\n<line43>}\n<line44>default: {\n<line45>JsonParse px;\n<line46>if( (flags & 0x3)==0 ) break;\n<line47>memset(&px, 0, sizeof(px));\n<line48>p = jsonParseFuncArg(ctx, argv[0], JSON_KEEPERROR);\n<line49>if( p ){\n<line50>if( p->oom ){\n<line51>sqlite3_result_error_nomem(ctx);\n<line52>}else if( p->nErr ){\n<line53>/* no-op */\n<line54>}else if( (flags & 0x02)!=0 || p->hasNonstd==0 ){\n<line55>res = 1;\n<line56>}\n<line57>jsonParseFree(p);\n<line58>}else{\n<line59>sqlite3_result_error_nomem(ctx);\n<line60>}\n<line61>break;\n<line62>}\n<line63>}\n<line64>sqlite3_result_int(ctx, res);\n<line65>}
----------------------------------------
Function: jsonErrorFunc
Content: <line0>static void jsonErrorFunc(\n<line1>sqlite3_context *ctx,\n<line2>int argc,\n<line3>sqlite3_value **argv\n<line4>){\n<line5>i64 iErrPos = 0;       /* Error position to be returned */\n<line6>JsonParse s;\n<line7>assert( argc==1 );\n<line8>UNUSED_PARAMETER(argc);\n<line9>memset(&s, 0, sizeof(s));\n<line10>s.db = sqlite3_context_db_handle(ctx);\n<line11>if( jsonArgIsJsonb(argv[0], &s) ){\n<line12>iErrPos = (i64)jsonbValidityCheck(&s, 0, s.nBlob, 1);\n<line13>}else{\n<line14>s.zJson = (char*)sqlite3_value_text(argv[0]);\n<line15>if( s.zJson==0 ) return;  /* NULL input or OOM */\n<line16>s.nJson = sqlite3_value_bytes(argv[0]);\n<line17>if( jsonConvertTextToBlob(&s,0) ){\n<line18>if( s.oom ){\n<line19>iErrPos = -1;\n<line20>}else{\n<line21>/* Convert byte-offset s.iErr into a character offset */\n<line22>u32 k;\n<line23>assert( s.zJson!=0 );  /* Because s.oom is false */\n<line24>for(k=0; k<s.iErr && ALWAYS(s.zJson[k]); k++){\n<line25>if( (s.zJson[k] & 0xc0)!=0x80 ) iErrPos++;\n<line26>}\n<line27>iErrPos++;\n<line28>}\n<line29>}\n<line30>}\n<line31>jsonParseReset(&s);\n<line32>if( iErrPos<0 ){\n<line33>sqlite3_result_error_nomem(ctx);\n<line34>}else{\n<line35>sqlite3_result_int64(ctx, iErrPos);\n<line36>}\n<line37>}
----------------------------------------
Function: jsonArrayStep
Content: <line0>static void jsonArrayStep(\n<line1>sqlite3_context *ctx,\n<line2>int argc,\n<line3>sqlite3_value **argv\n<line4>){\n<line5>JsonString *pStr;\n<line6>UNUSED_PARAMETER(argc);\n<line7>pStr = (JsonString*)sqlite3_aggregate_context(ctx, sizeof(*pStr));\n<line8>if( pStr ){\n<line9>if( pStr->zBuf==0 ){\n<line10>jsonStringInit(pStr, ctx);\n<line11>jsonAppendChar(pStr, '[');\n<line12>}else if( pStr->nUsed>1 ){\n<line13>jsonAppendChar(pStr, ',');\n<line14>}\n<line15>pStr->pCtx = ctx;\n<line16>jsonAppendSqlValue(pStr, argv[0]);\n<line17>}\n<line18>}
----------------------------------------
Function: jsonArrayCompute
Content: <line0>static void jsonArrayCompute(sqlite3_context *ctx, int isFinal){\n<line1>JsonString *pStr;\n<line2>pStr = (JsonString*)sqlite3_aggregate_context(ctx, 0);\n<line3>if( pStr ){\n<line4>int flags;\n<line5>pStr->pCtx = ctx;\n<line6>jsonAppendChar(pStr, ']');\n<line7>flags = SQLITE_PTR_TO_INT(sqlite3_user_data(ctx));\n<line8>if( pStr->eErr ){\n<line9>jsonReturnString(pStr, 0, 0);\n<line10>return;\n<line11>}else if( flags & JSON_BLOB ){\n<line12>jsonReturnStringAsBlob(pStr);\n<line13>if( isFinal ){\n<line14>if( !pStr->bStatic ) sqlite3RCStrUnref(pStr->zBuf);\n<line15>}else{\n<line16>jsonStringTrimOneChar(pStr);\n<line17>}\n<line18>return;\n<line19>}else if( isFinal ){\n<line20>sqlite3_result_text(ctx, pStr->zBuf, (int)pStr->nUsed,\n<line21>pStr->bStatic ? SQLITE_TRANSIENT :\n<line22>sqlite3RCStrUnref);\n<line23>pStr->bStatic = 1;\n<line24>}else{\n<line25>sqlite3_result_text(ctx, pStr->zBuf, (int)pStr->nUsed, SQLITE_TRANSIENT);\n<line26>jsonStringTrimOneChar(pStr);\n<line27>}\n<line28>}else{\n<line29>sqlite3_result_text(ctx, "[]", 2, SQLITE_STATIC);\n<line30>}\n<line31>sqlite3_result_subtype(ctx, JSON_SUBTYPE);\n<line32>}
----------------------------------------
Function: jsonArrayValue
Content: <line0>static void jsonArrayValue(sqlite3_context *ctx){\n<line1>jsonArrayCompute(ctx, 0);\n<line2>}
----------------------------------------
Function: jsonArrayFinal
Content: <line0>static void jsonArrayFinal(sqlite3_context *ctx){\n<line1>jsonArrayCompute(ctx, 1);\n<line2>}
----------------------------------------
Function: jsonGroupInverse
Content: <line0>static void jsonGroupInverse(\n<line1>sqlite3_context *ctx,\n<line2>int argc,\n<line3>sqlite3_value **argv\n<line4>){\n<line5>unsigned int i;\n<line6>int inStr = 0;\n<line7>int nNest = 0;\n<line8>char *z;\n<line9>char c;\n<line10>JsonString *pStr;\n<line11>UNUSED_PARAMETER(argc);\n<line12>UNUSED_PARAMETER(argv);\n<line13>pStr = (JsonString*)sqlite3_aggregate_context(ctx, 0);\n<line14>#ifdef NEVER\n<line15>/* pStr is always non-NULL since jsonArrayStep() or jsonObjectStep() will\n<line16>** always have been called to initialize it */\n<line17>if( NEVER(!pStr) ) return;\n<line18>#endif\n<line19>z = pStr->zBuf;\n<line20>for(i=1; i<pStr->nUsed && ((c = z[i])!=',' || inStr || nNest); i++){\n<line21>if( c=='"' ){\n<line22>inStr = !inStr;\n<line23>}else if( c=='\\' ){\n<line24>i++;\n<line25>}else if( !inStr ){\n<line26>if( c=='{' || c=='[' ) nNest++;\n<line27>if( c=='}' || c==']' ) nNest--;\n<line28>}\n<line29>}\n<line30>if( i<pStr->nUsed ){\n<line31>pStr->nUsed -= i;\n<line32>memmove(&z[1], &z[i+1], (size_t)pStr->nUsed-1);\n<line33>z[pStr->nUsed] = 0;\n<line34>}else{\n<line35>pStr->nUsed = 1;\n<line36>}\n<line37>}
----------------------------------------
Function: jsonObjectStep
Content: <line0>static void jsonObjectStep(\n<line1>sqlite3_context *ctx,\n<line2>int argc,\n<line3>sqlite3_value **argv\n<line4>){\n<line5>JsonString *pStr;\n<line6>const char *z;\n<line7>u32 n;\n<line8>UNUSED_PARAMETER(argc);\n<line9>pStr = (JsonString*)sqlite3_aggregate_context(ctx, sizeof(*pStr));\n<line10>if( pStr ){\n<line11>z = (const char*)sqlite3_value_text(argv[0]);\n<line12>n = sqlite3Strlen30(z);\n<line13>if( pStr->zBuf==0 ){\n<line14>jsonStringInit(pStr, ctx);\n<line15>jsonAppendChar(pStr, '{');\n<line16>}else if( pStr->nUsed>1 && z!=0 ){\n<line17>jsonAppendChar(pStr, ',');\n<line18>}\n<line19>pStr->pCtx = ctx;\n<line20>if( z!=0 ){\n<line21>jsonAppendString(pStr, z, n);\n<line22>jsonAppendChar(pStr, ':');\n<line23>jsonAppendSqlValue(pStr, argv[1]);\n<line24>}\n<line25>}\n<line26>}
----------------------------------------
Function: jsonObjectCompute
Content: <line0>static void jsonObjectCompute(sqlite3_context *ctx, int isFinal){\n<line1>JsonString *pStr;\n<line2>pStr = (JsonString*)sqlite3_aggregate_context(ctx, 0);\n<line3>if( pStr ){\n<line4>int flags;\n<line5>jsonAppendChar(pStr, '}');\n<line6>pStr->pCtx = ctx;\n<line7>flags = SQLITE_PTR_TO_INT(sqlite3_user_data(ctx));\n<line8>if( pStr->eErr ){\n<line9>jsonReturnString(pStr, 0, 0);\n<line10>return;\n<line11>}else if( flags & JSON_BLOB ){\n<line12>jsonReturnStringAsBlob(pStr);\n<line13>if( isFinal ){\n<line14>if( !pStr->bStatic ) sqlite3RCStrUnref(pStr->zBuf);\n<line15>}else{\n<line16>jsonStringTrimOneChar(pStr);\n<line17>}\n<line18>return;\n<line19>}else if( isFinal ){\n<line20>sqlite3_result_text(ctx, pStr->zBuf, (int)pStr->nUsed,\n<line21>pStr->bStatic ? SQLITE_TRANSIENT :\n<line22>sqlite3RCStrUnref);\n<line23>pStr->bStatic = 1;\n<line24>}else{\n<line25>sqlite3_result_text(ctx, pStr->zBuf, (int)pStr->nUsed, SQLITE_TRANSIENT);\n<line26>jsonStringTrimOneChar(pStr);\n<line27>}\n<line28>}else{\n<line29>sqlite3_result_text(ctx, "{}", 2, SQLITE_STATIC);\n<line30>}\n<line31>sqlite3_result_subtype(ctx, JSON_SUBTYPE);\n<line32>}
----------------------------------------
Function: jsonObjectValue
Content: <line0>static void jsonObjectValue(sqlite3_context *ctx){\n<line1>jsonObjectCompute(ctx, 0);\n<line2>}
----------------------------------------
Function: jsonObjectFinal
Content: <line0>static void jsonObjectFinal(sqlite3_context *ctx){\n<line1>jsonObjectCompute(ctx, 1);\n<line2>}
----------------------------------------
Function: jsonEachConnect
Content: <line0>static int jsonEachConnect(\n<line1>sqlite3 *db,\n<line2>void *pAux,\n<line3>int argc, const char *const*argv,\n<line4>sqlite3_vtab **ppVtab,\n<line5>char **pzErr\n<line6>){\n<line7>JsonEachConnection *pNew;\n<line8>int rc;\n<line9>/* Column numbers */\n<line10>#define JEACH_KEY     0\n<line11>#define JEACH_VALUE   1\n<line12>#define JEACH_TYPE    2\n<line13>#define JEACH_ATOM    3\n<line14>#define JEACH_ID      4\n<line15>#define JEACH_PARENT  5\n<line16>#define JEACH_FULLKEY 6\n<line17>#define JEACH_PATH    7\n<line18>/* The xBestIndex method assumes that the JSON and ROOT columns are\n<line19>** the last two columns in the table.  Should this ever changes, be\n<line20>** sure to update the xBestIndex method. */\n<line21>#define JEACH_JSON    8\n<line22>#define JEACH_ROOT    9\n<line23>UNUSED_PARAMETER(pzErr);\n<line24>UNUSED_PARAMETER(argv);\n<line25>UNUSED_PARAMETER(argc);\n<line26>UNUSED_PARAMETER(pAux);\n<line27>rc = sqlite3_declare_vtab(db,\n<line28>"CREATE TABLE x(key,value,type,atom,id,parent,fullkey,path,"\n<line29>"json HIDDEN,root HIDDEN)");\n<line30>if( rc==SQLITE_OK ){\n<line31>pNew = (JsonEachConnection*)sqlite3DbMallocZero(db, sizeof(*pNew));\n<line32>*ppVtab = (sqlite3_vtab*)pNew;\n<line33>if( pNew==0 ) return SQLITE_NOMEM;\n<line34>sqlite3_vtab_config(db, SQLITE_VTAB_INNOCUOUS);\n<line35>pNew->db = db;\n<line36>pNew->eMode = argv[0][4]=='b' ? 2 : 1;\n<line37>pNew->bRecursive = argv[0][4+pNew->eMode]=='t';\n<line38>}\n<line39>return rc;\n<line40>}
----------------------------------------
Function: jsonEachDisconnect
Content: <line0>static int jsonEachDisconnect(sqlite3_vtab *pVtab){\n<line1>JsonEachConnection *p = (JsonEachConnection*)pVtab;\n<line2>sqlite3DbFree(p->db, pVtab);\n<line3>return SQLITE_OK;\n<line4>}
----------------------------------------
Function: jsonEachOpen
Content: <line0>static int jsonEachOpen(sqlite3_vtab *p, sqlite3_vtab_cursor **ppCursor){\n<line1>JsonEachConnection *pVtab = (JsonEachConnection*)p;\n<line2>JsonEachCursor *pCur;\n<line3>UNUSED_PARAMETER(p);\n<line4>pCur = sqlite3DbMallocZero(pVtab->db, sizeof(*pCur));\n<line5>if( pCur==0 ) return SQLITE_NOMEM;\n<line6>pCur->db = pVtab->db;\n<line7>pCur->eMode = pVtab->eMode;\n<line8>pCur->bRecursive = pVtab->bRecursive;\n<line9>jsonStringZero(&pCur->path);\n<line10>*ppCursor = &pCur->base;\n<line11>return SQLITE_OK;\n<line12>}
----------------------------------------
Function: jsonEachCursorReset
Content: <line0>static void jsonEachCursorReset(JsonEachCursor *p){\n<line1>jsonParseReset(&p->sParse);\n<line2>jsonStringReset(&p->path);\n<line3>sqlite3DbFree(p->db, p->aParent);\n<line4>p->iRowid = 0;\n<line5>p->i = 0;\n<line6>p->aParent = 0;\n<line7>p->nParent = 0;\n<line8>p->nParentAlloc = 0;\n<line9>p->iEnd = 0;\n<line10>p->eType = 0;\n<line11>}
----------------------------------------
Function: jsonEachClose
Content: <line0>static int jsonEachClose(sqlite3_vtab_cursor *cur){\n<line1>JsonEachCursor *p = (JsonEachCursor*)cur;\n<line2>jsonEachCursorReset(p);\n<line3>sqlite3DbFree(p->db, cur);\n<line4>return SQLITE_OK;\n<line5>}
----------------------------------------
Function: jsonEachEof
Content: <line0>static int jsonEachEof(sqlite3_vtab_cursor *cur){\n<line1>JsonEachCursor *p = (JsonEachCursor*)cur;\n<line2>return p->i >= p->iEnd;\n<line3>}
----------------------------------------
Function: jsonSkipLabel
Content: <line0>static int jsonSkipLabel(JsonEachCursor *p){\n<line1>if( p->eType==JSONB_OBJECT ){\n<line2>u32 sz = 0;\n<line3>u32 n = jsonbPayloadSize(&p->sParse, p->i, &sz);\n<line4>return p->i + n + sz;\n<line5>}else{\n<line6>return p->i;\n<line7>}\n<line8>}
----------------------------------------
Function: jsonAppendPathName
Content: <line0>static void jsonAppendPathName(JsonEachCursor *p){\n<line1>assert( p->nParent>0 );\n<line2>assert( p->eType==JSONB_ARRAY || p->eType==JSONB_OBJECT );\n<line3>if( p->eType==JSONB_ARRAY ){\n<line4>jsonPrintf(30, &p->path, "[%lld]", p->aParent[p->nParent-1].iKey);\n<line5>}else{\n<line6>u32 n, sz = 0, k, i;\n<line7>const char *z;\n<line8>int needQuote = 0;\n<line9>n = jsonbPayloadSize(&p->sParse, p->i, &sz);\n<line10>k = p->i + n;\n<line11>z = (const char*)&p->sParse.aBlob[k];\n<line12>if( sz==0 || !sqlite3Isalpha(z[0]) ){\n<line13>needQuote = 1;\n<line14>}else{\n<line15>for(i=0; i<sz; i++){\n<line16>if( !sqlite3Isalnum(z[i]) ){\n<line17>needQuote = 1;\n<line18>break;\n<line19>}\n<line20>}\n<line21>}\n<line22>if( needQuote ){\n<line23>jsonPrintf(sz+4,&p->path,".\"%.*s\"", sz, z);\n<line24>}else{\n<line25>jsonPrintf(sz+2,&p->path,".%.*s", sz, z);\n<line26>}\n<line27>}\n<line28>}
----------------------------------------
Function: jsonEachNext
Content: <line0>static int jsonEachNext(sqlite3_vtab_cursor *cur){\n<line1>JsonEachCursor *p = (JsonEachCursor*)cur;\n<line2>int rc = SQLITE_OK;\n<line3>if( p->bRecursive ){\n<line4>u8 x;\n<line5>u8 levelChange = 0;\n<line6>u32 n, sz = 0;\n<line7>u32 i = jsonSkipLabel(p);\n<line8>x = p->sParse.aBlob[i] & 0x0f;\n<line9>n = jsonbPayloadSize(&p->sParse, i, &sz);\n<line10>if( x==JSONB_OBJECT || x==JSONB_ARRAY ){\n<line11>JsonParent *pParent;\n<line12>if( p->nParent>=p->nParentAlloc ){\n<line13>JsonParent *pNew;\n<line14>u64 nNew;\n<line15>nNew = p->nParentAlloc*2 + 3;\n<line16>pNew = sqlite3DbRealloc(p->db, p->aParent, sizeof(JsonParent)*nNew);\n<line17>if( pNew==0 ) return SQLITE_NOMEM;\n<line18>p->nParentAlloc = (u32)nNew;\n<line19>p->aParent = pNew;\n<line20>}\n<line21>levelChange = 1;\n<line22>pParent = &p->aParent[p->nParent];\n<line23>pParent->iHead = p->i;\n<line24>pParent->iValue = i;\n<line25>pParent->iEnd = i + n + sz;\n<line26>pParent->iKey = -1;\n<line27>pParent->nPath = (u32)p->path.nUsed;\n<line28>if( p->eType && p->nParent ){\n<line29>jsonAppendPathName(p);\n<line30>if( p->path.eErr ) rc = SQLITE_NOMEM;\n<line31>}\n<line32>p->nParent++;\n<line33>p->i = i + n;\n<line34>}else{\n<line35>p->i = i + n + sz;\n<line36>}\n<line37>while( p->nParent>0 && p->i >= p->aParent[p->nParent-1].iEnd ){\n<line38>p->nParent--;\n<line39>p->path.nUsed = p->aParent[p->nParent].nPath;\n<line40>levelChange = 1;\n<line41>}\n<line42>if( levelChange ){\n<line43>if( p->nParent>0 ){\n<line44>JsonParent *pParent = &p->aParent[p->nParent-1];\n<line45>u32 iVal = pParent->iValue;\n<line46>p->eType = p->sParse.aBlob[iVal] & 0x0f;\n<line47>}else{\n<line48>p->eType = 0;\n<line49>}\n<line50>}\n<line51>}else{\n<line52>u32 n, sz = 0;\n<line53>u32 i = jsonSkipLabel(p);\n<line54>n = jsonbPayloadSize(&p->sParse, i, &sz);\n<line55>p->i = i + n + sz;\n<line56>}\n<line57>if( p->eType==JSONB_ARRAY && p->nParent ){\n<line58>p->aParent[p->nParent-1].iKey++;\n<line59>}\n<line60>p->iRowid++;\n<line61>return rc;\n<line62>}
----------------------------------------
Function: jsonEachPathLength
Content: <line0>static int jsonEachPathLength(JsonEachCursor *p){\n<line1>u32 n = p->path.nUsed;\n<line2>char *z = p->path.zBuf;\n<line3>if( p->iRowid==0 && p->bRecursive && n>=2 ){\n<line4>while( n>1 ){\n<line5>n--;\n<line6>if( z[n]=='[' || z[n]=='.' ){\n<line7>u32 x, sz = 0;\n<line8>char cSaved = z[n];\n<line9>z[n] = 0;\n<line10>assert( p->sParse.eEdit==0 );\n<line11>x = jsonLookupStep(&p->sParse, 0, z+1, 0);\n<line12>z[n] = cSaved;\n<line13>if( JSON_LOOKUP_ISERROR(x) ) continue;\n<line14>if( x + jsonbPayloadSize(&p->sParse, x, &sz) == p->i ) break;\n<line15>}\n<line16>}\n<line17>}\n<line18>return n;\n<line19>}
----------------------------------------
Function: jsonEachColumn
Content: <line0>static int jsonEachColumn(\n<line1>sqlite3_vtab_cursor *cur,   /* The cursor */\n<line2>sqlite3_context *ctx,       /* First argument to sqlite3_result_...() */\n<line3>int iColumn                 /* Which column to return */\n<line4>){\n<line5>JsonEachCursor *p = (JsonEachCursor*)cur;\n<line6>switch( iColumn ){\n<line7>case JEACH_KEY: {\n<line8>if( p->nParent==0 ){\n<line9>u32 n, j;\n<line10>if( p->nRoot==1 ) break;\n<line11>j = jsonEachPathLength(p);\n<line12>n = p->nRoot - j;\n<line13>if( n==0 ){\n<line14>break;\n<line15>}else if( p->path.zBuf[j]=='[' ){\n<line16>i64 x;\n<line17>sqlite3Atoi64(&p->path.zBuf[j+1], &x, n-1, SQLITE_UTF8);\n<line18>sqlite3_result_int64(ctx, x);\n<line19>}else if( p->path.zBuf[j+1]=='"' ){\n<line20>sqlite3_result_text(ctx, &p->path.zBuf[j+2], n-3, SQLITE_TRANSIENT);\n<line21>}else{\n<line22>sqlite3_result_text(ctx, &p->path.zBuf[j+1], n-1, SQLITE_TRANSIENT);\n<line23>}\n<line24>break;\n<line25>}\n<line26>if( p->eType==JSONB_OBJECT ){\n<line27>jsonReturnFromBlob(&p->sParse, p->i, ctx, 1);\n<line28>}else{\n<line29>assert( p->eType==JSONB_ARRAY );\n<line30>sqlite3_result_int64(ctx, p->aParent[p->nParent-1].iKey);\n<line31>}\n<line32>break;\n<line33>}\n<line34>case JEACH_VALUE: {\n<line35>u32 i = jsonSkipLabel(p);\n<line36>jsonReturnFromBlob(&p->sParse, i, ctx, p->eMode);\n<line37>if( (p->sParse.aBlob[i] & 0x0f)>=JSONB_ARRAY ){\n<line38>sqlite3_result_subtype(ctx, JSON_SUBTYPE);\n<line39>}\n<line40>break;\n<line41>}\n<line42>case JEACH_TYPE: {\n<line43>u32 i = jsonSkipLabel(p);\n<line44>u8 eType = p->sParse.aBlob[i] & 0x0f;\n<line45>sqlite3_result_text(ctx, jsonbType[eType], -1, SQLITE_STATIC);\n<line46>break;\n<line47>}\n<line48>case JEACH_ATOM: {\n<line49>u32 i = jsonSkipLabel(p);\n<line50>if( (p->sParse.aBlob[i] & 0x0f)<JSONB_ARRAY ){\n<line51>jsonReturnFromBlob(&p->sParse, i, ctx, 1);\n<line52>}\n<line53>break;\n<line54>}\n<line55>case JEACH_ID: {\n<line56>sqlite3_result_int64(ctx, (sqlite3_int64)p->i);\n<line57>break;\n<line58>}\n<line59>case JEACH_PARENT: {\n<line60>if( p->nParent>0 && p->bRecursive ){\n<line61>sqlite3_result_int64(ctx, p->aParent[p->nParent-1].iHead);\n<line62>}\n<line63>break;\n<line64>}\n<line65>case JEACH_FULLKEY: {\n<line66>u64 nBase = p->path.nUsed;\n<line67>if( p->nParent ) jsonAppendPathName(p);\n<line68>sqlite3_result_text64(ctx, p->path.zBuf, p->path.nUsed,\n<line69>SQLITE_TRANSIENT, SQLITE_UTF8);\n<line70>p->path.nUsed = nBase;\n<line71>break;\n<line72>}\n<line73>case JEACH_PATH: {\n<line74>u32 n = jsonEachPathLength(p);\n<line75>sqlite3_result_text64(ctx, p->path.zBuf, n,\n<line76>SQLITE_TRANSIENT, SQLITE_UTF8);\n<line77>break;\n<line78>}\n<line79>default: {\n<line80>sqlite3_result_text(ctx, p->path.zBuf, p->nRoot, SQLITE_STATIC);\n<line81>break;\n<line82>}\n<line83>case JEACH_JSON: {\n<line84>if( p->sParse.zJson==0 ){\n<line85>sqlite3_result_blob(ctx, p->sParse.aBlob, p->sParse.nBlob,\n<line86>SQLITE_TRANSIENT);\n<line87>}else{\n<line88>sqlite3_result_text(ctx, p->sParse.zJson, -1, SQLITE_TRANSIENT);\n<line89>}\n<line90>break;\n<line91>}\n<line92>}\n<line93>return SQLITE_OK;\n<line94>}
----------------------------------------
Function: jsonEachRowid
Content: <line0>static int jsonEachRowid(sqlite3_vtab_cursor *cur, sqlite_int64 *pRowid){\n<line1>JsonEachCursor *p = (JsonEachCursor*)cur;\n<line2>*pRowid = p->iRowid;\n<line3>return SQLITE_OK;\n<line4>}
----------------------------------------
Function: jsonEachBestIndex
Content: <line0>static int jsonEachBestIndex(\n<line1>sqlite3_vtab *tab,\n<line2>sqlite3_index_info *pIdxInfo\n<line3>){\n<line4>int i;                     /* Loop counter or computed array index */\n<line5>int aIdx[2];               /* Index of constraints for JSON and ROOT */\n<line6>int unusableMask = 0;      /* Mask of unusable JSON and ROOT constraints */\n<line7>int idxMask = 0;           /* Mask of usable == constraints JSON and ROOT */\n<line8>const struct sqlite3_index_constraint *pConstraint;\n<line9>/* This implementation assumes that JSON and ROOT are the last two\n<line10>** columns in the table */\n<line11>assert( JEACH_ROOT == JEACH_JSON+1 );\n<line12>UNUSED_PARAMETER(tab);\n<line13>aIdx[0] = aIdx[1] = -1;\n<line14>pConstraint = pIdxInfo->aConstraint;\n<line15>for(i=0; i<pIdxInfo->nConstraint; i++, pConstraint++){\n<line16>int iCol;\n<line17>int iMask;\n<line18>if( pConstraint->iColumn < JEACH_JSON ) continue;\n<line19>iCol = pConstraint->iColumn - JEACH_JSON;\n<line20>assert( iCol==0 || iCol==1 );\n<line21>testcase( iCol==0 );\n<line22>iMask = 1 << iCol;\n<line23>if( pConstraint->usable==0 ){\n<line24>unusableMask |= iMask;\n<line25>}else if( pConstraint->op==SQLITE_INDEX_CONSTRAINT_EQ ){\n<line26>aIdx[iCol] = i;\n<line27>idxMask |= iMask;\n<line28>}\n<line29>}\n<line30>if( pIdxInfo->nOrderBy>0\n<line31>&& pIdxInfo->aOrderBy[0].iColumn<0\n<line32>&& pIdxInfo->aOrderBy[0].desc==0\n<line33>){\n<line34>pIdxInfo->orderByConsumed = 1;\n<line35>}\n<line36>if( (unusableMask & ~idxMask)!=0 ){\n<line37>/* If there are any unusable constraints on JSON or ROOT, then reject\n<line38>** this entire plan */\n<line39>return SQLITE_CONSTRAINT;\n<line40>}\n<line41>if( aIdx[0]<0 ){\n<line42>/* No JSON input.  Leave estimatedCost at the huge value that it was\n<line43>** initialized to to discourage the query planner from selecting this\n<line44>** plan. */\n<line45>pIdxInfo->idxNum = 0;\n<line46>}else{\n<line47>pIdxInfo->estimatedCost = 1.0;\n<line48>i = aIdx[0];\n<line49>pIdxInfo->aConstraintUsage[i].argvIndex = 1;\n<line50>pIdxInfo->aConstraintUsage[i].omit = 1;\n<line51>if( aIdx[1]<0 ){\n<line52>pIdxInfo->idxNum = 1;  /* Only JSON supplied.  Plan 1 */\n<line53>}else{\n<line54>i = aIdx[1];\n<line55>pIdxInfo->aConstraintUsage[i].argvIndex = 2;\n<line56>pIdxInfo->aConstraintUsage[i].omit = 1;\n<line57>pIdxInfo->idxNum = 3;  /* Both JSON and ROOT are supplied.  Plan 3 */\n<line58>}\n<line59>}\n<line60>return SQLITE_OK;\n<line61>}
----------------------------------------
Function: jsonEachFilter
Content: <line0>static int jsonEachFilter(\n<line1>sqlite3_vtab_cursor *cur,\n<line2>int idxNum, const char *idxStr,\n<line3>int argc, sqlite3_value **argv\n<line4>){\n<line5>JsonEachCursor *p = (JsonEachCursor*)cur;\n<line6>const char *zRoot = 0;\n<line7>u32 i, n, sz;\n<line8>UNUSED_PARAMETER(idxStr);\n<line9>UNUSED_PARAMETER(argc);\n<line10>jsonEachCursorReset(p);\n<line11>if( idxNum==0 ) return SQLITE_OK;\n<line12>memset(&p->sParse, 0, sizeof(p->sParse));\n<line13>p->sParse.nJPRef = 1;\n<line14>p->sParse.db = p->db;\n<line15>if( jsonArgIsJsonb(argv[0], &p->sParse) ){\n<line16>/* We have JSONB */\n<line17>}else{\n<line18>p->sParse.zJson = (char*)sqlite3_value_text(argv[0]);\n<line19>p->sParse.nJson = sqlite3_value_bytes(argv[0]);\n<line20>if( p->sParse.zJson==0 ){\n<line21>p->i = p->iEnd = 0;\n<line22>return SQLITE_OK;\n<line23>}\n<line24>if( jsonConvertTextToBlob(&p->sParse, 0) ){\n<line25>if( p->sParse.oom ){\n<line26>return SQLITE_NOMEM;\n<line27>}\n<line28>goto json_each_malformed_input;\n<line29>}\n<line30>}\n<line31>if( idxNum==3 ){\n<line32>zRoot = (const char*)sqlite3_value_text(argv[1]);\n<line33>if( zRoot==0 ) return SQLITE_OK;\n<line34>if( zRoot[0]!='$' ){\n<line35>sqlite3_free(cur->pVtab->zErrMsg);\n<line36>cur->pVtab->zErrMsg = jsonBadPathError(0, zRoot);\n<line37>jsonEachCursorReset(p);\n<line38>return cur->pVtab->zErrMsg ? SQLITE_ERROR : SQLITE_NOMEM;\n<line39>}\n<line40>p->nRoot = sqlite3Strlen30(zRoot);\n<line41>if( zRoot[1]==0 ){\n<line42>i = p->i = 0;\n<line43>p->eType = 0;\n<line44>}else{\n<line45>i = jsonLookupStep(&p->sParse, 0, zRoot+1, 0);\n<line46>if( JSON_LOOKUP_ISERROR(i) ){\n<line47>if( i==JSON_LOOKUP_NOTFOUND ){\n<line48>p->i = 0;\n<line49>p->eType = 0;\n<line50>p->iEnd = 0;\n<line51>return SQLITE_OK;\n<line52>}\n<line53>sqlite3_free(cur->pVtab->zErrMsg);\n<line54>cur->pVtab->zErrMsg = jsonBadPathError(0, zRoot);\n<line55>jsonEachCursorReset(p);\n<line56>return cur->pVtab->zErrMsg ? SQLITE_ERROR : SQLITE_NOMEM;\n<line57>}\n<line58>if( p->sParse.iLabel ){\n<line59>p->i = p->sParse.iLabel;\n<line60>p->eType = JSONB_OBJECT;\n<line61>}else{\n<line62>p->i = i;\n<line63>p->eType = JSONB_ARRAY;\n<line64>}\n<line65>}\n<line66>jsonAppendRaw(&p->path, zRoot, p->nRoot);\n<line67>}else{\n<line68>i = p->i = 0;\n<line69>p->eType = 0;\n<line70>p->nRoot = 1;\n<line71>jsonAppendRaw(&p->path, "$", 1);\n<line72>}\n<line73>p->nParent = 0;\n<line74>n = jsonbPayloadSize(&p->sParse, i, &sz);\n<line75>p->iEnd = i+n+sz;\n<line76>if( (p->sParse.aBlob[i] & 0x0f)>=JSONB_ARRAY && !p->bRecursive ){\n<line77>p->i = i + n;\n<line78>p->eType = p->sParse.aBlob[i] & 0x0f;\n<line79>p->aParent = sqlite3DbMallocZero(p->db, sizeof(JsonParent));\n<line80>if( p->aParent==0 ) return SQLITE_NOMEM;\n<line81>p->nParent = 1;\n<line82>p->nParentAlloc = 1;\n<line83>p->aParent[0].iKey = 0;\n<line84>p->aParent[0].iEnd = p->iEnd;\n<line85>p->aParent[0].iHead = p->i;\n<line86>p->aParent[0].iValue = i;\n<line87>}\n<line88>return SQLITE_OK;\n<line89>json_each_malformed_input:\n<line90>sqlite3_free(cur->pVtab->zErrMsg);\n<line91>cur->pVtab->zErrMsg = sqlite3_mprintf("malformed JSON");\n<line92>jsonEachCursorReset(p);\n<line93>return cur->pVtab->zErrMsg ? SQLITE_ERROR : SQLITE_NOMEM;\n<line94>}
----------------------------------------
Function: sqlite3_sourceid
Content: <line0>SQLITE_API const char *sqlite3_sourceid(void){ return SQLITE_SOURCE_ID; }
----------------------------------------
