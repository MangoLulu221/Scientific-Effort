========================================
/home/huihui/Downloads/coreutils-9.4/src/chroot.c
========================================
Function: uid_unset
Content: <line0>static inline bool uid_unset (uid_t uid) { return uid == (uid_t) -1; }
----------------------------------------
Function: gid_unset
Content: <line0>static inline bool gid_unset (gid_t gid) { return gid == (gid_t) -1; }
----------------------------------------
Function: parse_additional_groups
Content: <line0>static int\n<line1>parse_additional_groups (char const *groups, GETGROUPS_T **pgids,\n<line2>size_t *pn_gids, bool show_errors)\n<line3>{\n<line4>GETGROUPS_T *gids = nullptr;\n<line5>size_t n_gids_allocated = 0;\n<line6>size_t n_gids = 0;\n<line7>char *buffer = xstrdup (groups);\n<line8>char const *tmp;\n<line9>int ret = 0;\n<line10>for (tmp = strtok (buffer, ","); tmp; tmp = strtok (nullptr, ","))\n<line11>{\n<line12>struct group *g;\n<line13>uintmax_t value;\n<line14>if (xstrtoumax (tmp, nullptr, 10, &value, "") == LONGINT_OK\n<line15>&& value <= MAXGID)\n<line16>{\n<line17>while (isspace (to_uchar (*tmp)))\n<line18>tmp++;\n<line19>if (*tmp != '+')\n<line20>{\n<line21>/* Handle the case where the name is numeric.  */\n<line22>g = getgrnam (tmp);\n<line23>if (g != nullptr)\n<line24>value = g->gr_gid;\n<line25>}\n<line26>/* Flag that we've got a group from the number.  */\n<line27>g = (struct group *) (intptr_t) ! nullptr;\n<line28>}\n<line29>else\n<line30>{\n<line31>g = getgrnam (tmp);\n<line32>if (g != nullptr)\n<line33>value = g->gr_gid;\n<line34>}\n<line35>if (g == nullptr)\n<line36>{\n<line37>ret = -1;\n<line38>if (show_errors)\n<line39>{\n<line40>error (0, errno, _("invalid group %s"), quote (tmp));\n<line41>continue;\n<line42>}\n<line43>break;\n<line44>}\n<line45>if (n_gids == n_gids_allocated)\n<line46>gids = X2NREALLOC (gids, &n_gids_allocated);\n<line47>gids[n_gids++] = value;\n<line48>}\n<line49>if (ret == 0 && n_gids == 0)\n<line50>{\n<line51>if (show_errors)\n<line52>error (0, 0, _("invalid group list %s"), quote (groups));\n<line53>ret = -1;\n<line54>}\n<line55>*pgids = gids;\n<line56>if (ret == 0)\n<line57>*pn_gids = n_gids;\n<line58>free (buffer);\n<line59>return ret;\n<line60>}
----------------------------------------
Function: is_root
Content: <line0>static bool\n<line1>is_root (char const *dir)\n<line2>{\n<line3>char *resolved = canonicalize_file_name (dir);\n<line4>bool is_res_root = resolved && STREQ ("/", resolved);\n<line5>free (resolved);\n<line6>return is_res_root;\n<line7>}
----------------------------------------
Function: usage
Content: <line0>void\n<line1>usage (int status)\n<line2>{\n<line3>if (status != EXIT_SUCCESS)\n<line4>emit_try_help ();\n<line5>else\n<line6>{\n<line7>printf (_("\\n<line8>Usage: %s [OPTION] NEWROOT [COMMAND [ARG]...]\n\\n<line9>or:  %s OPTION\n\\n<line10>"), program_name, program_name);\n<line11>fputs (_("\\n<line12>Run COMMAND with root directory set to NEWROOT.\n\\n<line13>\n\\n<line14>"), stdout);\n<line15>fputs (_("\\n<line16>--groups=G_LIST        specify supplementary groups as g1,g2,..,gN\n\\n<line17>"), stdout);\n<line18>fputs (_("\\n<line19>--userspec=USER:GROUP  specify user and group (ID or name) to use\n\\n<line20>"), stdout);\n<line21>printf (_("\\n<line22>--skip-chdir           do not change working directory to %s\n\\n<line23>"), quoteaf ("/"));\n<line24>fputs (HELP_OPTION_DESCRIPTION, stdout);\n<line25>fputs (VERSION_OPTION_DESCRIPTION, stdout);\n<line26>fputs (_("\\n<line27>\n\\n<line28>If no command is given, run '\"$SHELL\" -i' (default: '/bin/sh -i').\n\\n<line29>"), stdout);\n<line30>emit_exec_status (PROGRAM_NAME);\n<line31>emit_ancillary_info (PROGRAM_NAME);\n<line32>}\n<line33>exit (status);\n<line34>}
----------------------------------------
Function: main
Content: <line0>int\n<line1>main (int argc, char **argv)\n<line2>{\n<line3>int c;\n<line4>/* Input user and groups spec.  */\n<line5>char *userspec = nullptr;\n<line6>char const *username = nullptr;\n<line7>char const *groups = nullptr;\n<line8>bool skip_chdir = false;\n<line9>/* Parsed user and group IDs.  */\n<line10>uid_t uid = -1;\n<line11>gid_t gid = -1;\n<line12>GETGROUPS_T *out_gids = nullptr;\n<line13>size_t n_gids = 0;\n<line14>initialize_main (&argc, &argv);\n<line15>set_program_name (argv[0]);\n<line16>setlocale (LC_ALL, "");\n<line17>bindtextdomain (PACKAGE, LOCALEDIR);\n<line18>textdomain (PACKAGE);\n<line19>initialize_exit_failure (EXIT_CANCELED);\n<line20>atexit (close_stdout);\n<line21>while ((c = getopt_long (argc, argv, "+", long_opts, nullptr)) != -1)\n<line22>{\n<line23>switch (c)\n<line24>{\n<line25>case USERSPEC:\n<line26>{\n<line27>userspec = optarg;\n<line28>/* Treat 'user:' just like 'user'\n<line29>as we lookup the primary group by default\n<line30>(and support doing so for UIDs as well as names.  */\n<line31>size_t userlen = strlen (userspec);\n<line32>if (userlen && userspec[userlen - 1] == ':')\n<line33>userspec[userlen - 1] = '\0';\n<line34>break;\n<line35>}\n<line36>case GROUPS:\n<line37>groups = optarg;\n<line38>break;\n<line39>case SKIP_CHDIR:\n<line40>skip_chdir = true;\n<line41>break;\n<line42>case_GETOPT_HELP_CHAR;\n<line43>case_GETOPT_VERSION_CHAR (PROGRAM_NAME, AUTHORS);\n<line44>default:\n<line45>usage (EXIT_CANCELED);\n<line46>}\n<line47>}\n<line48>if (argc <= optind)\n<line49>{\n<line50>error (0, 0, _("missing operand"));\n<line51>usage (EXIT_CANCELED);\n<line52>}\n<line53>char const *newroot = argv[optind];\n<line54>bool is_oldroot = is_root (newroot);\n<line55>if (! is_oldroot && skip_chdir)\n<line56>{\n<line57>error (0, 0, _("option --skip-chdir only permitted if NEWROOT is old %s"),\n<line58>quoteaf ("/"));\n<line59>usage (EXIT_CANCELED);\n<line60>}\n<line61>if (! is_oldroot)\n<line62>{\n<line63>/* We have to look up users and groups twice.\n<line64>- First, outside the chroot to load potentially necessary passwd/group\n<line65>parsing plugins (e.g. NSS);\n<line66>- Second, inside chroot to redo parsing in case IDs are different.\n<line67>Within chroot lookup is the main justification for having\n<line68>the --user option supported by the chroot command itself.  */\n<line69>if (userspec)\n<line70>ignore_value (parse_user_spec (userspec, &uid, &gid, nullptr, nullptr));\n<line71>/* If no gid is supplied or looked up, do so now.\n<line72>Also lookup the username for use with getgroups.  */\n<line73>if (uid_set (uid) && (! groups || gid_unset (gid)))\n<line74>{\n<line75>const struct passwd *pwd;\n<line76>if ((pwd = getpwuid (uid)))\n<line77>{\n<line78>if (gid_unset (gid))\n<line79>gid = pwd->pw_gid;\n<line80>username = pwd->pw_name;\n<line81>}\n<line82>}\n<line83>if (groups && *groups)\n<line84>ignore_value (parse_additional_groups (groups, &out_gids, &n_gids,\n<line85>false));\n<line86>#if HAVE_SETGROUPS\n<line87>else if (! groups && gid_set (gid) && username)\n<line88>{\n<line89>int ngroups = xgetgroups (username, gid, &out_gids);\n<line90>if (0 < ngroups)\n<line91>n_gids = ngroups;\n<line92>}\n<line93>#endif\n<line94>}\n<line95>if (chroot (newroot) != 0)\n<line96>error (EXIT_CANCELED, errno, _("cannot change root directory to %s"),\n<line97>quoteaf (newroot));\n<line98>if (! skip_chdir && chdir ("/"))\n<line99>error (EXIT_CANCELED, errno, _("cannot chdir to root directory"));\n<line100>if (argc == optind + 1)\n<line101>{\n<line102>/* No command.  Run an interactive shell.  */\n<line103>char *shell = getenv ("SHELL");\n<line104>if (shell == nullptr)\n<line105>shell = bad_cast ("/bin/sh");\n<line106>argv[0] = shell;\n<line107>argv[1] = bad_cast ("-i");\n<line108>argv[2] = nullptr;\n<line109>}\n<line110>else\n<line111>{\n<line112>/* The following arguments give the command.  */\n<line113>argv += optind + 1;\n<line114>}\n<line115>/* Attempt to set all three: supplementary groups, group ID, user ID.\n<line116>Diagnose any failures.  If any have failed, exit before execvp.  */\n<line117>if (userspec)\n<line118>{\n<line119>bool warn;\n<line120>char const *err = parse_user_spec_warn (userspec, &uid, &gid,\n<line121>nullptr, nullptr, &warn);\n<line122>if (err)\n<line123>error (warn ? 0 : EXIT_CANCELED, 0, "%s", (err));\n<line124>}\n<line125>/* If no gid is supplied or looked up, do so now.\n<line126>Also lookup the username for use with getgroups.  */\n<line127>if (uid_set (uid) && (! groups || gid_unset (gid)))\n<line128>{\n<line129>const struct passwd *pwd;\n<line130>if ((pwd = getpwuid (uid)))\n<line131>{\n<line132>if (gid_unset (gid))\n<line133>gid = pwd->pw_gid;\n<line134>username = pwd->pw_name;\n<line135>}\n<line136>else if (gid_unset (gid))\n<line137>{\n<line138>error (EXIT_CANCELED, errno,\n<line139>_("no group specified for unknown uid: %d"), (int) uid);\n<line140>}\n<line141>}\n<line142>GETGROUPS_T *gids = out_gids;\n<line143>GETGROUPS_T *in_gids = nullptr;\n<line144>if (groups && *groups)\n<line145>{\n<line146>if (parse_additional_groups (groups, &in_gids, &n_gids, !n_gids) != 0)\n<line147>{\n<line148>if (! n_gids)\n<line149>return EXIT_CANCELED;\n<line150>/* else look-up outside the chroot worked, then go with those.  */\n<line151>}\n<line152>else\n<line153>gids = in_gids;\n<line154>}\n<line155>#if HAVE_SETGROUPS\n<line156>else if (! groups && gid_set (gid) && username)\n<line157>{\n<line158>int ngroups = xgetgroups (username, gid, &in_gids);\n<line159>if (ngroups <= 0)\n<line160>{\n<line161>if (! n_gids)\n<line162>error (EXIT_CANCELED, errno,\n<line163>_("failed to get supplemental groups"));\n<line164>/* else look-up outside the chroot worked, then go with those.  */\n<line165>}\n<line166>else\n<line167>{\n<line168>n_gids = ngroups;\n<line169>gids = in_gids;\n<line170>}\n<line171>}\n<line172>#endif\n<line173>if ((uid_set (uid) || groups) && setgroups (n_gids, gids) != 0)\n<line174>error (EXIT_CANCELED, errno, _("failed to set supplemental groups"));\n<line175>free (in_gids);\n<line176>free (out_gids);\n<line177>if (gid_set (gid) && setgid (gid))\n<line178>error (EXIT_CANCELED, errno, _("failed to set group-ID"));\n<line179>if (uid_set (uid) && setuid (uid))\n<line180>error (EXIT_CANCELED, errno, _("failed to set user-ID"));\n<line181>/* Execute the given command.  */\n<line182>execvp (argv[0], argv);\n<line183>int exit_status = errno == ENOENT ? EXIT_ENOENT : EXIT_CANNOT_INVOKE;\n<line184>error (0, errno, _("failed to run command %s"), quote (argv[0]));\n<line185>return exit_status;\n<line186>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/src/version.c
========================================
========================================
/home/huihui/Downloads/coreutils-9.4/lib/copy-acl.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
In file included from /home/huihui/Downloads/coreutils-9.4/lib/copy-acl.c:27:
./lib/error.h:28:3: warning: #include_next in file found relative to primary source file or found by absolute path; will search from start of include path [-Winclude-next-absolute-path]
# include_next <error.h>
  ^
2 warnings generated.
Function: copy_acl
Content: <line0>int\n<line1>copy_acl (const char *src_name, int source_desc, const char *dst_name,\n<line2>int dest_desc, mode_t mode)\n<line3>{\n<line4>int ret = qcopy_acl (src_name, source_desc, dst_name, dest_desc, mode);\n<line5>switch (ret)\n<line6>{\n<line7>case -2:\n<line8>error (0, errno, "%s", quote (src_name));\n<line9>break;\n<line10>case -1:\n<line11>error (0, errno, _("preserving permissions for %s"), quote (dst_name));\n<line12>break;\n<line13>default:\n<line14>break;\n<line15>}\n<line16>return ret;\n<line17>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/set-acl.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
In file included from /home/huihui/Downloads/coreutils-9.4/lib/set-acl.c:27:
./lib/error.h:28:3: warning: #include_next in file found relative to primary source file or found by absolute path; will search from start of include path [-Winclude-next-absolute-path]
# include_next <error.h>
  ^
2 warnings generated.
Function: set_acl
Content: <line0>int\n<line1>set_acl (char const *name, int desc, mode_t mode)\n<line2>{\n<line3>int ret = qset_acl (name, desc, mode);\n<line4>if (ret != 0)\n<line5>error (0, errno, _("setting permissions for %s"), quote (name));\n<line6>return ret;\n<line7>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/acl-errno-valid.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
========================================
/home/huihui/Downloads/coreutils-9.4/lib/acl-internal.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
Function: free_permission_context
Content: <line0>void\n<line1>free_permission_context (struct permission_context *ctx)\n<line2>{\n<line3>#if USE_ACL\n<line4># if HAVE_ACL_GET_FILE /* Linux, FreeBSD, Mac OS X, IRIX, Tru64, Cygwin >= 2.5 */\n<line5>if (ctx->acl)\n<line6>acl_free (ctx->acl);\n<line7>#  if !HAVE_ACL_TYPE_EXTENDED\n<line8>if (ctx->default_acl)\n<line9>acl_free (ctx->default_acl);\n<line10>#  endif\n<line11># elif defined GETACL /* Solaris, Cygwin < 2.5 */\n<line12>free (ctx->entries);\n<line13>#  ifdef ACE_GETACL\n<line14>free (ctx->ace_entries);\n<line15>#  endif\n<line16># elif HAVE_GETACL /* HP-UX */\n<line17>#  if HAVE_ACLV_H\n<line18>#  endif\n<line19># elif HAVE_STATACL /* older AIX */\n<line20># elif HAVE_ACLSORT /* NonStop Kernel */\n<line21># endif\n<line22>#endif\n<line23>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/get-permissions.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
Function: get_permissions
Content: <line0>int\n<line1>get_permissions (const char *name, int desc, mode_t mode,\n<line2>struct permission_context *ctx)\n<line3>{\n<line4>memset (ctx, 0, sizeof *ctx);\n<line5>ctx->mode = mode;\n<line6>#if USE_ACL && HAVE_ACL_GET_FILE\n<line7>/* POSIX 1003.1e (draft 17 -- abandoned) specific version.  */\n<line8>/* Linux, FreeBSD, Mac OS X, IRIX, Tru64, Cygwin >= 2.5 */\n<line9># if !HAVE_ACL_TYPE_EXTENDED\n<line10>/* Linux, FreeBSD, IRIX, Tru64, Cygwin >= 2.5 */\n<line11>if (HAVE_ACL_GET_FD && desc != -1)\n<line12>ctx->acl = acl_get_fd (desc);\n<line13>else\n<line14>ctx->acl = acl_get_file (name, ACL_TYPE_ACCESS);\n<line15>if (ctx->acl == NULL)\n<line16>return acl_errno_valid (errno) ? -1 : 0;\n<line17>/* With POSIX ACLs, a file cannot have "no" acl; a file without\n<line18>extended permissions has a "minimal" acl which is equivalent to the\n<line19>file mode.  */\n<line20>if (S_ISDIR (mode))\n<line21>{\n<line22>ctx->default_acl = acl_get_file (name, ACL_TYPE_DEFAULT);\n<line23>if (ctx->default_acl == NULL)\n<line24>return -1;\n<line25>}\n<line26>#  if HAVE_ACL_TYPE_NFS4  /* FreeBSD */\n<line27>/* TODO (see set_permissions). */\n<line28>#  endif\n<line29># else /* HAVE_ACL_TYPE_EXTENDED */\n<line30>/* Mac OS X */\n<line31>/* On Mac OS X,  acl_get_file (name, ACL_TYPE_ACCESS)\n<line32>and           acl_get_file (name, ACL_TYPE_DEFAULT)\n<line33>always return NULL / EINVAL.  You have to use\n<line34>acl_get_file (name, ACL_TYPE_EXTENDED)\n<line35>or            acl_get_fd (open (name, ...))\n<line36>to retrieve an ACL.\n<line37>On the other hand,\n<line38>acl_set_file (name, ACL_TYPE_ACCESS, acl)\n<line39>and           acl_set_file (name, ACL_TYPE_DEFAULT, acl)\n<line40>have the same effect as\n<line41>acl_set_file (name, ACL_TYPE_EXTENDED, acl):\n<line42>Each of these calls sets the file's ACL.  */\n<line43>if (HAVE_ACL_GET_FD && desc != -1)\n<line44>ctx->acl = acl_get_fd (desc);\n<line45>else\n<line46>ctx->acl = acl_get_file (name, ACL_TYPE_EXTENDED);\n<line47>if (ctx->acl == NULL)\n<line48>return acl_errno_valid (errno) ? -1 : 0;\n<line49># endif\n<line50>#elif USE_ACL && defined GETACL /* Solaris, Cygwin, not HP-UX */\n<line51>/* Solaris 2.5 through Solaris 10, Cygwin, and contemporaneous versions\n<line52>of Unixware.  The acl() call returns the access and default ACL both\n<line53>at once.  */\n<line54># ifdef ACE_GETACL\n<line55>/* Solaris also has a different variant of ACLs, used in ZFS and NFSv4\n<line56>file systems (whereas the other ones are used in UFS file systems).\n<line57>There is an API\n<line58>pathconf (name, _PC_ACL_ENABLED)\n<line59>fpathconf (desc, _PC_ACL_ENABLED)\n<line60>that allows us to determine which of the two kinds of ACLs is supported\n<line61>for the given file.  But some file systems may implement this call\n<line62>incorrectly, so better not use it.\n<line63>When fetching the source ACL, we simply fetch both ACL types.\n<line64>When setting the destination ACL, we try either ACL types, assuming\n<line65>that the kernel will translate the ACL from one form to the other.\n<line66>(See in <https://docs.oracle.com/cd/E86824_01/html/E54765/acl-2.html>\n<line67>the description of ENOTSUP.)  */\n<line68>for (;;)\n<line69>{\n<line70>int ret;\n<line71>if (desc != -1)\n<line72>ret = facl (desc, ACE_GETACLCNT, 0, NULL);\n<line73>else\n<line74>ret = acl (name, ACE_GETACLCNT, 0, NULL);\n<line75>if (ret < 0)\n<line76>{\n<line77>if (errno == ENOSYS || errno == EINVAL)\n<line78>ret = 0;\n<line79>else\n<line80>return -1;\n<line81>}\n<line82>ctx->ace_count = ret;\n<line83>if (ctx->ace_count == 0)\n<line84>break;\n<line85>ctx->ace_entries = (ace_t *) malloc (ctx->ace_count * sizeof (ace_t));\n<line86>if (ctx->ace_entries == NULL)\n<line87>{\n<line88>errno = ENOMEM;\n<line89>return -1;\n<line90>}\n<line91>if (desc != -1)\n<line92>ret = facl (desc, ACE_GETACL, ctx->ace_count, ctx->ace_entries);\n<line93>else\n<line94>ret = acl (name, ACE_GETACL, ctx->ace_count, ctx->ace_entries);\n<line95>if (ret < 0)\n<line96>{\n<line97>if (errno == ENOSYS || errno == EINVAL)\n<line98>{\n<line99>free (ctx->ace_entries);\n<line100>ctx->ace_entries = NULL;\n<line101>ctx->ace_count = 0;\n<line102>break;\n<line103>}\n<line104>else\n<line105>return -1;\n<line106>}\n<line107>if (ret <= ctx->ace_count)\n<line108>{\n<line109>ctx->ace_count = ret;\n<line110>break;\n<line111>}\n<line112>/* Huh? The number of ACL entries has increased since the last call.\n<line113>Repeat.  */\n<line114>free (ctx->ace_entries);\n<line115>ctx->ace_entries = NULL;\n<line116>}\n<line117># endif\n<line118>for (;;)\n<line119>{\n<line120>int ret;\n<line121>if (desc != -1)\n<line122>ret = facl (desc, GETACLCNT, 0, NULL);\n<line123>else\n<line124>ret = acl (name, GETACLCNT, 0, NULL);\n<line125>if (ret < 0)\n<line126>{\n<line127>if (errno == ENOSYS || errno == ENOTSUP || errno == EOPNOTSUPP)\n<line128>ret = 0;\n<line129>else\n<line130>return -1;\n<line131>}\n<line132>ctx->count = ret;\n<line133>if (ctx->count == 0)\n<line134>break;\n<line135>ctx->entries = (aclent_t *) malloc (ctx->count * sizeof (aclent_t));\n<line136>if (ctx->entries == NULL)\n<line137>{\n<line138>errno = ENOMEM;\n<line139>return -1;\n<line140>}\n<line141>if (desc != -1)\n<line142>ret = facl (desc, GETACL, ctx->count, ctx->entries);\n<line143>else\n<line144>ret = acl (name, GETACL, ctx->count, ctx->entries);\n<line145>if (ret < 0)\n<line146>{\n<line147>if (errno == ENOSYS || errno == ENOTSUP || errno == EOPNOTSUPP)\n<line148>{\n<line149>free (ctx->entries);\n<line150>ctx->entries = NULL;\n<line151>ctx->count = 0;\n<line152>break;\n<line153>}\n<line154>else\n<line155>return -1;\n<line156>}\n<line157>if (ret <= ctx->count)\n<line158>{\n<line159>ctx->count = ret;\n<line160>break;\n<line161>}\n<line162>/* Huh? The number of ACL entries has increased since the last call.\n<line163>Repeat.  */\n<line164>free (ctx->entries);\n<line165>ctx->entries = NULL;\n<line166>}\n<line167>#elif USE_ACL && HAVE_GETACL /* HP-UX */\n<line168>{\n<line169>int ret;\n<line170>if (desc != -1)\n<line171>ret = fgetacl (desc, NACLENTRIES, ctx->entries);\n<line172>else\n<line173>ret = getacl (name, NACLENTRIES, ctx->entries);\n<line174>if (ret < 0)\n<line175>{\n<line176>if (errno == ENOSYS || errno == EOPNOTSUPP || errno == ENOTSUP)\n<line177>ret = 0;\n<line178>else\n<line179>return -1;\n<line180>}\n<line181>else if (ret > NACLENTRIES)\n<line182>/* If NACLENTRIES cannot be trusted, use dynamic memory allocation.  */\n<line183>abort ();\n<line184>ctx->count = ret;\n<line185># if HAVE_ACLV_H\n<line186>ret = acl ((char *) name, ACL_GET, NACLVENTRIES, ctx->aclv_entries);\n<line187>if (ret < 0)\n<line188>{\n<line189>if (errno == ENOSYS || errno == EOPNOTSUPP || errno == EINVAL)\n<line190>ret = 0;\n<line191>else\n<line192>return -2;\n<line193>}\n<line194>else if (ret > NACLVENTRIES)\n<line195>/* If NACLVENTRIES cannot be trusted, use dynamic memory allocation.  */\n<line196>abort ();\n<line197>ctx->aclv_count = ret;\n<line198># endif\n<line199>}\n<line200>#elif USE_ACL && HAVE_ACLX_GET && ACL_AIX_WIP /* AIX */\n<line201>/* TODO (see set_permissions). */\n<line202>#elif USE_ACL && HAVE_STATACL /* older AIX */\n<line203>{\n<line204>int ret;\n<line205>if (desc != -1)\n<line206>ret = fstatacl (desc, STX_NORMAL, &ctx->u.a, sizeof ctx->u);\n<line207>else\n<line208>ret = statacl ((char *) name, STX_NORMAL, &ctx->u.a, sizeof ctx->u);\n<line209>if (ret == 0)\n<line210>ctx->have_u = true;\n<line211>}\n<line212>#elif USE_ACL && HAVE_ACLSORT /* NonStop Kernel */\n<line213>{\n<line214>int ret = acl ((char *) name, ACL_GET, NACLENTRIES, ctx->entries);\n<line215>if (ret < 0)\n<line216>return -1;\n<line217>else if (ret > NACLENTRIES)\n<line218>/* If NACLENTRIES cannot be trusted, use dynamic memory allocation.  */\n<line219>abort ();\n<line220>ctx->count = ret;\n<line221>}\n<line222>#endif\n<line223>return 0;\n<line224>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/set-permissions.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
Function: chmod_or_fchmod
Content: <line0>int\n<line1>chmod_or_fchmod (const char *name, int desc, mode_t mode)\n<line2>{\n<line3>if (HAVE_FCHMOD && desc != -1)\n<line4>return fchmod (desc, mode);\n<line5>else\n<line6>return chmod (name, mode);\n<line7>}
----------------------------------------
Function: set_permissions
Content: <line0>int\n<line1>set_permissions (struct permission_context *ctx, const char *name, int desc)\n<line2>{\n<line3>_GL_UNUSED bool acls_set = false;\n<line4>bool early_chmod;\n<line5>bool must_chmod = false;\n<line6>int ret = 0;\n<line7>#if USE_ACL\n<line8># if HAVE_STATACL\n<line9>/* older AIX */\n<line10>/* There is no need to call chmod_or_fchmod, since the mode\n<line11>bits S_ISUID, S_ISGID, S_ISVTX are also stored in the ACL.  */\n<line12>early_chmod = false;\n<line13># else\n<line14>/* All other platforms */\n<line15>/* On Cygwin, it is necessary to call chmod before acl, because\n<line16>chmod can change the contents of the ACL (in ways that don't\n<line17>change the allowed accesses, but still visible).  */\n<line18>early_chmod = (! MODE_INSIDE_ACL || (ctx->mode & (S_ISUID | S_ISGID | S_ISVTX)));\n<line19># endif\n<line20>#else\n<line21>/* No ACLs */\n<line22>early_chmod = true;\n<line23>#endif\n<line24>if (early_chmod)\n<line25>{\n<line26>ret = chmod_or_fchmod (name, desc, ctx->mode);\n<line27>if (ret != 0)\n<line28>return -1;\n<line29>}\n<line30>#if USE_ACL\n<line31>ret = set_acls (ctx, name, desc, false, &must_chmod, &acls_set);\n<line32>if (! acls_set)\n<line33>{\n<line34>int saved_errno = ret ? errno : 0;\n<line35>/* If we can't set an acl which we expect to be able to set, try setting\n<line36>the permissions to ctx->mode. Due to possible inherited permissions,\n<line37>we cannot simply chmod.  */\n<line38>ret = set_acls (ctx, name, desc, true, &must_chmod, &acls_set);\n<line39>if (! acls_set)\n<line40>must_chmod = true;\n<line41>if (saved_errno)\n<line42>{\n<line43>errno = saved_errno;\n<line44>ret = -1;\n<line45>}\n<line46>}\n<line47>#endif\n<line48>if (must_chmod && ! early_chmod)\n<line49>{\n<line50>int saved_errno = ret ? errno : 0;\n<line51>ret = chmod_or_fchmod (name, desc, ctx->mode);\n<line52>if (saved_errno)\n<line53>{\n<line54>errno = saved_errno;\n<line55>ret = -1;\n<line56>}\n<line57>}\n<line58>return ret;\n<line59>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/alignalloc.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
========================================
/home/huihui/Downloads/coreutils-9.4/lib/allocator.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
========================================
/home/huihui/Downloads/coreutils-9.4/lib/areadlink.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
Function: careadlinkatcwd
Content: <line0>static ssize_t\n<line1>careadlinkatcwd (int fd, char const *filename, char *buffer,\n<line2>size_t buffer_size)\n<line3>{\n<line4>/* FD must be AT_FDCWD here, otherwise the caller is using this\n<line5>function in contexts it was not meant for.  */\n<line6>if (fd != AT_FDCWD)\n<line7>abort ();\n<line8>return readlink (filename, buffer, buffer_size);\n<line9>}
----------------------------------------
Function: areadlink
Content: <line0>char *\n<line1>areadlink (char const *filename)\n<line2>{\n<line3>return careadlinkat (AT_FDCWD, filename, NULL, 0, NULL, careadlinkatcwd);\n<line4>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/areadlink-with-size.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
Function: areadlink_with_size
Content: <line0>char *\n<line1>areadlink_with_size (char const *file, size_t size)\n<line2>{\n<line3>/* Some buggy file systems report garbage in st_size.  Defend\n<line4>against them by ignoring outlandish st_size values in the initial\n<line5>memory allocation.  */\n<line6>size_t symlink_max = SYMLINK_MAX;\n<line7>size_t INITIAL_LIMIT_BOUND = 8 * 1024;\n<line8>size_t initial_limit = (symlink_max < INITIAL_LIMIT_BOUND\n<line9>? symlink_max + 1\n<line10>: INITIAL_LIMIT_BOUND);\n<line11>enum { stackbuf_size = 128 };\n<line12>/* The initial buffer size for the link value.  */\n<line13>size_t buf_size = (size == 0 ? stackbuf_size\n<line14>: size < initial_limit ? size + 1 : initial_limit);\n<line15>while (1)\n<line16>{\n<line17>ssize_t r;\n<line18>size_t link_length;\n<line19>char stackbuf[stackbuf_size];\n<line20>char *buf = stackbuf;\n<line21>char *buffer = NULL;\n<line22>if (! (size == 0 && buf_size == stackbuf_size))\n<line23>{\n<line24>buf = buffer = malloc (buf_size);\n<line25>if (!buffer)\n<line26>{\n<line27>errno = ENOMEM;\n<line28>return NULL;\n<line29>}\n<line30>}\n<line31>r = readlink (file, buf, buf_size);\n<line32>link_length = r;\n<line33>if (r < 0)\n<line34>{\n<line35>free (buffer);\n<line36>return NULL;\n<line37>}\n<line38>if (link_length < buf_size)\n<line39>{\n<line40>buf[link_length] = 0;\n<line41>if (!buffer)\n<line42>{\n<line43>buffer = malloc (link_length + 1);\n<line44>if (buffer)\n<line45>return memcpy (buffer, buf, link_length + 1);\n<line46>}\n<line47>else if (link_length + 1 < buf_size)\n<line48>{\n<line49>/* Shrink BUFFER before returning it.  */\n<line50>char *shrinked_buffer = realloc (buffer, link_length + 1);\n<line51>if (shrinked_buffer != NULL)\n<line52>buffer = shrinked_buffer;\n<line53>}\n<line54>return buffer;\n<line55>}\n<line56>free (buffer);\n<line57>if (buf_size <= MAXSIZE / 2)\n<line58>buf_size *= 2;\n<line59>else if (buf_size < MAXSIZE)\n<line60>buf_size = MAXSIZE;\n<line61>else\n<line62>{\n<line63>errno = ENOMEM;\n<line64>return NULL;\n<line65>}\n<line66>}\n<line67>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/areadlinkat.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
Function: areadlinkat
Content: <line0>char *\n<line1>areadlinkat (int fd, char const *filename)\n<line2>{\n<line3>return careadlinkat (fd, filename, NULL, 0, NULL, readlinkat);\n<line4>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/areadlinkat-with-size.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
Function: areadlinkat_with_size
Content: <line0>char *\n<line1>areadlinkat_with_size (int fd, char const *file, size_t size)\n<line2>{\n<line3>/* Some buggy file systems report garbage in st_size.  Defend\n<line4>against them by ignoring outlandish st_size values in the initial\n<line5>memory allocation.  */\n<line6>size_t symlink_max = SYMLINK_MAX;\n<line7>size_t INITIAL_LIMIT_BOUND = 8 * 1024;\n<line8>size_t initial_limit = (symlink_max < INITIAL_LIMIT_BOUND\n<line9>? symlink_max + 1\n<line10>: INITIAL_LIMIT_BOUND);\n<line11>enum { stackbuf_size = 128 };\n<line12>/* The initial buffer size for the link value.  */\n<line13>size_t buf_size = (size == 0 ? stackbuf_size\n<line14>: size < initial_limit ? size + 1 : initial_limit);\n<line15>while (1)\n<line16>{\n<line17>ssize_t r;\n<line18>size_t link_length;\n<line19>char stackbuf[stackbuf_size];\n<line20>char *buf = stackbuf;\n<line21>char *buffer = NULL;\n<line22>if (! (size == 0 && buf_size == stackbuf_size))\n<line23>{\n<line24>buf = buffer = malloc (buf_size);\n<line25>if (!buffer)\n<line26>/* We can assume errno == ENOMEM here, since all platforms that have\n<line27>readlinkat() have a POSIX compliant malloc().  */\n<line28>return NULL;\n<line29>}\n<line30>r = readlinkat (fd, file, buf, buf_size);\n<line31>link_length = r;\n<line32>if (r < 0)\n<line33>{\n<line34>free (buffer);\n<line35>return NULL;\n<line36>}\n<line37>if (link_length < buf_size)\n<line38>{\n<line39>buf[link_length] = 0;\n<line40>if (!buffer)\n<line41>{\n<line42>buffer = malloc (link_length + 1);\n<line43>if (buffer)\n<line44>return memcpy (buffer, buf, link_length + 1);\n<line45>}\n<line46>else if (link_length + 1 < buf_size)\n<line47>{\n<line48>/* Shrink BUFFER before returning it.  */\n<line49>char *shrinked_buffer = realloc (buffer, link_length + 1);\n<line50>if (shrinked_buffer != NULL)\n<line51>buffer = shrinked_buffer;\n<line52>}\n<line53>return buffer;\n<line54>}\n<line55>free (buffer);\n<line56>if (buf_size <= MAXSIZE / 2)\n<line57>buf_size *= 2;\n<line58>else if (buf_size < MAXSIZE)\n<line59>buf_size = MAXSIZE;\n<line60>else\n<line61>{\n<line62>errno = ENOMEM;\n<line63>return NULL;\n<line64>}\n<line65>}\n<line66>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/argmatch.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
In file included from /home/huihui/Downloads/coreutils-9.4/lib/argmatch.c:33:
./lib/error.h:28:3: warning: #include_next in file found relative to primary source file or found by absolute path; will search from start of include path [-Winclude-next-absolute-path]
# include_next <error.h>
  ^
2 warnings generated.
Function: __argmatch_die
Content: <line0>static void\n<line1>__argmatch_die (void)\n<line2>{\n<line3>ARGMATCH_DIE;\n<line4>}
----------------------------------------
Function: argmatch
Content: <line0>ptrdiff_t\n<line1>argmatch (const char *arg, const char *const *arglist,\n<line2>const void *vallist, size_t valsize)\n<line3>{\n<line4>size_t i;                     /* Temporary index in ARGLIST.  */\n<line5>size_t arglen;                /* Length of ARG.  */\n<line6>ptrdiff_t matchind = -1;      /* Index of first nonexact match.  */\n<line7>bool ambiguous = false;       /* If true, multiple nonexact match(es).  */\n<line8>arglen = strlen (arg);\n<line9>/* Test all elements for either exact match or abbreviated matches.  */\n<line10>for (i = 0; arglist[i]; i++)\n<line11>{\n<line12>if (!strncmp (arglist[i], arg, arglen))\n<line13>{\n<line14>if (strlen (arglist[i]) == arglen)\n<line15>/* Exact match found.  */\n<line16>return i;\n<line17>else if (matchind == -1)\n<line18>/* First nonexact match found.  */\n<line19>matchind = i;\n<line20>else\n<line21>{\n<line22>/* Second nonexact match found.  */\n<line23>if (vallist == NULL\n<line24>|| memcmp ((char const *) vallist + valsize * matchind,\n<line25>(char const *) vallist + valsize * i, valsize))\n<line26>{\n<line27>/* There is a real ambiguity, or we could not\n<line28>disambiguate. */\n<line29>ambiguous = true;\n<line30>}\n<line31>}\n<line32>}\n<line33>}\n<line34>if (ambiguous)\n<line35>return -2;\n<line36>else\n<line37>return matchind;\n<line38>}
----------------------------------------
Function: argmatch_exact
Content: <line0>ptrdiff_t\n<line1>argmatch_exact (const char *arg, const char *const *arglist)\n<line2>{\n<line3>size_t i;\n<line4>/* Test elements for exact match.  */\n<line5>for (i = 0; arglist[i]; i++)\n<line6>{\n<line7>if (!strcmp (arglist[i], arg))\n<line8>return i;\n<line9>}\n<line10>return -1;\n<line11>}
----------------------------------------
Function: argmatch_invalid
Content: <line0>void\n<line1>argmatch_invalid (const char *context, const char *value, ptrdiff_t problem)\n<line2>{\n<line3>char const *format = (problem == -1\n<line4>? _("invalid argument %s for %s")\n<line5>: _("ambiguous argument %s for %s"));\n<line6>error (0, 0, format, quotearg_n_style (0, ARGMATCH_QUOTING_STYLE, value),\n<line7>quote_n (1, context));\n<line8>}
----------------------------------------
Function: argmatch_valid
Content: <line0>void\n<line1>argmatch_valid (const char *const *arglist,\n<line2>const void *vallist, size_t valsize)\n<line3>{\n<line4>size_t i;\n<line5>const char *last_val = NULL;\n<line6>/* We try to put synonyms on the same line.  The assumption is that\n<line7>synonyms follow each other */\n<line8>fputs (_("Valid arguments are:"), stderr);\n<line9>for (i = 0; arglist[i]; i++)\n<line10>if ((i == 0)\n<line11>|| memcmp (last_val, (char const *) vallist + valsize * i, valsize))\n<line12>{\n<line13>fprintf (stderr, "\n  - %s", quote (arglist[i]));\n<line14>last_val = (char const *) vallist + valsize * i;\n<line15>}\n<line16>else\n<line17>{\n<line18>fprintf (stderr, ", %s", quote (arglist[i]));\n<line19>}\n<line20>putc ('\n', stderr);\n<line21>}
----------------------------------------
Function: __xargmatch_internal
Content: <line0>ptrdiff_t\n<line1>__xargmatch_internal (const char *context,\n<line2>const char *arg, const char *const *arglist,\n<line3>const void *vallist, size_t valsize,\n<line4>argmatch_exit_fn exit_fn,\n<line5>bool allow_abbreviation)\n<line6>{\n<line7>ptrdiff_t res;\n<line8>if (allow_abbreviation)\n<line9>res = argmatch (arg, arglist, vallist, valsize);\n<line10>else\n<line11>res = argmatch_exact (arg, arglist);\n<line12>if (res >= 0)\n<line13>/* Success. */\n<line14>return res;\n<line15>/* We failed.  Explain why. */\n<line16>argmatch_invalid (context, arg, res);\n<line17>argmatch_valid (arglist, vallist, valsize);\n<line18>(*exit_fn) ();\n<line19>return -1; /* To please the compilers. */\n<line20>}
----------------------------------------
Function: argmatch_to_argument
Content: <line0>const char *\n<line1>argmatch_to_argument (const void *value,\n<line2>const char *const *arglist,\n<line3>const void *vallist, size_t valsize)\n<line4>{\n<line5>size_t i;\n<line6>for (i = 0; arglist[i]; i++)\n<line7>if (!memcmp (value, (char const *) vallist + valsize * i, valsize))\n<line8>return arglist[i];\n<line9>return NULL;\n<line10>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/argv-iter.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
Function: argv_iter_init_argv
Content: <line0>struct argv_iterator *\n<line1>argv_iter_init_argv (char **argv)\n<line2>{\n<line3>struct argv_iterator *ai = malloc (sizeof *ai);\n<line4>if (!ai)\n<line5>return NULL;\n<line6>ai->fp = NULL;\n<line7>ai->arg_list = argv;\n<line8>ai->p = argv;\n<line9>return ai;\n<line10>}
----------------------------------------
Function: argv_iter_init_stream
Content: <line0>struct argv_iterator *\n<line1>argv_iter_init_stream (FILE *fp)\n<line2>{\n<line3>struct argv_iterator *ai = malloc (sizeof *ai);\n<line4>if (!ai)\n<line5>return NULL;\n<line6>ai->fp = fp;\n<line7>ai->tok = NULL;\n<line8>ai->buf_len = 0;\n<line9>ai->item_idx = 0;\n<line10>ai->arg_list = NULL;\n<line11>return ai;\n<line12>}
----------------------------------------
Function: argv_iter
Content: <line0>char *\n<line1>argv_iter (struct argv_iterator *ai, enum argv_iter_err *err)\n<line2>{\n<line3>if (ai->fp)\n<line4>{\n<line5>ssize_t len = getdelim (&ai->tok, &ai->buf_len, '\0', ai->fp);\n<line6>if (len < 0)\n<line7>{\n<line8>*err = feof (ai->fp) ? AI_ERR_EOF : AI_ERR_READ;\n<line9>return NULL;\n<line10>}\n<line11>*err = AI_ERR_OK;\n<line12>ai->item_idx++;\n<line13>return ai->tok;\n<line14>}\n<line15>else\n<line16>{\n<line17>if (*(ai->p) == NULL)\n<line18>{\n<line19>*err = AI_ERR_EOF;\n<line20>return NULL;\n<line21>}\n<line22>else\n<line23>{\n<line24>*err = AI_ERR_OK;\n<line25>return *(ai->p++);\n<line26>}\n<line27>}\n<line28>}
----------------------------------------
Function: argv_iter_n_args
Content: <line0>size_t\n<line1>argv_iter_n_args (struct argv_iterator const *ai)\n<line2>{\n<line3>return ai->fp ? ai->item_idx : ai->p - ai->arg_list;\n<line4>}
----------------------------------------
Function: argv_iter_free
Content: <line0>void\n<line1>argv_iter_free (struct argv_iterator *ai)\n<line2>{\n<line3>if (ai->fp)\n<line4>free (ai->tok);\n<line5>free (ai);\n<line6>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/openat-proc.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
Function: openat_proc_name
Content: <line0>char *\n<line1>openat_proc_name (char buf[OPENAT_BUFFER_SIZE], int fd, char const *file)\n<line2>{\n<line3>char *result = buf;\n<line4>int dirlen;\n<line5>/* Make sure the caller gets ENOENT when appropriate.  */\n<line6>if (!*file)\n<line7>{\n<line8>buf[0] = '\0';\n<line9>return buf;\n<line10>}\n<line11>#if !(defined __KLIBC__ || defined __MVS__)\n<line12>/* Generic code for Linux, Solaris, and similar platforms.  */\n<line13># define PROC_SELF_FD_FORMAT "/proc/self/fd/%d/"\n<line14>{\n<line15>enum {\n<line16>PROC_SELF_FD_DIR_SIZE_BOUND\n<line17>= (sizeof PROC_SELF_FD_FORMAT - (sizeof "%d" - 1)\n<line18>+ INT_STRLEN_BOUND (int))\n<line19>};\n<line20>static int proc_status = 0;\n<line21>if (! proc_status)\n<line22>{\n<line23>/* Set PROC_STATUS to a positive value if /proc/self/fd is\n<line24>reliable, and a negative value otherwise.  Solaris 10\n<line25>/proc/self/fd mishandles "..", and any file name might expand\n<line26>to ".." after symbolic link expansion, so avoid /proc/self/fd\n<line27>if it mishandles "..".  Solaris 10 has openat, but this\n<line28>problem is exhibited on code that built on Solaris 8 and\n<line29>running on Solaris 10.  */\n<line30>int proc_self_fd =\n<line31>open ("/proc/self/fd",\n<line32>O_SEARCH | O_DIRECTORY | O_NOCTTY | O_NONBLOCK | O_CLOEXEC);\n<line33>if (proc_self_fd < 0)\n<line34>proc_status = -1;\n<line35>else\n<line36>{\n<line37>/* Detect whether /proc/self/fd/%i/../fd exists, where %i is the\n<line38>number of a file descriptor open on /proc/self/fd.  On Linux,\n<line39>that name resolves to /proc/self/fd, which was opened above.\n<line40>However, on Solaris, it may resolve to /proc/self/fd/fd, which\n<line41>cannot exist, since all names in /proc/self/fd are numeric.  */\n<line42>char dotdot_buf[PROC_SELF_FD_DIR_SIZE_BOUND + sizeof "../fd" - 1];\n<line43>sprintf (dotdot_buf, PROC_SELF_FD_FORMAT "../fd", proc_self_fd);\n<line44>proc_status = access (dotdot_buf, F_OK) ? -1 : 1;\n<line45>close (proc_self_fd);\n<line46>}\n<line47>}\n<line48>if (proc_status < 0)\n<line49>return NULL;\n<line50>else\n<line51>{\n<line52>size_t bufsize = PROC_SELF_FD_DIR_SIZE_BOUND + strlen (file);\n<line53>if (OPENAT_BUFFER_SIZE < bufsize)\n<line54>{\n<line55>result = malloc (bufsize);\n<line56>if (! result)\n<line57>return NULL;\n<line58>}\n<line59>dirlen = sprintf (result, PROC_SELF_FD_FORMAT, fd);\n<line60>}\n<line61>}\n<line62>#else /* (defined __KLIBC__ || defined __MVS__), i.e. OS/2 or z/OS */\n<line63>/* OS/2 kLIBC provides a function to retrieve a path from a fd.  */\n<line64>{\n<line65>size_t bufsize;\n<line66># ifdef __KLIBC__\n<line67>char dir[_MAX_PATH];\n<line68>if (__libc_Back_ioFHToPath (fd, dir, sizeof dir))\n<line69>return NULL;\n<line70># endif\n<line71># ifdef __MVS__\n<line72>char dir[_XOPEN_PATH_MAX];\n<line73>/* Documentation:\n<line74>https://www.ibm.com/docs/en/zos/2.2.0?topic=functions-w-ioctl-w-pioctl-control-devices */\n<line75>if (w_ioctl (fd, _IOCC_GPN, sizeof dir, dir) < 0)\n<line76>return NULL;\n<line77>/* Documentation:\n<line78>https://www.ibm.com/docs/en/zos/2.2.0?topic=functions-e2a-l-convert-characters-from-ebcdic-ascii */\n<line79>dirlen = __e2a_l (dir, strlen (dir));\n<line80>if (dirlen < 0 || dirlen >= sizeof dir)\n<line81>return NULL;\n<line82>dir[dirlen] = '\0';\n<line83># endif\n<line84>dirlen = strlen (dir);\n<line85>bufsize = dirlen + 1 + strlen (file) + 1; /* 1 for '/', 1 for null */\n<line86>if (OPENAT_BUFFER_SIZE < bufsize)\n<line87>{\n<line88>result = malloc (bufsize);\n<line89>if (! result)\n<line90>return NULL;\n<line91>}\n<line92>strcpy (result, dir);\n<line93>result[dirlen++] = '/';\n<line94>}\n<line95>#endif\n<line96>strcpy (result + dirlen, file);\n<line97>return result;\n<line98>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/backupfile.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
Function: set_simple_backup_suffix
Content: <line0>void\n<line1>set_simple_backup_suffix (char const *s)\n<line2>{\n<line3>if (!s)\n<line4>s = getenv ("SIMPLE_BACKUP_SUFFIX");\n<line5>simple_backup_suffix = s && *s && s == last_component (s) ? s : "~";\n<line6>}
----------------------------------------
Function: check_extension
Content: <line0>static bool\n<line1>check_extension (char *file, idx_t filelen, char e,\n<line2>int dir_fd, idx_t *base_max)\n<line3>{\n<line4>char *base = last_component (file);\n<line5>idx_t baselen = base_len (base);\n<line6>idx_t baselen_max = HAVE_LONG_FILE_NAMES ? 255 : NAME_MAX_MINIMUM;\n<line7>if (HAVE_DOS_FILE_NAMES || NAME_MAX_MINIMUM < baselen)\n<line8>{\n<line9>/* The new base name is long enough to require a pathconf check.  */\n<line10>if (*base_max == 0)\n<line11>{\n<line12>long name_max;\n<line13>if (dir_fd < 0)\n<line14>{\n<line15>/* Temporarily modify the buffer into its parent\n<line16>directory name, invoke pathconf on the directory, and\n<line17>then restore the buffer.  */\n<line18>char tmp[sizeof "."];\n<line19>memcpy (tmp, base, sizeof ".");\n<line20>strcpy (base, ".");\n<line21>errno = 0;\n<line22>name_max = pathconf (file, _PC_NAME_MAX);\n<line23>name_max -= !errno;\n<line24>memcpy (base, tmp, sizeof ".");\n<line25>}\n<line26>else\n<line27>{\n<line28>errno = 0;\n<line29>name_max = fpathconf (dir_fd, _PC_NAME_MAX);\n<line30>name_max -= !errno;\n<line31>}\n<line32>*base_max = (0 <= name_max && name_max <= SIZE_MAX ? name_max\n<line33>: name_max < -1 ? NAME_MAX_MINIMUM : SIZE_MAX);\n<line34>}\n<line35>baselen_max = *base_max;\n<line36>}\n<line37>if (HAVE_DOS_FILE_NAMES && baselen_max <= 12)\n<line38>{\n<line39>/* Live within DOS's 8.3 limit.  */\n<line40>char *dot = strchr (base, '.');\n<line41>if (!dot)\n<line42>baselen_max = 8;\n<line43>else\n<line44>{\n<line45>char const *second_dot = strchr (dot + 1, '.');\n<line46>baselen_max = (second_dot\n<line47>? second_dot - base\n<line48>: dot + 1 - base + 3);\n<line49>}\n<line50>}\n<line51>if (baselen <= baselen_max)\n<line52>return true;\n<line53>else\n<line54>{\n<line55>baselen = file + filelen - base;\n<line56>if (baselen_max <= baselen)\n<line57>baselen = baselen_max - 1;\n<line58>base[baselen] = e;\n<line59>base[baselen + 1] = '\0';\n<line60>return false;\n<line61>}\n<line62>}
----------------------------------------
Function: numbered_backup
Content: <line0>static enum numbered_backup_result\n<line1>numbered_backup (int dir_fd, char **buffer, idx_t buffer_size, idx_t filelen,\n<line2>idx_t base_offset, DIR **dirpp, int *pnew_fd)\n<line3>{\n<line4>enum numbered_backup_result result = BACKUP_IS_NEW;\n<line5>DIR *dirp = *dirpp;\n<line6>char *buf = *buffer;\n<line7>idx_t versionlenmax = 1;\n<line8>idx_t baselen = filelen - base_offset;\n<line9>if (dirp)\n<line10>rewinddir (dirp);\n<line11>else\n<line12>{\n<line13>/* Temporarily modify the buffer into its parent directory name,\n<line14>open the directory, and then restore the buffer.  */\n<line15>char tmp[sizeof "."];\n<line16>char *base = buf + base_offset;\n<line17>memcpy (tmp, base, sizeof ".");\n<line18>strcpy (base, ".");\n<line19>dirp = opendirat (dir_fd, buf, 0, pnew_fd);\n<line20>if (!dirp && errno == ENOMEM)\n<line21>result = BACKUP_NOMEM;\n<line22>memcpy (base, tmp, sizeof ".");\n<line23>strcpy (base + baselen, ".~1~");\n<line24>if (!dirp)\n<line25>return result;\n<line26>*dirpp = dirp;\n<line27>}\n<line28>for (struct dirent *dp; (dp = readdir (dirp)) != NULL; )\n<line29>{\n<line30>if (_D_EXACT_NAMLEN (dp) < baselen + 4)\n<line31>continue;\n<line32>if (memcmp (buf + base_offset, dp->d_name, baselen + 2) != 0)\n<line33>continue;\n<line34>char const *p = dp->d_name + baselen + 2;\n<line35>/* Check whether this file has a version number and if so,\n<line36>whether it is larger.  Use string operations rather than\n<line37>integer arithmetic, to avoid problems with integer overflow.  */\n<line38>if (! ('1' <= *p && *p <= '9'))\n<line39>continue;\n<line40>bool all_9s = (*p == '9');\n<line41>idx_t versionlen;\n<line42>for (versionlen = 1; ISDIGIT (p[versionlen]); versionlen++)\n<line43>all_9s &= (p[versionlen] == '9');\n<line44>if (! (p[versionlen] == '~' && !p[versionlen + 1]\n<line45>&& (versionlenmax < versionlen\n<line46>|| (versionlenmax == versionlen\n<line47>&& memcmp (buf + filelen + 2, p, versionlen) <= 0))))\n<line48>continue;\n<line49>/* This entry has the largest version number seen so far.\n<line50>Append this highest numbered extension to the file name,\n<line51>prepending '0' to the number if it is all 9s.  */\n<line52>versionlenmax = all_9s + versionlen;\n<line53>result = (all_9s ? BACKUP_IS_LONGER : BACKUP_IS_SAME_LENGTH);\n<line54>idx_t new_buffer_size = filelen + 2 + versionlenmax + 2;\n<line55>if (buffer_size < new_buffer_size)\n<line56>{\n<line57>idx_t grown;\n<line58>if (! ckd_add (&grown, new_buffer_size, new_buffer_size >> 1))\n<line59>new_buffer_size = grown;\n<line60>char *new_buf = irealloc (buf, new_buffer_size);\n<line61>if (!new_buf)\n<line62>{\n<line63>*buffer = buf;\n<line64>return BACKUP_NOMEM;\n<line65>}\n<line66>buf = new_buf;\n<line67>buffer_size = new_buffer_size;\n<line68>}\n<line69>char *q = buf + filelen;\n<line70>*q++ = '.';\n<line71>*q++ = '~';\n<line72>*q = '0';\n<line73>q += all_9s;\n<line74>memcpy (q, p, versionlen + 2);\n<line75>/* Add 1 to the version number.  */\n<line76>q += versionlen;\n<line77>while (*--q == '9')\n<line78>*q = '0';\n<line79>++*q;\n<line80>}\n<line81>*buffer = buf;\n<line82>return result;\n<line83>}
----------------------------------------
Function: backupfile_internal
Content: <line0>char *\n<line1>backupfile_internal (int dir_fd, char const *file,\n<line2>enum backup_type backup_type, bool rename)\n<line3>{\n<line4>idx_t base_offset = last_component (file) - file;\n<line5>idx_t filelen = base_offset + base_len (file + base_offset);\n<line6>if (! simple_backup_suffix)\n<line7>set_simple_backup_suffix (NULL);\n<line8>/* Allow room for simple or ".~N~" backups.  The guess must be at\n<line9>least sizeof ".~1~", but otherwise will be adjusted as needed.  */\n<line10>idx_t simple_backup_suffix_size = strlen (simple_backup_suffix) + 1;\n<line11>idx_t backup_suffix_size_guess = simple_backup_suffix_size;\n<line12>enum { GUESS = sizeof ".~12345~" };\n<line13>if (backup_suffix_size_guess < GUESS)\n<line14>backup_suffix_size_guess = GUESS;\n<line15>idx_t ssize = filelen + backup_suffix_size_guess + 1;\n<line16>char *s = imalloc (ssize);\n<line17>if (!s)\n<line18>return s;\n<line19>DIR *dirp = NULL;\n<line20>int sdir = -1;\n<line21>idx_t base_max = 0;\n<line22>while (true)\n<line23>{\n<line24>bool extended = true;\n<line25>memcpy (s, file, filelen);\n<line26>if (backup_type == simple_backups)\n<line27>memcpy (s + filelen, simple_backup_suffix, simple_backup_suffix_size);\n<line28>else\n<line29>switch (numbered_backup (dir_fd, &s, ssize, filelen, base_offset,\n<line30>&dirp, &sdir))\n<line31>{\n<line32>case BACKUP_IS_SAME_LENGTH:\n<line33>break;\n<line34>case BACKUP_IS_NEW:\n<line35>if (backup_type == numbered_existing_backups)\n<line36>{\n<line37>backup_type = simple_backups;\n<line38>memcpy (s + filelen, simple_backup_suffix,\n<line39>simple_backup_suffix_size);\n<line40>}\n<line41>FALLTHROUGH;\n<line42>case BACKUP_IS_LONGER:\n<line43>extended = check_extension (s, filelen, '~', sdir, &base_max);\n<line44>break;\n<line45>case BACKUP_NOMEM:\n<line46>if (dirp)\n<line47>closedir (dirp);\n<line48>free (s);\n<line49>errno = ENOMEM;\n<line50>return NULL;\n<line51>}\n<line52>if (! rename)\n<line53>break;\n<line54>dir_fd = sdir < 0 ? dir_fd : sdir;\n<line55>idx_t offset = sdir < 0 ? 0 : base_offset;\n<line56>unsigned flags = backup_type == simple_backups ? 0 : RENAME_NOREPLACE;\n<line57>if (renameatu (dir_fd, file + offset, dir_fd, s + offset, flags) == 0)\n<line58>break;\n<line59>int e = errno;\n<line60>if (! (e == EEXIST && extended))\n<line61>{\n<line62>if (dirp)\n<line63>closedir (dirp);\n<line64>free (s);\n<line65>errno = e;\n<line66>return NULL;\n<line67>}\n<line68>}\n<line69>if (dirp)\n<line70>closedir (dirp);\n<line71>return s;\n<line72>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/backup-rename.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
Function: backup_file_rename
Content: <line0>char *\n<line1>backup_file_rename (int dir_fd, char const *file, enum backup_type backup_type)\n<line2>{\n<line3>return backupfile_internal (dir_fd, file, backup_type, true);\n<line4>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/backup-find.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
/home/huihui/Downloads/coreutils-9.4/lib/backup-find.c:63:1: warning: '_Static_assert' with no message is a C2x extension [-Wc2x-extensions]
ARGMATCH_VERIFY (backup_args, backup_types);
^
./lib/argmatch.h:49:54: note: expanded from macro 'ARGMATCH_VERIFY'
                   == ARRAY_CARDINALITY (Vallist) + 1)
                                                     ^
2 warnings generated.
Function: find_backup_file_name
Content: <line0>char *\n<line1>find_backup_file_name (int dir_fd, char const *file,\n<line2>enum backup_type backup_type)\n<line3>{\n<line4>char *result = backupfile_internal (dir_fd, file, backup_type, false);\n<line5>if (!result)\n<line6>xalloc_die ();\n<line7>return result;\n<line8>}
----------------------------------------
Function: get_version
Content: <line0>enum backup_type\n<line1>get_version (char const *context, char const *version)\n<line2>{\n<line3>if (version == 0 || *version == 0)\n<line4>return numbered_existing_backups;\n<line5>else\n<line6>return XARGMATCH (context, version, backup_args, backup_types);\n<line7>}
----------------------------------------
Function: xget_version
Content: <line0>enum backup_type\n<line1>xget_version (char const *context, char const *version)\n<line2>{\n<line3>if (version && *version)\n<line4>return get_version (context, version);\n<line5>else\n<line6>return get_version ("$VERSION_CONTROL", getenv ("VERSION_CONTROL"));\n<line7>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/base32.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
Function: to_uchar
Content: <line0>static unsigned char\n<line1>to_uchar (char ch)\n<line2>{\n<line3>return ch;\n<line4>}
----------------------------------------
Function: base32_encode
Content: <line0>void\n<line1>base32_encode (const char *restrict in, idx_t inlen,\n<line2>char *restrict out, idx_t outlen)\n<line3>{\n<line4>static const char b32str[32] =\n<line5>"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567";\n<line6>while (inlen && outlen)\n<line7>{\n<line8>*out++ = b32str[(to_uchar (in[0]) >> 3) & 0x1f];\n<line9>if (!--outlen)\n<line10>break;\n<line11>*out++ = b32str[((to_uchar (in[0]) << 2)\n<line12>+ (--inlen ? to_uchar (in[1]) >> 6 : 0))\n<line13>& 0x1f];\n<line14>if (!--outlen)\n<line15>break;\n<line16>*out++ =\n<line17>(inlen\n<line18>? b32str[(to_uchar (in[1]) >> 1) & 0x1f]\n<line19>: '=');\n<line20>if (!--outlen)\n<line21>break;\n<line22>*out++ =\n<line23>(inlen\n<line24>? b32str[((to_uchar (in[1]) << 4)\n<line25>+ (--inlen ? to_uchar (in[2]) >> 4 : 0))\n<line26>& 0x1f]\n<line27>: '=');\n<line28>if (!--outlen)\n<line29>break;\n<line30>*out++ =\n<line31>(inlen\n<line32>? b32str[((to_uchar (in[2]) << 1)\n<line33>+ (--inlen ? to_uchar (in[3]) >> 7 : 0))\n<line34>& 0x1f]\n<line35>: '=');\n<line36>if (!--outlen)\n<line37>break;\n<line38>*out++ =\n<line39>(inlen\n<line40>? b32str[(to_uchar (in[3]) >> 2) & 0x1f]\n<line41>: '=');\n<line42>if (!--outlen)\n<line43>break;\n<line44>*out++ =\n<line45>(inlen\n<line46>? b32str[((to_uchar (in[3]) << 3)\n<line47>+ (--inlen ? to_uchar (in[4]) >> 5 : 0))\n<line48>& 0x1f]\n<line49>: '=');\n<line50>if (!--outlen)\n<line51>break;\n<line52>*out++ = inlen ? b32str[to_uchar (in[4]) & 0x1f] : '=';\n<line53>if (!--outlen)\n<line54>break;\n<line55>if (inlen)\n<line56>inlen--;\n<line57>if (inlen)\n<line58>in += 5;\n<line59>}\n<line60>if (outlen)\n<line61>*out = '\0';\n<line62>}
----------------------------------------
Function: base32_encode_alloc
Content: <line0>idx_t\n<line1>base32_encode_alloc (const char *in, idx_t inlen, char **out)\n<line2>{\n<line3>/* Check for overflow in outlen computation.\n<line4>Treat negative INLEN as overflow, for better compatibility with\n<line5>pre-2021-08-27 API, which used size_t.  */\n<line6>idx_t in_over_5 = inlen / 5 + (inlen % 5 != 0), outlen;\n<line7>if (! INT_MULTIPLY_OK (in_over_5, 8, &outlen) || inlen < 0)\n<line8>{\n<line9>*out = NULL;\n<line10>return 0;\n<line11>}\n<line12>outlen++;\n<line13>*out = imalloc (outlen);\n<line14>if (!*out)\n<line15>return outlen;\n<line16>base32_encode (in, inlen, *out, outlen);\n<line17>return outlen - 1;\n<line18>}
----------------------------------------
Function: base32_decode_ctx_init
Content: <line0>void\n<line1>base32_decode_ctx_init (struct base32_decode_context *ctx)\n<line2>{\n<line3>ctx->i = 0;\n<line4>}
----------------------------------------
Function: get_8
Content: <line0>static char *\n<line1>get_8 (struct base32_decode_context *ctx,\n<line2>char const *restrict *in, char const *restrict in_end,\n<line3>idx_t *n_non_newline)\n<line4>{\n<line5>if (ctx->i == 8)\n<line6>ctx->i = 0;\n<line7>if (ctx->i == 0)\n<line8>{\n<line9>char const *t = *in;\n<line10>if (8 <= in_end - *in && memchr (t, '\n', 8) == NULL)\n<line11>{\n<line12>/* This is the common case: no newline.  */\n<line13>*in += 8;\n<line14>*n_non_newline = 8;\n<line15>return (char *) t;\n<line16>}\n<line17>}\n<line18>{\n<line19>/* Copy non-newline bytes into BUF.  */\n<line20>char const *p = *in;\n<line21>while (p < in_end)\n<line22>{\n<line23>char c = *p++;\n<line24>if (c != '\n')\n<line25>{\n<line26>ctx->buf[ctx->i++] = c;\n<line27>if (ctx->i == 8)\n<line28>break;\n<line29>}\n<line30>}\n<line31>*in = p;\n<line32>*n_non_newline = ctx->i;\n<line33>return ctx->buf;\n<line34>}\n<line35>}
----------------------------------------
Function: decode_8
Content: <line0>static bool\n<line1>decode_8 (char const *restrict in, idx_t inlen,\n<line2>char *restrict *outp, idx_t *outleft)\n<line3>{\n<line4>char *out = *outp;\n<line5>if (inlen < 8)\n<line6>return false;\n<line7>if (!isbase32 (in[0]) || !isbase32 (in[1]))\n<line8>return false;\n<line9>if (*outleft)\n<line10>{\n<line11>*out++ = ((b32[to_uchar (in[0])] << 3)\n<line12>| (b32[to_uchar (in[1])] >> 2));\n<line13>--*outleft;\n<line14>}\n<line15>if (in[2] == '=')\n<line16>{\n<line17>if (in[3] != '=' || in[4] != '=' || in[5] != '='\n<line18>|| in[6] != '=' || in[7] != '=')\n<line19>return_false;\n<line20>}\n<line21>else\n<line22>{\n<line23>if (!isbase32 (in[2]) || !isbase32 (in[3]))\n<line24>return_false;\n<line25>if (*outleft)\n<line26>{\n<line27>*out++ = ((b32[to_uchar (in[1])] << 6)\n<line28>| (b32[to_uchar (in[2])] << 1)\n<line29>| (b32[to_uchar (in[3])] >> 4));\n<line30>--*outleft;\n<line31>}\n<line32>if (in[4] == '=')\n<line33>{\n<line34>if (in[5] != '=' || in[6] != '=' || in[7] != '=')\n<line35>return_false;\n<line36>}\n<line37>else\n<line38>{\n<line39>if (!isbase32 (in[4]))\n<line40>return_false;\n<line41>if (*outleft)\n<line42>{\n<line43>*out++ = ((b32[to_uchar (in[3])] << 4)\n<line44>| (b32[to_uchar (in[4])] >> 1));\n<line45>--*outleft;\n<line46>}\n<line47>if (in[5] == '=')\n<line48>{\n<line49>if (in[6] != '=' || in[7] != '=')\n<line50>return_false;\n<line51>}\n<line52>else\n<line53>{\n<line54>if (!isbase32 (in[5]) || !isbase32 (in[6]))\n<line55>return_false;\n<line56>if (*outleft)\n<line57>{\n<line58>*out++ = ((b32[to_uchar (in[4])] << 7)\n<line59>| (b32[to_uchar (in[5])] << 2)\n<line60>| (b32[to_uchar (in[6])] >> 3));\n<line61>--*outleft;\n<line62>}\n<line63>if (in[7] != '=')\n<line64>{\n<line65>if (!isbase32 (in[7]))\n<line66>return_false;\n<line67>if (*outleft)\n<line68>{\n<line69>*out++ = ((b32[to_uchar (in[6])] << 5)\n<line70>| (b32[to_uchar (in[7])]));\n<line71>--*outleft;\n<line72>}\n<line73>}\n<line74>}\n<line75>}\n<line76>}\n<line77>*outp = out;\n<line78>return true;\n<line79>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/base64.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
Function: to_uchar
Content: <line0>static unsigned char\n<line1>to_uchar (char ch)\n<line2>{\n<line3>return ch;\n<line4>}
----------------------------------------
Function: base64_encode_fast
Content: <line0>static void\n<line1>base64_encode_fast (const char *restrict in, idx_t inlen, char *restrict out)\n<line2>{\n<line3>while (inlen)\n<line4>{\n<line5>*out++ = b64c[(to_uchar (in[0]) >> 2) & 0x3f];\n<line6>*out++ = b64c[((to_uchar (in[0]) << 4) + (to_uchar (in[1]) >> 4)) & 0x3f];\n<line7>*out++ = b64c[((to_uchar (in[1]) << 2) + (to_uchar (in[2]) >> 6)) & 0x3f];\n<line8>*out++ = b64c[to_uchar (in[2]) & 0x3f];\n<line9>inlen -= 3;\n<line10>in += 3;\n<line11>}\n<line12>}
----------------------------------------
Function: base64_encode
Content: <line0>void\n<line1>base64_encode (const char *restrict in, idx_t inlen,\n<line2>char *restrict out, idx_t outlen)\n<line3>{\n<line4>/* Note this outlen constraint can be enforced at compile time.\n<line5>I.E. that the output buffer is exactly large enough to hold\n<line6>the encoded inlen bytes.  The inlen constraints (of corresponding\n<line7>to outlen, and being a multiple of 3) can change at runtime\n<line8>at the end of input.  However the common case when reading\n<line9>large inputs is to have both constraints satisfied, so we depend\n<line10>on both in base_encode_fast().  */\n<line11>if (outlen % 4 == 0 && inlen == (outlen >> 2) * 3)\n<line12>{\n<line13>base64_encode_fast (in, inlen, out);\n<line14>return;\n<line15>}\n<line16>while (inlen && outlen)\n<line17>{\n<line18>*out++ = b64c[(to_uchar (in[0]) >> 2) & 0x3f];\n<line19>if (!--outlen)\n<line20>break;\n<line21>*out++ = b64c[((to_uchar (in[0]) << 4)\n<line22>+ (--inlen ? to_uchar (in[1]) >> 4 : 0))\n<line23>& 0x3f];\n<line24>if (!--outlen)\n<line25>break;\n<line26>*out++ =\n<line27>(inlen\n<line28>? b64c[((to_uchar (in[1]) << 2)\n<line29>+ (--inlen ? to_uchar (in[2]) >> 6 : 0))\n<line30>& 0x3f]\n<line31>: '=');\n<line32>if (!--outlen)\n<line33>break;\n<line34>*out++ = inlen ? b64c[to_uchar (in[2]) & 0x3f] : '=';\n<line35>if (!--outlen)\n<line36>break;\n<line37>if (inlen)\n<line38>inlen--;\n<line39>if (inlen)\n<line40>in += 3;\n<line41>}\n<line42>if (outlen)\n<line43>*out = '\0';\n<line44>}
----------------------------------------
Function: base64_encode_alloc
Content: <line0>idx_t\n<line1>base64_encode_alloc (const char *in, idx_t inlen, char **out)\n<line2>{\n<line3>/* Check for overflow in outlen computation.\n<line4>Treat negative INLEN as overflow, for better compatibility with\n<line5>pre-2021-08-27 API, which used size_t.  */\n<line6>idx_t in_over_3 = inlen / 3 + (inlen % 3 != 0), outlen;\n<line7>if (! INT_MULTIPLY_OK (in_over_3, 4, &outlen) || inlen < 0)\n<line8>{\n<line9>*out = NULL;\n<line10>return 0;\n<line11>}\n<line12>outlen++;\n<line13>*out = imalloc (outlen);\n<line14>if (!*out)\n<line15>return outlen;\n<line16>base64_encode (in, inlen, *out, outlen);\n<line17>return outlen - 1;\n<line18>}
----------------------------------------
Function: base64_decode_ctx_init
Content: <line0>void\n<line1>base64_decode_ctx_init (struct base64_decode_context *ctx)\n<line2>{\n<line3>ctx->i = 0;\n<line4>}
----------------------------------------
Function: get_4
Content: <line0>static char *\n<line1>get_4 (struct base64_decode_context *ctx,\n<line2>char const *restrict *in, char const *restrict in_end,\n<line3>idx_t *n_non_newline)\n<line4>{\n<line5>if (ctx->i == 4)\n<line6>ctx->i = 0;\n<line7>if (ctx->i == 0)\n<line8>{\n<line9>char const *t = *in;\n<line10>if (4 <= in_end - *in && memchr (t, '\n', 4) == NULL)\n<line11>{\n<line12>/* This is the common case: no newline.  */\n<line13>*in += 4;\n<line14>*n_non_newline = 4;\n<line15>return (char *) t;\n<line16>}\n<line17>}\n<line18>{\n<line19>/* Copy non-newline bytes into BUF.  */\n<line20>char const *p = *in;\n<line21>while (p < in_end)\n<line22>{\n<line23>char c = *p++;\n<line24>if (c != '\n')\n<line25>{\n<line26>ctx->buf[ctx->i++] = c;\n<line27>if (ctx->i == 4)\n<line28>break;\n<line29>}\n<line30>}\n<line31>*in = p;\n<line32>*n_non_newline = ctx->i;\n<line33>return ctx->buf;\n<line34>}\n<line35>}
----------------------------------------
Function: decode_4
Content: <line0>static bool\n<line1>decode_4 (char const *restrict in, idx_t inlen,\n<line2>char *restrict *outp, idx_t *outleft)\n<line3>{\n<line4>char *out = *outp;\n<line5>if (inlen < 2)\n<line6>return false;\n<line7>if (!isbase64 (in[0]) || !isbase64 (in[1]))\n<line8>return false;\n<line9>if (*outleft)\n<line10>{\n<line11>*out++ = ((b64[to_uchar (in[0])] << 2)\n<line12>| (b64[to_uchar (in[1])] >> 4));\n<line13>--*outleft;\n<line14>}\n<line15>if (inlen == 2)\n<line16>return_false;\n<line17>if (in[2] == '=')\n<line18>{\n<line19>if (inlen != 4)\n<line20>return_false;\n<line21>if (in[3] != '=')\n<line22>return_false;\n<line23>}\n<line24>else\n<line25>{\n<line26>if (!isbase64 (in[2]))\n<line27>return_false;\n<line28>if (*outleft)\n<line29>{\n<line30>*out++ = (((b64[to_uchar (in[1])] << 4) & 0xf0)\n<line31>| (b64[to_uchar (in[2])] >> 2));\n<line32>--*outleft;\n<line33>}\n<line34>if (inlen == 3)\n<line35>return_false;\n<line36>if (in[3] == '=')\n<line37>{\n<line38>if (inlen != 4)\n<line39>return_false;\n<line40>}\n<line41>else\n<line42>{\n<line43>if (!isbase64 (in[3]))\n<line44>return_false;\n<line45>if (*outleft)\n<line46>{\n<line47>*out++ = (((b64[to_uchar (in[2])] << 6) & 0xc0)\n<line48>| b64[to_uchar (in[3])]);\n<line49>--*outleft;\n<line50>}\n<line51>}\n<line52>}\n<line53>*outp = out;\n<line54>return true;\n<line55>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/basename-lgpl.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
Function: last_component
Content: <line0>char *\n<line1>last_component (char const *name)\n<line2>{\n<line3>char const *base = name + FILE_SYSTEM_PREFIX_LEN (name);\n<line4>char const *p;\n<line5>bool last_was_slash = false;\n<line6>while (ISSLASH (*base))\n<line7>base++;\n<line8>for (p = base; *p; p++)\n<line9>{\n<line10>if (ISSLASH (*p))\n<line11>last_was_slash = true;\n<line12>else if (last_was_slash)\n<line13>{\n<line14>base = p;\n<line15>last_was_slash = false;\n<line16>}\n<line17>}\n<line18>return (char *) base;\n<line19>}
----------------------------------------
Function: base_len
Content: <line0>size_t\n<line1>base_len (char const *name)\n<line2>{\n<line3>size_t len;\n<line4>size_t prefix_len = FILE_SYSTEM_PREFIX_LEN (name);\n<line5>for (len = strlen (name);  1 < len && ISSLASH (name[len - 1]);  len--)\n<line6>continue;\n<line7>if (DOUBLE_SLASH_IS_DISTINCT_ROOT && len == 1\n<line8>&& ISSLASH (name[0]) && ISSLASH (name[1]) && ! name[2])\n<line9>return 2;\n<line10>if (FILE_SYSTEM_DRIVE_PREFIX_CAN_BE_RELATIVE && prefix_len\n<line11>&& len == prefix_len && ISSLASH (name[prefix_len]))\n<line12>return prefix_len + 1;\n<line13>return len;\n<line14>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/binary-io.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
========================================
/home/huihui/Downloads/coreutils-9.4/lib/bitrotate.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
========================================
/home/huihui/Downloads/coreutils-9.4/lib/btoc32.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
========================================
/home/huihui/Downloads/coreutils-9.4/lib/btowc.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
Function: rpl_btowc
Content: <line0>wint_t\n<line1>btowc (int c)\n<line2>{\n<line3>if (c != EOF)\n<line4>{\n<line5>char buf[1];\n<line6>wchar_t wc;\n<line7>buf[0] = c;\n<line8>#if HAVE_MBRTOWC\n<line9>mbstate_t state;\n<line10>mbszero (&state);\n<line11>size_t ret = mbrtowc (&wc, buf, 1, &state);\n<line12>if (!(ret == (size_t)(-1) || ret == (size_t)(-2)))\n<line13>#else\n<line14>if (mbtowc (&wc, buf, 1) >= 0)\n<line15>#endif\n<line16>return wc;\n<line17>}\n<line18>return WEOF;\n<line19>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/buffer-lcm.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
Function: buffer_lcm
Content: <line0>size_t\n<line1>buffer_lcm (size_t a, size_t b, size_t lcm_max)\n<line2>{\n<line3>size_t size;\n<line4>/* Use reasonable values if buffer sizes are zero.  */\n<line5>if (!a)\n<line6>size = b ? b : 8 * 1024;\n<line7>else\n<line8>{\n<line9>if (b)\n<line10>{\n<line11>/* Return lcm (A, B) if it is in range; otherwise, fall back\n<line12>on A.  */\n<line13>size_t lcm, m, n, q, r;\n<line14>/* N = gcd (A, B).  */\n<line15>for (m = a, n = b;  (r = m % n) != 0;  m = n, n = r)\n<line16>continue;\n<line17>/* LCM = lcm (A, B), if in range.  */\n<line18>q = a / n;\n<line19>lcm = q * b;\n<line20>if (lcm <= lcm_max && lcm / b == q)\n<line21>return lcm;\n<line22>}\n<line23>size = a;\n<line24>}\n<line25>return size <= lcm_max ? size : lcm_max;\n<line26>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/c-ctype.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
========================================
/home/huihui/Downloads/coreutils-9.4/lib/c-file-type.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
Function: c_file_type
Content: <line0>char const *\n<line1>c_file_type (struct stat const *st)\n<line2>{\n<line3>/* For some of these formats, see POSIX 1003.1-2017 "file" command,\n<line4>STDOUT section, Table: File Utility Output Strings\n<line5><https://pubs.opengroup.org/onlinepubs/9699919799/utilities/file.html#tagtcjh_27>.\n<line6>To keep diagnostics grammatical in English, the returned string\n<line7>must start with a consonant.  */\n<line8>/* Do these three first, as they're the most common.  */\n<line9>if (S_ISREG (st->st_mode))\n<line10>return st->st_size == 0 ? N_("regular empty file") : N_("regular file");\n<line11>if (S_ISDIR (st->st_mode))\n<line12>return N_("directory");\n<line13>if (S_ISLNK (st->st_mode))\n<line14>return N_("symbolic link");\n<line15>/* Do the S_TYPEIS* macros next, as they may be implemented in terms\n<line16>of S_ISNAM, and we want the more-specialized interpretation.  */\n<line17>if (S_TYPEISMQ (st))\n<line18>return N_("message queue");\n<line19>if (S_TYPEISSEM (st))\n<line20>return N_("semaphore");\n<line21>if (S_TYPEISSHM (st))\n<line22>return N_("shared memory object");\n<line23>if (S_TYPEISTMO (st))\n<line24>return N_("typed memory object");\n<line25>/* The remaining are in alphabetical order.  */\n<line26>if (S_ISBLK (st->st_mode))\n<line27>return N_("block special file");\n<line28>if (S_ISCHR (st->st_mode))\n<line29>return N_("character special file");\n<line30>if (S_ISCTG (st->st_mode))\n<line31>return N_("contiguous data");\n<line32>if (S_ISFIFO (st->st_mode))\n<line33>return N_("fifo");\n<line34>if (S_ISDOOR (st->st_mode))\n<line35>return N_("door");\n<line36>if (S_ISMPB (st->st_mode))\n<line37>return N_("multiplexed block special file");\n<line38>if (S_ISMPC (st->st_mode))\n<line39>return N_("multiplexed character special file");\n<line40>if (S_ISMPX (st->st_mode))\n<line41>return N_("multiplexed file");\n<line42>if (S_ISNAM (st->st_mode))\n<line43>return N_("named file");\n<line44>if (S_ISNWK (st->st_mode))\n<line45>return N_("network special file");\n<line46>if (S_ISOFD (st->st_mode))\n<line47>return N_("migrated file with data");\n<line48>if (S_ISOFL (st->st_mode))\n<line49>return N_("migrated file without data");\n<line50>if (S_ISPORT (st->st_mode))\n<line51>return N_("port");\n<line52>if (S_ISSOCK (st->st_mode))\n<line53>return N_("socket");\n<line54>if (S_ISWHT (st->st_mode))\n<line55>return N_("whiteout");\n<line56>return N_("weird file");\n<line57>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/c-strcasecmp.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
Function: c_strcasecmp
Content: <line0>int\n<line1>c_strcasecmp (const char *s1, const char *s2)\n<line2>{\n<line3>register const unsigned char *p1 = (const unsigned char *) s1;\n<line4>register const unsigned char *p2 = (const unsigned char *) s2;\n<line5>unsigned char c1, c2;\n<line6>if (p1 == p2)\n<line7>return 0;\n<line8>do\n<line9>{\n<line10>c1 = c_tolower (*p1);\n<line11>c2 = c_tolower (*p2);\n<line12>if (c1 == '\0')\n<line13>break;\n<line14>++p1;\n<line15>++p2;\n<line16>}\n<line17>while (c1 == c2);\n<line18>if (UCHAR_MAX <= INT_MAX)\n<line19>return c1 - c2;\n<line20>else\n<line21>/* On machines where 'char' and 'int' are types of the same size, the\n<line22>difference of two 'unsigned char' values - including the sign bit -\n<line23>doesn't fit in an 'int'.  */\n<line24>return _GL_CMP (c1, c2);\n<line25>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/c-strncasecmp.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
Function: c_strncasecmp
Content: <line0>int\n<line1>c_strncasecmp (const char *s1, const char *s2, size_t n)\n<line2>{\n<line3>register const unsigned char *p1 = (const unsigned char *) s1;\n<line4>register const unsigned char *p2 = (const unsigned char *) s2;\n<line5>unsigned char c1, c2;\n<line6>if (p1 == p2 || n == 0)\n<line7>return 0;\n<line8>do\n<line9>{\n<line10>c1 = c_tolower (*p1);\n<line11>c2 = c_tolower (*p2);\n<line12>if (--n == 0 || c1 == '\0')\n<line13>break;\n<line14>++p1;\n<line15>++p2;\n<line16>}\n<line17>while (c1 == c2);\n<line18>if (UCHAR_MAX <= INT_MAX)\n<line19>return c1 - c2;\n<line20>else\n<line21>/* On machines where 'char' and 'int' are types of the same size, the\n<line22>difference of two 'unsigned char' values - including the sign bit -\n<line23>doesn't fit in an 'int'.  */\n<line24>return _GL_CMP (c1, c2);\n<line25>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/c-strtod.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
Function: c_locale
Content: <line0>static locale_t\n<line1>c_locale (void)\n<line2>{\n<line3>if (!c_locale_cache)\n<line4>c_locale_cache = newlocale (LC_ALL_MASK, "C", (locale_t) 0);\n<line5>return c_locale_cache;\n<line6>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/c-strtold.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
========================================
/home/huihui/Downloads/coreutils-9.4/lib/c32_apply_type_test.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
========================================
/home/huihui/Downloads/coreutils-9.4/lib/c32_get_type_test.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
========================================
/home/huihui/Downloads/coreutils-9.4/lib/c32isalnum.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
========================================
/home/huihui/Downloads/coreutils-9.4/lib/c32isalpha.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
========================================
/home/huihui/Downloads/coreutils-9.4/lib/c32isblank.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
========================================
/home/huihui/Downloads/coreutils-9.4/lib/c32iscntrl.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
========================================
/home/huihui/Downloads/coreutils-9.4/lib/c32isdigit.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
========================================
/home/huihui/Downloads/coreutils-9.4/lib/c32isgraph.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
========================================
/home/huihui/Downloads/coreutils-9.4/lib/c32islower.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
========================================
/home/huihui/Downloads/coreutils-9.4/lib/c32isprint.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
========================================
/home/huihui/Downloads/coreutils-9.4/lib/c32ispunct.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
========================================
/home/huihui/Downloads/coreutils-9.4/lib/c32isspace.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
========================================
/home/huihui/Downloads/coreutils-9.4/lib/c32isupper.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
========================================
/home/huihui/Downloads/coreutils-9.4/lib/c32isxdigit.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
========================================
/home/huihui/Downloads/coreutils-9.4/lib/c32tolower.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
========================================
/home/huihui/Downloads/coreutils-9.4/lib/c32width.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
========================================
/home/huihui/Downloads/coreutils-9.4/lib/canon-host.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
Function: canon_host
Content: <line0>char *\n<line1>canon_host (const char *host)\n<line2>{\n<line3>return canon_host_r (host, &last_cherror);\n<line4>}
----------------------------------------
Function: canon_host_r
Content: <line0>char *\n<line1>canon_host_r (char const *host, int *cherror)\n<line2>{\n<line3>char *retval = NULL;\n<line4>static struct addrinfo hints;\n<line5>struct addrinfo *res = NULL;\n<line6>int status;\n<line7>hints.ai_flags = AI_CANONNAME;\n<line8>status = getaddrinfo (host, NULL, &hints, &res);\n<line9>if (!status)\n<line10>{\n<line11>/* https://lists.gnu.org/r/bug-coreutils/2006-09/msg00300.html\n<line12>says Darwin 7.9.0 getaddrinfo returns 0 but sets\n<line13>res->ai_canonname to NULL.  */\n<line14>retval = strdup (res->ai_canonname ? res->ai_canonname : host);\n<line15>if (!retval && cherror)\n<line16>*cherror = EAI_MEMORY;\n<line17>freeaddrinfo (res);\n<line18>}\n<line19>else if (cherror)\n<line20>*cherror = status;\n<line21>return retval;\n<line22>}
----------------------------------------
Function: ch_strerror
Content: <line0>const char *\n<line1>ch_strerror (void)\n<line2>{\n<line3>return gai_strerror (last_cherror);\n<line4>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/canonicalize.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
Function: file_accessible
Content: <line0>static bool\n<line1>file_accessible (char const *file)\n<line2>{\n<line3># if HAVE_FACCESSAT\n<line4>return faccessat (AT_FDCWD, file, F_OK, AT_EACCESS) == 0;\n<line5># else\n<line6>struct stat st;\n<line7>return stat (file, &st) == 0 || errno == EOVERFLOW;\n<line8># endif\n<line9>}
----------------------------------------
Function: suffix_requires_dir_check
Content: <line0>static bool _GL_ATTRIBUTE_PURE\n<line1>suffix_requires_dir_check (char const *end)\n<line2>{\n<line3>/* If END does not start with a slash, the suffix is OK.  */\n<line4>while (ISSLASH (*end))\n<line5>{\n<line6>/* Two or more slashes act like a single slash.  */\n<line7>do\n<line8>end++;\n<line9>while (ISSLASH (*end));\n<line10>switch (*end++)\n<line11>{\n<line12>default: return false;  /* An ordinary file name component is OK.  */\n<line13>case '\0': return true; /* Trailing "/" is trouble.  */\n<line14>case '.': break;        /* Possibly "." or "..".  */\n<line15>}\n<line16>/* Trailing "/.", or "/.." even if not trailing, is trouble.  */\n<line17>if (!*end || (*end == '.' && (!end[1] || ISSLASH (end[1]))))\n<line18>return true;\n<line19>}\n<line20>return false;\n<line21>}
----------------------------------------
Function: dir_check
Content: <line0>static bool\n<line1>dir_check (char *dir, char *dirend)\n<line2>{\n<line3>strcpy (dirend, dir_suffix);\n<line4>return file_accessible (dir);\n<line5>}
----------------------------------------
Function: multiple_bits_set
Content: <line0>static bool\n<line1>multiple_bits_set (canonicalize_mode_t i)\n<line2>{\n<line3>return (i & (i - 1)) != 0;\n<line4>}
----------------------------------------
Function: seen_triple
Content: <line0>static bool\n<line1>seen_triple (Hash_table **ht, char const *filename, struct stat const *st)\n<line2>{\n<line3>if (*ht == NULL)\n<line4>{\n<line5>idx_t initial_capacity = 7;\n<line6>*ht = hash_initialize (initial_capacity,\n<line7>NULL,\n<line8>triple_hash,\n<line9>triple_compare_ino_str,\n<line10>triple_free);\n<line11>if (*ht == NULL)\n<line12>xalloc_die ();\n<line13>}\n<line14>if (seen_file (*ht, filename, st))\n<line15>return true;\n<line16>record_file (*ht, filename, st);\n<line17>return false;\n<line18>}
----------------------------------------
Function: canonicalize_filename_mode_stk
Content: <line0>static char *\n<line1>canonicalize_filename_mode_stk (const char *name, canonicalize_mode_t can_mode,\n<line2>struct realpath_bufs *bufs)\n<line3>{\n<line4>char *dest;\n<line5>char const *start;\n<line6>char const *end;\n<line7>Hash_table *ht = NULL;\n<line8>bool logical = (can_mode & CAN_NOLINKS) != 0;\n<line9>int num_links = 0;\n<line10>canonicalize_mode_t can_exist = can_mode & CAN_MODE_MASK;\n<line11>if (multiple_bits_set (can_exist))\n<line12>{\n<line13>errno = EINVAL;\n<line14>return NULL;\n<line15>}\n<line16>if (name == NULL)\n<line17>{\n<line18>errno = EINVAL;\n<line19>return NULL;\n<line20>}\n<line21>if (name[0] == '\0')\n<line22>{\n<line23>errno = ENOENT;\n<line24>return NULL;\n<line25>}\n<line26>char *rname = bufs->rname.data;\n<line27>bool end_in_extra_buffer = false;\n<line28>bool failed = true;\n<line29>/* This is always zero for Posix hosts, but can be 2 for MS-Windows\n<line30>and MS-DOS X:/foo/bar file names.  */\n<line31>idx_t prefix_len = FILE_SYSTEM_PREFIX_LEN (name);\n<line32>if (!IS_ABSOLUTE_FILE_NAME (name))\n<line33>{\n<line34>while (!getcwd (bufs->rname.data, bufs->rname.length))\n<line35>{\n<line36>switch (errno)\n<line37>{\n<line38>case ERANGE:\n<line39>if (scratch_buffer_grow (&bufs->rname))\n<line40>break;\n<line41>FALLTHROUGH;\n<line42>case ENOMEM:\n<line43>xalloc_die ();\n<line44>default:\n<line45>dest = rname;\n<line46>goto error;\n<line47>}\n<line48>rname = bufs->rname.data;\n<line49>}\n<line50>dest = rawmemchr (rname, '\0');\n<line51>start = name;\n<line52>prefix_len = FILE_SYSTEM_PREFIX_LEN (rname);\n<line53>}\n<line54>else\n<line55>{\n<line56>dest = mempcpy (rname, name, prefix_len);\n<line57>*dest++ = '/';\n<line58>if (DOUBLE_SLASH_IS_DISTINCT_ROOT)\n<line59>{\n<line60>if (prefix_len == 0 /* implies ISSLASH (name[0]) */\n<line61>&& ISSLASH (name[1]) && !ISSLASH (name[2]))\n<line62>{\n<line63>*dest++ = '/';\n<line64>#if defined _WIN32 && !defined __CYGWIN__\n<line65>/* For UNC file names '\\server\path\to\file', extend the prefix\n<line66>to include the server: '\\server\'.  */\n<line67>{\n<line68>idx_t i;\n<line69>for (i = 2; name[i] != '\0' && !ISSLASH (name[i]); )\n<line70>i++;\n<line71>if (name[i] != '\0' /* implies ISSLASH (name[i]) */\n<line72>&& i + 1 < bufs->rname.length)\n<line73>{\n<line74>prefix_len = i;\n<line75>memcpy (dest, name + 2, i - 2 + 1);\n<line76>dest += i - 2 + 1;\n<line77>}\n<line78>else\n<line79>{\n<line80>/* Either name = '\\server'; this is an invalid file name.\n<line81>Or name = '\\server\...' and server is more than\n<line82>bufs->rname.length - 4 bytes long.  In either\n<line83>case, stop the UNC processing.  */\n<line84>}\n<line85>}\n<line86>#endif\n<line87>}\n<line88>*dest = '\0';\n<line89>}\n<line90>start = name + prefix_len;\n<line91>}\n<line92>for ( ; *start; start = end)\n<line93>{\n<line94>/* Skip sequence of multiple file name separators.  */\n<line95>while (ISSLASH (*start))\n<line96>++start;\n<line97>/* Find end of component.  */\n<line98>for (end = start; *end && !ISSLASH (*end); ++end)\n<line99>/* Nothing.  */;\n<line100>/* Length of this file name component; it can be zero if a file\n<line101>name ends in '/'.  */\n<line102>idx_t startlen = end - start;\n<line103>if (startlen == 0)\n<line104>break;\n<line105>else if (startlen == 1 && start[0] == '.')\n<line106>/* nothing */;\n<line107>else if (startlen == 2 && start[0] == '.' && start[1] == '.')\n<line108>{\n<line109>/* Back up to previous component, ignore if at root already.  */\n<line110>if (dest > rname + prefix_len + 1)\n<line111>for (--dest; dest > rname && !ISSLASH (dest[-1]); --dest)\n<line112>continue;\n<line113>if (DOUBLE_SLASH_IS_DISTINCT_ROOT\n<line114>&& dest == rname + 1 && !prefix_len\n<line115>&& ISSLASH (*dest) && !ISSLASH (dest[1]))\n<line116>dest++;\n<line117>}\n<line118>else\n<line119>{\n<line120>if (!ISSLASH (dest[-1]))\n<line121>*dest++ = '/';\n<line122>while (rname + bufs->rname.length - dest\n<line123>< startlen + sizeof dir_suffix)\n<line124>{\n<line125>idx_t dest_offset = dest - rname;\n<line126>if (!scratch_buffer_grow_preserve (&bufs->rname))\n<line127>xalloc_die ();\n<line128>rname = bufs->rname.data;\n<line129>dest = rname + dest_offset;\n<line130>}\n<line131>dest = mempcpy (dest, start, startlen);\n<line132>*dest = '\0';\n<line133>char *buf;\n<line134>ssize_t n = -1;\n<line135>if (!logical)\n<line136>{\n<line137>while (true)\n<line138>{\n<line139>buf = bufs->link.data;\n<line140>idx_t bufsize = bufs->link.length;\n<line141>n = readlink (rname, buf, bufsize - 1);\n<line142>if (n < bufsize - 1)\n<line143>break;\n<line144>if (!scratch_buffer_grow (&bufs->link))\n<line145>xalloc_die ();\n<line146>}\n<line147>}\n<line148>if (0 <= n)\n<line149>{\n<line150>/* A physical traversal and RNAME is a symbolic link.  */\n<line151>if (num_links < 20)\n<line152>num_links++;\n<line153>else if (*start)\n<line154>{\n<line155>/* Enough symlinks have been seen that it is time to\n<line156>worry about being in a symlink cycle.\n<line157>Get the device and inode of the parent directory, as\n<line158>pre-2017 POSIX says this info is not reliable for\n<line159>symlinks.  */\n<line160>struct stat st;\n<line161>dest[- startlen] = '\0';\n<line162>if (stat (*rname ? rname : ".", &st) != 0)\n<line163>goto error;\n<line164>dest[- startlen] = *start;\n<line165>/* Detect loops.  We cannot use the cycle-check module here,\n<line166>since it's possible to encounter the same parent\n<line167>directory more than once in a given traversal.  However,\n<line168>encountering the same (parentdir, START) pair twice does\n<line169>indicate a loop.  */\n<line170>if (seen_triple (&ht, start, &st))\n<line171>{\n<line172>if (can_exist == CAN_MISSING)\n<line173>continue;\n<line174>errno = ELOOP;\n<line175>goto error;\n<line176>}\n<line177>}\n<line178>buf[n] = '\0';\n<line179>char *extra_buf = bufs->extra.data;\n<line180>idx_t end_idx;\n<line181>if (end_in_extra_buffer)\n<line182>end_idx = end - extra_buf;\n<line183>size_t len = strlen (end);\n<line184>if (INT_ADD_OVERFLOW (len, n))\n<line185>xalloc_die ();\n<line186>while (bufs->extra.length <= len + n)\n<line187>{\n<line188>if (!scratch_buffer_grow_preserve (&bufs->extra))\n<line189>xalloc_die ();\n<line190>extra_buf = bufs->extra.data;\n<line191>}\n<line192>if (end_in_extra_buffer)\n<line193>end = extra_buf + end_idx;\n<line194>/* Careful here, end may be a pointer into extra_buf... */\n<line195>memmove (&extra_buf[n], end, len + 1);\n<line196>name = end = memcpy (extra_buf, buf, n);\n<line197>end_in_extra_buffer = true;\n<line198>if (IS_ABSOLUTE_FILE_NAME (buf))\n<line199>{\n<line200>idx_t pfxlen = FILE_SYSTEM_PREFIX_LEN (buf);\n<line201>dest = mempcpy (rname, buf, pfxlen);\n<line202>*dest++ = '/'; /* It's an absolute symlink */\n<line203>if (DOUBLE_SLASH_IS_DISTINCT_ROOT)\n<line204>{\n<line205>if (ISSLASH (buf[1]) && !ISSLASH (buf[2]) && !pfxlen)\n<line206>*dest++ = '/';\n<line207>*dest = '\0';\n<line208>}\n<line209>/* Install the new prefix to be in effect hereafter.  */\n<line210>prefix_len = pfxlen;\n<line211>}\n<line212>else\n<line213>{\n<line214>/* Back up to previous component, ignore if at root\n<line215>already: */\n<line216>if (dest > rname + prefix_len + 1)\n<line217>for (--dest; dest > rname && !ISSLASH (dest[-1]); --dest)\n<line218>continue;\n<line219>if (DOUBLE_SLASH_IS_DISTINCT_ROOT && dest == rname + 1\n<line220>&& ISSLASH (*dest) && !ISSLASH (dest[1]) && !prefix_len)\n<line221>dest++;\n<line222>}\n<line223>}\n<line224>else if (! (can_exist == CAN_MISSING\n<line225>|| (suffix_requires_dir_check (end)\n<line226>? dir_check (rname, dest)\n<line227>: !logical\n<line228>? errno == EINVAL\n<line229>: *end || file_accessible (rname))\n<line230>|| (can_exist == CAN_ALL_BUT_LAST\n<line231>&& errno == ENOENT\n<line232>&& !end[strspn (end, SLASHES)])))\n<line233>goto error;\n<line234>}\n<line235>}\n<line236>if (dest > rname + prefix_len + 1 && ISSLASH (dest[-1]))\n<line237>--dest;\n<line238>if (DOUBLE_SLASH_IS_DISTINCT_ROOT && dest == rname + 1 && !prefix_len\n<line239>&& ISSLASH (*dest) && !ISSLASH (dest[1]))\n<line240>dest++;\n<line241>failed = false;\n<line242>error:\n<line243>if (ht)\n<line244>hash_free (ht);\n<line245>if (failed)\n<line246>return NULL;\n<line247>*dest++ = '\0';\n<line248>char *result = malloc (dest - rname);\n<line249>if (!result)\n<line250>xalloc_die ();\n<line251>return memcpy (result, rname, dest - rname);\n<line252>}
----------------------------------------
Function: canonicalize_filename_mode
Content: <line0>char *\n<line1>canonicalize_filename_mode (const char *name, canonicalize_mode_t can_mode)\n<line2>{\n<line3>struct realpath_bufs bufs;\n<line4>scratch_buffer_init (&bufs.rname);\n<line5>scratch_buffer_init (&bufs.extra);\n<line6>scratch_buffer_init (&bufs.link);\n<line7>char *result = canonicalize_filename_mode_stk (name, can_mode, &bufs);\n<line8>scratch_buffer_free (&bufs.link);\n<line9>scratch_buffer_free (&bufs.extra);\n<line10>scratch_buffer_free (&bufs.rname);\n<line11>return result;\n<line12>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/careadlinkat.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
Function: readlink_stk
Content: <line0>static char *\n<line1>readlink_stk (int fd, char const *filename,\n<line2>char *buffer, size_t buffer_size,\n<line3>struct allocator const *alloc,\n<line4>ssize_t (*preadlinkat) (int, char const *, char *, size_t),\n<line5>char stack_buf[STACK_BUF_SIZE])\n<line6>{\n<line7>if (! alloc)\n<line8>alloc = &stdlib_allocator;\n<line9>if (!buffer)\n<line10>{\n<line11>buffer = stack_buf;\n<line12>buffer_size = STACK_BUF_SIZE;\n<line13>}\n<line14>char *buf = buffer;\n<line15>idx_t buf_size_max = MIN (IDX_MAX, MIN (SSIZE_MAX, SIZE_MAX));\n<line16>idx_t buf_size = MIN (buffer_size, buf_size_max);\n<line17>while (buf)\n<line18>{\n<line19>/* Attempt to read the link into the current buffer.  */\n<line20>idx_t link_length = preadlinkat (fd, filename, buf, buf_size);\n<line21>if (link_length < 0)\n<line22>{\n<line23>if (buf != buffer)\n<line24>{\n<line25>int readlinkat_errno = errno;\n<line26>alloc->free (buf);\n<line27>errno = readlinkat_errno;\n<line28>}\n<line29>return NULL;\n<line30>}\n<line31>idx_t link_size = link_length;\n<line32>if (link_size < buf_size)\n<line33>{\n<line34>buf[link_size++] = '\0';\n<line35>if (buf == stack_buf)\n<line36>{\n<line37>char *b = alloc->allocate (link_size);\n<line38>buf_size = link_size;\n<line39>if (! b)\n<line40>break;\n<line41>return memcpy (b, buf, link_size);\n<line42>}\n<line43>if (link_size < buf_size && buf != buffer && alloc->reallocate)\n<line44>{\n<line45>/* Shrink BUF before returning it.  */\n<line46>char *b = alloc->reallocate (buf, link_size);\n<line47>if (b)\n<line48>return b;\n<line49>}\n<line50>return buf;\n<line51>}\n<line52>if (buf != buffer)\n<line53>alloc->free (buf);\n<line54>if (buf_size_max / 2 <= buf_size)\n<line55>{\n<line56>errno = ENAMETOOLONG;\n<line57>return NULL;\n<line58>}\n<line59>buf_size = 2 * buf_size + 1;\n<line60>buf = alloc->allocate (buf_size);\n<line61>}\n<line62>if (alloc->die)\n<line63>alloc->die (buf_size);\n<line64>errno = ENOMEM;\n<line65>return NULL;\n<line66>}
----------------------------------------
Function: careadlinkat
Content: <line0>char *\n<line1>careadlinkat (int fd, char const *filename,\n<line2>char *buffer, size_t buffer_size,\n<line3>struct allocator const *alloc,\n<line4>ssize_t (*preadlinkat) (int, char const *, char *, size_t))\n<line5>{\n<line6>/* Allocate the initial buffer on the stack.  This way, in the\n<line7>common case of a symlink of small size, we get away with a\n<line8>single small malloc instead of a big malloc followed by a\n<line9>shrinking realloc.  */\n<line10>#ifdef GCC_BOGUS_WRETURN_LOCAL_ADDR\n<line11>#warning "GCC might issue a bogus -Wreturn-local-addr warning here."\n<line12>#warning "See <https://gcc.gnu.org/bugzilla/show_bug.cgi?id=93644>."\n<line13>#endif\n<line14>char stack_buf[STACK_BUF_SIZE];\n<line15>return readlink_stk (fd, filename, buffer, buffer_size, alloc,\n<line16>preadlinkat, stack_buf);\n<line17>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/chdir-long.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
Function: cdb_init
Content: <line0>static void\n<line1>cdb_init (struct cd_buf *cdb)\n<line2>{\n<line3>cdb->fd = AT_FDCWD;\n<line4>}
----------------------------------------
Function: cdb_fchdir
Content: <line0>static int\n<line1>cdb_fchdir (struct cd_buf const *cdb)\n<line2>{\n<line3>return fchdir (cdb->fd);\n<line4>}
----------------------------------------
Function: cdb_free
Content: <line0>static void\n<line1>cdb_free (struct cd_buf const *cdb)\n<line2>{\n<line3>if (0 <= cdb->fd)\n<line4>{\n<line5>bool close_fail = close (cdb->fd);\n<line6>assure (! close_fail);\n<line7>}\n<line8>}
----------------------------------------
Function: cdb_advance_fd
Content: <line0>static int\n<line1>cdb_advance_fd (struct cd_buf *cdb, char const *dir)\n<line2>{\n<line3>int new_fd = openat (cdb->fd, dir,\n<line4>O_SEARCH | O_DIRECTORY | O_NOCTTY | O_NONBLOCK);\n<line5>if (new_fd < 0)\n<line6>return -1;\n<line7>cdb_free (cdb);\n<line8>cdb->fd = new_fd;\n<line9>return 0;\n<line10>}
----------------------------------------
Function: find_non_slash
Content: <line0>static char * _GL_ATTRIBUTE_PURE\n<line1>find_non_slash (char const *s)\n<line2>{\n<line3>size_t n_slash = strspn (s, "/");\n<line4>return (char *) s + n_slash;\n<line5>}
----------------------------------------
Function: chdir_long
Content: <line0>int\n<line1>chdir_long (char *dir)\n<line2>{\n<line3>int e = chdir (dir);\n<line4>if (e == 0 || errno != ENAMETOOLONG)\n<line5>return e;\n<line6>{\n<line7>size_t len = strlen (dir);\n<line8>char *dir_end = dir + len;\n<line9>struct cd_buf cdb;\n<line10>size_t n_leading_slash;\n<line11>cdb_init (&cdb);\n<line12>/* If DIR is the empty string, then the chdir above\n<line13>must have failed and set errno to ENOENT.  */\n<line14>assure (0 < len);\n<line15>assure (PATH_MAX <= len);\n<line16>/* Count leading slashes.  */\n<line17>n_leading_slash = strspn (dir, "/");\n<line18>/* Handle any leading slashes as well as any name that matches\n<line19>the regular expression, m!^//hostname[/]*! .  Handling this\n<line20>prefix separately usually results in a single additional\n<line21>cdb_advance_fd call, but it's worthwhile, since it makes the\n<line22>code in the following loop cleaner.  */\n<line23>if (n_leading_slash == 2)\n<line24>{\n<line25>int err;\n<line26>/* Find next slash.\n<line27>We already know that dir[2] is neither a slash nor '\0'.  */\n<line28>char *slash = memchr (dir + 3, '/', dir_end - (dir + 3));\n<line29>if (slash == NULL)\n<line30>{\n<line31>errno = ENAMETOOLONG;\n<line32>return -1;\n<line33>}\n<line34>*slash = '\0';\n<line35>err = cdb_advance_fd (&cdb, dir);\n<line36>*slash = '/';\n<line37>if (err != 0)\n<line38>goto Fail;\n<line39>dir = find_non_slash (slash + 1);\n<line40>}\n<line41>else if (n_leading_slash)\n<line42>{\n<line43>if (cdb_advance_fd (&cdb, "/") != 0)\n<line44>goto Fail;\n<line45>dir += n_leading_slash;\n<line46>}\n<line47>assure (*dir != '/');\n<line48>assure (dir <= dir_end);\n<line49>while (PATH_MAX <= dir_end - dir)\n<line50>{\n<line51>int err;\n<line52>/* Find a slash that is PATH_MAX or fewer bytes away from dir.\n<line53>I.e. see if there is a slash that will give us a name of\n<line54>length PATH_MAX-1 or less.  */\n<line55>char *slash = memrchr (dir, '/', PATH_MAX);\n<line56>if (slash == NULL)\n<line57>{\n<line58>errno = ENAMETOOLONG;\n<line59>return -1;\n<line60>}\n<line61>*slash = '\0';\n<line62>assure (slash - dir < PATH_MAX);\n<line63>err = cdb_advance_fd (&cdb, dir);\n<line64>*slash = '/';\n<line65>if (err != 0)\n<line66>goto Fail;\n<line67>dir = find_non_slash (slash + 1);\n<line68>}\n<line69>if (dir < dir_end)\n<line70>{\n<line71>if (cdb_advance_fd (&cdb, dir) != 0)\n<line72>goto Fail;\n<line73>}\n<line74>if (cdb_fchdir (&cdb) != 0)\n<line75>goto Fail;\n<line76>cdb_free (&cdb);\n<line77>return 0;\n<line78>Fail:\n<line79>{\n<line80>int saved_errno = errno;\n<line81>cdb_free (&cdb);\n<line82>errno = saved_errno;\n<line83>return -1;\n<line84>}\n<line85>}\n<line86>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/chmodat.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
========================================
/home/huihui/Downloads/coreutils-9.4/lib/chownat.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
========================================
/home/huihui/Downloads/coreutils-9.4/lib/cl-strtod.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
========================================
/home/huihui/Downloads/coreutils-9.4/lib/cl-strtold.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
========================================
/home/huihui/Downloads/coreutils-9.4/lib/cloexec.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
Function: set_cloexec_flag
Content: <line0>int\n<line1>set_cloexec_flag (int desc, bool value)\n<line2>{\n<line3>#ifdef F_SETFD\n<line4>int flags = fcntl (desc, F_GETFD, 0);\n<line5>if (0 <= flags)\n<line6>{\n<line7>int newflags = (value ? flags | FD_CLOEXEC : flags & ~FD_CLOEXEC);\n<line8>if (flags == newflags\n<line9>|| fcntl (desc, F_SETFD, newflags) != -1)\n<line10>return 0;\n<line11>}\n<line12>return -1;\n<line13>#else /* !F_SETFD */\n<line14>/* Use dup2 to reject invalid file descriptors; the cloexec flag\n<line15>will be unaffected.  */\n<line16>if (desc < 0)\n<line17>{\n<line18>errno = EBADF;\n<line19>return -1;\n<line20>}\n<line21>if (dup2 (desc, desc) < 0)\n<line22>/* errno is EBADF here.  */\n<line23>return -1;\n<line24>/* There is nothing we can do on this kind of platform.  Punt.  */\n<line25>return 0;\n<line26>#endif /* !F_SETFD */\n<line27>}
----------------------------------------
Function: dup_cloexec
Content: <line0>int\n<line1>dup_cloexec (int fd)\n<line2>{\n<line3>return fcntl (fd, F_DUPFD_CLOEXEC, 0);\n<line4>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/close-stream.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
Function: close_stream
Content: <line0>int\n<line1>close_stream (FILE *stream)\n<line2>{\n<line3>const bool some_pending = (__fpending (stream) != 0);\n<line4>const bool prev_fail = (ferror (stream) != 0);\n<line5>const bool fclose_fail = (fclose (stream) != 0);\n<line6>/* Return an error indication if there was a previous failure or if\n<line7>fclose failed, with one exception: ignore an fclose failure if\n<line8>there was no previous error, no data remains to be flushed, and\n<line9>fclose failed with EBADF.  That can happen when a program like cp\n<line10>is invoked like this 'cp a b >&-' (i.e., with standard output\n<line11>closed) and doesn't generate any output (hence no previous error\n<line12>and nothing to be flushed).  */\n<line13>if (prev_fail || (fclose_fail && (some_pending || errno != EBADF)))\n<line14>{\n<line15>if (! fclose_fail)\n<line16>errno = 0;\n<line17>return EOF;\n<line18>}\n<line19>return 0;\n<line20>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/closein.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
In file included from /home/huihui/Downloads/coreutils-9.4/lib/closein.c:31:
./lib/error.h:28:3: warning: #include_next in file found relative to primary source file or found by absolute path; will search from start of include path [-Winclude-next-absolute-path]
# include_next <error.h>
  ^
2 warnings generated.
Function: close_stdin_set_file_name
Content: <line0>void\n<line1>close_stdin_set_file_name (const char *file)\n<line2>{\n<line3>file_name = file;\n<line4>}
----------------------------------------
Function: close_stdin
Content: <line0>void\n<line1>close_stdin (void)\n<line2>{\n<line3>bool fail = false;\n<line4>/* There is no need to flush stdin if we can determine quickly that stdin's\n<line5>input buffer is empty; in this case we know that if stdin is seekable,\n<line6>(fseeko (stdin, 0, SEEK_CUR), ftello (stdin))\n<line7>== lseek (0, 0, SEEK_CUR).  */\n<line8>if (freadahead (stdin) > 0)\n<line9>{\n<line10>/* Only attempt flush if stdin is seekable, as fflush is entitled to\n<line11>fail on non-seekable streams.  */\n<line12>if (fseeko (stdin, 0, SEEK_CUR) == 0 && fflush (stdin) != 0)\n<line13>fail = true;\n<line14>}\n<line15>if (close_stream (stdin) != 0)\n<line16>fail = true;\n<line17>if (fail)\n<line18>{\n<line19>/* Report failure, but defer exit until after closing stdout,\n<line20>since the failure report should still be flushed.  */\n<line21>char const *close_error = _("error closing file");\n<line22>if (file_name)\n<line23>error (0, errno, "%s: %s", quotearg_colon (file_name),\n<line24>close_error);\n<line25>else\n<line26>error (0, errno, "%s", close_error);\n<line27>}\n<line28>close_stdout ();\n<line29>if (fail)\n<line30>_exit (exit_failure);\n<line31>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/closeout.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
In file included from /home/huihui/Downloads/coreutils-9.4/lib/closeout.c:31:
./lib/error.h:28:3: warning: #include_next in file found relative to primary source file or found by absolute path; will search from start of include path [-Winclude-next-absolute-path]
# include_next <error.h>
  ^
2 warnings generated.
Function: close_stdout_set_file_name
Content: <line0>void\n<line1>close_stdout_set_file_name (const char *file)\n<line2>{\n<line3>file_name = file;\n<line4>}
----------------------------------------
Function: close_stdout_set_ignore_EPIPE
Content: <line0>void\n<line1>close_stdout_set_ignore_EPIPE (bool ignore)\n<line2>{\n<line3>ignore_EPIPE = ignore;\n<line4>}
----------------------------------------
Function: close_stdout
Content: <line0>void\n<line1>close_stdout (void)\n<line2>{\n<line3>if (close_stream (stdout) != 0\n<line4>&& !(ignore_EPIPE && errno == EPIPE))\n<line5>{\n<line6>char const *write_error = _("write error");\n<line7>if (file_name)\n<line8>error (0, errno, "%s: %s", quotearg_colon (file_name),\n<line9>write_error);\n<line10>else\n<line11>error (0, errno, "%s", write_error);\n<line12>_exit (exit_failure);\n<line13>}\n<line14>/* Close stderr only if not sanitizing, as sanitizers may report to\n<line15>stderr after this function returns.  */\n<line16>if (!SANITIZE_ADDRESS && close_stream (stderr) != 0)\n<line17>_exit (exit_failure);\n<line18>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/copy-file-range.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
Function: rpl_copy_file_range
Content: <line0>ssize_t\n<line1>copy_file_range (int infd, off_t *pinoff,\n<line2>int outfd, off_t *poutoff,\n<line3>size_t length, unsigned int flags)\n<line4>{\n<line5>#undef copy_file_range\n<line6>#if defined __linux__ && HAVE_COPY_FILE_RANGE\n<line7>/* The implementation of copy_file_range (which first appeared in\n<line8>Linux kernel release 4.5) had many issues before release 5.3\n<line9><https://lwn.net/Articles/789527/>, so fail with ENOSYS for Linux\n<line10>kernels 5.2 and earlier.\n<line11>This workaround, and the configure-time check for Linux, can be\n<line12>removed when such kernels (released March 2016 through September\n<line13>2019) are no longer a consideration.  As of January 2021, the\n<line14>furthest-future planned kernel EOL is December 2024 for kernel\n<line15>release 4.19.  */\n<line16>static signed char ok;\n<line17>if (! ok)\n<line18>{\n<line19>struct utsname name;\n<line20>uname (&name);\n<line21>char *p = name.release;\n<line22>ok = ((p[1] != '.' || '5' < p[0]\n<line23>|| (p[0] == '5' && (p[3] != '.' || '2' < p[2])))\n<line24>? 1 : -1);\n<line25>}\n<line26>if (0 < ok)\n<line27>return copy_file_range (infd, pinoff, outfd, poutoff, length, flags);\n<line28>#endif\n<line29>/* There is little need to emulate copy_file_range with read+write,\n<line30>since programs that use copy_file_range must fall back on\n<line31>read+write anyway.  */\n<line32>errno = ENOSYS;\n<line33>return -1;\n<line34>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/count-leading-zeros.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
========================================
/home/huihui/Downloads/coreutils-9.4/lib/af_alg.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
========================================
/home/huihui/Downloads/coreutils-9.4/lib/md5-stream.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
Function: md5_stream
Content: <line0>int\n<line1>md5_stream (FILE *stream, void *resblock)\n<line2>{\n<line3>switch (afalg_stream (stream, "md5", resblock, MD5_DIGEST_SIZE))\n<line4>{\n<line5>case 0: return 0;\n<line6>case -EIO: return 1;\n<line7>}\n<line8>char *buffer = malloc (BLOCKSIZE + 72);\n<line9>if (!buffer)\n<line10>return 1;\n<line11>struct md5_ctx ctx;\n<line12>md5_init_ctx (&ctx);\n<line13>size_t sum;\n<line14>/* Iterate over full file contents.  */\n<line15>while (1)\n<line16>{\n<line17>/* We read the file in blocks of BLOCKSIZE bytes.  One call of the\n<line18>computation function processes the whole buffer so that with the\n<line19>next round of the loop another block can be read.  */\n<line20>size_t n;\n<line21>sum = 0;\n<line22>/* Read block.  Take care for partial reads.  */\n<line23>while (1)\n<line24>{\n<line25>/* Either process a partial fread() from this loop,\n<line26>or the fread() in afalg_stream may have gotten EOF.\n<line27>We need to avoid a subsequent fread() as EOF may\n<line28>not be sticky.  For details of such systems, see:\n<line29>https://sourceware.org/bugzilla/show_bug.cgi?id=1190  */\n<line30>if (feof (stream))\n<line31>goto process_partial_block;\n<line32>n = fread (buffer + sum, 1, BLOCKSIZE - sum, stream);\n<line33>sum += n;\n<line34>if (sum == BLOCKSIZE)\n<line35>break;\n<line36>if (n == 0)\n<line37>{\n<line38>/* Check for the error flag IFF N == 0, so that we don't\n<line39>exit the loop after a partial read due to e.g., EAGAIN\n<line40>or EWOULDBLOCK.  */\n<line41>if (ferror (stream))\n<line42>{\n<line43>free (buffer);\n<line44>return 1;\n<line45>}\n<line46>goto process_partial_block;\n<line47>}\n<line48>}\n<line49>/* Process buffer with BLOCKSIZE bytes.  Note that\n<line50>BLOCKSIZE % 64 == 0\n<line51>*/\n<line52>md5_process_block (buffer, BLOCKSIZE, &ctx);\n<line53>}\n<line54>process_partial_block:\n<line55>/* Process any remaining bytes.  */\n<line56>if (sum > 0)\n<line57>md5_process_bytes (buffer, sum, &ctx);\n<line58>/* Construct result in desired memory.  */\n<line59>md5_finish_ctx (&ctx, resblock);\n<line60>free (buffer);\n<line61>return 0;\n<line62>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/md5.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
Function: md5_init_ctx
Content: <line0>void\n<line1>md5_init_ctx (struct md5_ctx *ctx)\n<line2>{\n<line3>ctx->A = 0x67452301;\n<line4>ctx->B = 0xefcdab89;\n<line5>ctx->C = 0x98badcfe;\n<line6>ctx->D = 0x10325476;\n<line7>ctx->total[0] = ctx->total[1] = 0;\n<line8>ctx->buflen = 0;\n<line9>}
----------------------------------------
Function: set_uint32
Content: <line0>static void\n<line1>set_uint32 (char *cp, uint32_t v)\n<line2>{\n<line3>memcpy (cp, &v, sizeof v);\n<line4>}
----------------------------------------
Function: md5_read_ctx
Content: <line0>void *\n<line1>md5_read_ctx (const struct md5_ctx *ctx, void *resbuf)\n<line2>{\n<line3>char *r = resbuf;\n<line4>set_uint32 (r + 0 * sizeof ctx->A, SWAP (ctx->A));\n<line5>set_uint32 (r + 1 * sizeof ctx->B, SWAP (ctx->B));\n<line6>set_uint32 (r + 2 * sizeof ctx->C, SWAP (ctx->C));\n<line7>set_uint32 (r + 3 * sizeof ctx->D, SWAP (ctx->D));\n<line8>return resbuf;\n<line9>}
----------------------------------------
Function: md5_finish_ctx
Content: <line0>void *\n<line1>md5_finish_ctx (struct md5_ctx *ctx, void *resbuf)\n<line2>{\n<line3>/* Take yet unprocessed bytes into account.  */\n<line4>uint32_t bytes = ctx->buflen;\n<line5>size_t size = (bytes < 56) ? 64 / 4 : 64 * 2 / 4;\n<line6>/* Now count remaining bytes.  */\n<line7>ctx->total[0] += bytes;\n<line8>if (ctx->total[0] < bytes)\n<line9>++ctx->total[1];\n<line10>/* Put the 64-bit file length in *bits* at the end of the buffer.  */\n<line11>ctx->buffer[size - 2] = SWAP (ctx->total[0] << 3);\n<line12>ctx->buffer[size - 1] = SWAP ((ctx->total[1] << 3) | (ctx->total[0] >> 29));\n<line13>memcpy (&((char *) ctx->buffer)[bytes], fillbuf, (size - 2) * 4 - bytes);\n<line14>/* Process last bytes.  */\n<line15>md5_process_block (ctx->buffer, size * 4, ctx);\n<line16>return md5_read_ctx (ctx, resbuf);\n<line17>}
----------------------------------------
Function: md5_buffer
Content: <line0>void *\n<line1>md5_buffer (const char *buffer, size_t len, void *resblock)\n<line2>{\n<line3>struct md5_ctx ctx;\n<line4>/* Initialize the computation context.  */\n<line5>md5_init_ctx (&ctx);\n<line6>/* Process whole buffer but last len % 64 bytes.  */\n<line7>md5_process_bytes (buffer, len, &ctx);\n<line8>/* Put result in desired memory area.  */\n<line9>return md5_finish_ctx (&ctx, resblock);\n<line10>}
----------------------------------------
Function: md5_process_bytes
Content: <line0>void\n<line1>md5_process_bytes (const void *buffer, size_t len, struct md5_ctx *ctx)\n<line2>{\n<line3>/* When we already have some bits in our internal buffer concatenate\n<line4>both inputs first.  */\n<line5>if (ctx->buflen != 0)\n<line6>{\n<line7>size_t left_over = ctx->buflen;\n<line8>size_t add = 128 - left_over > len ? len : 128 - left_over;\n<line9>memcpy (&((char *) ctx->buffer)[left_over], buffer, add);\n<line10>ctx->buflen += add;\n<line11>if (ctx->buflen > 64)\n<line12>{\n<line13>md5_process_block (ctx->buffer, ctx->buflen & ~63, ctx);\n<line14>ctx->buflen &= 63;\n<line15>/* The regions in the following copy operation cannot overlap,\n<line16>because ctx->buflen < 64  (left_over + add) & ~63.  */\n<line17>memcpy (ctx->buffer,\n<line18>&((char *) ctx->buffer)[(left_over + add) & ~63],\n<line19>ctx->buflen);\n<line20>}\n<line21>buffer = (const char *) buffer + add;\n<line22>len -= add;\n<line23>}\n<line24>/* Process available complete blocks.  */\n<line25>if (len >= 64)\n<line26>{\n<line27>#if !(_STRING_ARCH_unaligned || _STRING_INLINE_unaligned)\n<line28># define UNALIGNED_P(p) ((uintptr_t) (p) % alignof (uint32_t) != 0)\n<line29>if (UNALIGNED_P (buffer))\n<line30>while (len > 64)\n<line31>{\n<line32>md5_process_block (memcpy (ctx->buffer, buffer, 64), 64, ctx);\n<line33>buffer = (const char *) buffer + 64;\n<line34>len -= 64;\n<line35>}\n<line36>else\n<line37>#endif\n<line38>{\n<line39>md5_process_block (buffer, len & ~63, ctx);\n<line40>buffer = (const char *) buffer + (len & ~63);\n<line41>len &= 63;\n<line42>}\n<line43>}\n<line44>/* Move remaining bytes in internal buffer.  */\n<line45>if (len > 0)\n<line46>{\n<line47>size_t left_over = ctx->buflen;\n<line48>memcpy (&((char *) ctx->buffer)[left_over], buffer, len);\n<line49>left_over += len;\n<line50>if (left_over >= 64)\n<line51>{\n<line52>md5_process_block (ctx->buffer, 64, ctx);\n<line53>left_over -= 64;\n<line54>/* The regions in the following copy operation cannot overlap,\n<line55>because left_over  64.  */\n<line56>memcpy (ctx->buffer, &ctx->buffer[16], left_over);\n<line57>}\n<line58>ctx->buflen = left_over;\n<line59>}\n<line60>}
----------------------------------------
Function: md5_process_block
Content: <line0>void\n<line1>md5_process_block (const void *buffer, size_t len, struct md5_ctx *ctx)\n<line2>{\n<line3>uint32_t correct_words[16];\n<line4>const uint32_t *words = buffer;\n<line5>size_t nwords = len / sizeof (uint32_t);\n<line6>const uint32_t *endp = words + nwords;\n<line7>uint32_t A = ctx->A;\n<line8>uint32_t B = ctx->B;\n<line9>uint32_t C = ctx->C;\n<line10>uint32_t D = ctx->D;\n<line11>uint32_t lolen = len;\n<line12>/* First increment the byte count.  RFC 1321 specifies the possible\n<line13>length of the file up to 2^64 bits.  Here we only compute the\n<line14>number of bytes.  Do a double word increment.  */\n<line15>ctx->total[0] += lolen;\n<line16>ctx->total[1] += (len >> 31 >> 1) + (ctx->total[0] < lolen);\n<line17>/* Process all bytes in the buffer with 64 bytes in each round of\n<line18>the loop.  */\n<line19>while (words < endp)\n<line20>{\n<line21>uint32_t *cwp = correct_words;\n<line22>uint32_t A_save = A;\n<line23>uint32_t B_save = B;\n<line24>uint32_t C_save = C;\n<line25>uint32_t D_save = D;\n<line26>/* First round: using the given function, the context and a constant\n<line27>the next context is computed.  Because the algorithms processing\n<line28>unit is a 32-bit word and it is determined to work on words in\n<line29>little endian byte order we perhaps have to change the byte order\n<line30>before the computation.  To reduce the work for the next steps\n<line31>we store the swapped words in the array CORRECT_WORDS.  */\n<line32>#define OP(a, b, c, d, s, T)                                            \\n<line33>do                                                                \\n<line34>{                                                               \\n<line35>a += FF (b, c, d) + (*cwp++ = SWAP (*words)) + T;             \\n<line36>++words;                                                      \\n<line37>CYCLIC (a, s);                                                \\n<line38>a += b;                                                       \\n<line39>}                                                               \\n<line40>while (0)\n<line41>/* It is unfortunate that C does not provide an operator for\n<line42>cyclic rotation.  Hope the C compiler is smart enough.  */\n<line43>#define CYCLIC(w, s) (w = (w << s) | (w >> (32 - s)))\n<line44>/* Before we start, one word to the strange constants.\n<line45>They are defined in RFC 1321 as\n<line46>T[i] = (int) (4294967296.0 * fabs (sin (i))), i=1..64\n<line47>Here is an equivalent invocation using Perl:\n<line48>perl -e 'foreach(1..64){printf "0x%08x\n", int (4294967296 * abs (sin $_))}'\n<line49>*/\n<line50>/* Round 1.  */\n<line51>OP (A, B, C, D, 7, 0xd76aa478);\n<line52>OP (D, A, B, C, 12, 0xe8c7b756);\n<line53>OP (C, D, A, B, 17, 0x242070db);\n<line54>OP (B, C, D, A, 22, 0xc1bdceee);\n<line55>OP (A, B, C, D, 7, 0xf57c0faf);\n<line56>OP (D, A, B, C, 12, 0x4787c62a);\n<line57>OP (C, D, A, B, 17, 0xa8304613);\n<line58>OP (B, C, D, A, 22, 0xfd469501);\n<line59>OP (A, B, C, D, 7, 0x698098d8);\n<line60>OP (D, A, B, C, 12, 0x8b44f7af);\n<line61>OP (C, D, A, B, 17, 0xffff5bb1);\n<line62>OP (B, C, D, A, 22, 0x895cd7be);\n<line63>OP (A, B, C, D, 7, 0x6b901122);\n<line64>OP (D, A, B, C, 12, 0xfd987193);\n<line65>OP (C, D, A, B, 17, 0xa679438e);\n<line66>OP (B, C, D, A, 22, 0x49b40821);\n<line67>/* For the second to fourth round we have the possibly swapped words\n<line68>in CORRECT_WORDS.  Redefine the macro to take an additional first\n<line69>argument specifying the function to use.  */\n<line70>#undef OP\n<line71>#define OP(f, a, b, c, d, k, s, T)                                      \\n<line72>do                                                                \\n<line73>{                                                               \\n<line74>a += f (b, c, d) + correct_words[k] + T;                      \\n<line75>CYCLIC (a, s);                                                \\n<line76>a += b;                                                       \\n<line77>}                                                               \\n<line78>while (0)\n<line79>/* Round 2.  */\n<line80>OP (FG, A, B, C, D, 1, 5, 0xf61e2562);\n<line81>OP (FG, D, A, B, C, 6, 9, 0xc040b340);\n<line82>OP (FG, C, D, A, B, 11, 14, 0x265e5a51);\n<line83>OP (FG, B, C, D, A, 0, 20, 0xe9b6c7aa);\n<line84>OP (FG, A, B, C, D, 5, 5, 0xd62f105d);\n<line85>OP (FG, D, A, B, C, 10, 9, 0x02441453);\n<line86>OP (FG, C, D, A, B, 15, 14, 0xd8a1e681);\n<line87>OP (FG, B, C, D, A, 4, 20, 0xe7d3fbc8);\n<line88>OP (FG, A, B, C, D, 9, 5, 0x21e1cde6);\n<line89>OP (FG, D, A, B, C, 14, 9, 0xc33707d6);\n<line90>OP (FG, C, D, A, B, 3, 14, 0xf4d50d87);\n<line91>OP (FG, B, C, D, A, 8, 20, 0x455a14ed);\n<line92>OP (FG, A, B, C, D, 13, 5, 0xa9e3e905);\n<line93>OP (FG, D, A, B, C, 2, 9, 0xfcefa3f8);\n<line94>OP (FG, C, D, A, B, 7, 14, 0x676f02d9);\n<line95>OP (FG, B, C, D, A, 12, 20, 0x8d2a4c8a);\n<line96>/* Round 3.  */\n<line97>OP (FH, A, B, C, D, 5, 4, 0xfffa3942);\n<line98>OP (FH, D, A, B, C, 8, 11, 0x8771f681);\n<line99>OP (FH, C, D, A, B, 11, 16, 0x6d9d6122);\n<line100>OP (FH, B, C, D, A, 14, 23, 0xfde5380c);\n<line101>OP (FH, A, B, C, D, 1, 4, 0xa4beea44);\n<line102>OP (FH, D, A, B, C, 4, 11, 0x4bdecfa9);\n<line103>OP (FH, C, D, A, B, 7, 16, 0xf6bb4b60);\n<line104>OP (FH, B, C, D, A, 10, 23, 0xbebfbc70);\n<line105>OP (FH, A, B, C, D, 13, 4, 0x289b7ec6);\n<line106>OP (FH, D, A, B, C, 0, 11, 0xeaa127fa);\n<line107>OP (FH, C, D, A, B, 3, 16, 0xd4ef3085);\n<line108>OP (FH, B, C, D, A, 6, 23, 0x04881d05);\n<line109>OP (FH, A, B, C, D, 9, 4, 0xd9d4d039);\n<line110>OP (FH, D, A, B, C, 12, 11, 0xe6db99e5);\n<line111>OP (FH, C, D, A, B, 15, 16, 0x1fa27cf8);\n<line112>OP (FH, B, C, D, A, 2, 23, 0xc4ac5665);\n<line113>/* Round 4.  */\n<line114>OP (FI, A, B, C, D, 0, 6, 0xf4292244);\n<line115>OP (FI, D, A, B, C, 7, 10, 0x432aff97);\n<line116>OP (FI, C, D, A, B, 14, 15, 0xab9423a7);\n<line117>OP (FI, B, C, D, A, 5, 21, 0xfc93a039);\n<line118>OP (FI, A, B, C, D, 12, 6, 0x655b59c3);\n<line119>OP (FI, D, A, B, C, 3, 10, 0x8f0ccc92);\n<line120>OP (FI, C, D, A, B, 10, 15, 0xffeff47d);\n<line121>OP (FI, B, C, D, A, 1, 21, 0x85845dd1);\n<line122>OP (FI, A, B, C, D, 8, 6, 0x6fa87e4f);\n<line123>OP (FI, D, A, B, C, 15, 10, 0xfe2ce6e0);\n<line124>OP (FI, C, D, A, B, 6, 15, 0xa3014314);\n<line125>OP (FI, B, C, D, A, 13, 21, 0x4e0811a1);\n<line126>OP (FI, A, B, C, D, 4, 6, 0xf7537e82);\n<line127>OP (FI, D, A, B, C, 11, 10, 0xbd3af235);\n<line128>OP (FI, C, D, A, B, 2, 15, 0x2ad7d2bb);\n<line129>OP (FI, B, C, D, A, 9, 21, 0xeb86d391);\n<line130>/* Add the starting values of the context.  */\n<line131>A += A_save;\n<line132>B += B_save;\n<line133>C += C_save;\n<line134>D += D_save;\n<line135>}\n<line136>/* Put checksum in context given as argument.  */\n<line137>ctx->A = A;\n<line138>ctx->B = B;\n<line139>ctx->C = C;\n<line140>ctx->D = D;\n<line141>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/sha1-stream.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
Function: sha1_stream
Content: <line0>int\n<line1>sha1_stream (FILE *stream, void *resblock)\n<line2>{\n<line3>switch (afalg_stream (stream, "sha1", resblock, SHA1_DIGEST_SIZE))\n<line4>{\n<line5>case 0: return 0;\n<line6>case -EIO: return 1;\n<line7>}\n<line8>char *buffer = malloc (BLOCKSIZE + 72);\n<line9>if (!buffer)\n<line10>return 1;\n<line11>struct sha1_ctx ctx;\n<line12>sha1_init_ctx (&ctx);\n<line13>size_t sum;\n<line14>/* Iterate over full file contents.  */\n<line15>while (1)\n<line16>{\n<line17>/* We read the file in blocks of BLOCKSIZE bytes.  One call of the\n<line18>computation function processes the whole buffer so that with the\n<line19>next round of the loop another block can be read.  */\n<line20>size_t n;\n<line21>sum = 0;\n<line22>/* Read block.  Take care for partial reads.  */\n<line23>while (1)\n<line24>{\n<line25>/* Either process a partial fread() from this loop,\n<line26>or the fread() in afalg_stream may have gotten EOF.\n<line27>We need to avoid a subsequent fread() as EOF may\n<line28>not be sticky.  For details of such systems, see:\n<line29>https://sourceware.org/bugzilla/show_bug.cgi?id=1190  */\n<line30>if (feof (stream))\n<line31>goto process_partial_block;\n<line32>n = fread (buffer + sum, 1, BLOCKSIZE - sum, stream);\n<line33>sum += n;\n<line34>if (sum == BLOCKSIZE)\n<line35>break;\n<line36>if (n == 0)\n<line37>{\n<line38>/* Check for the error flag IFF N == 0, so that we don't\n<line39>exit the loop after a partial read due to e.g., EAGAIN\n<line40>or EWOULDBLOCK.  */\n<line41>if (ferror (stream))\n<line42>{\n<line43>free (buffer);\n<line44>return 1;\n<line45>}\n<line46>goto process_partial_block;\n<line47>}\n<line48>}\n<line49>/* Process buffer with BLOCKSIZE bytes.  Note that\n<line50>BLOCKSIZE % 64 == 0\n<line51>*/\n<line52>sha1_process_block (buffer, BLOCKSIZE, &ctx);\n<line53>}\n<line54>process_partial_block:;\n<line55>/* Process any remaining bytes.  */\n<line56>if (sum > 0)\n<line57>sha1_process_bytes (buffer, sum, &ctx);\n<line58>/* Construct result in desired memory.  */\n<line59>sha1_finish_ctx (&ctx, resblock);\n<line60>free (buffer);\n<line61>return 0;\n<line62>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/sha1.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
Function: sha1_init_ctx
Content: <line0>void\n<line1>sha1_init_ctx (struct sha1_ctx *ctx)\n<line2>{\n<line3>ctx->A = 0x67452301;\n<line4>ctx->B = 0xefcdab89;\n<line5>ctx->C = 0x98badcfe;\n<line6>ctx->D = 0x10325476;\n<line7>ctx->E = 0xc3d2e1f0;\n<line8>ctx->total[0] = ctx->total[1] = 0;\n<line9>ctx->buflen = 0;\n<line10>}
----------------------------------------
Function: set_uint32
Content: <line0>static void\n<line1>set_uint32 (char *cp, uint32_t v)\n<line2>{\n<line3>memcpy (cp, &v, sizeof v);\n<line4>}
----------------------------------------
Function: sha1_read_ctx
Content: <line0>void *\n<line1>sha1_read_ctx (const struct sha1_ctx *ctx, void *resbuf)\n<line2>{\n<line3>char *r = resbuf;\n<line4>set_uint32 (r + 0 * sizeof ctx->A, SWAP (ctx->A));\n<line5>set_uint32 (r + 1 * sizeof ctx->B, SWAP (ctx->B));\n<line6>set_uint32 (r + 2 * sizeof ctx->C, SWAP (ctx->C));\n<line7>set_uint32 (r + 3 * sizeof ctx->D, SWAP (ctx->D));\n<line8>set_uint32 (r + 4 * sizeof ctx->E, SWAP (ctx->E));\n<line9>return resbuf;\n<line10>}
----------------------------------------
Function: sha1_finish_ctx
Content: <line0>void *\n<line1>sha1_finish_ctx (struct sha1_ctx *ctx, void *resbuf)\n<line2>{\n<line3>/* Take yet unprocessed bytes into account.  */\n<line4>uint32_t bytes = ctx->buflen;\n<line5>size_t size = (bytes < 56) ? 64 / 4 : 64 * 2 / 4;\n<line6>/* Now count remaining bytes.  */\n<line7>ctx->total[0] += bytes;\n<line8>if (ctx->total[0] < bytes)\n<line9>++ctx->total[1];\n<line10>/* Put the 64-bit file length in *bits* at the end of the buffer.  */\n<line11>ctx->buffer[size - 2] = SWAP ((ctx->total[1] << 3) | (ctx->total[0] >> 29));\n<line12>ctx->buffer[size - 1] = SWAP (ctx->total[0] << 3);\n<line13>memcpy (&((char *) ctx->buffer)[bytes], fillbuf, (size - 2) * 4 - bytes);\n<line14>/* Process last bytes.  */\n<line15>sha1_process_block (ctx->buffer, size * 4, ctx);\n<line16>return sha1_read_ctx (ctx, resbuf);\n<line17>}
----------------------------------------
Function: sha1_buffer
Content: <line0>void *\n<line1>sha1_buffer (const char *buffer, size_t len, void *resblock)\n<line2>{\n<line3>struct sha1_ctx ctx;\n<line4>/* Initialize the computation context.  */\n<line5>sha1_init_ctx (&ctx);\n<line6>/* Process whole buffer but last len % 64 bytes.  */\n<line7>sha1_process_bytes (buffer, len, &ctx);\n<line8>/* Put result in desired memory area.  */\n<line9>return sha1_finish_ctx (&ctx, resblock);\n<line10>}
----------------------------------------
Function: sha1_process_bytes
Content: <line0>void\n<line1>sha1_process_bytes (const void *buffer, size_t len, struct sha1_ctx *ctx)\n<line2>{\n<line3>/* When we already have some bits in our internal buffer concatenate\n<line4>both inputs first.  */\n<line5>if (ctx->buflen != 0)\n<line6>{\n<line7>size_t left_over = ctx->buflen;\n<line8>size_t add = 128 - left_over > len ? len : 128 - left_over;\n<line9>memcpy (&((char *) ctx->buffer)[left_over], buffer, add);\n<line10>ctx->buflen += add;\n<line11>if (ctx->buflen > 64)\n<line12>{\n<line13>sha1_process_block (ctx->buffer, ctx->buflen & ~63, ctx);\n<line14>ctx->buflen &= 63;\n<line15>/* The regions in the following copy operation cannot overlap,\n<line16>because ctx->buflen < 64  (left_over + add) & ~63.  */\n<line17>memcpy (ctx->buffer,\n<line18>&((char *) ctx->buffer)[(left_over + add) & ~63],\n<line19>ctx->buflen);\n<line20>}\n<line21>buffer = (const char *) buffer + add;\n<line22>len -= add;\n<line23>}\n<line24>/* Process available complete blocks.  */\n<line25>if (len >= 64)\n<line26>{\n<line27>#if !(_STRING_ARCH_unaligned || _STRING_INLINE_unaligned)\n<line28># define UNALIGNED_P(p) ((uintptr_t) (p) % alignof (uint32_t) != 0)\n<line29>if (UNALIGNED_P (buffer))\n<line30>while (len > 64)\n<line31>{\n<line32>sha1_process_block (memcpy (ctx->buffer, buffer, 64), 64, ctx);\n<line33>buffer = (const char *) buffer + 64;\n<line34>len -= 64;\n<line35>}\n<line36>else\n<line37>#endif\n<line38>{\n<line39>sha1_process_block (buffer, len & ~63, ctx);\n<line40>buffer = (const char *) buffer + (len & ~63);\n<line41>len &= 63;\n<line42>}\n<line43>}\n<line44>/* Move remaining bytes in internal buffer.  */\n<line45>if (len > 0)\n<line46>{\n<line47>size_t left_over = ctx->buflen;\n<line48>memcpy (&((char *) ctx->buffer)[left_over], buffer, len);\n<line49>left_over += len;\n<line50>if (left_over >= 64)\n<line51>{\n<line52>sha1_process_block (ctx->buffer, 64, ctx);\n<line53>left_over -= 64;\n<line54>/* The regions in the following copy operation cannot overlap,\n<line55>because left_over  64.  */\n<line56>memcpy (ctx->buffer, &ctx->buffer[16], left_over);\n<line57>}\n<line58>ctx->buflen = left_over;\n<line59>}\n<line60>}
----------------------------------------
Function: sha1_process_block
Content: <line0>void\n<line1>sha1_process_block (const void *buffer, size_t len, struct sha1_ctx *ctx)\n<line2>{\n<line3>const uint32_t *words = buffer;\n<line4>size_t nwords = len / sizeof (uint32_t);\n<line5>const uint32_t *endp = words + nwords;\n<line6>uint32_t x[16];\n<line7>uint32_t a = ctx->A;\n<line8>uint32_t b = ctx->B;\n<line9>uint32_t c = ctx->C;\n<line10>uint32_t d = ctx->D;\n<line11>uint32_t e = ctx->E;\n<line12>uint32_t lolen = len;\n<line13>/* First increment the byte count.  RFC 1321 specifies the possible\n<line14>length of the file up to 2^64 bits.  Here we only compute the\n<line15>number of bytes.  Do a double word increment.  */\n<line16>ctx->total[0] += lolen;\n<line17>ctx->total[1] += (len >> 31 >> 1) + (ctx->total[0] < lolen);\n<line18>#define rol(x, n) (((x) << (n)) | ((uint32_t) (x) >> (32 - (n))))\n<line19>#define M(I) ( tm =   x[I&0x0f] ^ x[(I-14)&0x0f] \\n<line20>^ x[(I-8)&0x0f] ^ x[(I-3)&0x0f] \\n<line21>, (x[I&0x0f] = rol(tm, 1)) )\n<line22>#define R(A,B,C,D,E,F,K,M)  do { E += rol( A, 5 )     \\n<line23>+ F( B, C, D )  \\n<line24>+ K             \\n<line25>+ M;            \\n<line26>B = rol( B, 30 );    \\n<line27>} while(0)\n<line28>while (words < endp)\n<line29>{\n<line30>uint32_t tm;\n<line31>int t;\n<line32>for (t = 0; t < 16; t++)\n<line33>{\n<line34>x[t] = SWAP (*words);\n<line35>words++;\n<line36>}\n<line37>R( a, b, c, d, e, F1, K1, x[ 0] );\n<line38>R( e, a, b, c, d, F1, K1, x[ 1] );\n<line39>R( d, e, a, b, c, F1, K1, x[ 2] );\n<line40>R( c, d, e, a, b, F1, K1, x[ 3] );\n<line41>R( b, c, d, e, a, F1, K1, x[ 4] );\n<line42>R( a, b, c, d, e, F1, K1, x[ 5] );\n<line43>R( e, a, b, c, d, F1, K1, x[ 6] );\n<line44>R( d, e, a, b, c, F1, K1, x[ 7] );\n<line45>R( c, d, e, a, b, F1, K1, x[ 8] );\n<line46>R( b, c, d, e, a, F1, K1, x[ 9] );\n<line47>R( a, b, c, d, e, F1, K1, x[10] );\n<line48>R( e, a, b, c, d, F1, K1, x[11] );\n<line49>R( d, e, a, b, c, F1, K1, x[12] );\n<line50>R( c, d, e, a, b, F1, K1, x[13] );\n<line51>R( b, c, d, e, a, F1, K1, x[14] );\n<line52>R( a, b, c, d, e, F1, K1, x[15] );\n<line53>R( e, a, b, c, d, F1, K1, M(16) );\n<line54>R( d, e, a, b, c, F1, K1, M(17) );\n<line55>R( c, d, e, a, b, F1, K1, M(18) );\n<line56>R( b, c, d, e, a, F1, K1, M(19) );\n<line57>R( a, b, c, d, e, F2, K2, M(20) );\n<line58>R( e, a, b, c, d, F2, K2, M(21) );\n<line59>R( d, e, a, b, c, F2, K2, M(22) );\n<line60>R( c, d, e, a, b, F2, K2, M(23) );\n<line61>R( b, c, d, e, a, F2, K2, M(24) );\n<line62>R( a, b, c, d, e, F2, K2, M(25) );\n<line63>R( e, a, b, c, d, F2, K2, M(26) );\n<line64>R( d, e, a, b, c, F2, K2, M(27) );\n<line65>R( c, d, e, a, b, F2, K2, M(28) );\n<line66>R( b, c, d, e, a, F2, K2, M(29) );\n<line67>R( a, b, c, d, e, F2, K2, M(30) );\n<line68>R( e, a, b, c, d, F2, K2, M(31) );\n<line69>R( d, e, a, b, c, F2, K2, M(32) );\n<line70>R( c, d, e, a, b, F2, K2, M(33) );\n<line71>R( b, c, d, e, a, F2, K2, M(34) );\n<line72>R( a, b, c, d, e, F2, K2, M(35) );\n<line73>R( e, a, b, c, d, F2, K2, M(36) );\n<line74>R( d, e, a, b, c, F2, K2, M(37) );\n<line75>R( c, d, e, a, b, F2, K2, M(38) );\n<line76>R( b, c, d, e, a, F2, K2, M(39) );\n<line77>R( a, b, c, d, e, F3, K3, M(40) );\n<line78>R( e, a, b, c, d, F3, K3, M(41) );\n<line79>R( d, e, a, b, c, F3, K3, M(42) );\n<line80>R( c, d, e, a, b, F3, K3, M(43) );\n<line81>R( b, c, d, e, a, F3, K3, M(44) );\n<line82>R( a, b, c, d, e, F3, K3, M(45) );\n<line83>R( e, a, b, c, d, F3, K3, M(46) );\n<line84>R( d, e, a, b, c, F3, K3, M(47) );\n<line85>R( c, d, e, a, b, F3, K3, M(48) );\n<line86>R( b, c, d, e, a, F3, K3, M(49) );\n<line87>R( a, b, c, d, e, F3, K3, M(50) );\n<line88>R( e, a, b, c, d, F3, K3, M(51) );\n<line89>R( d, e, a, b, c, F3, K3, M(52) );\n<line90>R( c, d, e, a, b, F3, K3, M(53) );\n<line91>R( b, c, d, e, a, F3, K3, M(54) );\n<line92>R( a, b, c, d, e, F3, K3, M(55) );\n<line93>R( e, a, b, c, d, F3, K3, M(56) );\n<line94>R( d, e, a, b, c, F3, K3, M(57) );\n<line95>R( c, d, e, a, b, F3, K3, M(58) );\n<line96>R( b, c, d, e, a, F3, K3, M(59) );\n<line97>R( a, b, c, d, e, F4, K4, M(60) );\n<line98>R( e, a, b, c, d, F4, K4, M(61) );\n<line99>R( d, e, a, b, c, F4, K4, M(62) );\n<line100>R( c, d, e, a, b, F4, K4, M(63) );\n<line101>R( b, c, d, e, a, F4, K4, M(64) );\n<line102>R( a, b, c, d, e, F4, K4, M(65) );\n<line103>R( e, a, b, c, d, F4, K4, M(66) );\n<line104>R( d, e, a, b, c, F4, K4, M(67) );\n<line105>R( c, d, e, a, b, F4, K4, M(68) );\n<line106>R( b, c, d, e, a, F4, K4, M(69) );\n<line107>R( a, b, c, d, e, F4, K4, M(70) );\n<line108>R( e, a, b, c, d, F4, K4, M(71) );\n<line109>R( d, e, a, b, c, F4, K4, M(72) );\n<line110>R( c, d, e, a, b, F4, K4, M(73) );\n<line111>R( b, c, d, e, a, F4, K4, M(74) );\n<line112>R( a, b, c, d, e, F4, K4, M(75) );\n<line113>R( e, a, b, c, d, F4, K4, M(76) );\n<line114>R( d, e, a, b, c, F4, K4, M(77) );\n<line115>R( c, d, e, a, b, F4, K4, M(78) );\n<line116>R( b, c, d, e, a, F4, K4, M(79) );\n<line117>a = ctx->A += a;\n<line118>b = ctx->B += b;\n<line119>c = ctx->C += c;\n<line120>d = ctx->D += d;\n<line121>e = ctx->E += e;\n<line122>}\n<line123>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/sha256-stream.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
Function: shaxxx_stream
Content: <line0>static int\n<line1>shaxxx_stream (FILE *stream, char const *alg, void *resblock,\n<line2>ssize_t hashlen, void (*init_ctx) (struct sha256_ctx *),\n<line3>void *(*finish_ctx) (struct sha256_ctx *, void *))\n<line4>{\n<line5>switch (afalg_stream (stream, alg, resblock, hashlen))\n<line6>{\n<line7>case 0: return 0;\n<line8>case -EIO: return 1;\n<line9>}\n<line10>char *buffer = malloc (BLOCKSIZE + 72);\n<line11>if (!buffer)\n<line12>return 1;\n<line13>struct sha256_ctx ctx;\n<line14>init_ctx (&ctx);\n<line15>size_t sum;\n<line16>/* Iterate over full file contents.  */\n<line17>while (1)\n<line18>{\n<line19>/* We read the file in blocks of BLOCKSIZE bytes.  One call of the\n<line20>computation function processes the whole buffer so that with the\n<line21>next round of the loop another block can be read.  */\n<line22>size_t n;\n<line23>sum = 0;\n<line24>/* Read block.  Take care for partial reads.  */\n<line25>while (1)\n<line26>{\n<line27>/* Either process a partial fread() from this loop,\n<line28>or the fread() in afalg_stream may have gotten EOF.\n<line29>We need to avoid a subsequent fread() as EOF may\n<line30>not be sticky.  For details of such systems, see:\n<line31>https://sourceware.org/bugzilla/show_bug.cgi?id=1190  */\n<line32>if (feof (stream))\n<line33>goto process_partial_block;\n<line34>n = fread (buffer + sum, 1, BLOCKSIZE - sum, stream);\n<line35>sum += n;\n<line36>if (sum == BLOCKSIZE)\n<line37>break;\n<line38>if (n == 0)\n<line39>{\n<line40>/* Check for the error flag IFF N == 0, so that we don't\n<line41>exit the loop after a partial read due to e.g., EAGAIN\n<line42>or EWOULDBLOCK.  */\n<line43>if (ferror (stream))\n<line44>{\n<line45>free (buffer);\n<line46>return 1;\n<line47>}\n<line48>goto process_partial_block;\n<line49>}\n<line50>}\n<line51>/* Process buffer with BLOCKSIZE bytes.  Note that\n<line52>BLOCKSIZE % 64 == 0\n<line53>*/\n<line54>sha256_process_block (buffer, BLOCKSIZE, &ctx);\n<line55>}\n<line56>process_partial_block:;\n<line57>/* Process any remaining bytes.  */\n<line58>if (sum > 0)\n<line59>sha256_process_bytes (buffer, sum, &ctx);\n<line60>/* Construct result in desired memory.  */\n<line61>finish_ctx (&ctx, resblock);\n<line62>free (buffer);\n<line63>return 0;\n<line64>}
----------------------------------------
Function: sha256_stream
Content: <line0>int\n<line1>sha256_stream (FILE *stream, void *resblock)\n<line2>{\n<line3>return shaxxx_stream (stream, "sha256", resblock, SHA256_DIGEST_SIZE,\n<line4>sha256_init_ctx, sha256_finish_ctx);\n<line5>}
----------------------------------------
Function: sha224_stream
Content: <line0>int\n<line1>sha224_stream (FILE *stream, void *resblock)\n<line2>{\n<line3>return shaxxx_stream (stream, "sha224", resblock, SHA224_DIGEST_SIZE,\n<line4>sha224_init_ctx, sha224_finish_ctx);\n<line5>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/sha256.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
Function: sha256_init_ctx
Content: <line0>void\n<line1>sha256_init_ctx (struct sha256_ctx *ctx)\n<line2>{\n<line3>ctx->state[0] = 0x6a09e667UL;\n<line4>ctx->state[1] = 0xbb67ae85UL;\n<line5>ctx->state[2] = 0x3c6ef372UL;\n<line6>ctx->state[3] = 0xa54ff53aUL;\n<line7>ctx->state[4] = 0x510e527fUL;\n<line8>ctx->state[5] = 0x9b05688cUL;\n<line9>ctx->state[6] = 0x1f83d9abUL;\n<line10>ctx->state[7] = 0x5be0cd19UL;\n<line11>ctx->total[0] = ctx->total[1] = 0;\n<line12>ctx->buflen = 0;\n<line13>}
----------------------------------------
Function: sha224_init_ctx
Content: <line0>void\n<line1>sha224_init_ctx (struct sha256_ctx *ctx)\n<line2>{\n<line3>ctx->state[0] = 0xc1059ed8UL;\n<line4>ctx->state[1] = 0x367cd507UL;\n<line5>ctx->state[2] = 0x3070dd17UL;\n<line6>ctx->state[3] = 0xf70e5939UL;\n<line7>ctx->state[4] = 0xffc00b31UL;\n<line8>ctx->state[5] = 0x68581511UL;\n<line9>ctx->state[6] = 0x64f98fa7UL;\n<line10>ctx->state[7] = 0xbefa4fa4UL;\n<line11>ctx->total[0] = ctx->total[1] = 0;\n<line12>ctx->buflen = 0;\n<line13>}
----------------------------------------
Function: set_uint32
Content: <line0>static void\n<line1>set_uint32 (char *cp, uint32_t v)\n<line2>{\n<line3>memcpy (cp, &v, sizeof v);\n<line4>}
----------------------------------------
Function: sha256_read_ctx
Content: <line0>void *\n<line1>sha256_read_ctx (const struct sha256_ctx *ctx, void *resbuf)\n<line2>{\n<line3>int i;\n<line4>char *r = resbuf;\n<line5>for (i = 0; i < 8; i++)\n<line6>set_uint32 (r + i * sizeof ctx->state[0], SWAP (ctx->state[i]));\n<line7>return resbuf;\n<line8>}
----------------------------------------
Function: sha224_read_ctx
Content: <line0>void *\n<line1>sha224_read_ctx (const struct sha256_ctx *ctx, void *resbuf)\n<line2>{\n<line3>int i;\n<line4>char *r = resbuf;\n<line5>for (i = 0; i < 7; i++)\n<line6>set_uint32 (r + i * sizeof ctx->state[0], SWAP (ctx->state[i]));\n<line7>return resbuf;\n<line8>}
----------------------------------------
Function: sha256_conclude_ctx
Content: <line0>static void\n<line1>sha256_conclude_ctx (struct sha256_ctx *ctx)\n<line2>{\n<line3>/* Take yet unprocessed bytes into account.  */\n<line4>size_t bytes = ctx->buflen;\n<line5>size_t size = (bytes < 56) ? 64 / 4 : 64 * 2 / 4;\n<line6>/* Now count remaining bytes.  */\n<line7>ctx->total[0] += bytes;\n<line8>if (ctx->total[0] < bytes)\n<line9>++ctx->total[1];\n<line10>/* Put the 64-bit file length in *bits* at the end of the buffer.\n<line11>Use set_uint32 rather than a simple assignment, to avoid risk of\n<line12>unaligned access.  */\n<line13>set_uint32 ((char *) &ctx->buffer[size - 2],\n<line14>SWAP ((ctx->total[1] << 3) | (ctx->total[0] >> 29)));\n<line15>set_uint32 ((char *) &ctx->buffer[size - 1],\n<line16>SWAP (ctx->total[0] << 3));\n<line17>memcpy (&((char *) ctx->buffer)[bytes], fillbuf, (size - 2) * 4 - bytes);\n<line18>/* Process last bytes.  */\n<line19>sha256_process_block (ctx->buffer, size * 4, ctx);\n<line20>}
----------------------------------------
Function: sha256_finish_ctx
Content: <line0>void *\n<line1>sha256_finish_ctx (struct sha256_ctx *ctx, void *resbuf)\n<line2>{\n<line3>sha256_conclude_ctx (ctx);\n<line4>return sha256_read_ctx (ctx, resbuf);\n<line5>}
----------------------------------------
Function: sha224_finish_ctx
Content: <line0>void *\n<line1>sha224_finish_ctx (struct sha256_ctx *ctx, void *resbuf)\n<line2>{\n<line3>sha256_conclude_ctx (ctx);\n<line4>return sha224_read_ctx (ctx, resbuf);\n<line5>}
----------------------------------------
Function: sha256_buffer
Content: <line0>void *\n<line1>sha256_buffer (const char *buffer, size_t len, void *resblock)\n<line2>{\n<line3>struct sha256_ctx ctx;\n<line4>/* Initialize the computation context.  */\n<line5>sha256_init_ctx (&ctx);\n<line6>/* Process whole buffer but last len % 64 bytes.  */\n<line7>sha256_process_bytes (buffer, len, &ctx);\n<line8>/* Put result in desired memory area.  */\n<line9>return sha256_finish_ctx (&ctx, resblock);\n<line10>}
----------------------------------------
Function: sha224_buffer
Content: <line0>void *\n<line1>sha224_buffer (const char *buffer, size_t len, void *resblock)\n<line2>{\n<line3>struct sha256_ctx ctx;\n<line4>/* Initialize the computation context.  */\n<line5>sha224_init_ctx (&ctx);\n<line6>/* Process whole buffer but last len % 64 bytes.  */\n<line7>sha256_process_bytes (buffer, len, &ctx);\n<line8>/* Put result in desired memory area.  */\n<line9>return sha224_finish_ctx (&ctx, resblock);\n<line10>}
----------------------------------------
Function: sha256_process_bytes
Content: <line0>void\n<line1>sha256_process_bytes (const void *buffer, size_t len, struct sha256_ctx *ctx)\n<line2>{\n<line3>/* When we already have some bits in our internal buffer concatenate\n<line4>both inputs first.  */\n<line5>if (ctx->buflen != 0)\n<line6>{\n<line7>size_t left_over = ctx->buflen;\n<line8>size_t add = 128 - left_over > len ? len : 128 - left_over;\n<line9>memcpy (&((char *) ctx->buffer)[left_over], buffer, add);\n<line10>ctx->buflen += add;\n<line11>if (ctx->buflen > 64)\n<line12>{\n<line13>sha256_process_block (ctx->buffer, ctx->buflen & ~63, ctx);\n<line14>ctx->buflen &= 63;\n<line15>/* The regions in the following copy operation cannot overlap,\n<line16>because ctx->buflen < 64  (left_over + add) & ~63.  */\n<line17>memcpy (ctx->buffer,\n<line18>&((char *) ctx->buffer)[(left_over + add) & ~63],\n<line19>ctx->buflen);\n<line20>}\n<line21>buffer = (const char *) buffer + add;\n<line22>len -= add;\n<line23>}\n<line24>/* Process available complete blocks.  */\n<line25>if (len >= 64)\n<line26>{\n<line27>#if !(_STRING_ARCH_unaligned || _STRING_INLINE_unaligned)\n<line28># define UNALIGNED_P(p) ((uintptr_t) (p) % alignof (uint32_t) != 0)\n<line29>if (UNALIGNED_P (buffer))\n<line30>while (len > 64)\n<line31>{\n<line32>sha256_process_block (memcpy (ctx->buffer, buffer, 64), 64, ctx);\n<line33>buffer = (const char *) buffer + 64;\n<line34>len -= 64;\n<line35>}\n<line36>else\n<line37>#endif\n<line38>{\n<line39>sha256_process_block (buffer, len & ~63, ctx);\n<line40>buffer = (const char *) buffer + (len & ~63);\n<line41>len &= 63;\n<line42>}\n<line43>}\n<line44>/* Move remaining bytes in internal buffer.  */\n<line45>if (len > 0)\n<line46>{\n<line47>size_t left_over = ctx->buflen;\n<line48>memcpy (&((char *) ctx->buffer)[left_over], buffer, len);\n<line49>left_over += len;\n<line50>if (left_over >= 64)\n<line51>{\n<line52>sha256_process_block (ctx->buffer, 64, ctx);\n<line53>left_over -= 64;\n<line54>/* The regions in the following copy operation cannot overlap,\n<line55>because left_over  64.  */\n<line56>memcpy (ctx->buffer, &ctx->buffer[16], left_over);\n<line57>}\n<line58>ctx->buflen = left_over;\n<line59>}\n<line60>}
----------------------------------------
Function: sha256_process_block
Content: <line0>void\n<line1>sha256_process_block (const void *buffer, size_t len, struct sha256_ctx *ctx)\n<line2>{\n<line3>const uint32_t *words = buffer;\n<line4>size_t nwords = len / sizeof (uint32_t);\n<line5>const uint32_t *endp = words + nwords;\n<line6>uint32_t x[16];\n<line7>uint32_t a = ctx->state[0];\n<line8>uint32_t b = ctx->state[1];\n<line9>uint32_t c = ctx->state[2];\n<line10>uint32_t d = ctx->state[3];\n<line11>uint32_t e = ctx->state[4];\n<line12>uint32_t f = ctx->state[5];\n<line13>uint32_t g = ctx->state[6];\n<line14>uint32_t h = ctx->state[7];\n<line15>uint32_t lolen = len;\n<line16>/* First increment the byte count.  FIPS PUB 180-2 specifies the possible\n<line17>length of the file up to 2^64 bits.  Here we only compute the\n<line18>number of bytes.  Do a double word increment.  */\n<line19>ctx->total[0] += lolen;\n<line20>ctx->total[1] += (len >> 31 >> 1) + (ctx->total[0] < lolen);\n<line21>#define rol(x, n) (((x) << (n)) | ((x) >> (32 - (n))))\n<line22>#define S0(x) (rol(x,25)^rol(x,14)^(x>>3))\n<line23>#define S1(x) (rol(x,15)^rol(x,13)^(x>>10))\n<line24>#define SS0(x) (rol(x,30)^rol(x,19)^rol(x,10))\n<line25>#define SS1(x) (rol(x,26)^rol(x,21)^rol(x,7))\n<line26>#define M(I) ( tm =   S1(x[(I-2)&0x0f]) + x[(I-7)&0x0f] \\n<line27>+ S0(x[(I-15)&0x0f]) + x[I&0x0f]    \\n<line28>, x[I&0x0f] = tm )\n<line29>#define R(A,B,C,D,E,F,G,H,K,M)  do { t0 = SS0(A) + F2(A,B,C); \\n<line30>t1 = H + SS1(E)  \\n<line31>+ F1(E,F,G)     \\n<line32>+ K             \\n<line33>+ M;            \\n<line34>D += t1;  H = t0 + t1; \\n<line35>} while(0)\n<line36>while (words < endp)\n<line37>{\n<line38>uint32_t tm;\n<line39>uint32_t t0, t1;\n<line40>int t;\n<line41>/* FIXME: see sha1.c for a better implementation.  */\n<line42>for (t = 0; t < 16; t++)\n<line43>{\n<line44>x[t] = SWAP (*words);\n<line45>words++;\n<line46>}\n<line47>R( a, b, c, d, e, f, g, h, K( 0), x[ 0] );\n<line48>R( h, a, b, c, d, e, f, g, K( 1), x[ 1] );\n<line49>R( g, h, a, b, c, d, e, f, K( 2), x[ 2] );\n<line50>R( f, g, h, a, b, c, d, e, K( 3), x[ 3] );\n<line51>R( e, f, g, h, a, b, c, d, K( 4), x[ 4] );\n<line52>R( d, e, f, g, h, a, b, c, K( 5), x[ 5] );\n<line53>R( c, d, e, f, g, h, a, b, K( 6), x[ 6] );\n<line54>R( b, c, d, e, f, g, h, a, K( 7), x[ 7] );\n<line55>R( a, b, c, d, e, f, g, h, K( 8), x[ 8] );\n<line56>R( h, a, b, c, d, e, f, g, K( 9), x[ 9] );\n<line57>R( g, h, a, b, c, d, e, f, K(10), x[10] );\n<line58>R( f, g, h, a, b, c, d, e, K(11), x[11] );\n<line59>R( e, f, g, h, a, b, c, d, K(12), x[12] );\n<line60>R( d, e, f, g, h, a, b, c, K(13), x[13] );\n<line61>R( c, d, e, f, g, h, a, b, K(14), x[14] );\n<line62>R( b, c, d, e, f, g, h, a, K(15), x[15] );\n<line63>R( a, b, c, d, e, f, g, h, K(16), M(16) );\n<line64>R( h, a, b, c, d, e, f, g, K(17), M(17) );\n<line65>R( g, h, a, b, c, d, e, f, K(18), M(18) );\n<line66>R( f, g, h, a, b, c, d, e, K(19), M(19) );\n<line67>R( e, f, g, h, a, b, c, d, K(20), M(20) );\n<line68>R( d, e, f, g, h, a, b, c, K(21), M(21) );\n<line69>R( c, d, e, f, g, h, a, b, K(22), M(22) );\n<line70>R( b, c, d, e, f, g, h, a, K(23), M(23) );\n<line71>R( a, b, c, d, e, f, g, h, K(24), M(24) );\n<line72>R( h, a, b, c, d, e, f, g, K(25), M(25) );\n<line73>R( g, h, a, b, c, d, e, f, K(26), M(26) );\n<line74>R( f, g, h, a, b, c, d, e, K(27), M(27) );\n<line75>R( e, f, g, h, a, b, c, d, K(28), M(28) );\n<line76>R( d, e, f, g, h, a, b, c, K(29), M(29) );\n<line77>R( c, d, e, f, g, h, a, b, K(30), M(30) );\n<line78>R( b, c, d, e, f, g, h, a, K(31), M(31) );\n<line79>R( a, b, c, d, e, f, g, h, K(32), M(32) );\n<line80>R( h, a, b, c, d, e, f, g, K(33), M(33) );\n<line81>R( g, h, a, b, c, d, e, f, K(34), M(34) );\n<line82>R( f, g, h, a, b, c, d, e, K(35), M(35) );\n<line83>R( e, f, g, h, a, b, c, d, K(36), M(36) );\n<line84>R( d, e, f, g, h, a, b, c, K(37), M(37) );\n<line85>R( c, d, e, f, g, h, a, b, K(38), M(38) );\n<line86>R( b, c, d, e, f, g, h, a, K(39), M(39) );\n<line87>R( a, b, c, d, e, f, g, h, K(40), M(40) );\n<line88>R( h, a, b, c, d, e, f, g, K(41), M(41) );\n<line89>R( g, h, a, b, c, d, e, f, K(42), M(42) );\n<line90>R( f, g, h, a, b, c, d, e, K(43), M(43) );\n<line91>R( e, f, g, h, a, b, c, d, K(44), M(44) );\n<line92>R( d, e, f, g, h, a, b, c, K(45), M(45) );\n<line93>R( c, d, e, f, g, h, a, b, K(46), M(46) );\n<line94>R( b, c, d, e, f, g, h, a, K(47), M(47) );\n<line95>R( a, b, c, d, e, f, g, h, K(48), M(48) );\n<line96>R( h, a, b, c, d, e, f, g, K(49), M(49) );\n<line97>R( g, h, a, b, c, d, e, f, K(50), M(50) );\n<line98>R( f, g, h, a, b, c, d, e, K(51), M(51) );\n<line99>R( e, f, g, h, a, b, c, d, K(52), M(52) );\n<line100>R( d, e, f, g, h, a, b, c, K(53), M(53) );\n<line101>R( c, d, e, f, g, h, a, b, K(54), M(54) );\n<line102>R( b, c, d, e, f, g, h, a, K(55), M(55) );\n<line103>R( a, b, c, d, e, f, g, h, K(56), M(56) );\n<line104>R( h, a, b, c, d, e, f, g, K(57), M(57) );\n<line105>R( g, h, a, b, c, d, e, f, K(58), M(58) );\n<line106>R( f, g, h, a, b, c, d, e, K(59), M(59) );\n<line107>R( e, f, g, h, a, b, c, d, K(60), M(60) );\n<line108>R( d, e, f, g, h, a, b, c, K(61), M(61) );\n<line109>R( c, d, e, f, g, h, a, b, K(62), M(62) );\n<line110>R( b, c, d, e, f, g, h, a, K(63), M(63) );\n<line111>a = ctx->state[0] += a;\n<line112>b = ctx->state[1] += b;\n<line113>c = ctx->state[2] += c;\n<line114>d = ctx->state[3] += d;\n<line115>e = ctx->state[4] += e;\n<line116>f = ctx->state[5] += f;\n<line117>g = ctx->state[6] += g;\n<line118>h = ctx->state[7] += h;\n<line119>}\n<line120>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/sha512-stream.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
Function: shaxxx_stream
Content: <line0>static int\n<line1>shaxxx_stream (FILE *stream, char const *alg, void *resblock,\n<line2>ssize_t hashlen, void (*init_ctx) (struct sha512_ctx *),\n<line3>void *(*finish_ctx) (struct sha512_ctx *, void *))\n<line4>{\n<line5>switch (afalg_stream (stream, alg, resblock, hashlen))\n<line6>{\n<line7>case 0: return 0;\n<line8>case -EIO: return 1;\n<line9>}\n<line10>char *buffer = malloc (BLOCKSIZE + 72);\n<line11>if (!buffer)\n<line12>return 1;\n<line13>struct sha512_ctx ctx;\n<line14>init_ctx (&ctx);\n<line15>size_t sum;\n<line16>/* Iterate over full file contents.  */\n<line17>while (1)\n<line18>{\n<line19>/* We read the file in blocks of BLOCKSIZE bytes.  One call of the\n<line20>computation function processes the whole buffer so that with the\n<line21>next round of the loop another block can be read.  */\n<line22>size_t n;\n<line23>sum = 0;\n<line24>/* Read block.  Take care for partial reads.  */\n<line25>while (1)\n<line26>{\n<line27>/* Either process a partial fread() from this loop,\n<line28>or the fread() in afalg_stream may have gotten EOF.\n<line29>We need to avoid a subsequent fread() as EOF may\n<line30>not be sticky.  For details of such systems, see:\n<line31>https://sourceware.org/bugzilla/show_bug.cgi?id=1190  */\n<line32>if (feof (stream))\n<line33>goto process_partial_block;\n<line34>n = fread (buffer + sum, 1, BLOCKSIZE - sum, stream);\n<line35>sum += n;\n<line36>if (sum == BLOCKSIZE)\n<line37>break;\n<line38>if (n == 0)\n<line39>{\n<line40>/* Check for the error flag IFF N == 0, so that we don't\n<line41>exit the loop after a partial read due to e.g., EAGAIN\n<line42>or EWOULDBLOCK.  */\n<line43>if (ferror (stream))\n<line44>{\n<line45>free (buffer);\n<line46>return 1;\n<line47>}\n<line48>goto process_partial_block;\n<line49>}\n<line50>}\n<line51>/* Process buffer with BLOCKSIZE bytes.  Note that\n<line52>BLOCKSIZE % 128 == 0\n<line53>*/\n<line54>sha512_process_block (buffer, BLOCKSIZE, &ctx);\n<line55>}\n<line56>process_partial_block:;\n<line57>/* Process any remaining bytes.  */\n<line58>if (sum > 0)\n<line59>sha512_process_bytes (buffer, sum, &ctx);\n<line60>/* Construct result in desired memory.  */\n<line61>finish_ctx (&ctx, resblock);\n<line62>free (buffer);\n<line63>return 0;\n<line64>}
----------------------------------------
Function: sha512_stream
Content: <line0>int\n<line1>sha512_stream (FILE *stream, void *resblock)\n<line2>{\n<line3>return shaxxx_stream (stream, "sha512", resblock, SHA512_DIGEST_SIZE,\n<line4>sha512_init_ctx, sha512_finish_ctx);\n<line5>}
----------------------------------------
Function: sha384_stream
Content: <line0>int\n<line1>sha384_stream (FILE *stream, void *resblock)\n<line2>{\n<line3>return shaxxx_stream (stream, "sha384", resblock, SHA384_DIGEST_SIZE,\n<line4>sha384_init_ctx, sha384_finish_ctx);\n<line5>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/sha512.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
Function: sha512_init_ctx
Content: <line0>void\n<line1>sha512_init_ctx (struct sha512_ctx *ctx)\n<line2>{\n<line3>ctx->state[0] = u64hilo (0x6a09e667, 0xf3bcc908);\n<line4>ctx->state[1] = u64hilo (0xbb67ae85, 0x84caa73b);\n<line5>ctx->state[2] = u64hilo (0x3c6ef372, 0xfe94f82b);\n<line6>ctx->state[3] = u64hilo (0xa54ff53a, 0x5f1d36f1);\n<line7>ctx->state[4] = u64hilo (0x510e527f, 0xade682d1);\n<line8>ctx->state[5] = u64hilo (0x9b05688c, 0x2b3e6c1f);\n<line9>ctx->state[6] = u64hilo (0x1f83d9ab, 0xfb41bd6b);\n<line10>ctx->state[7] = u64hilo (0x5be0cd19, 0x137e2179);\n<line11>ctx->total[0] = ctx->total[1] = u64lo (0);\n<line12>ctx->buflen = 0;\n<line13>}
----------------------------------------
Function: sha384_init_ctx
Content: <line0>void\n<line1>sha384_init_ctx (struct sha512_ctx *ctx)\n<line2>{\n<line3>ctx->state[0] = u64hilo (0xcbbb9d5d, 0xc1059ed8);\n<line4>ctx->state[1] = u64hilo (0x629a292a, 0x367cd507);\n<line5>ctx->state[2] = u64hilo (0x9159015a, 0x3070dd17);\n<line6>ctx->state[3] = u64hilo (0x152fecd8, 0xf70e5939);\n<line7>ctx->state[4] = u64hilo (0x67332667, 0xffc00b31);\n<line8>ctx->state[5] = u64hilo (0x8eb44a87, 0x68581511);\n<line9>ctx->state[6] = u64hilo (0xdb0c2e0d, 0x64f98fa7);\n<line10>ctx->state[7] = u64hilo (0x47b5481d, 0xbefa4fa4);\n<line11>ctx->total[0] = ctx->total[1] = u64lo (0);\n<line12>ctx->buflen = 0;\n<line13>}
----------------------------------------
Function: set_uint64
Content: <line0>static void\n<line1>set_uint64 (char *cp, u64 v)\n<line2>{\n<line3>memcpy (cp, &v, sizeof v);\n<line4>}
----------------------------------------
Function: sha512_read_ctx
Content: <line0>void *\n<line1>sha512_read_ctx (const struct sha512_ctx *ctx, void *resbuf)\n<line2>{\n<line3>int i;\n<line4>char *r = resbuf;\n<line5>for (i = 0; i < 8; i++)\n<line6>set_uint64 (r + i * sizeof ctx->state[0], SWAP (ctx->state[i]));\n<line7>return resbuf;\n<line8>}
----------------------------------------
Function: sha384_read_ctx
Content: <line0>void *\n<line1>sha384_read_ctx (const struct sha512_ctx *ctx, void *resbuf)\n<line2>{\n<line3>int i;\n<line4>char *r = resbuf;\n<line5>for (i = 0; i < 6; i++)\n<line6>set_uint64 (r + i * sizeof ctx->state[0], SWAP (ctx->state[i]));\n<line7>return resbuf;\n<line8>}
----------------------------------------
Function: sha512_conclude_ctx
Content: <line0>static void\n<line1>sha512_conclude_ctx (struct sha512_ctx *ctx)\n<line2>{\n<line3>/* Take yet unprocessed bytes into account.  */\n<line4>size_t bytes = ctx->buflen;\n<line5>size_t size = (bytes < 112) ? 128 / 8 : 128 * 2 / 8;\n<line6>/* Now count remaining bytes.  */\n<line7>ctx->total[0] = u64plus (ctx->total[0], u64lo (bytes));\n<line8>if (u64lt (ctx->total[0], u64lo (bytes)))\n<line9>ctx->total[1] = u64plus (ctx->total[1], u64lo (1));\n<line10>/* Put the 128-bit file length in *bits* at the end of the buffer.\n<line11>Use set_uint64 rather than a simple assignment, to avoid risk of\n<line12>unaligned access.  */\n<line13>set_uint64 ((char *) &ctx->buffer[size - 2],\n<line14>SWAP (u64or (u64shl (ctx->total[1], 3),\n<line15>u64shr (ctx->total[0], 61))));\n<line16>set_uint64 ((char *) &ctx->buffer[size - 1],\n<line17>SWAP (u64shl (ctx->total[0], 3)));\n<line18>memcpy (&((char *) ctx->buffer)[bytes], fillbuf, (size - 2) * 8 - bytes);\n<line19>/* Process last bytes.  */\n<line20>sha512_process_block (ctx->buffer, size * 8, ctx);\n<line21>}
----------------------------------------
Function: sha512_finish_ctx
Content: <line0>void *\n<line1>sha512_finish_ctx (struct sha512_ctx *ctx, void *resbuf)\n<line2>{\n<line3>sha512_conclude_ctx (ctx);\n<line4>return sha512_read_ctx (ctx, resbuf);\n<line5>}
----------------------------------------
Function: sha384_finish_ctx
Content: <line0>void *\n<line1>sha384_finish_ctx (struct sha512_ctx *ctx, void *resbuf)\n<line2>{\n<line3>sha512_conclude_ctx (ctx);\n<line4>return sha384_read_ctx (ctx, resbuf);\n<line5>}
----------------------------------------
Function: sha512_buffer
Content: <line0>void *\n<line1>sha512_buffer (const char *buffer, size_t len, void *resblock)\n<line2>{\n<line3>struct sha512_ctx ctx;\n<line4>/* Initialize the computation context.  */\n<line5>sha512_init_ctx (&ctx);\n<line6>/* Process whole buffer but last len % 128 bytes.  */\n<line7>sha512_process_bytes (buffer, len, &ctx);\n<line8>/* Put result in desired memory area.  */\n<line9>return sha512_finish_ctx (&ctx, resblock);\n<line10>}
----------------------------------------
Function: sha384_buffer
Content: <line0>void *\n<line1>sha384_buffer (const char *buffer, size_t len, void *resblock)\n<line2>{\n<line3>struct sha512_ctx ctx;\n<line4>/* Initialize the computation context.  */\n<line5>sha384_init_ctx (&ctx);\n<line6>/* Process whole buffer but last len % 128 bytes.  */\n<line7>sha512_process_bytes (buffer, len, &ctx);\n<line8>/* Put result in desired memory area.  */\n<line9>return sha384_finish_ctx (&ctx, resblock);\n<line10>}
----------------------------------------
Function: sha512_process_bytes
Content: <line0>void\n<line1>sha512_process_bytes (const void *buffer, size_t len, struct sha512_ctx *ctx)\n<line2>{\n<line3>/* When we already have some bits in our internal buffer concatenate\n<line4>both inputs first.  */\n<line5>if (ctx->buflen != 0)\n<line6>{\n<line7>size_t left_over = ctx->buflen;\n<line8>size_t add = 256 - left_over > len ? len : 256 - left_over;\n<line9>memcpy (&((char *) ctx->buffer)[left_over], buffer, add);\n<line10>ctx->buflen += add;\n<line11>if (ctx->buflen > 128)\n<line12>{\n<line13>sha512_process_block (ctx->buffer, ctx->buflen & ~127, ctx);\n<line14>ctx->buflen &= 127;\n<line15>/* The regions in the following copy operation cannot overlap,\n<line16>because ctx->buflen < 128  (left_over + add) & ~127.  */\n<line17>memcpy (ctx->buffer,\n<line18>&((char *) ctx->buffer)[(left_over + add) & ~127],\n<line19>ctx->buflen);\n<line20>}\n<line21>buffer = (const char *) buffer + add;\n<line22>len -= add;\n<line23>}\n<line24>/* Process available complete blocks.  */\n<line25>if (len >= 128)\n<line26>{\n<line27>#if !(_STRING_ARCH_unaligned || _STRING_INLINE_unaligned)\n<line28># define UNALIGNED_P(p) ((uintptr_t) (p) % alignof (u64) != 0)\n<line29>if (UNALIGNED_P (buffer))\n<line30>while (len > 128)\n<line31>{\n<line32>sha512_process_block (memcpy (ctx->buffer, buffer, 128), 128, ctx);\n<line33>buffer = (const char *) buffer + 128;\n<line34>len -= 128;\n<line35>}\n<line36>else\n<line37>#endif\n<line38>{\n<line39>sha512_process_block (buffer, len & ~127, ctx);\n<line40>buffer = (const char *) buffer + (len & ~127);\n<line41>len &= 127;\n<line42>}\n<line43>}\n<line44>/* Move remaining bytes in internal buffer.  */\n<line45>if (len > 0)\n<line46>{\n<line47>size_t left_over = ctx->buflen;\n<line48>memcpy (&((char *) ctx->buffer)[left_over], buffer, len);\n<line49>left_over += len;\n<line50>if (left_over >= 128)\n<line51>{\n<line52>sha512_process_block (ctx->buffer, 128, ctx);\n<line53>left_over -= 128;\n<line54>/* The regions in the following copy operation cannot overlap,\n<line55>because left_over  128.  */\n<line56>memcpy (ctx->buffer, &ctx->buffer[16], left_over);\n<line57>}\n<line58>ctx->buflen = left_over;\n<line59>}\n<line60>}
----------------------------------------
Function: sha512_process_block
Content: <line0>void\n<line1>sha512_process_block (const void *buffer, size_t len, struct sha512_ctx *ctx)\n<line2>{\n<line3>u64 const *words = buffer;\n<line4>u64 const *endp = words + len / sizeof (u64);\n<line5>u64 x[16];\n<line6>u64 a = ctx->state[0];\n<line7>u64 b = ctx->state[1];\n<line8>u64 c = ctx->state[2];\n<line9>u64 d = ctx->state[3];\n<line10>u64 e = ctx->state[4];\n<line11>u64 f = ctx->state[5];\n<line12>u64 g = ctx->state[6];\n<line13>u64 h = ctx->state[7];\n<line14>u64 lolen = u64size (len);\n<line15>/* First increment the byte count.  FIPS PUB 180-2 specifies the possible\n<line16>length of the file up to 2^128 bits.  Here we only compute the\n<line17>number of bytes.  Do a double word increment.  */\n<line18>ctx->total[0] = u64plus (ctx->total[0], lolen);\n<line19>ctx->total[1] = u64plus (ctx->total[1],\n<line20>u64plus (u64size (len >> 31 >> 31 >> 2),\n<line21>u64lo (u64lt (ctx->total[0], lolen))));\n<line22>#define S0(x) u64xor (u64rol(x, 63), u64xor (u64rol (x, 56), u64shr (x, 7)))\n<line23>#define S1(x) u64xor (u64rol (x, 45), u64xor (u64rol (x, 3), u64shr (x, 6)))\n<line24>#define SS0(x) u64xor (u64rol (x, 36), u64xor (u64rol (x, 30), u64rol (x, 25)))\n<line25>#define SS1(x) u64xor (u64rol(x, 50), u64xor (u64rol (x, 46), u64rol (x, 23)))\n<line26>#define M(I) (x[(I) & 15]                                                 \\n<line27>= u64plus (x[(I) & 15],                                     \\n<line28>u64plus (S1 (x[((I) - 2) & 15]),                 \\n<line29>u64plus (x[((I) - 7) & 15],             \\n<line30>S0 (x[((I) - 15) & 15])))))\n<line31>#define R(A, B, C, D, E, F, G, H, K, M)                                   \\n<line32>do                                                                      \\n<line33>{                                                                     \\n<line34>u64 t0 = u64plus (SS0 (A), F2 (A, B, C));                           \\n<line35>u64 t1 =                                                            \\n<line36>u64plus (H, u64plus (SS1 (E),                                     \\n<line37>u64plus (F1 (E, F, G), u64plus (K, M))));    \\n<line38>D = u64plus (D, t1);                                                \\n<line39>H = u64plus (t0, t1);                                               \\n<line40>}                                                                     \\n<line41>while (0)\n<line42>while (words < endp)\n<line43>{\n<line44>int t;\n<line45>/* FIXME: see sha1.c for a better implementation.  */\n<line46>for (t = 0; t < 16; t++)\n<line47>{\n<line48>x[t] = SWAP (*words);\n<line49>words++;\n<line50>}\n<line51>R( a, b, c, d, e, f, g, h, K( 0), x[ 0] );\n<line52>R( h, a, b, c, d, e, f, g, K( 1), x[ 1] );\n<line53>R( g, h, a, b, c, d, e, f, K( 2), x[ 2] );\n<line54>R( f, g, h, a, b, c, d, e, K( 3), x[ 3] );\n<line55>R( e, f, g, h, a, b, c, d, K( 4), x[ 4] );\n<line56>R( d, e, f, g, h, a, b, c, K( 5), x[ 5] );\n<line57>R( c, d, e, f, g, h, a, b, K( 6), x[ 6] );\n<line58>R( b, c, d, e, f, g, h, a, K( 7), x[ 7] );\n<line59>R( a, b, c, d, e, f, g, h, K( 8), x[ 8] );\n<line60>R( h, a, b, c, d, e, f, g, K( 9), x[ 9] );\n<line61>R( g, h, a, b, c, d, e, f, K(10), x[10] );\n<line62>R( f, g, h, a, b, c, d, e, K(11), x[11] );\n<line63>R( e, f, g, h, a, b, c, d, K(12), x[12] );\n<line64>R( d, e, f, g, h, a, b, c, K(13), x[13] );\n<line65>R( c, d, e, f, g, h, a, b, K(14), x[14] );\n<line66>R( b, c, d, e, f, g, h, a, K(15), x[15] );\n<line67>R( a, b, c, d, e, f, g, h, K(16), M(16) );\n<line68>R( h, a, b, c, d, e, f, g, K(17), M(17) );\n<line69>R( g, h, a, b, c, d, e, f, K(18), M(18) );\n<line70>R( f, g, h, a, b, c, d, e, K(19), M(19) );\n<line71>R( e, f, g, h, a, b, c, d, K(20), M(20) );\n<line72>R( d, e, f, g, h, a, b, c, K(21), M(21) );\n<line73>R( c, d, e, f, g, h, a, b, K(22), M(22) );\n<line74>R( b, c, d, e, f, g, h, a, K(23), M(23) );\n<line75>R( a, b, c, d, e, f, g, h, K(24), M(24) );\n<line76>R( h, a, b, c, d, e, f, g, K(25), M(25) );\n<line77>R( g, h, a, b, c, d, e, f, K(26), M(26) );\n<line78>R( f, g, h, a, b, c, d, e, K(27), M(27) );\n<line79>R( e, f, g, h, a, b, c, d, K(28), M(28) );\n<line80>R( d, e, f, g, h, a, b, c, K(29), M(29) );\n<line81>R( c, d, e, f, g, h, a, b, K(30), M(30) );\n<line82>R( b, c, d, e, f, g, h, a, K(31), M(31) );\n<line83>R( a, b, c, d, e, f, g, h, K(32), M(32) );\n<line84>R( h, a, b, c, d, e, f, g, K(33), M(33) );\n<line85>R( g, h, a, b, c, d, e, f, K(34), M(34) );\n<line86>R( f, g, h, a, b, c, d, e, K(35), M(35) );\n<line87>R( e, f, g, h, a, b, c, d, K(36), M(36) );\n<line88>R( d, e, f, g, h, a, b, c, K(37), M(37) );\n<line89>R( c, d, e, f, g, h, a, b, K(38), M(38) );\n<line90>R( b, c, d, e, f, g, h, a, K(39), M(39) );\n<line91>R( a, b, c, d, e, f, g, h, K(40), M(40) );\n<line92>R( h, a, b, c, d, e, f, g, K(41), M(41) );\n<line93>R( g, h, a, b, c, d, e, f, K(42), M(42) );\n<line94>R( f, g, h, a, b, c, d, e, K(43), M(43) );\n<line95>R( e, f, g, h, a, b, c, d, K(44), M(44) );\n<line96>R( d, e, f, g, h, a, b, c, K(45), M(45) );\n<line97>R( c, d, e, f, g, h, a, b, K(46), M(46) );\n<line98>R( b, c, d, e, f, g, h, a, K(47), M(47) );\n<line99>R( a, b, c, d, e, f, g, h, K(48), M(48) );\n<line100>R( h, a, b, c, d, e, f, g, K(49), M(49) );\n<line101>R( g, h, a, b, c, d, e, f, K(50), M(50) );\n<line102>R( f, g, h, a, b, c, d, e, K(51), M(51) );\n<line103>R( e, f, g, h, a, b, c, d, K(52), M(52) );\n<line104>R( d, e, f, g, h, a, b, c, K(53), M(53) );\n<line105>R( c, d, e, f, g, h, a, b, K(54), M(54) );\n<line106>R( b, c, d, e, f, g, h, a, K(55), M(55) );\n<line107>R( a, b, c, d, e, f, g, h, K(56), M(56) );\n<line108>R( h, a, b, c, d, e, f, g, K(57), M(57) );\n<line109>R( g, h, a, b, c, d, e, f, K(58), M(58) );\n<line110>R( f, g, h, a, b, c, d, e, K(59), M(59) );\n<line111>R( e, f, g, h, a, b, c, d, K(60), M(60) );\n<line112>R( d, e, f, g, h, a, b, c, K(61), M(61) );\n<line113>R( c, d, e, f, g, h, a, b, K(62), M(62) );\n<line114>R( b, c, d, e, f, g, h, a, K(63), M(63) );\n<line115>R( a, b, c, d, e, f, g, h, K(64), M(64) );\n<line116>R( h, a, b, c, d, e, f, g, K(65), M(65) );\n<line117>R( g, h, a, b, c, d, e, f, K(66), M(66) );\n<line118>R( f, g, h, a, b, c, d, e, K(67), M(67) );\n<line119>R( e, f, g, h, a, b, c, d, K(68), M(68) );\n<line120>R( d, e, f, g, h, a, b, c, K(69), M(69) );\n<line121>R( c, d, e, f, g, h, a, b, K(70), M(70) );\n<line122>R( b, c, d, e, f, g, h, a, K(71), M(71) );\n<line123>R( a, b, c, d, e, f, g, h, K(72), M(72) );\n<line124>R( h, a, b, c, d, e, f, g, K(73), M(73) );\n<line125>R( g, h, a, b, c, d, e, f, K(74), M(74) );\n<line126>R( f, g, h, a, b, c, d, e, K(75), M(75) );\n<line127>R( e, f, g, h, a, b, c, d, K(76), M(76) );\n<line128>R( d, e, f, g, h, a, b, c, K(77), M(77) );\n<line129>R( c, d, e, f, g, h, a, b, K(78), M(78) );\n<line130>R( b, c, d, e, f, g, h, a, K(79), M(79) );\n<line131>a = ctx->state[0] = u64plus (ctx->state[0], a);\n<line132>b = ctx->state[1] = u64plus (ctx->state[1], b);\n<line133>c = ctx->state[2] = u64plus (ctx->state[2], c);\n<line134>d = ctx->state[3] = u64plus (ctx->state[3], d);\n<line135>e = ctx->state[4] = u64plus (ctx->state[4], e);\n<line136>f = ctx->state[5] = u64plus (ctx->state[5], f);\n<line137>g = ctx->state[6] = u64plus (ctx->state[6], g);\n<line138>h = ctx->state[7] = u64plus (ctx->state[7], h);\n<line139>}\n<line140>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/sm3-stream.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
Function: sm3_stream
Content: <line0>int\n<line1>sm3_stream (FILE *stream, void *resblock)\n<line2>{\n<line3>struct sm3_ctx ctx;\n<line4>size_t sum;\n<line5>char *buffer = malloc (BLOCKSIZE + 72);\n<line6>if (!buffer)\n<line7>return 1;\n<line8>/* Initialize the computation context.  */\n<line9>sm3_init_ctx (&ctx);\n<line10>/* Iterate over full file contents.  */\n<line11>while (1)\n<line12>{\n<line13>/* We read the file in blocks of BLOCKSIZE bytes.  One call of the\n<line14>computation function processes the whole buffer so that with the\n<line15>next round of the loop another block can be read.  */\n<line16>size_t n;\n<line17>sum = 0;\n<line18>/* Read block.  Take care for partial reads.  */\n<line19>while (1)\n<line20>{\n<line21>n = fread (buffer + sum, 1, BLOCKSIZE - sum, stream);\n<line22>sum += n;\n<line23>if (sum == BLOCKSIZE)\n<line24>break;\n<line25>if (n == 0)\n<line26>{\n<line27>/* Check for the error flag IFF N == 0, so that we don't\n<line28>exit the loop after a partial read due to e.g., EAGAIN\n<line29>or EWOULDBLOCK.  */\n<line30>if (ferror (stream))\n<line31>{\n<line32>free (buffer);\n<line33>return 1;\n<line34>}\n<line35>goto process_partial_block;\n<line36>}\n<line37>/* We've read at least one byte, so ignore errors.  But always\n<line38>check for EOF, since feof may be true even though N > 0.\n<line39>Otherwise, we could end up calling fread after EOF.  */\n<line40>if (feof (stream))\n<line41>goto process_partial_block;\n<line42>}\n<line43>/* Process buffer with BLOCKSIZE bytes.  Note that\n<line44>BLOCKSIZE % 64 == 0\n<line45>*/\n<line46>sm3_process_block (buffer, BLOCKSIZE, &ctx);\n<line47>}\n<line48>process_partial_block:;\n<line49>/* Process any remaining bytes.  */\n<line50>if (sum > 0)\n<line51>sm3_process_bytes (buffer, sum, &ctx);\n<line52>/* Construct result in desired memory.  */\n<line53>sm3_finish_ctx (&ctx, resblock);\n<line54>free (buffer);\n<line55>return 0;\n<line56>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/sm3.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
Function: sm3_init_ctx
Content: <line0>void\n<line1>sm3_init_ctx (struct sm3_ctx *ctx)\n<line2>{\n<line3>ctx->state[0] = 0x7380166fUL;\n<line4>ctx->state[1] = 0x4914b2b9UL;\n<line5>ctx->state[2] = 0x172442d7UL;\n<line6>ctx->state[3] = 0xda8a0600UL;\n<line7>ctx->state[4] = 0xa96f30bcUL;\n<line8>ctx->state[5] = 0x163138aaUL;\n<line9>ctx->state[6] = 0xe38dee4dUL;\n<line10>ctx->state[7] = 0xb0fb0e4eUL;\n<line11>ctx->total[0] = ctx->total[1] = 0;\n<line12>ctx->buflen = 0;\n<line13>}
----------------------------------------
Function: set_uint32
Content: <line0>static void\n<line1>set_uint32 (char *cp, uint32_t v)\n<line2>{\n<line3>memcpy (cp, &v, sizeof v);\n<line4>}
----------------------------------------
Function: sm3_read_ctx
Content: <line0>void *\n<line1>sm3_read_ctx (const struct sm3_ctx *ctx, void *resbuf)\n<line2>{\n<line3>int i;\n<line4>char *r = resbuf;\n<line5>for (i = 0; i < 8; i++)\n<line6>set_uint32 (r + i * sizeof ctx->state[0], SWAP (ctx->state[i]));\n<line7>return resbuf;\n<line8>}
----------------------------------------
Function: sm3_conclude_ctx
Content: <line0>static void\n<line1>sm3_conclude_ctx (struct sm3_ctx *ctx)\n<line2>{\n<line3>/* Take yet unprocessed bytes into account.  */\n<line4>size_t bytes = ctx->buflen;\n<line5>size_t size = (bytes < 56) ? 64 / 4 : 64 * 2 / 4;\n<line6>/* Now count remaining bytes.  */\n<line7>ctx->total[0] += bytes;\n<line8>if (ctx->total[0] < bytes)\n<line9>++ctx->total[1];\n<line10>/* Put the 64-bit file length in *bits* at the end of the buffer.\n<line11>Use set_uint32 rather than a simple assignment, to avoid risk of\n<line12>unaligned access.  */\n<line13>set_uint32 ((char *) &ctx->buffer[size - 2],\n<line14>SWAP ((ctx->total[1] << 3) | (ctx->total[0] >> 29)));\n<line15>set_uint32 ((char *) &ctx->buffer[size - 1],\n<line16>SWAP (ctx->total[0] << 3));\n<line17>memcpy (&((char *) ctx->buffer)[bytes], fillbuf, (size - 2) * 4 - bytes);\n<line18>/* Process last bytes.  */\n<line19>sm3_process_block (ctx->buffer, size * 4, ctx);\n<line20>}
----------------------------------------
Function: sm3_finish_ctx
Content: <line0>void *\n<line1>sm3_finish_ctx (struct sm3_ctx *ctx, void *resbuf)\n<line2>{\n<line3>sm3_conclude_ctx (ctx);\n<line4>return sm3_read_ctx (ctx, resbuf);\n<line5>}
----------------------------------------
Function: sm3_buffer
Content: <line0>void *\n<line1>sm3_buffer (const char *buffer, size_t len, void *resblock)\n<line2>{\n<line3>struct sm3_ctx ctx;\n<line4>/* Initialize the computation context.  */\n<line5>sm3_init_ctx (&ctx);\n<line6>/* Process whole buffer but last len % 64 bytes.  */\n<line7>sm3_process_bytes (buffer, len, &ctx);\n<line8>/* Put result in desired memory area.  */\n<line9>return sm3_finish_ctx (&ctx, resblock);\n<line10>}
----------------------------------------
Function: sm3_process_bytes
Content: <line0>void\n<line1>sm3_process_bytes (const void *buffer, size_t len, struct sm3_ctx *ctx)\n<line2>{\n<line3>/* When we already have some bits in our internal buffer concatenate\n<line4>both inputs first.  */\n<line5>if (ctx->buflen != 0)\n<line6>{\n<line7>size_t left_over = ctx->buflen;\n<line8>size_t add = 128 - left_over > len ? len : 128 - left_over;\n<line9>memcpy (&((char *) ctx->buffer)[left_over], buffer, add);\n<line10>ctx->buflen += add;\n<line11>if (ctx->buflen > 64)\n<line12>{\n<line13>sm3_process_block (ctx->buffer, ctx->buflen & ~63, ctx);\n<line14>ctx->buflen &= 63;\n<line15>/* The regions in the following copy operation cannot overlap,\n<line16>because ctx->buflen < 64  (left_over + add) & ~63.  */\n<line17>memcpy (ctx->buffer,\n<line18>&((char *) ctx->buffer)[(left_over + add) & ~63],\n<line19>ctx->buflen);\n<line20>}\n<line21>buffer = (const char *) buffer + add;\n<line22>len -= add;\n<line23>}\n<line24>/* Process available complete blocks.  */\n<line25>if (len >= 64)\n<line26>{\n<line27>#if !(_STRING_ARCH_unaligned || _STRING_INLINE_unaligned)\n<line28># define UNALIGNED_P(p) ((uintptr_t) (p) % alignof (uint32_t) != 0)\n<line29>if (UNALIGNED_P (buffer))\n<line30>while (len > 64)\n<line31>{\n<line32>sm3_process_block (memcpy (ctx->buffer, buffer, 64), 64, ctx);\n<line33>buffer = (const char *) buffer + 64;\n<line34>len -= 64;\n<line35>}\n<line36>else\n<line37>#endif\n<line38>{\n<line39>sm3_process_block (buffer, len & ~63, ctx);\n<line40>buffer = (const char *) buffer + (len & ~63);\n<line41>len &= 63;\n<line42>}\n<line43>}\n<line44>/* Move remaining bytes in internal buffer.  */\n<line45>if (len > 0)\n<line46>{\n<line47>size_t left_over = ctx->buflen;\n<line48>memcpy (&((char *) ctx->buffer)[left_over], buffer, len);\n<line49>left_over += len;\n<line50>if (left_over >= 64)\n<line51>{\n<line52>sm3_process_block (ctx->buffer, 64, ctx);\n<line53>left_over -= 64;\n<line54>/* The regions in the following copy operation cannot overlap,\n<line55>because left_over  64.  */\n<line56>memcpy (ctx->buffer, &ctx->buffer[16], left_over);\n<line57>}\n<line58>ctx->buflen = left_over;\n<line59>}\n<line60>}
----------------------------------------
Function: sm3_process_block
Content: <line0>void\n<line1>sm3_process_block (const void *buffer, size_t len, struct sm3_ctx *ctx)\n<line2>{\n<line3>const uint32_t *words = buffer;\n<line4>size_t nwords = len / sizeof (uint32_t);\n<line5>const uint32_t *endp = words + nwords;\n<line6>uint32_t x[16];\n<line7>uint32_t a = ctx->state[0];\n<line8>uint32_t b = ctx->state[1];\n<line9>uint32_t c = ctx->state[2];\n<line10>uint32_t d = ctx->state[3];\n<line11>uint32_t e = ctx->state[4];\n<line12>uint32_t f = ctx->state[5];\n<line13>uint32_t g = ctx->state[6];\n<line14>uint32_t h = ctx->state[7];\n<line15>uint32_t lolen = len;\n<line16>/* First increment the byte count.  GM/T 004-2012 specifies the possible\n<line17>length of the file up to 2^64 bits.  Here we only compute the\n<line18>number of bytes.  Do a double word increment.  */\n<line19>ctx->total[0] += lolen;\n<line20>ctx->total[1] += (len >> 31 >> 1) + (ctx->total[0] < lolen);\n<line21>#define rol(x, n) (((x) << ((n) & 31)) | ((x) >> ((32 - (n)) & 31)))\n<line22>#define P0(x) ((x)^rol(x,9)^rol(x,17))\n<line23>#define P1(x) ((x)^rol(x,15)^rol(x,23))\n<line24>#define W1(I) ( x[I&0x0f] )\n<line25>#define W2(I) ( tw =   P1(x[I&0x0f]^x[(I-9)&0x0f]^rol(x[(I-3)&0x0f],15)) \\n<line26>^ rol(x[(I-13)&0x0f],7) ^ x[(I-6)&0x0f] \\n<line27>, x[I&0x0f] = tw )\n<line28>#define R(i,A,B,C,D,E,F,G,H,T,W1,W2) \\n<line29>do { \\n<line30>if (++j) \\n<line31>dbg_printf("%2d %08x %08x %08x %08x %08x %08x %08x %08x\n", \\n<line32>j-1, A, B, C, D, E, F, G, H); \\n<line33>ss1 = rol(rol(A,12) + E + T,7); \\n<line34>ss2 = ss1 ^ rol(A,12); \\n<line35>D += FF##i(A,B,C) + ss2 + (W1 ^ W2); \\n<line36>H += GG##i(E,F,G) + ss1 + W1; \\n<line37>B = rol(B,9); \\n<line38>F = rol(F,19); \\n<line39>H = P0(H); \\n<line40>} while(0)\n<line41>#define R1(A,B,C,D,E,F,G,H,T,W1,W2) R(1,A,B,C,D,E,F,G,H,T,W1,W2)\n<line42>#define R2(A,B,C,D,E,F,G,H,T,W1,W2) R(2,A,B,C,D,E,F,G,H,T,W1,W2)\n<line43>while (words < endp)\n<line44>{\n<line45>uint32_t tw;\n<line46>uint32_t ss1, ss2;\n<line47>int j;\n<line48>for (j = 0; j < 16; j++)\n<line49>{\n<line50>x[j] = SWAP (*words);\n<line51>words++;\n<line52>}\n<line53>j = -1;\n<line54>dbg_printf (" j    A        B        C        D        E  "\n<line55>"      F        G        H\n"\n<line56>"   %08x %08x %08x %08x %08x %08x %08x %08x\n",\n<line57>a, b, c, d, e, f, g, h);\n<line58>R1( a, b, c, d, e, f, g, h, T( 0), W1( 0), W1( 4) );\n<line59>R1( d, a, b, c, h, e, f, g, T( 1), W1( 1), W1( 5) );\n<line60>R1( c, d, a, b, g, h, e, f, T( 2), W1( 2), W1( 6) );\n<line61>R1( b, c, d, a, f, g, h, e, T( 3), W1( 3), W1( 7) );\n<line62>R1( a, b, c, d, e, f, g, h, T( 4), W1( 4), W1( 8) );\n<line63>R1( d, a, b, c, h, e, f, g, T( 5), W1( 5), W1( 9) );\n<line64>R1( c, d, a, b, g, h, e, f, T( 6), W1( 6), W1(10) );\n<line65>R1( b, c, d, a, f, g, h, e, T( 7), W1( 7), W1(11) );\n<line66>R1( a, b, c, d, e, f, g, h, T( 8), W1( 8), W1(12) );\n<line67>R1( d, a, b, c, h, e, f, g, T( 9), W1( 9), W1(13) );\n<line68>R1( c, d, a, b, g, h, e, f, T(10), W1(10), W1(14) );\n<line69>R1( b, c, d, a, f, g, h, e, T(11), W1(11), W1(15) );\n<line70>R1( a, b, c, d, e, f, g, h, T(12), W1(12), W2(16) );\n<line71>R1( d, a, b, c, h, e, f, g, T(13), W1(13), W2(17) );\n<line72>R1( c, d, a, b, g, h, e, f, T(14), W1(14), W2(18) );\n<line73>R1( b, c, d, a, f, g, h, e, T(15), W1(15), W2(19) );\n<line74>R2( a, b, c, d, e, f, g, h, T(16), W1(16), W2(20) );\n<line75>R2( d, a, b, c, h, e, f, g, T(17), W1(17), W2(21) );\n<line76>R2( c, d, a, b, g, h, e, f, T(18), W1(18), W2(22) );\n<line77>R2( b, c, d, a, f, g, h, e, T(19), W1(19), W2(23) );\n<line78>R2( a, b, c, d, e, f, g, h, T(20), W1(20), W2(24) );\n<line79>R2( d, a, b, c, h, e, f, g, T(21), W1(21), W2(25) );\n<line80>R2( c, d, a, b, g, h, e, f, T(22), W1(22), W2(26) );\n<line81>R2( b, c, d, a, f, g, h, e, T(23), W1(23), W2(27) );\n<line82>R2( a, b, c, d, e, f, g, h, T(24), W1(24), W2(28) );\n<line83>R2( d, a, b, c, h, e, f, g, T(25), W1(25), W2(29) );\n<line84>R2( c, d, a, b, g, h, e, f, T(26), W1(26), W2(30) );\n<line85>R2( b, c, d, a, f, g, h, e, T(27), W1(27), W2(31) );\n<line86>R2( a, b, c, d, e, f, g, h, T(28), W1(28), W2(32) );\n<line87>R2( d, a, b, c, h, e, f, g, T(29), W1(29), W2(33) );\n<line88>R2( c, d, a, b, g, h, e, f, T(30), W1(30), W2(34) );\n<line89>R2( b, c, d, a, f, g, h, e, T(31), W1(31), W2(35) );\n<line90>R2( a, b, c, d, e, f, g, h, T(32), W1(32), W2(36) );\n<line91>R2( d, a, b, c, h, e, f, g, T(33), W1(33), W2(37) );\n<line92>R2( c, d, a, b, g, h, e, f, T(34), W1(34), W2(38) );\n<line93>R2( b, c, d, a, f, g, h, e, T(35), W1(35), W2(39) );\n<line94>R2( a, b, c, d, e, f, g, h, T(36), W1(36), W2(40) );\n<line95>R2( d, a, b, c, h, e, f, g, T(37), W1(37), W2(41) );\n<line96>R2( c, d, a, b, g, h, e, f, T(38), W1(38), W2(42) );\n<line97>R2( b, c, d, a, f, g, h, e, T(39), W1(39), W2(43) );\n<line98>R2( a, b, c, d, e, f, g, h, T(40), W1(40), W2(44) );\n<line99>R2( d, a, b, c, h, e, f, g, T(41), W1(41), W2(45) );\n<line100>R2( c, d, a, b, g, h, e, f, T(42), W1(42), W2(46) );\n<line101>R2( b, c, d, a, f, g, h, e, T(43), W1(43), W2(47) );\n<line102>R2( a, b, c, d, e, f, g, h, T(44), W1(44), W2(48) );\n<line103>R2( d, a, b, c, h, e, f, g, T(45), W1(45), W2(49) );\n<line104>R2( c, d, a, b, g, h, e, f, T(46), W1(46), W2(50) );\n<line105>R2( b, c, d, a, f, g, h, e, T(47), W1(47), W2(51) );\n<line106>R2( a, b, c, d, e, f, g, h, T(48), W1(48), W2(52) );\n<line107>R2( d, a, b, c, h, e, f, g, T(49), W1(49), W2(53) );\n<line108>R2( c, d, a, b, g, h, e, f, T(50), W1(50), W2(54) );\n<line109>R2( b, c, d, a, f, g, h, e, T(51), W1(51), W2(55) );\n<line110>R2( a, b, c, d, e, f, g, h, T(52), W1(52), W2(56) );\n<line111>R2( d, a, b, c, h, e, f, g, T(53), W1(53), W2(57) );\n<line112>R2( c, d, a, b, g, h, e, f, T(54), W1(54), W2(58) );\n<line113>R2( b, c, d, a, f, g, h, e, T(55), W1(55), W2(59) );\n<line114>R2( a, b, c, d, e, f, g, h, T(56), W1(56), W2(60) );\n<line115>R2( d, a, b, c, h, e, f, g, T(57), W1(57), W2(61) );\n<line116>R2( c, d, a, b, g, h, e, f, T(58), W1(58), W2(62) );\n<line117>R2( b, c, d, a, f, g, h, e, T(59), W1(59), W2(63) );\n<line118>R2( a, b, c, d, e, f, g, h, T(60), W1(60), W2(64) );\n<line119>R2( d, a, b, c, h, e, f, g, T(61), W1(61), W2(65) );\n<line120>R2( c, d, a, b, g, h, e, f, T(62), W1(62), W2(66) );\n<line121>R2( b, c, d, a, f, g, h, e, T(63), W1(63), W2(67) );\n<line122>dbg_printf("%2d %08x %08x %08x %08x %08x %08x %08x %08x\n",\n<line123>j, a, b, c, d, e, f, g, h);\n<line124>a = ctx->state[0] ^= a;\n<line125>b = ctx->state[1] ^= b;\n<line126>c = ctx->state[2] ^= c;\n<line127>d = ctx->state[3] ^= d;\n<line128>e = ctx->state[4] ^= e;\n<line129>f = ctx->state[5] ^= f;\n<line130>g = ctx->state[6] ^= g;\n<line131>h = ctx->state[7] ^= h;\n<line132>}\n<line133>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/cycle-check.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
Function: is_zero_or_power_of_two
Content: <line0>static bool\n<line1>is_zero_or_power_of_two (uintmax_t i)\n<line2>{\n<line3>return (i & (i - 1)) == 0;\n<line4>}
----------------------------------------
Function: cycle_check_init
Content: <line0>void\n<line1>cycle_check_init (struct cycle_check_state *state)\n<line2>{\n<line3>state->chdir_counter = 0;\n<line4>state->magic = CC_MAGIC;\n<line5>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/di-set.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
Function: di_ent_hash
Content: <line0>static size_t\n<line1>di_ent_hash (void const *x, size_t table_size)\n<line2>{\n<line3>struct di_ent const *p = x;\n<line4>dev_t dev = p->dev;\n<line5>/* When DEV is wider than size_t, exclusive-OR the words of DEV into H.\n<line6>This avoids loss of info, without applying % to the wider type,\n<line7>which could be quite slow on some systems.  */\n<line8>size_t h = dev;\n<line9>unsigned int i;\n<line10>unsigned int n_words = sizeof dev / sizeof h + (sizeof dev % sizeof h != 0);\n<line11>for (i = 1; i < n_words; i++)\n<line12>h ^= dev >> CHAR_BIT * sizeof h * i;\n<line13>return h % table_size;\n<line14>}
----------------------------------------
Function: di_ent_compare
Content: <line0>static bool\n<line1>di_ent_compare (void const *x, void const *y)\n<line2>{\n<line3>struct di_ent const *a = x;\n<line4>struct di_ent const *b = y;\n<line5>return a->dev == b->dev;\n<line6>}
----------------------------------------
Function: di_ent_free
Content: <line0>static void\n<line1>di_ent_free (void *v)\n<line2>{\n<line3>struct di_ent *a = v;\n<line4>hash_free (a->ino_set);\n<line5>free (a);\n<line6>}
----------------------------------------
Function: di_set_alloc
Content: <line0>struct di_set *\n<line1>di_set_alloc (void)\n<line2>{\n<line3>struct di_set *dis = malloc (sizeof *dis);\n<line4>if (dis)\n<line5>{\n<line6>enum { INITIAL_DEV_MAP_SIZE = 11 };\n<line7>dis->dev_map = hash_initialize (INITIAL_DEV_MAP_SIZE, NULL,\n<line8>di_ent_hash, di_ent_compare,\n<line9>di_ent_free);\n<line10>if (! dis->dev_map)\n<line11>{\n<line12>free (dis);\n<line13>return NULL;\n<line14>}\n<line15>dis->ino_map = NULL;\n<line16>dis->probe = NULL;\n<line17>}\n<line18>return dis;\n<line19>}
----------------------------------------
Function: di_set_free
Content: <line0>void\n<line1>di_set_free (struct di_set *dis)\n<line2>{\n<line3>hash_free (dis->dev_map);\n<line4>if (dis->ino_map)\n<line5>ino_map_free (dis->ino_map);\n<line6>free (dis->probe);\n<line7>free (dis);\n<line8>}
----------------------------------------
Function: di_ino_hash
Content: <line0>static size_t\n<line1>di_ino_hash (void const *i, size_t table_size)\n<line2>{\n<line3>return (hashint) i % table_size;\n<line4>}
----------------------------------------
Function: map_device
Content: <line0>static struct hash_table *\n<line1>map_device (struct di_set *dis, dev_t dev)\n<line2>{\n<line3>/* Find space for the probe, reusing the cache if available.  */\n<line4>struct di_ent *ent;\n<line5>struct di_ent *probe = dis->probe;\n<line6>if (probe)\n<line7>{\n<line8>/* If repeating a recent query, return the cached result.   */\n<line9>if (probe->dev == dev)\n<line10>return probe->ino_set;\n<line11>}\n<line12>else\n<line13>{\n<line14>dis->probe = probe = malloc (sizeof *probe);\n<line15>if (! probe)\n<line16>return NULL;\n<line17>}\n<line18>/* Probe for the device.  */\n<line19>probe->dev = dev;\n<line20>ent = hash_insert (dis->dev_map, probe);\n<line21>if (! ent)\n<line22>return NULL;\n<line23>if (ent != probe)\n<line24>{\n<line25>/* Use the existing entry.  */\n<line26>probe->ino_set = ent->ino_set;\n<line27>}\n<line28>else\n<line29>{\n<line30>enum { INITIAL_INO_SET_SIZE = 1021 };\n<line31>/* Prepare to allocate a new probe next time; this one is in use.  */\n<line32>dis->probe = NULL;\n<line33>/* DEV is new; allocate an inode set for it.  */\n<line34>probe->ino_set = hash_initialize (INITIAL_INO_SET_SIZE, NULL,\n<line35>di_ino_hash, NULL, NULL);\n<line36>}\n<line37>return probe->ino_set;\n<line38>}
----------------------------------------
Function: map_inode_number
Content: <line0>static hashint\n<line1>map_inode_number (struct di_set *dis, ino_t ino)\n<line2>{\n<line3>if (0 < ino && ino < LARGE_INO_MIN)\n<line4>return ino;\n<line5>if (! dis->ino_map)\n<line6>{\n<line7>dis->ino_map = ino_map_alloc (LARGE_INO_MIN);\n<line8>if (! dis->ino_map)\n<line9>return INO_MAP_INSERT_FAILURE;\n<line10>}\n<line11>return ino_map_insert (dis->ino_map, ino);\n<line12>}
----------------------------------------
Function: di_set_insert
Content: <line0>int\n<line1>di_set_insert (struct di_set *dis, dev_t dev, ino_t ino)\n<line2>{\n<line3>hashint i;\n<line4>/* Map the device number to a set of inodes.  */\n<line5>struct hash_table *ino_set = map_device (dis, dev);\n<line6>if (! ino_set)\n<line7>return -1;\n<line8>/* Map the inode number to a small representative I.  */\n<line9>i = map_inode_number (dis, ino);\n<line10>if (i == INO_MAP_INSERT_FAILURE)\n<line11>return -1;\n<line12>/* Put I into the inode set.  */\n<line13>return hash_insert_if_absent (ino_set, (void const *) i, NULL);\n<line14>}
----------------------------------------
Function: di_set_lookup
Content: <line0>int\n<line1>di_set_lookup (struct di_set *dis, dev_t dev, ino_t ino)\n<line2>{\n<line3>hashint i;\n<line4>/* Map the device number to a set of inodes.  */\n<line5>struct hash_table *ino_set = map_device (dis, dev);\n<line6>if (! ino_set)\n<line7>return -1;\n<line8>/* Map the inode number to a small representative I.  */\n<line9>i = map_inode_number (dis, ino);\n<line10>if (i == INO_MAP_INSERT_FAILURE)\n<line11>return -1;\n<line12>/* Perform the look-up.  */\n<line13>return !!hash_lookup (ino_set, (void const *) i);\n<line14>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/opendir-safer.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
Function: opendir_safer
Content: <line0>DIR *\n<line1>opendir_safer (char const *name)\n<line2>{\n<line3>DIR *dp = opendir (name);\n<line4>if (dp)\n<line5>{\n<line6>int fd = dirfd (dp);\n<line7>if (0 <= fd && fd <= STDERR_FILENO)\n<line8>{\n<line9>/* If fdopendir is native (as on Linux), then it is safe to\n<line10>assume dirfd(fdopendir(n))==n.  If we are using the\n<line11>gnulib module fdopendir, then this guarantee is not met,\n<line12>but fdopendir recursively calls opendir_safer up to 3\n<line13>times to at least get a safe fd.  If fdopendir is not\n<line14>present but dirfd is accurate (as on cygwin 1.5.x), then\n<line15>we recurse up to 3 times ourselves.  Finally, if dirfd\n<line16>always fails (as on mingw), then we are already safe.  */\n<line17>DIR *newdp;\n<line18>int e;\n<line19>#if HAVE_FDOPENDIR || GNULIB_FDOPENDIR\n<line20>int f = fcntl (fd, F_DUPFD_CLOEXEC, STDERR_FILENO + 1);\n<line21>if (f < 0)\n<line22>{\n<line23>e = errno;\n<line24>newdp = NULL;\n<line25>}\n<line26>else\n<line27>{\n<line28>newdp = fdopendir (f);\n<line29>e = errno;\n<line30>if (! newdp)\n<line31>close (f);\n<line32>}\n<line33>#else /* !FDOPENDIR */\n<line34>newdp = opendir_safer (name);\n<line35>e = errno;\n<line36>#endif\n<line37>closedir (dp);\n<line38>errno = e;\n<line39>dp = newdp;\n<line40>}\n<line41>}\n<line42>return dp;\n<line43>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/dirname.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
Function: dir_name
Content: <line0>char *\n<line1>dir_name (char const *file)\n<line2>{\n<line3>char *result = mdir_name (file);\n<line4>if (!result)\n<line5>xalloc_die ();\n<line6>return result;\n<line7>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/basename.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
Function: base_name
Content: <line0>char *\n<line1>base_name (char const *name)\n<line2>{\n<line3>char const *base = last_component (name);\n<line4>idx_t length;\n<line5>int dotslash_len;\n<line6>if (*base)\n<line7>{\n<line8>length = base_len (base);\n<line9>/* Collapse a sequence of trailing slashes into one.  */\n<line10>length += ISSLASH (base[length]);\n<line11>/* On systems with drive letters, "a/b:c" must return "./b:c" rather\n<line12>than "b:c" to avoid confusion with a drive letter.  On systems\n<line13>with pure POSIX semantics, this is not an issue.  */\n<line14>dotslash_len = FILE_SYSTEM_PREFIX_LEN (base) != 0 ? 2 : 0;\n<line15>}\n<line16>else\n<line17>{\n<line18>/* There is no last component, so NAME is a file system root or\n<line19>the empty string.  */\n<line20>base = name;\n<line21>length = base_len (base);\n<line22>dotslash_len = 0;\n<line23>}\n<line24>char *p = ximalloc (dotslash_len + length + 1);\n<line25>if (dotslash_len)\n<line26>{\n<line27>p[0] = '.';\n<line28>p[1] = '/';\n<line29>}\n<line30>/* Finally, copy the basename.  */\n<line31>memcpy (p + dotslash_len, base, length);\n<line32>p[dotslash_len + length] = '\0';\n<line33>return p;\n<line34>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/dirname-lgpl.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
Function: dir_len
Content: <line0>size_t\n<line1>dir_len (char const *file)\n<line2>{\n<line3>size_t prefix_length = FILE_SYSTEM_PREFIX_LEN (file);\n<line4>size_t length;\n<line5>/* Advance prefix_length beyond important leading slashes.  */\n<line6>prefix_length += (prefix_length != 0\n<line7>? (FILE_SYSTEM_DRIVE_PREFIX_CAN_BE_RELATIVE\n<line8>&& ISSLASH (file[prefix_length]))\n<line9>: (ISSLASH (file[0])\n<line10>? ((DOUBLE_SLASH_IS_DISTINCT_ROOT\n<line11>&& ISSLASH (file[1]) && ! ISSLASH (file[2])\n<line12>? 2 : 1))\n<line13>: 0));\n<line14>/* Strip the basename and any redundant slashes before it.  */\n<line15>for (length = last_component (file) - file;\n<line16>prefix_length < length; length--)\n<line17>if (! ISSLASH (file[length - 1]))\n<line18>break;\n<line19>return length;\n<line20>}
----------------------------------------
Function: mdir_name
Content: <line0>char *\n<line1>mdir_name (char const *file)\n<line2>{\n<line3>size_t length = dir_len (file);\n<line4>bool append_dot = (length == 0\n<line5>|| (FILE_SYSTEM_DRIVE_PREFIX_CAN_BE_RELATIVE\n<line6>&& length == FILE_SYSTEM_PREFIX_LEN (file)\n<line7>&& file[2] != '\0' && ! ISSLASH (file[2])));\n<line8>char *dir = malloc (length + append_dot + 1);\n<line9>if (!dir)\n<line10>return NULL;\n<line11>memcpy (dir, file, length);\n<line12>if (append_dot)\n<line13>dir[length++] = '.';\n<line14>dir[length] = '\0';\n<line15>return dir;\n<line16>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/stripslash.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
========================================
/home/huihui/Downloads/coreutils-9.4/lib/dtoastr.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
========================================
/home/huihui/Downloads/coreutils-9.4/lib/dtotimespec.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
Function: dtotimespec
Content: <line0>struct timespec\n<line1>dtotimespec (double sec)\n<line2>{\n<line3>if (! (TYPE_MINIMUM (time_t) < sec))\n<line4>return make_timespec (TYPE_MINIMUM (time_t), 0);\n<line5>else if (! (sec < 1.0 + TYPE_MAXIMUM (time_t)))\n<line6>return make_timespec (TYPE_MAXIMUM (time_t), TIMESPEC_HZ - 1);\n<line7>else\n<line8>{\n<line9>time_t s = sec;\n<line10>double frac = TIMESPEC_HZ * (sec - s);\n<line11>long ns = frac;\n<line12>ns += ns < frac;\n<line13>s += ns / TIMESPEC_HZ;\n<line14>ns %= TIMESPEC_HZ;\n<line15>if (ns < 0)\n<line16>{\n<line17>s--;\n<line18>ns += TIMESPEC_HZ;\n<line19>}\n<line20>return make_timespec (s, ns);\n<line21>}\n<line22>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/exclude.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
/home/huihui/Downloads/coreutils-9.4/lib/exclude.c:60:20: warning: '_Static_assert' with no message is a C2x extension [-Wc2x-extensions]
               == 0);
                   ^
                   , ""
2 warnings generated.
Function: exclude_add_pattern_buffer
Content: <line0>void\n<line1>exclude_add_pattern_buffer (struct exclude *ex, char *buf)\n<line2>{\n<line3>struct pattern_buffer *pbuf = xmalloc (sizeof *pbuf);\n<line4>pbuf->base = buf;\n<line5>pbuf->next = ex->patbuf;\n<line6>ex->patbuf = pbuf;\n<line7>}
----------------------------------------
Function: unescape_pattern
Content: <line0>static void\n<line1>unescape_pattern (char *str)\n<line2>{\n<line3>char const *q = str;\n<line4>do\n<line5>q += *q == '\\' && q[1];\n<line6>while ((*str++ = *q++));\n<line7>}
----------------------------------------
Function: new_exclude
Content: <line0>struct exclude *\n<line1>new_exclude (void)\n<line2>{\n<line3>return xzalloc (sizeof *new_exclude ());\n<line4>}
----------------------------------------
Function: string_hasher
Content: <line0>static size_t\n<line1>string_hasher (void const *data, size_t n_buckets)\n<line2>{\n<line3>return hash_string (data, n_buckets);\n<line4>}
----------------------------------------
Function: string_hasher_ci
Content: <line0>static size_t\n<line1>string_hasher_ci (void const *data, size_t n_buckets)\n<line2>{\n<line3>char const *p = data;\n<line4>size_t value = 0;\n<line5>mbui_iterator_t iter;\n<line6>for (mbui_init (iter, p); mbui_avail (iter); mbui_advance (iter))\n<line7>{\n<line8>mbchar_t m = mbui_cur (iter);\n<line9>char32_t wc;\n<line10>if (m.wc_valid)\n<line11>wc = c32tolower (m.wc);\n<line12>else\n<line13>wc = *m.ptr;\n<line14>value = value * 31 + wc;\n<line15>}\n<line16>return value % n_buckets;\n<line17>}
----------------------------------------
Function: string_compare
Content: <line0>static bool\n<line1>string_compare (void const *data1, void const *data2)\n<line2>{\n<line3>return strcmp (data1, data2) == 0;\n<line4>}
----------------------------------------
Function: string_compare_ci
Content: <line0>static bool\n<line1>string_compare_ci (void const *data1, void const *data2)\n<line2>{\n<line3>return mbscasecmp (data1, data2) == 0;\n<line4>}
----------------------------------------
Function: new_exclude_segment
Content: <line0>static void\n<line1>new_exclude_segment (struct exclude *ex, enum exclude_type type, int options)\n<line2>{\n<line3>struct exclude_segment *sp = xmalloc (sizeof (struct exclude_segment));\n<line4>sp->type = type;\n<line5>sp->options = options;\n<line6>switch (type)\n<line7>{\n<line8>case exclude_pattern:\n<line9>sp->v.pat = (struct exclude_pattern) {0};\n<line10>break;\n<line11>case exclude_hash:\n<line12>sp->v.table = hash_initialize (0, nullptr,\n<line13>(options & FNM_CASEFOLD\n<line14>? string_hasher_ci\n<line15>: string_hasher),\n<line16>(options & FNM_CASEFOLD\n<line17>? string_compare_ci\n<line18>: string_compare),\n<line19>free);\n<line20>break;\n<line21>}\n<line22>sp->next = ex->head;\n<line23>ex->head = sp;\n<line24>}
----------------------------------------
Function: free_exclude_segment
Content: <line0>static void\n<line1>free_exclude_segment (struct exclude_segment *seg)\n<line2>{\n<line3>switch (seg->type)\n<line4>{\n<line5>case exclude_pattern:\n<line6>for (idx_t i = 0; i < seg->v.pat.exclude_count; i++)\n<line7>if (seg->v.pat.exclude[i].options & EXCLUDE_REGEX)\n<line8>regfree (&seg->v.pat.exclude[i].v.re);\n<line9>free (seg->v.pat.exclude);\n<line10>break;\n<line11>case exclude_hash:\n<line12>hash_free (seg->v.table);\n<line13>break;\n<line14>}\n<line15>free (seg);\n<line16>}
----------------------------------------
Function: free_exclude
Content: <line0>void\n<line1>free_exclude (struct exclude *ex)\n<line2>{\n<line3>for (struct exclude_segment *seg = ex->head; seg; )\n<line4>{\n<line5>struct exclude_segment *next = seg->next;\n<line6>free_exclude_segment (seg);\n<line7>seg = next;\n<line8>}\n<line9>for (struct pattern_buffer *pbuf = ex->patbuf; pbuf; )\n<line10>{\n<line11>struct pattern_buffer *next = pbuf->next;\n<line12>free (pbuf->base);\n<line13>free (pbuf);\n<line14>pbuf = next;\n<line15>}\n<line16>free (ex);\n<line17>}
----------------------------------------
Function: fnmatch_no_wildcards
Content: <line0>static int\n<line1>fnmatch_no_wildcards (char const *pattern, char const *f, int options)\n<line2>{\n<line3>if (! (options & FNM_LEADING_DIR))\n<line4>return ((options & FNM_CASEFOLD)\n<line5>? mbscasecmp (pattern, f)\n<line6>: strcmp (pattern, f));\n<line7>else if (! (options & FNM_CASEFOLD))\n<line8>{\n<line9>idx_t patlen = strlen (pattern);\n<line10>int r = strncmp (pattern, f, patlen);\n<line11>if (! r)\n<line12>{\n<line13>r = f[patlen];\n<line14>if (r == '/')\n<line15>r = 0;\n<line16>}\n<line17>return r;\n<line18>}\n<line19>else\n<line20>{\n<line21>/* Walk through a copy of F, seeing whether P matches any prefix\n<line22>of F.\n<line23>FIXME: This is an O(N**2) algorithm; it should be O(N).\n<line24>Also, the copy should not be necessary.  However, fixing this\n<line25>will probably involve a change to the mbs* API.  */\n<line26>char *fcopy = xstrdup (f);\n<line27>int r;\n<line28>for (char *p = fcopy; ; *p++ = '/')\n<line29>{\n<line30>p = strchr (p, '/');\n<line31>if (p)\n<line32>*p = '\0';\n<line33>r = mbscasecmp (pattern, fcopy);\n<line34>if (!p || r <= 0)\n<line35>break;\n<line36>}\n<line37>free (fcopy);\n<line38>return r;\n<line39>}\n<line40>}
----------------------------------------
Function: exclude_patopts
Content: <line0>static bool\n<line1>exclude_patopts (struct patopts const *opts, char const *f)\n<line2>{\n<line3>int options = opts->options;\n<line4>return (options & EXCLUDE_REGEX\n<line5>? regexec (&opts->v.re, f, 0, nullptr, 0) == 0\n<line6>: exclude_fnmatch (opts->v.pattern, f, options));\n<line7>}
----------------------------------------
Function: file_pattern_matches
Content: <line0>static bool\n<line1>file_pattern_matches (struct exclude_segment const *seg, char const *f)\n<line2>{\n<line3>idx_t exclude_count = seg->v.pat.exclude_count;\n<line4>struct patopts const *exclude = seg->v.pat.exclude;\n<line5>for (idx_t i = 0; i < exclude_count; i++)\n<line6>if (exclude_patopts (exclude + i, f))\n<line7>return true;\n<line8>return false;\n<line9>}
----------------------------------------
Function: file_name_matches
Content: <line0>static bool\n<line1>file_name_matches (struct exclude_segment const *seg, char const *f,\n<line2>char *buffer)\n<line3>{\n<line4>int options = seg->options;\n<line5>Hash_table *table = seg->v.table;\n<line6>do\n<line7>{\n<line8>/* initialize the pattern */\n<line9>strcpy (buffer, f);\n<line10>while (true)\n<line11>{\n<line12>if (hash_lookup (table, buffer))\n<line13>return true;\n<line14>if (options & FNM_LEADING_DIR)\n<line15>{\n<line16>char *p = strrchr (buffer, '/');\n<line17>if (p)\n<line18>{\n<line19>*p = '\0';\n<line20>continue;\n<line21>}\n<line22>}\n<line23>break;\n<line24>}\n<line25>if (!(options & EXCLUDE_ANCHORED))\n<line26>{\n<line27>f = strchr (f, '/');\n<line28>if (f)\n<line29>f++;\n<line30>}\n<line31>else\n<line32>break;\n<line33>}\n<line34>while (f);\n<line35>return false;\n<line36>}
----------------------------------------
Function: add_exclude
Content: <line0>void\n<line1>add_exclude (struct exclude *ex, char const *pattern, int options)\n<line2>{\n<line3>if ((options & (EXCLUDE_REGEX|EXCLUDE_WILDCARDS))\n<line4>&& fnmatch_pattern_has_wildcards (pattern, options))\n<line5>{\n<line6>if (! (ex->head && ex->head->type == exclude_pattern\n<line7>&& ((ex->head->options & EXCLUDE_INCLUDE)\n<line8>== (options & EXCLUDE_INCLUDE))))\n<line9>new_exclude_segment (ex, exclude_pattern, options);\n<line10>struct exclude_pattern *pat = &ex->head->v.pat;\n<line11>if (pat->exclude_count == pat->exclude_alloc)\n<line12>pat->exclude = xpalloc (pat->exclude, &pat->exclude_alloc, 1, -1,\n<line13>sizeof *pat->exclude);\n<line14>struct patopts *patopts = &pat->exclude[pat->exclude_count++];\n<line15>patopts->options = options;\n<line16>if (options & EXCLUDE_REGEX)\n<line17>{\n<line18>int rc;\n<line19>int cflags = (REG_NOSUB | REG_EXTENDED\n<line20>| (options & FNM_CASEFOLD ? REG_ICASE : 0));\n<line21>if (! (options & FNM_LEADING_DIR))\n<line22>rc = regcomp (&patopts->v.re, pattern, cflags);\n<line23>else\n<line24>for (idx_t len = strlen (pattern); ; len--)\n<line25>{\n<line26>if (len == 0)\n<line27>{\n<line28>rc = 1;\n<line29>break;\n<line30>}\n<line31>if (!ISSLASH (pattern[len - 1]))\n<line32>{\n<line33>static char const patsuffix[] = "(/.*)?";\n<line34>char *tmp = ximalloc (len + sizeof patsuffix);\n<line35>memcpy (tmp, pattern, len);\n<line36>strcpy (tmp + len, patsuffix);\n<line37>rc = regcomp (&patopts->v.re, tmp, cflags);\n<line38>free (tmp);\n<line39>break;\n<line40>}\n<line41>}\n<line42>if (rc)\n<line43>{\n<line44>pat->exclude_count--;\n<line45>return;\n<line46>}\n<line47>}\n<line48>else\n<line49>{\n<line50>if (options & EXCLUDE_ALLOC)\n<line51>{\n<line52>char *dup = xstrdup (pattern);\n<line53>pattern = dup;\n<line54>exclude_add_pattern_buffer (ex, dup);\n<line55>}\n<line56>patopts->v.pattern = pattern;\n<line57>}\n<line58>}\n<line59>else\n<line60>{\n<line61>int exclude_hash_flags = (EXCLUDE_INCLUDE | EXCLUDE_ANCHORED\n<line62>| FNM_LEADING_DIR | FNM_CASEFOLD);\n<line63>if (! (ex->head && ex->head->type == exclude_hash\n<line64>&& ((ex->head->options & exclude_hash_flags)\n<line65>== (options & exclude_hash_flags))))\n<line66>new_exclude_segment (ex, exclude_hash, options);\n<line67>char *str = xstrdup (pattern);\n<line68>if ((options & (EXCLUDE_WILDCARDS | FNM_NOESCAPE)) == EXCLUDE_WILDCARDS)\n<line69>unescape_pattern (str);\n<line70>if (hash_insert (ex->head->v.table, str) != str)\n<line71>free (str);\n<line72>}\n<line73>}
----------------------------------------
Function: add_exclude_fp
Content: <line0>int\n<line1>add_exclude_fp (void (*add_func) (struct exclude *, char const *, int, void *),\n<line2>struct exclude *ex, FILE *fp, int options,\n<line3>char line_end, void *data)\n<line4>{\n<line5>char *buf = nullptr;\n<line6>idx_t buf_alloc = 0;\n<line7>idx_t buf_count = 0;\n<line8>for (int c; (c = getc (fp)) != EOF; )\n<line9>{\n<line10>if (buf_count == buf_alloc)\n<line11>buf = xpalloc (buf, &buf_alloc, 1, -1, 1);\n<line12>buf[buf_count++] = c;\n<line13>}\n<line14>int e = ferror (fp) ? errno : 0;\n<line15>buf = xirealloc (buf, buf_count + 1);\n<line16>buf[buf_count] = line_end;\n<line17>char const *lim = (buf + buf_count\n<line18>+ ! (buf_count == 0 || buf[buf_count - 1] == line_end));\n<line19>exclude_add_pattern_buffer (ex, buf);\n<line20>char *pattern = buf;\n<line21>for (char *p = buf; p < lim; p++)\n<line22>if (*p == line_end)\n<line23>{\n<line24>char *pattern_end = p;\n<line25>if (isspace ((unsigned char) line_end))\n<line26>{\n<line27>/* Assume that no multi-byte character has a trailing byte\n<line28>that satisfies isspace, and that nobody cares about\n<line29>trailing white space containing non-single-byte characters.\n<line30>If either assumption turns out to be false, presumably\n<line31>the code should be changed to scan forward through the\n<line32>entire pattern, one multi-byte character at a time.  */\n<line33>for (; ; pattern_end--)\n<line34>if (pattern_end == pattern)\n<line35>goto next_pattern;\n<line36>else if (! isspace ((unsigned char) pattern_end[-1]))\n<line37>break;\n<line38>}\n<line39>*pattern_end = '\0';\n<line40>add_func (ex, pattern, options, data);\n<line41>next_pattern:\n<line42>pattern = p + 1;\n<line43>}\n<line44>errno = e;\n<line45>return e ? -1 : 0;\n<line46>}
----------------------------------------
Function: call_addfn
Content: <line0>static void\n<line1>call_addfn (struct exclude *ex, char const *pattern, int options, void *data)\n<line2>{\n<line3>void (**addfnptr) (struct exclude *, char const *, int) = data;\n<line4>(*addfnptr) (ex, pattern, options);\n<line5>}
----------------------------------------
Function: add_exclude_file
Content: <line0>int\n<line1>add_exclude_file (void (*add_func) (struct exclude *, char const *, int),\n<line2>struct exclude *ex, char const *file_name, int options,\n<line3>char line_end)\n<line4>{\n<line5>if (strcmp (file_name, "-") == 0)\n<line6>return add_exclude_fp (call_addfn, ex, stdin, options, line_end, &add_func);\n<line7>FILE *in = fopen (file_name, "re");\n<line8>if (!in)\n<line9>return -1;\n<line10>int rc = add_exclude_fp (call_addfn, ex, in, options, line_end, &add_func);\n<line11>int e = errno;\n<line12>if (fclose (in) < 0)\n<line13>return -1;\n<line14>errno = e;\n<line15>return rc;\n<line16>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/exitfail.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
========================================
/home/huihui/Downloads/coreutils-9.4/lib/fadvise.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
Function: fdadvise
Content: <line0>void\n<line1>fdadvise (int fd, off_t offset, off_t len, fadvice_t advice)\n<line2>{\n<line3>#if HAVE_POSIX_FADVISE\n<line4>ignore_value (posix_fadvise (fd, offset, len, advice));\n<line5>#endif\n<line6>}
----------------------------------------
Function: fadvise
Content: <line0>void\n<line1>fadvise (FILE *fp, fadvice_t advice)\n<line2>{\n<line3>if (fp)\n<line4>fdadvise (fileno (fp), 0, 0, advice);\n<line5>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/fclose.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
Function: rpl_fclose
Content: <line0>int\n<line1>rpl_fclose (FILE *fp)\n<line2>{\n<line3>int saved_errno = 0;\n<line4>int fd;\n<line5>int result = 0;\n<line6>/* Don't change behavior on memstreams.  */\n<line7>fd = fileno (fp);\n<line8>if (fd < 0)\n<line9>return fclose_nothrow (fp);\n<line10>/* We only need to flush the file if it is not reading or if it is\n<line11>seekable.  This only guarantees the file position of input files\n<line12>if the fflush module is also in use.  */\n<line13>if ((!freading (fp) || lseek (fileno (fp), 0, SEEK_CUR) != -1)\n<line14>&& fflush (fp))\n<line15>saved_errno = errno;\n<line16>/* fclose() calls close(), but we need to also invoke all hooks that our\n<line17>overridden close() function invokes.  See lib/close.c.  */\n<line18>#if WINDOWS_SOCKETS\n<line19>/* Call the overridden close(), then the original fclose().\n<line20>Note about multithread-safety: There is a race condition where some\n<line21>other thread could open fd between our close and fclose.  */\n<line22>if (close (fd) < 0 && saved_errno == 0)\n<line23>saved_errno = errno;\n<line24>fclose_nothrow (fp); /* will fail with errno = EBADF,\n<line25>if we did not lose a race */\n<line26>#else /* !WINDOWS_SOCKETS */\n<line27>/* Call fclose() and invoke all hooks of the overridden close().  */\n<line28># if REPLACE_FCHDIR\n<line29>/* Note about multithread-safety: There is a race condition here as well.\n<line30>Some other thread could open fd between our calls to fclose and\n<line31>_gl_unregister_fd.  */\n<line32>result = fclose_nothrow (fp);\n<line33>if (result == 0)\n<line34>_gl_unregister_fd (fd);\n<line35># else\n<line36>/* No race condition here.  */\n<line37>result = fclose_nothrow (fp);\n<line38># endif\n<line39>#endif /* !WINDOWS_SOCKETS */\n<line40>if (saved_errno != 0)\n<line41>{\n<line42>errno = saved_errno;\n<line43>result = EOF;\n<line44>}\n<line45>return result;\n<line46>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/fcntl.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
Function: rpl_fcntl
Content: <line0>int\n<line1>fcntl (int fd, int action, /* arg */...)\n<line2>#undef fcntl\n<line3>#ifdef __KLIBC__\n<line4># define fcntl klibc_fcntl\n<line5>#endif\n<line6>{\n<line7>va_list arg;\n<line8>int result = -1;\n<line9>va_start (arg, action);\n<line10>switch (action)\n<line11>{\n<line12>case F_DUPFD:\n<line13>{\n<line14>int target = va_arg (arg, int);\n<line15>result = rpl_fcntl_DUPFD (fd, target);\n<line16>break;\n<line17>}\n<line18>case F_DUPFD_CLOEXEC:\n<line19>{\n<line20>int target = va_arg (arg, int);\n<line21>result = rpl_fcntl_DUPFD_CLOEXEC (fd, target);\n<line22>break;\n<line23>}\n<line24>#if !HAVE_FCNTL\n<line25>case F_GETFD:\n<line26>{\n<line27># if defined _WIN32 && ! defined __CYGWIN__\n<line28>HANDLE handle = (HANDLE) _get_osfhandle (fd);\n<line29>DWORD flags;\n<line30>if (handle == INVALID_HANDLE_VALUE\n<line31>|| GetHandleInformation (handle, &flags) == 0)\n<line32>errno = EBADF;\n<line33>else\n<line34>result = (flags & HANDLE_FLAG_INHERIT) ? 0 : FD_CLOEXEC;\n<line35># else /* !W32 */\n<line36>/* Use dup2 to reject invalid file descriptors.  No way to\n<line37>access this information, so punt.  */\n<line38>if (0 <= dup2 (fd, fd))\n<line39>result = 0;\n<line40># endif /* !W32 */\n<line41>break;\n<line42>} /* F_GETFD */\n<line43>#endif /* !HAVE_FCNTL */\n<line44>/* Implementing F_SETFD on mingw is not trivial - there is no\n<line45>API for changing the O_NOINHERIT bit on an fd, and merely\n<line46>changing the HANDLE_FLAG_INHERIT bit on the underlying handle\n<line47>can lead to odd state.  It may be possible by duplicating the\n<line48>handle, using _open_osfhandle with the right flags, then\n<line49>using dup2 to move the duplicate onto the original, but that\n<line50>is not supported for now.  */\n<line51>default:\n<line52>{\n<line53>#if HAVE_FCNTL\n<line54>switch (action)\n<line55>{\n<line56>#ifdef F_BARRIERFSYNC                  /* macOS */\n<line57>case F_BARRIERFSYNC:\n<line58>#endif\n<line59>#ifdef F_CHKCLEAN                      /* macOS */\n<line60>case F_CHKCLEAN:\n<line61>#endif\n<line62>#ifdef F_CLOSEM                        /* NetBSD, HP-UX */\n<line63>case F_CLOSEM:\n<line64>#endif\n<line65>#ifdef F_FLUSH_DATA                    /* macOS */\n<line66>case F_FLUSH_DATA:\n<line67>#endif\n<line68>#ifdef F_FREEZE_FS                     /* macOS */\n<line69>case F_FREEZE_FS:\n<line70>#endif\n<line71>#ifdef F_FULLFSYNC                     /* macOS */\n<line72>case F_FULLFSYNC:\n<line73>#endif\n<line74>#ifdef F_GETCONFINED                   /* macOS */\n<line75>case F_GETCONFINED:\n<line76>#endif\n<line77>#ifdef F_GETDEFAULTPROTLEVEL           /* macOS */\n<line78>case F_GETDEFAULTPROTLEVEL:\n<line79>#endif\n<line80>#ifdef F_GETFD                         /* POSIX */\n<line81>case F_GETFD:\n<line82>#endif\n<line83>#ifdef F_GETFL                         /* POSIX */\n<line84>case F_GETFL:\n<line85>#endif\n<line86>#ifdef F_GETLEASE                      /* Linux */\n<line87>case F_GETLEASE:\n<line88>#endif\n<line89>#ifdef F_GETNOSIGPIPE                  /* macOS */\n<line90>case F_GETNOSIGPIPE:\n<line91>#endif\n<line92>#ifdef F_GETOWN                        /* POSIX */\n<line93>case F_GETOWN:\n<line94>#endif\n<line95>#ifdef F_GETPIPE_SZ                    /* Linux */\n<line96>case F_GETPIPE_SZ:\n<line97>#endif\n<line98>#ifdef F_GETPROTECTIONCLASS            /* macOS */\n<line99>case F_GETPROTECTIONCLASS:\n<line100>#endif\n<line101>#ifdef F_GETPROTECTIONLEVEL            /* macOS */\n<line102>case F_GETPROTECTIONLEVEL:\n<line103>#endif\n<line104>#ifdef F_GET_SEALS                     /* Linux */\n<line105>case F_GET_SEALS:\n<line106>#endif\n<line107>#ifdef F_GETSIG                        /* Linux */\n<line108>case F_GETSIG:\n<line109>#endif\n<line110>#ifdef F_MAXFD                         /* NetBSD */\n<line111>case F_MAXFD:\n<line112>#endif\n<line113>#ifdef F_RECYCLE                       /* macOS */\n<line114>case F_RECYCLE:\n<line115>#endif\n<line116>#ifdef F_SETFIFOENH                    /* HP-UX */\n<line117>case F_SETFIFOENH:\n<line118>#endif\n<line119>#ifdef F_THAW_FS                       /* macOS */\n<line120>case F_THAW_FS:\n<line121>#endif\n<line122>/* These actions take no argument.  */\n<line123>result = fcntl (fd, action);\n<line124>break;\n<line125>#ifdef F_ADD_SEALS                     /* Linux */\n<line126>case F_ADD_SEALS:\n<line127>#endif\n<line128>#ifdef F_BADFD                         /* Solaris */\n<line129>case F_BADFD:\n<line130>#endif\n<line131>#ifdef F_CHECK_OPENEVT                 /* macOS */\n<line132>case F_CHECK_OPENEVT:\n<line133>#endif\n<line134>#ifdef F_DUP2FD                        /* FreeBSD, AIX, Solaris */\n<line135>case F_DUP2FD:\n<line136>#endif\n<line137>#ifdef F_DUP2FD_CLOEXEC                /* FreeBSD, Solaris */\n<line138>case F_DUP2FD_CLOEXEC:\n<line139>#endif\n<line140>#ifdef F_DUP2FD_CLOFORK                /* Solaris */\n<line141>case F_DUP2FD_CLOFORK:\n<line142>#endif\n<line143>#ifdef F_DUPFD                         /* POSIX */\n<line144>case F_DUPFD:\n<line145>#endif\n<line146>#ifdef F_DUPFD_CLOEXEC                 /* POSIX */\n<line147>case F_DUPFD_CLOEXEC:\n<line148>#endif\n<line149>#ifdef F_DUPFD_CLOFORK                 /* Solaris */\n<line150>case F_DUPFD_CLOFORK:\n<line151>#endif\n<line152>#ifdef F_GETXFL                        /* Solaris */\n<line153>case F_GETXFL:\n<line154>#endif\n<line155>#ifdef F_GLOBAL_NOCACHE                /* macOS */\n<line156>case F_GLOBAL_NOCACHE:\n<line157>#endif\n<line158>#ifdef F_MAKECOMPRESSED                /* macOS */\n<line159>case F_MAKECOMPRESSED:\n<line160>#endif\n<line161>#ifdef F_MOVEDATAEXTENTS               /* macOS */\n<line162>case F_MOVEDATAEXTENTS:\n<line163>#endif\n<line164>#ifdef F_NOCACHE                       /* macOS */\n<line165>case F_NOCACHE:\n<line166>#endif\n<line167>#ifdef F_NODIRECT                      /* macOS */\n<line168>case F_NODIRECT:\n<line169>#endif\n<line170>#ifdef F_NOTIFY                        /* Linux */\n<line171>case F_NOTIFY:\n<line172>#endif\n<line173>#ifdef F_OPLKACK                       /* IRIX */\n<line174>case F_OPLKACK:\n<line175>#endif\n<line176>#ifdef F_OPLKREG                       /* IRIX */\n<line177>case F_OPLKREG:\n<line178>#endif\n<line179>#ifdef F_RDAHEAD                       /* macOS */\n<line180>case F_RDAHEAD:\n<line181>#endif\n<line182>#ifdef F_SETBACKINGSTORE               /* macOS */\n<line183>case F_SETBACKINGSTORE:\n<line184>#endif\n<line185>#ifdef F_SETCONFINED                   /* macOS */\n<line186>case F_SETCONFINED:\n<line187>#endif\n<line188>#ifdef F_SETFD                         /* POSIX */\n<line189>case F_SETFD:\n<line190>#endif\n<line191>#ifdef F_SETFL                         /* POSIX */\n<line192>case F_SETFL:\n<line193>#endif\n<line194>#ifdef F_SETLEASE                      /* Linux */\n<line195>case F_SETLEASE:\n<line196>#endif\n<line197>#ifdef F_SETNOSIGPIPE                  /* macOS */\n<line198>case F_SETNOSIGPIPE:\n<line199>#endif\n<line200>#ifdef F_SETOWN                        /* POSIX */\n<line201>case F_SETOWN:\n<line202>#endif\n<line203>#ifdef F_SETPIPE_SZ                    /* Linux */\n<line204>case F_SETPIPE_SZ:\n<line205>#endif\n<line206>#ifdef F_SETPROTECTIONCLASS            /* macOS */\n<line207>case F_SETPROTECTIONCLASS:\n<line208>#endif\n<line209>#ifdef F_SETSIG                        /* Linux */\n<line210>case F_SETSIG:\n<line211>#endif\n<line212>#ifdef F_SINGLE_WRITER                 /* macOS */\n<line213>case F_SINGLE_WRITER:\n<line214>#endif\n<line215>/* These actions take an 'int' argument.  */\n<line216>{\n<line217>int x = va_arg (arg, int);\n<line218>result = fcntl (fd, action, x);\n<line219>}\n<line220>break;\n<line221>default:\n<line222>/* Other actions take a pointer argument.  */\n<line223>{\n<line224>void *p = va_arg (arg, void *);\n<line225>result = fcntl (fd, action, p);\n<line226>}\n<line227>break;\n<line228>}\n<line229>#else\n<line230>errno = EINVAL;\n<line231>#endif\n<line232>break;\n<line233>}\n<line234>}\n<line235>va_end (arg);\n<line236>return result;\n<line237>}
----------------------------------------
Function: rpl_fcntl_DUPFD
Content: <line0>static int\n<line1>rpl_fcntl_DUPFD (int fd, int target)\n<line2>{\n<line3>int result;\n<line4>#if !HAVE_FCNTL\n<line5>result = dupfd (fd, target, 0);\n<line6>#elif FCNTL_DUPFD_BUGGY || REPLACE_FCHDIR\n<line7>/* Detect invalid target; needed for cygwin 1.5.x.  */\n<line8>if (target < 0 || getdtablesize () <= target)\n<line9>{\n<line10>result = -1;\n<line11>errno = EINVAL;\n<line12>}\n<line13>else\n<line14>{\n<line15>/* Haiku alpha 2 loses fd flags on original.  */\n<line16>int flags = fcntl (fd, F_GETFD);\n<line17>if (flags < 0)\n<line18>result = -1;\n<line19>else\n<line20>{\n<line21>result = fcntl (fd, F_DUPFD, target);\n<line22>if (0 <= result && fcntl (fd, F_SETFD, flags) == -1)\n<line23>{\n<line24>int saved_errno = errno;\n<line25>close (result);\n<line26>result = -1;\n<line27>errno = saved_errno;\n<line28>}\n<line29># if REPLACE_FCHDIR\n<line30>if (0 <= result)\n<line31>result = _gl_register_dup (fd, result);\n<line32># endif\n<line33>}\n<line34>}\n<line35>#else\n<line36>result = fcntl (fd, F_DUPFD, target);\n<line37>#endif\n<line38>return result;\n<line39>}
----------------------------------------
Function: rpl_fcntl_DUPFD_CLOEXEC
Content: <line0>static int\n<line1>rpl_fcntl_DUPFD_CLOEXEC (int fd, int target)\n<line2>{\n<line3>int result;\n<line4>#if !HAVE_FCNTL\n<line5>result = dupfd (fd, target, O_CLOEXEC);\n<line6>#else /* HAVE_FCNTL */\n<line7># if defined __NetBSD__ || defined __HAIKU__\n<line8>/* On NetBSD 9.0, the system fcntl (fd, F_DUPFD_CLOEXEC, target)\n<line9>has only the same effect as fcntl (fd, F_DUPFD, target).  */\n<line10>/* On Haiku, the system fcntl (fd, F_DUPFD_CLOEXEC, target) sets\n<line11>the FD_CLOEXEC flag on fd, not on target.  Therefore avoid the\n<line12>system fcntl in this case.  */\n<line13>#  define have_dupfd_cloexec -1\n<line14># else\n<line15>/* Try the system call first, if the headers claim it exists\n<line16>(that is, if GNULIB_defined_F_DUPFD_CLOEXEC is 0), since we\n<line17>may be running with a glibc that has the macro but with an\n<line18>older kernel that does not support it.  Cache the\n<line19>information on whether the system call really works, but\n<line20>avoid caching failure if the corresponding F_DUPFD fails\n<line21>for any reason.  0 = unknown, 1 = yes, -1 = no.  */\n<line22>static int have_dupfd_cloexec = GNULIB_defined_F_DUPFD_CLOEXEC ? -1 : 0;\n<line23>if (0 <= have_dupfd_cloexec)\n<line24>{\n<line25>result = fcntl (fd, F_DUPFD_CLOEXEC, target);\n<line26>if (0 <= result || errno != EINVAL)\n<line27>{\n<line28>have_dupfd_cloexec = 1;\n<line29>#  if REPLACE_FCHDIR\n<line30>if (0 <= result)\n<line31>result = _gl_register_dup (fd, result);\n<line32>#  endif\n<line33>}\n<line34>else\n<line35>{\n<line36>result = rpl_fcntl_DUPFD (fd, target);\n<line37>if (result >= 0)\n<line38>have_dupfd_cloexec = -1;\n<line39>}\n<line40>}\n<line41>else\n<line42># endif\n<line43>result = rpl_fcntl_DUPFD (fd, target);\n<line44>if (0 <= result && have_dupfd_cloexec == -1)\n<line45>{\n<line46>int flags = fcntl (result, F_GETFD);\n<line47>if (flags < 0 || fcntl (result, F_SETFD, flags | FD_CLOEXEC) == -1)\n<line48>{\n<line49>int saved_errno = errno;\n<line50>close (result);\n<line51>errno = saved_errno;\n<line52>result = -1;\n<line53>}\n<line54>}\n<line55>#endif /* HAVE_FCNTL */\n<line56>return result;\n<line57>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/creat-safer.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
Function: creat_safer
Content: <line0>int\n<line1>creat_safer (char const *file, mode_t mode)\n<line2>{\n<line3>return fd_safer (creat (file, mode));\n<line4>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/open-safer.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
Function: open_safer
Content: <line0>int\n<line1>open_safer (char const *file, int flags, ...)\n<line2>{\n<line3>mode_t mode = 0;\n<line4>if (flags & O_CREAT)\n<line5>{\n<line6>va_list ap;\n<line7>va_start (ap, flags);\n<line8>/* We have to use PROMOTED_MODE_T instead of mode_t, otherwise GCC 4\n<line9>creates crashing code when 'mode_t' is smaller than 'int'.  */\n<line10>mode = va_arg (ap, PROMOTED_MODE_T);\n<line11>va_end (ap);\n<line12>}\n<line13>return fd_safer (open (file, flags, mode));\n<line14>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/fd-hook.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
========================================
/home/huihui/Downloads/coreutils-9.4/lib/fd-reopen.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
Function: fd_reopen
Content: <line0>int\n<line1>fd_reopen (int desired_fd, char const *file, int flags, mode_t mode)\n<line2>{\n<line3>int fd = open (file, flags, mode);\n<line4>if (fd == desired_fd || fd < 0)\n<line5>return fd;\n<line6>else\n<line7>{\n<line8>int fd2 = dup2 (fd, desired_fd);\n<line9>int saved_errno = errno;\n<line10>close (fd);\n<line11>errno = saved_errno;\n<line12>return fd2;\n<line13>}\n<line14>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/fd-safer-flag.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
Function: fd_safer_flag
Content: <line0>int\n<line1>fd_safer_flag (int fd, int flag)\n<line2>{\n<line3>if (STDIN_FILENO <= fd && fd <= STDERR_FILENO)\n<line4>{\n<line5>int f = dup_safer_flag (fd, flag);\n<line6>int e = errno;\n<line7>close (fd);\n<line8>errno = e;\n<line9>fd = f;\n<line10>}\n<line11>return fd;\n<line12>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/dup-safer-flag.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
Function: dup_safer_flag
Content: <line0>int\n<line1>dup_safer_flag (int fd, int flag)\n<line2>{\n<line3>return fcntl (fd, (flag & O_CLOEXEC) ? F_DUPFD_CLOEXEC : F_DUPFD,\n<line4>STDERR_FILENO + 1);\n<line5>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/fdutimensat.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
Function: fdutimensat
Content: <line0>int\n<line1>fdutimensat (int fd, int dir, char const *file, struct timespec const ts[2],\n<line2>int atflag)\n<line3>{\n<line4>int result = 1;\n<line5>if (0 <= fd)\n<line6>result = futimens (fd, ts);\n<line7>if (file && (fd < 0 || (result == -1 && errno == ENOSYS)))\n<line8>result = utimensat (dir, file, ts, atflag);\n<line9>if (result == 1)\n<line10>{\n<line11>errno = EBADF;\n<line12>result = -1;\n<line13>}\n<line14>return result;\n<line15>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/fflush.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
Function: clear_ungetc_buffer_preserving_position
Content: <line0>static void\n<line1>clear_ungetc_buffer_preserving_position (FILE *fp)\n<line2>{\n<line3>if (fp->_flags & _IO_IN_BACKUP)\n<line4>/* _IO_free_backup_area is a bit complicated.  Simply call fseek.  */\n<line5>fseeko (fp, 0, SEEK_CUR);\n<line6>}
----------------------------------------
Function: rpl_fflush
Content: <line0>int\n<line1>rpl_fflush (FILE *stream)\n<line2>{\n<line3>/* When stream is NULL, POSIX and C99 only require flushing of "output\n<line4>streams and update streams in which the most recent operation was not\n<line5>input", and all implementations do this.\n<line6>When stream is "an output stream or an update stream in which the most\n<line7>recent operation was not input", POSIX and C99 requires that fflush\n<line8>writes out any buffered data, and all implementations do this.\n<line9>When stream is, however, an input stream or an update stream in\n<line10>which the most recent operation was input, C99 specifies nothing,\n<line11>and POSIX only specifies behavior if the stream is seekable.\n<line12>mingw, in particular, drops the input buffer, leaving the file\n<line13>descriptor positioned at the end of the input buffer. I.e. ftell\n<line14>(stream) is lost.  We don't want to call the implementation's\n<line15>fflush in this case.\n<line16>We test ! freading (stream) here, rather than fwriting (stream), because\n<line17>what we need to know is whether the stream holds a "read buffer", and on\n<line18>mingw this is indicated by _IOREAD, regardless of _IOWRT.  */\n<line19>if (stream == NULL || ! freading (stream))\n<line20>return fflush (stream);\n<line21>#if defined _IO_EOF_SEEN || defined _IO_ftrylockfile || __GNU_LIBRARY__ == 1\n<line22>/* GNU libc, BeOS, Haiku, Linux libc5 */\n<line23>clear_ungetc_buffer_preserving_position (stream);\n<line24>return fflush (stream);\n<line25>#else\n<line26>{\n<line27>/* What POSIX says:\n<line28>1) About the file-position indicator (-> fseeko, ftello):\n<line29>The file position indicator is incremented by fgetc() and decremented\n<line30>by ungetc():\n<line31><https://pubs.opengroup.org/onlinepubs/9699919799/functions/fgetc.html>\n<line32>"... the fgetc() function shall ... advance the associated file\n<line33>position indicator for the stream ..."\n<line34><https://pubs.opengroup.org/onlinepubs/9699919799/functions/ungetc.html>\n<line35>"The file-position indicator is decremented by each successful\n<line36>call to ungetc()..."\n<line37>2) fflush discards bytes pushed back by ungetc:\n<line38><https://pubs.opengroup.org/onlinepubs/9699919799/functions/fflush.html>\n<line39>"...any characters pushed back onto the stream by ungetc()\n<line40>or ungetwc() that have not subsequently been read from the\n<line41>stream shall be discarded..."\n<line42>This implies implicitly: fflush does not change the file position\n<line43>indicator.\n<line44>3) Effects on the file descriptor, if the file descriptor is capable of\n<line45>seeking:\n<line46><https://pubs.opengroup.org/onlinepubs/9699919799/functions/fflush.html>\n<line47>"...the file offset of the underlying open file description shall\n<line48>be set to the file position of the stream..."  */\n<line49>/* POSIX does not specify fflush behavior for non-seekable input\n<line50>streams.  Some implementations purge unread data, some return\n<line51>EBADF, some do nothing.  */\n<line52>off_t pos = ftello (stream);\n<line53>if (pos == -1)\n<line54>{\n<line55>errno = EBADF;\n<line56>return EOF;\n<line57>}\n<line58>/* Clear the ungetc buffer.  */\n<line59>clear_ungetc_buffer (stream);\n<line60>/* To get here, we must be flushing a seekable input stream, so the\n<line61>semantics of fpurge are now appropriate to clear the buffer.  To\n<line62>avoid losing data, the lseek is also necessary.  */\n<line63>{\n<line64>int result = fpurge (stream);\n<line65>if (result != 0)\n<line66>return result;\n<line67>}\n<line68># if (defined __sferror || defined __DragonFly__ || defined __ANDROID__) && defined __SNPT\n<line69>/* FreeBSD, NetBSD, OpenBSD, DragonFly, Mac OS X, Cygwin, Minix 3, Android */\n<line70>{\n<line71>/* Disable seek optimization for the next fseeko call.  This tells the\n<line72>following fseeko call to seek to the desired position directly, rather\n<line73>than to seek to a block-aligned boundary.  */\n<line74>int saved_flags = disable_seek_optimization (stream);\n<line75>int result = fseeko (stream, pos, SEEK_SET);\n<line76>restore_seek_optimization (stream, saved_flags);\n<line77>return result;\n<line78>}\n<line79># else\n<line80>pos = lseek (fileno (stream), pos, SEEK_SET);\n<line81>if (pos == -1)\n<line82>return EOF;\n<line83>/* After a successful lseek, update the file descriptor's position cache\n<line84>in the stream.  */\n<line85>update_fpos_cache (stream, pos);\n<line86>return 0;\n<line87># endif\n<line88>}\n<line89>#endif\n<line90>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/file-has-acl.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
Function: file_has_acl
Content: <line0>int\n<line1>file_has_acl (char const *name, struct stat const *sb)\n<line2>{\n<line3>#if USE_ACL\n<line4>if (! S_ISLNK (sb->st_mode))\n<line5>{\n<line6># if HAVE_LINUX_XATTR_H && HAVE_LISTXATTR\n<line7>int initial_errno = errno;\n<line8>/* The max length of a trivial NFSv4 ACL is 6 words for owner,\n<line9>6 for group, 7 for everyone, all times 2 because there are\n<line10>both allow and deny ACEs.  There are 6 words for owner\n<line11>because of type, flag, mask, wholen, "OWNER@"+pad and\n<line12>similarly for group; everyone is another word to hold\n<line13>"EVERYONE@".  */\n<line14>typedef uint32_t trivial_NFSv4_xattr_buf[2 * (6 + 6 + 7)];\n<line15>/* A buffer large enough to hold any trivial NFSv4 ACL,\n<line16>and also useful as a small array of char.  */\n<line17>union {\n<line18>trivial_NFSv4_xattr_buf xattr;\n<line19>char ch[sizeof (trivial_NFSv4_xattr_buf)];\n<line20>} stackbuf;\n<line21>char *listbuf = stackbuf.ch;\n<line22>ssize_t listbufsize = sizeof stackbuf.ch;\n<line23>char *heapbuf = NULL;\n<line24>ssize_t listsize;\n<line25>/* Use listxattr first, as this means just one syscall in the\n<line26>typical case where the file lacks an ACL.  Try stackbuf\n<line27>first, falling back on malloc if stackbuf is too small.  */\n<line28>while ((listsize = listxattr (name, listbuf, listbufsize)) < 0\n<line29>&& errno == ERANGE)\n<line30>{\n<line31>free (heapbuf);\n<line32>ssize_t newsize = listxattr (name, NULL, 0);\n<line33>if (newsize <= 0)\n<line34>return newsize;\n<line35>/* Grow LISTBUFSIZE to at least NEWSIZE.  Grow it by a\n<line36>nontrivial amount too, to defend against denial of\n<line37>service by an adversary that fiddles with ACLs.  */\n<line38>bool overflow = ckd_add (&listbufsize, listbufsize, listbufsize >> 1);\n<line39>listbufsize = MAX (listbufsize, newsize);\n<line40>if (overflow || SIZE_MAX < listbufsize)\n<line41>{\n<line42>errno = ENOMEM;\n<line43>return -1;\n<line44>}\n<line45>listbuf = heapbuf = malloc (listbufsize);\n<line46>if (!listbuf)\n<line47>return -1;\n<line48>}\n<line49>/* In Fedora 39, a file can have both NFSv4 and POSIX ACLs,\n<line50>but if it has an NFSv4 ACL that's the one that matters.\n<line51>In earlier Fedora the two types of ACLs were mutually exclusive.\n<line52>Attempt to work correctly on both kinds of systems.  */\n<line53>bool nfsv4_acl\n<line54>= 0 < listsize && have_xattr (XATTR_NAME_NFSV4_ACL, listbuf, listsize);\n<line55>int ret\n<line56>= (listsize <= 0 ? listsize\n<line57>: (nfsv4_acl\n<line58>|| have_xattr (XATTR_NAME_POSIX_ACL_ACCESS, listbuf, listsize)\n<line59>|| (S_ISDIR (sb->st_mode)\n<line60>&& have_xattr (XATTR_NAME_POSIX_ACL_DEFAULT,\n<line61>listbuf, listsize))));\n<line62>free (heapbuf);\n<line63>/* If there is an NFSv4 ACL, follow up with a getxattr syscall\n<line64>to see whether the NFSv4 ACL is nontrivial.  */\n<line65>if (nfsv4_acl)\n<line66>{\n<line67>ret = getxattr (name, XATTR_NAME_NFSV4_ACL,\n<line68>stackbuf.xattr, sizeof stackbuf.xattr);\n<line69>if (ret < 0)\n<line70>switch (errno)\n<line71>{\n<line72>case ENODATA: return 0;\n<line73>case ERANGE : return 1; /* ACL must be nontrivial.  */\n<line74>}\n<line75>else\n<line76>{\n<line77>/* It looks like a trivial ACL, but investigate further.  */\n<line78>ret = acl_nfs4_nontrivial (stackbuf.xattr, ret);\n<line79>if (ret < 0)\n<line80>{\n<line81>errno = EINVAL;\n<line82>return ret;\n<line83>}\n<line84>errno = initial_errno;\n<line85>}\n<line86>}\n<line87>if (ret < 0)\n<line88>return - acl_errno_valid (errno);\n<line89>return ret;\n<line90># elif HAVE_ACL_GET_FILE\n<line91>/* POSIX 1003.1e (draft 17 -- abandoned) specific version.  */\n<line92>/* Linux, FreeBSD, Mac OS X, IRIX, Tru64, Cygwin >= 2.5 */\n<line93>int ret;\n<line94>if (HAVE_ACL_EXTENDED_FILE) /* Linux */\n<line95>{\n<line96>/* On Linux, acl_extended_file is an optimized function: It only\n<line97>makes two calls to getxattr(), one for ACL_TYPE_ACCESS, one for\n<line98>ACL_TYPE_DEFAULT.  */\n<line99>ret = acl_extended_file (name);\n<line100>}\n<line101>else /* FreeBSD, Mac OS X, IRIX, Tru64, Cygwin >= 2.5 */\n<line102>{\n<line103>#  if HAVE_ACL_TYPE_EXTENDED /* Mac OS X */\n<line104>/* On Mac OS X, acl_get_file (name, ACL_TYPE_ACCESS)\n<line105>and acl_get_file (name, ACL_TYPE_DEFAULT)\n<line106>always return NULL / EINVAL.  There is no point in making\n<line107>these two useless calls.  The real ACL is retrieved through\n<line108>acl_get_file (name, ACL_TYPE_EXTENDED).  */\n<line109>acl_t acl = acl_get_file (name, ACL_TYPE_EXTENDED);\n<line110>if (acl)\n<line111>{\n<line112>ret = acl_extended_nontrivial (acl);\n<line113>acl_free (acl);\n<line114>}\n<line115>else\n<line116>ret = -1;\n<line117>#  else /* FreeBSD, IRIX, Tru64, Cygwin >= 2.5 */\n<line118>acl_t acl = acl_get_file (name, ACL_TYPE_ACCESS);\n<line119>if (acl)\n<line120>{\n<line121>int saved_errno;\n<line122>ret = acl_access_nontrivial (acl);\n<line123>saved_errno = errno;\n<line124>acl_free (acl);\n<line125>errno = saved_errno;\n<line126>#   if HAVE_ACL_FREE_TEXT /* Tru64 */\n<line127>/* On OSF/1, acl_get_file (name, ACL_TYPE_DEFAULT) always\n<line128>returns NULL with errno not set.  There is no point in\n<line129>making this call.  */\n<line130>#   else /* FreeBSD, IRIX, Cygwin >= 2.5 */\n<line131>/* On Linux, FreeBSD, IRIX, acl_get_file (name, ACL_TYPE_ACCESS)\n<line132>and acl_get_file (name, ACL_TYPE_DEFAULT) on a directory\n<line133>either both succeed or both fail; it depends on the\n<line134>file system.  Therefore there is no point in making the second\n<line135>call if the first one already failed.  */\n<line136>if (ret == 0 && S_ISDIR (sb->st_mode))\n<line137>{\n<line138>acl = acl_get_file (name, ACL_TYPE_DEFAULT);\n<line139>if (acl)\n<line140>{\n<line141>#    ifdef __CYGWIN__ /* Cygwin >= 2.5 */\n<line142>ret = acl_access_nontrivial (acl);\n<line143>saved_errno = errno;\n<line144>acl_free (acl);\n<line145>errno = saved_errno;\n<line146>#    else\n<line147>ret = (0 < acl_entries (acl));\n<line148>acl_free (acl);\n<line149>#    endif\n<line150>}\n<line151>else\n<line152>ret = -1;\n<line153>}\n<line154>#   endif\n<line155>}\n<line156>else\n<line157>ret = -1;\n<line158>#  endif\n<line159>}\n<line160>if (ret < 0)\n<line161>return - acl_errno_valid (errno);\n<line162>return ret;\n<line163># elif HAVE_FACL && defined GETACL /* Solaris, Cygwin < 2.5, not HP-UX */\n<line164>#  if defined ACL_NO_TRIVIAL\n<line165>/* Solaris 10 (newer version), which has additional API declared in\n<line166><sys/acl.h> (acl_t) and implemented in libsec (acl_set, acl_trivial,\n<line167>acl_fromtext, ...).  */\n<line168>return acl_trivial (name);\n<line169>#  else /* Solaris, Cygwin, general case */\n<line170>/* Solaris 2.5 through Solaris 10, Cygwin, and contemporaneous versions\n<line171>of Unixware.  The acl() call returns the access and default ACL both\n<line172>at once.  */\n<line173>{\n<line174>/* Initially, try to read the entries into a stack-allocated buffer.\n<line175>Use malloc if it does not fit.  */\n<line176>enum\n<line177>{\n<line178>alloc_init = 4000 / sizeof (aclent_t), /* >= 3 */\n<line179>alloc_max = MIN (INT_MAX, SIZE_MAX / sizeof (aclent_t))\n<line180>};\n<line181>aclent_t buf[alloc_init];\n<line182>size_t alloc = alloc_init;\n<line183>aclent_t *entries = buf;\n<line184>aclent_t *malloced = NULL;\n<line185>int count;\n<line186>for (;;)\n<line187>{\n<line188>count = acl (name, GETACL, alloc, entries);\n<line189>if (count < 0 && errno == ENOSPC)\n<line190>{\n<line191>/* Increase the size of the buffer.  */\n<line192>free (malloced);\n<line193>if (alloc > alloc_max / 2)\n<line194>{\n<line195>errno = ENOMEM;\n<line196>return -1;\n<line197>}\n<line198>alloc = 2 * alloc; /* <= alloc_max */\n<line199>entries = malloced =\n<line200>(aclent_t *) malloc (alloc * sizeof (aclent_t));\n<line201>if (entries == NULL)\n<line202>{\n<line203>errno = ENOMEM;\n<line204>return -1;\n<line205>}\n<line206>continue;\n<line207>}\n<line208>break;\n<line209>}\n<line210>if (count < 0)\n<line211>{\n<line212>if (errno == ENOSYS || errno == ENOTSUP)\n<line213>;\n<line214>else\n<line215>{\n<line216>free (malloced);\n<line217>return -1;\n<line218>}\n<line219>}\n<line220>else if (count == 0)\n<line221>;\n<line222>else\n<line223>{\n<line224>/* Don't use MIN_ACL_ENTRIES:  It's set to 4 on Cygwin, but Cygwin\n<line225>returns only 3 entries for files with no ACL.  But this is safe:\n<line226>If there are more than 4 entries, there cannot be only the\n<line227>"user::", "group::", "other:", and "mask:" entries.  */\n<line228>if (count > 4)\n<line229>{\n<line230>free (malloced);\n<line231>return 1;\n<line232>}\n<line233>if (acl_nontrivial (count, entries))\n<line234>{\n<line235>free (malloced);\n<line236>return 1;\n<line237>}\n<line238>}\n<line239>free (malloced);\n<line240>}\n<line241>#   ifdef ACE_GETACL\n<line242>/* Solaris also has a different variant of ACLs, used in ZFS and NFSv4\n<line243>file systems (whereas the other ones are used in UFS file systems).  */\n<line244>{\n<line245>/* Initially, try to read the entries into a stack-allocated buffer.\n<line246>Use malloc if it does not fit.  */\n<line247>enum\n<line248>{\n<line249>alloc_init = 4000 / sizeof (ace_t), /* >= 3 */\n<line250>alloc_max = MIN (INT_MAX, SIZE_MAX / sizeof (ace_t))\n<line251>};\n<line252>ace_t buf[alloc_init];\n<line253>size_t alloc = alloc_init;\n<line254>ace_t *entries = buf;\n<line255>ace_t *malloced = NULL;\n<line256>int count;\n<line257>for (;;)\n<line258>{\n<line259>count = acl (name, ACE_GETACL, alloc, entries);\n<line260>if (count < 0 && errno == ENOSPC)\n<line261>{\n<line262>/* Increase the size of the buffer.  */\n<line263>free (malloced);\n<line264>if (alloc > alloc_max / 2)\n<line265>{\n<line266>errno = ENOMEM;\n<line267>return -1;\n<line268>}\n<line269>alloc = 2 * alloc; /* <= alloc_max */\n<line270>entries = malloced = (ace_t *) malloc (alloc * sizeof (ace_t));\n<line271>if (entries == NULL)\n<line272>{\n<line273>errno = ENOMEM;\n<line274>return -1;\n<line275>}\n<line276>continue;\n<line277>}\n<line278>break;\n<line279>}\n<line280>if (count < 0)\n<line281>{\n<line282>if (errno == ENOSYS || errno == EINVAL)\n<line283>;\n<line284>else\n<line285>{\n<line286>free (malloced);\n<line287>return -1;\n<line288>}\n<line289>}\n<line290>else if (count == 0)\n<line291>;\n<line292>else\n<line293>{\n<line294>/* In the old (original Solaris 10) convention:\n<line295>If there are more than 3 entries, there cannot be only the\n<line296>ACE_OWNER, ACE_GROUP, ACE_OTHER entries.\n<line297>In the newer Solaris 10 and Solaris 11 convention:\n<line298>If there are more than 6 entries, there cannot be only the\n<line299>ACE_OWNER, ACE_GROUP, ACE_EVERYONE entries, each once with\n<line300>NEW_ACE_ACCESS_ALLOWED_ACE_TYPE and once with\n<line301>NEW_ACE_ACCESS_DENIED_ACE_TYPE.  */\n<line302>if (count > 6)\n<line303>{\n<line304>free (malloced);\n<line305>return 1;\n<line306>}\n<line307>if (acl_ace_nontrivial (count, entries))\n<line308>{\n<line309>free (malloced);\n<line310>return 1;\n<line311>}\n<line312>}\n<line313>free (malloced);\n<line314>}\n<line315>#   endif\n<line316>return 0;\n<line317>#  endif\n<line318># elif HAVE_GETACL /* HP-UX */\n<line319>{\n<line320>struct acl_entry entries[NACLENTRIES];\n<line321>int count;\n<line322>count = getacl (name, NACLENTRIES, entries);\n<line323>if (count < 0)\n<line324>{\n<line325>/* ENOSYS is seen on newer HP-UX versions.\n<line326>EOPNOTSUPP is typically seen on NFS mounts.\n<line327>ENOTSUP was seen on Quantum StorNext file systems (cvfs).  */\n<line328>if (errno == ENOSYS || errno == EOPNOTSUPP || errno == ENOTSUP)\n<line329>;\n<line330>else\n<line331>return -1;\n<line332>}\n<line333>else if (count == 0)\n<line334>return 0;\n<line335>else /* count > 0 */\n<line336>{\n<line337>if (count > NACLENTRIES)\n<line338>/* If NACLENTRIES cannot be trusted, use dynamic memory\n<line339>allocation.  */\n<line340>abort ();\n<line341>/* If there are more than 3 entries, there cannot be only the\n<line342>(uid,%), (%,gid), (%,%) entries.  */\n<line343>if (count > 3)\n<line344>return 1;\n<line345>{\n<line346>struct stat statbuf;\n<line347>if (stat (name, &statbuf) == -1 && errno != EOVERFLOW)\n<line348>return -1;\n<line349>return acl_nontrivial (count, entries);\n<line350>}\n<line351>}\n<line352>}\n<line353>#  if HAVE_ACLV_H /* HP-UX >= 11.11 */\n<line354>{\n<line355>struct acl entries[NACLVENTRIES];\n<line356>int count;\n<line357>count = acl ((char *) name, ACL_GET, NACLVENTRIES, entries);\n<line358>if (count < 0)\n<line359>{\n<line360>/* EOPNOTSUPP is seen on NFS in HP-UX 11.11, 11.23.\n<line361>EINVAL is seen on NFS in HP-UX 11.31.  */\n<line362>if (errno == ENOSYS || errno == EOPNOTSUPP || errno == EINVAL)\n<line363>;\n<line364>else\n<line365>return -1;\n<line366>}\n<line367>else if (count == 0)\n<line368>return 0;\n<line369>else /* count > 0 */\n<line370>{\n<line371>if (count > NACLVENTRIES)\n<line372>/* If NACLVENTRIES cannot be trusted, use dynamic memory\n<line373>allocation.  */\n<line374>abort ();\n<line375>/* If there are more than 4 entries, there cannot be only the\n<line376>four base ACL entries.  */\n<line377>if (count > 4)\n<line378>return 1;\n<line379>return aclv_nontrivial (count, entries);\n<line380>}\n<line381>}\n<line382>#  endif\n<line383># elif HAVE_ACLX_GET && defined ACL_AIX_WIP /* AIX */\n<line384>acl_type_t type;\n<line385>char aclbuf[1024];\n<line386>void *acl = aclbuf;\n<line387>size_t aclsize = sizeof (aclbuf);\n<line388>mode_t mode;\n<line389>for (;;)\n<line390>{\n<line391>/* The docs say that type being 0 is equivalent to ACL_ANY, but it\n<line392>is not true, in AIX 5.3.  */\n<line393>type.u64 = ACL_ANY;\n<line394>if (aclx_get (name, 0, &type, aclbuf, &aclsize, &mode) >= 0)\n<line395>break;\n<line396>if (errno == ENOSYS)\n<line397>return 0;\n<line398>if (errno != ENOSPC)\n<line399>{\n<line400>if (acl != aclbuf)\n<line401>free (acl);\n<line402>return -1;\n<line403>}\n<line404>aclsize = 2 * aclsize;\n<line405>if (acl != aclbuf)\n<line406>free (acl);\n<line407>acl = malloc (aclsize);\n<line408>if (acl == NULL)\n<line409>{\n<line410>errno = ENOMEM;\n<line411>return -1;\n<line412>}\n<line413>}\n<line414>if (type.u64 == ACL_AIXC)\n<line415>{\n<line416>int result = acl_nontrivial ((struct acl *) acl);\n<line417>if (acl != aclbuf)\n<line418>free (acl);\n<line419>return result;\n<line420>}\n<line421>else if (type.u64 == ACL_NFS4)\n<line422>{\n<line423>int result = acl_nfs4_nontrivial ((nfs4_acl_int_t *) acl);\n<line424>if (acl != aclbuf)\n<line425>free (acl);\n<line426>return result;\n<line427>}\n<line428>else\n<line429>{\n<line430>/* A newer type of ACL has been introduced in the system.\n<line431>We should better support it.  */\n<line432>if (acl != aclbuf)\n<line433>free (acl);\n<line434>errno = EINVAL;\n<line435>return -1;\n<line436>}\n<line437># elif HAVE_STATACL /* older AIX */\n<line438>union { struct acl a; char room[4096]; } u;\n<line439>if (statacl ((char *) name, STX_NORMAL, &u.a, sizeof (u)) < 0)\n<line440>return -1;\n<line441>return acl_nontrivial (&u.a);\n<line442># elif HAVE_ACLSORT /* NonStop Kernel */\n<line443>{\n<line444>struct acl entries[NACLENTRIES];\n<line445>int count;\n<line446>count = acl ((char *) name, ACL_GET, NACLENTRIES, entries);\n<line447>if (count < 0)\n<line448>{\n<line449>if (errno == ENOSYS || errno == ENOTSUP)\n<line450>;\n<line451>else\n<line452>return -1;\n<line453>}\n<line454>else if (count == 0)\n<line455>return 0;\n<line456>else /* count > 0 */\n<line457>{\n<line458>if (count > NACLENTRIES)\n<line459>/* If NACLENTRIES cannot be trusted, use dynamic memory\n<line460>allocation.  */\n<line461>abort ();\n<line462>/* If there are more than 4 entries, there cannot be only the\n<line463>four base ACL entries.  */\n<line464>if (count > 4)\n<line465>return 1;\n<line466>return acl_nontrivial (count, entries);\n<line467>}\n<line468>}\n<line469># endif\n<line470>}\n<line471>#endif\n<line472>return 0;\n<line473>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/file-set.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
Function: record_file
Content: <line0>void\n<line1>record_file (Hash_table *ht, char const *file, struct stat const *stats)\n<line2>{\n<line3>struct F_triple *ent;\n<line4>if (ht == NULL)\n<line5>return;\n<line6>ent = xmalloc (sizeof *ent);\n<line7>ent->name = xstrdup (file);\n<line8>ent->st_ino = stats->st_ino;\n<line9>ent->st_dev = stats->st_dev;\n<line10>{\n<line11>struct F_triple *ent_from_table = hash_insert (ht, ent);\n<line12>if (ent_from_table == NULL)\n<line13>{\n<line14>/* Insertion failed due to lack of memory.  */\n<line15>xalloc_die ();\n<line16>}\n<line17>if (ent_from_table != ent)\n<line18>{\n<line19>/* There was already a matching entry in the table, so ENT was\n<line20>not inserted.  Free it.  */\n<line21>triple_free (ent);\n<line22>}\n<line23>}\n<line24>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/file-type.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
Function: file_type
Content: <line0>char const *\n<line1>file_type (struct stat const *st)\n<line2>{\n<line3>return gettext (c_file_type (st));\n<line4>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/filemode.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
Function: ftypelet
Content: <line0>static char\n<line1>ftypelet (mode_t bits)\n<line2>{\n<line3>/* These are the most common, so test for them first.  */\n<line4>if (S_ISREG (bits))\n<line5>return '-';\n<line6>if (S_ISDIR (bits))\n<line7>return 'd';\n<line8>/* Other letters standardized by POSIX 1003.1-2004.  */\n<line9>if (S_ISBLK (bits))\n<line10>return 'b';\n<line11>if (S_ISCHR (bits))\n<line12>return 'c';\n<line13>if (S_ISLNK (bits))\n<line14>return 'l';\n<line15>if (S_ISFIFO (bits))\n<line16>return 'p';\n<line17>/* Other file types (though not letters) standardized by POSIX.  */\n<line18>if (S_ISSOCK (bits))\n<line19>return 's';\n<line20>/* Nonstandard file types.  */\n<line21>if (S_ISCTG (bits))\n<line22>return 'C';\n<line23>if (S_ISDOOR (bits))\n<line24>return 'D';\n<line25>if (S_ISMPB (bits) || S_ISMPC (bits) || S_ISMPX (bits))\n<line26>return 'm';\n<line27>if (S_ISNWK (bits))\n<line28>return 'n';\n<line29>if (S_ISPORT (bits))\n<line30>return 'P';\n<line31>if (S_ISWHT (bits))\n<line32>return 'w';\n<line33>return '?';\n<line34>}
----------------------------------------
Function: strmode
Content: <line0>void\n<line1>strmode (mode_t mode, char *str)\n<line2>{\n<line3>str[0] = ftypelet (mode);\n<line4>str[1] = mode & S_IRUSR ? 'r' : '-';\n<line5>str[2] = mode & S_IWUSR ? 'w' : '-';\n<line6>str[3] = (mode & S_ISUID\n<line7>? (mode & S_IXUSR ? 's' : 'S')\n<line8>: (mode & S_IXUSR ? 'x' : '-'));\n<line9>str[4] = mode & S_IRGRP ? 'r' : '-';\n<line10>str[5] = mode & S_IWGRP ? 'w' : '-';\n<line11>str[6] = (mode & S_ISGID\n<line12>? (mode & S_IXGRP ? 's' : 'S')\n<line13>: (mode & S_IXGRP ? 'x' : '-'));\n<line14>str[7] = mode & S_IROTH ? 'r' : '-';\n<line15>str[8] = mode & S_IWOTH ? 'w' : '-';\n<line16>str[9] = (mode & S_ISVTX\n<line17>? (mode & S_IXOTH ? 't' : 'T')\n<line18>: (mode & S_IXOTH ? 'x' : '-'));\n<line19>str[10] = ' ';\n<line20>str[11] = '\0';\n<line21>}
----------------------------------------
Function: filemodestring
Content: <line0>void\n<line1>filemodestring (struct stat const *statp, char *str)\n<line2>{\n<line3>strmode (statp->st_mode, str);\n<line4>if (S_TYPEISSEM (statp))\n<line5>str[0] = 'F';\n<line6>else if (S_TYPEISMQ (statp))\n<line7>str[0] = 'Q';\n<line8>else if (S_TYPEISSHM (statp))\n<line9>str[0] = 'S';\n<line10>else if (S_TYPEISTMO (statp))\n<line11>str[0] = 'T';\n<line12>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/filenamecat.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
Function: file_name_concat
Content: <line0>char *\n<line1>file_name_concat (char const *dir, char const *base, char **base_in_result)\n<line2>{\n<line3>char *p = mfile_name_concat (dir, base, base_in_result);\n<line4>if (p == NULL)\n<line5>xalloc_die ();\n<line6>return p;\n<line7>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/filenamecat-lgpl.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
Function: mfile_name_concat
Content: <line0>char *\n<line1>mfile_name_concat (char const *dir, char const *base, char **base_in_result)\n<line2>{\n<line3>char const *dirbase = last_component (dir);\n<line4>size_t dirbaselen = base_len (dirbase);\n<line5>size_t dirlen = dirbase - dir + dirbaselen;\n<line6>size_t baselen = strlen (base);\n<line7>char sep = '\0';\n<line8>if (dirbaselen)\n<line9>{\n<line10>/* DIR is not a file system root, so separate with / if needed.  */\n<line11>if (! ISSLASH (dir[dirlen - 1]) && ! ISSLASH (*base))\n<line12>sep = '/';\n<line13>}\n<line14>else if (ISSLASH (*base))\n<line15>{\n<line16>/* DIR is a file system root and BASE begins with a slash, so\n<line17>separate with ".".  For example, if DIR is "/" and BASE is\n<line18>"/foo" then return "/./foo", as "//foo" would be wrong on\n<line19>some POSIX systems.  A fancier algorithm could omit "." in\n<line20>some cases but is not worth the trouble.  */\n<line21>sep = '.';\n<line22>}\n<line23>char *p_concat = malloc (dirlen + (sep != '\0')  + baselen + 1);\n<line24>if (p_concat == NULL)\n<line25>return NULL;\n<line26>{\n<line27>char *p;\n<line28>p = mempcpy (p_concat, dir, dirlen);\n<line29>*p = sep;\n<line30>p += sep != '\0';\n<line31>if (base_in_result)\n<line32>*base_in_result = p;\n<line33>p = mempcpy (p, base, baselen);\n<line34>*p = '\0';\n<line35>}\n<line36>return p_concat;\n<line37>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/filevercmp.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
/home/huihui/Downloads/coreutils-9.4/lib/filevercmp.c:76:56: warning: '_Static_assert' with no message is a C2x extension [-Wc2x-extensions]
      static_assert (UCHAR_MAX <= (INT_MAX - 1 - 2) / 2);
                                                       ^
                                                       , ""
2 warnings generated.
Function: file_prefixlen
Content: <line0>static idx_t\n<line1>file_prefixlen (char const *s, ptrdiff_t *len)\n<line2>{\n<line3>size_t n = *len;  /* SIZE_MAX if N == -1.  */\n<line4>idx_t prefixlen = 0;\n<line5>for (idx_t i = 0; ; )\n<line6>{\n<line7>if (*len < 0 ? !s[i] : i == n)\n<line8>{\n<line9>*len = i;\n<line10>return prefixlen;\n<line11>}\n<line12>i++;\n<line13>prefixlen = i;\n<line14>while (i + 1 < n && s[i] == '.' && (c_isalpha (s[i + 1])\n<line15>|| s[i + 1] == '~'))\n<line16>for (i += 2; i < n && (c_isalnum (s[i]) || s[i] == '~'); i++)\n<line17>continue;\n<line18>}\n<line19>}
----------------------------------------
Function: order
Content: <line0>static int\n<line1>order (char const *s, idx_t pos, idx_t len)\n<line2>{\n<line3>if (pos == len)\n<line4>return -1;\n<line5>unsigned char c = s[pos];\n<line6>if (c_isdigit (c))\n<line7>return 0;\n<line8>else if (c_isalpha (c))\n<line9>return c;\n<line10>else if (c == '~')\n<line11>return -2;\n<line12>else\n<line13>{\n<line14>static_assert (UCHAR_MAX <= (INT_MAX - 1 - 2) / 2);\n<line15>return c + UCHAR_MAX + 1;\n<line16>}\n<line17>}
----------------------------------------
Function: verrevcmp
Content: <line0>static int _GL_ATTRIBUTE_PURE\n<line1>verrevcmp (const char *s1, idx_t s1_len, const char *s2, idx_t s2_len)\n<line2>{\n<line3>idx_t s1_pos = 0;\n<line4>idx_t s2_pos = 0;\n<line5>while (s1_pos < s1_len || s2_pos < s2_len)\n<line6>{\n<line7>int first_diff = 0;\n<line8>while ((s1_pos < s1_len && !c_isdigit (s1[s1_pos]))\n<line9>|| (s2_pos < s2_len && !c_isdigit (s2[s2_pos])))\n<line10>{\n<line11>int s1_c = order (s1, s1_pos, s1_len);\n<line12>int s2_c = order (s2, s2_pos, s2_len);\n<line13>if (s1_c != s2_c)\n<line14>return s1_c - s2_c;\n<line15>s1_pos++;\n<line16>s2_pos++;\n<line17>}\n<line18>while (s1_pos < s1_len && s1[s1_pos] == '0')\n<line19>s1_pos++;\n<line20>while (s2_pos < s2_len && s2[s2_pos] == '0')\n<line21>s2_pos++;\n<line22>while (s1_pos < s1_len && s2_pos < s2_len\n<line23>&& c_isdigit (s1[s1_pos]) && c_isdigit (s2[s2_pos]))\n<line24>{\n<line25>if (!first_diff)\n<line26>first_diff = s1[s1_pos] - s2[s2_pos];\n<line27>s1_pos++;\n<line28>s2_pos++;\n<line29>}\n<line30>if (s1_pos < s1_len && c_isdigit (s1[s1_pos]))\n<line31>return 1;\n<line32>if (s2_pos < s2_len && c_isdigit (s2[s2_pos]))\n<line33>return -1;\n<line34>if (first_diff)\n<line35>return first_diff;\n<line36>}\n<line37>return 0;\n<line38>}
----------------------------------------
Function: filevercmp
Content: <line0>int\n<line1>filevercmp (const char *s1, const char *s2)\n<line2>{\n<line3>return filenvercmp (s1, -1, s2, -1);\n<line4>}
----------------------------------------
Function: filenvercmp
Content: <line0>int\n<line1>filenvercmp (char const *a, ptrdiff_t alen, char const *b, ptrdiff_t blen)\n<line2>{\n<line3>/* Special case for empty versions.  */\n<line4>bool aempty = alen < 0 ? !a[0] : !alen;\n<line5>bool bempty = blen < 0 ? !b[0] : !blen;\n<line6>if (aempty)\n<line7>return -!bempty;\n<line8>if (bempty)\n<line9>return 1;\n<line10>/* Special cases for leading ".": "." sorts first, then "..", then\n<line11>other names with leading ".", then other names.  */\n<line12>if (a[0] == '.')\n<line13>{\n<line14>if (b[0] != '.')\n<line15>return -1;\n<line16>bool adot = alen < 0 ? !a[1] : alen == 1;\n<line17>bool bdot = blen < 0 ? !b[1] : blen == 1;\n<line18>if (adot)\n<line19>return -!bdot;\n<line20>if (bdot)\n<line21>return 1;\n<line22>bool adotdot = a[1] == '.' && (alen < 0 ? !a[2] : alen == 2);\n<line23>bool bdotdot = b[1] == '.' && (blen < 0 ? !b[2] : blen == 2);\n<line24>if (adotdot)\n<line25>return -!bdotdot;\n<line26>if (bdotdot)\n<line27>return 1;\n<line28>}\n<line29>else if (b[0] == '.')\n<line30>return 1;\n<line31>/* Cut file suffixes.  */\n<line32>idx_t aprefixlen = file_prefixlen (a, &alen);\n<line33>idx_t bprefixlen = file_prefixlen (b, &blen);\n<line34>/* If both suffixes are empty, a second pass would return the same thing.  */\n<line35>bool one_pass_only = aprefixlen == alen && bprefixlen == blen;\n<line36>int result = verrevcmp (a, aprefixlen, b, bprefixlen);\n<line37>/* Return the initial result if nonzero, or if no second pass is needed.\n<line38>Otherwise, restore the suffixes and try again.  */\n<line39>return result || one_pass_only ? result : verrevcmp (a, alen, b, blen);\n<line40>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/fopen-safer.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
Function: fopen_safer
Content: <line0>FILE *\n<line1>fopen_safer (char const *file, char const *mode)\n<line2>{\n<line3>FILE *fp = fopen (file, mode);\n<line4>if (fp)\n<line5>{\n<line6>int fd = fileno (fp);\n<line7>if (0 <= fd && fd <= STDERR_FILENO)\n<line8>{\n<line9>int f = dup_safer (fd);\n<line10>if (f < 0)\n<line11>{\n<line12>int e = errno;\n<line13>fclose (fp);\n<line14>errno = e;\n<line15>return NULL;\n<line16>}\n<line17>if (fclose (fp) != 0\n<line18>|| ! (fp = fdopen (f, mode)))\n<line19>{\n<line20>int e = errno;\n<line21>close (f);\n<line22>errno = e;\n<line23>return NULL;\n<line24>}\n<line25>}\n<line26>}\n<line27>return fp;\n<line28>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/fprintftime.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
========================================
/home/huihui/Downloads/coreutils-9.4/lib/fpurge.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
Function: fpurge
Content: <line0>int\n<line1>fpurge (FILE *fp)\n<line2>{\n<line3>#if HAVE___FPURGE                   /* glibc >= 2.2, Haiku, Solaris >= 7, UnixWare >= 7.1.4.MP4, Cygwin >= 1.7.10, Android API >= 23, musl libc */\n<line4>__fpurge (fp);\n<line5>/* The __fpurge function does not have a return value.  */\n<line6>return 0;\n<line7>#elif HAVE_FPURGE                   /* FreeBSD, NetBSD, OpenBSD, DragonFly, Mac OS X, Cygwin >= 1.7 */\n<line8>/* Call the system's fpurge function.  */\n<line9># undef fpurge\n<line10># if !HAVE_DECL_FPURGE\n<line11>extern int fpurge (FILE *);\n<line12># endif\n<line13>int result = fpurge (fp);\n<line14># if defined __sferror || defined __DragonFly__ || defined __ANDROID__\n<line15>/* FreeBSD, NetBSD, OpenBSD, DragonFly, Mac OS X, Cygwin, Minix 3, Android */\n<line16>if (result == 0)\n<line17>/* Correct the invariants that fpurge broke.\n<line18><stdio.h> on BSD systems says:\n<line19>"The following always hold: if _flags & __SRD, _w is 0."\n<line20>If this invariant is not fulfilled and the stream is read-write but\n<line21>currently reading, subsequent putc or fputc calls will write directly\n<line22>into the buffer, although they shouldn't be allowed to.  */\n<line23>if ((fp_->_flags & __SRD) != 0)\n<line24>fp_->_w = 0;\n<line25># endif\n<line26>return result;\n<line27>#else\n<line28>/* Most systems provide FILE as a struct and the necessary bitmask in\n<line29><stdio.h>, because they need it for implementing getc() and putc() as\n<line30>fast macros.  */\n<line31># if defined _IO_EOF_SEEN || defined _IO_ftrylockfile || __GNU_LIBRARY__ == 1\n<line32>/* GNU libc, BeOS, Haiku, Linux libc5 */\n<line33>fp->_IO_read_end = fp->_IO_read_ptr;\n<line34>fp->_IO_write_ptr = fp->_IO_write_base;\n<line35>/* Avoid memory leak when there is an active ungetc buffer.  */\n<line36>if (fp->_IO_save_base != NULL)\n<line37>{\n<line38>free (fp->_IO_save_base);\n<line39>fp->_IO_save_base = NULL;\n<line40>}\n<line41>return 0;\n<line42># elif defined __sferror || defined __DragonFly__ || defined __ANDROID__\n<line43>/* FreeBSD, NetBSD, OpenBSD, DragonFly, Mac OS X, Cygwin, Minix 3, Android */\n<line44>fp_->_p = fp_->_bf._base;\n<line45>fp_->_r = 0;\n<line46>fp_->_w = ((fp_->_flags & (__SLBF | __SNBF | __SRD)) == 0 /* fully buffered and not currently reading? */\n<line47>? fp_->_bf._size\n<line48>: 0);\n<line49>/* Avoid memory leak when there is an active ungetc buffer.  */\n<line50>if (fp_ub._base != NULL)\n<line51>{\n<line52>if (fp_ub._base != fp_->_ubuf)\n<line53>free (fp_ub._base);\n<line54>fp_ub._base = NULL;\n<line55>}\n<line56>return 0;\n<line57># elif defined __EMX__              /* emx+gcc */\n<line58>fp->_ptr = fp->_buffer;\n<line59>fp->_rcount = 0;\n<line60>fp->_wcount = 0;\n<line61>fp->_ungetc_count = 0;\n<line62>return 0;\n<line63># elif defined __minix              /* Minix */\n<line64>fp->_ptr = fp->_buf;\n<line65>if (fp->_ptr != NULL)\n<line66>fp->_count = 0;\n<line67>return 0;\n<line68># elif defined _IOERR               /* AIX, HP-UX, IRIX, OSF/1, Solaris, OpenServer, UnixWare, mingw, MSVC, NonStop Kernel, OpenVMS */\n<line69>fp_->_ptr = fp_->_base;\n<line70>if (fp_->_ptr != NULL)\n<line71>fp_->_cnt = 0;\n<line72>return 0;\n<line73># elif defined __UCLIBC__           /* uClibc */\n<line74>#  ifdef __STDIO_BUFFERS\n<line75>if (fp->__modeflags & __FLAG_WRITING)\n<line76>fp->__bufpos = fp->__bufstart;\n<line77>else if (fp->__modeflags & (__FLAG_READONLY | __FLAG_READING))\n<line78>fp->__bufpos = fp->__bufread;\n<line79>#  endif\n<line80>return 0;\n<line81># elif defined __QNX__              /* QNX */\n<line82>fp->_Rback = fp->_Back + sizeof (fp->_Back);\n<line83>fp->_Rsave = NULL;\n<line84>if (fp->_Mode & 0x2000 /* _MWRITE */)\n<line85>/* fp->_Buf <= fp->_Next <= fp->_Wend */\n<line86>fp->_Next = fp->_Buf;\n<line87>else\n<line88>/* fp->_Buf <= fp->_Next <= fp->_Rend */\n<line89>fp->_Rend = fp->_Next;\n<line90>return 0;\n<line91># elif defined __MINT__             /* Atari FreeMiNT */\n<line92>if (fp->__pushed_back)\n<line93>{\n<line94>fp->__bufp = fp->__pushback_bufp;\n<line95>fp->__pushed_back = 0;\n<line96>}\n<line97>/* Preserve the current file position.  */\n<line98>if (fp->__target != -1)\n<line99>fp->__target += fp->__bufp - fp->__buffer;\n<line100>fp->__bufp = fp->__buffer;\n<line101>/* Nothing in the buffer, next getc is nontrivial.  */\n<line102>fp->__get_limit = fp->__bufp;\n<line103>/* Nothing in the buffer, next putc is nontrivial.  */\n<line104>fp->__put_limit = fp->__buffer;\n<line105>return 0;\n<line106># elif defined EPLAN9               /* Plan9 */\n<line107>fp->rp = fp->wp = fp->lp = fp->buf;\n<line108>return 0;\n<line109># else\n<line110>#  error "Please port gnulib fpurge.c to your platform! Look at the definitions of fflush, setvbuf and ungetc on your system, then report this to bug-gnulib."\n<line111># endif\n<line112>#endif\n<line113>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/freadahead.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
Function: freadahead
Content: <line0>size_t\n<line1>freadahead (FILE *fp)\n<line2>{\n<line3>#if defined _IO_EOF_SEEN || defined _IO_ftrylockfile || __GNU_LIBRARY__ == 1\n<line4>/* GNU libc, BeOS, Haiku, Linux libc5 */\n<line5>if (fp->_IO_write_ptr > fp->_IO_write_base)\n<line6>return 0;\n<line7>return (fp->_IO_read_end - fp->_IO_read_ptr)\n<line8>+ (fp->_flags & _IO_IN_BACKUP ? fp->_IO_save_end - fp->_IO_save_base :\n<line9>0);\n<line10>#elif defined __sferror || defined __DragonFly__ || defined __ANDROID__\n<line11>/* FreeBSD, NetBSD, OpenBSD, DragonFly, Mac OS X, Cygwin, Minix 3, Android */\n<line12>if ((fp_->_flags & __SWR) != 0 || fp_->_r < 0)\n<line13>return 0;\n<line14># if defined __DragonFly__\n<line15>return __sreadahead (fp);\n<line16># else\n<line17>return fp_->_r\n<line18>+ (HASUB (fp) ? fp_->_ur : 0);\n<line19># endif\n<line20>#elif defined __EMX__               /* emx+gcc */\n<line21>if ((fp->_flags & _IOWRT) != 0)\n<line22>return 0;\n<line23>/* Note: fp->_ungetc_count > 0 implies fp->_rcount <= 0,\n<line24>fp->_ungetc_count = 0 implies fp->_rcount >= 0.  */\n<line25>/* equivalent to\n<line26>(fp->_ungetc_count == 0 ? fp->_rcount : fp->_ungetc_count - fp->_rcount) */\n<line27>return (fp->_rcount > 0 ? fp->_rcount : fp->_ungetc_count - fp->_rcount);\n<line28>#elif defined __minix               /* Minix */\n<line29>if ((fp_->_flags & _IOWRITING) != 0)\n<line30>return 0;\n<line31>return fp_->_count;\n<line32>#elif defined _IOERR                /* AIX, HP-UX, IRIX, OSF/1, Solaris, OpenServer, UnixWare, mingw, MSVC, NonStop Kernel, OpenVMS */\n<line33>if ((fp_->_flag & _IOWRT) != 0)\n<line34>return 0;\n<line35>return fp_->_cnt;\n<line36>#elif defined __UCLIBC__            /* uClibc */\n<line37># ifdef __STDIO_BUFFERS\n<line38>if (fp->__modeflags & __FLAG_WRITING)\n<line39>return 0;\n<line40>return (fp->__bufread - fp->__bufpos)\n<line41>+ (fp->__modeflags & __FLAG_UNGOT ? 1 : 0);\n<line42># else\n<line43>return 0;\n<line44># endif\n<line45>#elif defined __QNX__               /* QNX */\n<line46>if ((fp->_Mode & 0x2000 /* _MWRITE */) != 0)\n<line47>return 0;\n<line48>/* fp->_Buf <= fp->_Next <= fp->_Rend,\n<line49>and fp->_Rend may be overridden by fp->_Rsave. */\n<line50>return ((fp->_Rsave ? fp->_Rsave : fp->_Rend) - fp->_Next)\n<line51>+ (fp->_Mode & 0x4000 /* _MBYTE */\n<line52>? (fp->_Back + sizeof (fp->_Back)) - fp->_Rback\n<line53>: 0);\n<line54>#elif defined __MINT__              /* Atari FreeMiNT */\n<line55>if (!fp->__mode.__read)\n<line56>return 0;\n<line57>return (fp->__pushed_back\n<line58>? fp->__get_limit - fp->__pushback_bufp + 1\n<line59>: fp->__get_limit - fp->__bufp);\n<line60>#elif defined EPLAN9                /* Plan9 */\n<line61>if (fp->state == 4 /* WR */ || fp->rp >= fp->wp)\n<line62>return 0;\n<line63>return fp->wp - fp->rp;\n<line64>#elif defined SLOW_BUT_NO_HACKS     /* users can define this */\n<line65>abort ();\n<line66>return 0;\n<line67>#else\n<line68>#error "Please port gnulib freadahead.c to your platform! Look at the definition of fflush, fread, ungetc on your system, then report this to bug-gnulib."\n<line69>#endif\n<line70>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/freading.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
========================================
/home/huihui/Downloads/coreutils-9.4/lib/freadptr.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
Function: freadptr
Content: <line0>const char *\n<line1>freadptr (FILE *fp, size_t *sizep)\n<line2>{\n<line3>size_t size;\n<line4>/* Keep this code in sync with freadahead!  */\n<line5>#if defined _IO_EOF_SEEN || defined _IO_ftrylockfile || __GNU_LIBRARY__ == 1\n<line6>/* GNU libc, BeOS, Haiku, Linux libc5 */\n<line7>if (fp->_IO_write_ptr > fp->_IO_write_base)\n<line8>return NULL;\n<line9>size = fp->_IO_read_end - fp->_IO_read_ptr;\n<line10>if (size == 0)\n<line11>return NULL;\n<line12>*sizep = size;\n<line13>return (const char *) fp->_IO_read_ptr;\n<line14>#elif defined __sferror || defined __DragonFly__ || defined __ANDROID__\n<line15>/* FreeBSD, NetBSD, OpenBSD, DragonFly, Mac OS X, Cygwin, Minix 3, Android */\n<line16>if ((fp_->_flags & __SWR) != 0 || fp_->_r < 0)\n<line17>return NULL;\n<line18>size = fp_->_r;\n<line19>if (size == 0)\n<line20>return NULL;\n<line21>*sizep = size;\n<line22>return (const char *) fp_->_p;\n<line23>#elif defined __EMX__               /* emx+gcc */\n<line24>if ((fp->_flags & _IOWRT) != 0)\n<line25>return NULL;\n<line26>/* Note: fp->_ungetc_count > 0 implies fp->_rcount <= 0,\n<line27>fp->_ungetc_count = 0 implies fp->_rcount >= 0.  */\n<line28>if (fp->_rcount <= 0)\n<line29>return NULL;\n<line30>if (!(fp->_ungetc_count == 0))\n<line31>abort ();\n<line32>*sizep = fp->_rcount;\n<line33>return fp->_ptr;\n<line34>#elif defined __minix               /* Minix */\n<line35>if ((fp_->_flags & _IOWRITING) != 0)\n<line36>return NULL;\n<line37>size = fp_->_count;\n<line38>if (size == 0)\n<line39>return NULL;\n<line40>*sizep = size;\n<line41>return (const char *) fp_->_ptr;\n<line42>#elif defined _IOERR                /* AIX, HP-UX, IRIX, OSF/1, Solaris, OpenServer, UnixWare, mingw, MSVC, NonStop Kernel, OpenVMS */\n<line43>if ((fp_->_flag & _IOWRT) != 0)\n<line44>return NULL;\n<line45>size = fp_->_cnt;\n<line46>if (size == 0)\n<line47>return NULL;\n<line48>*sizep = size;\n<line49>return (const char *) fp_->_ptr;\n<line50>#elif defined __UCLIBC__            /* uClibc */\n<line51># ifdef __STDIO_BUFFERS\n<line52>if (fp->__modeflags & __FLAG_WRITING)\n<line53>return NULL;\n<line54>if (fp->__modeflags & __FLAG_UNGOT)\n<line55>return NULL;\n<line56>size = fp->__bufread - fp->__bufpos;\n<line57>if (size == 0)\n<line58>return NULL;\n<line59>*sizep = size;\n<line60>return (const char *) fp->__bufpos;\n<line61># else\n<line62>return NULL;\n<line63># endif\n<line64>#elif defined __QNX__               /* QNX */\n<line65>if ((fp->_Mode & 0x2000 /* _MWRITE */) != 0)\n<line66>return NULL;\n<line67>/* fp->_Buf <= fp->_Next <= fp->_Rend */\n<line68>size = fp->_Rend - fp->_Next;\n<line69>if (size == 0)\n<line70>return NULL;\n<line71>*sizep = size;\n<line72>return (const char *) fp->_Next;\n<line73>#elif defined __MINT__              /* Atari FreeMiNT */\n<line74>if (!fp->__mode.__read)\n<line75>return NULL;\n<line76>size = fp->__get_limit - fp->__bufp;\n<line77>if (size == 0)\n<line78>return NULL;\n<line79>*sizep = size;\n<line80>return fp->__bufp;\n<line81>#elif defined EPLAN9                /* Plan9 */\n<line82>if (fp->state == 4 /* WR */)\n<line83>return NULL;\n<line84>if (fp->rp >= fp->wp)\n<line85>return NULL;\n<line86>*sizep = fp->wp - fp->rp;\n<line87>return fp->rp;\n<line88>#elif defined SLOW_BUT_NO_HACKS     /* users can define this */\n<line89>/* This implementation is correct on any ANSI C platform.  It is just\n<line90>awfully slow.  */\n<line91>return NULL;\n<line92>#else\n<line93>#error "Please port gnulib freadptr.c to your platform! Look at the definition of fflush, fread, getc, getc_unlocked on your system, then report this to bug-gnulib."\n<line94>#endif\n<line95>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/freadseek.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
Function: freadptrinc
Content: <line0>static void\n<line1>freadptrinc (FILE *fp, size_t increment)\n<line2>{\n<line3>/* Keep this code in sync with freadptr!  */\n<line4>#if HAVE___FREADPTRINC              /* musl libc */\n<line5>__freadptrinc (fp, increment);\n<line6>#elif defined _IO_EOF_SEEN || defined _IO_ftrylockfile || __GNU_LIBRARY__ == 1\n<line7>/* GNU libc, BeOS, Haiku, Linux libc5 */\n<line8>fp->_IO_read_ptr += increment;\n<line9>#elif defined __sferror || defined __DragonFly__ || defined __ANDROID__\n<line10>/* FreeBSD, NetBSD, OpenBSD, DragonFly, Mac OS X, Cygwin, Minix 3, Android */\n<line11>fp_->_p += increment;\n<line12>fp_->_r -= increment;\n<line13>#elif defined __EMX__               /* emx+gcc */\n<line14>fp->_ptr += increment;\n<line15>fp->_rcount -= increment;\n<line16>#elif defined __minix               /* Minix */\n<line17>fp_->_ptr += increment;\n<line18>fp_->_count -= increment;\n<line19>#elif defined _IOERR                /* AIX, HP-UX, IRIX, OSF/1, Solaris, OpenServer, UnixWare, mingw, MSVC, NonStop Kernel, OpenVMS */\n<line20>fp_->_ptr += increment;\n<line21>fp_->_cnt -= increment;\n<line22>#elif defined __UCLIBC__            /* uClibc */\n<line23># ifdef __STDIO_BUFFERS\n<line24>fp->__bufpos += increment;\n<line25># else\n<line26>abort ();\n<line27># endif\n<line28>#elif defined __QNX__               /* QNX */\n<line29>fp->_Next += increment;\n<line30>#elif defined __MINT__              /* Atari FreeMiNT */\n<line31>fp->__bufp += increment;\n<line32>#elif defined EPLAN9                /* Plan9 */\n<line33>fp->rp += increment;\n<line34>#elif defined SLOW_BUT_NO_HACKS     /* users can define this */\n<line35>#else\n<line36>#error "Please port gnulib freadseek.c to your platform! Look at the definition of getc, getc_unlocked on your system, then report this to bug-gnulib."\n<line37>#endif\n<line38>}
----------------------------------------
Function: freadseek
Content: <line0>int\n<line1>freadseek (FILE *fp, size_t offset)\n<line2>{\n<line3>size_t total_buffered;\n<line4>int fd;\n<line5>if (offset == 0)\n<line6>return 0;\n<line7>/* Seek over the already read and buffered input as quickly as possible,\n<line8>without doing any system calls.  */\n<line9>total_buffered = freadahead (fp);\n<line10>/* This loop is usually executed at most twice: once for ungetc buffer (if\n<line11>present) and once for the main buffer.  */\n<line12>while (total_buffered > 0)\n<line13>{\n<line14>size_t buffered;\n<line15>if (freadptr (fp, &buffered) != NULL && buffered > 0)\n<line16>{\n<line17>size_t increment = (buffered < offset ? buffered : offset);\n<line18>freadptrinc (fp, increment);\n<line19>offset -= increment;\n<line20>if (offset == 0)\n<line21>return 0;\n<line22>total_buffered -= increment;\n<line23>if (total_buffered == 0)\n<line24>break;\n<line25>}\n<line26>/* Read one byte.  If we were reading from the ungetc buffer, this\n<line27>switches the stream back to the main buffer.  */\n<line28>if (fgetc (fp) == EOF)\n<line29>goto eof;\n<line30>offset--;\n<line31>if (offset == 0)\n<line32>return 0;\n<line33>total_buffered--;\n<line34>}\n<line35>/* Test whether the stream is seekable or not.  */\n<line36>fd = fileno (fp);\n<line37>if (fd >= 0 && lseek (fd, 0, SEEK_CUR) >= 0)\n<line38>{\n<line39>/* FP refers to a regular file.  fseek is most efficient in this case.  */\n<line40>return fseeko (fp, offset, SEEK_CUR);\n<line41>}\n<line42>else\n<line43>{\n<line44>/* FP is a non-seekable stream, possibly not even referring to a file\n<line45>descriptor.  Read OFFSET bytes explicitly and discard them.  */\n<line46>char buf[4096];\n<line47>do\n<line48>{\n<line49>size_t count = (sizeof (buf) < offset ? sizeof (buf) : offset);\n<line50>if (fread (buf, 1, count, fp) < count)\n<line51>goto eof;\n<line52>offset -= count;\n<line53>}\n<line54>while (offset > 0);\n<line55>return 0;\n<line56>}\n<line57>eof:\n<line58>/* EOF, or error before or while reading.  */\n<line59>if (ferror (fp))\n<line60>return EOF;\n<line61>else\n<line62>/* Encountered EOF.  */\n<line63>return 0;\n<line64>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/freopen-safer.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
Function: protect_fd
Content: <line0>static bool\n<line1>protect_fd (int fd)\n<line2>{\n<line3>int value = open ("/dev/null", O_RDONLY);\n<line4>if (value != fd)\n<line5>{\n<line6>if (0 <= value)\n<line7>{\n<line8>close (value);\n<line9>errno = EBADF; /* Unexpected; this is as good as anything else.  */\n<line10>}\n<line11>return false;\n<line12>}\n<line13>return true;\n<line14>}
----------------------------------------
Function: freopen_safer
Content: <line0>FILE *\n<line1>freopen_safer (char const *name, char const *mode, FILE *f)\n<line2>{\n<line3>/* Unfortunately, we cannot use the fopen_safer approach of using\n<line4>fdopen (dup_safer (fileno (freopen (cmd, mode, f)))), because we\n<line5>need to return f itself.  The implementation of freopen(NULL,m,f)\n<line6>is system-dependent, so the best we can do is guarantee that all\n<line7>lower-valued standard fds are open prior to the freopen call,\n<line8>even though this puts more pressure on open fds.  */\n<line9>bool protect_in = false;\n<line10>bool protect_out = false;\n<line11>bool protect_err = false;\n<line12>int saved_errno;\n<line13>switch (fileno (f))\n<line14>{\n<line15>default: /* -1 or not a standard stream.  */\n<line16>if (dup2 (STDERR_FILENO, STDERR_FILENO) != STDERR_FILENO)\n<line17>protect_err = true;\n<line18>FALLTHROUGH;\n<line19>case STDERR_FILENO:\n<line20>if (dup2 (STDOUT_FILENO, STDOUT_FILENO) != STDOUT_FILENO)\n<line21>protect_out = true;\n<line22>FALLTHROUGH;\n<line23>case STDOUT_FILENO:\n<line24>if (dup2 (STDIN_FILENO, STDIN_FILENO) != STDIN_FILENO)\n<line25>protect_in = true;\n<line26>FALLTHROUGH;\n<line27>case STDIN_FILENO:\n<line28>/* Nothing left to protect.  */\n<line29>break;\n<line30>}\n<line31>if (protect_in && !protect_fd (STDIN_FILENO))\n<line32>f = NULL;\n<line33>else if (protect_out && !protect_fd (STDOUT_FILENO))\n<line34>f = NULL;\n<line35>else if (protect_err && !protect_fd (STDERR_FILENO))\n<line36>f = NULL;\n<line37>else\n<line38>f = freopen (name, mode, f);\n<line39>saved_errno = errno;\n<line40>if (protect_err)\n<line41>close (STDERR_FILENO);\n<line42>if (protect_out)\n<line43>close (STDOUT_FILENO);\n<line44>if (protect_in)\n<line45>close (STDIN_FILENO);\n<line46>if (!f)\n<line47>errno = saved_errno;\n<line48>return f;\n<line49>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/fseek.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
Function: rpl_fseek
Content: <line0>int\n<line1>fseek (FILE *fp, long offset, int whence)\n<line2>{\n<line3>/* Use the replacement fseeko function with all its workarounds.  */\n<line4>return fseeko (fp, (off_t)offset, whence);\n<line5>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/fseeko.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
Function: rpl_fseeko
Content: <line0>int\n<line1>fseeko (FILE *fp, off_t offset, int whence)\n<line2>#undef fseeko\n<line3>#if !HAVE_FSEEKO\n<line4># undef fseek\n<line5># define fseeko fseek\n<line6>#endif\n<line7>#if _GL_WINDOWS_64_BIT_OFF_T\n<line8># undef fseeko\n<line9># if HAVE__FSEEKI64 && HAVE_DECL__FSEEKI64 /* msvc, mingw since msvcrt8.0, mingw64 */\n<line10>#  define fseeko _fseeki64\n<line11># else /* mingw before msvcrt8.0 */\n<line12>#  define fseeko fseeko64\n<line13># endif\n<line14>#endif\n<line15>{\n<line16>#if LSEEK_PIPE_BROKEN\n<line17>/* mingw gives bogus answers rather than failure on non-seekable files.  */\n<line18>if (lseek (fileno (fp), 0, SEEK_CUR) == -1)\n<line19>return EOF;\n<line20>#endif\n<line21>/* These tests are based on fpurge.c.  */\n<line22>#if defined _IO_EOF_SEEN || defined _IO_ftrylockfile || __GNU_LIBRARY__ == 1\n<line23>/* GNU libc, BeOS, Haiku, Linux libc5 */\n<line24>if (fp->_IO_read_end == fp->_IO_read_ptr\n<line25>&& fp->_IO_write_ptr == fp->_IO_write_base\n<line26>&& fp->_IO_save_base == NULL)\n<line27>#elif defined __sferror || defined __DragonFly__ || defined __ANDROID__\n<line28>/* FreeBSD, NetBSD, OpenBSD, DragonFly, Mac OS X, Cygwin, Minix 3, Android */\n<line29># if defined __SL64 && defined __SCLE /* Cygwin */\n<line30>if ((fp->_flags & __SL64) == 0)\n<line31>{\n<line32>/* Cygwin 1.5.0 through 1.5.24 failed to open stdin in 64-bit\n<line33>mode; but has an fseeko that requires 64-bit mode.  */\n<line34>FILE *tmp = fopen ("/dev/null", "r");\n<line35>if (!tmp)\n<line36>return -1;\n<line37>fp->_flags |= __SL64;\n<line38>fp->_seek64 = tmp->_seek64;\n<line39>fclose (tmp);\n<line40>}\n<line41># endif\n<line42>if (fp_->_p == fp_->_bf._base\n<line43>&& fp_->_r == 0\n<line44>&& fp_->_w == ((fp_->_flags & (__SLBF | __SNBF | __SRD)) == 0 /* fully buffered and not currently reading? */\n<line45>? fp_->_bf._size\n<line46>: 0)\n<line47>&& fp_ub._base == NULL)\n<line48>#elif defined __EMX__               /* emx+gcc */\n<line49>if (fp->_ptr == fp->_buffer\n<line50>&& fp->_rcount == 0\n<line51>&& fp->_wcount == 0\n<line52>&& fp->_ungetc_count == 0)\n<line53>#elif defined __minix               /* Minix */\n<line54>if (fp_->_ptr == fp_->_buf\n<line55>&& (fp_->_ptr == NULL || fp_->_count == 0))\n<line56>#elif defined _IOERR                /* AIX, HP-UX, IRIX, OSF/1, Solaris, OpenServer, UnixWare, mingw, MSVC, NonStop Kernel, OpenVMS */\n<line57>if (fp_->_ptr == fp_->_base\n<line58>&& (fp_->_ptr == NULL || fp_->_cnt == 0))\n<line59>#elif defined __UCLIBC__            /* uClibc */\n<line60>if (((fp->__modeflags & __FLAG_WRITING) == 0\n<line61>|| fp->__bufpos == fp->__bufstart)\n<line62>&& ((fp->__modeflags & (__FLAG_READONLY | __FLAG_READING)) == 0\n<line63>|| fp->__bufpos == fp->__bufread))\n<line64>#elif defined __QNX__               /* QNX */\n<line65>if ((fp->_Mode & 0x2000 /* _MWRITE */ ? fp->_Next == fp->_Buf : fp->_Next == fp->_Rend)\n<line66>&& fp->_Rback == fp->_Back + sizeof (fp->_Back)\n<line67>&& fp->_Rsave == NULL)\n<line68>#elif defined __MINT__              /* Atari FreeMiNT */\n<line69>if (fp->__bufp == fp->__buffer\n<line70>&& fp->__get_limit == fp->__bufp\n<line71>&& fp->__put_limit == fp->__bufp\n<line72>&& !fp->__pushed_back)\n<line73>#elif defined EPLAN9                /* Plan9 */\n<line74>if (fp->rp == fp->buf\n<line75>&& fp->wp == fp->buf)\n<line76>#elif FUNC_FFLUSH_STDIN < 0 && 200809 <= _POSIX_VERSION\n<line77>/* Cross-compiling to some other system advertising conformance to\n<line78>POSIX.1-2008 or later.  Assume fseeko and fflush work as advertised.\n<line79>If this assumption is incorrect, please report the bug to\n<line80>bug-gnulib.  */\n<line81>if (0)\n<line82>#else\n<line83>#error "Please port gnulib fseeko.c to your platform! Look at the code in fseeko.c, then report this to bug-gnulib."\n<line84>#endif\n<line85>{\n<line86>/* We get here when an fflush() call immediately preceded this one (or\n<line87>if ftell() has created buffers but no I/O has occurred on a\n<line88>newly-opened stream).  We know there are no buffers.  */\n<line89>off_t pos = lseek (fileno (fp), offset, whence);\n<line90>if (pos == -1)\n<line91>{\n<line92>#if defined __sferror || defined __DragonFly__ || defined __ANDROID__\n<line93>/* FreeBSD, NetBSD, OpenBSD, DragonFly, Mac OS X, Cygwin, Minix 3, Android */\n<line94>fp_->_flags &= ~__SOFF;\n<line95>#endif\n<line96>return -1;\n<line97>}\n<line98>#if defined _IO_EOF_SEEN || defined _IO_ftrylockfile || __GNU_LIBRARY__ == 1\n<line99>/* GNU libc, BeOS, Haiku, Linux libc5 */\n<line100>fp->_flags &= ~_IO_EOF_SEEN;\n<line101>fp->_offset = pos;\n<line102>#elif defined __sferror || defined __DragonFly__ || defined __ANDROID__\n<line103>/* FreeBSD, NetBSD, OpenBSD, DragonFly, Mac OS X, Cygwin, Minix 3, Android */\n<line104># if defined __CYGWIN__ || (defined __NetBSD__ && __NetBSD_Version__ >= 600000000) || defined __minix\n<line105>/* fp_->_offset is typed as an integer.  */\n<line106>fp_->_offset = pos;\n<line107># else\n<line108>/* fp_->_offset is an fpos_t.  */\n<line109>{\n<line110>/* Use a union, since on NetBSD, the compilation flags\n<line111>determine whether fpos_t is typedef'd to off_t or a struct\n<line112>containing a single off_t member.  */\n<line113>union\n<line114>{\n<line115>fpos_t f;\n<line116>off_t o;\n<line117>} u;\n<line118>u.o = pos;\n<line119>fp_->_offset = u.f;\n<line120>}\n<line121># endif\n<line122>fp_->_flags |= __SOFF;\n<line123>fp_->_flags &= ~__SEOF;\n<line124>#elif defined __EMX__               /* emx+gcc */\n<line125>fp->_flags &= ~_IOEOF;\n<line126>#elif defined _IOERR                /* AIX, HP-UX, IRIX, OSF/1, Solaris, OpenServer, UnixWare, mingw, MSVC, NonStop Kernel, OpenVMS */\n<line127>fp_->_flag &= ~_IOEOF;\n<line128>#elif defined __MINT__              /* Atari FreeMiNT */\n<line129>fp->__offset = pos;\n<line130>fp->__eof = 0;\n<line131>#endif\n<line132>return 0;\n<line133>}\n<line134>return fseeko (fp, offset, whence);\n<line135>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/fseterr.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
Function: fseterr
Content: <line0>void\n<line1>fseterr (FILE *fp)\n<line2>{\n<line3>/* Most systems provide FILE as a struct and the necessary bitmask in\n<line4><stdio.h>, because they need it for implementing getc() and putc() as\n<line5>fast macros.  */\n<line6>#if defined _IO_EOF_SEEN || defined _IO_ftrylockfile || __GNU_LIBRARY__ == 1\n<line7>/* GNU libc, BeOS, Haiku, Linux libc5 */\n<line8>fp->_flags |= _IO_ERR_SEEN;\n<line9>#elif defined __sferror || defined __DragonFly__ || defined __ANDROID__\n<line10>/* FreeBSD, NetBSD, OpenBSD, DragonFly, Mac OS X, Cygwin, Minix 3, Android */\n<line11>fp_->_flags |= __SERR;\n<line12>#elif defined __EMX__               /* emx+gcc */\n<line13>fp->_flags |= _IOERR;\n<line14>#elif defined __minix               /* Minix */\n<line15>fp->_flags |= _IOERR;\n<line16>#elif defined _IOERR                /* AIX, HP-UX, IRIX, OSF/1, Solaris, OpenServer, UnixWare, mingw, MSVC, NonStop Kernel, OpenVMS */\n<line17>fp_->_flag |= _IOERR;\n<line18>#elif defined __UCLIBC__            /* uClibc */\n<line19>fp->__modeflags |= __FLAG_ERROR;\n<line20>#elif defined __QNX__               /* QNX */\n<line21>fp->_Mode |= 0x200 /* _MERR */;\n<line22>#elif defined __MINT__              /* Atari FreeMiNT */\n<line23>fp->__error = 1;\n<line24>#elif defined EPLAN9                /* Plan9 */\n<line25>if (fp->state != 0 /* CLOSED */)\n<line26>fp->state = 5 /* ERR */;\n<line27>#elif 0                             /* unknown  */\n<line28>/* Portable fallback, based on an idea by Rich Felker.\n<line29>Wow! 6 system calls for something that is just a bit operation!\n<line30>Not activated on any system, because there is no way to repair FP when\n<line31>the sequence of system calls fails, and library code should not call\n<line32>abort().  */\n<line33>int saved_errno;\n<line34>int fd;\n<line35>int fd2;\n<line36>saved_errno = errno;\n<line37>fflush (fp);\n<line38>fd = fileno (fp);\n<line39>fd2 = dup (fd);\n<line40>if (fd2 >= 0)\n<line41>{\n<line42>close (fd);\n<line43>fputc ('\0', fp); /* This should set the error indicator.  */\n<line44>fflush (fp);      /* Or this.  */\n<line45>if (dup2 (fd2, fd) < 0)\n<line46>/* Whee... we botched the stream and now cannot restore it!  */\n<line47>abort ();\n<line48>close (fd2);\n<line49>}\n<line50>errno = saved_errno;\n<line51>#else\n<line52>#error "Please port gnulib fseterr.c to your platform! Look at the definitions of ferror and clearerr on your system, then report this to bug-gnulib."\n<line53>#endif\n<line54>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/fsusage.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
Function: statvfs_works
Content: <line0>static int\n<line1>statvfs_works (void)\n<line2>{\n<line3>static int statvfs_works_cache = -1;\n<line4>struct utsname name;\n<line5>if (statvfs_works_cache < 0)\n<line6>statvfs_works_cache = (uname (&name) == 0\n<line7>&& 0 <= strverscmp (name.release, "2.6.36"));\n<line8>return statvfs_works_cache;\n<line9>}
----------------------------------------
Function: get_fs_usage
Content: <line0>int\n<line1>get_fs_usage (char const *file, char const *disk, struct fs_usage *fsp)\n<line2>{\n<line3>#ifdef STAT_STATVFS     /* POSIX, except pre-2.6.36 glibc/Linux */\n<line4>if (statvfs_works ())\n<line5>{\n<line6>struct statvfs vfsd;\n<line7>if (statvfs (file, &vfsd) < 0)\n<line8>return -1;\n<line9>/* f_frsize isn't guaranteed to be supported.  */\n<line10>fsp->fsu_blocksize = (vfsd.f_frsize\n<line11>? PROPAGATE_ALL_ONES (vfsd.f_frsize)\n<line12>: PROPAGATE_ALL_ONES (vfsd.f_bsize));\n<line13>fsp->fsu_blocks = PROPAGATE_ALL_ONES (vfsd.f_blocks);\n<line14>fsp->fsu_bfree = PROPAGATE_ALL_ONES (vfsd.f_bfree);\n<line15>fsp->fsu_bavail = PROPAGATE_TOP_BIT (vfsd.f_bavail);\n<line16>fsp->fsu_bavail_top_bit_set = EXTRACT_TOP_BIT (vfsd.f_bavail) != 0;\n<line17>fsp->fsu_files = PROPAGATE_ALL_ONES (vfsd.f_files);\n<line18>fsp->fsu_ffree = PROPAGATE_ALL_ONES (vfsd.f_ffree);\n<line19>return 0;\n<line20>}\n<line21>#endif\n<line22>#if defined STAT_STATVFS64            /* AIX */\n<line23>struct statvfs64 fsd;\n<line24>if (statvfs64 (file, &fsd) < 0)\n<line25>return -1;\n<line26>/* f_frsize isn't guaranteed to be supported.  */\n<line27>fsp->fsu_blocksize = (fsd.f_frsize\n<line28>? PROPAGATE_ALL_ONES (fsd.f_frsize)\n<line29>: PROPAGATE_ALL_ONES (fsd.f_bsize));\n<line30>#elif defined STAT_STATFS3_OSF1         /* OSF/1 */\n<line31>struct statfs fsd;\n<line32>if (statfs (file, &fsd, sizeof (struct statfs)) != 0)\n<line33>return -1;\n<line34>fsp->fsu_blocksize = PROPAGATE_ALL_ONES (fsd.f_fsize);\n<line35>#elif defined STAT_STATFS2_FRSIZE        /* 2.6 < glibc/Linux < 2.6.36 */\n<line36>struct statfs fsd;\n<line37>if (statfs (file, &fsd) < 0)\n<line38>return -1;\n<line39>fsp->fsu_blocksize = PROPAGATE_ALL_ONES (fsd.f_frsize);\n<line40>#elif defined STAT_STATFS2_BSIZE        /* glibc/Linux < 2.6, 4.3BSD, SunOS 4, \\n<line41>Mac OS X < 10.4, FreeBSD < 5.0, \\n<line42>NetBSD < 3.0, OpenBSD < 4.4 */\n<line43>struct statfs fsd;\n<line44>if (statfs (file, &fsd) < 0)\n<line45>return -1;\n<line46>fsp->fsu_blocksize = PROPAGATE_ALL_ONES (fsd.f_bsize);\n<line47># ifdef STATFS_TRUNCATES_BLOCK_COUNTS\n<line48>/* In SunOS 4.1.2, 4.1.3, and 4.1.3_U1, the block counts in the\n<line49>struct statfs are truncated to 2GB.  These conditions detect that\n<line50>truncation, presumably without botching the 4.1.1 case, in which\n<line51>the values are not truncated.  The correct counts are stored in\n<line52>undocumented spare fields.  */\n<line53>if (fsd.f_blocks == 0x7fffffff / fsd.f_bsize && fsd.f_spare[0] > 0)\n<line54>{\n<line55>fsd.f_blocks = fsd.f_spare[0];\n<line56>fsd.f_bfree = fsd.f_spare[1];\n<line57>fsd.f_bavail = fsd.f_spare[2];\n<line58>}\n<line59># endif /* STATFS_TRUNCATES_BLOCK_COUNTS */\n<line60>#elif defined STAT_STATFS2_FSIZE        /* 4.4BSD and older NetBSD */\n<line61>struct statfs fsd;\n<line62>if (statfs (file, &fsd) < 0)\n<line63>return -1;\n<line64>fsp->fsu_blocksize = PROPAGATE_ALL_ONES (fsd.f_fsize);\n<line65>#elif defined STAT_STATFS4              /* SVR3, old Irix */\n<line66>struct statfs fsd;\n<line67>if (statfs (file, &fsd, sizeof fsd, 0) < 0)\n<line68>return -1;\n<line69>/* Empirically, the block counts on most SVR3 and SVR3-derived\n<line70>systems seem to always be in terms of 512-byte blocks,\n<line71>no matter what value f_bsize has.  */\n<line72>fsp->fsu_blocksize = 512;\n<line73>#endif\n<line74>#if (defined STAT_STATVFS64 || defined STAT_STATFS3_OSF1                \\n<line75>|| defined STAT_STATFS2_FRSIZE || defined STAT_STATFS2_BSIZE       \\n<line76>|| defined STAT_STATFS2_FSIZE || defined STAT_STATFS4)\n<line77>fsp->fsu_blocks = PROPAGATE_ALL_ONES (fsd.f_blocks);\n<line78>fsp->fsu_bfree = PROPAGATE_ALL_ONES (fsd.f_bfree);\n<line79>fsp->fsu_bavail = PROPAGATE_TOP_BIT (fsd.f_bavail);\n<line80>fsp->fsu_bavail_top_bit_set = EXTRACT_TOP_BIT (fsd.f_bavail) != 0;\n<line81>fsp->fsu_files = PROPAGATE_ALL_ONES (fsd.f_files);\n<line82>fsp->fsu_ffree = PROPAGATE_ALL_ONES (fsd.f_ffree);\n<line83>#endif\n<line84>(void) disk;  /* avoid argument-unused warning */\n<line85>return 0;\n<line86>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/ftoastr.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
Function: ftoastr
Content: <line0>int\n<line1>FTOASTR (char *buf, size_t bufsize, int flags, int width, FLOAT x)\n<line2>{\n<line3>/* The following method is simple but slow.\n<line4>For ideas about speeding things up, please see:\n<line5>Andrysco M, Jhala R, Lerner S. Printing floating-point numbers:\n<line6>a faster, always correct method. ACM SIGPLAN notices - POPL '16.\n<line7>2016;51(1):555-67 <https://doi.org/10.1145/2914770.2837654>; draft at\n<line8><https://cseweb.ucsd.edu/~lerner/papers/fp-printing-popl16.pdf>.  */\n<line9>PROMOTED_FLOAT promoted_x = x;\n<line10>char format[sizeof "%-+ 0*.*Lg"];\n<line11>FLOAT abs_x = x < 0 ? -x : x;\n<line12>int prec;\n<line13>char *p = format;\n<line14>*p++ = '%';\n<line15>/* Support flags that generate output parsable by strtof.  */\n<line16>*p = '-'; p += (flags & FTOASTR_LEFT_JUSTIFY  ) != 0;\n<line17>*p = '+'; p += (flags & FTOASTR_ALWAYS_SIGNED ) != 0;\n<line18>*p = ' '; p += (flags & FTOASTR_SPACE_POSITIVE) != 0;\n<line19>*p = '0'; p += (flags & FTOASTR_ZERO_PAD      ) != 0;\n<line20>*p++ = '*';\n<line21>*p++ = '.';\n<line22>*p++ = '*';\n<line23>*p = 'L'; p += 2 < LENGTH;\n<line24>*p++ = flags & FTOASTR_UPPER_E ? 'G' : 'g';\n<line25>*p = '\0';\n<line26>for (prec = abs_x < FLOAT_MIN ? 1 : FLOAT_DIG; ; prec++)\n<line27>{\n<line28>int n = snprintf (buf, bufsize, format, width, prec, promoted_x);\n<line29>if (n < 0\n<line30>|| FLOAT_PREC_BOUND <= prec\n<line31>|| (n < bufsize && STRTOF (buf, NULL) == x))\n<line32>return n;\n<line33>}\n<line34>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/fts.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
In file included from /home/huihui/Downloads/coreutils-9.4/lib/fts.c:53:
In file included from ./lib/fts_.h:83:
./lib/i-ring.h:24:32: warning: '_Static_assert' with no message is a C2x extension [-Wc2x-extensions]
static_assert (1 <= I_RING_SIZE);
                               ^
                               , ""
2 warnings generated.
Function: fd_ring_clear
Content: <line0>static void\n<line1>fd_ring_clear (I_ring *fd_ring)\n<line2>{\n<line3>while ( ! i_ring_empty (fd_ring))\n<line4>{\n<line5>int fd = i_ring_pop (fd_ring);\n<line6>if (0 <= fd)\n<line7>close (fd);\n<line8>}\n<line9>}
----------------------------------------
Function: fts_set_stat_required
Content: <line0>static void\n<line1>fts_set_stat_required (FTSENT *p, bool required)\n<line2>{\n<line3>fts_assert (p->fts_info == FTS_NSOK);\n<line4>p->fts_statp->st_size = (required\n<line5>? FTS_STAT_REQUIRED\n<line6>: FTS_NO_STAT_REQUIRED);\n<line7>}
----------------------------------------
Function: cwd_advance_fd
Content: <line0>static void\n<line1>internal_function\n<line2>cwd_advance_fd (FTS *sp, int fd, bool chdir_down_one)\n<line3>{\n<line4>int old = sp->fts_cwd_fd;\n<line5>fts_assert (old != fd || old == AT_FDCWD);\n<line6>if (chdir_down_one)\n<line7>{\n<line8>/* Push "old" onto the ring.\n<line9>If the displaced file descriptor is non-negative, close it.  */\n<line10>int prev_fd_in_slot = i_ring_push (&sp->fts_fd_ring, old);\n<line11>fd_ring_print (sp, stderr, "post-push");\n<line12>if (0 <= prev_fd_in_slot)\n<line13>close (prev_fd_in_slot); /* ignore any close failure */\n<line14>}\n<line15>else if ( ! ISSET (FTS_NOCHDIR))\n<line16>{\n<line17>if (0 <= old)\n<line18>close (old); /* ignore any close failure */\n<line19>}\n<line20>sp->fts_cwd_fd = fd;\n<line21>}
----------------------------------------
Function: restore_initial_cwd
Content: <line0>static int\n<line1>restore_initial_cwd (FTS *sp)\n<line2>{\n<line3>int fail = FCHDIR (sp, ISSET (FTS_CWDFD) ? AT_FDCWD : sp->fts_rfd);\n<line4>fd_ring_clear (&(sp->fts_fd_ring));\n<line5>return fail;\n<line6>}
----------------------------------------
Function: diropen
Content: <line0>static int\n<line1>internal_function\n<line2>diropen (FTS const *sp, char const *dir)\n<line3>{\n<line4>int open_flags = (O_SEARCH | O_CLOEXEC | O_DIRECTORY | O_NOCTTY | O_NONBLOCK\n<line5>| (ISSET (FTS_PHYSICAL) ? O_NOFOLLOW : 0));\n<line6>int fd = (ISSET (FTS_CWDFD)\n<line7>? openat (sp->fts_cwd_fd, dir, open_flags)\n<line8>: open (dir, open_flags));\n<line9>return fd;\n<line10>}
----------------------------------------
Function: rpl_fts_open
Content: <line0>FTS *\n<line1>fts_open (char * const *argv,\n<line2>register int options,\n<line3>int (*compar) (FTSENT const **, FTSENT const **))\n<line4>{\n<line5>register FTS *sp;\n<line6>register FTSENT *p, *root;\n<line7>register size_t nitems;\n<line8>FTSENT *parent = NULL;\n<line9>FTSENT *tmp = NULL;     /* pacify gcc */\n<line10>bool defer_stat;\n<line11>/* Options check. */\n<line12>if (options & ~FTS_OPTIONMASK) {\n<line13>__set_errno (EINVAL);\n<line14>return (NULL);\n<line15>}\n<line16>if ((options & FTS_NOCHDIR) && (options & FTS_CWDFD)) {\n<line17>__set_errno (EINVAL);\n<line18>return (NULL);\n<line19>}\n<line20>if ( ! (options & (FTS_LOGICAL | FTS_PHYSICAL))) {\n<line21>__set_errno (EINVAL);\n<line22>return (NULL);\n<line23>}\n<line24>/* Allocate/initialize the stream */\n<line25>sp = calloc (1, sizeof *sp);\n<line26>if (sp == NULL)\n<line27>return (NULL);\n<line28>sp->fts_compar = compar;\n<line29>sp->fts_options = options;\n<line30>/* Logical walks turn on NOCHDIR; symbolic links are too hard. */\n<line31>if (ISSET(FTS_LOGICAL)) {\n<line32>SET(FTS_NOCHDIR);\n<line33>CLR(FTS_CWDFD);\n<line34>}\n<line35>/* Initialize fts_cwd_fd.  */\n<line36>sp->fts_cwd_fd = AT_FDCWD;\n<line37>if ( ISSET(FTS_CWDFD) && ! HAVE_OPENAT_SUPPORT)\n<line38>{\n<line39>/* While it isn't technically necessary to open "." this\n<line40>early, doing it here saves us the trouble of ensuring\n<line41>later (where it'd be messier) that "." can in fact\n<line42>be opened.  If not, revert to FTS_NOCHDIR mode.  */\n<line43>int fd = open (".", O_SEARCH | O_CLOEXEC);\n<line44>if (fd < 0)\n<line45>{\n<line46>/* Even if "." is unreadable, don't revert to FTS_NOCHDIR mode\n<line47>on systems like Linux+PROC_FS, where our openat emulation\n<line48>is good enough.  Note: on a system that emulates\n<line49>openat via /proc, this technique can still fail, but\n<line50>only in extreme conditions, e.g., when the working\n<line51>directory cannot be saved (i.e. save_cwd fails) --\n<line52>and that happens on Linux only when "." is unreadable\n<line53>and the CWD would be longer than PATH_MAX.\n<line54>FIXME: once Linux kernel openat support is well established,\n<line55>replace the above open call and this entire if/else block\n<line56>with the body of the if-block below.  */\n<line57>if ( openat_needs_fchdir ())\n<line58>{\n<line59>SET(FTS_NOCHDIR);\n<line60>CLR(FTS_CWDFD);\n<line61>}\n<line62>}\n<line63>else\n<line64>{\n<line65>close (fd);\n<line66>}\n<line67>}\n<line68>/*\n<line69>* Start out with 1K of file name space, and enough, in any case,\n<line70>* to hold the user's file names.\n<line71>*/\n<line72>#ifndef MAXPATHLEN\n<line73># define MAXPATHLEN 1024\n<line74>#endif\n<line75>{\n<line76>size_t maxarglen = fts_maxarglen(argv);\n<line77>if (! fts_palloc(sp, MAX(maxarglen, MAXPATHLEN)))\n<line78>goto mem1;\n<line79>}\n<line80>/* Allocate/initialize root's parent. */\n<line81>if (*argv != NULL) {\n<line82>if ((parent = fts_alloc(sp, "", 0)) == NULL)\n<line83>goto mem2;\n<line84>parent->fts_level = FTS_ROOTPARENTLEVEL;\n<line85>}\n<line86>/* The classic fts implementation would call fts_stat with\n<line87>a new entry for each iteration of the loop below.\n<line88>If the comparison function is not specified or if the\n<line89>FTS_DEFER_STAT option is in effect, don't stat any entry\n<line90>in this loop.  This is an attempt to minimize the interval\n<line91>between the initial stat/lstat/fstatat and the point at which\n<line92>a directory argument is first opened.  This matters for any\n<line93>directory command line argument that resides on a file system\n<line94>without genuine i-nodes.  If you specify FTS_DEFER_STAT along\n<line95>with a comparison function, that function must not access any\n<line96>data via the fts_statp pointer.  */\n<line97>defer_stat = (compar == NULL || ISSET(FTS_DEFER_STAT));\n<line98>/* Allocate/initialize root(s). */\n<line99>for (root = NULL, nitems = 0; *argv != NULL; ++argv, ++nitems) {\n<line100>/* *Do* allow zero-length file names. */\n<line101>size_t len = strlen(*argv);\n<line102>if ( ! (options & FTS_VERBATIM))\n<line103>{\n<line104>/* If there are two or more trailing slashes, trim all but one,\n<line105>but don't change "//" to "/", and do map "///" to "/".  */\n<line106>char const *v = *argv;\n<line107>if (2 < len && v[len - 1] == '/')\n<line108>while (1 < len && v[len - 2] == '/')\n<line109>--len;\n<line110>}\n<line111>if ((p = fts_alloc(sp, *argv, len)) == NULL)\n<line112>goto mem3;\n<line113>p->fts_level = FTS_ROOTLEVEL;\n<line114>p->fts_parent = parent;\n<line115>p->fts_accpath = p->fts_name;\n<line116>/* Even when defer_stat is true, be sure to stat the first\n<line117>command line argument, since fts_read (at least with\n<line118>FTS_XDEV) requires that.  */\n<line119>if (defer_stat && root != NULL) {\n<line120>p->fts_info = FTS_NSOK;\n<line121>fts_set_stat_required(p, true);\n<line122>} else {\n<line123>p->fts_info = fts_stat(sp, p, false);\n<line124>}\n<line125>/*\n<line126>* If comparison routine supplied, traverse in sorted\n<line127>* order; otherwise traverse in the order specified.\n<line128>*/\n<line129>if (compar) {\n<line130>p->fts_link = root;\n<line131>root = p;\n<line132>} else {\n<line133>p->fts_link = NULL;\n<line134>if (root == NULL)\n<line135>tmp = root = p;\n<line136>else {\n<line137>tmp->fts_link = p;\n<line138>tmp = p;\n<line139>}\n<line140>}\n<line141>}\n<line142>if (compar && nitems > 1)\n<line143>root = fts_sort(sp, root, nitems);\n<line144>/*\n<line145>* Allocate a dummy pointer and make fts_read think that we've just\n<line146>* finished the node before the root(s); set p->fts_info to FTS_INIT\n<line147>* so that everything about the "current" node is ignored.\n<line148>*/\n<line149>if ((sp->fts_cur = fts_alloc(sp, "", 0)) == NULL)\n<line150>goto mem3;\n<line151>sp->fts_cur->fts_link = root;\n<line152>sp->fts_cur->fts_info = FTS_INIT;\n<line153>sp->fts_cur->fts_level = 1;\n<line154>if (! setup_dir (sp))\n<line155>goto mem3;\n<line156>/*\n<line157>* If using chdir(2), grab a file descriptor pointing to dot to ensure\n<line158>* that we can get back here; this could be avoided for some file names,\n<line159>* but almost certainly not worth the effort.  Slashes, symbolic links,\n<line160>* and ".." are all fairly nasty problems.  Note, if we can't get the\n<line161>* descriptor we run anyway, just more slowly.\n<line162>*/\n<line163>if (!ISSET(FTS_NOCHDIR) && !ISSET(FTS_CWDFD)\n<line164>&& (sp->fts_rfd = diropen (sp, ".")) < 0)\n<line165>SET(FTS_NOCHDIR);\n<line166>i_ring_init (&sp->fts_fd_ring, -1);\n<line167>return (sp);\n<line168>mem3:   fts_lfree(root);\n<line169>free(parent);\n<line170>mem2:   free(sp->fts_path);\n<line171>mem1:   free(sp);\n<line172>return (NULL);\n<line173>}
----------------------------------------
Function: fts_load
Content: <line0>static void\n<line1>internal_function\n<line2>fts_load (FTS *sp, register FTSENT *p)\n<line3>{\n<line4>register size_t len;\n<line5>register char *cp;\n<line6>/*\n<line7>* Load the stream structure for the next traversal.  Since we don't\n<line8>* actually enter the directory until after the preorder visit, set\n<line9>* the fts_accpath field specially so the chdir gets done to the right\n<line10>* place and the user can access the first node.  From fts_open it's\n<line11>* known that the file name will fit.\n<line12>*/\n<line13>len = p->fts_pathlen = p->fts_namelen;\n<line14>memmove(sp->fts_path, p->fts_name, len + 1);\n<line15>if ((cp = strrchr(p->fts_name, '/')) && (cp != p->fts_name || cp[1])) {\n<line16>len = strlen(++cp);\n<line17>memmove(p->fts_name, cp, len + 1);\n<line18>p->fts_namelen = len;\n<line19>}\n<line20>p->fts_accpath = p->fts_path = sp->fts_path;\n<line21>}
----------------------------------------
Function: rpl_fts_close
Content: <line0>int\n<line1>fts_close (FTS *sp)\n<line2>{\n<line3>register FTSENT *freep, *p;\n<line4>int saved_errno = 0;\n<line5>/*\n<line6>* This still works if we haven't read anything -- the dummy structure\n<line7>* points to the root list, so we step through to the end of the root\n<line8>* list which has a valid parent pointer.\n<line9>*/\n<line10>if (sp->fts_cur) {\n<line11>for (p = sp->fts_cur; p->fts_level >= FTS_ROOTLEVEL;) {\n<line12>freep = p;\n<line13>p = p->fts_link != NULL ? p->fts_link : p->fts_parent;\n<line14>free(freep);\n<line15>}\n<line16>free(p);\n<line17>}\n<line18>/* Free up child linked list, sort array, file name buffer. */\n<line19>if (sp->fts_child)\n<line20>fts_lfree(sp->fts_child);\n<line21>free(sp->fts_array);\n<line22>free(sp->fts_path);\n<line23>if (ISSET(FTS_CWDFD))\n<line24>{\n<line25>if (0 <= sp->fts_cwd_fd)\n<line26>if (close (sp->fts_cwd_fd))\n<line27>saved_errno = errno;\n<line28>}\n<line29>else if (!ISSET(FTS_NOCHDIR))\n<line30>{\n<line31>/* Return to original directory, save errno if necessary. */\n<line32>if (fchdir(sp->fts_rfd))\n<line33>saved_errno = errno;\n<line34>/* If close fails, record errno only if saved_errno is zero,\n<line35>so that we report the probably-more-meaningful fchdir errno.  */\n<line36>if (close (sp->fts_rfd))\n<line37>if (saved_errno == 0)\n<line38>saved_errno = errno;\n<line39>}\n<line40>fd_ring_clear (&sp->fts_fd_ring);\n<line41>if (sp->fts_leaf_optimization_works_ht)\n<line42>hash_free (sp->fts_leaf_optimization_works_ht);\n<line43>free_dir (sp);\n<line44>/* Free up the stream pointer. */\n<line45>free(sp);\n<line46>/* Set errno and return. */\n<line47>if (saved_errno) {\n<line48>__set_errno (saved_errno);\n<line49>return (-1);\n<line50>}\n<line51>return (0);\n<line52>}
----------------------------------------
Function: dev_type_hash
Content: <line0>static size_t\n<line1>dev_type_hash (void const *x, size_t table_size)\n<line2>{\n<line3>struct dev_type const *ax = x;\n<line4>uintmax_t dev = ax->st_dev;\n<line5>return dev % table_size;\n<line6>}
----------------------------------------
Function: dev_type_compare
Content: <line0>static bool\n<line1>dev_type_compare (void const *x, void const *y)\n<line2>{\n<line3>struct dev_type const *ax = x;\n<line4>struct dev_type const *ay = y;\n<line5>return ax->st_dev == ay->st_dev;\n<line6>}
----------------------------------------
Function: filesystem_type
Content: <line0>static fsword\n<line1>filesystem_type (FTSENT const *p, int fd)\n<line2>{\n<line3>FTS *sp = p->fts_fts;\n<line4>Hash_table *h = sp->fts_leaf_optimization_works_ht;\n<line5>struct dev_type *ent;\n<line6>struct statfs fs_buf;\n<line7>/* If we're not in CWDFD mode, don't bother with this optimization,\n<line8>since the caller is not serious about performance.  */\n<line9>if (!ISSET (FTS_CWDFD))\n<line10>return 0;\n<line11>if (! h)\n<line12>h = sp->fts_leaf_optimization_works_ht\n<line13>= hash_initialize (DEV_TYPE_HT_INITIAL_SIZE, NULL, dev_type_hash,\n<line14>dev_type_compare, free);\n<line15>if (h)\n<line16>{\n<line17>struct dev_type tmp;\n<line18>tmp.st_dev = p->fts_statp->st_dev;\n<line19>ent = hash_lookup (h, &tmp);\n<line20>if (ent)\n<line21>return ent->f_type;\n<line22>}\n<line23>/* Look-up failed.  Query directly and cache the result.  */\n<line24>if (fd < 0 || fstatfs (fd, &fs_buf) != 0)\n<line25>return 0;\n<line26>if (h)\n<line27>{\n<line28>struct dev_type *t2 = malloc (sizeof *t2);\n<line29>if (t2)\n<line30>{\n<line31>t2->st_dev = p->fts_statp->st_dev;\n<line32>t2->f_type = fs_buf.f_type;\n<line33>ent = hash_insert (h, t2);\n<line34>if (ent)\n<line35>fts_assert (ent == t2);\n<line36>else\n<line37>free (t2);\n<line38>}\n<line39>}\n<line40>return fs_buf.f_type;\n<line41>}
----------------------------------------
Function: dirent_inode_sort_may_be_useful
Content: <line0>static bool\n<line1>dirent_inode_sort_may_be_useful (FTSENT const *p, int dir_fd)\n<line2>{\n<line3>/* Skip the sort only if we can determine efficiently\n<line4>that skipping it is the right thing to do.\n<line5>The cost of performing an unnecessary sort is negligible,\n<line6>while the cost of *not* performing it can be O(N^2) with\n<line7>a very large constant.  */\n<line8>switch (filesystem_type (p, dir_fd))\n<line9>{\n<line10>case S_MAGIC_CIFS:\n<line11>case S_MAGIC_NFS:\n<line12>case S_MAGIC_TMPFS:\n<line13>/* On a file system of any of these types, sorting\n<line14>is unnecessary, and hence wasteful.  */\n<line15>return false;\n<line16>default:\n<line17>return true;\n<line18>}\n<line19>}
----------------------------------------
Function: leaf_optimization
Content: <line0>static enum leaf_optimization\n<line1>leaf_optimization (FTSENT const *p, int dir_fd)\n<line2>{\n<line3>switch (filesystem_type (p, dir_fd))\n<line4>{\n<line5>case 0:\n<line6>/* Leaf optimization is unsafe if the file system type is unknown.  */\n<line7>FALLTHROUGH;\n<line8>case S_MAGIC_AFS:\n<line9>/* Although AFS mount points are not counted in st_nlink, they\n<line10>act like directories.  See <https://bugs.debian.org/143111>.  */\n<line11>FALLTHROUGH;\n<line12>case S_MAGIC_CIFS:\n<line13>/* Leaf optimization causes 'find' to abort.  See\n<line14><https://lists.gnu.org/r/bug-gnulib/2018-04/msg00015.html>.  */\n<line15>FALLTHROUGH;\n<line16>case S_MAGIC_NFS:\n<line17>/* NFS provides usable dirent.d_type but not necessarily for all entries\n<line18>of large directories, so as per <https://bugzilla.redhat.com/1252549>\n<line19>NFS should return true.  However st_nlink values are not accurate on\n<line20>all implementations as per <https://bugzilla.redhat.com/1299169>.  */\n<line21>FALLTHROUGH;\n<line22>case S_MAGIC_PROC:\n<line23>/* Per <https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=143111> /proc\n<line24>may have bogus stat.st_nlink values.  */\n<line25>return NO_LEAF_OPTIMIZATION;\n<line26>default:\n<line27>return OK_LEAF_OPTIMIZATION;\n<line28>}\n<line29>}
----------------------------------------
Function: rpl_fts_read
Content: <line0>FTSENT *\n<line1>fts_read (register FTS *sp)\n<line2>{\n<line3>register FTSENT *p, *tmp;\n<line4>register unsigned short int instr;\n<line5>register char *t;\n<line6>/* If finished or unrecoverable error, return NULL. */\n<line7>if (sp->fts_cur == NULL || ISSET(FTS_STOP))\n<line8>return (NULL);\n<line9>/* Set current node pointer. */\n<line10>p = sp->fts_cur;\n<line11>/* Save and zero out user instructions. */\n<line12>instr = p->fts_instr;\n<line13>p->fts_instr = FTS_NOINSTR;\n<line14>/* Any type of file may be re-visited; re-stat and re-turn. */\n<line15>if (instr == FTS_AGAIN) {\n<line16>p->fts_info = fts_stat(sp, p, false);\n<line17>return (p);\n<line18>}\n<line19>Dprintf (("fts_read: p=%s\n",\n<line20>p->fts_info == FTS_INIT ? "" : p->fts_path));\n<line21>/*\n<line22>* Following a symlink -- SLNONE test allows application to see\n<line23>* SLNONE and recover.  If indirecting through a symlink, have\n<line24>* keep a pointer to current location.  If unable to get that\n<line25>* pointer, follow fails.\n<line26>*/\n<line27>if (instr == FTS_FOLLOW &&\n<line28>(p->fts_info == FTS_SL || p->fts_info == FTS_SLNONE)) {\n<line29>p->fts_info = fts_stat(sp, p, true);\n<line30>if (p->fts_info == FTS_D && !ISSET(FTS_NOCHDIR)) {\n<line31>if ((p->fts_symfd = diropen (sp, ".")) < 0) {\n<line32>p->fts_errno = errno;\n<line33>p->fts_info = FTS_ERR;\n<line34>} else\n<line35>p->fts_flags |= FTS_SYMFOLLOW;\n<line36>}\n<line37>goto check_for_dir;\n<line38>}\n<line39>/* Directory in pre-order. */\n<line40>if (p->fts_info == FTS_D) {\n<line41>/* If skipped or crossed mount point, do post-order visit. */\n<line42>if (instr == FTS_SKIP ||\n<line43>(ISSET(FTS_XDEV) && p->fts_statp->st_dev != sp->fts_dev)) {\n<line44>if (p->fts_flags & FTS_SYMFOLLOW)\n<line45>(void)close(p->fts_symfd);\n<line46>if (sp->fts_child) {\n<line47>fts_lfree(sp->fts_child);\n<line48>sp->fts_child = NULL;\n<line49>}\n<line50>p->fts_info = FTS_DP;\n<line51>LEAVE_DIR (sp, p, "1");\n<line52>return (p);\n<line53>}\n<line54>/* Rebuild if only read the names and now traversing. */\n<line55>if (sp->fts_child != NULL && ISSET(FTS_NAMEONLY)) {\n<line56>CLR(FTS_NAMEONLY);\n<line57>fts_lfree(sp->fts_child);\n<line58>sp->fts_child = NULL;\n<line59>}\n<line60>/*\n<line61>* Cd to the subdirectory.\n<line62>*\n<line63>* If have already read and now fail to chdir, whack the list\n<line64>* to make the names come out right, and set the parent errno\n<line65>* so the application will eventually get an error condition.\n<line66>* Set the FTS_DONTCHDIR flag so that when we logically change\n<line67>* directories back to the parent we don't do a chdir.\n<line68>*\n<line69>* If haven't read do so.  If the read fails, fts_build sets\n<line70>* FTS_STOP or the fts_info field of the node.\n<line71>*/\n<line72>if (sp->fts_child != NULL) {\n<line73>if (fts_safe_changedir(sp, p, -1, p->fts_accpath)) {\n<line74>p->fts_errno = errno;\n<line75>p->fts_flags |= FTS_DONTCHDIR;\n<line76>for (p = sp->fts_child; p != NULL;\n<line77>p = p->fts_link)\n<line78>p->fts_accpath =\n<line79>p->fts_parent->fts_accpath;\n<line80>}\n<line81>} else if ((sp->fts_child = fts_build(sp, BREAD)) == NULL) {\n<line82>if (ISSET(FTS_STOP))\n<line83>return (NULL);\n<line84>/* If fts_build's call to fts_safe_changedir failed\n<line85>because it was not able to fchdir into a\n<line86>subdirectory, tell the caller.  */\n<line87>if (p->fts_errno && p->fts_info != FTS_DNR)\n<line88>p->fts_info = FTS_ERR;\n<line89>LEAVE_DIR (sp, p, "2");\n<line90>return (p);\n<line91>}\n<line92>p = sp->fts_child;\n<line93>sp->fts_child = NULL;\n<line94>goto name;\n<line95>}\n<line96>/* Move to the next node on this level. */\n<line97>next:   tmp = p;\n<line98>/* If we have so many directory entries that we're reading them\n<line99>in batches, and we've reached the end of the current batch,\n<line100>read in a new batch.  */\n<line101>if (p->fts_link == NULL && p->fts_parent->fts_dirp)\n<line102>{\n<line103>p = tmp->fts_parent;\n<line104>sp->fts_cur = p;\n<line105>sp->fts_path[p->fts_pathlen] = '\0';\n<line106>if ((p = fts_build (sp, BREAD)) == NULL)\n<line107>{\n<line108>if (ISSET(FTS_STOP))\n<line109>return NULL;\n<line110>goto cd_dot_dot;\n<line111>}\n<line112>free(tmp);\n<line113>goto name;\n<line114>}\n<line115>if ((p = p->fts_link) != NULL) {\n<line116>sp->fts_cur = p;\n<line117>free(tmp);\n<line118>/*\n<line119>* If reached the top, return to the original directory (or\n<line120>* the root of the tree), and load the file names for the next\n<line121>* root.\n<line122>*/\n<line123>if (p->fts_level == FTS_ROOTLEVEL) {\n<line124>if (restore_initial_cwd(sp)) {\n<line125>SET(FTS_STOP);\n<line126>return (NULL);\n<line127>}\n<line128>free_dir(sp);\n<line129>fts_load(sp, p);\n<line130>if (! setup_dir(sp)) {\n<line131>free_dir(sp);\n<line132>return (NULL);\n<line133>}\n<line134>goto check_for_dir;\n<line135>}\n<line136>/*\n<line137>* User may have called fts_set on the node.  If skipped,\n<line138>* ignore.  If followed, get a file descriptor so we can\n<line139>* get back if necessary.\n<line140>*/\n<line141>if (p->fts_instr == FTS_SKIP)\n<line142>goto next;\n<line143>if (p->fts_instr == FTS_FOLLOW) {\n<line144>p->fts_info = fts_stat(sp, p, true);\n<line145>if (p->fts_info == FTS_D && !ISSET(FTS_NOCHDIR)) {\n<line146>if ((p->fts_symfd = diropen (sp, ".")) < 0) {\n<line147>p->fts_errno = errno;\n<line148>p->fts_info = FTS_ERR;\n<line149>} else\n<line150>p->fts_flags |= FTS_SYMFOLLOW;\n<line151>}\n<line152>p->fts_instr = FTS_NOINSTR;\n<line153>}\n<line154>name:           t = sp->fts_path + NAPPEND(p->fts_parent);\n<line155>*t++ = '/';\n<line156>memmove(t, p->fts_name, p->fts_namelen + 1);\n<line157>check_for_dir:\n<line158>sp->fts_cur = p;\n<line159>if (p->fts_info == FTS_NSOK)\n<line160>{\n<line161>if (p->fts_statp->st_size == FTS_STAT_REQUIRED)\n<line162>p->fts_info = fts_stat(sp, p, false);\n<line163>else\n<line164>fts_assert (p->fts_statp->st_size == FTS_NO_STAT_REQUIRED);\n<line165>}\n<line166>if (p->fts_info == FTS_D)\n<line167>{\n<line168>/* Now that P->fts_statp is guaranteed to be valid,\n<line169>if this is a command-line directory, record its\n<line170>device number, to be used for FTS_XDEV.  */\n<line171>if (p->fts_level == FTS_ROOTLEVEL)\n<line172>sp->fts_dev = p->fts_statp->st_dev;\n<line173>Dprintf (("  entering: %s\n", p->fts_path));\n<line174>if (! enter_dir (sp, p))\n<line175>return NULL;\n<line176>}\n<line177>return p;\n<line178>}\n<line179>cd_dot_dot:\n<line180>/* Move up to the parent node. */\n<line181>p = tmp->fts_parent;\n<line182>sp->fts_cur = p;\n<line183>free(tmp);\n<line184>if (p->fts_level == FTS_ROOTPARENTLEVEL) {\n<line185>/*\n<line186>* Done; free everything up and set errno to 0 so the user\n<line187>* can distinguish between error and EOF.\n<line188>*/\n<line189>free(p);\n<line190>__set_errno (0);\n<line191>return (sp->fts_cur = NULL);\n<line192>}\n<line193>fts_assert (p->fts_info != FTS_NSOK);\n<line194>/* NUL terminate the file name.  */\n<line195>sp->fts_path[p->fts_pathlen] = '\0';\n<line196>/*\n<line197>* Return to the parent directory.  If at a root node, restore\n<line198>* the initial working directory.  If we came through a symlink,\n<line199>* go back through the file descriptor.  Otherwise, move up\n<line200>* one level, via "..".\n<line201>*/\n<line202>if (p->fts_level == FTS_ROOTLEVEL) {\n<line203>if (restore_initial_cwd(sp)) {\n<line204>p->fts_errno = errno;\n<line205>SET(FTS_STOP);\n<line206>}\n<line207>} else if (p->fts_flags & FTS_SYMFOLLOW) {\n<line208>if (FCHDIR(sp, p->fts_symfd)) {\n<line209>p->fts_errno = errno;\n<line210>SET(FTS_STOP);\n<line211>}\n<line212>(void)close(p->fts_symfd);\n<line213>} else if (!(p->fts_flags & FTS_DONTCHDIR) &&\n<line214>fts_safe_changedir(sp, p->fts_parent, -1, "..")) {\n<line215>p->fts_errno = errno;\n<line216>SET(FTS_STOP);\n<line217>}\n<line218>/* If the directory causes a cycle, preserve the FTS_DC flag and keep\n<line219>the corresponding dev/ino pair in the hash table.  It is going to be\n<line220>removed when leaving the original directory.  */\n<line221>if (p->fts_info != FTS_DC) {\n<line222>p->fts_info = p->fts_errno ? FTS_ERR : FTS_DP;\n<line223>if (p->fts_errno == 0)\n<line224>LEAVE_DIR (sp, p, "3");\n<line225>}\n<line226>return ISSET(FTS_STOP) ? NULL : p;\n<line227>}
----------------------------------------
Function: rpl_fts_set
Content: <line0>int\n<line1>fts_set(_GL_UNUSED FTS *sp, FTSENT *p, int instr)\n<line2>{\n<line3>if (instr != 0 && instr != FTS_AGAIN && instr != FTS_FOLLOW &&\n<line4>instr != FTS_NOINSTR && instr != FTS_SKIP) {\n<line5>__set_errno (EINVAL);\n<line6>return (1);\n<line7>}\n<line8>p->fts_instr = instr;\n<line9>return (0);\n<line10>}
----------------------------------------
Function: rpl_fts_children
Content: <line0>FTSENT *\n<line1>fts_children (register FTS *sp, int instr)\n<line2>{\n<line3>register FTSENT *p;\n<line4>int fd;\n<line5>if (instr != 0 && instr != FTS_NAMEONLY) {\n<line6>__set_errno (EINVAL);\n<line7>return (NULL);\n<line8>}\n<line9>/* Set current node pointer. */\n<line10>p = sp->fts_cur;\n<line11>/*\n<line12>* Errno set to 0 so user can distinguish empty directory from\n<line13>* an error.\n<line14>*/\n<line15>__set_errno (0);\n<line16>/* Fatal errors stop here. */\n<line17>if (ISSET(FTS_STOP))\n<line18>return (NULL);\n<line19>/* Return logical hierarchy of user's arguments. */\n<line20>if (p->fts_info == FTS_INIT)\n<line21>return (p->fts_link);\n<line22>/*\n<line23>* If not a directory being visited in pre-order, stop here.  Could\n<line24>* allow FTS_DNR, assuming the user has fixed the problem, but the\n<line25>* same effect is available with FTS_AGAIN.\n<line26>*/\n<line27>if (p->fts_info != FTS_D /* && p->fts_info != FTS_DNR */)\n<line28>return (NULL);\n<line29>/* Free up any previous child list. */\n<line30>if (sp->fts_child != NULL)\n<line31>fts_lfree(sp->fts_child);\n<line32>if (instr == FTS_NAMEONLY) {\n<line33>SET(FTS_NAMEONLY);\n<line34>instr = BNAMES;\n<line35>} else\n<line36>instr = BCHILD;\n<line37>/*\n<line38>* If using chdir on a relative file name and called BEFORE fts_read\n<line39>* does its chdir to the root of a traversal, we can lose -- we need to\n<line40>* chdir into the subdirectory, and we don't know where the current\n<line41>* directory is, so we can't get back so that the upcoming chdir by\n<line42>* fts_read will work.\n<line43>*/\n<line44>if (p->fts_level != FTS_ROOTLEVEL || p->fts_accpath[0] == '/' ||\n<line45>ISSET(FTS_NOCHDIR))\n<line46>return (sp->fts_child = fts_build(sp, instr));\n<line47>if ((fd = diropen (sp, ".")) < 0)\n<line48>return (sp->fts_child = NULL);\n<line49>sp->fts_child = fts_build(sp, instr);\n<line50>if (ISSET(FTS_CWDFD))\n<line51>{\n<line52>cwd_advance_fd (sp, fd, true);\n<line53>}\n<line54>else\n<line55>{\n<line56>if (fchdir(fd))\n<line57>{\n<line58>int saved_errno = errno;\n<line59>close (fd);\n<line60>__set_errno (saved_errno);\n<line61>return NULL;\n<line62>}\n<line63>close (fd);\n<line64>}\n<line65>return (sp->fts_child);\n<line66>}
----------------------------------------
Function: fts_compare_ino
Content: <line0>static int\n<line1>fts_compare_ino (struct _ftsent const **a, struct _ftsent const **b)\n<line2>{\n<line3>return _GL_CMP (a[0]->fts_statp->st_ino, b[0]->fts_statp->st_ino);\n<line4>}
----------------------------------------
Function: set_stat_type
Content: <line0>static void\n<line1>set_stat_type (struct stat *st, unsigned int dtype)\n<line2>{\n<line3>mode_t type;\n<line4>switch (dtype)\n<line5>{\n<line6>case DT_BLK:\n<line7>type = S_IFBLK;\n<line8>break;\n<line9>case DT_CHR:\n<line10>type = S_IFCHR;\n<line11>break;\n<line12>case DT_DIR:\n<line13>type = S_IFDIR;\n<line14>break;\n<line15>case DT_FIFO:\n<line16>type = S_IFIFO;\n<line17>break;\n<line18>case DT_LNK:\n<line19>type = S_IFLNK;\n<line20>break;\n<line21>case DT_REG:\n<line22>type = S_IFREG;\n<line23>break;\n<line24>case DT_SOCK:\n<line25>type = S_IFSOCK;\n<line26>break;\n<line27>default:\n<line28>type = 0;\n<line29>}\n<line30>st->st_mode = type;\n<line31>}
----------------------------------------
Function: fts_build
Content: <line0>static FTSENT *\n<line1>internal_function\n<line2>fts_build (register FTS *sp, int type)\n<line3>{\n<line4>register FTSENT *p, *head;\n<line5>register size_t nitems;\n<line6>FTSENT *tail;\n<line7>int saved_errno;\n<line8>bool descend;\n<line9>bool doadjust;\n<line10>ptrdiff_t level;\n<line11>size_t len, maxlen, new_len;\n<line12>char *cp;\n<line13>int dir_fd;\n<line14>FTSENT *cur = sp->fts_cur;\n<line15>bool continue_readdir = !!cur->fts_dirp;\n<line16>bool sort_by_inode = false;\n<line17>size_t max_entries;\n<line18>/* When cur->fts_dirp is non-NULL, that means we should\n<line19>continue calling readdir on that existing DIR* pointer\n<line20>rather than opening a new one.  */\n<line21>if (continue_readdir)\n<line22>{\n<line23>DIR *dp = cur->fts_dirp;\n<line24>dir_fd = dirfd (dp);\n<line25>if (dir_fd < 0)\n<line26>{\n<line27>int dirfd_errno = errno;\n<line28>closedir_and_clear (cur->fts_dirp);\n<line29>if (type == BREAD)\n<line30>{\n<line31>cur->fts_info = FTS_DNR;\n<line32>cur->fts_errno = dirfd_errno;\n<line33>}\n<line34>return NULL;\n<line35>}\n<line36>}\n<line37>else\n<line38>{\n<line39>/* Open the directory for reading.  If this fails, we're done.\n<line40>If being called from fts_read, set the fts_info field. */\n<line41>if ((cur->fts_dirp = fts_opendir(cur->fts_accpath, &dir_fd)) == NULL)\n<line42>{\n<line43>if (type == BREAD)\n<line44>{\n<line45>cur->fts_info = FTS_DNR;\n<line46>cur->fts_errno = errno;\n<line47>}\n<line48>return NULL;\n<line49>}\n<line50>/* Rather than calling fts_stat for each and every entry encountered\n<line51>in the readdir loop (below), stat each directory only right after\n<line52>opening it.  */\n<line53>bool stat_optimization = cur->fts_info == FTS_NSOK;\n<line54>if (stat_optimization\n<line55>/* Also read the stat info again after opening a directory to\n<line56>reveal eventual changes caused by a submount triggered by\n<line57>the traversal.  But do it only for utilities which use\n<line58>FTS_TIGHT_CYCLE_CHECK.  Therefore, only find and du\n<line59>benefit/suffer from this feature for now.  */\n<line60>|| ISSET (FTS_TIGHT_CYCLE_CHECK))\n<line61>{\n<line62>if (!stat_optimization)\n<line63>LEAVE_DIR (sp, cur, "4");\n<line64>if (fstat (dir_fd, cur->fts_statp) != 0)\n<line65>{\n<line66>int fstat_errno = errno;\n<line67>closedir_and_clear (cur->fts_dirp);\n<line68>if (type == BREAD)\n<line69>{\n<line70>cur->fts_errno = fstat_errno;\n<line71>cur->fts_info = FTS_NS;\n<line72>}\n<line73>__set_errno (fstat_errno);\n<line74>return NULL;\n<line75>}\n<line76>if (stat_optimization)\n<line77>cur->fts_info = FTS_D;\n<line78>else if (! enter_dir (sp, cur))\n<line79>{\n<line80>int err = errno;\n<line81>closedir_and_clear (cur->fts_dirp);\n<line82>__set_errno (err);\n<line83>return NULL;\n<line84>}\n<line85>}\n<line86>}\n<line87>/* Maximum number of readdir entries to read at one time.  This\n<line88>limitation is to avoid reading millions of entries into memory\n<line89>at once.  When an fts_compar function is specified, we have no\n<line90>choice: we must read all entries into memory before calling that\n<line91>function.  But when no such function is specified, we can read\n<line92>entries in batches that are large enough to help us with inode-\n<line93>sorting, yet not so large that we risk exhausting memory.  */\n<line94>max_entries = sp->fts_compar ? SIZE_MAX : FTS_MAX_READDIR_ENTRIES;\n<line95>/*\n<line96>* If we're going to need to stat anything or we want to descend\n<line97>* and stay in the directory, chdir.  If this fails we keep going,\n<line98>* but set a flag so we don't chdir after the post-order visit.\n<line99>* We won't be able to stat anything, but we can still return the\n<line100>* names themselves.  Note, that since fts_read won't be able to\n<line101>* chdir into the directory, it will have to return different file\n<line102>* names than before, i.e. "a/b" instead of "b".  Since the node\n<line103>* has already been visited in pre-order, have to wait until the\n<line104>* post-order visit to return the error.  There is a special case\n<line105>* here, if there was nothing to stat then it's not an error to\n<line106>* not be able to stat.  This is all fairly nasty.  If a program\n<line107>* needed sorted entries or stat information, they had better be\n<line108>* checking FTS_NS on the returned nodes.\n<line109>*/\n<line110>if (continue_readdir)\n<line111>{\n<line112>/* When resuming a short readdir run, we already have\n<line113>the required dirp and dir_fd.  */\n<line114>descend = true;\n<line115>}\n<line116>else\n<line117>{\n<line118>/* Try to descend unless it is a names-only fts_children,\n<line119>or the directory is known to lack subdirectories.  */\n<line120>descend = (type != BNAMES\n<line121>&& ! (ISSET (FTS_NOSTAT) && ISSET (FTS_PHYSICAL)\n<line122>&& ! ISSET (FTS_SEEDOT)\n<line123>&& cur->fts_statp->st_nlink == MIN_DIR_NLINK\n<line124>&& (leaf_optimization (cur, dir_fd)\n<line125>!= NO_LEAF_OPTIMIZATION)));\n<line126>if (descend || type == BREAD)\n<line127>{\n<line128>if (ISSET(FTS_CWDFD))\n<line129>dir_fd = fcntl (dir_fd, F_DUPFD_CLOEXEC, STDERR_FILENO + 1);\n<line130>if (dir_fd < 0 || fts_safe_changedir(sp, cur, dir_fd, NULL)) {\n<line131>if (descend && type == BREAD)\n<line132>cur->fts_errno = errno;\n<line133>cur->fts_flags |= FTS_DONTCHDIR;\n<line134>descend = false;\n<line135>closedir_and_clear(cur->fts_dirp);\n<line136>if (ISSET(FTS_CWDFD) && 0 <= dir_fd)\n<line137>close (dir_fd);\n<line138>cur->fts_dirp = NULL;\n<line139>} else\n<line140>descend = true;\n<line141>}\n<line142>}\n<line143>/*\n<line144>* Figure out the max file name length that can be stored in the\n<line145>* current buffer -- the inner loop allocates more space as necessary.\n<line146>* We really wouldn't have to do the maxlen calculations here, we\n<line147>* could do them in fts_read before returning the name, but it's a\n<line148>* lot easier here since the length is part of the dirent structure.\n<line149>*\n<line150>* If not changing directories set a pointer so that can just append\n<line151>* each new component into the file name.\n<line152>*/\n<line153>len = NAPPEND(cur);\n<line154>if (ISSET(FTS_NOCHDIR)) {\n<line155>cp = sp->fts_path + len;\n<line156>*cp++ = '/';\n<line157>} else {\n<line158>/* GCC, you're too verbose. */\n<line159>cp = NULL;\n<line160>}\n<line161>len++;\n<line162>maxlen = sp->fts_pathlen - len;\n<line163>level = cur->fts_level + 1;\n<line164>/* Read the directory, attaching each entry to the "link" pointer. */\n<line165>doadjust = false;\n<line166>head = NULL;\n<line167>tail = NULL;\n<line168>nitems = 0;\n<line169>while (cur->fts_dirp) {\n<line170>size_t d_namelen;\n<line171>__set_errno (0);\n<line172>struct dirent *dp = readdir(cur->fts_dirp);\n<line173>if (dp == NULL) {\n<line174>if (errno) {\n<line175>cur->fts_errno = errno;\n<line176>/* If we've not read any items yet, treat\n<line177>the error as if we can't access the dir.  */\n<line178>cur->fts_info = (continue_readdir || nitems)\n<line179>? FTS_ERR : FTS_DNR;\n<line180>}\n<line181>closedir_and_clear(cur->fts_dirp);\n<line182>break;\n<line183>}\n<line184>if (!ISSET(FTS_SEEDOT) && ISDOT(dp->d_name))\n<line185>continue;\n<line186>d_namelen = _D_EXACT_NAMLEN (dp);\n<line187>p = fts_alloc (sp, dp->d_name, d_namelen);\n<line188>if (!p)\n<line189>goto mem1;\n<line190>if (d_namelen >= maxlen) {\n<line191>/* include space for NUL */\n<line192>uintptr_t oldaddr = (uintptr_t) sp->fts_path;\n<line193>if (! fts_palloc(sp, d_namelen + len + 1)) {\n<line194>/*\n<line195>* No more memory.  Save\n<line196>* errno, free up the current structure and the\n<line197>* structures already allocated.\n<line198>*/\n<line199>mem1:                           saved_errno = errno;\n<line200>free(p);\n<line201>fts_lfree(head);\n<line202>closedir_and_clear(cur->fts_dirp);\n<line203>cur->fts_info = FTS_ERR;\n<line204>SET(FTS_STOP);\n<line205>__set_errno (saved_errno);\n<line206>return (NULL);\n<line207>}\n<line208>/* Did realloc() change the pointer? */\n<line209>if (oldaddr != (uintptr_t) sp->fts_path) {\n<line210>doadjust = true;\n<line211>if (ISSET(FTS_NOCHDIR))\n<line212>cp = sp->fts_path + len;\n<line213>}\n<line214>maxlen = sp->fts_pathlen - len;\n<line215>}\n<line216>new_len = len + d_namelen;\n<line217>if (new_len < len) {\n<line218>/*\n<line219>* In the unlikely event that we would end up\n<line220>* with a file name longer than SIZE_MAX, free up\n<line221>* the current structure and the structures already\n<line222>* allocated, then error out with ENAMETOOLONG.\n<line223>*/\n<line224>free(p);\n<line225>fts_lfree(head);\n<line226>closedir_and_clear(cur->fts_dirp);\n<line227>cur->fts_info = FTS_ERR;\n<line228>SET(FTS_STOP);\n<line229>__set_errno (ENAMETOOLONG);\n<line230>return (NULL);\n<line231>}\n<line232>p->fts_level = level;\n<line233>p->fts_parent = sp->fts_cur;\n<line234>p->fts_pathlen = new_len;\n<line235>/* Store dirent.d_ino, in case we need to sort\n<line236>entries before processing them.  */\n<line237>p->fts_statp->st_ino = D_INO (dp);\n<line238>/* Build a file name for fts_stat to stat. */\n<line239>if (ISSET(FTS_NOCHDIR)) {\n<line240>p->fts_accpath = p->fts_path;\n<line241>memmove(cp, p->fts_name, p->fts_namelen + 1);\n<line242>} else\n<line243>p->fts_accpath = p->fts_name;\n<line244>if (sp->fts_compar == NULL || ISSET(FTS_DEFER_STAT)) {\n<line245>/* Record what fts_read will have to do with this\n<line246>entry. In many cases, it will simply fts_stat it,\n<line247>but we can take advantage of any d_type information\n<line248>to optimize away the unnecessary stat calls.  I.e.,\n<line249>if FTS_NOSTAT is in effect and we're not following\n<line250>symlinks (FTS_PHYSICAL) and d_type indicates this\n<line251>is *not* a directory, then we won't have to stat it\n<line252>at all.  If it *is* a directory, then (currently)\n<line253>we stat it regardless, in order to get device and\n<line254>inode numbers.  Some day we might optimize that\n<line255>away, too, for directories where d_ino is known to\n<line256>be valid.  */\n<line257>bool skip_stat = (ISSET(FTS_NOSTAT)\n<line258>&& DT_IS_KNOWN(dp)\n<line259>&& ! DT_MUST_BE(dp, DT_DIR)\n<line260>&& (ISSET(FTS_PHYSICAL)\n<line261>|| ! DT_MUST_BE(dp, DT_LNK)));\n<line262>p->fts_info = FTS_NSOK;\n<line263>/* Propagate dirent.d_type information back\n<line264>to caller, when possible.  */\n<line265>set_stat_type (p->fts_statp, D_TYPE (dp));\n<line266>fts_set_stat_required(p, !skip_stat);\n<line267>} else {\n<line268>p->fts_info = fts_stat(sp, p, false);\n<line269>}\n<line270>/* We walk in directory order so "ls -f" doesn't get upset. */\n<line271>p->fts_link = NULL;\n<line272>if (head == NULL)\n<line273>head = tail = p;\n<line274>else {\n<line275>tail->fts_link = p;\n<line276>tail = p;\n<line277>}\n<line278>/* If there are many entries, no sorting function has been\n<line279>specified, and this file system is of a type that may be\n<line280>slow with a large number of entries, arrange to sort the\n<line281>directory entries on increasing inode numbers.\n<line282>The NITEMS comparison uses ==, not >, because the test\n<line283>needs to be tried at most once once, and NITEMS will exceed\n<line284>the threshold after it is incremented below.  */\n<line285>if (nitems == _FTS_INODE_SORT_DIR_ENTRIES_THRESHOLD\n<line286>&& !sp->fts_compar)\n<line287>sort_by_inode = dirent_inode_sort_may_be_useful (cur, dir_fd);\n<line288>++nitems;\n<line289>if (max_entries <= nitems) {\n<line290>/* When there are too many dir entries, leave\n<line291>fts_dirp open, so that a subsequent fts_read\n<line292>can take up where we leave off.  */\n<line293>break;\n<line294>}\n<line295>}\n<line296>/*\n<line297>* If realloc() changed the address of the file name, adjust the\n<line298>* addresses for the rest of the tree and the dir list.\n<line299>*/\n<line300>if (doadjust)\n<line301>fts_padjust(sp, head);\n<line302>/*\n<line303>* If not changing directories, reset the file name back to original\n<line304>* state.\n<line305>*/\n<line306>if (ISSET(FTS_NOCHDIR)) {\n<line307>if (len == sp->fts_pathlen || nitems == 0)\n<line308>--cp;\n<line309>*cp = '\0';\n<line310>}\n<line311>/*\n<line312>* If descended after called from fts_children or after called from\n<line313>* fts_read and nothing found, get back.  At the root level we use\n<line314>* the saved fd; if one of fts_open()'s arguments is a relative name\n<line315>* to an empty directory, we wind up here with no other way back.  If\n<line316>* can't get back, we're done.\n<line317>*/\n<line318>if (!continue_readdir && descend && (type == BCHILD || !nitems) &&\n<line319>(cur->fts_level == FTS_ROOTLEVEL\n<line320>? restore_initial_cwd(sp)\n<line321>: fts_safe_changedir(sp, cur->fts_parent, -1, ".."))) {\n<line322>cur->fts_info = FTS_ERR;\n<line323>SET(FTS_STOP);\n<line324>fts_lfree(head);\n<line325>return (NULL);\n<line326>}\n<line327>/* If didn't find anything, return NULL. */\n<line328>if (!nitems) {\n<line329>if (type == BREAD\n<line330>&& cur->fts_info != FTS_DNR && cur->fts_info != FTS_ERR)\n<line331>cur->fts_info = FTS_DP;\n<line332>fts_lfree(head);\n<line333>return (NULL);\n<line334>}\n<line335>if (sort_by_inode) {\n<line336>sp->fts_compar = fts_compare_ino;\n<line337>head = fts_sort (sp, head, nitems);\n<line338>sp->fts_compar = NULL;\n<line339>}\n<line340>/* Sort the entries. */\n<line341>if (sp->fts_compar && nitems > 1)\n<line342>head = fts_sort(sp, head, nitems);\n<line343>return (head);\n<line344>}
----------------------------------------
Function: fts_stat
Content: <line0>static unsigned short int\n<line1>internal_function\n<line2>fts_stat(FTS *sp, register FTSENT *p, bool follow)\n<line3>{\n<line4>struct stat *sbp = p->fts_statp;\n<line5>if (ISSET (FTS_LOGICAL)\n<line6>|| (ISSET (FTS_COMFOLLOW) && p->fts_level == FTS_ROOTLEVEL))\n<line7>follow = true;\n<line8>/*\n<line9>* If doing a logical walk, or application requested FTS_FOLLOW, do\n<line10>* a stat(2).  If that fails, check for a nonexistent symlink.  If\n<line11>* fail, set the errno from the stat call.\n<line12>*/\n<line13>int flags = follow ? 0 : AT_SYMLINK_NOFOLLOW;\n<line14>if (fstatat (sp->fts_cwd_fd, p->fts_accpath, sbp, flags) < 0)\n<line15>{\n<line16>if (follow && errno == ENOENT\n<line17>&& 0 <= fstatat (sp->fts_cwd_fd, p->fts_accpath, sbp,\n<line18>AT_SYMLINK_NOFOLLOW))\n<line19>{\n<line20>__set_errno (0);\n<line21>return FTS_SLNONE;\n<line22>}\n<line23>p->fts_errno = errno;\n<line24>memset (sbp, 0, sizeof *sbp);\n<line25>return FTS_NS;\n<line26>}\n<line27>if (S_ISDIR(sbp->st_mode)) {\n<line28>if (ISDOT(p->fts_name)) {\n<line29>/* Command-line "." and ".." are real directories. */\n<line30>return (p->fts_level == FTS_ROOTLEVEL ? FTS_D : FTS_DOT);\n<line31>}\n<line32>return (FTS_D);\n<line33>}\n<line34>if (S_ISLNK(sbp->st_mode))\n<line35>return (FTS_SL);\n<line36>if (S_ISREG(sbp->st_mode))\n<line37>return (FTS_F);\n<line38>return (FTS_DEFAULT);\n<line39>}
----------------------------------------
Function: fts_compar
Content: <line0>static int\n<line1>fts_compar (void const *a, void const *b)\n<line2>{\n<line3>/* Convert A and B to the correct types, to pacify the compiler, and\n<line4>for portability to bizarre hosts where "void const *" and "FTSENT\n<line5>const **" differ in runtime representation.  The comparison\n<line6>function cannot modify *a and *b, but there is no compile-time\n<line7>check for this.  */\n<line8>FTSENT const **pa = (FTSENT const **) a;\n<line9>FTSENT const **pb = (FTSENT const **) b;\n<line10>return pa[0]->fts_fts->fts_compar (pa, pb);\n<line11>}
----------------------------------------
Function: fts_sort
Content: <line0>static FTSENT *\n<line1>internal_function\n<line2>fts_sort (FTS *sp, FTSENT *head, register size_t nitems)\n<line3>{\n<line4>register FTSENT **ap, *p;\n<line5>/* On most modern hosts, void * and FTSENT ** have the same\n<line6>run-time representation, and one can convert sp->fts_compar to\n<line7>the type qsort expects without problem.  Use the heuristic that\n<line8>this is OK if the two pointer types are the same size, and if\n<line9>converting FTSENT ** to long int is the same as converting\n<line10>FTSENT ** to void * and then to long int.  This heuristic isn't\n<line11>valid in general but we don't know of any counterexamples.  */\n<line12>FTSENT *dummy;\n<line13>int (*compare) (void const *, void const *) =\n<line14>((sizeof &dummy == sizeof (void *)\n<line15>&& (long int) &dummy == (long int) (void *) &dummy)\n<line16>? (int (*) (void const *, void const *)) sp->fts_compar\n<line17>: fts_compar);\n<line18>/*\n<line19>* Construct an array of pointers to the structures and call qsort(3).\n<line20>* Reassemble the array in the order returned by qsort.  If unable to\n<line21>* sort for memory reasons, return the directory entries in their\n<line22>* current order.  Allocate enough space for the current needs plus\n<line23>* 40 so don't realloc one entry at a time.\n<line24>*/\n<line25>if (nitems > sp->fts_nitems) {\n<line26>FTSENT **a;\n<line27>sp->fts_nitems = nitems + 40;\n<line28>if (SIZE_MAX / sizeof *a < sp->fts_nitems\n<line29>|| ! (a = realloc (sp->fts_array,\n<line30>sp->fts_nitems * sizeof *a))) {\n<line31>free(sp->fts_array);\n<line32>sp->fts_array = NULL;\n<line33>sp->fts_nitems = 0;\n<line34>return (head);\n<line35>}\n<line36>sp->fts_array = a;\n<line37>}\n<line38>for (ap = sp->fts_array, p = head; p; p = p->fts_link)\n<line39>*ap++ = p;\n<line40>qsort((void *)sp->fts_array, nitems, sizeof(FTSENT *), compare);\n<line41>for (head = *(ap = sp->fts_array); --nitems; ++ap)\n<line42>ap[0]->fts_link = ap[1];\n<line43>ap[0]->fts_link = NULL;\n<line44>return (head);\n<line45>}
----------------------------------------
Function: fts_alloc
Content: <line0>static FTSENT *\n<line1>internal_function\n<line2>fts_alloc (FTS *sp, const char *name, register size_t namelen)\n<line3>{\n<line4>register FTSENT *p;\n<line5>size_t len;\n<line6>/*\n<line7>* The file name is a variable length array.  Allocate the FTSENT\n<line8>* structure and the file name in one chunk.\n<line9>*/\n<line10>len = FLEXSIZEOF(FTSENT, fts_name, namelen + 1);\n<line11>if ((p = malloc(len)) == NULL)\n<line12>return (NULL);\n<line13>/* Copy the name and guarantee NUL termination. */\n<line14>memcpy(p->fts_name, name, namelen);\n<line15>p->fts_name[namelen] = '\0';\n<line16>p->fts_namelen = namelen;\n<line17>p->fts_fts = sp;\n<line18>p->fts_path = sp->fts_path;\n<line19>p->fts_errno = 0;\n<line20>p->fts_dirp = NULL;\n<line21>p->fts_flags = 0;\n<line22>p->fts_instr = FTS_NOINSTR;\n<line23>p->fts_number = 0;\n<line24>p->fts_pointer = NULL;\n<line25>return (p);\n<line26>}
----------------------------------------
Function: fts_lfree
Content: <line0>static void\n<line1>internal_function\n<line2>fts_lfree (register FTSENT *head)\n<line3>{\n<line4>register FTSENT *p;\n<line5>int err = errno;\n<line6>/* Free a linked list of structures. */\n<line7>while ((p = head)) {\n<line8>head = head->fts_link;\n<line9>if (p->fts_dirp)\n<line10>closedir (p->fts_dirp);\n<line11>free(p);\n<line12>}\n<line13>__set_errno (err);\n<line14>}
----------------------------------------
Function: fts_palloc
Content: <line0>static bool\n<line1>internal_function\n<line2>fts_palloc (FTS *sp, size_t more)\n<line3>{\n<line4>char *p;\n<line5>size_t new_len = sp->fts_pathlen + more + 256;\n<line6>/*\n<line7>* See if fts_pathlen would overflow.\n<line8>*/\n<line9>if (new_len < sp->fts_pathlen) {\n<line10>free(sp->fts_path);\n<line11>sp->fts_path = NULL;\n<line12>__set_errno (ENAMETOOLONG);\n<line13>return false;\n<line14>}\n<line15>sp->fts_pathlen = new_len;\n<line16>p = realloc(sp->fts_path, sp->fts_pathlen);\n<line17>if (p == NULL) {\n<line18>free(sp->fts_path);\n<line19>sp->fts_path = NULL;\n<line20>return false;\n<line21>}\n<line22>sp->fts_path = p;\n<line23>return true;\n<line24>}
----------------------------------------
Function: fts_padjust
Content: <line0>static void\n<line1>internal_function\n<line2>fts_padjust (FTS *sp, FTSENT *head)\n<line3>{\n<line4>FTSENT *p;\n<line5>char *addr = sp->fts_path;\n<line6>/* This code looks at bit-patterns of freed pointers to\n<line7>relocate them, so it relies on undefined behavior.  If this\n<line8>trick does not work on your platform, please report a bug.  */\n<line9>#define ADJUST(p) do {                                                  \\n<line10>uintptr_t old_accpath = (uintptr_t) (p)->fts_accpath;           \\n<line11>if (old_accpath != (uintptr_t) (p)->fts_name) {                 \\n<line12>(p)->fts_accpath =                                      \\n<line13>addr + (old_accpath - (uintptr_t) (p)->fts_path);     \\n<line14>}                                                               \\n<line15>(p)->fts_path = addr;                                           \\n<line16>} while (0)\n<line17>/* Adjust the current set of children. */\n<line18>for (p = sp->fts_child; p; p = p->fts_link)\n<line19>ADJUST(p);\n<line20>/* Adjust the rest of the tree, including the current level. */\n<line21>for (p = head; p->fts_level >= FTS_ROOTLEVEL;) {\n<line22>ADJUST(p);\n<line23>p = p->fts_link ? p->fts_link : p->fts_parent;\n<line24>}\n<line25>}
----------------------------------------
Function: fts_maxarglen
Content: <line0>static size_t\n<line1>internal_function _GL_ATTRIBUTE_PURE\n<line2>fts_maxarglen (char * const *argv)\n<line3>{\n<line4>size_t len, max;\n<line5>for (max = 0; *argv; ++argv)\n<line6>if ((len = strlen(*argv)) > max)\n<line7>max = len;\n<line8>return (max + 1);\n<line9>}
----------------------------------------
Function: fts_safe_changedir
Content: <line0>static int\n<line1>internal_function\n<line2>fts_safe_changedir (FTS *sp, FTSENT *p, int fd, char const *dir)\n<line3>{\n<line4>int ret;\n<line5>bool is_dotdot = dir && STREQ (dir, "..");\n<line6>int newfd;\n<line7>/* This clause handles the unusual case in which FTS_NOCHDIR\n<line8>is specified, along with FTS_CWDFD.  In that case, there is\n<line9>no need to change even the virtual cwd file descriptor.\n<line10>However, if FD is non-negative, we do close it here.  */\n<line11>if (ISSET (FTS_NOCHDIR))\n<line12>{\n<line13>if (ISSET (FTS_CWDFD) && 0 <= fd)\n<line14>close (fd);\n<line15>return 0;\n<line16>}\n<line17>if (fd < 0 && is_dotdot && ISSET (FTS_CWDFD))\n<line18>{\n<line19>/* When possible, skip the diropen and subsequent fstat+dev/ino\n<line20>comparison.  I.e., when changing to parent directory\n<line21>(chdir ("..")), use a file descriptor from the ring and\n<line22>save the overhead of diropen+fstat, as well as avoiding\n<line23>failure when we lack "x" access to the virtual cwd.  */\n<line24>if ( ! i_ring_empty (&sp->fts_fd_ring))\n<line25>{\n<line26>int parent_fd;\n<line27>fd_ring_print (sp, stderr, "pre-pop");\n<line28>parent_fd = i_ring_pop (&sp->fts_fd_ring);\n<line29>if (0 <= parent_fd)\n<line30>{\n<line31>fd = parent_fd;\n<line32>dir = NULL;\n<line33>}\n<line34>}\n<line35>}\n<line36>newfd = fd;\n<line37>if (fd < 0 && (newfd = diropen (sp, dir)) < 0)\n<line38>return -1;\n<line39>/* The following dev/inode check is necessary if we're doing a\n<line40>"logical" traversal (through symlinks, a la chown -L), if the\n<line41>system lacks O_NOFOLLOW support, or if we're changing to ".."\n<line42>(but not via a popped file descriptor).  When changing to the\n<line43>name "..", O_NOFOLLOW can't help.  In general, when the target is\n<line44>not "..", diropen's use of O_NOFOLLOW ensures we don't mistakenly\n<line45>follow a symlink, so we can avoid the expense of this fstat.  */\n<line46>if (ISSET(FTS_LOGICAL) || ! HAVE_WORKING_O_NOFOLLOW\n<line47>|| (dir && STREQ (dir, "..")))\n<line48>{\n<line49>struct stat sb;\n<line50>if (fstat(newfd, &sb))\n<line51>{\n<line52>ret = -1;\n<line53>goto bail;\n<line54>}\n<line55>if (p->fts_statp->st_dev != sb.st_dev\n<line56>|| p->fts_statp->st_ino != sb.st_ino)\n<line57>{\n<line58>__set_errno (ENOENT);           /* disinformation */\n<line59>ret = -1;\n<line60>goto bail;\n<line61>}\n<line62>}\n<line63>if (ISSET(FTS_CWDFD))\n<line64>{\n<line65>cwd_advance_fd (sp, newfd, ! is_dotdot);\n<line66>return 0;\n<line67>}\n<line68>ret = fchdir(newfd);\n<line69>bail:\n<line70>if (fd < 0)\n<line71>{\n<line72>int oerrno = errno;\n<line73>(void)close(newfd);\n<line74>__set_errno (oerrno);\n<line75>}\n<line76>return ret;\n<line77>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/full-read.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
========================================
/home/huihui/Downloads/coreutils-9.4/lib/full-write.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
Function: full_write
Content: <line0>size_t\n<line1>full_rw (int fd, const void *buf, size_t count)\n<line2>{\n<line3>size_t total = 0;\n<line4>const char *ptr = (const char *) buf;\n<line5>while (count > 0)\n<line6>{\n<line7>size_t n_rw = safe_rw (fd, ptr, count);\n<line8>if (n_rw == (size_t) -1)\n<line9>break;\n<line10>if (n_rw == 0)\n<line11>{\n<line12>errno = ZERO_BYTE_TRANSFER_ERRNO;\n<line13>break;\n<line14>}\n<line15>total += n_rw;\n<line16>ptr += n_rw;\n<line17>count -= n_rw;\n<line18>}\n<line19>return total;\n<line20>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/gethrxtime.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
Function: gethrxtime
Content: <line0>xtime_t\n<line1>gethrxtime (void)\n<line2>{\n<line3># if HAVE_NANOUPTIME\n<line4>{\n<line5>struct timespec ts;\n<line6>nanouptime (&ts);\n<line7>return xtime_make (ts.tv_sec, ts.tv_nsec);\n<line8>}\n<line9># else\n<line10>#  if defined CLOCK_MONOTONIC && HAVE_CLOCK_GETTIME\n<line11>{\n<line12>struct timespec ts;\n<line13>if (clock_gettime (CLOCK_MONOTONIC, &ts) == 0)\n<line14>return xtime_make (ts.tv_sec, ts.tv_nsec);\n<line15>}\n<line16>#  endif\n<line17>#  if HAVE_MICROUPTIME\n<line18>{\n<line19>struct timeval tv;\n<line20>microuptime (&tv);\n<line21>return xtime_make (tv.tv_sec, 1000 * tv.tv_usec);\n<line22>}\n<line23>#  else\n<line24>/* No monotonically increasing clocks are available; fall back on a\n<line25>clock that might jump backwards, since it's the best we can do.  */\n<line26>{\n<line27>struct timespec ts;\n<line28>gettime (&ts);\n<line29>return xtime_make (ts.tv_sec, ts.tv_nsec);\n<line30>}\n<line31>#  endif\n<line32># endif\n<line33>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/xtime.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
========================================
/home/huihui/Downloads/coreutils-9.4/lib/getndelim2.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
Function: getndelim2
Content: <line0>ssize_t\n<line1>getndelim2 (char **lineptr, size_t *linesize, size_t offset, size_t nmax,\n<line2>int delim1, int delim2, FILE *stream)\n<line3>{\n<line4>size_t nbytes_avail;          /* Allocated but unused bytes in *LINEPTR.  */\n<line5>char *read_pos;               /* Where we're reading into *LINEPTR. */\n<line6>ssize_t bytes_stored = -1;\n<line7>char *ptr = *lineptr;\n<line8>size_t size = *linesize;\n<line9>bool found_delimiter;\n<line10>if (!ptr)\n<line11>{\n<line12>size = nmax < MIN_CHUNK ? nmax : MIN_CHUNK;\n<line13>ptr = malloc (size);\n<line14>if (!ptr)\n<line15>return -1;\n<line16>}\n<line17>if (size < offset)\n<line18>goto done;\n<line19>nbytes_avail = size - offset;\n<line20>read_pos = ptr + offset;\n<line21>if (nbytes_avail == 0 && nmax <= size)\n<line22>goto done;\n<line23>/* Normalize delimiters, since memchr2 doesn't handle EOF.  */\n<line24>if (delim1 == EOF)\n<line25>delim1 = delim2;\n<line26>else if (delim2 == EOF)\n<line27>delim2 = delim1;\n<line28>flockfile (stream);\n<line29>found_delimiter = false;\n<line30>do\n<line31>{\n<line32>/* Here always ptr + size == read_pos + nbytes_avail.\n<line33>Also nbytes_avail > 0 || size < nmax.  */\n<line34>int c;\n<line35>const char *buffer;\n<line36>size_t buffer_len;\n<line37>buffer = freadptr (stream, &buffer_len);\n<line38>if (buffer)\n<line39>{\n<line40>if (delim1 != EOF)\n<line41>{\n<line42>const char *end = memchr2 (buffer, delim1, delim2, buffer_len);\n<line43>if (end)\n<line44>{\n<line45>buffer_len = end - buffer + 1;\n<line46>found_delimiter = true;\n<line47>}\n<line48>}\n<line49>}\n<line50>else\n<line51>{\n<line52>c = getc (stream);\n<line53>if (c == EOF)\n<line54>{\n<line55>/* Return partial line, if any.  */\n<line56>if (read_pos == ptr)\n<line57>goto unlock_done;\n<line58>else\n<line59>break;\n<line60>}\n<line61>if (c == delim1 || c == delim2)\n<line62>found_delimiter = true;\n<line63>buffer_len = 1;\n<line64>}\n<line65>/* We always want at least one byte left in the buffer, since we\n<line66>always (unless we get an error while reading the first byte)\n<line67>NUL-terminate the line buffer.  */\n<line68>if (nbytes_avail < buffer_len + 1 && size < nmax)\n<line69>{\n<line70>/* Grow size proportionally, not linearly, to avoid O(n^2)\n<line71>running time.  */\n<line72>size_t newsize = size < MIN_CHUNK ? size + MIN_CHUNK : 2 * size;\n<line73>char *newptr;\n<line74>/* Increase newsize so that it becomes\n<line75>>= (read_pos - ptr) + buffer_len.  */\n<line76>if (newsize - (read_pos - ptr) < buffer_len + 1)\n<line77>newsize = (read_pos - ptr) + buffer_len + 1;\n<line78>/* Respect nmax.  This handles possible integer overflow.  */\n<line79>if (! (size < newsize && newsize <= nmax))\n<line80>newsize = nmax;\n<line81>if (GETNDELIM2_MAXIMUM < newsize - offset)\n<line82>{\n<line83>size_t newsizemax = offset + GETNDELIM2_MAXIMUM + 1;\n<line84>if (size == newsizemax)\n<line85>goto unlock_done;\n<line86>newsize = newsizemax;\n<line87>}\n<line88>nbytes_avail = newsize - (read_pos - ptr);\n<line89>newptr = realloc (ptr, newsize);\n<line90>if (!newptr)\n<line91>goto unlock_done;\n<line92>ptr = newptr;\n<line93>size = newsize;\n<line94>read_pos = size - nbytes_avail + ptr;\n<line95>}\n<line96>/* Here, if size < nmax, nbytes_avail >= buffer_len + 1.\n<line97>If size == nmax, nbytes_avail > 0.  */\n<line98>if (1 < nbytes_avail)\n<line99>{\n<line100>size_t copy_len = nbytes_avail - 1;\n<line101>if (buffer_len < copy_len)\n<line102>copy_len = buffer_len;\n<line103>if (buffer)\n<line104>memcpy (read_pos, buffer, copy_len);\n<line105>else\n<line106>*read_pos = c;\n<line107>read_pos += copy_len;\n<line108>nbytes_avail -= copy_len;\n<line109>}\n<line110>/* Here still nbytes_avail > 0.  */\n<line111>if (buffer && freadseek (stream, buffer_len))\n<line112>goto unlock_done;\n<line113>}\n<line114>while (!found_delimiter);\n<line115>/* Done - NUL terminate and return the number of bytes read.\n<line116>At this point we know that nbytes_avail >= 1.  */\n<line117>*read_pos = '\0';\n<line118>bytes_stored = read_pos - (ptr + offset);\n<line119>unlock_done:\n<line120>funlockfile (stream);\n<line121>done:\n<line122>*lineptr = ptr;\n<line123>*linesize = size;\n<line124>return bytes_stored ? bytes_stored : -1;\n<line125>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/getprogname.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
Function: getprogname
Content: <line0>char const *\n<line1>getprogname (void)\n<line2>{\n<line3># if HAVE_DECL_PROGRAM_INVOCATION_SHORT_NAME                /* glibc, BeOS */\n<line4>/* https://www.gnu.org/software/libc/manual/html_node/Error-Messages.html */\n<line5>return program_invocation_short_name;\n<line6># elif HAVE_DECL_PROGRAM_INVOCATION_NAME                    /* glibc, BeOS */\n<line7>/* https://www.gnu.org/software/libc/manual/html_node/Error-Messages.html */\n<line8>return last_component (program_invocation_name);\n<line9># elif HAVE_GETEXECNAME                                     /* Solaris */\n<line10>/* https://docs.oracle.com/cd/E19253-01/816-5168/6mbb3hrb1/index.html */\n<line11>const char *p = getexecname ();\n<line12>if (!p)\n<line13>p = "?";\n<line14>return last_component (p);\n<line15># elif HAVE_DECL___ARGV                                     /* mingw, MSVC */\n<line16>/* https://docs.microsoft.com/en-us/cpp/c-runtime-library/argc-argv-wargv */\n<line17>const char *p = __argv && __argv[0] ? __argv[0] : "?";\n<line18>return last_component (p);\n<line19># elif HAVE_VAR___PROGNAME                                  /* OpenBSD, Android, QNX */\n<line20>/* https://man.openbsd.org/style.9 */\n<line21>/* http://www.qnx.de/developers/docs/6.5.0/index.jsp?topic=%2Fcom.qnx.doc.neutrino_lib_ref%2Fp%2F__progname.html */\n<line22>/* Be careful to declare this only when we absolutely need it\n<line23>(OpenBSD 5.1), rather than when it's available.  Otherwise,\n<line24>its mere declaration makes program_invocation_short_name\n<line25>malfunction (have zero length) with Fedora 25's glibc.  */\n<line26>extern char *__progname;\n<line27>const char *p = __progname;\n<line28>#  if defined __ANDROID__\n<line29>return last_component (p);\n<line30>#  else\n<line31>return p && p[0] ? p : "?";\n<line32>#  endif\n<line33># elif _AIX                                                 /* AIX */\n<line34>/* Idea by Bastien ROUCARIS,\n<line35>https://lists.gnu.org/r/bug-gnulib/2010-12/msg00095.html\n<line36>Reference: https://www.ibm.com/support/knowledgecenter/en/ssw_aix_61/com.ibm.aix.basetrf1/getprocs.htm\n<line37>*/\n<line38>static char *p;\n<line39>static int first = 1;\n<line40>if (first)\n<line41>{\n<line42>first = 0;\n<line43>pid_t pid = getpid ();\n<line44>struct procentry64 procs;\n<line45>p = (0 < getprocs64 (&procs, sizeof procs, NULL, 0, &pid, 1)\n<line46>? strdup (procs.pi_comm)\n<line47>: NULL);\n<line48>if (!p)\n<line49>p = "?";\n<line50>}\n<line51>return p;\n<line52># elif defined __hpux\n<line53>static char *p;\n<line54>static int first = 1;\n<line55>if (first)\n<line56>{\n<line57>first = 0;\n<line58>pid_t pid = getpid ();\n<line59>struct pst_status status;\n<line60>if (pstat_getproc (&status, sizeof status, 0, pid) > 0)\n<line61>{\n<line62>char *ucomm = status.pst_ucomm;\n<line63>char *cmd = status.pst_cmd;\n<line64>if (strlen (ucomm) < PST_UCOMMLEN - 1)\n<line65>p = ucomm;\n<line66>else\n<line67>{\n<line68>/* ucomm is truncated to length PST_UCOMMLEN - 1.\n<line69>Look at cmd instead.  */\n<line70>char *space = strchr (cmd, ' ');\n<line71>if (space != NULL)\n<line72>*space = '\0';\n<line73>p = strrchr (cmd, '/');\n<line74>if (p != NULL)\n<line75>p++;\n<line76>else\n<line77>p = cmd;\n<line78>if (strlen (p) > PST_UCOMMLEN - 1\n<line79>&& memcmp (p, ucomm, PST_UCOMMLEN - 1) == 0)\n<line80>/* p is less truncated than ucomm.  */\n<line81>;\n<line82>else\n<line83>p = ucomm;\n<line84>}\n<line85>p = strdup (p);\n<line86>}\n<line87>else\n<line88>{\n<line89>#  if !defined __LP64__\n<line90>/* Support for 32-bit programs running in 64-bit HP-UX.\n<line91>The documented way to do this is to use the same source code\n<line92>as above, but in a compilation unit where '#define _PSTAT64 1'\n<line93>is in effect.  I prefer a single compilation unit; the struct\n<line94>size and the offsets are not going to change.  */\n<line95>char status64[1216];\n<line96>if (__pstat_getproc64 (status64, sizeof status64, 0, pid) > 0)\n<line97>{\n<line98>char *ucomm = status64 + 288;\n<line99>char *cmd = status64 + 168;\n<line100>if (strlen (ucomm) < PST_UCOMMLEN - 1)\n<line101>p = ucomm;\n<line102>else\n<line103>{\n<line104>/* ucomm is truncated to length PST_UCOMMLEN - 1.\n<line105>Look at cmd instead.  */\n<line106>char *space = strchr (cmd, ' ');\n<line107>if (space != NULL)\n<line108>*space = '\0';\n<line109>p = strrchr (cmd, '/');\n<line110>if (p != NULL)\n<line111>p++;\n<line112>else\n<line113>p = cmd;\n<line114>if (strlen (p) > PST_UCOMMLEN - 1\n<line115>&& memcmp (p, ucomm, PST_UCOMMLEN - 1) == 0)\n<line116>/* p is less truncated than ucomm.  */\n<line117>;\n<line118>else\n<line119>p = ucomm;\n<line120>}\n<line121>p = strdup (p);\n<line122>}\n<line123>else\n<line124>#  endif\n<line125>p = NULL;\n<line126>}\n<line127>if (!p)\n<line128>p = "?";\n<line129>}\n<line130>return p;\n<line131># elif __MVS__                                              /* z/OS */\n<line132>/* https://www.ibm.com/support/knowledgecenter/SSLTBW_2.1.0/com.ibm.zos.v2r1.bpxbd00/rtwgetp.htm */\n<line133>static char *p = "?";\n<line134>static int first = 1;\n<line135>if (first)\n<line136>{\n<line137>pid_t pid = getpid ();\n<line138>int token;\n<line139>W_PSPROC buf;\n<line140>first = 0;\n<line141>memset (&buf, 0, sizeof(buf));\n<line142>buf.ps_cmdptr    = (char *) malloc (buf.ps_cmdlen    = PS_CMDBLEN_LONG);\n<line143>buf.ps_conttyptr = (char *) malloc (buf.ps_conttylen = PS_CONTTYBLEN);\n<line144>buf.ps_pathptr   = (char *) malloc (buf.ps_pathlen   = PS_PATHBLEN);\n<line145>if (buf.ps_cmdptr && buf.ps_conttyptr && buf.ps_pathptr)\n<line146>{\n<line147>for (token = 0; token >= 0;\n<line148>token = w_getpsent (token, &buf, sizeof(buf)))\n<line149>{\n<line150>if (token > 0 && buf.ps_pid == pid)\n<line151>{\n<line152>char *s = strdup (last_component (buf.ps_pathptr));\n<line153>if (s)\n<line154>{\n<line155>#  if defined __XPLINK__ && __CHARSET_LIB == 1\n<line156>/* The compiler option -qascii is in use.\n<line157>https://makingdeveloperslivesbetter.wordpress.com/2022/01/07/is-z-os-ascii-or-ebcdic-yes/\n<line158>https://www.ibm.com/docs/en/zos/2.5.0?topic=features-macros-related-compiler-option-settings\n<line159>So, convert the result from EBCDIC to ASCII.\n<line160>https://www.ibm.com/docs/en/zos/2.5.0?topic=functions-e2a-s-convert-string-from-ebcdic-ascii */\n<line161>if (__e2a_s (s) == (size_t)-1)\n<line162>free (s);\n<line163>else\n<line164>#  endif\n<line165>p = s;\n<line166>}\n<line167>break;\n<line168>}\n<line169>}\n<line170>}\n<line171>free (buf.ps_cmdptr);\n<line172>free (buf.ps_conttyptr);\n<line173>free (buf.ps_pathptr);\n<line174>}\n<line175>return p;\n<line176># elif defined __sgi || defined __osf__                     /* IRIX or Tru64 */\n<line177>char filename[50];\n<line178>int fd;\n<line179># if defined __sgi\n<line180>sprintf (filename, "/proc/pinfo/%d", (int) getpid ());\n<line181># else\n<line182>sprintf (filename, "/proc/%d", (int) getpid ());\n<line183># endif\n<line184>fd = open (filename, O_RDONLY | O_CLOEXEC);\n<line185>if (0 <= fd)\n<line186>{\n<line187>prpsinfo_t buf;\n<line188>int ioctl_ok = 0 <= ioctl (fd, PIOCPSINFO, &buf);\n<line189>close (fd);\n<line190>if (ioctl_ok)\n<line191>{\n<line192>char *name = buf.pr_fname;\n<line193>size_t namesize = sizeof buf.pr_fname;\n<line194>/* It may not be NUL-terminated.  */\n<line195>char *namenul = memchr (name, '\0', namesize);\n<line196>size_t namelen = namenul ? namenul - name : namesize;\n<line197>char *namecopy = malloc (namelen + 1);\n<line198>if (namecopy)\n<line199>{\n<line200>namecopy[namelen] = '\0';\n<line201>return memcpy (namecopy, name, namelen);\n<line202>}\n<line203>}\n<line204>}\n<line205>return NULL;\n<line206># elif defined __SCO_VERSION__ || defined __sysv5__                /* SCO OpenServer6/UnixWare */\n<line207>char buf[80];\n<line208>int fd;\n<line209>sprintf (buf, "/proc/%d/cmdline", getpid());\n<line210>fd = open (buf, O_RDONLY);\n<line211>if (0 <= fd)\n<line212>{\n<line213>size_t n = read (fd, buf, 79);\n<line214>if (n > 0)\n<line215>{\n<line216>buf[n] = '\0'; /* Guarantee null-termination */\n<line217>char *progname;\n<line218>progname = strrchr (buf, '/');\n<line219>if (progname)\n<line220>{\n<line221>progname = progname + 1; /* Skip the '/' */\n<line222>}\n<line223>else\n<line224>{\n<line225>progname = buf;\n<line226>}\n<line227>char *ret;\n<line228>ret = malloc (strlen (progname) + 1);\n<line229>if (ret)\n<line230>{\n<line231>strcpy (ret, progname);\n<line232>return ret;\n<line233>}\n<line234>}\n<line235>close (fd);\n<line236>}\n<line237>return "?";\n<line238># else\n<line239>#  error "getprogname module not ported to this OS"\n<line240># endif\n<line241>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/gettime.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
Function: gettime
Content: <line0>void\n<line1>gettime (struct timespec *ts)\n<line2>{\n<line3>#if defined CLOCK_REALTIME && HAVE_CLOCK_GETTIME\n<line4>clock_gettime (CLOCK_REALTIME, ts);\n<line5>#elif defined HAVE_TIMESPEC_GET\n<line6>timespec_get (ts, TIME_UTC);\n<line7>#else\n<line8>struct timeval tv;\n<line9>gettimeofday (&tv, NULL);\n<line10>*ts = (struct timespec) { .tv_sec  = tv.tv_sec,\n<line11>.tv_nsec = tv.tv_usec * 1000 };\n<line12>#endif\n<line13>}
----------------------------------------
Function: current_timespec
Content: <line0>struct timespec\n<line1>current_timespec (void)\n<line2>{\n<line3>struct timespec ts;\n<line4>gettime (&ts);\n<line5>return ts;\n<line6>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/gettime-res.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
Function: gcd
Content: <line0>static long int _GL_ATTRIBUTE_CONST\n<line1>gcd (long int a, long int b)\n<line2>{\n<line3>while (b != 0)\n<line4>{\n<line5>long int r = a % b;\n<line6>a = b;\n<line7>b = r;\n<line8>}\n<line9>return a;\n<line10>}
----------------------------------------
Function: gettime_res
Content: <line0>long int\n<line1>gettime_res (void)\n<line2>{\n<line3>struct timespec res;\n<line4>#if defined CLOCK_REALTIME && HAVE_CLOCK_GETRES\n<line5>clock_getres (CLOCK_REALTIME, &res);\n<line6>#elif defined HAVE_TIMESPEC_GETRES\n<line7>timespec_getres (&res, TIME_UTC);\n<line8>#else\n<line9>/* Guess high and let the later code deduce better.  */\n<line10>res.tv_sec = 1;\n<line11>res.tv_nsec = 0;\n<line12>#endif\n<line13>/* On all Gnulib platforms the following calculations do not overflow.  */\n<line14>long int hz = TIMESPEC_HZ;\n<line15>long int r = res.tv_nsec <= 0 ? hz : res.tv_nsec;\n<line16>struct timespec earlier = { .tv_nsec = -1 };\n<line17>/* On some platforms, clock_getres (CLOCK_REALTIME, ...) yields a\n<line18>too-large resolution, under the mistaken theory that it should\n<line19>return the timer interval.  For example, on AIX 7.2 POWER8\n<line20>clock_getres yields 10 ms even though clock_gettime yields 1 s\n<line21>resolution.  Work around the problem with high probability by\n<line22>trying clock_gettime several times and observing the resulting\n<line23>bounds on resolution.  */\n<line24>int nsamples = 32;\n<line25>for (int i = 0; 1 < r && i < nsamples; i++)\n<line26>{\n<line27>/* If successive timestamps disagree the clock resolution must\n<line28>be small, so exit the inner loop to check this sample.\n<line29>Otherwise, arrange for the outer loop to exit but continue\n<line30>the inner-loop search for a differing timestamp sample.  */\n<line31>struct timespec now;\n<line32>for (;; i = nsamples)\n<line33>{\n<line34>now = current_timespec ();\n<line35>if (earlier.tv_nsec != now.tv_nsec || earlier.tv_sec != now.tv_sec)\n<line36>break;\n<line37>}\n<line38>earlier = now;\n<line39>if (0 < now.tv_nsec)\n<line40>r = gcd (r, now.tv_nsec);\n<line41>}\n<line42>return r;\n<line43>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/getugroups.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
Function: getugroups
Content: <line0>int\n<line1>getugroups (int maxcount, gid_t *grouplist, char const *username,\n<line2>gid_t gid)\n<line3>{\n<line4>int count = 0;\n<line5>if (gid != (gid_t) -1)\n<line6>{\n<line7>if (maxcount != 0)\n<line8>grouplist[count] = gid;\n<line9>++count;\n<line10>}\n<line11>setgrent ();\n<line12>while (1)\n<line13>{\n<line14>char **cp;\n<line15>struct group *grp;\n<line16>errno = 0;\n<line17>grp = getgrent ();\n<line18>if (grp == NULL)\n<line19>break;\n<line20>for (cp = grp->gr_mem; *cp; ++cp)\n<line21>{\n<line22>int n;\n<line23>if ( ! STREQ (username, *cp))\n<line24>continue;\n<line25>/* See if this group number is already on the list.  */\n<line26>for (n = 0; n < count; ++n)\n<line27>if (grouplist && grouplist[n] == grp->gr_gid)\n<line28>break;\n<line29>/* If it's a new group number, then try to add it to the list.  */\n<line30>if (n == count)\n<line31>{\n<line32>if (maxcount != 0)\n<line33>{\n<line34>if (count >= maxcount)\n<line35>goto done;\n<line36>grouplist[count] = grp->gr_gid;\n<line37>}\n<line38>if (count == INT_MAX)\n<line39>{\n<line40>errno = EOVERFLOW;\n<line41>goto done;\n<line42>}\n<line43>count++;\n<line44>}\n<line45>}\n<line46>}\n<line47>if (errno != 0)\n<line48>count = -1;\n<line49>done:\n<line50>{\n<line51>int saved_errno = errno;\n<line52>endgrent ();\n<line53>errno = saved_errno;\n<line54>}\n<line55>return count;\n<line56>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/malloc/dynarray_at_failure.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
Function: gl_dynarray_at_failure
Content: <line0>void\n<line1>__libc_dynarray_at_failure (size_t size, size_t index)\n<line2>{\n<line3>#ifdef _LIBC\n<line4>char buf[200];\n<line5>__snprintf (buf, sizeof (buf), "Fatal glibc error: "\n<line6>"array index %zu not less than array length %zu\n",\n<line7>index, size);\n<line8>__libc_fatal (buf);\n<line9>#else\n<line10>abort ();\n<line11>#endif\n<line12>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/malloc/dynarray_emplace_enlarge.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
========================================
/home/huihui/Downloads/coreutils-9.4/lib/malloc/dynarray_finalize.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
========================================
/home/huihui/Downloads/coreutils-9.4/lib/malloc/dynarray_resize.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
========================================
/home/huihui/Downloads/coreutils-9.4/lib/malloc/dynarray_resize_clear.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
========================================
/home/huihui/Downloads/coreutils-9.4/lib/malloc/scratch_buffer_grow.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
========================================
/home/huihui/Downloads/coreutils-9.4/lib/malloc/scratch_buffer_grow_preserve.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
========================================
/home/huihui/Downloads/coreutils-9.4/lib/malloc/scratch_buffer_set_array_size.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
========================================
/home/huihui/Downloads/coreutils-9.4/lib/hard-locale.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
========================================
/home/huihui/Downloads/coreutils-9.4/lib/hash.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
Function: hash_get_n_buckets
Content: <line0>size_t\n<line1>hash_get_n_buckets (const Hash_table *table)\n<line2>{\n<line3>return table->n_buckets;\n<line4>}
----------------------------------------
Function: hash_get_n_buckets_used
Content: <line0>size_t\n<line1>hash_get_n_buckets_used (const Hash_table *table)\n<line2>{\n<line3>return table->n_buckets_used;\n<line4>}
----------------------------------------
Function: hash_get_n_entries
Content: <line0>size_t\n<line1>hash_get_n_entries (const Hash_table *table)\n<line2>{\n<line3>return table->n_entries;\n<line4>}
----------------------------------------
Function: hash_get_max_bucket_length
Content: <line0>size_t\n<line1>hash_get_max_bucket_length (const Hash_table *table)\n<line2>{\n<line3>struct hash_entry const *bucket;\n<line4>size_t max_bucket_length = 0;\n<line5>for (bucket = table->bucket; bucket < table->bucket_limit; bucket++)\n<line6>{\n<line7>if (bucket->data)\n<line8>{\n<line9>struct hash_entry const *cursor = bucket;\n<line10>size_t bucket_length = 1;\n<line11>while (cursor = cursor->next, cursor)\n<line12>bucket_length++;\n<line13>if (bucket_length > max_bucket_length)\n<line14>max_bucket_length = bucket_length;\n<line15>}\n<line16>}\n<line17>return max_bucket_length;\n<line18>}
----------------------------------------
Function: hash_print_statistics
Content: <line0>void\n<line1>hash_print_statistics (const Hash_table *table, FILE *stream)\n<line2>{\n<line3>size_t n_entries = hash_get_n_entries (table);\n<line4>size_t n_buckets = hash_get_n_buckets (table);\n<line5>size_t n_buckets_used = hash_get_n_buckets_used (table);\n<line6>size_t max_bucket_length = hash_get_max_bucket_length (table);\n<line7>fprintf (stream, "# entries:         %lu\n", (unsigned long int) n_entries);\n<line8>fprintf (stream, "# buckets:         %lu\n", (unsigned long int) n_buckets);\n<line9>fprintf (stream, "# buckets used:    %lu (%.2f%%)\n",\n<line10>(unsigned long int) n_buckets_used,\n<line11>(100.0 * n_buckets_used) / n_buckets);\n<line12>fprintf (stream, "max bucket length: %lu\n",\n<line13>(unsigned long int) max_bucket_length);\n<line14>}
----------------------------------------
Function: safe_hasher
Content: <line0>static struct hash_entry *\n<line1>safe_hasher (const Hash_table *table, const void *key)\n<line2>{\n<line3>size_t n = table->hasher (key, table->n_buckets);\n<line4>if (! (n < table->n_buckets))\n<line5>abort ();\n<line6>return table->bucket + n;\n<line7>}
----------------------------------------
Function: hash_lookup
Content: <line0>void *\n<line1>hash_lookup (const Hash_table *table, const void *entry)\n<line2>{\n<line3>struct hash_entry const *bucket = safe_hasher (table, entry);\n<line4>struct hash_entry const *cursor;\n<line5>if (bucket->data == NULL)\n<line6>return NULL;\n<line7>for (cursor = bucket; cursor; cursor = cursor->next)\n<line8>if (entry == cursor->data || table->comparator (entry, cursor->data))\n<line9>return cursor->data;\n<line10>return NULL;\n<line11>}
----------------------------------------
Function: hash_get_first
Content: <line0>void *\n<line1>hash_get_first (const Hash_table *table)\n<line2>{\n<line3>struct hash_entry const *bucket;\n<line4>if (table->n_entries == 0)\n<line5>return NULL;\n<line6>for (bucket = table->bucket; ; bucket++)\n<line7>if (! (bucket < table->bucket_limit))\n<line8>abort ();\n<line9>else if (bucket->data)\n<line10>return bucket->data;\n<line11>}
----------------------------------------
Function: hash_get_next
Content: <line0>void *\n<line1>hash_get_next (const Hash_table *table, const void *entry)\n<line2>{\n<line3>struct hash_entry const *bucket = safe_hasher (table, entry);\n<line4>struct hash_entry const *cursor;\n<line5>/* Find next entry in the same bucket.  */\n<line6>cursor = bucket;\n<line7>do\n<line8>{\n<line9>if (cursor->data == entry && cursor->next)\n<line10>return cursor->next->data;\n<line11>cursor = cursor->next;\n<line12>}\n<line13>while (cursor != NULL);\n<line14>/* Find first entry in any subsequent bucket.  */\n<line15>while (++bucket < table->bucket_limit)\n<line16>if (bucket->data)\n<line17>return bucket->data;\n<line18>/* None found.  */\n<line19>return NULL;\n<line20>}
----------------------------------------
Function: hash_get_entries
Content: <line0>size_t\n<line1>hash_get_entries (const Hash_table *table, void **buffer,\n<line2>size_t buffer_size)\n<line3>{\n<line4>size_t counter = 0;\n<line5>struct hash_entry const *bucket;\n<line6>struct hash_entry const *cursor;\n<line7>for (bucket = table->bucket; bucket < table->bucket_limit; bucket++)\n<line8>{\n<line9>if (bucket->data)\n<line10>{\n<line11>for (cursor = bucket; cursor; cursor = cursor->next)\n<line12>{\n<line13>if (counter >= buffer_size)\n<line14>return counter;\n<line15>buffer[counter++] = cursor->data;\n<line16>}\n<line17>}\n<line18>}\n<line19>return counter;\n<line20>}
----------------------------------------
Function: hash_do_for_each
Content: <line0>size_t\n<line1>hash_do_for_each (const Hash_table *table, Hash_processor processor,\n<line2>void *processor_data)\n<line3>{\n<line4>size_t counter = 0;\n<line5>struct hash_entry const *bucket;\n<line6>struct hash_entry const *cursor;\n<line7>for (bucket = table->bucket; bucket < table->bucket_limit; bucket++)\n<line8>{\n<line9>if (bucket->data)\n<line10>{\n<line11>for (cursor = bucket; cursor; cursor = cursor->next)\n<line12>{\n<line13>if (! processor (cursor->data, processor_data))\n<line14>return counter;\n<line15>counter++;\n<line16>}\n<line17>}\n<line18>}\n<line19>return counter;\n<line20>}
----------------------------------------
Function: hash_string
Content: <line0>size_t\n<line1>hash_string (const char *string, size_t n_buckets)\n<line2>{\n<line3>size_t value = 0;\n<line4>unsigned char ch;\n<line5>for (; (ch = *string); string++)\n<line6>value = (value * 31 + ch) % n_buckets;\n<line7>return value;\n<line8>}
----------------------------------------
Function: is_prime
Content: <line0>static bool _GL_ATTRIBUTE_CONST\n<line1>is_prime (size_t candidate)\n<line2>{\n<line3>size_t divisor = 3;\n<line4>size_t square = divisor * divisor;\n<line5>while (square < candidate && (candidate % divisor))\n<line6>{\n<line7>divisor++;\n<line8>square += 4 * divisor;\n<line9>divisor++;\n<line10>}\n<line11>return (candidate % divisor ? true : false);\n<line12>}
----------------------------------------
Function: next_prime
Content: <line0>static size_t _GL_ATTRIBUTE_CONST\n<line1>next_prime (size_t candidate)\n<line2>{\n<line3>/* Skip small primes.  */\n<line4>if (candidate < 10)\n<line5>candidate = 10;\n<line6>/* Make it definitely odd.  */\n<line7>candidate |= 1;\n<line8>while (SIZE_MAX != candidate && !is_prime (candidate))\n<line9>candidate += 2;\n<line10>return candidate;\n<line11>}
----------------------------------------
Function: hash_reset_tuning
Content: <line0>void\n<line1>hash_reset_tuning (Hash_tuning *tuning)\n<line2>{\n<line3>*tuning = default_tuning;\n<line4>}
----------------------------------------
Function: raw_hasher
Content: <line0>static size_t\n<line1>raw_hasher (const void *data, size_t n)\n<line2>{\n<line3>/* When hashing unique pointers, it is often the case that they were\n<line4>generated by malloc and thus have the property that the low-order\n<line5>bits are 0.  As this tends to give poorer performance with small\n<line6>tables, we rotate the pointer value before performing division,\n<line7>in an attempt to improve hash quality.  */\n<line8>size_t val = rotr_sz ((size_t) data, 3);\n<line9>return val % n;\n<line10>}
----------------------------------------
Function: raw_comparator
Content: <line0>static bool\n<line1>raw_comparator (const void *a, const void *b)\n<line2>{\n<line3>return a == b;\n<line4>}
----------------------------------------
Function: check_tuning
Content: <line0>static bool\n<line1>check_tuning (Hash_table *table)\n<line2>{\n<line3>const Hash_tuning *tuning = table->tuning;\n<line4>float epsilon;\n<line5>if (tuning == &default_tuning)\n<line6>return true;\n<line7>/* Be a bit stricter than mathematics would require, so that\n<line8>rounding errors in size calculations do not cause allocations to\n<line9>fail to grow or shrink as they should.  The smallest allocation\n<line10>is 11 (due to next_prime's algorithm), so an epsilon of 0.1\n<line11>should be good enough.  */\n<line12>epsilon = 0.1f;\n<line13>if (epsilon < tuning->growth_threshold\n<line14>&& tuning->growth_threshold < 1 - epsilon\n<line15>&& 1 + epsilon < tuning->growth_factor\n<line16>&& 0 <= tuning->shrink_threshold\n<line17>&& tuning->shrink_threshold + epsilon < tuning->shrink_factor\n<line18>&& tuning->shrink_factor <= 1\n<line19>&& tuning->shrink_threshold + epsilon < tuning->growth_threshold)\n<line20>return true;\n<line21>table->tuning = &default_tuning;\n<line22>return false;\n<line23>}
----------------------------------------
Function: compute_bucket_size
Content: <line0>static size_t _GL_ATTRIBUTE_PURE\n<line1>compute_bucket_size (size_t candidate, const Hash_tuning *tuning)\n<line2>{\n<line3>if (!tuning->is_n_buckets)\n<line4>{\n<line5>float new_candidate = candidate / tuning->growth_threshold;\n<line6>if ((float) SIZE_MAX <= new_candidate)\n<line7>goto nomem;\n<line8>candidate = new_candidate;\n<line9>}\n<line10>candidate = next_prime (candidate);\n<line11>if (xalloc_oversized (candidate, sizeof (struct hash_entry *)))\n<line12>goto nomem;\n<line13>return candidate;\n<line14>nomem:\n<line15>errno = ENOMEM;\n<line16>return 0;\n<line17>}
----------------------------------------
Function: hash_initialize
Content: <line0>Hash_table *\n<line1>hash_initialize (size_t candidate, const Hash_tuning *tuning,\n<line2>Hash_hasher hasher, Hash_comparator comparator,\n<line3>Hash_data_freer data_freer)\n<line4>{\n<line5>Hash_table *table;\n<line6>if (hasher == NULL)\n<line7>hasher = raw_hasher;\n<line8>if (comparator == NULL)\n<line9>comparator = raw_comparator;\n<line10>table = malloc (sizeof *table);\n<line11>if (table == NULL)\n<line12>return NULL;\n<line13>if (!tuning)\n<line14>tuning = &default_tuning;\n<line15>table->tuning = tuning;\n<line16>if (!check_tuning (table))\n<line17>{\n<line18>/* Fail if the tuning options are invalid.  This is the only occasion\n<line19>when the user gets some feedback about it.  Once the table is created,\n<line20>if the user provides invalid tuning options, we silently revert to\n<line21>using the defaults, and ignore further request to change the tuning\n<line22>options.  */\n<line23>errno = EINVAL;\n<line24>goto fail;\n<line25>}\n<line26>table->n_buckets = compute_bucket_size (candidate, tuning);\n<line27>if (!table->n_buckets)\n<line28>goto fail;\n<line29>table->bucket = calloc (table->n_buckets, sizeof *table->bucket);\n<line30>if (table->bucket == NULL)\n<line31>goto fail;\n<line32>table->bucket_limit = table->bucket + table->n_buckets;\n<line33>table->n_buckets_used = 0;\n<line34>table->n_entries = 0;\n<line35>table->hasher = hasher;\n<line36>table->comparator = comparator;\n<line37>table->data_freer = data_freer;\n<line38>table->free_entry_list = NULL;\n<line39>#if USE_OBSTACK\n<line40>obstack_init (&table->entry_stack);\n<line41>#endif\n<line42>return table;\n<line43>fail:\n<line44>free (table);\n<line45>return NULL;\n<line46>}
----------------------------------------
Function: hash_clear
Content: <line0>void\n<line1>hash_clear (Hash_table *table)\n<line2>{\n<line3>struct hash_entry *bucket;\n<line4>for (bucket = table->bucket; bucket < table->bucket_limit; bucket++)\n<line5>{\n<line6>if (bucket->data)\n<line7>{\n<line8>struct hash_entry *cursor;\n<line9>struct hash_entry *next;\n<line10>/* Free the bucket overflow.  */\n<line11>for (cursor = bucket->next; cursor; cursor = next)\n<line12>{\n<line13>if (table->data_freer)\n<line14>table->data_freer (cursor->data);\n<line15>cursor->data = NULL;\n<line16>next = cursor->next;\n<line17>/* Relinking is done one entry at a time, as it is to be expected\n<line18>that overflows are either rare or short.  */\n<line19>cursor->next = table->free_entry_list;\n<line20>table->free_entry_list = cursor;\n<line21>}\n<line22>/* Free the bucket head.  */\n<line23>if (table->data_freer)\n<line24>table->data_freer (bucket->data);\n<line25>bucket->data = NULL;\n<line26>bucket->next = NULL;\n<line27>}\n<line28>}\n<line29>table->n_buckets_used = 0;\n<line30>table->n_entries = 0;\n<line31>}
----------------------------------------
Function: hash_free
Content: <line0>void\n<line1>hash_free (Hash_table *table)\n<line2>{\n<line3>struct hash_entry *bucket;\n<line4>struct hash_entry *cursor;\n<line5>struct hash_entry *next;\n<line6>int err = errno;\n<line7>/* Call the user data_freer function.  */\n<line8>if (table->data_freer && table->n_entries)\n<line9>{\n<line10>for (bucket = table->bucket; bucket < table->bucket_limit; bucket++)\n<line11>{\n<line12>if (bucket->data)\n<line13>{\n<line14>for (cursor = bucket; cursor; cursor = cursor->next)\n<line15>table->data_freer (cursor->data);\n<line16>}\n<line17>}\n<line18>}\n<line19>#if USE_OBSTACK\n<line20>obstack_free (&table->entry_stack, NULL);\n<line21>#else\n<line22>/* Free all bucket overflowed entries.  */\n<line23>for (bucket = table->bucket; bucket < table->bucket_limit; bucket++)\n<line24>{\n<line25>for (cursor = bucket->next; cursor; cursor = next)\n<line26>{\n<line27>next = cursor->next;\n<line28>free (cursor);\n<line29>}\n<line30>}\n<line31>/* Also reclaim the internal list of previously freed entries.  */\n<line32>for (cursor = table->free_entry_list; cursor; cursor = next)\n<line33>{\n<line34>next = cursor->next;\n<line35>free (cursor);\n<line36>}\n<line37>#endif\n<line38>/* Free the remainder of the hash table structure.  */\n<line39>free (table->bucket);\n<line40>free (table);\n<line41>errno = err;\n<line42>}
----------------------------------------
Function: allocate_entry
Content: <line0>static struct hash_entry *\n<line1>allocate_entry (Hash_table *table)\n<line2>{\n<line3>struct hash_entry *new;\n<line4>if (table->free_entry_list)\n<line5>{\n<line6>new = table->free_entry_list;\n<line7>table->free_entry_list = new->next;\n<line8>}\n<line9>else\n<line10>{\n<line11>#if USE_OBSTACK\n<line12>new = obstack_alloc (&table->entry_stack, sizeof *new);\n<line13>#else\n<line14>new = malloc (sizeof *new);\n<line15>#endif\n<line16>}\n<line17>return new;\n<line18>}
----------------------------------------
Function: free_entry
Content: <line0>static void\n<line1>free_entry (Hash_table *table, struct hash_entry *entry)\n<line2>{\n<line3>entry->data = NULL;\n<line4>entry->next = table->free_entry_list;\n<line5>table->free_entry_list = entry;\n<line6>}
----------------------------------------
Function: hash_find_entry
Content: <line0>static void *\n<line1>hash_find_entry (Hash_table *table, const void *entry,\n<line2>struct hash_entry **bucket_head, bool delete)\n<line3>{\n<line4>struct hash_entry *bucket = safe_hasher (table, entry);\n<line5>struct hash_entry *cursor;\n<line6>*bucket_head = bucket;\n<line7>/* Test for empty bucket.  */\n<line8>if (bucket->data == NULL)\n<line9>return NULL;\n<line10>/* See if the entry is the first in the bucket.  */\n<line11>if (entry == bucket->data || table->comparator (entry, bucket->data))\n<line12>{\n<line13>void *data = bucket->data;\n<line14>if (delete)\n<line15>{\n<line16>if (bucket->next)\n<line17>{\n<line18>struct hash_entry *next = bucket->next;\n<line19>/* Bump the first overflow entry into the bucket head, then save\n<line20>the previous first overflow entry for later recycling.  */\n<line21>*bucket = *next;\n<line22>free_entry (table, next);\n<line23>}\n<line24>else\n<line25>{\n<line26>bucket->data = NULL;\n<line27>}\n<line28>}\n<line29>return data;\n<line30>}\n<line31>/* Scan the bucket overflow.  */\n<line32>for (cursor = bucket; cursor->next; cursor = cursor->next)\n<line33>{\n<line34>if (entry == cursor->next->data\n<line35>|| table->comparator (entry, cursor->next->data))\n<line36>{\n<line37>void *data = cursor->next->data;\n<line38>if (delete)\n<line39>{\n<line40>struct hash_entry *next = cursor->next;\n<line41>/* Unlink the entry to delete, then save the freed entry for later\n<line42>recycling.  */\n<line43>cursor->next = next->next;\n<line44>free_entry (table, next);\n<line45>}\n<line46>return data;\n<line47>}\n<line48>}\n<line49>/* No entry found.  */\n<line50>return NULL;\n<line51>}
----------------------------------------
Function: transfer_entries
Content: <line0>static bool\n<line1>transfer_entries (Hash_table *dst, Hash_table *src, bool safe)\n<line2>{\n<line3>struct hash_entry *bucket;\n<line4>struct hash_entry *cursor;\n<line5>struct hash_entry *next;\n<line6>for (bucket = src->bucket; bucket < src->bucket_limit; bucket++)\n<line7>if (bucket->data)\n<line8>{\n<line9>void *data;\n<line10>struct hash_entry *new_bucket;\n<line11>/* Within each bucket, transfer overflow entries first and\n<line12>then the bucket head, to minimize memory pressure.  After\n<line13>all, the only time we might allocate is when moving the\n<line14>bucket head, but moving overflow entries first may create\n<line15>free entries that can be recycled by the time we finally\n<line16>get to the bucket head.  */\n<line17>for (cursor = bucket->next; cursor; cursor = next)\n<line18>{\n<line19>data = cursor->data;\n<line20>new_bucket = safe_hasher (dst, data);\n<line21>next = cursor->next;\n<line22>if (new_bucket->data)\n<line23>{\n<line24>/* Merely relink an existing entry, when moving from a\n<line25>bucket overflow into a bucket overflow.  */\n<line26>cursor->next = new_bucket->next;\n<line27>new_bucket->next = cursor;\n<line28>}\n<line29>else\n<line30>{\n<line31>/* Free an existing entry, when moving from a bucket\n<line32>overflow into a bucket header.  */\n<line33>new_bucket->data = data;\n<line34>dst->n_buckets_used++;\n<line35>free_entry (dst, cursor);\n<line36>}\n<line37>}\n<line38>/* Now move the bucket head.  Be sure that if we fail due to\n<line39>allocation failure that the src table is in a consistent\n<line40>state.  */\n<line41>data = bucket->data;\n<line42>bucket->next = NULL;\n<line43>if (safe)\n<line44>continue;\n<line45>new_bucket = safe_hasher (dst, data);\n<line46>if (new_bucket->data)\n<line47>{\n<line48>/* Allocate or recycle an entry, when moving from a bucket\n<line49>header into a bucket overflow.  */\n<line50>struct hash_entry *new_entry = allocate_entry (dst);\n<line51>if (new_entry == NULL)\n<line52>return false;\n<line53>new_entry->data = data;\n<line54>new_entry->next = new_bucket->next;\n<line55>new_bucket->next = new_entry;\n<line56>}\n<line57>else\n<line58>{\n<line59>/* Move from one bucket header to another.  */\n<line60>new_bucket->data = data;\n<line61>dst->n_buckets_used++;\n<line62>}\n<line63>bucket->data = NULL;\n<line64>src->n_buckets_used--;\n<line65>}\n<line66>return true;\n<line67>}
----------------------------------------
Function: hash_insert_if_absent
Content: <line0>int\n<line1>hash_insert_if_absent (Hash_table *table, void const *entry,\n<line2>void const **matched_ent)\n<line3>{\n<line4>void *data;\n<line5>struct hash_entry *bucket;\n<line6>/* The caller cannot insert a NULL entry, since hash_lookup returns NULL\n<line7>to indicate "not found", and hash_find_entry uses "bucket->data == NULL"\n<line8>to indicate an empty bucket.  */\n<line9>if (! entry)\n<line10>abort ();\n<line11>/* If there's a matching entry already in the table, return that.  */\n<line12>if ((data = hash_find_entry (table, entry, &bucket, false)) != NULL)\n<line13>{\n<line14>if (matched_ent)\n<line15>*matched_ent = data;\n<line16>return 0;\n<line17>}\n<line18>/* If the growth threshold of the buckets in use has been reached, increase\n<line19>the table size and rehash.  There's no point in checking the number of\n<line20>entries:  if the hashing function is ill-conditioned, rehashing is not\n<line21>likely to improve it.  */\n<line22>if (table->n_buckets_used\n<line23>> table->tuning->growth_threshold * table->n_buckets)\n<line24>{\n<line25>/* Check more fully, before starting real work.  If tuning arguments\n<line26>became invalid, the second check will rely on proper defaults.  */\n<line27>check_tuning (table);\n<line28>if (table->n_buckets_used\n<line29>> table->tuning->growth_threshold * table->n_buckets)\n<line30>{\n<line31>const Hash_tuning *tuning = table->tuning;\n<line32>float candidate =\n<line33>(tuning->is_n_buckets\n<line34>? (table->n_buckets * tuning->growth_factor)\n<line35>: (table->n_buckets * tuning->growth_factor\n<line36>* tuning->growth_threshold));\n<line37>if ((float) SIZE_MAX <= candidate)\n<line38>{\n<line39>errno = ENOMEM;\n<line40>return -1;\n<line41>}\n<line42>/* If the rehash fails, arrange to return NULL.  */\n<line43>if (!hash_rehash (table, candidate))\n<line44>return -1;\n<line45>/* Update the bucket we are interested in.  */\n<line46>if (hash_find_entry (table, entry, &bucket, false) != NULL)\n<line47>abort ();\n<line48>}\n<line49>}\n<line50>/* ENTRY is not matched, it should be inserted.  */\n<line51>if (bucket->data)\n<line52>{\n<line53>struct hash_entry *new_entry = allocate_entry (table);\n<line54>if (new_entry == NULL)\n<line55>return -1;\n<line56>/* Add ENTRY in the overflow of the bucket.  */\n<line57>new_entry->data = (void *) entry;\n<line58>new_entry->next = bucket->next;\n<line59>bucket->next = new_entry;\n<line60>table->n_entries++;\n<line61>return 1;\n<line62>}\n<line63>/* Add ENTRY right in the bucket head.  */\n<line64>bucket->data = (void *) entry;\n<line65>table->n_entries++;\n<line66>table->n_buckets_used++;\n<line67>return 1;\n<line68>}
----------------------------------------
Function: hash_insert
Content: <line0>void *\n<line1>hash_insert (Hash_table *table, void const *entry)\n<line2>{\n<line3>void const *matched_ent;\n<line4>int err = hash_insert_if_absent (table, entry, &matched_ent);\n<line5>return (err == -1\n<line6>? NULL\n<line7>: (void *) (err == 0 ? matched_ent : entry));\n<line8>}
----------------------------------------
Function: hash_remove
Content: <line0>void *\n<line1>hash_remove (Hash_table *table, const void *entry)\n<line2>{\n<line3>void *data;\n<line4>struct hash_entry *bucket;\n<line5>data = hash_find_entry (table, entry, &bucket, true);\n<line6>if (!data)\n<line7>return NULL;\n<line8>table->n_entries--;\n<line9>if (!bucket->data)\n<line10>{\n<line11>table->n_buckets_used--;\n<line12>/* If the shrink threshold of the buckets in use has been reached,\n<line13>rehash into a smaller table.  */\n<line14>if (table->n_buckets_used\n<line15>< table->tuning->shrink_threshold * table->n_buckets)\n<line16>{\n<line17>/* Check more fully, before starting real work.  If tuning arguments\n<line18>became invalid, the second check will rely on proper defaults.  */\n<line19>check_tuning (table);\n<line20>if (table->n_buckets_used\n<line21>< table->tuning->shrink_threshold * table->n_buckets)\n<line22>{\n<line23>const Hash_tuning *tuning = table->tuning;\n<line24>size_t candidate =\n<line25>(tuning->is_n_buckets\n<line26>? table->n_buckets * tuning->shrink_factor\n<line27>: (table->n_buckets * tuning->shrink_factor\n<line28>* tuning->growth_threshold));\n<line29>if (!hash_rehash (table, candidate))\n<line30>{\n<line31>/* Failure to allocate memory in an attempt to\n<line32>shrink the table is not fatal.  But since memory\n<line33>is low, we can at least be kind and free any\n<line34>spare entries, rather than keeping them tied up\n<line35>in the free entry list.  */\n<line36>#if ! USE_OBSTACK\n<line37>struct hash_entry *cursor = table->free_entry_list;\n<line38>struct hash_entry *next;\n<line39>while (cursor)\n<line40>{\n<line41>next = cursor->next;\n<line42>free (cursor);\n<line43>cursor = next;\n<line44>}\n<line45>table->free_entry_list = NULL;\n<line46>#endif\n<line47>}\n<line48>}\n<line49>}\n<line50>}\n<line51>return data;\n<line52>}
----------------------------------------
Function: hash_delete
Content: <line0>void *\n<line1>hash_delete (Hash_table *table, const void *entry)\n<line2>{\n<line3>return hash_remove (table, entry);\n<line4>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/hash-pjw.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
Function: hash_pjw
Content: <line0>size_t\n<line1>hash_pjw (const void *x, size_t tablesize)\n<line2>{\n<line3>const char *s;\n<line4>size_t h = 0;\n<line5>for (s = x; *s; s++)\n<line6>h = *s + ((h << 9) | (h >> (SIZE_BITS - 9)));\n<line7>return h % tablesize;\n<line8>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/hash-triple.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
Function: triple_hash_no_name
Content: <line0>size_t\n<line1>triple_hash_no_name (void const *x, size_t table_size)\n<line2>{\n<line3>struct F_triple const *p = x;\n<line4>/* Ignoring the device number here should be fine.  */\n<line5>return p->st_ino % table_size;\n<line6>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/hash-triple-simple.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
Function: triple_hash
Content: <line0>size_t\n<line1>triple_hash (void const *x, size_t table_size)\n<line2>{\n<line3>struct F_triple const *p = x;\n<line4>size_t tmp = hash_pjw (p->name, table_size);\n<line5>/* Ignoring the device number here should be fine.  */\n<line6>return (tmp ^ p->st_ino) % table_size;\n<line7>}
----------------------------------------
Function: triple_free
Content: <line0>void\n<line1>triple_free (void *x)\n<line2>{\n<line3>struct F_triple *a = x;\n<line4>free (a->name);\n<line5>free (a);\n<line6>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/heap.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
Function: heap_alloc
Content: <line0>struct heap *\n<line1>heap_alloc (int (*compare) (void const *, void const *), size_t n_reserve)\n<line2>{\n<line3>struct heap *heap = xmalloc (sizeof *heap);\n<line4>if (n_reserve == 0)\n<line5>n_reserve = 1;\n<line6>heap->array = xnmalloc (n_reserve, sizeof *(heap->array));\n<line7>heap->array[0] = nullptr;\n<line8>heap->capacity = n_reserve;\n<line9>heap->count = 0;\n<line10>heap->compare = compare ? compare : heap_default_compare;\n<line11>return heap;\n<line12>}
----------------------------------------
Function: heap_default_compare
Content: <line0>static int\n<line1>heap_default_compare (void const *a, void const *b)\n<line2>{\n<line3>return 0;\n<line4>}
----------------------------------------
Function: heap_free
Content: <line0>void\n<line1>heap_free (struct heap *heap)\n<line2>{\n<line3>free (heap->array);\n<line4>free (heap);\n<line5>}
----------------------------------------
Function: heap_insert
Content: <line0>int\n<line1>heap_insert (struct heap *heap, void *item)\n<line2>{\n<line3>if (heap->capacity - 1 <= heap->count)\n<line4>heap->array = x2nrealloc (heap->array, &heap->capacity,\n<line5>sizeof *(heap->array));\n<line6>heap->array[++heap->count] = item;\n<line7>heapify_up (heap->array, heap->count, heap->compare);\n<line8>return 0;\n<line9>}
----------------------------------------
Function: heap_remove_top
Content: <line0>void *\n<line1>heap_remove_top (struct heap *heap)\n<line2>{\n<line3>void *top;\n<line4>if (heap->count == 0)\n<line5>return nullptr;\n<line6>top = heap->array[1];\n<line7>heap->array[1] = heap->array[heap->count--];\n<line8>heapify_down (heap->array, heap->count, 1, heap->compare);\n<line9>return top;\n<line10>}
----------------------------------------
Function: heapify_down
Content: <line0>static size_t\n<line1>heapify_down (void **array, size_t count, size_t initial,\n<line2>int (*compare) (void const *, void const *))\n<line3>{\n<line4>void *element = array[initial];\n<line5>size_t parent = initial;\n<line6>while (parent <= count / 2)\n<line7>{\n<line8>size_t child = 2 * parent;\n<line9>if (child < count && compare (array[child], array[child + 1]) < 0)\n<line10>child++;\n<line11>if (compare (array[child], element) <= 0)\n<line12>break;\n<line13>array[parent] = array[child];\n<line14>parent = child;\n<line15>}\n<line16>array[parent] = element;\n<line17>return parent;\n<line18>}
----------------------------------------
Function: heapify_up
Content: <line0>static void\n<line1>heapify_up (void **array, size_t count,\n<line2>int (*compare) (void const *, void const *))\n<line3>{\n<line4>size_t k = count;\n<line5>void *new_element = array[k];\n<line6>while (k != 1 && compare (array[k / 2], new_element) <= 0)\n<line7>{\n<line8>array[k] = array[k / 2];\n<line9>k /= 2;\n<line10>}\n<line11>array[k] = new_element;\n<line12>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/human.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
Function: adjust_value
Content: <line0>static long double\n<line1>adjust_value (int inexact_style, long double value)\n<line2>{\n<line3>/* Do not use the floorl or ceill functions, as that would mean\n<line4>checking for their presence and possibly linking with the\n<line5>standard math library, which is a porting pain.  So leave the\n<line6>value alone if it is too large to easily round.  */\n<line7>if (inexact_style != human_round_to_nearest && value < UINTMAX_MAX)\n<line8>{\n<line9>uintmax_t u = value;\n<line10>value = u + (inexact_style == human_ceiling && u != value);\n<line11>}\n<line12>return value;\n<line13>}
----------------------------------------
Function: group_number
Content: <line0>static char *\n<line1>group_number (char *number, size_t numberlen,\n<line2>char const *grouping, char const *thousands_sep)\n<line3>{\n<line4>register char *d;\n<line5>size_t grouplen = SIZE_MAX;\n<line6>size_t thousands_seplen = strlen (thousands_sep);\n<line7>size_t i = numberlen;\n<line8>/* The maximum possible value for NUMBERLEN is the number of digits\n<line9>in the square of the largest uintmax_t, so double the size needed.  */\n<line10>char buf[2 * INT_STRLEN_BOUND (uintmax_t) + 1];\n<line11>memcpy (buf, number, numberlen);\n<line12>d = number + numberlen;\n<line13>for (;;)\n<line14>{\n<line15>unsigned char g = *grouping;\n<line16>if (g)\n<line17>{\n<line18>grouplen = g < CHAR_MAX ? g : i;\n<line19>grouping++;\n<line20>}\n<line21>if (i < grouplen)\n<line22>grouplen = i;\n<line23>d -= grouplen;\n<line24>i -= grouplen;\n<line25>memcpy (d, buf + i, grouplen);\n<line26>if (i == 0)\n<line27>return d;\n<line28>d -= thousands_seplen;\n<line29>memcpy (d, thousands_sep, thousands_seplen);\n<line30>}\n<line31>}
----------------------------------------
Function: human_readable
Content: <line0>char *\n<line1>human_readable (uintmax_t n, char *buf, int opts,\n<line2>uintmax_t from_block_size, uintmax_t to_block_size)\n<line3>{\n<line4>int inexact_style =\n<line5>opts & (human_round_to_nearest | human_floor | human_ceiling);\n<line6>unsigned int base = opts & human_base_1024 ? 1024 : 1000;\n<line7>uintmax_t amt;\n<line8>int tenths;\n<line9>int exponent = -1;\n<line10>int exponent_max = sizeof power_letter - 1;\n<line11>char *p;\n<line12>char *psuffix;\n<line13>char const *integerlim;\n<line14>/* 0 means adjusted N == AMT.TENTHS;\n<line15>1 means AMT.TENTHS < adjusted N < AMT.TENTHS + 0.05;\n<line16>2 means adjusted N == AMT.TENTHS + 0.05;\n<line17>3 means AMT.TENTHS + 0.05 < adjusted N < AMT.TENTHS + 0.1.  */\n<line18>int rounding;\n<line19>char const *decimal_point = ".";\n<line20>size_t decimal_pointlen = 1;\n<line21>char const *grouping = "";\n<line22>char const *thousands_sep = "";\n<line23>struct lconv const *l = localeconv ();\n<line24>size_t pointlen = strlen (l->decimal_point);\n<line25>if (0 < pointlen && pointlen <= MB_LEN_MAX)\n<line26>{\n<line27>decimal_point = l->decimal_point;\n<line28>decimal_pointlen = pointlen;\n<line29>}\n<line30>grouping = l->grouping;\n<line31>if (strlen (l->thousands_sep) <= MB_LEN_MAX)\n<line32>thousands_sep = l->thousands_sep;\n<line33>/* Leave room for a trailing space and following suffix.  */\n<line34>psuffix = buf + LONGEST_HUMAN_READABLE - 1 - HUMAN_READABLE_SUFFIX_LENGTH_MAX;\n<line35>p = psuffix;\n<line36>/* Adjust AMT out of FROM_BLOCK_SIZE units and into TO_BLOCK_SIZE\n<line37>units.  If this can be done exactly with integer arithmetic, do\n<line38>not use floating point operations.  */\n<line39>if (to_block_size <= from_block_size)\n<line40>{\n<line41>if (from_block_size % to_block_size == 0)\n<line42>{\n<line43>uintmax_t multiplier = from_block_size / to_block_size;\n<line44>amt = n * multiplier;\n<line45>if (amt / multiplier == n)\n<line46>{\n<line47>tenths = 0;\n<line48>rounding = 0;\n<line49>goto use_integer_arithmetic;\n<line50>}\n<line51>}\n<line52>}\n<line53>else if (from_block_size != 0 && to_block_size % from_block_size == 0)\n<line54>{\n<line55>uintmax_t divisor = to_block_size / from_block_size;\n<line56>uintmax_t r10 = (n % divisor) * 10;\n<line57>uintmax_t r2 = (r10 % divisor) * 2;\n<line58>amt = n / divisor;\n<line59>tenths = r10 / divisor;\n<line60>rounding = r2 < divisor ? 0 < r2 : 2 + (divisor < r2);\n<line61>goto use_integer_arithmetic;\n<line62>}\n<line63>{\n<line64>/* Either the result cannot be computed easily using uintmax_t,\n<line65>or from_block_size is zero.  Fall back on floating point.\n<line66>FIXME: This can yield answers that are slightly off.  */\n<line67>long double dto_block_size = to_block_size;\n<line68>long double damt = n * (from_block_size / dto_block_size);\n<line69>size_t buflen;\n<line70>size_t nonintegerlen;\n<line71>if (! (opts & human_autoscale))\n<line72>{\n<line73>sprintf (buf, "%.0Lf", adjust_value (inexact_style, damt));\n<line74>buflen = strlen (buf);\n<line75>nonintegerlen = 0;\n<line76>}\n<line77>else\n<line78>{\n<line79>long double e = 1;\n<line80>exponent = 0;\n<line81>do\n<line82>{\n<line83>e *= base;\n<line84>exponent++;\n<line85>}\n<line86>while (e * base <= damt && exponent < exponent_max);\n<line87>damt /= e;\n<line88>sprintf (buf, "%.1Lf", adjust_value (inexact_style, damt));\n<line89>buflen = strlen (buf);\n<line90>nonintegerlen = decimal_pointlen + 1;\n<line91>if (1 + nonintegerlen + ! (opts & human_base_1024) < buflen\n<line92>|| ((opts & human_suppress_point_zero)\n<line93>&& buf[buflen - 1] == '0'))\n<line94>{\n<line95>sprintf (buf, "%.0Lf",\n<line96>adjust_value (inexact_style, damt * 10) / 10);\n<line97>buflen = strlen (buf);\n<line98>nonintegerlen = 0;\n<line99>}\n<line100>}\n<line101>p = psuffix - buflen;\n<line102>memmove (p, buf, buflen);\n<line103>integerlim = p + buflen - nonintegerlen;\n<line104>}\n<line105>goto do_grouping;\n<line106>use_integer_arithmetic:\n<line107>{\n<line108>/* The computation can be done exactly, with integer arithmetic.\n<line109>Use power of BASE notation if requested and if adjusted AMT is\n<line110>large enough.  */\n<line111>if (opts & human_autoscale)\n<line112>{\n<line113>exponent = 0;\n<line114>if (base <= amt)\n<line115>{\n<line116>do\n<line117>{\n<line118>unsigned int r10 = (amt % base) * 10 + tenths;\n<line119>unsigned int r2 = (r10 % base) * 2 + (rounding >> 1);\n<line120>amt /= base;\n<line121>tenths = r10 / base;\n<line122>rounding = (r2 < base\n<line123>? (r2 + rounding) != 0\n<line124>: 2 + (base < r2 + rounding));\n<line125>exponent++;\n<line126>}\n<line127>while (base <= amt && exponent < exponent_max);\n<line128>if (amt < 10)\n<line129>{\n<line130>if (inexact_style == human_round_to_nearest\n<line131>? 2 < rounding + (tenths & 1)\n<line132>: inexact_style == human_ceiling && 0 < rounding)\n<line133>{\n<line134>tenths++;\n<line135>rounding = 0;\n<line136>if (tenths == 10)\n<line137>{\n<line138>amt++;\n<line139>tenths = 0;\n<line140>}\n<line141>}\n<line142>if (amt < 10\n<line143>&& (tenths || ! (opts & human_suppress_point_zero)))\n<line144>{\n<line145>*--p = '0' + tenths;\n<line146>p -= decimal_pointlen;\n<line147>memcpy (p, decimal_point, decimal_pointlen);\n<line148>tenths = rounding = 0;\n<line149>}\n<line150>}\n<line151>}\n<line152>}\n<line153>if (inexact_style == human_round_to_nearest\n<line154>? 5 < tenths + (0 < rounding + (amt & 1))\n<line155>: inexact_style == human_ceiling && 0 < tenths + rounding)\n<line156>{\n<line157>amt++;\n<line158>if ((opts & human_autoscale)\n<line159>&& amt == base && exponent < exponent_max)\n<line160>{\n<line161>exponent++;\n<line162>if (! (opts & human_suppress_point_zero))\n<line163>{\n<line164>*--p = '0';\n<line165>p -= decimal_pointlen;\n<line166>memcpy (p, decimal_point, decimal_pointlen);\n<line167>}\n<line168>amt = 1;\n<line169>}\n<line170>}\n<line171>integerlim = p;\n<line172>do\n<line173>{\n<line174>int digit = amt % 10;\n<line175>*--p = digit + '0';\n<line176>}\n<line177>while ((amt /= 10) != 0);\n<line178>}\n<line179>do_grouping:\n<line180>if (opts & human_group_digits)\n<line181>p = group_number (p, integerlim - p, grouping, thousands_sep);\n<line182>if (opts & human_SI)\n<line183>{\n<line184>if (exponent < 0)\n<line185>{\n<line186>uintmax_t power;\n<line187>exponent = 0;\n<line188>for (power = 1; power < to_block_size; power *= base)\n<line189>if (++exponent == exponent_max)\n<line190>break;\n<line191>}\n<line192>if ((exponent | (opts & human_B)) && (opts & human_space_before_unit))\n<line193>*psuffix++ = ' ';\n<line194>if (exponent)\n<line195>*psuffix++ = (! (opts & human_base_1024) && exponent == 1\n<line196>? 'k'\n<line197>: power_letter[exponent]);\n<line198>if (opts & human_B)\n<line199>{\n<line200>if ((opts & human_base_1024) && exponent)\n<line201>*psuffix++ = 'i';\n<line202>*psuffix++ = 'B';\n<line203>}\n<line204>}\n<line205>*psuffix = '\0';\n<line206>return p;\n<line207>}
----------------------------------------
Function: default_block_size
Content: <line0>static uintmax_t\n<line1>default_block_size (void)\n<line2>{\n<line3>return getenv ("POSIXLY_CORRECT") ? 512 : DEFAULT_BLOCK_SIZE;\n<line4>}
----------------------------------------
Function: humblock
Content: <line0>static strtol_error\n<line1>humblock (char const *spec, uintmax_t *block_size, int *options)\n<line2>{\n<line3>int i;\n<line4>int opts = 0;\n<line5>if (! spec\n<line6>&& ! (spec = getenv ("BLOCK_SIZE"))\n<line7>&& ! (spec = getenv ("BLOCKSIZE")))\n<line8>*block_size = default_block_size ();\n<line9>else\n<line10>{\n<line11>if (*spec == '\'')\n<line12>{\n<line13>opts |= human_group_digits;\n<line14>spec++;\n<line15>}\n<line16>if (0 <= (i = ARGMATCH (spec, block_size_args, block_size_opts)))\n<line17>{\n<line18>opts |= block_size_opts[i];\n<line19>*block_size = 1;\n<line20>}\n<line21>else\n<line22>{\n<line23>char *ptr;\n<line24>strtol_error e = xstrtoumax (spec, &ptr, 0, block_size,\n<line25>"eEgGkKmMpPtTyYzZ0");\n<line26>if (e != LONGINT_OK)\n<line27>{\n<line28>*options = 0;\n<line29>return e;\n<line30>}\n<line31>for (; ! ('0' <= *spec && *spec <= '9'); spec++)\n<line32>if (spec == ptr)\n<line33>{\n<line34>opts |= human_SI;\n<line35>if (ptr[-1] == 'B')\n<line36>opts |= human_B;\n<line37>if (ptr[-1] != 'B' || ptr[-2] == 'i')\n<line38>opts |= human_base_1024;\n<line39>break;\n<line40>}\n<line41>}\n<line42>}\n<line43>*options = opts;\n<line44>return LONGINT_OK;\n<line45>}
----------------------------------------
Function: human_options
Content: <line0>enum strtol_error\n<line1>human_options (char const *spec, int *opts, uintmax_t *block_size)\n<line2>{\n<line3>strtol_error e = humblock (spec, block_size, opts);\n<line4>if (*block_size == 0)\n<line5>{\n<line6>*block_size = default_block_size ();\n<line7>e = LONGINT_INVALID;\n<line8>}\n<line9>return e;\n<line10>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/i-ring.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
In file included from /home/huihui/Downloads/coreutils-9.4/lib/i-ring.c:20:
./lib/i-ring.h:24:32: warning: '_Static_assert' with no message is a C2x extension [-Wc2x-extensions]
static_assert (1 <= I_RING_SIZE);
                               ^
                               , ""
2 warnings generated.
Function: i_ring_init
Content: <line0>void\n<line1>i_ring_init (I_ring *ir, int default_val)\n<line2>{\n<line3>int i;\n<line4>ir->ir_empty = true;\n<line5>ir->ir_front = 0;\n<line6>ir->ir_back = 0;\n<line7>for (i = 0; i < I_RING_SIZE; i++)\n<line8>ir->ir_data[i] = default_val;\n<line9>ir->ir_default_val = default_val;\n<line10>}
----------------------------------------
Function: i_ring_push
Content: <line0>int\n<line1>i_ring_push (I_ring *ir, int val)\n<line2>{\n<line3>unsigned int dest_idx = (ir->ir_front + !ir->ir_empty) % I_RING_SIZE;\n<line4>int old_val = ir->ir_data[dest_idx];\n<line5>ir->ir_data[dest_idx] = val;\n<line6>ir->ir_front = dest_idx;\n<line7>if (dest_idx == ir->ir_back)\n<line8>ir->ir_back = (ir->ir_back + !ir->ir_empty) % I_RING_SIZE;\n<line9>ir->ir_empty = false;\n<line10>return old_val;\n<line11>}
----------------------------------------
Function: i_ring_pop
Content: <line0>int\n<line1>i_ring_pop (I_ring *ir)\n<line2>{\n<line3>int top_val;\n<line4>if (i_ring_empty (ir))\n<line5>abort ();\n<line6>top_val = ir->ir_data[ir->ir_front];\n<line7>ir->ir_data[ir->ir_front] = ir->ir_default_val;\n<line8>if (ir->ir_front == ir->ir_back)\n<line9>ir->ir_empty = true;\n<line10>else\n<line11>ir->ir_front = ((ir->ir_front + I_RING_SIZE - 1) % I_RING_SIZE);\n<line12>return top_val;\n<line13>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/ialloc.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
========================================
/home/huihui/Downloads/coreutils-9.4/lib/idcache.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
Function: getuser
Content: <line0>char *\n<line1>getuser (uid_t uid)\n<line2>{\n<line3>struct userid *tail;\n<line4>struct userid *match = NULL;\n<line5>for (tail = user_alist; tail; tail = tail->next)\n<line6>{\n<line7>if (tail->id.u == uid)\n<line8>{\n<line9>match = tail;\n<line10>break;\n<line11>}\n<line12>}\n<line13>if (match == NULL)\n<line14>{\n<line15>struct passwd *pwent = getpwuid (uid);\n<line16>char const *name = pwent ? pwent->pw_name : "";\n<line17>match = xmalloc (FLEXSIZEOF (struct userid, name, strlen (name) + 1));\n<line18>match->id.u = uid;\n<line19>strcpy (match->name, name);\n<line20>/* Add to the head of the list, so most recently used is first.  */\n<line21>match->next = user_alist;\n<line22>user_alist = match;\n<line23>}\n<line24>return match->name[0] ? match->name : NULL;\n<line25>}
----------------------------------------
Function: getuidbyname
Content: <line0>uid_t *\n<line1>getuidbyname (const char *user)\n<line2>{\n<line3>struct userid *tail;\n<line4>struct passwd *pwent;\n<line5>for (tail = user_alist; tail; tail = tail->next)\n<line6>/* Avoid a function call for the most common case.  */\n<line7>if (*tail->name == *user && !strcmp (tail->name, user))\n<line8>return &tail->id.u;\n<line9>for (tail = nouser_alist; tail; tail = tail->next)\n<line10>/* Avoid a function call for the most common case.  */\n<line11>if (*tail->name == *user && !strcmp (tail->name, user))\n<line12>return NULL;\n<line13>pwent = getpwnam (user);\n<line14>#ifdef __DJGPP__\n<line15>/* We need to pretend to be the user USER, to make\n<line16>pwd functions know about an arbitrary user name.  */\n<line17>if (!pwent && strspn (user, digits) < strlen (user))\n<line18>{\n<line19>setenv ("USER", user, 1);\n<line20>pwent = getpwnam (user);  /* now it will succeed */\n<line21>}\n<line22>#endif\n<line23>tail = xmalloc (FLEXSIZEOF (struct userid, name, strlen (user) + 1));\n<line24>strcpy (tail->name, user);\n<line25>/* Add to the head of the list, so most recently used is first.  */\n<line26>if (pwent)\n<line27>{\n<line28>tail->id.u = pwent->pw_uid;\n<line29>tail->next = user_alist;\n<line30>user_alist = tail;\n<line31>return &tail->id.u;\n<line32>}\n<line33>tail->next = nouser_alist;\n<line34>nouser_alist = tail;\n<line35>return NULL;\n<line36>}
----------------------------------------
Function: getgroup
Content: <line0>char *\n<line1>getgroup (gid_t gid)\n<line2>{\n<line3>struct userid *tail;\n<line4>struct userid *match = NULL;\n<line5>for (tail = group_alist; tail; tail = tail->next)\n<line6>{\n<line7>if (tail->id.g == gid)\n<line8>{\n<line9>match = tail;\n<line10>break;\n<line11>}\n<line12>}\n<line13>if (match == NULL)\n<line14>{\n<line15>struct group *grent = getgrgid (gid);\n<line16>char const *name = grent ? grent->gr_name : "";\n<line17>match = xmalloc (FLEXSIZEOF (struct userid, name, strlen (name) + 1));\n<line18>match->id.g = gid;\n<line19>strcpy (match->name, name);\n<line20>/* Add to the head of the list, so most recently used is first.  */\n<line21>match->next = group_alist;\n<line22>group_alist = match;\n<line23>}\n<line24>return match->name[0] ? match->name : NULL;\n<line25>}
----------------------------------------
Function: getgidbyname
Content: <line0>gid_t *\n<line1>getgidbyname (const char *group)\n<line2>{\n<line3>struct userid *tail;\n<line4>struct group *grent;\n<line5>for (tail = group_alist; tail; tail = tail->next)\n<line6>/* Avoid a function call for the most common case.  */\n<line7>if (*tail->name == *group && !strcmp (tail->name, group))\n<line8>return &tail->id.g;\n<line9>for (tail = nogroup_alist; tail; tail = tail->next)\n<line10>/* Avoid a function call for the most common case.  */\n<line11>if (*tail->name == *group && !strcmp (tail->name, group))\n<line12>return NULL;\n<line13>grent = getgrnam (group);\n<line14>#ifdef __DJGPP__\n<line15>/* We need to pretend to belong to group GROUP, to make\n<line16>grp functions know about an arbitrary group name.  */\n<line17>if (!grent && strspn (group, digits) < strlen (group))\n<line18>{\n<line19>setenv ("GROUP", group, 1);\n<line20>grent = getgrnam (group); /* now it will succeed */\n<line21>}\n<line22>#endif\n<line23>tail = xmalloc (FLEXSIZEOF (struct userid, name, strlen (group) + 1));\n<line24>strcpy (tail->name, group);\n<line25>/* Add to the head of the list, so most recently used is first.  */\n<line26>if (grent)\n<line27>{\n<line28>tail->id.g = grent->gr_gid;\n<line29>tail->next = group_alist;\n<line30>group_alist = tail;\n<line31>return &tail->id.g;\n<line32>}\n<line33>tail->next = nogroup_alist;\n<line34>nogroup_alist = tail;\n<line35>return NULL;\n<line36>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/ino-map.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
/home/huihui/Downloads/coreutils-9.4/lib/ino-map.c:153:53: warning: '_Static_assert' with no message is a C2x extension [-Wc2x-extensions]
      static_assert (INO_MAP_INSERT_FAILURE + 1 == 0);
                                                    ^
                                                    , ""
2 warnings generated.
Function: ino_hash
Content: <line0>static size_t\n<line1>ino_hash (void const *x, size_t table_size)\n<line2>{\n<line3>struct ino_map_ent const *p = x;\n<line4>ino_t ino = p->ino;\n<line5>/* When INO is wider than size_t, exclusive-OR the words of INO into H.\n<line6>This avoids loss of info, without applying % to the wider type,\n<line7>which could be quite slow on some systems.  */\n<line8>size_t h = ino;\n<line9>unsigned int i;\n<line10>unsigned int n_words = sizeof ino / sizeof h + (sizeof ino % sizeof h != 0);\n<line11>for (i = 1; i < n_words; i++)\n<line12>h ^= ino >> CHAR_BIT * sizeof h * i;\n<line13>return h % table_size;\n<line14>}
----------------------------------------
Function: ino_compare
Content: <line0>static bool\n<line1>ino_compare (void const *x, void const *y)\n<line2>{\n<line3>struct ino_map_ent const *a = x;\n<line4>struct ino_map_ent const *b = y;\n<line5>return a->ino == b->ino;\n<line6>}
----------------------------------------
Function: ino_map_alloc
Content: <line0>struct ino_map *\n<line1>ino_map_alloc (size_t next_mapped_ino)\n<line2>{\n<line3>struct ino_map *im = malloc (sizeof *im);\n<line4>if (im)\n<line5>{\n<line6>enum { INITIAL_INO_MAP_TABLE_SIZE = 1021 };\n<line7>im->map = hash_initialize (INITIAL_INO_MAP_TABLE_SIZE, NULL,\n<line8>ino_hash, ino_compare, free);\n<line9>if (! im->map)\n<line10>{\n<line11>free (im);\n<line12>return NULL;\n<line13>}\n<line14>im->next_mapped_ino = next_mapped_ino;\n<line15>im->probe = NULL;\n<line16>}\n<line17>return im;\n<line18>}
----------------------------------------
Function: ino_map_free
Content: <line0>void\n<line1>ino_map_free (struct ino_map *map)\n<line2>{\n<line3>hash_free (map->map);\n<line4>free (map->probe);\n<line5>free (map);\n<line6>}
----------------------------------------
Function: ino_map_insert
Content: <line0>size_t\n<line1>ino_map_insert (struct ino_map *im, ino_t ino)\n<line2>{\n<line3>struct ino_map_ent *ent;\n<line4>/* Find space for the probe, reusing the cache if available.  */\n<line5>struct ino_map_ent *probe = im->probe;\n<line6>if (probe)\n<line7>{\n<line8>/* If repeating a recent query, return the cached result.   */\n<line9>if (probe->ino == ino)\n<line10>return probe->mapped_ino;\n<line11>}\n<line12>else\n<line13>{\n<line14>im->probe = probe = malloc (sizeof *probe);\n<line15>if (! probe)\n<line16>return INO_MAP_INSERT_FAILURE;\n<line17>}\n<line18>probe->ino = ino;\n<line19>ent = hash_insert (im->map, probe);\n<line20>if (! ent)\n<line21>return INO_MAP_INSERT_FAILURE;\n<line22>if (ent != probe)\n<line23>{\n<line24>/* Use the existing entry.  */\n<line25>probe->mapped_ino = ent->mapped_ino;\n<line26>}\n<line27>else\n<line28>{\n<line29>/* If adding 1 to map->next_mapped_ino would cause it to\n<line30>overflow to zero, then it must equal INO_MAP_INSERT_FAILURE,\n<line31>which is the value that should be returned in that case.\n<line32>Verify that this works.  */\n<line33>static_assert (INO_MAP_INSERT_FAILURE + 1 == 0);\n<line34>/* Prepare to allocate a new probe next time; this one is in use.  */\n<line35>im->probe = NULL;\n<line36>/* INO is new; allocate a mapped inode number for it.  */\n<line37>probe->mapped_ino = im->next_mapped_ino++;\n<line38>}\n<line39>return probe->mapped_ino;\n<line40>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/imaxtostr.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
========================================
/home/huihui/Downloads/coreutils-9.4/lib/inttostr.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
========================================
/home/huihui/Downloads/coreutils-9.4/lib/offtostr.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
========================================
/home/huihui/Downloads/coreutils-9.4/lib/uinttostr.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
========================================
/home/huihui/Downloads/coreutils-9.4/lib/umaxtostr.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
========================================
/home/huihui/Downloads/coreutils-9.4/lib/isapipe.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
Function: isapipe
Content: <line0>int\n<line1>isapipe (int fd)\n<line2>{\n<line3>nlink_t pipe_link_count_max = PIPE_LINK_COUNT_MAX;\n<line4>bool check_for_fifo = (HAVE_FIFO_PIPES == 1);\n<line5>struct stat st;\n<line6>int fstat_result = fstat (fd, &st);\n<line7>if (fstat_result != 0)\n<line8>return fstat_result;\n<line9>/* We want something that succeeds only for pipes, but on\n<line10>POSIX-conforming hosts S_ISFIFO succeeds for both FIFOs and pipes\n<line11>and we know of no portable, reliable way to distinguish them in\n<line12>general.  However, in practice pipes always have a link count <=\n<line13>PIPE_LINK_COUNT_MAX (unless someone attaches them to the file\n<line14>system name space using fattach, in which case they're not really\n<line15>pipes any more), so test for that as well.\n<line16>On Darwin 7.7, pipes are sockets, so check for those instead.  */\n<line17>if (! ((HAVE_FIFO_PIPES == 0 || HAVE_FIFO_PIPES == 1)\n<line18>&& PIPE_LINK_COUNT_MAX != (nlink_t) -1)\n<line19>&& (S_ISFIFO (st.st_mode) | S_ISSOCK (st.st_mode)))\n<line20>{\n<line21>int fd_pair[2];\n<line22>int pipe_result = pipe (fd_pair);\n<line23>if (pipe_result != 0)\n<line24>return pipe_result;\n<line25>else\n<line26>{\n<line27>struct stat pipe_st;\n<line28>int fstat_pipe_result = fstat (fd_pair[0], &pipe_st);\n<line29>int fstat_pipe_errno = errno;\n<line30>close (fd_pair[0]);\n<line31>close (fd_pair[1]);\n<line32>if (fstat_pipe_result != 0)\n<line33>{\n<line34>errno = fstat_pipe_errno;\n<line35>return fstat_pipe_result;\n<line36>}\n<line37>check_for_fifo = (S_ISFIFO (pipe_st.st_mode) != 0);\n<line38>pipe_link_count_max = pipe_st.st_nlink;\n<line39>}\n<line40>}\n<line41>return\n<line42>(st.st_nlink <= pipe_link_count_max\n<line43>&& (check_for_fifo ? S_ISFIFO (st.st_mode) : S_ISSOCK (st.st_mode)));\n<line44>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/ldtoastr.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
========================================
/home/huihui/Downloads/coreutils-9.4/lib/mini-gmp-gnulib.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
========================================
/home/huihui/Downloads/coreutils-9.4/lib/linebuffer.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
Function: initbuffer
Content: <line0>void\n<line1>initbuffer (struct linebuffer *linebuffer)\n<line2>{\n<line3>memset (linebuffer, 0, sizeof *linebuffer);\n<line4>}
----------------------------------------
Function: readlinebuffer
Content: <line0>struct linebuffer *\n<line1>readlinebuffer (struct linebuffer *linebuffer, FILE *stream)\n<line2>{\n<line3>return readlinebuffer_delim (linebuffer, stream, '\n');\n<line4>}
----------------------------------------
Function: readlinebuffer_delim
Content: <line0>struct linebuffer *\n<line1>readlinebuffer_delim (struct linebuffer *linebuffer, FILE *stream,\n<line2>char delimiter)\n<line3>{\n<line4>int c;\n<line5>char *buffer = linebuffer->buffer;\n<line6>char *p = linebuffer->buffer;\n<line7>char *end = buffer + linebuffer->size; /* Sentinel. */\n<line8>if (feof (stream))\n<line9>return NULL;\n<line10>do\n<line11>{\n<line12>c = getc (stream);\n<line13>if (c == EOF)\n<line14>{\n<line15>if (p == buffer || ferror (stream))\n<line16>return NULL;\n<line17>if (p[-1] == delimiter)\n<line18>break;\n<line19>c = delimiter;\n<line20>}\n<line21>if (p == end)\n<line22>{\n<line23>idx_t oldsize = linebuffer->size;\n<line24>buffer = xpalloc (buffer, &linebuffer->size, 1, -1, 1);\n<line25>p = buffer + oldsize;\n<line26>linebuffer->buffer = buffer;\n<line27>end = buffer + linebuffer->size;\n<line28>}\n<line29>*p++ = c;\n<line30>}\n<line31>while (c != delimiter);\n<line32>linebuffer->length = p - buffer;\n<line33>return linebuffer;\n<line34>}
----------------------------------------
Function: freebuffer
Content: <line0>void\n<line1>freebuffer (struct linebuffer *linebuffer)\n<line2>{\n<line3>free (linebuffer->buffer);\n<line4>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/localcharset.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
Function: locale_charset
Content: <line0>const char *\n<line1>locale_charset (void)\n<line2>{\n<line3>const char *codeset;\n<line4>/* This function must be multithread-safe.  To achieve this without using\n<line5>thread-local storage, we use a simple strcpy or memcpy to fill this static\n<line6>buffer.  Filling it through, for example, strcpy + strcat would not be\n<line7>guaranteed to leave the buffer's contents intact if another thread is\n<line8>currently accessing it.  If necessary, the contents is first assembled in\n<line9>a stack-allocated buffer.  */\n<line10>#if HAVE_LANGINFO_CODESET || defined WINDOWS_NATIVE || defined OS2\n<line11># if HAVE_LANGINFO_CODESET\n<line12>/* Most systems support nl_langinfo (CODESET) nowadays.  */\n<line13>codeset = nl_langinfo (CODESET);\n<line14>#  ifdef __CYGWIN__\n<line15>/* Cygwin < 1.7 does not have locales.  nl_langinfo (CODESET) always\n<line16>returns "US-ASCII".  Return the suffix of the locale name from the\n<line17>environment variables (if present) or the codepage as a number.  */\n<line18>if (codeset != NULL && strcmp (codeset, "US-ASCII") == 0)\n<line19>{\n<line20>const char *locale;\n<line21>static char resultbuf[2 + 10 + 1];\n<line22>locale = getenv ("LC_ALL");\n<line23>if (locale == NULL || locale[0] == '\0')\n<line24>{\n<line25>locale = getenv ("LC_CTYPE");\n<line26>if (locale == NULL || locale[0] == '\0')\n<line27>locale = getenv ("LANG");\n<line28>}\n<line29>if (locale != NULL && locale[0] != '\0')\n<line30>{\n<line31>/* If the locale name contains an encoding after the dot, return\n<line32>it.  */\n<line33>const char *dot = strchr (locale, '.');\n<line34>if (dot != NULL)\n<line35>{\n<line36>const char *modifier;\n<line37>dot++;\n<line38>/* Look for the possible @... trailer and remove it, if any.  */\n<line39>modifier = strchr (dot, '@');\n<line40>if (modifier == NULL)\n<line41>return dot;\n<line42>if (modifier - dot < sizeof (resultbuf))\n<line43>{\n<line44>/* This way of filling resultbuf is multithread-safe.  */\n<line45>memcpy (resultbuf, dot, modifier - dot);\n<line46>resultbuf [modifier - dot] = '\0';\n<line47>return resultbuf;\n<line48>}\n<line49>}\n<line50>}\n<line51>/* The Windows API has a function returning the locale's codepage as a\n<line52>number: GetACP().  This encoding is used by Cygwin, unless the user\n<line53>has set the environment variable CYGWIN=codepage:oem (which very few\n<line54>people do).\n<line55>Output directed to console windows needs to be converted (to\n<line56>GetOEMCP() if the console is using a raster font, or to\n<line57>GetConsoleOutputCP() if it is using a TrueType font).  Cygwin does\n<line58>this conversion transparently (see winsup/cygwin/fhandler_console.cc),\n<line59>converting to GetConsoleOutputCP().  This leads to correct results,\n<line60>except when SetConsoleOutputCP has been called and a raster font is\n<line61>in use.  */\n<line62>{\n<line63>char buf[2 + 10 + 1];\n<line64>sprintf (buf, "CP%u", GetACP ());\n<line65>strcpy (resultbuf, buf);\n<line66>codeset = resultbuf;\n<line67>}\n<line68>}\n<line69>#  endif\n<line70>if (codeset == NULL)\n<line71>/* The canonical name cannot be determined.  */\n<line72>codeset = "";\n<line73># elif defined WINDOWS_NATIVE\n<line74>char buf[2 + 10 + 1];\n<line75>static char resultbuf[2 + 10 + 1];\n<line76>/* The Windows API has a function returning the locale's codepage as\n<line77>a number, but the value doesn't change according to what the\n<line78>'setlocale' call specified.  So we use it as a last resort, in\n<line79>case the string returned by 'setlocale' doesn't specify the\n<line80>codepage.  */\n<line81>char *current_locale = setlocale (LC_CTYPE, NULL);\n<line82>char *pdot = strrchr (current_locale, '.');\n<line83>if (pdot && 2 + strlen (pdot + 1) + 1 <= sizeof (buf))\n<line84>sprintf (buf, "CP%s", pdot + 1);\n<line85>else\n<line86>{\n<line87>/* The Windows API has a function returning the locale's codepage as a\n<line88>number: GetACP().\n<line89>When the output goes to a console window, it needs to be provided in\n<line90>GetOEMCP() encoding if the console is using a raster font, or in\n<line91>GetConsoleOutputCP() encoding if it is using a TrueType font.\n<line92>But in GUI programs and for output sent to files and pipes, GetACP()\n<line93>encoding is the best bet.  */\n<line94>sprintf (buf, "CP%u", GetACP ());\n<line95>}\n<line96>/* For a locale name such as "French_France.65001", in Windows 10,\n<line97>setlocale now returns "French_France.utf8" instead.  */\n<line98>if (strcmp (buf + 2, "65001") == 0 || strcmp (buf + 2, "utf8") == 0)\n<line99>codeset = "UTF-8";\n<line100>else\n<line101>{\n<line102>strcpy (resultbuf, buf);\n<line103>codeset = resultbuf;\n<line104>}\n<line105># elif defined OS2\n<line106>const char *locale;\n<line107>static char resultbuf[2 + 10 + 1];\n<line108>ULONG cp[3];\n<line109>ULONG cplen;\n<line110>codeset = NULL;\n<line111>/* Allow user to override the codeset, as set in the operating system,\n<line112>with standard language environment variables.  */\n<line113>locale = getenv ("LC_ALL");\n<line114>if (locale == NULL || locale[0] == '\0')\n<line115>{\n<line116>locale = getenv ("LC_CTYPE");\n<line117>if (locale == NULL || locale[0] == '\0')\n<line118>locale = getenv ("LANG");\n<line119>}\n<line120>if (locale != NULL && locale[0] != '\0')\n<line121>{\n<line122>/* If the locale name contains an encoding after the dot, return it.  */\n<line123>const char *dot = strchr (locale, '.');\n<line124>if (dot != NULL)\n<line125>{\n<line126>const char *modifier;\n<line127>dot++;\n<line128>/* Look for the possible @... trailer and remove it, if any.  */\n<line129>modifier = strchr (dot, '@');\n<line130>if (modifier == NULL)\n<line131>return dot;\n<line132>if (modifier - dot < sizeof (resultbuf))\n<line133>{\n<line134>/* This way of filling resultbuf is multithread-safe.  */\n<line135>memcpy (resultbuf, dot, modifier - dot);\n<line136>resultbuf [modifier - dot] = '\0';\n<line137>return resultbuf;\n<line138>}\n<line139>}\n<line140>/* For the POSIX locale, don't use the system's codepage.  */\n<line141>if (strcmp (locale, "C") == 0 || strcmp (locale, "POSIX") == 0)\n<line142>codeset = "";\n<line143>}\n<line144>if (codeset == NULL)\n<line145>{\n<line146>/* OS/2 has a function returning the locale's codepage as a number.  */\n<line147>if (DosQueryCp (sizeof (cp), cp, &cplen))\n<line148>codeset = "";\n<line149>else\n<line150>{\n<line151>char buf[2 + 10 + 1];\n<line152>sprintf (buf, "CP%u", cp[0]);\n<line153>strcpy (resultbuf, buf);\n<line154>codeset = resultbuf;\n<line155>}\n<line156>}\n<line157># else\n<line158>#  error "Add code for other platforms here."\n<line159># endif\n<line160>/* Resolve alias.  */\n<line161>{\n<line162># ifdef alias_table_defined\n<line163>/* On some platforms, UTF-8 locales are the most frequently used ones.\n<line164>Speed up the common case and slow down the less common cases by\n<line165>testing for this case first.  */\n<line166>#  if defined __OpenBSD__ || (defined __APPLE__ && defined __MACH__) || defined __sun || defined __CYGWIN__\n<line167>if (strcmp (codeset, "UTF-8") == 0)\n<line168>goto done_table_lookup;\n<line169>else\n<line170>#  endif\n<line171>{\n<line172>const struct table_entry * const table = alias_table;\n<line173>size_t const table_size =\n<line174>sizeof (alias_table) / sizeof (struct table_entry);\n<line175>/* The table is sorted.  Perform a binary search.  */\n<line176>size_t hi = table_size;\n<line177>size_t lo = 0;\n<line178>while (lo < hi)\n<line179>{\n<line180>/* Invariant:\n<line181>for i < lo, strcmp (table[i].alias, codeset) < 0,\n<line182>for i >= hi, strcmp (table[i].alias, codeset) > 0.  */\n<line183>size_t mid = (hi + lo) >> 1; /* >= lo, < hi */\n<line184>int cmp = strcmp (table[mid].alias, codeset);\n<line185>if (cmp < 0)\n<line186>lo = mid + 1;\n<line187>else if (cmp > 0)\n<line188>hi = mid;\n<line189>else\n<line190>{\n<line191>/* Found an i with\n<line192>strcmp (table[i].alias, codeset) == 0.  */\n<line193>codeset = table[mid].canonical;\n<line194>goto done_table_lookup;\n<line195>}\n<line196>}\n<line197>}\n<line198>if (0)\n<line199>done_table_lookup: ;\n<line200>else\n<line201># endif\n<line202>{\n<line203>/* Did not find it in the table.  */\n<line204>/* On Mac OS X, all modern locales use the UTF-8 encoding.\n<line205>BeOS and Haiku have a single locale, and it has UTF-8 encoding.  */\n<line206># if (defined __APPLE__ && defined __MACH__) || defined __BEOS__ || defined __HAIKU__\n<line207>codeset = "UTF-8";\n<line208># else\n<line209>/* Don't return an empty string.  GNU libc and GNU libiconv interpret\n<line210>the empty string as denoting "the locale's character encoding",\n<line211>thus GNU libiconv would call this function a second time.  */\n<line212>if (codeset[0] == '\0')\n<line213>codeset = "ASCII";\n<line214># endif\n<line215>}\n<line216>}\n<line217>#else\n<line218>/* On old systems which lack it, use setlocale or getenv.  */\n<line219>const char *locale = NULL;\n<line220>/* But most old systems don't have a complete set of locales.  Some\n<line221>(like DJGPP) have only the C locale.  Therefore we don't use setlocale\n<line222>here; it would return "C" when it doesn't support the locale name the\n<line223>user has set.  */\n<line224># if 0\n<line225>locale = setlocale (LC_CTYPE, NULL);\n<line226># endif\n<line227>if (locale == NULL || locale[0] == '\0')\n<line228>{\n<line229>locale = getenv ("LC_ALL");\n<line230>if (locale == NULL || locale[0] == '\0')\n<line231>{\n<line232>locale = getenv ("LC_CTYPE");\n<line233>if (locale == NULL || locale[0] == '\0')\n<line234>locale = getenv ("LANG");\n<line235>if (locale == NULL)\n<line236>locale = "";\n<line237>}\n<line238>}\n<line239>/* Map locale name to canonical encoding name.  */\n<line240>{\n<line241># ifdef locale_table_defined\n<line242>const struct table_entry * const table = locale_table;\n<line243>size_t const table_size =\n<line244>sizeof (locale_table) / sizeof (struct table_entry);\n<line245>/* The table is sorted.  Perform a binary search.  */\n<line246>size_t hi = table_size;\n<line247>size_t lo = 0;\n<line248>while (lo < hi)\n<line249>{\n<line250>/* Invariant:\n<line251>for i < lo, strcmp (table[i].locale, locale) < 0,\n<line252>for i >= hi, strcmp (table[i].locale, locale) > 0.  */\n<line253>size_t mid = (hi + lo) >> 1; /* >= lo, < hi */\n<line254>int cmp = strcmp (table[mid].locale, locale);\n<line255>if (cmp < 0)\n<line256>lo = mid + 1;\n<line257>else if (cmp > 0)\n<line258>hi = mid;\n<line259>else\n<line260>{\n<line261>/* Found an i with\n<line262>strcmp (table[i].locale, locale) == 0.  */\n<line263>codeset = table[mid].canonical;\n<line264>goto done_table_lookup;\n<line265>}\n<line266>}\n<line267>if (0)\n<line268>done_table_lookup: ;\n<line269>else\n<line270># endif\n<line271>{\n<line272>/* Did not find it in the table.  */\n<line273>/* On Mac OS X, all modern locales use the UTF-8 encoding.\n<line274>BeOS and Haiku have a single locale, and it has UTF-8 encoding.  */\n<line275># if (defined __APPLE__ && defined __MACH__) || defined __BEOS__ || defined __HAIKU__\n<line276>codeset = "UTF-8";\n<line277># else\n<line278>/* The canonical name cannot be determined.  */\n<line279>/* Don't return an empty string.  GNU libc and GNU libiconv interpret\n<line280>the empty string as denoting "the locale's character encoding",\n<line281>thus GNU libiconv would call this function a second time.  */\n<line282>codeset = "ASCII";\n<line283># endif\n<line284>}\n<line285>}\n<line286>#endif\n<line287>#ifdef DARWIN7\n<line288>/* Mac OS X sets MB_CUR_MAX to 1 when LC_ALL=C, and "UTF-8"\n<line289>(the default codeset) does not work when MB_CUR_MAX is 1.  */\n<line290>if (strcmp (codeset, "UTF-8") == 0 && MB_CUR_MAX_L (uselocale (NULL)) <= 1)\n<line291>codeset = "ASCII";\n<line292>#endif\n<line293>return codeset;\n<line294>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/glthread/lock.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
Function: glthread_rwlock_init_for_glibc
Content: <line0>int\n<line1>glthread_rwlock_init_for_glibc (pthread_rwlock_t *lock)\n<line2>{\n<line3>pthread_rwlockattr_t attributes;\n<line4>int err;\n<line5>err = pthread_rwlockattr_init (&attributes);\n<line6>if (err != 0)\n<line7>return err;\n<line8>/* Note: PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP is the only value that\n<line9>causes the writer to be preferred. PTHREAD_RWLOCK_PREFER_WRITER_NP does not\n<line10>do this; see\n<line11>http://man7.org/linux/man-pages/man3/pthread_rwlockattr_setkind_np.3.html */\n<line12>err = pthread_rwlockattr_setkind_np (&attributes,\n<line13>PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP);\n<line14>if (err == 0)\n<line15>err = pthread_rwlock_init(lock, &attributes);\n<line16>/* pthread_rwlockattr_destroy always returns 0.  It cannot influence the\n<line17>return value.  */\n<line18>pthread_rwlockattr_destroy (&attributes);\n<line19>return err;\n<line20>}
----------------------------------------
Function: glthread_recursive_lock_init_multithreaded
Content: <line0>int\n<line1>glthread_recursive_lock_init_multithreaded (gl_recursive_lock_t *lock)\n<line2>{\n<line3>pthread_mutexattr_t attributes;\n<line4>int err;\n<line5>err = pthread_mutexattr_init (&attributes);\n<line6>if (err != 0)\n<line7>return err;\n<line8>err = pthread_mutexattr_settype (&attributes, PTHREAD_MUTEX_RECURSIVE);\n<line9>if (err != 0)\n<line10>{\n<line11>pthread_mutexattr_destroy (&attributes);\n<line12>return err;\n<line13>}\n<line14>err = pthread_mutex_init (lock, &attributes);\n<line15>if (err != 0)\n<line16>{\n<line17>pthread_mutexattr_destroy (&attributes);\n<line18>return err;\n<line19>}\n<line20>err = pthread_mutexattr_destroy (&attributes);\n<line21>if (err != 0)\n<line22>return err;\n<line23>return 0;\n<line24>}
----------------------------------------
Function: glthread_once_singlethreaded
Content: <line0>int\n<line1>glthread_once_singlethreaded (pthread_once_t *once_control)\n<line2>{\n<line3>/* We don't know whether pthread_once_t is an integer type, a floating-point\n<line4>type, a pointer type, or a structure type.  */\n<line5>char *firstbyte = (char *)once_control;\n<line6>if (*firstbyte == *(const char *)&fresh_once)\n<line7>{\n<line8>/* First time use of once_control.  Invert the first byte.  */\n<line9>*firstbyte = ~ *(const char *)&fresh_once;\n<line10>return 1;\n<line11>}\n<line12>else\n<line13>return 0;\n<line14>}
----------------------------------------
Function: glthread_once_multithreaded
Content: <line0>int\n<line1>glthread_once_multithreaded (pthread_once_t *once_control,\n<line2>void (*init_function) (void))\n<line3>{\n<line4>int err = pthread_once (once_control, init_function);\n<line5>if (err == ENOSYS)\n<line6>{\n<line7>/* This happens on FreeBSD 11: The pthread_once function in libc returns\n<line8>ENOSYS.  */\n<line9>if (glthread_once_singlethreaded (once_control))\n<line10>init_function ();\n<line11>return 0;\n<line12>}\n<line13>return err;\n<line14>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/long-options.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
Function: parse_long_options
Content: <line0>void\n<line1>parse_long_options (int argc,\n<line2>char **argv,\n<line3>const char *command_name,\n<line4>const char *package,\n<line5>const char *version,\n<line6>void (*usage_func) (int),\n<line7>/* const char *author1, ...*/ ...)\n<line8>{\n<line9>int c;\n<line10>int saved_opterr;\n<line11>saved_opterr = opterr;\n<line12>/* Don't print an error message for unrecognized options.  */\n<line13>opterr = 0;\n<line14>if (argc == 2\n<line15>&& (c = getopt_long (argc, argv, "+", long_options, NULL)) != -1)\n<line16>{\n<line17>switch (c)\n<line18>{\n<line19>case 'h':\n<line20>(*usage_func) (EXIT_SUCCESS);\n<line21>break;\n<line22>case 'v':\n<line23>{\n<line24>va_list authors;\n<line25>va_start (authors, usage_func);\n<line26>version_etc_va (stdout, command_name, package, version, authors);\n<line27>exit (EXIT_SUCCESS);\n<line28>}\n<line29>default:\n<line30>/* Don't process any other long-named options.  */\n<line31>break;\n<line32>}\n<line33>}\n<line34>/* Restore previous value.  */\n<line35>opterr = saved_opterr;\n<line36>/* Reset this to zero so that getopt internals get initialized from\n<line37>the probably-new parameters when/if getopt is called later.  */\n<line38>optind = 0;\n<line39>}
----------------------------------------
Function: parse_gnu_standard_options_only
Content: <line0>void\n<line1>parse_gnu_standard_options_only (int argc,\n<line2>char **argv,\n<line3>const char *command_name,\n<line4>const char *package,\n<line5>const char *version,\n<line6>bool scan_all,\n<line7>void (*usage_func) (int),\n<line8>/* const char *author1, ...*/ ...)\n<line9>{\n<line10>int c;\n<line11>int saved_opterr = opterr;\n<line12>/* Print an error message for unrecognized options.  */\n<line13>opterr = 1;\n<line14>const char *optstring = scan_all ? "" : "+";\n<line15>if ((c = getopt_long (argc, argv, optstring, long_options, NULL)) != -1)\n<line16>{\n<line17>switch (c)\n<line18>{\n<line19>case 'h':\n<line20>(*usage_func) (EXIT_SUCCESS);\n<line21>break;\n<line22>case 'v':\n<line23>{\n<line24>va_list authors;\n<line25>va_start (authors, usage_func);\n<line26>version_etc_va (stdout, command_name, package, version, authors);\n<line27>exit (EXIT_SUCCESS);\n<line28>}\n<line29>default:\n<line30>(*usage_func) (exit_failure);\n<line31>break;\n<line32>}\n<line33>}\n<line34>/* Restore previous value.  */\n<line35>opterr = saved_opterr;\n<line36>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/malloca.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
/home/huihui/Downloads/coreutils-9.4/lib/malloca.c:42:56: warning: '_Static_assert' with no message is a C2x extension [-Wc2x-extensions]
static_assert (2 * sa_alignment_max - 1 <= (small_t) -1);
                                                       ^
                                                       , ""
2 warnings generated.
Function: mmalloca
Content: <line0>void *\n<line1>mmalloca (size_t n)\n<line2>{\n<line3>#if HAVE_ALLOCA\n<line4>/* Allocate one more word, used to determine the address to pass to freea(),\n<line5>and room for the alignment  sa_alignment_max mod 2*sa_alignment_max.  */\n<line6>uintptr_t alignment2_mask = 2 * sa_alignment_max - 1;\n<line7>int plus = sizeof (small_t) + alignment2_mask;\n<line8>idx_t nplus;\n<line9>if (!ckd_add (&nplus, n, plus) && !xalloc_oversized (nplus, 1))\n<line10>{\n<line11>char *mem = (char *) malloc (nplus);\n<line12>if (mem != NULL)\n<line13>{\n<line14>uintptr_t umem = (uintptr_t)mem, umemplus;\n<line15>/* The ckd_add avoids signed integer overflow on\n<line16>theoretical platforms where UINTPTR_MAX <= INT_MAX.  */\n<line17>ckd_add (&umemplus, umem, sizeof (small_t) + sa_alignment_max - 1);\n<line18>idx_t offset = ((umemplus & ~alignment2_mask)\n<line19>+ sa_alignment_max - umem);\n<line20>void *vp = mem + offset;\n<line21>small_t *p = vp;\n<line22>/* Here p >= mem + sizeof (small_t),\n<line23>and p <= mem + sizeof (small_t) + 2 * sa_alignment_max - 1\n<line24>hence p + n <= mem + nplus.\n<line25>So, the memory range [p, p+n) lies in the allocated memory range\n<line26>[mem, mem + nplus).  */\n<line27>p[-1] = offset;\n<line28>/* p  sa_alignment_max mod 2*sa_alignment_max.  */\n<line29>return p;\n<line30>}\n<line31>}\n<line32>/* Out of memory.  */\n<line33>return NULL;\n<line34>#else\n<line35># if !MALLOC_0_IS_NONNULL\n<line36>if (n == 0)\n<line37>n = 1;\n<line38># endif\n<line39>return malloc (n);\n<line40>#endif\n<line41>}
----------------------------------------
Function: freea
Content: <line0>void\n<line1>freea (void *p)\n<line2>{\n<line3>/* Check argument.  */\n<line4>if ((uintptr_t) p & (sa_alignment_max - 1))\n<line5>{\n<line6>/* p was not the result of a malloca() call.  Invalid argument.  */\n<line7>abort ();\n<line8>}\n<line9>/* Determine whether p was a non-NULL pointer returned by mmalloca().  */\n<line10>if ((uintptr_t) p & sa_alignment_max)\n<line11>{\n<line12>void *mem = (char *) p - ((small_t *) p)[-1];\n<line13>free (mem);\n<line14>}\n<line15>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/math.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
========================================
/home/huihui/Downloads/coreutils-9.4/lib/mbchar.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
========================================
/home/huihui/Downloads/coreutils-9.4/lib/mbrlen.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
Function: rpl_mbrlen
Content: <line0>size_t\n<line1>mbrlen (const char *s, size_t n, mbstate_t *ps)\n<line2>{\n<line3>if (ps == NULL)\n<line4>ps = &internal_state;\n<line5>return mbrtowc (NULL, s, n, ps);\n<line6>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/mbrtoc32.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
Function: rpl_mbrtoc32
Content: <line0>size_t\n<line1>mbrtoc32 (char32_t *pwc, const char *s, size_t n, mbstate_t *ps)\n<line2># undef mbrtoc32\n<line3>{\n<line4>/* It's simpler to handle the case s == NULL upfront, than to worry about\n<line5>this case later, before every test of pwc and n.  */\n<line6>if (s == NULL)\n<line7>{\n<line8>pwc = NULL;\n<line9>s = "";\n<line10>n = 1;\n<line11>}\n<line12># if MBRTOC32_EMPTY_INPUT_BUG || _GL_SMALL_WCHAR_T\n<line13>if (n == 0)\n<line14>return (size_t) -2;\n<line15># endif\n<line16>if (ps == NULL)\n<line17>ps = &internal_state;\n<line18># if HAVE_WORKING_MBRTOC32\n<line19>/* mbrtoc32() may produce different values for wc than mbrtowc().  Therefore\n<line20>use mbrtoc32().  */\n<line21>#  if defined _WIN32 && !defined __CYGWIN__\n<line22>char32_t wc;\n<line23>size_t ret = mbrtoc32 (&wc, s, n, ps);\n<line24>if (ret < (size_t) -2 && pwc != NULL)\n<line25>*pwc = wc;\n<line26>#  else\n<line27>size_t ret = mbrtoc32 (pwc, s, n, ps);\n<line28>#  endif\n<line29>#  if GNULIB_MBRTOC32_REGULAR\n<line30>/* Verify that mbrtoc32 is regular.  */\n<line31>if (ret < (size_t) -3 && ! mbsinit (ps))\n<line32>/* This occurs on glibc 2.36.  */\n<line33>mbszero (ps);\n<line34>if (ret == (size_t) -3)\n<line35>abort ();\n<line36>#  endif\n<line37>#  if MBRTOC32_IN_C_LOCALE_MAYBE_EILSEQ\n<line38>if ((size_t) -2 <= ret && n != 0 && ! hard_locale (LC_CTYPE))\n<line39>{\n<line40>if (pwc != NULL)\n<line41>*pwc = (unsigned char) *s;\n<line42>return 1;\n<line43>}\n<line44>#  endif\n<line45>return ret;\n<line46># elif _GL_SMALL_WCHAR_T\n<line47>/* Special-case all encodings that may produce wide character values\n<line48>> WCHAR_MAX.  */\n<line49>const char *encoding = locale_charset ();\n<line50>if (STREQ_OPT (encoding, "UTF-8", 'U', 'T', 'F', '-', '8', 0, 0, 0, 0))\n<line51>{\n<line52>/* Special-case the UTF-8 encoding.  Assume that the wide-character\n<line53>encoding in a UTF-8 locale is UCS-2 or, equivalently, UTF-16.  */\n<line54>/* Here n > 0.  */\n<line55>char *pstate = (char *)ps;\n<line56>size_t nstate = pstate[0];\n<line57>char buf[4];\n<line58>const char *p;\n<line59>size_t m;\n<line60>int res;\n<line61>switch (nstate)\n<line62>{\n<line63>case 0:\n<line64>p = s;\n<line65>m = n;\n<line66>break;\n<line67>case 3:\n<line68>buf[2] = pstate[3];\n<line69>FALLTHROUGH;\n<line70>case 2:\n<line71>buf[1] = pstate[2];\n<line72>FALLTHROUGH;\n<line73>case 1:\n<line74>buf[0] = pstate[1];\n<line75>p = buf;\n<line76>m = nstate;\n<line77>buf[m++] = s[0];\n<line78>if (n >= 2 && m < 4)\n<line79>{\n<line80>buf[m++] = s[1];\n<line81>if (n >= 3 && m < 4)\n<line82>buf[m++] = s[2];\n<line83>}\n<line84>break;\n<line85>default:\n<line86>errno = EINVAL;\n<line87>return (size_t)(-1);\n<line88>}\n<line89>/* Here m > 0.  */\n<line90>{\n<line91>#  define FITS_IN_CHAR_TYPE(wc)  1\n<line92>#  include "mbrtowc-impl-utf8.h"\n<line93>}\n<line94>success:\n<line95>if (nstate >= (res > 0 ? res : 1))\n<line96>abort ();\n<line97>res -= nstate;\n<line98>/* Set *ps to an initial state.  */\n<line99>#  if defined _WIN32 && !defined __CYGWIN__\n<line100>/* Native Windows.  */\n<line101>/* MSVC defines 'mbstate_t' as an 8-byte struct; the first 4 bytes matter.\n<line102>On mingw, 'mbstate_t' is sometimes defined as 'int', sometimes defined\n<line103>as an 8-byte struct, of which the first 4 bytes matter.  */\n<line104>*(unsigned int *)pstate = 0;\n<line105>#  elif defined __CYGWIN__\n<line106>/* Cygwin defines 'mbstate_t' as an 8-byte struct; the first 4 bytes\n<line107>matter.  */\n<line108>ps->__count = 0;\n<line109>#  else\n<line110>pstate[0] = 0;\n<line111>#  endif\n<line112>return res;\n<line113>incomplete:\n<line114>{\n<line115>size_t k = nstate;\n<line116>/* Here 0 <= k < m < 4.  */\n<line117>pstate[++k] = s[0];\n<line118>if (k < m)\n<line119>{\n<line120>pstate[++k] = s[1];\n<line121>if (k < m)\n<line122>pstate[++k] = s[2];\n<line123>}\n<line124>if (k != m)\n<line125>abort ();\n<line126>}\n<line127>pstate[0] = m;\n<line128>return (size_t)(-2);\n<line129>invalid:\n<line130>errno = EILSEQ;\n<line131>/* The conversion state is undefined, says POSIX.  */\n<line132>return (size_t)(-1);\n<line133>}\n<line134>else\n<line135>{\n<line136>wchar_t wc;\n<line137>size_t ret = mbrtowc (&wc, s, n, ps);\n<line138>if (ret < (size_t) -2 && pwc != NULL)\n<line139>*pwc = wc;\n<line140>return ret;\n<line141>}\n<line142># else\n<line143>/* char32_t and wchar_t are equivalent.  Use mbrtowc().  */\n<line144>wchar_t wc;\n<line145>size_t ret = mbrtowc (&wc, s, n, ps);\n<line146>#  if GNULIB_MBRTOC32_REGULAR\n<line147>/* Ensure that mbrtoc32 is regular.  */\n<line148>if (ret < (size_t) -2 && ! mbsinit (ps))\n<line149>/* This occurs on glibc 2.12.  */\n<line150>mbszero (ps);\n<line151>#  endif\n<line152>#  if GL_CHAR32_T_IS_UNICODE && GL_CHAR32_T_VS_WCHAR_T_NEEDS_CONVERSION\n<line153>if (ret < (size_t) -2 && wc != 0)\n<line154>{\n<line155>wc = locale_encoding_to_unicode (wc);\n<line156>if (wc == 0)\n<line157>{\n<line158>ret = (size_t) -1;\n<line159>errno = EILSEQ;\n<line160>}\n<line161>}\n<line162>#  endif\n<line163>if (ret < (size_t) -2 && pwc != NULL)\n<line164>*pwc = wc;\n<line165>return ret;\n<line166># endif\n<line167>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/mbrtowc.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
Function: rpl_mbrtowc
Content: <line0>size_t\n<line1>rpl_mbrtowc (wchar_t *pwc, const char *s, size_t n, mbstate_t *ps)\n<line2>{\n<line3>size_t ret;\n<line4>wchar_t wc;\n<line5># if MBRTOWC_NULL_ARG2_BUG || MBRTOWC_RETVAL_BUG || MBRTOWC_EMPTY_INPUT_BUG\n<line6>if (s == NULL)\n<line7>{\n<line8>pwc = NULL;\n<line9>s = "";\n<line10>n = 1;\n<line11>}\n<line12># endif\n<line13># if MBRTOWC_EMPTY_INPUT_BUG\n<line14>if (n == 0)\n<line15>return (size_t) -2;\n<line16># endif\n<line17>if (! pwc)\n<line18>pwc = &wc;\n<line19># if MBRTOWC_RETVAL_BUG\n<line20>{\n<line21>static mbstate_t internal_state;\n<line22>/* Override mbrtowc's internal state.  We cannot call mbsinit() on the\n<line23>hidden internal state, but we can call it on our variable.  */\n<line24>if (ps == NULL)\n<line25>ps = &internal_state;\n<line26>if (!mbsinit (ps))\n<line27>{\n<line28>/* Parse the rest of the multibyte character byte for byte.  */\n<line29>size_t count = 0;\n<line30>for (; n > 0; s++, n--)\n<line31>{\n<line32>ret = mbrtowc (&wc, s, 1, ps);\n<line33>if (ret == (size_t)(-1))\n<line34>return (size_t)(-1);\n<line35>count++;\n<line36>if (ret != (size_t)(-2))\n<line37>{\n<line38>/* The multibyte character has been completed.  */\n<line39>*pwc = wc;\n<line40>return (wc == 0 ? 0 : count);\n<line41>}\n<line42>}\n<line43>return (size_t)(-2);\n<line44>}\n<line45>}\n<line46># endif\n<line47># if MBRTOWC_STORES_INCOMPLETE_BUG\n<line48>ret = mbrtowc (&wc, s, n, ps);\n<line49>if (ret < (size_t) -2 && pwc != NULL)\n<line50>*pwc = wc;\n<line51># else\n<line52>ret = mbrtowc (pwc, s, n, ps);\n<line53># endif\n<line54># if MBRTOWC_NUL_RETVAL_BUG\n<line55>if (ret < (size_t) -2 && !*pwc)\n<line56>return 0;\n<line57># endif\n<line58># if MBRTOWC_IN_C_LOCALE_MAYBE_EILSEQ\n<line59>if ((size_t) -2 <= ret && n != 0 && ! hard_locale (LC_CTYPE))\n<line60>{\n<line61>unsigned char uc = *s;\n<line62>*pwc = uc;\n<line63>return 1;\n<line64>}\n<line65># endif\n<line66>return ret;\n<line67>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/mbsalign.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
Function: wc_ensure_printable
Content: <line0>static bool\n<line1>wc_ensure_printable (wchar_t *wchars)\n<line2>{\n<line3>bool replaced = false;\n<line4>wchar_t *wc = wchars;\n<line5>while (*wc)\n<line6>{\n<line7>if (!iswprint ((wint_t) *wc))\n<line8>{\n<line9>*wc = 0xFFFD; /* L'\uFFFD' (replacement char) */\n<line10>replaced = true;\n<line11>}\n<line12>wc++;\n<line13>}\n<line14>return replaced;\n<line15>}
----------------------------------------
Function: wc_truncate
Content: <line0>static size_t\n<line1>wc_truncate (wchar_t *wc, size_t width)\n<line2>{\n<line3>size_t cells = 0;\n<line4>int next_cells = 0;\n<line5>while (*wc)\n<line6>{\n<line7>next_cells = wcwidth (*wc);\n<line8>if (next_cells == -1) /* non printable */\n<line9>{\n<line10>*wc = 0xFFFD; /* L'\uFFFD' (replacement char) */\n<line11>next_cells = 1;\n<line12>}\n<line13>if (cells + next_cells > width)\n<line14>break;\n<line15>cells += next_cells;\n<line16>wc++;\n<line17>}\n<line18>*wc = L'\0';\n<line19>return cells;\n<line20>}
----------------------------------------
Function: mbs_align_pad
Content: <line0>static char *\n<line1>mbs_align_pad (char *dest, char const *dest_end, size_t n_spaces)\n<line2>{\n<line3>/* FIXME: Should we pad with "figure space" (\u2007)\n<line4>if non ascii data present?  */\n<line5>while (n_spaces-- && (dest < dest_end))\n<line6>*dest++ = ' ';\n<line7>*dest = '\0';\n<line8>return dest;\n<line9>}
----------------------------------------
Function: mbsalign
Content: <line0>size_t\n<line1>mbsalign (char const *src, char *dest, size_t dest_size,\n<line2>size_t *width, mbs_align_t align, int flags)\n<line3>{\n<line4>size_t ret = SIZE_MAX;\n<line5>size_t src_size = strlen (src) + 1;\n<line6>char *newstr = nullptr;\n<line7>wchar_t *str_wc = nullptr;\n<line8>char const *str_to_print = src;\n<line9>size_t n_cols = src_size - 1;\n<line10>size_t n_used_bytes = n_cols; /* Not including NUL */\n<line11>size_t n_spaces = 0;\n<line12>bool conversion = false;\n<line13>bool wc_enabled = false;\n<line14>/* In multi-byte locales convert to wide characters\n<line15>to allow easy truncation. Also determine number\n<line16>of screen columns used.  */\n<line17>if (!(flags & MBA_UNIBYTE_ONLY) && MB_CUR_MAX > 1)\n<line18>{\n<line19>size_t src_chars = mbstowcs (nullptr, src, 0);\n<line20>if (src_chars == SIZE_MAX)\n<line21>{\n<line22>if (flags & MBA_UNIBYTE_FALLBACK)\n<line23>goto mbsalign_unibyte;\n<line24>else\n<line25>goto mbsalign_cleanup;\n<line26>}\n<line27>src_chars += 1; /* make space for NUL */\n<line28>str_wc = malloc (src_chars * sizeof (wchar_t));\n<line29>if (str_wc == nullptr)\n<line30>{\n<line31>if (flags & MBA_UNIBYTE_FALLBACK)\n<line32>goto mbsalign_unibyte;\n<line33>else\n<line34>goto mbsalign_cleanup;\n<line35>}\n<line36>if (mbstowcs (str_wc, src, src_chars) != 0)\n<line37>{\n<line38>str_wc[src_chars - 1] = L'\0';\n<line39>wc_enabled = true;\n<line40>conversion = wc_ensure_printable (str_wc);\n<line41>n_cols = wcswidth (str_wc, src_chars);\n<line42>}\n<line43>}\n<line44>/* If we transformed or need to truncate the source string\n<line45>then create a modified copy of it.  */\n<line46>if (wc_enabled && (conversion || (n_cols > *width)))\n<line47>{\n<line48>if (conversion)\n<line49>{\n<line50>/* May have increased the size by converting\n<line51>\t to \uFFFD for example.  */\n<line52>src_size = wcstombs (nullptr, str_wc, 0) + 1;\n<line53>}\n<line54>newstr = malloc (src_size);\n<line55>if (newstr == nullptr)\n<line56>{\n<line57>if (flags & MBA_UNIBYTE_FALLBACK)\n<line58>goto mbsalign_unibyte;\n<line59>else\n<line60>goto mbsalign_cleanup;\n<line61>}\n<line62>str_to_print = newstr;\n<line63>n_cols = wc_truncate (str_wc, *width);\n<line64>n_used_bytes = wcstombs (newstr, str_wc, src_size);\n<line65>}\n<line66>mbsalign_unibyte:\n<line67>if (n_cols > *width) /* Unibyte truncation required.  */\n<line68>{\n<line69>n_cols = *width;\n<line70>n_used_bytes = n_cols;\n<line71>}\n<line72>if (*width > n_cols) /* Padding required.  */\n<line73>n_spaces = *width - n_cols;\n<line74>/* indicate to caller how many cells needed (not including padding).  */\n<line75>*width = n_cols;\n<line76>{\n<line77>size_t start_spaces, end_spaces;\n<line78>switch (align)\n<line79>{\n<line80>case MBS_ALIGN_LEFT:\n<line81>start_spaces = 0;\n<line82>end_spaces = n_spaces;\n<line83>break;\n<line84>case MBS_ALIGN_RIGHT:\n<line85>start_spaces = n_spaces;\n<line86>end_spaces = 0;\n<line87>break;\n<line88>case MBS_ALIGN_CENTER:\n<line89>default:\n<line90>start_spaces = n_spaces / 2 + n_spaces % 2;\n<line91>end_spaces = n_spaces / 2;\n<line92>break;\n<line93>}\n<line94>if (flags & MBA_NO_LEFT_PAD)\n<line95>start_spaces = 0;\n<line96>if (flags & MBA_NO_RIGHT_PAD)\n<line97>end_spaces = 0;\n<line98>/* Write as much NUL terminated output to DEST as possible.  */\n<line99>if (dest_size != 0)\n<line100>{\n<line101>size_t space_left;\n<line102>char *dest_end = dest + dest_size - 1;\n<line103>dest = mbs_align_pad (dest, dest_end, start_spaces);\n<line104>space_left = dest_end - dest;\n<line105>dest = mempcpy (dest, str_to_print, MIN (n_used_bytes, space_left));\n<line106>mbs_align_pad (dest, dest_end, end_spaces);\n<line107>}\n<line108>/* indicate to caller how many bytes needed (not including NUL).  */\n<line109>ret = n_used_bytes + ((start_spaces + end_spaces) * 1);\n<line110>}\n<line111>mbsalign_cleanup:\n<line112>free (str_wc);\n<line113>free (newstr);\n<line114>return ret;\n<line115>}
----------------------------------------
Function: ambsalign
Content: <line0>char *\n<line1>ambsalign (char const *src, size_t *width, mbs_align_t align, int flags)\n<line2>{\n<line3>size_t orig_width = *width;\n<line4>size_t size = *width;         /* Start with enough for unibyte mode.  */\n<line5>size_t req = size;\n<line6>char *buf = nullptr;\n<line7>while (req >= size)\n<line8>{\n<line9>char *nbuf;\n<line10>size = req + 1;           /* Space for NUL.  */\n<line11>nbuf = realloc (buf, size);\n<line12>if (nbuf == nullptr)\n<line13>{\n<line14>free (buf);\n<line15>buf = nullptr;\n<line16>break;\n<line17>}\n<line18>buf = nbuf;\n<line19>*width = orig_width;\n<line20>req = mbsalign (src, buf, size, width, align, flags);\n<line21>if (req == SIZE_MAX)\n<line22>{\n<line23>free (buf);\n<line24>buf = nullptr;\n<line25>break;\n<line26>}\n<line27>}\n<line28>return buf;\n<line29>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/mbscasecmp.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
Function: mbscasecmp
Content: <line0>int\n<line1>mbscasecmp (const char *s1, const char *s2)\n<line2>{\n<line3>if (s1 == s2)\n<line4>return 0;\n<line5>/* Be careful not to look at the entire extent of s1 or s2 until needed.\n<line6>This is useful because when two strings differ, the difference is\n<line7>most often already in the very few first characters.  */\n<line8>if (MB_CUR_MAX > 1)\n<line9>{\n<line10>mbuif_state_t state1;\n<line11>const char *iter1;\n<line12>mbuif_init (state1);\n<line13>iter1 = s1;\n<line14>mbuif_state_t state2;\n<line15>const char *iter2;\n<line16>mbuif_init (state2);\n<line17>iter2 = s2;\n<line18>while (mbuif_avail (state1, iter1) && mbuif_avail (state2, iter2))\n<line19>{\n<line20>mbchar_t cur1 = mbuif_next (state1, iter1);\n<line21>mbchar_t cur2 = mbuif_next (state2, iter2);\n<line22>int cmp = mb_casecmp (cur1, cur2);\n<line23>if (cmp != 0)\n<line24>return cmp;\n<line25>iter1 += mb_len (cur1);\n<line26>iter2 += mb_len (cur2);\n<line27>}\n<line28>if (mbuif_avail (state1, iter1))\n<line29>/* s2 terminated before s1.  */\n<line30>return 1;\n<line31>if (mbuif_avail (state2, iter2))\n<line32>/* s1 terminated before s2.  */\n<line33>return -1;\n<line34>return 0;\n<line35>}\n<line36>else\n<line37>{\n<line38>const unsigned char *p1 = (const unsigned char *) s1;\n<line39>const unsigned char *p2 = (const unsigned char *) s2;\n<line40>unsigned char c1, c2;\n<line41>do\n<line42>{\n<line43>c1 = tolower (*p1);\n<line44>c2 = tolower (*p2);\n<line45>if (c1 == '\0')\n<line46>break;\n<line47>++p1;\n<line48>++p2;\n<line49>}\n<line50>while (c1 == c2);\n<line51>if (UCHAR_MAX <= INT_MAX)\n<line52>return c1 - c2;\n<line53>else\n<line54>/* On machines where 'char' and 'int' are types of the same size, the\n<line55>difference of two 'unsigned char' values - including the sign bit -\n<line56>doesn't fit in an 'int'.  */\n<line57>return _GL_CMP (c1, c2);\n<line58>}\n<line59>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/mbschr.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
Function: mbschr
Content: <line0>char *\n<line1>mbschr (const char *string, int c)\n<line2>{\n<line3>if (MB_CUR_MAX > 1\n<line4>/* Optimization: We know that ASCII characters < 0x30 don't occur as\n<line5>part of multibyte characters longer than 1 byte.  Hence, if c < 0x30,\n<line6>the faster unibyte loop can be used.  */\n<line7>&& (unsigned char) c >= 0x30)\n<line8>{\n<line9>mbuif_state_t state;\n<line10>const char *iter;\n<line11>for (mbuif_init (state), iter = string;; )\n<line12>{\n<line13>if (!mbuif_avail (state, iter))\n<line14>goto notfound;\n<line15>mbchar_t cur = mbuif_next (state, iter);\n<line16>if (mb_len (cur) == 1 && (unsigned char) *iter == (unsigned char) c)\n<line17>break;\n<line18>iter += mb_len (cur);\n<line19>}\n<line20>return (char *) iter;\n<line21>notfound:\n<line22>return NULL;\n<line23>}\n<line24>else\n<line25>return strchr (string, c);\n<line26>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/mbslen.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
Function: mbslen
Content: <line0>size_t\n<line1>mbslen (const char *string)\n<line2>{\n<line3>if (MB_CUR_MAX > 1)\n<line4>{\n<line5>size_t count = 0;\n<line6>mbuif_state_t state;\n<line7>const char *iter;\n<line8>for (mbuif_init (state), iter = string; mbuif_avail (state, iter); )\n<line9>{\n<line10>mbchar_t cur = mbuif_next (state, iter);\n<line11>count++;\n<line12>iter += mb_len (cur);\n<line13>}\n<line14>return count;\n<line15>}\n<line16>else\n<line17>return strlen (string);\n<line18>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/mbsrtoc32s.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
/home/huihui/Downloads/coreutils-9.4/lib/mbsrtoc32s.c:54:53: warning: '_Static_assert' with no message is a C2x extension [-Wc2x-extensions]
static_assert (sizeof (char32_t) == sizeof (wchar_t));
                                                    ^
                                                    , ""
2 warnings generated.
========================================
/home/huihui/Downloads/coreutils-9.4/lib/mbsrtowcs.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
========================================
/home/huihui/Downloads/coreutils-9.4/lib/mbswidth.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
Function: gnu_mbswidth
Content: <line0>int\n<line1>mbswidth (const char *string, int flags)\n<line2>{\n<line3>return mbsnwidth (string, strlen (string), flags);\n<line4>}
----------------------------------------
Function: mbsnwidth
Content: <line0>int\n<line1>mbsnwidth (const char *string, size_t nbytes, int flags)\n<line2>{\n<line3>const char *p = string;\n<line4>const char *plimit = p + nbytes;\n<line5>int width;\n<line6>width = 0;\n<line7>if (MB_CUR_MAX > 1)\n<line8>{\n<line9>while (p < plimit)\n<line10>switch (*p)\n<line11>{\n<line12>case ' ': case '!': case '"': case '#': case '$': case '%':\n<line13>case '&': case '\'': case '(': case ')': case '*':\n<line14>case '+': case ',': case '-': case '.': case '/':\n<line15>case '0': case '1': case '2': case '3': case '4':\n<line16>case '5': case '6': case '7': case '8': case '9':\n<line17>case ':': case ';': case '<': case '=': case '>':\n<line18>case '?': case '@':\n<line19>case 'A': case 'B': case 'C': case 'D': case 'E':\n<line20>case 'F': case 'G': case 'H': case 'I': case 'J':\n<line21>case 'K': case 'L': case 'M': case 'N': case 'O':\n<line22>case 'P': case 'Q': case 'R': case 'S': case 'T':\n<line23>case 'U': case 'V': case 'W': case 'X': case 'Y':\n<line24>case 'Z':\n<line25>case '[': case '\\': case ']': case '^': case '_': case '`':\n<line26>case 'a': case 'b': case 'c': case 'd': case 'e':\n<line27>case 'f': case 'g': case 'h': case 'i': case 'j':\n<line28>case 'k': case 'l': case 'm': case 'n': case 'o':\n<line29>case 'p': case 'q': case 'r': case 's': case 't':\n<line30>case 'u': case 'v': case 'w': case 'x': case 'y':\n<line31>case 'z': case '{': case '|': case '}': case '~':\n<line32>/* These characters are printable ASCII characters.  */\n<line33>p++;\n<line34>width++;\n<line35>break;\n<line36>default:\n<line37>/* If we have a multibyte sequence, scan it up to its end.  */\n<line38>{\n<line39>mbstate_t mbstate;\n<line40>mbszero (&mbstate);\n<line41>for (;;)\n<line42>{\n<line43>char32_t wc;\n<line44>size_t bytes;\n<line45>int w;\n<line46>bytes = mbrtoc32 (&wc, p, plimit - p, &mbstate);\n<line47>if (bytes == (size_t) -1)\n<line48>/* An invalid multibyte sequence was encountered.  */\n<line49>{\n<line50>if (!(flags & MBSW_REJECT_INVALID))\n<line51>{\n<line52>p++;\n<line53>width++;\n<line54>break;\n<line55>}\n<line56>else\n<line57>return -1;\n<line58>}\n<line59>if (bytes == (size_t) -2)\n<line60>/* An incomplete multibyte character at the end.  */\n<line61>{\n<line62>if (!(flags & MBSW_REJECT_INVALID))\n<line63>{\n<line64>p = plimit;\n<line65>width++;\n<line66>break;\n<line67>}\n<line68>else\n<line69>return -1;\n<line70>}\n<line71>if (bytes == 0)\n<line72>/* A null wide character was encountered.  */\n<line73>bytes = 1;\n<line74>#if !GNULIB_MBRTOC32_REGULAR\n<line75>else if (bytes == (size_t) -3)\n<line76>bytes = 0;\n<line77>#endif\n<line78>w = c32width (wc);\n<line79>if (w >= 0)\n<line80>/* A printable multibyte character.  */\n<line81>{\n<line82>if (w > INT_MAX - width)\n<line83>goto overflow;\n<line84>width += w;\n<line85>}\n<line86>else\n<line87>/* An unprintable multibyte character.  */\n<line88>if (!(flags & MBSW_REJECT_UNPRINTABLE))\n<line89>{\n<line90>if (!c32iscntrl (wc))\n<line91>{\n<line92>if (width == INT_MAX)\n<line93>goto overflow;\n<line94>width++;\n<line95>}\n<line96>}\n<line97>else\n<line98>return -1;\n<line99>p += bytes;\n<line100>#if !GNULIB_MBRTOC32_REGULAR\n<line101>if (mbsinit (&mbstate))\n<line102>#endif\n<line103>break;\n<line104>}\n<line105>}\n<line106>break;\n<line107>}\n<line108>return width;\n<line109>}\n<line110>while (p < plimit)\n<line111>{\n<line112>unsigned char c = (unsigned char) *p++;\n<line113>if (isprint (c))\n<line114>{\n<line115>if (width == INT_MAX)\n<line116>goto overflow;\n<line117>width++;\n<line118>}\n<line119>else if (!(flags & MBSW_REJECT_UNPRINTABLE))\n<line120>{\n<line121>if (!iscntrl (c))\n<line122>{\n<line123>if (width == INT_MAX)\n<line124>goto overflow;\n<line125>width++;\n<line126>}\n<line127>}\n<line128>else\n<line129>return -1;\n<line130>}\n<line131>return width;\n<line132>overflow:\n<line133>return INT_MAX;\n<line134>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/mbszero.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
========================================
/home/huihui/Downloads/coreutils-9.4/lib/mbuiter.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
========================================
/home/huihui/Downloads/coreutils-9.4/lib/mbuiterf.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
========================================
/home/huihui/Downloads/coreutils-9.4/lib/memcasecmp.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
Function: memcasecmp
Content: <line0>int\n<line1>memcasecmp (const void *vs1, const void *vs2, size_t n)\n<line2>{\n<line3>size_t i;\n<line4>char const *s1 = vs1;\n<line5>char const *s2 = vs2;\n<line6>for (i = 0; i < n; i++)\n<line7>{\n<line8>unsigned char u1 = s1[i];\n<line9>unsigned char u2 = s2[i];\n<line10>int U1 = toupper (u1);\n<line11>int U2 = toupper (u2);\n<line12>int diff = (UCHAR_MAX <= INT_MAX ? U1 - U2 : _GL_CMP (U1, U2));\n<line13>if (diff)\n<line14>return diff;\n<line15>}\n<line16>return 0;\n<line17>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/memchr2.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
Function: memchr2
Content: <line0>void *\n<line1>memchr2 (void const *s, int c1_in, int c2_in, size_t n)\n<line2>{\n<line3>/* On 32-bit hardware, choosing longword to be a 32-bit unsigned\n<line4>long instead of a 64-bit uintmax_t tends to give better\n<line5>performance.  On 64-bit hardware, unsigned long is generally 64\n<line6>bits already.  Change this typedef to experiment with\n<line7>performance.  */\n<line8>typedef unsigned long int longword;\n<line9>const unsigned char *char_ptr;\n<line10>void const *void_ptr;\n<line11>const longword *longword_ptr;\n<line12>longword repeated_one;\n<line13>longword repeated_c1;\n<line14>longword repeated_c2;\n<line15>unsigned char c1;\n<line16>unsigned char c2;\n<line17>c1 = (unsigned char) c1_in;\n<line18>c2 = (unsigned char) c2_in;\n<line19>if (c1 == c2)\n<line20>return memchr (s, c1, n);\n<line21>/* Handle the first few bytes by reading one byte at a time.\n<line22>Do this until VOID_PTR is aligned on a longword boundary.  */\n<line23>for (void_ptr = s;\n<line24>n > 0 && (uintptr_t) void_ptr % sizeof (longword) != 0;\n<line25>--n)\n<line26>{\n<line27>char_ptr = void_ptr;\n<line28>if (*char_ptr == c1 || *char_ptr == c2)\n<line29>return (void *) void_ptr;\n<line30>void_ptr = char_ptr + 1;\n<line31>}\n<line32>longword_ptr = void_ptr;\n<line33>/* All these elucidatory comments refer to 4-byte longwords,\n<line34>but the theory applies equally well to any size longwords.  */\n<line35>/* Compute auxiliary longword values:\n<line36>repeated_one is a value which has a 1 in every byte.\n<line37>repeated_c1 has c1 in every byte.\n<line38>repeated_c2 has c2 in every byte.  */\n<line39>repeated_one = 0x01010101;\n<line40>repeated_c1 = c1 | (c1 << 8);\n<line41>repeated_c2 = c2 | (c2 << 8);\n<line42>repeated_c1 |= repeated_c1 << 16;\n<line43>repeated_c2 |= repeated_c2 << 16;\n<line44>if (0xffffffffU < (longword) -1)\n<line45>{\n<line46>repeated_one |= repeated_one << 31 << 1;\n<line47>repeated_c1 |= repeated_c1 << 31 << 1;\n<line48>repeated_c2 |= repeated_c2 << 31 << 1;\n<line49>if (8 < sizeof (longword))\n<line50>{\n<line51>size_t i;\n<line52>for (i = 64; i < sizeof (longword) * 8; i *= 2)\n<line53>{\n<line54>repeated_one |= repeated_one << i;\n<line55>repeated_c1 |= repeated_c1 << i;\n<line56>repeated_c2 |= repeated_c2 << i;\n<line57>}\n<line58>}\n<line59>}\n<line60>/* Instead of the traditional loop which tests each byte, we will test a\n<line61>longword at a time.  The tricky part is testing if *any of the four*\n<line62>bytes in the longword in question are equal to c1 or c2.  We first use\n<line63>an xor with repeated_c1 and repeated_c2, respectively.  This reduces\n<line64>the task to testing whether *any of the four* bytes in longword1 or\n<line65>longword2 is zero.\n<line66>Let's consider longword1.  We compute tmp1 =\n<line67>((longword1 - repeated_one) & ~longword1) & (repeated_one << 7).\n<line68>That is, we perform the following operations:\n<line69>1. Subtract repeated_one.\n<line70>2. & ~longword1.\n<line71>3. & a mask consisting of 0x80 in every byte.\n<line72>Consider what happens in each byte:\n<line73>- If a byte of longword1 is zero, step 1 and 2 transform it into 0xff,\n<line74>and step 3 transforms it into 0x80.  A carry can also be propagated\n<line75>to more significant bytes.\n<line76>- If a byte of longword1 is nonzero, let its lowest 1 bit be at\n<line77>position k (0 <= k <= 7); so the lowest k bits are 0.  After step 1,\n<line78>the byte ends in a single bit of value 0 and k bits of value 1.\n<line79>After step 2, the result is just k bits of value 1: 2^k - 1.  After\n<line80>step 3, the result is 0.  And no carry is produced.\n<line81>So, if longword1 has only non-zero bytes, tmp1 is zero.\n<line82>Whereas if longword1 has a zero byte, call j the position of the least\n<line83>significant zero byte.  Then the result has a zero at positions 0, ...,\n<line84>j-1 and a 0x80 at position j.  We cannot predict the result at the more\n<line85>significant bytes (positions j+1..3), but it does not matter since we\n<line86>already have a non-zero bit at position 8*j+7.\n<line87>Similarly, we compute tmp2 =\n<line88>((longword2 - repeated_one) & ~longword2) & (repeated_one << 7).\n<line89>The test whether any byte in longword1 or longword2 is zero is equivalent\n<line90>to testing whether tmp1 is nonzero or tmp2 is nonzero.  We can combine\n<line91>this into a single test, whether (tmp1 | tmp2) is nonzero.  */\n<line92>while (n >= sizeof (longword))\n<line93>{\n<line94>longword longword1 = *longword_ptr ^ repeated_c1;\n<line95>longword longword2 = *longword_ptr ^ repeated_c2;\n<line96>if (((((longword1 - repeated_one) & ~longword1)\n<line97>| ((longword2 - repeated_one) & ~longword2))\n<line98>& (repeated_one << 7)) != 0)\n<line99>break;\n<line100>longword_ptr++;\n<line101>n -= sizeof (longword);\n<line102>}\n<line103>char_ptr = (const unsigned char *) longword_ptr;\n<line104>/* At this point, we know that either n < sizeof (longword), or one of the\n<line105>sizeof (longword) bytes starting at char_ptr is == c1 or == c2.  On\n<line106>little-endian machines, we could determine the first such byte without\n<line107>any further memory accesses, just by looking at the (tmp1 | tmp2) result\n<line108>from the last loop iteration.  But this does not work on big-endian\n<line109>machines.  Choose code that works in both cases.  */\n<line110>for (; n > 0; --n, ++char_ptr)\n<line111>{\n<line112>if (*char_ptr == c1 || *char_ptr == c2)\n<line113>return (void *) char_ptr;\n<line114>}\n<line115>return NULL;\n<line116>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/memcmp2.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
Function: memcmp2
Content: <line0>int\n<line1>memcmp2 (const char *s1, size_t n1, const char *s2, size_t n2)\n<line2>{\n<line3>int cmp = memcmp (s1, s2, n1 <= n2 ? n1 : n2);\n<line4>if (cmp == 0)\n<line5>cmp = _GL_CMP (n1, n2);\n<line6>return cmp;\n<line7>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/memcoll.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
Function: strcoll_loop
Content: <line0>static int\n<line1>strcoll_loop (char const *s1, size_t s1size, char const *s2, size_t s2size)\n<line2>{\n<line3>int diff;\n<line4>while (! (errno = 0, (diff = strcoll (s1, s2)) || errno))\n<line5>{\n<line6>/* strcoll found no difference, but perhaps it was fooled by NUL\n<line7>characters in the data.  Work around this problem by advancing\n<line8>past the NUL chars.  */\n<line9>size_t size1 = strlen (s1) + 1;\n<line10>size_t size2 = strlen (s2) + 1;\n<line11>s1 += size1;\n<line12>s2 += size2;\n<line13>s1size -= size1;\n<line14>s2size -= size2;\n<line15>if (s1size == 0)\n<line16>return - (s2size != 0);\n<line17>if (s2size == 0)\n<line18>return 1;\n<line19>}\n<line20>return diff;\n<line21>}
----------------------------------------
Function: memcoll
Content: <line0>int\n<line1>memcoll (char *s1, size_t s1len, char *s2, size_t s2len)\n<line2>{\n<line3>int diff;\n<line4>/* strcoll is slow on many platforms, so check for the common case\n<line5>where the arguments are bytewise equal.  Otherwise, walk through\n<line6>the buffers using strcoll on each substring.  */\n<line7>if (s1len == s2len && memcmp (s1, s2, s1len) == 0)\n<line8>{\n<line9>errno = 0;\n<line10>diff = 0;\n<line11>}\n<line12>else\n<line13>{\n<line14>char n1 = s1[s1len];\n<line15>char n2 = s2[s2len];\n<line16>s1[s1len] = '\0';\n<line17>s2[s2len] = '\0';\n<line18>diff = strcoll_loop (s1, s1len + 1, s2, s2len + 1);\n<line19>s1[s1len] = n1;\n<line20>s2[s2len] = n2;\n<line21>}\n<line22>return diff;\n<line23>}
----------------------------------------
Function: memcoll0
Content: <line0>int\n<line1>memcoll0 (char const *s1, size_t s1size, char const *s2, size_t s2size)\n<line2>{\n<line3>if (s1size == s2size && memcmp (s1, s2, s1size) == 0)\n<line4>{\n<line5>errno = 0;\n<line6>return 0;\n<line7>}\n<line8>else\n<line9>return strcoll_loop (s1, s1size, s2, s2size);\n<line10>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/memset_explicit.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
Function: memset_explicit
Content: <line0>void *\n<line1>memset_explicit (void *s, int c, size_t len)\n<line2>{\n<line3>#if HAVE_EXPLICIT_MEMSET\n<line4>return explicit_memset (s, c, len);\n<line5>#elif HAVE_MEMSET_S\n<line6>(void) memset_s (s, len, c, len);\n<line7>return s;\n<line8>#elif defined __GNUC__ && !defined __clang__\n<line9>memset (s, c, len);\n<line10>/* Compiler barrier.  */\n<line11>__asm__ volatile ("" ::: "memory");\n<line12>return s;\n<line13>#elif defined __clang__\n<line14>memset (s, c, len);\n<line15>/* Compiler barrier.  */\n<line16>/* With asm ("" ::: "memory") LLVM analyzes uses of 's' and finds that the\n<line17>whole thing is dead and eliminates it.  Use 'g' to work around this\n<line18>problem.  See <https://bugs.llvm.org/show_bug.cgi?id=15495#c11>.  */\n<line19>__asm__ volatile ("" : : "g"(s) : "memory");\n<line20>return s;\n<line21>#else\n<line22>/* Invoke memset through a volatile function pointer.  This defeats compiler\n<line23>optimizations.  */\n<line24>void * (* const volatile volatile_memset) (void *, int, size_t) = memset;\n<line25>return volatile_memset (s, c, len);\n<line26>#endif\n<line27>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/mgetgroups.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
Function: realloc_groupbuf
Content: <line0>static gid_t *\n<line1>realloc_groupbuf (gid_t *g, size_t num)\n<line2>{\n<line3>if (xalloc_oversized (num, sizeof *g))\n<line4>{\n<line5>errno = ENOMEM;\n<line6>return NULL;\n<line7>}\n<line8>return realloc (g, num * sizeof *g);\n<line9>}
----------------------------------------
Function: mgetgroups
Content: <line0>int\n<line1>mgetgroups (char const *username, gid_t gid, gid_t **groups)\n<line2>{\n<line3>int max_n_groups;\n<line4>int ng;\n<line5>gid_t *g;\n<line6>#if HAVE_GETGROUPLIST\n<line7>/* We prefer to use getgrouplist if available, because it has better\n<line8>performance characteristics.\n<line9>In glibc 2.3.2, getgrouplist is buggy.  If you pass a zero as the\n<line10>length of the output buffer, getgrouplist will still write to the\n<line11>buffer.  Contrary to what some versions of the getgrouplist\n<line12>manpage say, this doesn't happen with nonzero buffer sizes.\n<line13>Therefore our usage here just avoids a zero sized buffer.  */\n<line14>if (username)\n<line15>{\n<line16>enum { N_GROUPS_INIT = 10 };\n<line17>max_n_groups = N_GROUPS_INIT;\n<line18>g = realloc_groupbuf (NULL, max_n_groups);\n<line19>if (g == NULL)\n<line20>return -1;\n<line21>while (1)\n<line22>{\n<line23>gid_t *h;\n<line24>int last_n_groups = max_n_groups;\n<line25>/* getgrouplist updates max_n_groups to num required.  */\n<line26>ng = getgrouplist (username, gid, g, &max_n_groups);\n<line27>/* Some systems (like Darwin) have a bug where they\n<line28>never increase max_n_groups.  */\n<line29>if (ng < 0 && last_n_groups == max_n_groups)\n<line30>max_n_groups *= 2;\n<line31>if ((h = realloc_groupbuf (g, max_n_groups)) == NULL)\n<line32>{\n<line33>free (g);\n<line34>return -1;\n<line35>}\n<line36>g = h;\n<line37>if (0 <= ng)\n<line38>{\n<line39>*groups = g;\n<line40>/* On success some systems just return 0 from getgrouplist,\n<line41>so return max_n_groups rather than ng.  */\n<line42>return max_n_groups;\n<line43>}\n<line44>}\n<line45>}\n<line46>/* else no username, so fall through and use getgroups. */\n<line47>#endif\n<line48>max_n_groups = (username\n<line49>? getugroups (0, NULL, username, gid)\n<line50>: getgroups (0, NULL));\n<line51>/* If we failed to count groups because there is no supplemental\n<line52>group support, then return an array containing just GID.\n<line53>Otherwise, we fail for the same reason.  */\n<line54>if (max_n_groups < 0)\n<line55>{\n<line56>if (errno == ENOSYS && (g = realloc_groupbuf (NULL, 1)))\n<line57>{\n<line58>*groups = g;\n<line59>*g = gid;\n<line60>return gid != (gid_t) -1;\n<line61>}\n<line62>return -1;\n<line63>}\n<line64>if (max_n_groups == 0 || (!username && gid != (gid_t) -1))\n<line65>max_n_groups++;\n<line66>g = realloc_groupbuf (NULL, max_n_groups);\n<line67>if (g == NULL)\n<line68>return -1;\n<line69>ng = (username\n<line70>? getugroups (max_n_groups, g, username, gid)\n<line71>: getgroups (max_n_groups - (gid != (gid_t) -1),\n<line72>g + (gid != (gid_t) -1)));\n<line73>if (ng < 0)\n<line74>{\n<line75>/* Failure is unexpected, but handle it anyway.  */\n<line76>free (g);\n<line77>return -1;\n<line78>}\n<line79>if (!username && gid != (gid_t) -1)\n<line80>{\n<line81>*g = gid;\n<line82>ng++;\n<line83>}\n<line84>*groups = g;\n<line85>/* Reduce the number of duplicates.  On some systems, getgroups\n<line86>returns the effective gid twice: once as the first element, and\n<line87>once in its position within the supplementary groups.  On other\n<line88>systems, getgroups does not return the effective gid at all,\n<line89>which is why we provide a GID argument.  Meanwhile, the GID\n<line90>argument, if provided, is typically any member of the\n<line91>supplementary groups, and not necessarily the effective gid.  So,\n<line92>the most likely duplicates are the first element with an\n<line93>arbitrary other element, or pair-wise duplication between the\n<line94>first and second elements returned by getgroups.  It is possible\n<line95>that this O(n) pass will not remove all duplicates, but it is not\n<line96>worth the effort to slow down to an O(n log n) algorithm that\n<line97>sorts the array in place, nor the extra memory needed for\n<line98>duplicate removal via an O(n) hash-table.  Hence, this function\n<line99>is only documented as guaranteeing no pair-wise duplicates,\n<line100>rather than returning the minimal set.  */\n<line101>if (1 < ng)\n<line102>{\n<line103>gid_t first = *g;\n<line104>gid_t *next;\n<line105>gid_t *groups_end = g + ng;\n<line106>for (next = g + 1; next < groups_end; next++)\n<line107>{\n<line108>if (*next == first || *next == *g)\n<line109>ng--;\n<line110>else\n<line111>*++g = *next;\n<line112>}\n<line113>}\n<line114>return ng;\n<line115>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/mkancesdirs.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
Function: mkancesdirs
Content: <line0>ptrdiff_t\n<line1>mkancesdirs (char *file, struct savewd *wd,\n<line2>int (*make_dir) (char const *, char const *, void *),\n<line3>void *make_dir_arg)\n<line4>{\n<line5>/* Address of the previous directory separator that follows an\n<line6>ordinary byte in a file name in the left-to-right scan, or NULL\n<line7>if no such separator precedes the current location P.  */\n<line8>char *sep = NULL;\n<line9>/* Address of the leftmost file name component that has not yet\n<line10>been processed.  */\n<line11>char *component = file;\n<line12>char *p = file + FILE_SYSTEM_PREFIX_LEN (file);\n<line13>char c;\n<line14>bool made_dir = false;\n<line15>/* Scan forward through FILE, creating and chdiring into directories\n<line16>along the way.  Try MAKE_DIR before chdir, so that the procedure\n<line17>works even when two or more processes are executing it in\n<line18>parallel.  Isolate each file name component by having COMPONENT\n<line19>point to its start and SEP point just after its end.  */\n<line20>while ((c = *p++))\n<line21>if (ISSLASH (*p))\n<line22>{\n<line23>if (! ISSLASH (c))\n<line24>sep = p;\n<line25>}\n<line26>else if (ISSLASH (c) && *p && sep)\n<line27>{\n<line28>/* Don't bother to make or test for "." since it does not\n<line29>affect the algorithm.  */\n<line30>if (! (sep - component == 1 && component[0] == '.'))\n<line31>{\n<line32>int make_dir_errno = 0;\n<line33>int savewd_chdir_options = 0;\n<line34>int chdir_result;\n<line35>/* Temporarily modify FILE to isolate this file name\n<line36>component.  */\n<line37>*sep = '\0';\n<line38>/* Invoke MAKE_DIR on this component, except don't bother\n<line39>with ".." since it must exist if its "parent" does.  */\n<line40>if (sep - component == 2\n<line41>&& component[0] == '.' && component[1] == '.')\n<line42>made_dir = false;\n<line43>else if (make_dir (file, component, make_dir_arg) < 0)\n<line44>make_dir_errno = errno;\n<line45>else\n<line46>made_dir = true;\n<line47>if (made_dir)\n<line48>savewd_chdir_options |= SAVEWD_CHDIR_NOFOLLOW;\n<line49>chdir_result =\n<line50>savewd_chdir (wd, component, savewd_chdir_options, NULL);\n<line51>/* Undo the temporary modification to FILE, unless there\n<line52>was a failure.  */\n<line53>if (chdir_result != -1)\n<line54>*sep = '/';\n<line55>if (chdir_result != 0)\n<line56>{\n<line57>if (make_dir_errno != 0 && errno == ENOENT)\n<line58>errno = make_dir_errno;\n<line59>return chdir_result;\n<line60>}\n<line61>}\n<line62>component = p;\n<line63>}\n<line64>return component - file;\n<line65>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/dirchownmod.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
Function: dirchownmod
Content: <line0>int\n<line1>dirchownmod (int fd, char const *dir, mode_t mkdir_mode,\n<line2>uid_t owner, gid_t group,\n<line3>mode_t mode, mode_t mode_bits)\n<line4>{\n<line5>struct stat st;\n<line6>int result = (fd < 0 ? stat (dir, &st) : fstat (fd, &st));\n<line7>if (result == 0)\n<line8>{\n<line9>mode_t dir_mode = st.st_mode;\n<line10>/* Check whether DIR is a directory.  If FD is nonnegative, this\n<line11>check avoids changing the ownership and mode bits of the\n<line12>wrong file in many cases.  This doesn't fix all the race\n<line13>conditions, but it is better than nothing.  */\n<line14>if (! S_ISDIR (dir_mode))\n<line15>{\n<line16>errno = ENOTDIR;\n<line17>result = -1;\n<line18>}\n<line19>else\n<line20>{\n<line21>/* If at least one of the S_IXUGO bits are set, chown might\n<line22>clear the S_ISUID and S_SGID bits.  Keep track of any\n<line23>file mode bits whose values are indeterminate due to this\n<line24>issue.  */\n<line25>mode_t indeterminate = 0;\n<line26>/* On some systems, chown clears S_ISUID and S_ISGID, so do\n<line27>chown before chmod.  On older System V hosts, ordinary\n<line28>users can give their files away via chown; don't worry\n<line29>about that here, since users shouldn't do that.  */\n<line30>if ((owner != (uid_t) -1 && owner != st.st_uid)\n<line31>|| (group != (gid_t) -1 && group != st.st_gid))\n<line32>{\n<line33>result = (0 <= fd\n<line34>? fchown (fd, owner, group)\n<line35>: mkdir_mode != (mode_t) -1\n<line36>? lchown (dir, owner, group)\n<line37>: chown (dir, owner, group));\n<line38>/* Either the user cares about an indeterminate bit and\n<line39>it'll be set properly by chmod below, or the user\n<line40>doesn't care and it's OK to use the bit's pre-chown\n<line41>value.  So there's no need to re-stat DIR here.  */\n<line42>if (result == 0 && (dir_mode & S_IXUGO))\n<line43>indeterminate = dir_mode & (S_ISUID | S_ISGID);\n<line44>}\n<line45>/* If the file mode bits might not be right, use chmod to\n<line46>change them.  Don't change bits the user doesn't care\n<line47>about.  */\n<line48>if (result == 0 && (((dir_mode ^ mode) | indeterminate) & mode_bits))\n<line49>{\n<line50>mode_t chmod_mode =\n<line51>mode | (dir_mode & CHMOD_MODE_BITS & ~mode_bits);\n<line52>result = (HAVE_FCHMOD && 0 <= fd\n<line53>? fchmod (fd, chmod_mode)\n<line54>: mkdir_mode != (mode_t) -1\n<line55>? lchmod (dir, chmod_mode)\n<line56>: chmod (dir, chmod_mode));\n<line57>}\n<line58>}\n<line59>}\n<line60>if (0 <= fd)\n<line61>{\n<line62>if (result == 0)\n<line63>result = close (fd);\n<line64>else\n<line65>{\n<line66>int e = errno;\n<line67>close (fd);\n<line68>errno = e;\n<line69>}\n<line70>}\n<line71>return result;\n<line72>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/mkdir-p.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
In file included from /home/huihui/Downloads/coreutils-9.4/lib/mkdir-p.c:34:
./lib/error.h:28:3: warning: #include_next in file found relative to primary source file or found by absolute path; will search from start of include path [-Winclude-next-absolute-path]
# include_next <error.h>
  ^
2 warnings generated.
========================================
/home/huihui/Downloads/coreutils-9.4/lib/modechange.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
Function: octal_to_mode
Content: <line0>static mode_t\n<line1>octal_to_mode (unsigned int octal)\n<line2>{\n<line3>/* Help the compiler optimize the usual case where mode_t uses\n<line4>the traditional octal representation.  */\n<line5>return ((S_ISUID == SUID && S_ISGID == SGID && S_ISVTX == SVTX\n<line6>&& S_IRUSR == RUSR && S_IWUSR == WUSR && S_IXUSR == XUSR\n<line7>&& S_IRGRP == RGRP && S_IWGRP == WGRP && S_IXGRP == XGRP\n<line8>&& S_IROTH == ROTH && S_IWOTH == WOTH && S_IXOTH == XOTH)\n<line9>? octal\n<line10>: (mode_t) ((octal & SUID ? S_ISUID : 0)\n<line11>| (octal & SGID ? S_ISGID : 0)\n<line12>| (octal & SVTX ? S_ISVTX : 0)\n<line13>| (octal & RUSR ? S_IRUSR : 0)\n<line14>| (octal & WUSR ? S_IWUSR : 0)\n<line15>| (octal & XUSR ? S_IXUSR : 0)\n<line16>| (octal & RGRP ? S_IRGRP : 0)\n<line17>| (octal & WGRP ? S_IWGRP : 0)\n<line18>| (octal & XGRP ? S_IXGRP : 0)\n<line19>| (octal & ROTH ? S_IROTH : 0)\n<line20>| (octal & WOTH ? S_IWOTH : 0)\n<line21>| (octal & XOTH ? S_IXOTH : 0)));\n<line22>}
----------------------------------------
Function: make_node_op_equals
Content: <line0>static struct mode_change *\n<line1>make_node_op_equals (mode_t new_mode, mode_t mentioned)\n<line2>{\n<line3>struct mode_change *p = xmalloc (2 * sizeof *p);\n<line4>p->op = '=';\n<line5>p->flag = MODE_ORDINARY_CHANGE;\n<line6>p->affected = CHMOD_MODE_BITS;\n<line7>p->value = new_mode;\n<line8>p->mentioned = mentioned;\n<line9>p[1].flag = MODE_DONE;\n<line10>return p;\n<line11>}
----------------------------------------
Function: mode_compile
Content: <line0>struct mode_change *\n<line1>mode_compile (char const *mode_string)\n<line2>{\n<line3>/* The array of mode-change directives to be returned.  */\n<line4>struct mode_change *mc;\n<line5>size_t used = 0;\n<line6>char const *p;\n<line7>if ('0' <= *mode_string && *mode_string < '8')\n<line8>{\n<line9>unsigned int octal_mode = 0;\n<line10>mode_t mode;\n<line11>mode_t mentioned;\n<line12>p = mode_string;\n<line13>do\n<line14>{\n<line15>octal_mode = 8 * octal_mode + *p++ - '0';\n<line16>if (ALLM < octal_mode)\n<line17>return NULL;\n<line18>}\n<line19>while ('0' <= *p && *p < '8');\n<line20>if (*p)\n<line21>return NULL;\n<line22>mode = octal_to_mode (octal_mode);\n<line23>mentioned = (p - mode_string < 5\n<line24>? (mode & (S_ISUID | S_ISGID)) | S_ISVTX | S_IRWXUGO\n<line25>: CHMOD_MODE_BITS);\n<line26>return make_node_op_equals (mode, mentioned);\n<line27>}\n<line28>/* Allocate enough space to hold the result.  */\n<line29>{\n<line30>size_t needed = 1;\n<line31>for (p = mode_string; *p; p++)\n<line32>needed += (*p == '=' || *p == '+' || *p == '-');\n<line33>mc = xnmalloc (needed, sizeof *mc);\n<line34>}\n<line35>/* One loop iteration for each\n<line36>'[ugoa]*([-+=]([rwxXst]*|[ugo]))+|[-+=][0-7]+'.  */\n<line37>for (p = mode_string; ; p++)\n<line38>{\n<line39>/* Which bits in the mode are operated on.  */\n<line40>mode_t affected = 0;\n<line41>/* Turn on all the bits in 'affected' for each group given.  */\n<line42>for (;; p++)\n<line43>switch (*p)\n<line44>{\n<line45>default:\n<line46>goto invalid;\n<line47>case 'u':\n<line48>affected |= S_ISUID | S_IRWXU;\n<line49>break;\n<line50>case 'g':\n<line51>affected |= S_ISGID | S_IRWXG;\n<line52>break;\n<line53>case 'o':\n<line54>affected |= S_ISVTX | S_IRWXO;\n<line55>break;\n<line56>case 'a':\n<line57>affected |= CHMOD_MODE_BITS;\n<line58>break;\n<line59>case '=': case '+': case '-':\n<line60>goto no_more_affected;\n<line61>}\n<line62>no_more_affected:;\n<line63>do\n<line64>{\n<line65>char op = *p++;\n<line66>mode_t value;\n<line67>mode_t mentioned = 0;\n<line68>char flag = MODE_COPY_EXISTING;\n<line69>struct mode_change *change;\n<line70>switch (*p)\n<line71>{\n<line72>case '0': case '1': case '2': case '3':\n<line73>case '4': case '5': case '6': case '7':\n<line74>{\n<line75>unsigned int octal_mode = 0;\n<line76>do\n<line77>{\n<line78>octal_mode = 8 * octal_mode + *p++ - '0';\n<line79>if (ALLM < octal_mode)\n<line80>goto invalid;\n<line81>}\n<line82>while ('0' <= *p && *p < '8');\n<line83>if (affected || (*p && *p != ','))\n<line84>goto invalid;\n<line85>affected = mentioned = CHMOD_MODE_BITS;\n<line86>value = octal_to_mode (octal_mode);\n<line87>flag = MODE_ORDINARY_CHANGE;\n<line88>break;\n<line89>}\n<line90>case 'u':\n<line91>/* Set the affected bits to the value of the "u" bits\n<line92>on the same file.  */\n<line93>value = S_IRWXU;\n<line94>p++;\n<line95>break;\n<line96>case 'g':\n<line97>/* Set the affected bits to the value of the "g" bits\n<line98>on the same file.  */\n<line99>value = S_IRWXG;\n<line100>p++;\n<line101>break;\n<line102>case 'o':\n<line103>/* Set the affected bits to the value of the "o" bits\n<line104>on the same file.  */\n<line105>value = S_IRWXO;\n<line106>p++;\n<line107>break;\n<line108>default:\n<line109>value = 0;\n<line110>flag = MODE_ORDINARY_CHANGE;\n<line111>for (;; p++)\n<line112>switch (*p)\n<line113>{\n<line114>case 'r':\n<line115>value |= S_IRUSR | S_IRGRP | S_IROTH;\n<line116>break;\n<line117>case 'w':\n<line118>value |= S_IWUSR | S_IWGRP | S_IWOTH;\n<line119>break;\n<line120>case 'x':\n<line121>value |= S_IXUSR | S_IXGRP | S_IXOTH;\n<line122>break;\n<line123>case 'X':\n<line124>flag = MODE_X_IF_ANY_X;\n<line125>break;\n<line126>case 's':\n<line127>/* Set the setuid/gid bits if 'u' or 'g' is selected.  */\n<line128>value |= S_ISUID | S_ISGID;\n<line129>break;\n<line130>case 't':\n<line131>/* Set the "save text image" bit if 'o' is selected.  */\n<line132>value |= S_ISVTX;\n<line133>break;\n<line134>default:\n<line135>goto no_more_values;\n<line136>}\n<line137>no_more_values:;\n<line138>}\n<line139>change = &mc[used++];\n<line140>change->op = op;\n<line141>change->flag = flag;\n<line142>change->affected = affected;\n<line143>change->value = value;\n<line144>change->mentioned =\n<line145>(mentioned ? mentioned : affected ? affected & value : value);\n<line146>}\n<line147>while (*p == '=' || *p == '+' || *p == '-');\n<line148>if (*p != ',')\n<line149>break;\n<line150>}\n<line151>if (*p == 0)\n<line152>{\n<line153>mc[used].flag = MODE_DONE;\n<line154>return mc;\n<line155>}\n<line156>invalid:\n<line157>free (mc);\n<line158>return NULL;\n<line159>}
----------------------------------------
Function: mode_create_from_ref
Content: <line0>struct mode_change *\n<line1>mode_create_from_ref (const char *ref_file)\n<line2>{\n<line3>struct stat ref_stats;\n<line4>if (stat (ref_file, &ref_stats) != 0)\n<line5>return NULL;\n<line6>return make_node_op_equals (ref_stats.st_mode, CHMOD_MODE_BITS);\n<line7>}
----------------------------------------
Function: mode_adjust
Content: <line0>mode_t\n<line1>mode_adjust (mode_t oldmode, bool dir, mode_t umask_value,\n<line2>struct mode_change const *changes, mode_t *pmode_bits)\n<line3>{\n<line4>/* The adjusted mode.  */\n<line5>mode_t newmode = oldmode & CHMOD_MODE_BITS;\n<line6>/* File mode bits that CHANGES cares about.  */\n<line7>mode_t mode_bits = 0;\n<line8>for (; changes->flag != MODE_DONE; changes++)\n<line9>{\n<line10>mode_t affected = changes->affected;\n<line11>mode_t omit_change =\n<line12>(dir ? S_ISUID | S_ISGID : 0) & ~ changes->mentioned;\n<line13>mode_t value = changes->value;\n<line14>switch (changes->flag)\n<line15>{\n<line16>case MODE_ORDINARY_CHANGE:\n<line17>break;\n<line18>case MODE_COPY_EXISTING:\n<line19>/* Isolate in 'value' the bits in 'newmode' to copy.  */\n<line20>value &= newmode;\n<line21>/* Copy the isolated bits to the other two parts.  */\n<line22>value |= ((value & (S_IRUSR | S_IRGRP | S_IROTH)\n<line23>? S_IRUSR | S_IRGRP | S_IROTH : 0)\n<line24>| (value & (S_IWUSR | S_IWGRP | S_IWOTH)\n<line25>? S_IWUSR | S_IWGRP | S_IWOTH : 0)\n<line26>| (value & (S_IXUSR | S_IXGRP | S_IXOTH)\n<line27>? S_IXUSR | S_IXGRP | S_IXOTH : 0));\n<line28>break;\n<line29>case MODE_X_IF_ANY_X:\n<line30>/* Affect the execute bits if execute bits are already set\n<line31>or if the file is a directory.  */\n<line32>if ((newmode & (S_IXUSR | S_IXGRP | S_IXOTH)) | dir)\n<line33>value |= S_IXUSR | S_IXGRP | S_IXOTH;\n<line34>break;\n<line35>}\n<line36>/* If WHO was specified, limit the change to the affected bits.\n<line37>Otherwise, apply the umask.  Either way, omit changes as\n<line38>requested.  */\n<line39>value &= (affected ? affected : ~umask_value) & ~ omit_change;\n<line40>switch (changes->op)\n<line41>{\n<line42>case '=':\n<line43>/* If WHO was specified, preserve the previous values of\n<line44>bits that are not affected by this change operation.\n<line45>Otherwise, clear all the bits.  */\n<line46>{\n<line47>mode_t preserved = (affected ? ~affected : 0) | omit_change;\n<line48>mode_bits |= CHMOD_MODE_BITS & ~preserved;\n<line49>newmode = (newmode & preserved) | value;\n<line50>break;\n<line51>}\n<line52>case '+':\n<line53>mode_bits |= value;\n<line54>newmode |= value;\n<line55>break;\n<line56>case '-':\n<line57>mode_bits |= value;\n<line58>newmode &= ~value;\n<line59>break;\n<line60>}\n<line61>}\n<line62>if (pmode_bits)\n<line63>*pmode_bits = mode_bits;\n<line64>return newmode;\n<line65>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/mountlist.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
Function: dev_from_mount_options
Content: <line0>static dev_t\n<line1>dev_from_mount_options (char const *mount_options)\n<line2>{\n<line3>/* GNU/Linux allows file system implementations to define their own\n<line4>meaning for "dev=" mount options, so don't trust the meaning\n<line5>here.  */\n<line6># ifndef __linux__\n<line7>static char const dev_pattern[] = ",dev=";\n<line8>char const *devopt = strstr (mount_options, dev_pattern);\n<line9>if (devopt)\n<line10>{\n<line11>char const *optval = devopt + sizeof dev_pattern - 1;\n<line12>char *optvalend;\n<line13>unsigned long int dev;\n<line14>errno = 0;\n<line15>dev = strtoul (optval, &optvalend, 16);\n<line16>if (optval != optvalend\n<line17>&& (*optvalend == '\0' || *optvalend == ',')\n<line18>&& ! (dev == ULONG_MAX && errno == ERANGE)\n<line19>&& dev == (dev_t) dev)\n<line20>return dev;\n<line21>}\n<line22># endif\n<line23>(void) mount_options;\n<line24>return -1;\n<line25>}
----------------------------------------
Function: unescape_tab
Content: <line0>static void\n<line1>unescape_tab (char *str)\n<line2>{\n<line3>size_t i, j = 0;\n<line4>size_t len = strlen (str) + 1;\n<line5>for (i = 0; i < len; i++)\n<line6>{\n<line7>if (str[i] == '\\' && (i + 4 < len)\n<line8>&& str[i + 1] >= '0' && str[i + 1] <= '3'\n<line9>&& str[i + 2] >= '0' && str[i + 2] <= '7'\n<line10>&& str[i + 3] >= '0' && str[i + 3] <= '7')\n<line11>{\n<line12>str[j++] = (str[i + 1] - '0') * 64 +\n<line13>(str[i + 2] - '0') * 8 +\n<line14>(str[i + 3] - '0');\n<line15>i += 3;\n<line16>}\n<line17>else\n<line18>str[j++] = str[i];\n<line19>}\n<line20>}
----------------------------------------
Function: terminate_at_blank
Content: <line0>static char *\n<line1>terminate_at_blank (char *str)\n<line2>{\n<line3>char *s = strchr (str, ' ');\n<line4>if (s)\n<line5>*s = '\0';\n<line6>return s;\n<line7>}
----------------------------------------
Function: read_file_system_list
Content: <line0>struct mount_entry *\n<line1>read_file_system_list (bool need_fs_type)\n<line2>{\n<line3>struct mount_entry *mount_list;\n<line4>struct mount_entry *me;\n<line5>struct mount_entry **mtail = &mount_list;\n<line6>(void) need_fs_type;\n<line7>#ifdef MOUNTED_GETMNTENT1       /* glibc, HP-UX, IRIX, Cygwin, Android,\n<line8>also (obsolete) 4.3BSD, SunOS */\n<line9>{\n<line10>FILE *fp;\n<line11># if defined __linux__ || defined __ANDROID__\n<line12>/* Try parsing mountinfo first, as that make device IDs available.\n<line13>Note we could use libmount routines to simplify this parsing a little\n<line14>(and that code is in previous versions of this function), however\n<line15>libmount depends on libselinux which pulls in many dependencies.  */\n<line16>char const *mountinfo = "/proc/self/mountinfo";\n<line17>fp = fopen (mountinfo, "re");\n<line18>if (fp != NULL)\n<line19>{\n<line20>char *line = NULL;\n<line21>size_t buf_size = 0;\n<line22>while (getline (&line, &buf_size, fp) != -1)\n<line23>{\n<line24>unsigned int devmaj, devmin;\n<line25>int rc, mntroot_s;\n<line26>rc = sscanf(line, "%*u "        /* id - discarded  */\n<line27>"%*u "        /* parent - discarded  */\n<line28>"%u:%u "      /* dev major:minor  */\n<line29>"%n",         /* mountroot (start)  */\n<line30>&devmaj, &devmin,\n<line31>&mntroot_s);\n<line32>if (rc != 2 && rc != 3)  /* 3 if %n included in count.  */\n<line33>continue;\n<line34>/* find end of MNTROOT.  */\n<line35>char *mntroot = line + mntroot_s;\n<line36>char *blank = terminate_at_blank (mntroot);\n<line37>if (! blank)\n<line38>continue;\n<line39>/* find end of TARGET.  */\n<line40>char *target = blank + 1;\n<line41>blank = terminate_at_blank (target);\n<line42>if (! blank)\n<line43>continue;\n<line44>/* skip optional fields, terminated by " - "  */\n<line45>char *dash = strstr (blank + 1, " - ");\n<line46>if (! dash)\n<line47>continue;\n<line48>/* advance past the " - " separator.  */\n<line49>char *fstype = dash + 3;\n<line50>blank = terminate_at_blank (fstype);\n<line51>if (! blank)\n<line52>continue;\n<line53>/* find end of SOURCE.  */\n<line54>char *source = blank + 1;\n<line55>if (! terminate_at_blank (source))\n<line56>continue;\n<line57>/* manipulate the sub-strings in place.  */\n<line58>unescape_tab (source);\n<line59>unescape_tab (target);\n<line60>unescape_tab (mntroot);\n<line61>unescape_tab (fstype);\n<line62>me = xmalloc (sizeof *me);\n<line63>me->me_devname = xstrdup (source);\n<line64>me->me_mountdir = xstrdup (target);\n<line65>me->me_mntroot = xstrdup (mntroot);\n<line66>me->me_type = xstrdup (fstype);\n<line67>me->me_type_malloced = 1;\n<line68>me->me_dev = makedev (devmaj, devmin);\n<line69>/* we pass "false" for the "Bind" option as that's only\n<line70>significant when the Fs_type is "none" which will not be\n<line71>the case when parsing "/proc/self/mountinfo", and only\n<line72>applies for static /etc/mtab files.  */\n<line73>me->me_dummy = ME_DUMMY (me->me_devname, me->me_type, false);\n<line74>me->me_remote = ME_REMOTE (me->me_devname, me->me_type);\n<line75>/* Add to the linked list. */\n<line76>*mtail = me;\n<line77>mtail = &me->me_next;\n<line78>}\n<line79>free (line);\n<line80>if (ferror (fp))\n<line81>{\n<line82>int saved_errno = errno;\n<line83>fclose (fp);\n<line84>errno = saved_errno;\n<line85>goto free_then_fail;\n<line86>}\n<line87>if (fclose (fp) == EOF)\n<line88>goto free_then_fail;\n<line89>}\n<line90>else /* fallback to /proc/self/mounts (/etc/mtab).  */\n<line91># endif /* __linux __ || __ANDROID__ */\n<line92>{\n<line93>struct mntent *mnt;\n<line94>char const *table = MOUNTED;\n<line95>fp = setmntent (table, "r");\n<line96>if (fp == NULL)\n<line97>return NULL;\n<line98>while ((mnt = getmntent (fp)))\n<line99>{\n<line100>bool bind = hasmntopt (mnt, "bind");\n<line101>me = xmalloc (sizeof *me);\n<line102>me->me_devname = xstrdup (mnt->mnt_fsname);\n<line103>me->me_mountdir = xstrdup (mnt->mnt_dir);\n<line104>me->me_mntroot = NULL;\n<line105>me->me_type = xstrdup (mnt->mnt_type);\n<line106>me->me_type_malloced = 1;\n<line107>me->me_dummy = ME_DUMMY (me->me_devname, me->me_type, bind);\n<line108>me->me_remote = ME_REMOTE (me->me_devname, me->me_type);\n<line109>me->me_dev = dev_from_mount_options (mnt->mnt_opts);\n<line110>/* Add to the linked list. */\n<line111>*mtail = me;\n<line112>mtail = &me->me_next;\n<line113>}\n<line114>if (endmntent (fp) == 0)\n<line115>goto free_then_fail;\n<line116>}\n<line117>}\n<line118>#endif /* MOUNTED_GETMNTENT1. */\n<line119>#ifdef MOUNTED_GETMNTINFO       /* Mac OS X, FreeBSD, OpenBSD, also (obsolete) 4.4BSD */\n<line120>{\n<line121>struct statfs *fsp;\n<line122>int entries;\n<line123>entries = getmntinfo (&fsp, MNT_NOWAIT);\n<line124>if (entries < 0)\n<line125>return NULL;\n<line126>for (; entries-- > 0; fsp++)\n<line127>{\n<line128>char *fs_type = fsp_to_string (fsp);\n<line129>me = xmalloc (sizeof *me);\n<line130>me->me_devname = xstrdup (fsp->f_mntfromname);\n<line131>me->me_mountdir = xstrdup (fsp->f_mntonname);\n<line132>me->me_mntroot = NULL;\n<line133>me->me_type = fs_type;\n<line134>me->me_type_malloced = 0;\n<line135>me->me_dummy = ME_DUMMY (me->me_devname, me->me_type);\n<line136>me->me_remote = ME_REMOTE (me->me_devname, me->me_type);\n<line137>me->me_dev = (dev_t) -1;        /* Magic; means not known yet. */\n<line138>/* Add to the linked list. */\n<line139>*mtail = me;\n<line140>mtail = &me->me_next;\n<line141>}\n<line142>}\n<line143>#endif /* MOUNTED_GETMNTINFO */\n<line144>#ifdef MOUNTED_GETMNTINFO2      /* NetBSD, Minix */\n<line145>{\n<line146>struct statvfs *fsp;\n<line147>int entries;\n<line148>entries = getmntinfo (&fsp, MNT_NOWAIT);\n<line149>if (entries < 0)\n<line150>return NULL;\n<line151>for (; entries-- > 0; fsp++)\n<line152>{\n<line153>me = xmalloc (sizeof *me);\n<line154>me->me_devname = xstrdup (fsp->f_mntfromname);\n<line155>me->me_mountdir = xstrdup (fsp->f_mntonname);\n<line156>me->me_mntroot = NULL;\n<line157>me->me_type = xstrdup (fsp->f_fstypename);\n<line158>me->me_type_malloced = 1;\n<line159>me->me_dummy = ME_DUMMY (me->me_devname, me->me_type);\n<line160>me->me_remote = ME_REMOTE (me->me_devname, me->me_type);\n<line161>me->me_dev = (dev_t) -1;        /* Magic; means not known yet. */\n<line162>/* Add to the linked list. */\n<line163>*mtail = me;\n<line164>mtail = &me->me_next;\n<line165>}\n<line166>}\n<line167>#endif /* MOUNTED_GETMNTINFO2 */\n<line168>#if defined MOUNTED_FS_STAT_DEV /* Haiku, also (obsolete) BeOS */\n<line169>{\n<line170>/* The next_dev() and fs_stat_dev() system calls give the list of\n<line171>all file systems, including the information returned by statvfs()\n<line172>(fs type, total blocks, free blocks etc.), but without the mount\n<line173>point. But on BeOS all file systems except / are mounted in the\n<line174>rootfs, directly under /.\n<line175>The directory name of the mount point is often, but not always,\n<line176>identical to the volume name of the device.\n<line177>We therefore get the list of subdirectories of /, and the list\n<line178>of all file systems, and match the two lists.  */\n<line179>DIR *dirp;\n<line180>struct rootdir_entry\n<line181>{\n<line182>char *name;\n<line183>dev_t dev;\n<line184>ino_t ino;\n<line185>struct rootdir_entry *next;\n<line186>};\n<line187>struct rootdir_entry *rootdir_list;\n<line188>struct rootdir_entry **rootdir_tail;\n<line189>int32 pos;\n<line190>dev_t dev;\n<line191>fs_info fi;\n<line192>/* All volumes are mounted in the rootfs, directly under /. */\n<line193>rootdir_list = NULL;\n<line194>rootdir_tail = &rootdir_list;\n<line195>dirp = opendir ("/");\n<line196>if (dirp)\n<line197>{\n<line198>struct dirent *d;\n<line199>while ((d = readdir (dirp)) != NULL)\n<line200>{\n<line201>char *name;\n<line202>struct stat statbuf;\n<line203>if (strcmp (d->d_name, "..") == 0)\n<line204>continue;\n<line205>if (strcmp (d->d_name, ".") == 0)\n<line206>name = xstrdup ("/");\n<line207>else\n<line208>{\n<line209>name = xmalloc (1 + strlen (d->d_name) + 1);\n<line210>name[0] = '/';\n<line211>strcpy (name + 1, d->d_name);\n<line212>}\n<line213>if (lstat (name, &statbuf) >= 0 && S_ISDIR (statbuf.st_mode))\n<line214>{\n<line215>struct rootdir_entry *re = xmalloc (sizeof *re);\n<line216>re->name = name;\n<line217>re->dev = statbuf.st_dev;\n<line218>re->ino = statbuf.st_ino;\n<line219>/* Add to the linked list.  */\n<line220>*rootdir_tail = re;\n<line221>rootdir_tail = &re->next;\n<line222>}\n<line223>else\n<line224>free (name);\n<line225>}\n<line226>closedir (dirp);\n<line227>}\n<line228>*rootdir_tail = NULL;\n<line229>for (pos = 0; (dev = next_dev (&pos)) >= 0; )\n<line230>if (fs_stat_dev (dev, &fi) >= 0)\n<line231>{\n<line232>/* Note: fi.dev == dev. */\n<line233>struct rootdir_entry *re;\n<line234>for (re = rootdir_list; re; re = re->next)\n<line235>if (re->dev == fi.dev && re->ino == fi.root)\n<line236>break;\n<line237>me = xmalloc (sizeof *me);\n<line238>me->me_devname = xstrdup (fi.device_name[0] != '\0'\n<line239>? fi.device_name : fi.fsh_name);\n<line240>me->me_mountdir = xstrdup (re != NULL ? re->name : fi.fsh_name);\n<line241>me->me_mntroot = NULL;\n<line242>me->me_type = xstrdup (fi.fsh_name);\n<line243>me->me_type_malloced = 1;\n<line244>me->me_dev = fi.dev;\n<line245>me->me_dummy = 0;\n<line246>me->me_remote = (fi.flags & B_FS_IS_SHARED) != 0;\n<line247>/* Add to the linked list. */\n<line248>*mtail = me;\n<line249>mtail = &me->me_next;\n<line250>}\n<line251>*mtail = NULL;\n<line252>while (rootdir_list != NULL)\n<line253>{\n<line254>struct rootdir_entry *re = rootdir_list;\n<line255>rootdir_list = re->next;\n<line256>free (re->name);\n<line257>free (re);\n<line258>}\n<line259>}\n<line260>#endif /* MOUNTED_FS_STAT_DEV */\n<line261>#if defined MOUNTED_GETFSSTAT   /* OSF/1, also (obsolete) Apple Darwin 1.3 */\n<line262>{\n<line263>int numsys, counter;\n<line264>size_t bufsize;\n<line265>struct statfs *stats;\n<line266>numsys = getfsstat (NULL, 0L, MNT_NOWAIT);\n<line267>if (numsys < 0)\n<line268>return NULL;\n<line269>if (SIZE_MAX / sizeof *stats <= numsys)\n<line270>xalloc_die ();\n<line271>bufsize = (1 + numsys) * sizeof *stats;\n<line272>stats = xmalloc (bufsize);\n<line273>numsys = getfsstat (stats, bufsize, MNT_NOWAIT);\n<line274>if (numsys < 0)\n<line275>{\n<line276>free (stats);\n<line277>return NULL;\n<line278>}\n<line279>for (counter = 0; counter < numsys; counter++)\n<line280>{\n<line281>me = xmalloc (sizeof *me);\n<line282>me->me_devname = xstrdup (stats[counter].f_mntfromname);\n<line283>me->me_mountdir = xstrdup (stats[counter].f_mntonname);\n<line284>me->me_mntroot = NULL;\n<line285>me->me_type = xstrdup (FS_TYPE (stats[counter]));\n<line286>me->me_type_malloced = 1;\n<line287>me->me_dummy = ME_DUMMY (me->me_devname, me->me_type);\n<line288>me->me_remote = ME_REMOTE (me->me_devname, me->me_type);\n<line289>me->me_dev = (dev_t) -1;        /* Magic; means not known yet. */\n<line290>/* Add to the linked list. */\n<line291>*mtail = me;\n<line292>mtail = &me->me_next;\n<line293>}\n<line294>free (stats);\n<line295>}\n<line296>#endif /* MOUNTED_GETFSSTAT */\n<line297>#if defined MOUNTED_FREAD_FSTYP /* (obsolete) SVR3 */\n<line298>{\n<line299>struct mnttab mnt;\n<line300>char *table = "/etc/mnttab";\n<line301>FILE *fp;\n<line302>fp = fopen (table, "re");\n<line303>if (fp == NULL)\n<line304>return NULL;\n<line305>while (fread (&mnt, sizeof mnt, 1, fp) > 0)\n<line306>{\n<line307>me = xmalloc (sizeof *me);\n<line308>me->me_devname = xstrdup (mnt.mt_dev);\n<line309>me->me_mountdir = xstrdup (mnt.mt_filsys);\n<line310>me->me_mntroot = NULL;\n<line311>me->me_dev = (dev_t) -1;        /* Magic; means not known yet. */\n<line312>me->me_type = "";\n<line313>me->me_type_malloced = 0;\n<line314>if (need_fs_type)\n<line315>{\n<line316>struct statfs fsd;\n<line317>char typebuf[FSTYPSZ];\n<line318>if (statfs (me->me_mountdir, &fsd, sizeof fsd, 0) != -1\n<line319>&& sysfs (GETFSTYP, fsd.f_fstyp, typebuf) != -1)\n<line320>{\n<line321>me->me_type = xstrdup (typebuf);\n<line322>me->me_type_malloced = 1;\n<line323>}\n<line324>}\n<line325>me->me_dummy = ME_DUMMY (me->me_devname, me->me_type);\n<line326>me->me_remote = ME_REMOTE (me->me_devname, me->me_type);\n<line327>/* Add to the linked list. */\n<line328>*mtail = me;\n<line329>mtail = &me->me_next;\n<line330>}\n<line331>if (ferror (fp))\n<line332>{\n<line333>/* The last fread() call must have failed.  */\n<line334>int saved_errno = errno;\n<line335>fclose (fp);\n<line336>errno = saved_errno;\n<line337>goto free_then_fail;\n<line338>}\n<line339>if (fclose (fp) == EOF)\n<line340>goto free_then_fail;\n<line341>}\n<line342>#endif /* MOUNTED_FREAD_FSTYP.  */\n<line343>#ifdef MOUNTED_GETEXTMNTENT     /* Solaris >= 8 */\n<line344>{\n<line345>struct extmnttab mnt;\n<line346>const char *table = MNTTAB;\n<line347>FILE *fp;\n<line348>int ret;\n<line349>/* No locking is needed, because the contents of /etc/mnttab is generated\n<line350>by the kernel.  */\n<line351>errno = 0;\n<line352>fp = fopen (table, "re");\n<line353>if (fp == NULL)\n<line354>ret = errno;\n<line355>else\n<line356>{\n<line357>while ((ret = getextmntent (fp, &mnt, 1)) == 0)\n<line358>{\n<line359>me = xmalloc (sizeof *me);\n<line360>me->me_devname = xstrdup (mnt.mnt_special);\n<line361>me->me_mountdir = xstrdup (mnt.mnt_mountp);\n<line362>me->me_mntroot = NULL;\n<line363>me->me_type = xstrdup (mnt.mnt_fstype);\n<line364>me->me_type_malloced = 1;\n<line365>me->me_dummy = MNT_IGNORE (&mnt) != 0;\n<line366>me->me_remote = ME_REMOTE (me->me_devname, me->me_type);\n<line367>me->me_dev = makedev (mnt.mnt_major, mnt.mnt_minor);\n<line368>/* Add to the linked list. */\n<line369>*mtail = me;\n<line370>mtail = &me->me_next;\n<line371>}\n<line372>ret = fclose (fp) == EOF ? errno : 0 < ret ? 0 : -1;\n<line373>/* Here ret = -1 means success, ret >= 0 means failure.  */\n<line374>}\n<line375>if (0 <= ret)\n<line376>{\n<line377>errno = ret;\n<line378>goto free_then_fail;\n<line379>}\n<line380>}\n<line381>#endif /* MOUNTED_GETEXTMNTENT */\n<line382>#ifdef MOUNTED_GETMNTENT2       /* Solaris < 8, also (obsolete) SVR4 */\n<line383>{\n<line384>struct mnttab mnt;\n<line385>const char *table = MNTTAB;\n<line386>FILE *fp;\n<line387>int ret;\n<line388>int lockfd = -1;\n<line389># if defined F_RDLCK && defined F_SETLKW\n<line390>/* MNTTAB_LOCK is a macro name of our own invention; it's not present in\n<line391>e.g. Solaris 2.6.  If the SVR4 folks ever define a macro\n<line392>for this file name, we should use their macro name instead.\n<line393>(Why not just lock MNTTAB directly?  We don't know.)  */\n<line394>#  ifndef MNTTAB_LOCK\n<line395>#   define MNTTAB_LOCK "/etc/.mnttab.lock"\n<line396>#  endif\n<line397>lockfd = open (MNTTAB_LOCK, O_RDONLY | O_CLOEXEC);\n<line398>if (0 <= lockfd)\n<line399>{\n<line400>struct flock flock;\n<line401>flock.l_type = F_RDLCK;\n<line402>flock.l_whence = SEEK_SET;\n<line403>flock.l_start = 0;\n<line404>flock.l_len = 0;\n<line405>while (fcntl (lockfd, F_SETLKW, &flock) == -1)\n<line406>if (errno != EINTR)\n<line407>{\n<line408>int saved_errno = errno;\n<line409>close (lockfd);\n<line410>errno = saved_errno;\n<line411>return NULL;\n<line412>}\n<line413>}\n<line414>else if (errno != ENOENT)\n<line415>return NULL;\n<line416># endif\n<line417>errno = 0;\n<line418>fp = fopen (table, "re");\n<line419>if (fp == NULL)\n<line420>ret = errno;\n<line421>else\n<line422>{\n<line423>while ((ret = getmntent (fp, &mnt)) == 0)\n<line424>{\n<line425>me = xmalloc (sizeof *me);\n<line426>me->me_devname = xstrdup (mnt.mnt_special);\n<line427>me->me_mountdir = xstrdup (mnt.mnt_mountp);\n<line428>me->me_mntroot = NULL;\n<line429>me->me_type = xstrdup (mnt.mnt_fstype);\n<line430>me->me_type_malloced = 1;\n<line431>me->me_dummy = MNT_IGNORE (&mnt) != 0;\n<line432>me->me_remote = ME_REMOTE (me->me_devname, me->me_type);\n<line433>me->me_dev = dev_from_mount_options (mnt.mnt_mntopts);\n<line434>/* Add to the linked list. */\n<line435>*mtail = me;\n<line436>mtail = &me->me_next;\n<line437>}\n<line438>ret = fclose (fp) == EOF ? errno : 0 < ret ? 0 : -1;\n<line439>/* Here ret = -1 means success, ret >= 0 means failure.  */\n<line440>}\n<line441>if (0 <= lockfd && close (lockfd) != 0)\n<line442>ret = errno;\n<line443>if (0 <= ret)\n<line444>{\n<line445>errno = ret;\n<line446>goto free_then_fail;\n<line447>}\n<line448>}\n<line449>#endif /* MOUNTED_GETMNTENT2.  */\n<line450>#ifdef MOUNTED_VMOUNT           /* AIX */\n<line451>{\n<line452>int bufsize;\n<line453>void *entries;\n<line454>char *thisent;\n<line455>struct vmount *vmp;\n<line456>int n_entries;\n<line457>int i;\n<line458>/* Ask how many bytes to allocate for the mounted file system info.  */\n<line459>entries = &bufsize;\n<line460>if (mntctl (MCTL_QUERY, sizeof bufsize, entries) != 0)\n<line461>return NULL;\n<line462>entries = xmalloc (bufsize);\n<line463>/* Get the list of mounted file systems.  */\n<line464>n_entries = mntctl (MCTL_QUERY, bufsize, entries);\n<line465>if (n_entries < 0)\n<line466>{\n<line467>free (entries);\n<line468>return NULL;\n<line469>}\n<line470>for (i = 0, thisent = entries;\n<line471>i < n_entries;\n<line472>i++, thisent += vmp->vmt_length)\n<line473>{\n<line474>char *options, *ignore;\n<line475>vmp = (struct vmount *) thisent;\n<line476>me = xmalloc (sizeof *me);\n<line477>if (vmp->vmt_flags & MNT_REMOTE)\n<line478>{\n<line479>char *host, *dir;\n<line480>me->me_remote = 1;\n<line481>/* Prepend the remote dirname.  */\n<line482>host = thisent + vmp->vmt_data[VMT_HOSTNAME].vmt_off;\n<line483>dir = thisent + vmp->vmt_data[VMT_OBJECT].vmt_off;\n<line484>me->me_devname = xmalloc (strlen (host) + strlen (dir) + 2);\n<line485>strcpy (me->me_devname, host);\n<line486>strcat (me->me_devname, ":");\n<line487>strcat (me->me_devname, dir);\n<line488>}\n<line489>else\n<line490>{\n<line491>me->me_remote = 0;\n<line492>me->me_devname = xstrdup (thisent +\n<line493>vmp->vmt_data[VMT_OBJECT].vmt_off);\n<line494>}\n<line495>me->me_mountdir = xstrdup (thisent + vmp->vmt_data[VMT_STUB].vmt_off);\n<line496>me->me_mntroot = NULL;\n<line497>me->me_type = xstrdup (fstype_to_string (vmp->vmt_gfstype));\n<line498>me->me_type_malloced = 1;\n<line499>options = thisent + vmp->vmt_data[VMT_ARGS].vmt_off;\n<line500>ignore = strstr (options, "ignore");\n<line501>me->me_dummy = (ignore\n<line502>&& (ignore == options || ignore[-1] == ',')\n<line503>&& (ignore[sizeof "ignore" - 1] == ','\n<line504>|| ignore[sizeof "ignore" - 1] == '\0'));\n<line505>me->me_dev = (dev_t) -1; /* vmt_fsid might be the info we want.  */\n<line506>/* Add to the linked list. */\n<line507>*mtail = me;\n<line508>mtail = &me->me_next;\n<line509>}\n<line510>free (entries);\n<line511>}\n<line512>#endif /* MOUNTED_VMOUNT. */\n<line513>#ifdef MOUNTED_INTERIX_STATVFS  /* Interix */\n<line514>{\n<line515>DIR *dirp = opendir ("/dev/fs");\n<line516>char node[9 + NAME_MAX];\n<line517>if (!dirp)\n<line518>goto free_then_fail;\n<line519>while (1)\n<line520>{\n<line521>struct statvfs dev;\n<line522>struct dirent entry;\n<line523>struct dirent *result;\n<line524>/* FIXME: readdir_r is planned to be withdrawn from POSIX and\n<line525>marked obsolescent in glibc.  Use readdir instead.  */\n<line526>if (readdir_r (dirp, &entry, &result) || result == NULL)\n<line527>break;\n<line528>strcpy (node, "/dev/fs/");\n<line529>strcat (node, entry.d_name);\n<line530>if (statvfs (node, &dev) == 0)\n<line531>{\n<line532>me = xmalloc (sizeof *me);\n<line533>me->me_devname = xstrdup (dev.f_mntfromname);\n<line534>me->me_mountdir = xstrdup (dev.f_mntonname);\n<line535>me->me_mntroot = NULL;\n<line536>me->me_type = xstrdup (dev.f_fstypename);\n<line537>me->me_type_malloced = 1;\n<line538>me->me_dummy = ME_DUMMY (me->me_devname, me->me_type);\n<line539>me->me_remote = ME_REMOTE (me->me_devname, me->me_type);\n<line540>me->me_dev = (dev_t) -1;        /* Magic; means not known yet. */\n<line541>/* Add to the linked list. */\n<line542>*mtail = me;\n<line543>mtail = &me->me_next;\n<line544>}\n<line545>}\n<line546>closedir (dirp);\n<line547>}\n<line548>#endif /* MOUNTED_INTERIX_STATVFS */\n<line549>*mtail = NULL;\n<line550>return mount_list;\n<line551>free_then_fail: _GL_UNUSED_LABEL;\n<line552>{\n<line553>int saved_errno = errno;\n<line554>*mtail = NULL;\n<line555>while (mount_list)\n<line556>{\n<line557>me = mount_list->me_next;\n<line558>free_mount_entry (mount_list);\n<line559>mount_list = me;\n<line560>}\n<line561>errno = saved_errno;\n<line562>return NULL;\n<line563>}\n<line564>}
----------------------------------------
Function: free_mount_entry
Content: <line0>void\n<line1>free_mount_entry (struct mount_entry *me)\n<line2>{\n<line3>free (me->me_devname);\n<line4>free (me->me_mountdir);\n<line5>free (me->me_mntroot);\n<line6>if (me->me_type_malloced)\n<line7>free (me->me_type);\n<line8>free (me);\n<line9>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/mpsort.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
Function: mpsort_into_tmp
Content: <line0>static void\n<line1>mpsort_into_tmp (void const **restrict base, size_t n,\n<line2>void const **restrict tmp,\n<line3>comparison_function cmp)\n<line4>{\n<line5>size_t n1 = n / 2;\n<line6>size_t n2 = n - n1;\n<line7>size_t a = 0;\n<line8>size_t alim = n1;\n<line9>size_t b = n1;\n<line10>size_t blim = n;\n<line11>void const *ba;\n<line12>void const *bb;\n<line13>mpsort_with_tmp (base + n1, n2, tmp, cmp);\n<line14>mpsort_with_tmp (base, n1, tmp, cmp);\n<line15>ba = base[a];\n<line16>bb = base[b];\n<line17>for (;;)\n<line18>if (cmp (ba, bb) <= 0)\n<line19>{\n<line20>*tmp++ = ba;\n<line21>a++;\n<line22>if (a == alim)\n<line23>{\n<line24>a = b;\n<line25>alim = blim;\n<line26>break;\n<line27>}\n<line28>ba = base[a];\n<line29>}\n<line30>else\n<line31>{\n<line32>*tmp++ = bb;\n<line33>b++;\n<line34>if (b == blim)\n<line35>break;\n<line36>bb = base[b];\n<line37>}\n<line38>memcpy (tmp, base + a, (alim - a) * sizeof *base);\n<line39>}
----------------------------------------
Function: mpsort_with_tmp
Content: <line0>static void\n<line1>mpsort_with_tmp (void const **restrict base, size_t n,\n<line2>void const **restrict tmp,\n<line3>comparison_function cmp)\n<line4>{\n<line5>if (n <= 2)\n<line6>{\n<line7>if (n == 2)\n<line8>{\n<line9>void const *p0 = base[0];\n<line10>void const *p1 = base[1];\n<line11>if (! (cmp (p0, p1) <= 0))\n<line12>{\n<line13>base[0] = p1;\n<line14>base[1] = p0;\n<line15>}\n<line16>}\n<line17>}\n<line18>else\n<line19>{\n<line20>size_t n1 = n / 2;\n<line21>size_t n2 = n - n1;\n<line22>size_t i;\n<line23>size_t t = 0;\n<line24>size_t tlim = n1;\n<line25>size_t b = n1;\n<line26>size_t blim = n;\n<line27>void const *bb;\n<line28>void const *tt;\n<line29>mpsort_with_tmp (base + n1, n2, tmp, cmp);\n<line30>if (n1 < 2)\n<line31>tmp[0] = base[0];\n<line32>else\n<line33>mpsort_into_tmp (base, n1, tmp, cmp);\n<line34>tt = tmp[t];\n<line35>bb = base[b];\n<line36>for (i = 0; ; )\n<line37>if (cmp (tt, bb) <= 0)\n<line38>{\n<line39>base[i++] = tt;\n<line40>t++;\n<line41>if (t == tlim)\n<line42>break;\n<line43>tt = tmp[t];\n<line44>}\n<line45>else\n<line46>{\n<line47>base[i++] = bb;\n<line48>b++;\n<line49>if (b == blim)\n<line50>{\n<line51>memcpy (base + i, tmp + t, (tlim - t) * sizeof *base);\n<line52>break;\n<line53>}\n<line54>bb = base[b];\n<line55>}\n<line56>}\n<line57>}
----------------------------------------
Function: mpsort
Content: <line0>void\n<line1>mpsort (void const **base, size_t n, comparison_function cmp)\n<line2>{\n<line3>mpsort_with_tmp (base, n, base + n, cmp);\n<line4>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/nanosleep.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
/home/huihui/Downloads/coreutils-9.4/lib/nanosleep.c:60:61: warning: '_Static_assert' with no message is a C2x extension [-Wc2x-extensions]
    static_assert (TYPE_MAXIMUM (time_t) / 24 / 24 / 60 / 60);
                                                            ^
                                                            , ""
2 warnings generated.
Function: rpl_nanosleep
Content: <line0>int\n<line1>nanosleep (const struct timespec *requested_delay,\n<line2>struct timespec *remaining_delay)\n<line3># undef nanosleep\n<line4>{\n<line5>/* nanosleep mishandles large sleeps due to internal overflow problems.\n<line6>The worst known case of this is Linux 2.6.9 with glibc 2.3.4, which\n<line7>can't sleep more than 24.85 days (2^31 milliseconds).  Similarly,\n<line8>cygwin 1.5.x, which can't sleep more than 49.7 days (2^32 milliseconds).\n<line9>Solve this by breaking the sleep up into smaller chunks.  */\n<line10>if (requested_delay->tv_nsec < 0 || BILLION <= requested_delay->tv_nsec)\n<line11>{\n<line12>errno = EINVAL;\n<line13>return -1;\n<line14>}\n<line15>{\n<line16>/* Verify that time_t is large enough.  */\n<line17>static_assert (TYPE_MAXIMUM (time_t) / 24 / 24 / 60 / 60);\n<line18>const time_t limit = 24 * 24 * 60 * 60;\n<line19>time_t seconds = requested_delay->tv_sec;\n<line20>struct timespec intermediate = *requested_delay;\n<line21>while (limit < seconds)\n<line22>{\n<line23>int result;\n<line24>intermediate.tv_sec = limit;\n<line25>result = nanosleep (&intermediate, remaining_delay);\n<line26>seconds -= limit;\n<line27>if (result)\n<line28>{\n<line29>if (remaining_delay)\n<line30>remaining_delay->tv_sec += seconds;\n<line31>return result;\n<line32>}\n<line33>intermediate.tv_nsec = 0;\n<line34>}\n<line35>intermediate.tv_sec = seconds;\n<line36>return nanosleep (&intermediate, remaining_delay);\n<line37>}\n<line38>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/nproc.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
Function: num_processors_via_affinity_mask
Content: <line0>static unsigned long\n<line1>num_processors_via_affinity_mask (void)\n<line2>{\n<line3>/* glibc >= 2.3.3 with NPTL and NetBSD 5 have pthread_getaffinity_np,\n<line4>but with different APIs.  Also it requires linking with -lpthread.\n<line5>Therefore this code is not enabled.\n<line6>glibc >= 2.3.4 has sched_getaffinity whereas NetBSD 5 has\n<line7>sched_getaffinity_np.  */\n<line8>#if HAVE_PTHREAD_GETAFFINITY_NP && defined __GLIBC__ && 0\n<line9>{\n<line10>cpu_set_t set;\n<line11>if (pthread_getaffinity_np (pthread_self (), sizeof (set), &set) == 0)\n<line12>{\n<line13>unsigned long count;\n<line14># ifdef CPU_COUNT\n<line15>/* glibc >= 2.6 has the CPU_COUNT macro.  */\n<line16>count = CPU_COUNT (&set);\n<line17># else\n<line18>size_t i;\n<line19>count = 0;\n<line20>for (i = 0; i < CPU_SETSIZE; i++)\n<line21>if (CPU_ISSET (i, &set))\n<line22>count++;\n<line23># endif\n<line24>if (count > 0)\n<line25>return count;\n<line26>}\n<line27>}\n<line28>#elif HAVE_PTHREAD_GETAFFINITY_NP && defined __NetBSD__ && 0\n<line29>{\n<line30>cpuset_t *set;\n<line31>set = cpuset_create ();\n<line32>if (set != NULL)\n<line33>{\n<line34>unsigned long count = 0;\n<line35>if (pthread_getaffinity_np (pthread_self (), cpuset_size (set), set)\n<line36>== 0)\n<line37>{\n<line38>cpuid_t i;\n<line39>for (i = 0;; i++)\n<line40>{\n<line41>int ret = cpuset_isset (i, set);\n<line42>if (ret < 0)\n<line43>break;\n<line44>if (ret > 0)\n<line45>count++;\n<line46>}\n<line47>}\n<line48>cpuset_destroy (set);\n<line49>if (count > 0)\n<line50>return count;\n<line51>}\n<line52>}\n<line53>#elif HAVE_SCHED_GETAFFINITY_LIKE_GLIBC /* glibc >= 2.3.4 */\n<line54>{\n<line55>cpu_set_t set;\n<line56>if (sched_getaffinity (0, sizeof (set), &set) == 0)\n<line57>{\n<line58>unsigned long count;\n<line59># ifdef CPU_COUNT\n<line60>/* glibc >= 2.6 has the CPU_COUNT macro.  */\n<line61>count = CPU_COUNT (&set);\n<line62># else\n<line63>size_t i;\n<line64>count = 0;\n<line65>for (i = 0; i < CPU_SETSIZE; i++)\n<line66>if (CPU_ISSET (i, &set))\n<line67>count++;\n<line68># endif\n<line69>if (count > 0)\n<line70>return count;\n<line71>}\n<line72>}\n<line73>#elif HAVE_SCHED_GETAFFINITY_NP /* NetBSD >= 5 */\n<line74>{\n<line75>cpuset_t *set;\n<line76>set = cpuset_create ();\n<line77>if (set != NULL)\n<line78>{\n<line79>unsigned long count = 0;\n<line80>if (sched_getaffinity_np (getpid (), cpuset_size (set), set) == 0)\n<line81>{\n<line82>cpuid_t i;\n<line83>for (i = 0;; i++)\n<line84>{\n<line85>int ret = cpuset_isset (i, set);\n<line86>if (ret < 0)\n<line87>break;\n<line88>if (ret > 0)\n<line89>count++;\n<line90>}\n<line91>}\n<line92>cpuset_destroy (set);\n<line93>if (count > 0)\n<line94>return count;\n<line95>}\n<line96>}\n<line97>#endif\n<line98>#if defined _WIN32 && ! defined __CYGWIN__\n<line99>{ /* This works on native Windows platforms.  */\n<line100>DWORD_PTR process_mask;\n<line101>DWORD_PTR system_mask;\n<line102>if (GetProcessAffinityMask (GetCurrentProcess (),\n<line103>&process_mask, &system_mask))\n<line104>{\n<line105>DWORD_PTR mask = process_mask;\n<line106>unsigned long count = 0;\n<line107>for (; mask != 0; mask = mask >> 1)\n<line108>if (mask & 1)\n<line109>count++;\n<line110>if (count > 0)\n<line111>return count;\n<line112>}\n<line113>}\n<line114>#endif\n<line115>return 0;\n<line116>}
----------------------------------------
Function: num_processors_ignoring_omp
Content: <line0>static unsigned long int\n<line1>num_processors_ignoring_omp (enum nproc_query query)\n<line2>{\n<line3>/* On systems with a modern affinity mask system call, we have\n<line4>sysconf (_SC_NPROCESSORS_CONF)\n<line5>>= sysconf (_SC_NPROCESSORS_ONLN)\n<line6>>= num_processors_via_affinity_mask ()\n<line7>The first number is the number of CPUs configured in the system.\n<line8>The second number is the number of CPUs available to the scheduler.\n<line9>The third number is the number of CPUs available to the current process.\n<line10>Note! On Linux systems with glibc, the first and second number come from\n<line11>the /sys and /proc file systems (see\n<line12>glibc/sysdeps/unix/sysv/linux/getsysstats.c).\n<line13>In some situations these file systems are not mounted, and the sysconf call\n<line14>returns 1 or 2 (<https://sourceware.org/bugzilla/show_bug.cgi?id=21542>),\n<line15>which does not reflect the reality.  */\n<line16>if (query == NPROC_CURRENT)\n<line17>{\n<line18>/* Try the modern affinity mask system call.  */\n<line19>{\n<line20>unsigned long nprocs = num_processors_via_affinity_mask ();\n<line21>if (nprocs > 0)\n<line22>return nprocs;\n<line23>}\n<line24>#if defined _SC_NPROCESSORS_ONLN\n<line25>{ /* This works on glibc, Mac OS X 10.5, FreeBSD, AIX, OSF/1, Solaris,\n<line26>Cygwin, Haiku.  */\n<line27>long int nprocs = sysconf (_SC_NPROCESSORS_ONLN);\n<line28>if (nprocs > 0)\n<line29>return nprocs;\n<line30>}\n<line31>#endif\n<line32>}\n<line33>else /* query == NPROC_ALL */\n<line34>{\n<line35>#if defined _SC_NPROCESSORS_CONF\n<line36>{ /* This works on glibc, Mac OS X 10.5, FreeBSD, AIX, OSF/1, Solaris,\n<line37>Cygwin, Haiku.  */\n<line38>long int nprocs = sysconf (_SC_NPROCESSORS_CONF);\n<line39># if __GLIBC__ >= 2 && defined __linux__\n<line40>/* On Linux systems with glibc, this information comes from the /sys and\n<line41>/proc file systems (see glibc/sysdeps/unix/sysv/linux/getsysstats.c).\n<line42>In some situations these file systems are not mounted, and the\n<line43>sysconf call returns 1 or 2.  But we wish to guarantee that\n<line44>num_processors (NPROC_ALL) >= num_processors (NPROC_CURRENT).  */\n<line45>if (nprocs == 1 || nprocs == 2)\n<line46>{\n<line47>unsigned long nprocs_current = num_processors_via_affinity_mask ();\n<line48>if (/* nprocs_current > 0 && */ nprocs_current > nprocs)\n<line49>nprocs = nprocs_current;\n<line50>}\n<line51># endif\n<line52>if (nprocs > 0)\n<line53>return nprocs;\n<line54>}\n<line55>#endif\n<line56>}\n<line57>#if HAVE_PSTAT_GETDYNAMIC\n<line58>{ /* This works on HP-UX.  */\n<line59>struct pst_dynamic psd;\n<line60>if (pstat_getdynamic (&psd, sizeof psd, 1, 0) >= 0)\n<line61>{\n<line62>/* The field psd_proc_cnt contains the number of active processors.\n<line63>In newer releases of HP-UX 11, the field psd_max_proc_cnt includes\n<line64>deactivated processors.  */\n<line65>if (query == NPROC_CURRENT)\n<line66>{\n<line67>if (psd.psd_proc_cnt > 0)\n<line68>return psd.psd_proc_cnt;\n<line69>}\n<line70>else\n<line71>{\n<line72>if (psd.psd_max_proc_cnt > 0)\n<line73>return psd.psd_max_proc_cnt;\n<line74>}\n<line75>}\n<line76>}\n<line77>#endif\n<line78>#if HAVE_SYSMP && defined MP_NAPROCS && defined MP_NPROCS\n<line79>{ /* This works on IRIX.  */\n<line80>/* MP_NPROCS yields the number of installed processors.\n<line81>MP_NAPROCS yields the number of processors available to unprivileged\n<line82>processes.  */\n<line83>int nprocs =\n<line84>sysmp (query == NPROC_CURRENT && getuid () != 0\n<line85>? MP_NAPROCS\n<line86>: MP_NPROCS);\n<line87>if (nprocs > 0)\n<line88>return nprocs;\n<line89>}\n<line90>#endif\n<line91>/* Finally, as fallback, use the APIs that don't distinguish between\n<line92>NPROC_CURRENT and NPROC_ALL.  */\n<line93>#if HAVE_SYSCTL && !(defined __GLIBC__ && defined __linux__) && defined HW_NCPU\n<line94>{ /* This works on macOS, FreeBSD, NetBSD, OpenBSD.\n<line95>macOS 10.14 does not allow mib to be const.  */\n<line96>int nprocs;\n<line97>size_t len = sizeof (nprocs);\n<line98>static int mib[][2] = {\n<line99># ifdef HW_NCPUONLINE\n<line100>{ CTL_HW, HW_NCPUONLINE },\n<line101># endif\n<line102>{ CTL_HW, HW_NCPU }\n<line103>};\n<line104>for (int i = 0; i < ARRAY_SIZE (mib); i++)\n<line105>{\n<line106>if (sysctl (mib[i], ARRAY_SIZE (mib[i]), &nprocs, &len, NULL, 0) == 0\n<line107>&& len == sizeof (nprocs)\n<line108>&& 0 < nprocs)\n<line109>return nprocs;\n<line110>}\n<line111>}\n<line112>#endif\n<line113>#if defined _WIN32 && ! defined __CYGWIN__\n<line114>{ /* This works on native Windows platforms.  */\n<line115>SYSTEM_INFO system_info;\n<line116>GetSystemInfo (&system_info);\n<line117>if (0 < system_info.dwNumberOfProcessors)\n<line118>return system_info.dwNumberOfProcessors;\n<line119>}\n<line120>#endif\n<line121>return 1;\n<line122>}
----------------------------------------
Function: parse_omp_threads
Content: <line0>static unsigned long int\n<line1>parse_omp_threads (char const* threads)\n<line2>{\n<line3>unsigned long int ret = 0;\n<line4>if (threads == NULL)\n<line5>return ret;\n<line6>/* The OpenMP spec says that the value assigned to the environment variables\n<line7>"may have leading and trailing white space".  */\n<line8>while (*threads != '\0' && c_isspace (*threads))\n<line9>threads++;\n<line10>/* Convert it from positive decimal to 'unsigned long'.  */\n<line11>if (c_isdigit (*threads))\n<line12>{\n<line13>char *endptr = NULL;\n<line14>unsigned long int value = strtoul (threads, &endptr, 10);\n<line15>if (endptr != NULL)\n<line16>{\n<line17>while (*endptr != '\0' && c_isspace (*endptr))\n<line18>endptr++;\n<line19>if (*endptr == '\0')\n<line20>return value;\n<line21>/* Also accept the first value in a nesting level,\n<line22>since we can't determine the nesting level from env vars.  */\n<line23>else if (*endptr == ',')\n<line24>return value;\n<line25>}\n<line26>}\n<line27>return ret;\n<line28>}
----------------------------------------
Function: num_processors
Content: <line0>unsigned long int\n<line1>num_processors (enum nproc_query query)\n<line2>{\n<line3>unsigned long int omp_env_limit = ULONG_MAX;\n<line4>if (query == NPROC_CURRENT_OVERRIDABLE)\n<line5>{\n<line6>unsigned long int omp_env_threads;\n<line7>/* Honor the OpenMP environment variables, recognized also by all\n<line8>programs that are based on OpenMP.  */\n<line9>omp_env_threads = parse_omp_threads (getenv ("OMP_NUM_THREADS"));\n<line10>omp_env_limit = parse_omp_threads (getenv ("OMP_THREAD_LIMIT"));\n<line11>if (! omp_env_limit)\n<line12>omp_env_limit = ULONG_MAX;\n<line13>if (omp_env_threads)\n<line14>return MIN (omp_env_threads, omp_env_limit);\n<line15>query = NPROC_CURRENT;\n<line16>}\n<line17>/* Here query is one of NPROC_ALL, NPROC_CURRENT.  */\n<line18>{\n<line19>unsigned long nprocs = num_processors_ignoring_omp (query);\n<line20>return MIN (nprocs, omp_env_limit);\n<line21>}\n<line22>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/nstrftime.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
Function: memcpy_lowcase
Content: <line0>static CHAR_T *\n<line1>memcpy_lowcase (CHAR_T *dest, const CHAR_T *src, size_t len LOCALE_PARAM)\n<line2>{\n<line3>while (len-- > 0)\n<line4>dest[len] = TOLOWER ((UCHAR_T) src[len], loc);\n<line5>return dest;\n<line6>}
----------------------------------------
Function: memcpy_uppcase
Content: <line0>static CHAR_T *\n<line1>memcpy_uppcase (CHAR_T *dest, const CHAR_T *src, size_t len LOCALE_PARAM)\n<line2>{\n<line3>while (len-- > 0)\n<line4>dest[len] = TOUPPER ((UCHAR_T) src[len], loc);\n<line5>return dest;\n<line6>}
----------------------------------------
Function: iso_week_days
Content: <line0>static __inline int\n<line1>iso_week_days (int yday, int wday)\n<line2>{\n<line3>/* Add enough to the first operand of % to make it nonnegative.  */\n<line4>int big_enough_multiple_of_7 = (-YDAY_MINIMUM / 7 + 2) * 7;\n<line5>return (yday\n<line6>- (yday - wday + ISO_WEEK1_WDAY + big_enough_multiple_of_7) % 7\n<line7>+ ISO_WEEK1_WDAY - ISO_WEEK_START_WDAY);\n<line8>}
----------------------------------------
Function: nstrftime
Content: <line0>size_t\n<line1>my_strftime (STREAM_OR_CHAR_T *s, STRFTIME_ARG (size_t maxsize)\n<line2>const CHAR_T *format,\n<line3>const struct tm *tp extra_args_spec LOCALE_PARAM)\n<line4>{\n<line5>bool tzset_called = false;\n<line6>return __strftime_internal (s, STRFTIME_ARG (maxsize) format, tp, false,\n<line7>0, -1, &tzset_called extra_args LOCALE_ARG);\n<line8>}
----------------------------------------
Function: __strftime_internal
Content: <line0>static size_t\n<line1>__strftime_internal (STREAM_OR_CHAR_T *s, STRFTIME_ARG (size_t maxsize)\n<line2>const CHAR_T *format,\n<line3>const struct tm *tp, bool upcase,\n<line4>int yr_spec, int width, bool *tzset_called\n<line5>extra_args_spec LOCALE_PARAM)\n<line6>{\n<line7>#if defined _LIBC && defined USE_IN_EXTENDED_LOCALE_MODEL\n<line8>struct __locale_data *const current = loc->__locales[LC_TIME];\n<line9>#endif\n<line10>#if FPRINTFTIME\n<line11>size_t maxsize = (size_t) -1;\n<line12>#endif\n<line13>int saved_errno = errno;\n<line14>int hour12 = tp->tm_hour;\n<line15>#ifdef _NL_CURRENT\n<line16>/* We cannot make the following values variables since we must delay\n<line17>the evaluation of these values until really needed since some\n<line18>expressions might not be valid in every situation.  The 'struct tm'\n<line19>might be generated by a strptime() call that initialized\n<line20>only a few elements.  Dereference the pointers only if the format\n<line21>requires this.  Then it is ok to fail if the pointers are invalid.  */\n<line22># define a_wkday \\n<line23>((const CHAR_T *) (tp->tm_wday < 0 || tp->tm_wday > 6                      \\n<line24>? "?" : _NL_CURRENT (LC_TIME, NLW(ABDAY_1) + tp->tm_wday)))\n<line25># define f_wkday \\n<line26>((const CHAR_T *) (tp->tm_wday < 0 || tp->tm_wday > 6                      \\n<line27>? "?" : _NL_CURRENT (LC_TIME, NLW(DAY_1) + tp->tm_wday)))\n<line28># define a_month \\n<line29>((const CHAR_T *) (tp->tm_mon < 0 || tp->tm_mon > 11                       \\n<line30>? "?" : _NL_CURRENT (LC_TIME, NLW(ABMON_1) + tp->tm_mon)))\n<line31># define f_month \\n<line32>((const CHAR_T *) (tp->tm_mon < 0 || tp->tm_mon > 11                       \\n<line33>? "?" : _NL_CURRENT (LC_TIME, NLW(MON_1) + tp->tm_mon)))\n<line34># define a_altmonth \\n<line35>((const CHAR_T *) (tp->tm_mon < 0 || tp->tm_mon > 11                       \\n<line36>? "?" : _NL_CURRENT (LC_TIME, NLW(ABALTMON_1) + tp->tm_mon)))\n<line37># define f_altmonth \\n<line38>((const CHAR_T *) (tp->tm_mon < 0 || tp->tm_mon > 11                       \\n<line39>? "?" : _NL_CURRENT (LC_TIME, NLW(ALTMON_1) + tp->tm_mon)))\n<line40># define ampm \\n<line41>((const CHAR_T *) _NL_CURRENT (LC_TIME, tp->tm_hour > 11                    \\n<line42>? NLW(PM_STR) : NLW(AM_STR)))\n<line43># define aw_len STRLEN (a_wkday)\n<line44># define am_len STRLEN (a_month)\n<line45># define aam_len STRLEN (a_altmonth)\n<line46># define ap_len STRLEN (ampm)\n<line47>#endif\n<line48>#if HAVE_TZNAME\n<line49>char **tzname_vec = tzname;\n<line50>#endif\n<line51>const char *zone;\n<line52>size_t i = 0;\n<line53>STREAM_OR_CHAR_T *p = s;\n<line54>const CHAR_T *f;\n<line55>#if DO_MULTIBYTE && !defined COMPILE_WIDE\n<line56>const char *format_end = NULL;\n<line57>#endif\n<line58>zone = NULL;\n<line59>#if HAVE_STRUCT_TM_TM_ZONE\n<line60>/* The POSIX test suite assumes that setting\n<line61>the environment variable TZ to a new value before calling strftime()\n<line62>will influence the result (the %Z format) even if the information in\n<line63>TP is computed with a totally different time zone.\n<line64>This is bogus: though POSIX allows bad behavior like this,\n<line65>POSIX does not require it.  Do the right thing instead.  */\n<line66>zone = (const char *) tp->tm_zone;\n<line67>#endif\n<line68>#if HAVE_TZNAME\n<line69>if (!tz)\n<line70>{\n<line71>if (! (zone && *zone))\n<line72>zone = "GMT";\n<line73>}\n<line74>else\n<line75>{\n<line76># if !HAVE_STRUCT_TM_TM_ZONE\n<line77>/* Infer the zone name from *TZ instead of from TZNAME.  */\n<line78>tzname_vec = tz->tzname_copy;\n<line79># endif\n<line80>}\n<line81>/* The tzset() call might have changed the value.  */\n<line82>if (!(zone && *zone) && tp->tm_isdst >= 0)\n<line83>{\n<line84>/* POSIX.1 requires that local time zone information be used as\n<line85>though strftime called tzset.  */\n<line86># ifndef my_strftime\n<line87>if (!*tzset_called)\n<line88>{\n<line89>tzset ();\n<line90>*tzset_called = true;\n<line91>}\n<line92># endif\n<line93>zone = tzname_vec[tp->tm_isdst != 0];\n<line94>}\n<line95>#endif\n<line96>if (! zone)\n<line97>zone = "";\n<line98>if (hour12 > 12)\n<line99>hour12 -= 12;\n<line100>else\n<line101>if (hour12 == 0)\n<line102>hour12 = 12;\n<line103>for (f = format; *f != '\0'; width = -1, f++)\n<line104>{\n<line105>int pad = 0;  /* Padding for number ('_', '-', '+', '0', or 0).  */\n<line106>int modifier;             /* Field modifier ('E', 'O', or 0).  */\n<line107>int digits = 0;           /* Max digits for numeric format.  */\n<line108>int number_value;         /* Numeric value to be printed.  */\n<line109>unsigned int u_number_value; /* (unsigned int) number_value.  */\n<line110>bool negative_number;     /* The number is negative.  */\n<line111>bool always_output_a_sign; /* +/- should always be output.  */\n<line112>int tz_colon_mask;        /* Bitmask of where ':' should appear.  */\n<line113>const CHAR_T *subfmt;\n<line114>CHAR_T *bufp;\n<line115>CHAR_T buf[1\n<line116>+ 2 /* for the two colons in a %::z or %:::z time zone */\n<line117>+ (sizeof (int) < sizeof (time_t)\n<line118>? INT_STRLEN_BOUND (time_t)\n<line119>: INT_STRLEN_BOUND (int))];\n<line120>bool to_lowcase = false;\n<line121>bool to_uppcase = upcase;\n<line122>size_t colons;\n<line123>bool change_case = false;\n<line124>int format_char;\n<line125>int subwidth;\n<line126>#if DO_MULTIBYTE && !defined COMPILE_WIDE\n<line127>switch (*f)\n<line128>{\n<line129>case L_('%'):\n<line130>break;\n<line131>case L_('\b'): case L_('\t'): case L_('\n'):\n<line132>case L_('\v'): case L_('\f'): case L_('\r'):\n<line133>case L_(' '): case L_('!'): case L_('"'): case L_('#'): case L_('&'):\n<line134>case L_('\''): case L_('('): case L_(')'): case L_('*'): case L_('+'):\n<line135>case L_(','): case L_('-'): case L_('.'): case L_('/'): case L_('0'):\n<line136>case L_('1'): case L_('2'): case L_('3'): case L_('4'): case L_('5'):\n<line137>case L_('6'): case L_('7'): case L_('8'): case L_('9'): case L_(':'):\n<line138>case L_(';'): case L_('<'): case L_('='): case L_('>'): case L_('?'):\n<line139>case L_('A'): case L_('B'): case L_('C'): case L_('D'): case L_('E'):\n<line140>case L_('F'): case L_('G'): case L_('H'): case L_('I'): case L_('J'):\n<line141>case L_('K'): case L_('L'): case L_('M'): case L_('N'): case L_('O'):\n<line142>case L_('P'): case L_('Q'): case L_('R'): case L_('S'): case L_('T'):\n<line143>case L_('U'): case L_('V'): case L_('W'): case L_('X'): case L_('Y'):\n<line144>case L_('Z'): case L_('['): case L_('\\'): case L_(']'): case L_('^'):\n<line145>case L_('_'): case L_('a'): case L_('b'): case L_('c'): case L_('d'):\n<line146>case L_('e'): case L_('f'): case L_('g'): case L_('h'): case L_('i'):\n<line147>case L_('j'): case L_('k'): case L_('l'): case L_('m'): case L_('n'):\n<line148>case L_('o'): case L_('p'): case L_('q'): case L_('r'): case L_('s'):\n<line149>case L_('t'): case L_('u'): case L_('v'): case L_('w'): case L_('x'):\n<line150>case L_('y'): case L_('z'): case L_('{'): case L_('|'): case L_('}'):\n<line151>case L_('~'):\n<line152>/* The C Standard requires these 98 characters (plus '%') to\n<line153>be in the basic execution character set.  None of these\n<line154>characters can start a multibyte sequence, so they need\n<line155>not be analyzed further.  */\n<line156>add1 (*f);\n<line157>continue;\n<line158>default:\n<line159>/* Copy this multibyte sequence until we reach its end, find\n<line160>an error, or come back to the initial shift state.  */\n<line161>{\n<line162>mbstate_t mbstate = mbstate_zero;\n<line163>size_t len = 0;\n<line164>size_t fsize;\n<line165>if (! format_end)\n<line166>format_end = f + strlen (f) + 1;\n<line167>fsize = format_end - f;\n<line168>do\n<line169>{\n<line170>size_t bytes = mbrlen (f + len, fsize - len, &mbstate);\n<line171>if (bytes == 0)\n<line172>break;\n<line173>if (bytes == (size_t) -2)\n<line174>{\n<line175>len += strlen (f + len);\n<line176>break;\n<line177>}\n<line178>if (bytes == (size_t) -1)\n<line179>{\n<line180>len++;\n<line181>break;\n<line182>}\n<line183>len += bytes;\n<line184>}\n<line185>while (! mbsinit (&mbstate));\n<line186>cpy (len, f);\n<line187>f += len - 1;\n<line188>continue;\n<line189>}\n<line190>}\n<line191>#else /* ! DO_MULTIBYTE */\n<line192>/* Either multibyte encodings are not supported, they are\n<line193>safe for formats, so any non-'%' byte can be copied through,\n<line194>or this is the wide character version.  */\n<line195>if (*f != L_('%'))\n<line196>{\n<line197>add1 (*f);\n<line198>continue;\n<line199>}\n<line200>#endif /* ! DO_MULTIBYTE */\n<line201>char const *percent = f;\n<line202>/* Check for flags that can modify a format.  */\n<line203>while (1)\n<line204>{\n<line205>switch (*++f)\n<line206>{\n<line207>/* This influences the number formats.  */\n<line208>case L_('_'):\n<line209>case L_('-'):\n<line210>case L_('+'):\n<line211>case L_('0'):\n<line212>pad = *f;\n<line213>continue;\n<line214>/* This changes textual output.  */\n<line215>case L_('^'):\n<line216>to_uppcase = true;\n<line217>continue;\n<line218>case L_('#'):\n<line219>change_case = true;\n<line220>continue;\n<line221>default:\n<line222>break;\n<line223>}\n<line224>break;\n<line225>}\n<line226>if (ISDIGIT (*f))\n<line227>{\n<line228>width = 0;\n<line229>do\n<line230>{\n<line231>if (ckd_mul (&width, width, 10)\n<line232>|| ckd_add (&width, width, *f - L_('0')))\n<line233>width = INT_MAX;\n<line234>++f;\n<line235>}\n<line236>while (ISDIGIT (*f));\n<line237>}\n<line238>/* Check for modifiers.  */\n<line239>switch (*f)\n<line240>{\n<line241>case L_('E'):\n<line242>case L_('O'):\n<line243>modifier = *f++;\n<line244>break;\n<line245>default:\n<line246>modifier = 0;\n<line247>break;\n<line248>}\n<line249>/* Now do the specified format.  */\n<line250>format_char = *f;\n<line251>switch (format_char)\n<line252>{\n<line253>#define DO_NUMBER(d, v) \\n<line254>do                                                                  \\n<line255>{                                                                 \\n<line256>digits = d;                                                     \\n<line257>number_value = v;                                               \\n<line258>goto do_number;                                                 \\n<line259>}                                                                 \\n<line260>while (0)\n<line261>#define DO_SIGNED_NUMBER(d, negative, v) \\n<line262>DO_MAYBE_SIGNED_NUMBER (d, negative, v, do_signed_number)\n<line263>#define DO_YEARISH(d, negative, v) \\n<line264>DO_MAYBE_SIGNED_NUMBER (d, negative, v, do_yearish)\n<line265>#define DO_MAYBE_SIGNED_NUMBER(d, negative, v, label) \\n<line266>do                                                                  \\n<line267>{                                                                 \\n<line268>digits = d;                                                     \\n<line269>negative_number = negative;                                     \\n<line270>u_number_value = v;                                             \\n<line271>goto label;                                                     \\n<line272>}                                                                 \\n<line273>while (0)\n<line274>/* The mask is not what you might think.\n<line275>When the ordinal i'th bit is set, insert a colon\n<line276>before the i'th digit of the time zone representation.  */\n<line277>#define DO_TZ_OFFSET(d, mask, v) \\n<line278>do                                                                  \\n<line279>{                                                                 \\n<line280>digits = d;                                                     \\n<line281>tz_colon_mask = mask;                                           \\n<line282>u_number_value = v;                                             \\n<line283>goto do_tz_offset;                                              \\n<line284>}                                                                 \\n<line285>while (0)\n<line286>#define DO_NUMBER_SPACEPAD(d, v) \\n<line287>do                                                                  \\n<line288>{                                                                 \\n<line289>digits = d;                                                     \\n<line290>number_value = v;                                               \\n<line291>goto do_number_spacepad;                                        \\n<line292>}                                                                 \\n<line293>while (0)\n<line294>case L_('%'):\n<line295>if (f - 1 != percent)\n<line296>goto bad_percent;\n<line297>add1 (*f);\n<line298>break;\n<line299>case L_('a'):\n<line300>if (modifier != 0)\n<line301>goto bad_format;\n<line302>if (change_case)\n<line303>{\n<line304>to_uppcase = true;\n<line305>to_lowcase = false;\n<line306>}\n<line307>#ifdef _NL_CURRENT\n<line308>cpy (aw_len, a_wkday);\n<line309>break;\n<line310>#else\n<line311>goto underlying_strftime;\n<line312>#endif\n<line313>case 'A':\n<line314>if (modifier != 0)\n<line315>goto bad_format;\n<line316>if (change_case)\n<line317>{\n<line318>to_uppcase = true;\n<line319>to_lowcase = false;\n<line320>}\n<line321>#ifdef _NL_CURRENT\n<line322>cpy (STRLEN (f_wkday), f_wkday);\n<line323>break;\n<line324>#else\n<line325>goto underlying_strftime;\n<line326>#endif\n<line327>case L_('b'):\n<line328>case L_('h'):\n<line329>if (change_case)\n<line330>{\n<line331>to_uppcase = true;\n<line332>to_lowcase = false;\n<line333>}\n<line334>if (modifier == L_('E'))\n<line335>goto bad_format;\n<line336>#ifdef _NL_CURRENT\n<line337>if (modifier == L_('O'))\n<line338>cpy (aam_len, a_altmonth);\n<line339>else\n<line340>cpy (am_len, a_month);\n<line341>break;\n<line342>#else\n<line343>goto underlying_strftime;\n<line344>#endif\n<line345>case L_('B'):\n<line346>if (modifier == L_('E'))\n<line347>goto bad_format;\n<line348>if (change_case)\n<line349>{\n<line350>to_uppcase = true;\n<line351>to_lowcase = false;\n<line352>}\n<line353>#ifdef _NL_CURRENT\n<line354>if (modifier == L_('O'))\n<line355>cpy (STRLEN (f_altmonth), f_altmonth);\n<line356>else\n<line357>cpy (STRLEN (f_month), f_month);\n<line358>break;\n<line359>#else\n<line360>goto underlying_strftime;\n<line361>#endif\n<line362>case L_('c'):\n<line363>if (modifier == L_('O'))\n<line364>goto bad_format;\n<line365>#ifdef _NL_CURRENT\n<line366>if (! (modifier == L_('E')\n<line367>&& (*(subfmt =\n<line368>(const CHAR_T *) _NL_CURRENT (LC_TIME,\n<line369>NLW(ERA_D_T_FMT)))\n<line370>!= '\0')))\n<line371>subfmt = (const CHAR_T *) _NL_CURRENT (LC_TIME, NLW(D_T_FMT));\n<line372>#else\n<line373>goto underlying_strftime;\n<line374>#endif\n<line375>subformat:\n<line376>subwidth = -1;\n<line377>subformat_width:\n<line378>{\n<line379>size_t len = __strftime_internal (NULL, STRFTIME_ARG ((size_t) -1)\n<line380>subfmt, tp, to_uppcase,\n<line381>pad, subwidth, tzset_called\n<line382>extra_args LOCALE_ARG);\n<line383>add (len, __strftime_internal (p,\n<line384>STRFTIME_ARG (maxsize - i)\n<line385>subfmt, tp, to_uppcase,\n<line386>pad, subwidth, tzset_called\n<line387>extra_args LOCALE_ARG));\n<line388>}\n<line389>break;\n<line390>#if !(defined _NL_CURRENT && HAVE_STRUCT_ERA_ENTRY)\n<line391>underlying_strftime:\n<line392>{\n<line393>/* The relevant information is available only via the\n<line394>underlying strftime implementation, so use that.  */\n<line395>char ufmt[5];\n<line396>char *u = ufmt;\n<line397>char ubuf[1024]; /* enough for any single format in practice */\n<line398>size_t len;\n<line399>/* Make sure we're calling the actual underlying strftime.\n<line400>In some cases, config.h contains something like\n<line401>"#define strftime rpl_strftime".  */\n<line402># ifdef strftime\n<line403>#  undef strftime\n<line404>size_t strftime ();\n<line405># endif\n<line406>/* The space helps distinguish strftime failure from empty\n<line407>output.  */\n<line408>*u++ = ' ';\n<line409>*u++ = '%';\n<line410>if (modifier != 0)\n<line411>*u++ = modifier;\n<line412>*u++ = format_char;\n<line413>*u = '\0';\n<line414>len = strftime (ubuf, sizeof ubuf, ufmt, tp);\n<line415>if (len != 0)\n<line416>cpy (len - 1, ubuf + 1);\n<line417>}\n<line418>break;\n<line419>#endif\n<line420>case L_('C'):\n<line421>if (modifier == L_('E'))\n<line422>{\n<line423>#if HAVE_STRUCT_ERA_ENTRY\n<line424>struct era_entry *era = _nl_get_era_entry (tp HELPER_LOCALE_ARG);\n<line425>if (era)\n<line426>{\n<line427># ifdef COMPILE_WIDE\n<line428>size_t len = __wcslen (era->era_wname);\n<line429>cpy (len, era->era_wname);\n<line430># else\n<line431>size_t len = strlen (era->era_name);\n<line432>cpy (len, era->era_name);\n<line433># endif\n<line434>break;\n<line435>}\n<line436>#else\n<line437>goto underlying_strftime;\n<line438>#endif\n<line439>}\n<line440>{\n<line441>bool negative_year = tp->tm_year < - TM_YEAR_BASE;\n<line442>bool zero_thru_1899 = !negative_year & (tp->tm_year < 0);\n<line443>int century = ((tp->tm_year - 99 * zero_thru_1899) / 100\n<line444>+ TM_YEAR_BASE / 100);\n<line445>DO_YEARISH (2, negative_year, century);\n<line446>}\n<line447>case L_('x'):\n<line448>if (modifier == L_('O'))\n<line449>goto bad_format;\n<line450>#ifdef _NL_CURRENT\n<line451>if (! (modifier == L_('E')\n<line452>&& (*(subfmt =\n<line453>(const CHAR_T *) _NL_CURRENT (LC_TIME, NLW(ERA_D_FMT)))\n<line454>!= L_('\0'))))\n<line455>subfmt = (const CHAR_T *) _NL_CURRENT (LC_TIME, NLW(D_FMT));\n<line456>goto subformat;\n<line457>#else\n<line458>goto underlying_strftime;\n<line459>#endif\n<line460>case L_('D'):\n<line461>if (modifier != 0)\n<line462>goto bad_format;\n<line463>subfmt = L_("%m/%d/%y");\n<line464>goto subformat;\n<line465>case L_('d'):\n<line466>if (modifier == L_('E'))\n<line467>goto bad_format;\n<line468>DO_NUMBER (2, tp->tm_mday);\n<line469>case L_('e'):\n<line470>if (modifier == L_('E'))\n<line471>goto bad_format;\n<line472>DO_NUMBER_SPACEPAD (2, tp->tm_mday);\n<line473>/* All numeric formats set DIGITS and NUMBER_VALUE (or U_NUMBER_VALUE)\n<line474>and then jump to one of these labels.  */\n<line475>do_tz_offset:\n<line476>always_output_a_sign = true;\n<line477>goto do_number_body;\n<line478>do_yearish:\n<line479>if (pad == 0)\n<line480>pad = yr_spec;\n<line481>always_output_a_sign\n<line482>= (pad == L_('+')\n<line483>&& ((digits == 2 ? 99 : 9999) < u_number_value\n<line484>|| digits < width));\n<line485>goto do_maybe_signed_number;\n<line486>do_number_spacepad:\n<line487>if (pad == 0)\n<line488>pad = L_('_');\n<line489>do_number:\n<line490>/* Format NUMBER_VALUE according to the MODIFIER flag.  */\n<line491>negative_number = number_value < 0;\n<line492>u_number_value = number_value;\n<line493>do_signed_number:\n<line494>always_output_a_sign = false;\n<line495>do_maybe_signed_number:\n<line496>tz_colon_mask = 0;\n<line497>do_number_body:\n<line498>/* Format U_NUMBER_VALUE according to the MODIFIER flag.\n<line499>NEGATIVE_NUMBER is nonzero if the original number was\n<line500>negative; in this case it was converted directly to\n<line501>unsigned int (i.e., modulo (UINT_MAX + 1)) without\n<line502>negating it.  */\n<line503>if (modifier == L_('O') && !negative_number)\n<line504>{\n<line505>#ifdef _NL_CURRENT\n<line506>/* Get the locale specific alternate representation of\n<line507>the number.  If none exist NULL is returned.  */\n<line508>const CHAR_T *cp = nl_get_alt_digit (u_number_value\n<line509>HELPER_LOCALE_ARG);\n<line510>if (cp != NULL)\n<line511>{\n<line512>size_t digitlen = STRLEN (cp);\n<line513>if (digitlen != 0)\n<line514>{\n<line515>cpy (digitlen, cp);\n<line516>break;\n<line517>}\n<line518>}\n<line519>#else\n<line520>goto underlying_strftime;\n<line521>#endif\n<line522>}\n<line523>bufp = buf + sizeof (buf) / sizeof (buf[0]);\n<line524>if (negative_number)\n<line525>u_number_value = - u_number_value;\n<line526>do\n<line527>{\n<line528>if (tz_colon_mask & 1)\n<line529>*--bufp = ':';\n<line530>tz_colon_mask >>= 1;\n<line531>*--bufp = u_number_value % 10 + L_('0');\n<line532>u_number_value /= 10;\n<line533>}\n<line534>while (u_number_value != 0 || tz_colon_mask != 0);\n<line535>do_number_sign_and_padding:\n<line536>if (pad == 0)\n<line537>pad = L_('0');\n<line538>if (width < 0)\n<line539>width = digits;\n<line540>{\n<line541>CHAR_T sign_char = (negative_number ? L_('-')\n<line542>: always_output_a_sign ? L_('+')\n<line543>: 0);\n<line544>int numlen = buf + sizeof buf / sizeof buf[0] - bufp;\n<line545>int shortage = width - !!sign_char - numlen;\n<line546>int padding = pad == L_('-') || shortage <= 0 ? 0 : shortage;\n<line547>if (sign_char)\n<line548>{\n<line549>if (pad == L_('_'))\n<line550>{\n<line551>if (p)\n<line552>memset_space (p, padding);\n<line553>i += padding;\n<line554>width -= padding;\n<line555>}\n<line556>width_add1 (0, sign_char);\n<line557>width--;\n<line558>}\n<line559>cpy (numlen, bufp);\n<line560>}\n<line561>break;\n<line562>case L_('F'):\n<line563>if (modifier != 0)\n<line564>goto bad_format;\n<line565>if (pad == 0 && width < 0)\n<line566>{\n<line567>pad = L_('+');\n<line568>subwidth = 4;\n<line569>}\n<line570>else\n<line571>{\n<line572>subwidth = width - 6;\n<line573>if (subwidth < 0)\n<line574>subwidth = 0;\n<line575>}\n<line576>subfmt = L_("%Y-%m-%d");\n<line577>goto subformat_width;\n<line578>case L_('H'):\n<line579>if (modifier == L_('E'))\n<line580>goto bad_format;\n<line581>DO_NUMBER (2, tp->tm_hour);\n<line582>case L_('I'):\n<line583>if (modifier == L_('E'))\n<line584>goto bad_format;\n<line585>DO_NUMBER (2, hour12);\n<line586>case L_('k'):           /* GNU extension.  */\n<line587>if (modifier == L_('E'))\n<line588>goto bad_format;\n<line589>DO_NUMBER_SPACEPAD (2, tp->tm_hour);\n<line590>case L_('l'):           /* GNU extension.  */\n<line591>if (modifier == L_('E'))\n<line592>goto bad_format;\n<line593>DO_NUMBER_SPACEPAD (2, hour12);\n<line594>case L_('j'):\n<line595>if (modifier == L_('E'))\n<line596>goto bad_format;\n<line597>DO_SIGNED_NUMBER (3, tp->tm_yday < -1, tp->tm_yday + 1U);\n<line598>case L_('M'):\n<line599>if (modifier == L_('E'))\n<line600>goto bad_format;\n<line601>DO_NUMBER (2, tp->tm_min);\n<line602>case L_('m'):\n<line603>if (modifier == L_('E'))\n<line604>goto bad_format;\n<line605>DO_SIGNED_NUMBER (2, tp->tm_mon < -1, tp->tm_mon + 1U);\n<line606>#ifndef _LIBC\n<line607>case L_('N'):           /* GNU extension.  */\n<line608>if (modifier == L_('E'))\n<line609>goto bad_format;\n<line610>{\n<line611>int n = ns, ns_digits = 9;\n<line612>if (width <= 0)\n<line613>width = ns_digits;\n<line614>int ndigs = ns_digits;\n<line615>while (width < ndigs || (1 < ndigs && n % 10 == 0))\n<line616>ndigs--, n /= 10;\n<line617>for (int j = ndigs; 0 < j; j--)\n<line618>buf[j - 1] = n % 10 + L_('0'), n /= 10;\n<line619>if (!pad)\n<line620>pad = L_('0');\n<line621>width_cpy (0, ndigs, buf);\n<line622>width_add (width - ndigs, 0, (void) 0);\n<line623>}\n<line624>break;\n<line625>#endif\n<line626>case L_('n'):\n<line627>add1 (L_('\n'));\n<line628>break;\n<line629>case L_('P'):\n<line630>to_lowcase = true;\n<line631>#ifndef _NL_CURRENT\n<line632>format_char = L_('p');\n<line633>#endif\n<line634>FALLTHROUGH;\n<line635>case L_('p'):\n<line636>if (change_case)\n<line637>{\n<line638>to_uppcase = false;\n<line639>to_lowcase = true;\n<line640>}\n<line641>#ifdef _NL_CURRENT\n<line642>cpy (ap_len, ampm);\n<line643>break;\n<line644>#else\n<line645>goto underlying_strftime;\n<line646>#endif\n<line647>case L_('q'):           /* GNU extension.  */\n<line648>DO_SIGNED_NUMBER (1, false, ((tp->tm_mon * 11) >> 5) + 1);\n<line649>case L_('R'):\n<line650>subfmt = L_("%H:%M");\n<line651>goto subformat;\n<line652>case L_('r'):\n<line653>#ifdef _NL_CURRENT\n<line654>if (*(subfmt = (const CHAR_T *) _NL_CURRENT (LC_TIME,\n<line655>NLW(T_FMT_AMPM)))\n<line656>== L_('\0'))\n<line657>subfmt = L_("%I:%M:%S %p");\n<line658>goto subformat;\n<line659>#else\n<line660>goto underlying_strftime;\n<line661>#endif\n<line662>case L_('S'):\n<line663>if (modifier == L_('E'))\n<line664>goto bad_format;\n<line665>DO_NUMBER (2, tp->tm_sec);\n<line666>case L_('s'):           /* GNU extension.  */\n<line667>{\n<line668>struct tm ltm;\n<line669>time_t t;\n<line670>ltm = *tp;\n<line671>ltm.tm_yday = -1;\n<line672>t = mktime_z (tz, &ltm);\n<line673>if (ltm.tm_yday < 0)\n<line674>{\n<line675>errno = EOVERFLOW;\n<line676>return 0;\n<line677>}\n<line678>/* Generate string value for T using time_t arithmetic;\n<line679>this works even if sizeof (long) < sizeof (time_t).  */\n<line680>bufp = buf + sizeof (buf) / sizeof (buf[0]);\n<line681>negative_number = t < 0;\n<line682>do\n<line683>{\n<line684>int d = t % 10;\n<line685>t /= 10;\n<line686>*--bufp = (negative_number ? -d : d) + L_('0');\n<line687>}\n<line688>while (t != 0);\n<line689>digits = 1;\n<line690>always_output_a_sign = false;\n<line691>goto do_number_sign_and_padding;\n<line692>}\n<line693>case L_('X'):\n<line694>if (modifier == L_('O'))\n<line695>goto bad_format;\n<line696>#ifdef _NL_CURRENT\n<line697>if (! (modifier == L_('E')\n<line698>&& (*(subfmt =\n<line699>(const CHAR_T *) _NL_CURRENT (LC_TIME, NLW(ERA_T_FMT)))\n<line700>!= L_('\0'))))\n<line701>subfmt = (const CHAR_T *) _NL_CURRENT (LC_TIME, NLW(T_FMT));\n<line702>goto subformat;\n<line703>#else\n<line704>goto underlying_strftime;\n<line705>#endif\n<line706>case L_('T'):\n<line707>subfmt = L_("%H:%M:%S");\n<line708>goto subformat;\n<line709>case L_('t'):\n<line710>add1 (L_('\t'));\n<line711>break;\n<line712>case L_('u'):\n<line713>DO_NUMBER (1, (tp->tm_wday - 1 + 7) % 7 + 1);\n<line714>case L_('U'):\n<line715>if (modifier == L_('E'))\n<line716>goto bad_format;\n<line717>DO_NUMBER (2, (tp->tm_yday - tp->tm_wday + 7) / 7);\n<line718>case L_('V'):\n<line719>case L_('g'):\n<line720>case L_('G'):\n<line721>if (modifier == L_('E'))\n<line722>goto bad_format;\n<line723>{\n<line724>/* YEAR is a leap year if and only if (tp->tm_year + TM_YEAR_BASE)\n<line725>is a leap year, except that YEAR and YEAR - 1 both work\n<line726>correctly even when (tp->tm_year + TM_YEAR_BASE) would\n<line727>overflow.  */\n<line728>int year = (tp->tm_year\n<line729>+ (tp->tm_year < 0\n<line730>? TM_YEAR_BASE % 400\n<line731>: TM_YEAR_BASE % 400 - 400));\n<line732>int year_adjust = 0;\n<line733>int days = iso_week_days (tp->tm_yday, tp->tm_wday);\n<line734>if (days < 0)\n<line735>{\n<line736>/* This ISO week belongs to the previous year.  */\n<line737>year_adjust = -1;\n<line738>days = iso_week_days (tp->tm_yday + (365 + __isleap (year - 1)),\n<line739>tp->tm_wday);\n<line740>}\n<line741>else\n<line742>{\n<line743>int d = iso_week_days (tp->tm_yday - (365 + __isleap (year)),\n<line744>tp->tm_wday);\n<line745>if (0 <= d)\n<line746>{\n<line747>/* This ISO week belongs to the next year.  */\n<line748>year_adjust = 1;\n<line749>days = d;\n<line750>}\n<line751>}\n<line752>switch (*f)\n<line753>{\n<line754>case L_('g'):\n<line755>{\n<line756>int yy = (tp->tm_year % 100 + year_adjust) % 100;\n<line757>DO_YEARISH (2, false,\n<line758>(0 <= yy\n<line759>? yy\n<line760>: tp->tm_year < -TM_YEAR_BASE - year_adjust\n<line761>? -yy\n<line762>: yy + 100));\n<line763>}\n<line764>case L_('G'):\n<line765>DO_YEARISH (4, tp->tm_year < -TM_YEAR_BASE - year_adjust,\n<line766>(tp->tm_year + (unsigned int) TM_YEAR_BASE\n<line767>+ year_adjust));\n<line768>default:\n<line769>DO_NUMBER (2, days / 7 + 1);\n<line770>}\n<line771>}\n<line772>case L_('W'):\n<line773>if (modifier == L_('E'))\n<line774>goto bad_format;\n<line775>DO_NUMBER (2, (tp->tm_yday - (tp->tm_wday - 1 + 7) % 7 + 7) / 7);\n<line776>case L_('w'):\n<line777>if (modifier == L_('E'))\n<line778>goto bad_format;\n<line779>DO_NUMBER (1, tp->tm_wday);\n<line780>case L_('Y'):\n<line781>if (modifier == L_('E'))\n<line782>{\n<line783>#if HAVE_STRUCT_ERA_ENTRY\n<line784>struct era_entry *era = _nl_get_era_entry (tp HELPER_LOCALE_ARG);\n<line785>if (era)\n<line786>{\n<line787># ifdef COMPILE_WIDE\n<line788>subfmt = era->era_wformat;\n<line789># else\n<line790>subfmt = era->era_format;\n<line791># endif\n<line792>if (pad == 0)\n<line793>pad = yr_spec;\n<line794>goto subformat;\n<line795>}\n<line796>#else\n<line797>goto underlying_strftime;\n<line798>#endif\n<line799>}\n<line800>if (modifier == L_('O'))\n<line801>goto bad_format;\n<line802>DO_YEARISH (4, tp->tm_year < -TM_YEAR_BASE,\n<line803>tp->tm_year + (unsigned int) TM_YEAR_BASE);\n<line804>case L_('y'):\n<line805>if (modifier == L_('E'))\n<line806>{\n<line807>#if HAVE_STRUCT_ERA_ENTRY\n<line808>struct era_entry *era = _nl_get_era_entry (tp HELPER_LOCALE_ARG);\n<line809>if (era)\n<line810>{\n<line811>int delta = tp->tm_year - era->start_date[0];\n<line812>if (pad == 0)\n<line813>pad = yr_spec;\n<line814>DO_NUMBER (2, (era->offset\n<line815>+ delta * era->absolute_direction));\n<line816>}\n<line817>#else\n<line818>goto underlying_strftime;\n<line819>#endif\n<line820>}\n<line821>{\n<line822>int yy = tp->tm_year % 100;\n<line823>if (yy < 0)\n<line824>yy = tp->tm_year < - TM_YEAR_BASE ? -yy : yy + 100;\n<line825>DO_YEARISH (2, false, yy);\n<line826>}\n<line827>case L_('Z'):\n<line828>if (change_case)\n<line829>{\n<line830>to_uppcase = false;\n<line831>to_lowcase = true;\n<line832>}\n<line833>#ifdef COMPILE_WIDE\n<line834>{\n<line835>/* The zone string is always given in multibyte form.  We have\n<line836>to convert it to wide character.  */\n<line837>size_t w = pad == L_('-') || width < 0 ? 0 : width;\n<line838>char const *z = zone;\n<line839>mbstate_t st = {0};\n<line840>size_t len = __mbsrtowcs_l (p, &z, maxsize - i, &st, loc);\n<line841>if (len == (size_t) -1)\n<line842>return 0;\n<line843>size_t incr = len < w ? w : len;\n<line844>if (incr >= maxsize - i)\n<line845>{\n<line846>errno = ERANGE;\n<line847>return 0;\n<line848>}\n<line849>if (p)\n<line850>{\n<line851>if (len < w)\n<line852>{\n<line853>size_t delta = w - len;\n<line854>__wmemmove (p + delta, p, len);\n<line855>wchar_t wc = pad == L_('0') || pad == L_('+') ? L'0' : L' ';\n<line856>wmemset (p, wc, delta);\n<line857>}\n<line858>p += incr;\n<line859>}\n<line860>i += incr;\n<line861>}\n<line862>#else\n<line863>cpy (strlen (zone), zone);\n<line864>#endif\n<line865>break;\n<line866>case L_(':'):\n<line867>/* :, ::, and ::: are valid only just before 'z'.\n<line868>:::: etc. are rejected later.  */\n<line869>for (colons = 1; f[colons] == L_(':'); colons++)\n<line870>continue;\n<line871>if (f[colons] != L_('z'))\n<line872>goto bad_format;\n<line873>f += colons;\n<line874>goto do_z_conversion;\n<line875>case L_('z'):\n<line876>colons = 0;\n<line877>do_z_conversion:\n<line878>if (tp->tm_isdst < 0)\n<line879>break;\n<line880>{\n<line881>int diff;\n<line882>int hour_diff;\n<line883>int min_diff;\n<line884>int sec_diff;\n<line885>#if HAVE_TM_GMTOFF\n<line886>diff = tp->tm_gmtoff;\n<line887>#else\n<line888>if (!tz)\n<line889>diff = 0;\n<line890>else\n<line891>{\n<line892>struct tm gtm;\n<line893>struct tm ltm;\n<line894>time_t lt;\n<line895>/* POSIX.1 requires that local time zone information be used as\n<line896>though strftime called tzset.  */\n<line897># ifndef my_strftime\n<line898>if (!*tzset_called)\n<line899>{\n<line900>tzset ();\n<line901>*tzset_called = true;\n<line902>}\n<line903># endif\n<line904>ltm = *tp;\n<line905>ltm.tm_wday = -1;\n<line906>lt = mktime_z (tz, &ltm);\n<line907>if (ltm.tm_wday < 0 || ! localtime_rz (0, &lt, &gtm))\n<line908>break;\n<line909>diff = tm_diff (&ltm, &gtm);\n<line910>}\n<line911>#endif\n<line912>negative_number = diff < 0 || (diff == 0 && *zone == '-');\n<line913>hour_diff = diff / 60 / 60;\n<line914>min_diff = diff / 60 % 60;\n<line915>sec_diff = diff % 60;\n<line916>switch (colons)\n<line917>{\n<line918>case 0: /* +hhmm */\n<line919>DO_TZ_OFFSET (5, 0, hour_diff * 100 + min_diff);\n<line920>case 1: tz_hh_mm: /* +hh:mm */\n<line921>DO_TZ_OFFSET (6, 04, hour_diff * 100 + min_diff);\n<line922>case 2: tz_hh_mm_ss: /* +hh:mm:ss */\n<line923>DO_TZ_OFFSET (9, 024,\n<line924>hour_diff * 10000 + min_diff * 100 + sec_diff);\n<line925>case 3: /* +hh if possible, else +hh:mm, else +hh:mm:ss */\n<line926>if (sec_diff != 0)\n<line927>goto tz_hh_mm_ss;\n<line928>if (min_diff != 0)\n<line929>goto tz_hh_mm;\n<line930>DO_TZ_OFFSET (3, 0, hour_diff);\n<line931>default:\n<line932>goto bad_format;\n<line933>}\n<line934>}\n<line935>case L_('\0'):          /* GNU extension: % at end of format.  */\n<line936>bad_percent:\n<line937>--f;\n<line938>FALLTHROUGH;\n<line939>default:\n<line940>/* Unknown format; output the format, including the '%',\n<line941>since this is most likely the right thing to do if a\n<line942>multibyte string has been misparsed.  */\n<line943>bad_format:\n<line944>cpy (f - percent + 1, percent);\n<line945>break;\n<line946>}\n<line947>}\n<line948>#if ! FPRINTFTIME\n<line949>if (p && maxsize != 0)\n<line950>*p = L_('\0');\n<line951>#endif\n<line952>errno = saved_errno;\n<line953>return i;\n<line954>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/obstack.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
Function: call_chunkfun
Content: <line0>static void *\n<line1>call_chunkfun (struct obstack *h, size_t size)\n<line2>{\n<line3>if (h->use_extra_arg)\n<line4>return h->chunkfun.extra (h->extra_arg, size);\n<line5>else\n<line6>return h->chunkfun.plain (size);\n<line7>}
----------------------------------------
Function: call_freefun
Content: <line0>static void\n<line1>call_freefun (struct obstack *h, void *old_chunk)\n<line2>{\n<line3>if (h->use_extra_arg)\n<line4>h->freefun.extra (h->extra_arg, old_chunk);\n<line5>else\n<line6>h->freefun.plain (old_chunk);\n<line7>}
----------------------------------------
Function: _obstack_begin_worker
Content: <line0>static int\n<line1>_obstack_begin_worker (struct obstack *h,\n<line2>_OBSTACK_SIZE_T size, _OBSTACK_SIZE_T alignment)\n<line3>{\n<line4>struct _obstack_chunk *chunk; /* points to new chunk */\n<line5>if (alignment == 0)\n<line6>alignment = DEFAULT_ALIGNMENT;\n<line7>if (size == 0)\n<line8>/* Default size is what GNU malloc can fit in a 4096-byte block.  */\n<line9>{\n<line10>/* 12 is sizeof (mhead) and 4 is EXTRA from GNU malloc.\n<line11>Use the values for range checking, because if range checking is off,\n<line12>the extra bytes won't be missed terribly, but if range checking is on\n<line13>and we used a larger request, a whole extra 4096 bytes would be\n<line14>allocated.\n<line15>These number are irrelevant to the new GNU malloc.  I suspect it is\n<line16>less sensitive to the size of the request.  */\n<line17>int extra = ((((12 + DEFAULT_ROUNDING - 1) & ~(DEFAULT_ROUNDING - 1))\n<line18>+ 4 + DEFAULT_ROUNDING - 1)\n<line19>& ~(DEFAULT_ROUNDING - 1));\n<line20>size = 4096 - extra;\n<line21>}\n<line22>h->chunk_size = size;\n<line23>h->alignment_mask = alignment - 1;\n<line24>chunk = h->chunk = call_chunkfun (h, h->chunk_size);\n<line25>if (!chunk)\n<line26>(*obstack_alloc_failed_handler) ();\n<line27>h->next_free = h->object_base = __PTR_ALIGN ((char *) chunk, chunk->contents,\n<line28>alignment - 1);\n<line29>h->chunk_limit = chunk->limit = (char *) chunk + h->chunk_size;\n<line30>chunk->prev = 0;\n<line31>/* The initial chunk now contains no empty object.  */\n<line32>h->maybe_empty_object = 0;\n<line33>h->alloc_failed = 0;\n<line34>return 1;\n<line35>}
----------------------------------------
Function: _obstack_begin
Content: <line0>int\n<line1>_obstack_begin (struct obstack *h,\n<line2>_OBSTACK_SIZE_T size, _OBSTACK_SIZE_T alignment,\n<line3>void *(*chunkfun) (size_t),\n<line4>void (*freefun) (void *))\n<line5>{\n<line6>h->chunkfun.plain = chunkfun;\n<line7>h->freefun.plain = freefun;\n<line8>h->use_extra_arg = 0;\n<line9>return _obstack_begin_worker (h, size, alignment);\n<line10>}
----------------------------------------
Function: _obstack_begin_1
Content: <line0>int\n<line1>_obstack_begin_1 (struct obstack *h,\n<line2>_OBSTACK_SIZE_T size, _OBSTACK_SIZE_T alignment,\n<line3>void *(*chunkfun) (void *, size_t),\n<line4>void (*freefun) (void *, void *),\n<line5>void *arg)\n<line6>{\n<line7>h->chunkfun.extra = chunkfun;\n<line8>h->freefun.extra = freefun;\n<line9>h->extra_arg = arg;\n<line10>h->use_extra_arg = 1;\n<line11>return _obstack_begin_worker (h, size, alignment);\n<line12>}
----------------------------------------
Function: _obstack_newchunk
Content: <line0>void\n<line1>_obstack_newchunk (struct obstack *h, _OBSTACK_SIZE_T length)\n<line2>{\n<line3>struct _obstack_chunk *old_chunk = h->chunk;\n<line4>struct _obstack_chunk *new_chunk = 0;\n<line5>size_t obj_size = h->next_free - h->object_base;\n<line6>char *object_base;\n<line7>/* Compute size for new chunk.  */\n<line8>size_t sum1 = obj_size + length;\n<line9>size_t sum2 = sum1 + h->alignment_mask;\n<line10>size_t new_size = sum2 + (obj_size >> 3) + 100;\n<line11>if (new_size < sum2)\n<line12>new_size = sum2;\n<line13>if (new_size < h->chunk_size)\n<line14>new_size = h->chunk_size;\n<line15>/* Allocate and initialize the new chunk.  */\n<line16>if (obj_size <= sum1 && sum1 <= sum2)\n<line17>new_chunk = call_chunkfun (h, new_size);\n<line18>if (!new_chunk)\n<line19>(*obstack_alloc_failed_handler)();\n<line20>h->chunk = new_chunk;\n<line21>new_chunk->prev = old_chunk;\n<line22>new_chunk->limit = h->chunk_limit = (char *) new_chunk + new_size;\n<line23>/* Compute an aligned object_base in the new chunk */\n<line24>object_base =\n<line25>__PTR_ALIGN ((char *) new_chunk, new_chunk->contents, h->alignment_mask);\n<line26>/* Move the existing object to the new chunk.  */\n<line27>memcpy (object_base, h->object_base, obj_size);\n<line28>/* If the object just copied was the only data in OLD_CHUNK,\n<line29>free that chunk and remove it from the chain.\n<line30>But not if that chunk might contain an empty object.  */\n<line31>if (!h->maybe_empty_object\n<line32>&& (h->object_base\n<line33>== __PTR_ALIGN ((char *) old_chunk, old_chunk->contents,\n<line34>h->alignment_mask)))\n<line35>{\n<line36>new_chunk->prev = old_chunk->prev;\n<line37>call_freefun (h, old_chunk);\n<line38>}\n<line39>h->object_base = object_base;\n<line40>h->next_free = h->object_base + obj_size;\n<line41>/* The new chunk certainly contains no empty object yet.  */\n<line42>h->maybe_empty_object = 0;\n<line43>}
----------------------------------------
Function: _obstack_allocated_p
Content: <line0>int\n<line1>_obstack_allocated_p (struct obstack *h, void *obj)\n<line2>{\n<line3>struct _obstack_chunk *lp;    /* below addr of any objects in this chunk */\n<line4>struct _obstack_chunk *plp;   /* point to previous chunk if any */\n<line5>lp = (h)->chunk;\n<line6>/* We use >= rather than > since the object cannot be exactly at\n<line7>the beginning of the chunk but might be an empty object exactly\n<line8>at the end of an adjacent chunk.  */\n<line9>while (lp != 0 && ((void *) lp >= obj || (void *) (lp)->limit < obj))\n<line10>{\n<line11>plp = lp->prev;\n<line12>lp = plp;\n<line13>}\n<line14>return lp != 0;\n<line15>}
----------------------------------------
Function: _obstack_free
Content: <line0>void\n<line1>_obstack_free (struct obstack *h, void *obj)\n<line2>{\n<line3>struct _obstack_chunk *lp;    /* below addr of any objects in this chunk */\n<line4>struct _obstack_chunk *plp;   /* point to previous chunk if any */\n<line5>lp = h->chunk;\n<line6>/* We use >= because there cannot be an object at the beginning of a chunk.\n<line7>But there can be an empty object at that address\n<line8>at the end of another chunk.  */\n<line9>while (lp != 0 && ((void *) lp >= obj || (void *) (lp)->limit < obj))\n<line10>{\n<line11>plp = lp->prev;\n<line12>call_freefun (h, lp);\n<line13>lp = plp;\n<line14>/* If we switch chunks, we can't tell whether the new current\n<line15>chunk contains an empty object, so assume that it may.  */\n<line16>h->maybe_empty_object = 1;\n<line17>}\n<line18>if (lp)\n<line19>{\n<line20>h->object_base = h->next_free = (char *) (obj);\n<line21>h->chunk_limit = lp->limit;\n<line22>h->chunk = lp;\n<line23>}\n<line24>else if (obj != 0)\n<line25>/* obj is not in any of the chunks! */\n<line26>abort ();\n<line27>}
----------------------------------------
Function: print_and_abort
Content: <line0>static __attribute_noreturn__ void\n<line1>print_and_abort (void)\n<line2>{\n<line3>/* Don't change any of these strings.  Yes, it would be possible to add\n<line4>the newline to the string and use fputs or so.  But this must not\n<line5>happen because the "memory exhausted" message appears in other places\n<line6>like this and the translation should be reused instead of creating\n<line7>a very similar string which requires a separate translation.  */\n<line8>#  ifdef _LIBC\n<line9>(void) __fxprintf (NULL, "%s\n", _("memory exhausted"));\n<line10>#  else\n<line11>fprintf (stderr, "%s\n", _("memory exhausted"));\n<line12>#  endif\n<line13>exit (obstack_exit_failure);\n<line14>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/openat-die.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
In file included from /home/huihui/Downloads/coreutils-9.4/lib/openat-die.c:25:
./lib/error.h:28:3: warning: #include_next in file found relative to primary source file or found by absolute path; will search from start of include path [-Winclude-next-absolute-path]
# include_next <error.h>
  ^
2 warnings generated.
Function: openat_save_fail
Content: <line0>_Noreturn void\n<line1>openat_save_fail (int errnum)\n<line2>{\n<line3>#ifndef GNULIB_LIBPOSIX\n<line4>error (exit_failure, errnum,\n<line5>_("unable to record current working directory"));\n<line6>#endif\n<line7>/* _Noreturn cannot be applied to error, since it returns\n<line8>when its first argument is 0.  To help compilers understand that this\n<line9>function does not return, call abort.  Also, the abort is a\n<line10>safety feature if exit_failure is 0 (which shouldn't happen).  */\n<line11>abort ();\n<line12>}
----------------------------------------
Function: openat_restore_fail
Content: <line0>_Noreturn void\n<line1>openat_restore_fail (int errnum)\n<line2>{\n<line3>#ifndef GNULIB_LIBPOSIX\n<line4>error (exit_failure, errnum,\n<line5>_("failed to return to initial working directory"));\n<line6>#endif\n<line7>/* As above.  */\n<line8>abort ();\n<line9>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/openat-safer.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
Function: openat_safer
Content: <line0>int\n<line1>openat_safer (int fd, char const *file, int flags, ...)\n<line2>{\n<line3>mode_t mode = 0;\n<line4>if (flags & O_CREAT)\n<line5>{\n<line6>va_list ap;\n<line7>va_start (ap, flags);\n<line8>/* We have to use PROMOTED_MODE_T instead of mode_t, otherwise GCC 4\n<line9>creates crashing code when 'mode_t' is smaller than 'int'.  */\n<line10>mode = va_arg (ap, PROMOTED_MODE_T);\n<line11>va_end (ap);\n<line12>}\n<line13>return fd_safer (openat (fd, file, flags, mode));\n<line14>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/opendirat.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
Function: opendirat
Content: <line0>DIR *\n<line1>opendirat (int dir_fd, char const *dir, int extra_flags, int *pnew_fd)\n<line2>{\n<line3>int open_flags = (O_RDONLY | O_CLOEXEC | O_DIRECTORY | O_NOCTTY\n<line4>| O_NONBLOCK | extra_flags);\n<line5>int new_fd = openat (dir_fd, dir, open_flags);\n<line6>if (new_fd < 0)\n<line7>return NULL;\n<line8>DIR *dirp = fdopendir (new_fd);\n<line9>if (dirp)\n<line10>*pnew_fd = new_fd;\n<line11>else\n<line12>{\n<line13>int fdopendir_errno = errno;\n<line14>close (new_fd);\n<line15>errno = fdopendir_errno;\n<line16>}\n<line17>return dirp;\n<line18>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/parse-datetime.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
parse-datetime.y:97:40: warning: '_Static_assert' with no message is a C2x extension [-Wc2x-extensions]
static_assert (TYPE_IS_INTEGER (time_t));
                                       ^
                                       , ""
parse-datetime.y:98:76: warning: '_Static_assert' with no message is a C2x extension [-Wc2x-extensions]
static_assert (!TYPE_SIGNED (time_t) || INTMAX_MIN <= TYPE_MINIMUM (time_t));
                                                                           ^
                                                                           , ""
parse-datetime.y:99:51: warning: '_Static_assert' with no message is a C2x extension [-Wc2x-extensions]
static_assert (TYPE_MAXIMUM (time_t) <= INTMAX_MAX);
                                                  ^
                                                  , ""
parse-datetime.y:1254:41: warning: '_Static_assert' with no message is a C2x extension [-Wc2x-extensions]
  static_assert (TM_YEAR_BASE % 100 == 0);
                                        ^
                                        , ""
5 warnings generated.
Function: time_overflow
Content: <line0>static bool\n<line1>time_overflow (intmax_t n)\n<line2>{\n<line3>return ! ((TYPE_SIGNED (time_t) ? TYPE_MINIMUM (time_t) <= n : 0 <= n)\n<line4>&& n <= TYPE_MAXIMUM (time_t));\n<line5>}
----------------------------------------
Function: to_uchar
Content: <line0>static unsigned char to_uchar (char ch) { return ch; }
----------------------------------------
Function: dbg_printf
Content: <line0>static void _GL_ATTRIBUTE_FORMAT ((__printf__, 1, 2))\n<line1>dbg_printf (char const *msg, ...)\n<line2>{\n<line3>va_list args;\n<line4>/* TODO: use gnulib's 'program_name' instead?  */\n<line5>fputs ("date: ", stderr);\n<line6>va_start (args, msg);\n<line7>vfprintf (stderr, msg, args);\n<line8>va_end (args);\n<line9>}
----------------------------------------
Function: debugging
Content: <line0>static bool\n<line1>debugging (parser_control const *pc)\n<line2>{\n<line3>#ifdef GNULIB_PARSE_DATETIME2\n<line4>return pc->parse_datetime_debug;\n<line5>#else\n<line6>return false;\n<line7>#endif\n<line8>}
----------------------------------------
Function: digits_to_date_time
Content: <line0>static void\n<line1>digits_to_date_time (parser_control *pc, textint text_int)\n<line2>{\n<line3>if (pc->dates_seen && ! pc->year.digits\n<line4>&& ! pc->rels_seen && (pc->times_seen || 2 < text_int.digits))\n<line5>{\n<line6>pc->year_seen = true;\n<line7>pc->year = text_int;\n<line8>}\n<line9>else\n<line10>{\n<line11>if (4 < text_int.digits)\n<line12>{\n<line13>pc->dates_seen++;\n<line14>pc->day = text_int.value % 100;\n<line15>pc->month = (text_int.value / 100) % 100;\n<line16>pc->year.value = text_int.value / 10000;\n<line17>pc->year.digits = text_int.digits - 4;\n<line18>}\n<line19>else\n<line20>{\n<line21>pc->times_seen++;\n<line22>if (text_int.digits <= 2)\n<line23>{\n<line24>pc->hour = text_int.value;\n<line25>pc->minutes = 0;\n<line26>}\n<line27>else\n<line28>{\n<line29>pc->hour = text_int.value / 100;\n<line30>pc->minutes = text_int.value % 100;\n<line31>}\n<line32>pc->seconds = (struct timespec) {0};\n<line33>pc->meridian = MER24;\n<line34>}\n<line35>}\n<line36>}
----------------------------------------
Function: apply_relative_time
Content: <line0>static bool\n<line1>apply_relative_time (parser_control *pc, relative_time rel, int factor)\n<line2>{\n<line3>if (factor < 0\n<line4>? (ckd_sub (&pc->rel.ns, pc->rel.ns, rel.ns)\n<line5>| ckd_sub (&pc->rel.seconds, pc->rel.seconds, rel.seconds)\n<line6>| ckd_sub (&pc->rel.minutes, pc->rel.minutes, rel.minutes)\n<line7>| ckd_sub (&pc->rel.hour, pc->rel.hour, rel.hour)\n<line8>| ckd_sub (&pc->rel.day, pc->rel.day, rel.day)\n<line9>| ckd_sub (&pc->rel.month, pc->rel.month, rel.month)\n<line10>| ckd_sub (&pc->rel.year, pc->rel.year, rel.year))\n<line11>: (ckd_add (&pc->rel.ns, pc->rel.ns, rel.ns)\n<line12>| ckd_add (&pc->rel.seconds, pc->rel.seconds, rel.seconds)\n<line13>| ckd_add (&pc->rel.minutes, pc->rel.minutes, rel.minutes)\n<line14>| ckd_add (&pc->rel.hour, pc->rel.hour, rel.hour)\n<line15>| ckd_add (&pc->rel.day, pc->rel.day, rel.day)\n<line16>| ckd_add (&pc->rel.month, pc->rel.month, rel.month)\n<line17>| ckd_add (&pc->rel.year, pc->rel.year, rel.year)))\n<line18>return false;\n<line19>pc->rels_seen = true;\n<line20>return true;\n<line21>}
----------------------------------------
Function: set_hhmmss
Content: <line0>static void\n<line1>set_hhmmss (parser_control *pc, intmax_t hour, intmax_t minutes,\n<line2>time_t sec, int nsec)\n<line3>{\n<line4>pc->hour = hour;\n<line5>pc->minutes = minutes;\n<line6>pc->seconds = (struct timespec) { .tv_sec = sec, .tv_nsec = nsec };\n<line7>}
----------------------------------------
Function: str_days
Content: <line0>static const char *\n<line1>str_days (parser_control *pc, char *buffer, int n)\n<line2>{\n<line3>/* TODO: use relative_time_table for reverse lookup.  */\n<line4>static char const ordinal_values[][11] = {\n<line5>"last",\n<line6>"this",\n<line7>"next/first",\n<line8>"(SECOND)", /* SECOND is commented out in relative_time_table.  */\n<line9>"third",\n<line10>"fourth",\n<line11>"fifth",\n<line12>"sixth",\n<line13>"seventh",\n<line14>"eight",\n<line15>"ninth",\n<line16>"tenth",\n<line17>"eleventh",\n<line18>"twelfth"\n<line19>};\n<line20>static char const days_values[][4] = {\n<line21>"Sun",\n<line22>"Mon",\n<line23>"Tue",\n<line24>"Wed",\n<line25>"Thu",\n<line26>"Fri",\n<line27>"Sat"\n<line28>};\n<line29>int len;\n<line30>/* Don't add an ordinal prefix if the user didn't specify it\n<line31>(e.g., "this wed" vs "wed").  */\n<line32>if (pc->debug_ordinal_day_seen)\n<line33>{\n<line34>/* Use word description if possible (e.g., -1 = last, 3 = third).  */\n<line35>len = (-1 <= pc->day_ordinal && pc->day_ordinal <= 12\n<line36>? snprintf (buffer, n, "%s", ordinal_values[pc->day_ordinal + 1])\n<line37>: snprintf (buffer, n, "%"PRIdMAX, pc->day_ordinal));\n<line38>}\n<line39>else\n<line40>{\n<line41>buffer[0] = '\0';\n<line42>len = 0;\n<line43>}\n<line44>/* Add the day name */\n<line45>if (0 <= pc->day_number && pc->day_number <= 6 && 0 <= len && len < n)\n<line46>snprintf (buffer + len, n - len, &" %s"[len == 0],\n<line47>days_values[pc->day_number]);\n<line48>else\n<line49>{\n<line50>/* invalid day_number value - should never happen */\n<line51>}\n<line52>return buffer;\n<line53>}
----------------------------------------
Function: time_zone_str
Content: <line0>static char const *\n<line1>time_zone_str (int time_zone, char time_zone_buf[TIME_ZONE_BUFSIZE])\n<line2>{\n<line3>char *p = time_zone_buf;\n<line4>char sign = time_zone < 0 ? '-' : '+';\n<line5>int hour = abs (time_zone / (60 * 60));\n<line6>p += sprintf (time_zone_buf, "%c%02d", sign, hour);\n<line7>int offset_from_hour = abs (time_zone % (60 * 60));\n<line8>if (offset_from_hour != 0)\n<line9>{\n<line10>int mm = offset_from_hour / 60;\n<line11>int ss = offset_from_hour % 60;\n<line12>*p++ = ':';\n<line13>*p++ = '0' + mm / 10;\n<line14>*p++ = '0' + mm % 10;\n<line15>if (ss)\n<line16>{\n<line17>*p++ = ':';\n<line18>*p++ = '0' + ss / 10;\n<line19>*p++ = '0' + ss % 10;\n<line20>}\n<line21>*p = '\0';\n<line22>}\n<line23>return time_zone_buf;\n<line24>}
----------------------------------------
Function: debug_print_current_time
Content: <line0>static void\n<line1>debug_print_current_time (char const *item, parser_control *pc)\n<line2>{\n<line3>bool space = false;\n<line4>if (!debugging (pc))\n<line5>return;\n<line6>/* no newline, more items printed below */\n<line7>dbg_printf (_("parsed %s part: "), item);\n<line8>if (pc->dates_seen && !pc->debug_dates_seen)\n<line9>{\n<line10>/*TODO: use pc->year.negative?  */\n<line11>fprintf (stderr, "(Y-M-D) %04"PRIdMAX"-%02"PRIdMAX"-%02"PRIdMAX,\n<line12>pc->year.value, pc->month, pc->day);\n<line13>pc->debug_dates_seen = true;\n<line14>space = true;\n<line15>}\n<line16>if (pc->year_seen != pc->debug_year_seen)\n<line17>{\n<line18>if (space)\n<line19>fputc (' ', stderr);\n<line20>fprintf (stderr, _("year: %04"PRIdMAX), pc->year.value);\n<line21>pc->debug_year_seen = pc->year_seen;\n<line22>space = true;\n<line23>}\n<line24>if (pc->times_seen && !pc->debug_times_seen)\n<line25>{\n<line26>intmax_t sec = pc->seconds.tv_sec;\n<line27>fprintf (stderr, &" %02"PRIdMAX":%02"PRIdMAX":%02"PRIdMAX[!space],\n<line28>pc->hour, pc->minutes, sec);\n<line29>if (pc->seconds.tv_nsec != 0)\n<line30>{\n<line31>int nsec = pc->seconds.tv_nsec;\n<line32>fprintf (stderr, ".%09d", nsec);\n<line33>}\n<line34>if (pc->meridian == MERpm)\n<line35>fputs ("pm", stderr);\n<line36>pc->debug_times_seen = true;\n<line37>space = true;\n<line38>}\n<line39>if (pc->days_seen && !pc->debug_days_seen)\n<line40>{\n<line41>if (space)\n<line42>fputc (' ', stderr);\n<line43>char tmp[DBGBUFSIZE];\n<line44>fprintf (stderr, _("%s (day ordinal=%"PRIdMAX" number=%d)"),\n<line45>str_days (pc, tmp, sizeof tmp),\n<line46>pc->day_ordinal, pc->day_number);\n<line47>pc->debug_days_seen = true;\n<line48>space = true;\n<line49>}\n<line50>/* local zone strings only change the DST settings,\n<line51>not the timezone value.  If seen, inform about the DST.  */\n<line52>if (pc->local_zones_seen && !pc->debug_local_zones_seen)\n<line53>{\n<line54>fprintf (stderr, &" isdst=%d%s"[!space],\n<line55>pc->local_isdst, pc->dsts_seen ? " DST" : "");\n<line56>pc->debug_local_zones_seen = true;\n<line57>space = true;\n<line58>}\n<line59>if (pc->zones_seen && !pc->debug_zones_seen)\n<line60>{\n<line61>char time_zone_buf[TIME_ZONE_BUFSIZE];\n<line62>fprintf (stderr, &" UTC%s"[!space],\n<line63>time_zone_str (pc->time_zone, time_zone_buf));\n<line64>pc->debug_zones_seen = true;\n<line65>space = true;\n<line66>}\n<line67>if (pc->timespec_seen)\n<line68>{\n<line69>intmax_t sec = pc->seconds.tv_sec;\n<line70>if (space)\n<line71>fputc (' ', stderr);\n<line72>fprintf (stderr, _("number of seconds: %"PRIdMAX), sec);\n<line73>}\n<line74>fputc ('\n', stderr);\n<line75>}
----------------------------------------
Function: print_rel_part
Content: <line0>static bool\n<line1>print_rel_part (bool space, intmax_t val, char const *name)\n<line2>{\n<line3>if (val == 0)\n<line4>return space;\n<line5>fprintf (stderr, &" %+"PRIdMAX" %s"[!space], val, name);\n<line6>return true;\n<line7>}
----------------------------------------
Function: debug_print_relative_time
Content: <line0>static void\n<line1>debug_print_relative_time (char const *item, parser_control const *pc)\n<line2>{\n<line3>bool space = false;\n<line4>if (!debugging (pc))\n<line5>return;\n<line6>/* no newline, more items printed below */\n<line7>dbg_printf (_("parsed %s part: "), item);\n<line8>if (pc->rel.year == 0 && pc->rel.month == 0 && pc->rel.day == 0\n<line9>&& pc->rel.hour == 0 && pc->rel.minutes == 0 && pc->rel.seconds == 0\n<line10>&& pc->rel.ns == 0)\n<line11>{\n<line12>/* Special case: relative time of this/today/now */\n<line13>fputs (_("today/this/now\n"), stderr);\n<line14>return;\n<line15>}\n<line16>space = print_rel_part (space, pc->rel.year, "year(s)");\n<line17>space = print_rel_part (space, pc->rel.month, "month(s)");\n<line18>space = print_rel_part (space, pc->rel.day, "day(s)");\n<line19>space = print_rel_part (space, pc->rel.hour, "hour(s)");\n<line20>space = print_rel_part (space, pc->rel.minutes, "minutes");\n<line21>space = print_rel_part (space, pc->rel.seconds, "seconds");\n<line22>print_rel_part (space, pc->rel.ns, "nanoseconds");\n<line23>fputc ('\n', stderr);\n<line24>}
----------------------------------------
Function: yydestruct
Content: <line0>static void\n<line1>yydestruct (const char *yymsg,\n<line2>yysymbol_kind_t yykind, YYSTYPE *yyvaluep, parser_control *pc)\n<line3>{\n<line4>YY_USE (yyvaluep);\n<line5>YY_USE (pc);\n<line6>if (!yymsg)\n<line7>yymsg = "Deleting";\n<line8>YY_SYMBOL_PRINT (yymsg, yykind, yyvaluep, yylocationp);\n<line9>YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN\n<line10>YY_USE (yykind);\n<line11>YY_IGNORE_MAYBE_UNINITIALIZED_END\n<line12>}
----------------------------------------
Function: yyparse
Content: <line0>int\n<line1>yyparse (parser_control *pc)\n<line2>{\n<line3>/* Lookahead token kind.  */\n<line4>int yychar;\n<line5>/* The semantic value of the lookahead symbol.  */\n<line6>/* Default value used for initialization, for pacifying older GCCs\n<line7>or non-GCC compilers.  */\n<line8>YY_INITIAL_VALUE (static YYSTYPE yyval_default;)\n<line9>YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);\n<line10>/* Number of syntax errors so far.  */\n<line11>int yynerrs = 0;\n<line12>yy_state_fast_t yystate = 0;\n<line13>/* Number of tokens to shift before error messages enabled.  */\n<line14>int yyerrstatus = 0;\n<line15>/* Refer to the stacks through separate pointers, to allow yyoverflow\n<line16>to reallocate them elsewhere.  */\n<line17>/* Their size.  */\n<line18>YYPTRDIFF_T yystacksize = YYINITDEPTH;\n<line19>/* The state stack: array, bottom, top.  */\n<line20>yy_state_t yyssa[YYINITDEPTH];\n<line21>yy_state_t *yyss = yyssa;\n<line22>yy_state_t *yyssp = yyss;\n<line23>/* The semantic value stack: array, bottom, top.  */\n<line24>YYSTYPE yyvsa[YYINITDEPTH];\n<line25>YYSTYPE *yyvs = yyvsa;\n<line26>YYSTYPE *yyvsp = yyvs;\n<line27>int yyn;\n<line28>/* The return value of yyparse.  */\n<line29>int yyresult;\n<line30>/* Lookahead symbol kind.  */\n<line31>yysymbol_kind_t yytoken = YYSYMBOL_YYEMPTY;\n<line32>/* The variables used to return semantic value and location from the\n<line33>action routines.  */\n<line34>YYSTYPE yyval;\n<line35>#define YYPOPSTACK(N)   (yyvsp -= (N), yyssp -= (N))\n<line36>/* The number of symbols on the RHS of the reduced rule.\n<line37>Keep to zero when no symbol should be popped.  */\n<line38>int yylen = 0;\n<line39>YYDPRINTF ((stderr, "Starting parse\n"));\n<line40>yychar = YYEMPTY; /* Cause a token to be read.  */\n<line41>goto yysetstate;\n<line42>/*------------------------------------------------------------.\n<line43>| yynewstate -- push a new state, which is found in yystate.  |\n<line44>`------------------------------------------------------------*/\n<line45>yynewstate:\n<line46>/* In all cases, when you get here, the value and location stacks\n<line47>have just been pushed.  So pushing a state here evens the stacks.  */\n<line48>yyssp++;\n<line49>/*--------------------------------------------------------------------.\n<line50>| yysetstate -- set current state (the top of the stack) to yystate.  |\n<line51>`--------------------------------------------------------------------*/\n<line52>yysetstate:\n<line53>YYDPRINTF ((stderr, "Entering state %d\n", yystate));\n<line54>YY_ASSERT (0 <= yystate && yystate < YYNSTATES);\n<line55>YY_IGNORE_USELESS_CAST_BEGIN\n<line56>*yyssp = YY_CAST (yy_state_t, yystate);\n<line57>YY_IGNORE_USELESS_CAST_END\n<line58>YY_STACK_PRINT (yyss, yyssp);\n<line59>if (yyss + yystacksize - 1 <= yyssp)\n<line60>#if !defined yyoverflow && !defined YYSTACK_RELOCATE\n<line61>YYNOMEM;\n<line62>#else\n<line63>{\n<line64>/* Get the current used size of the three stacks, in elements.  */\n<line65>YYPTRDIFF_T yysize = yyssp - yyss + 1;\n<line66># if defined yyoverflow\n<line67>{\n<line68>/* Give user a chance to reallocate the stack.  Use copies of\n<line69>these so that the &'s don't force the real ones into\n<line70>memory.  */\n<line71>yy_state_t *yyss1 = yyss;\n<line72>YYSTYPE *yyvs1 = yyvs;\n<line73>/* Each stack pointer address is followed by the size of the\n<line74>data in use in that stack, in bytes.  This used to be a\n<line75>conditional around just the two extra args, but that might\n<line76>be undefined if yyoverflow is a macro.  */\n<line77>yyoverflow (YY_("memory exhausted"),\n<line78>&yyss1, yysize * YYSIZEOF (*yyssp),\n<line79>&yyvs1, yysize * YYSIZEOF (*yyvsp),\n<line80>&yystacksize);\n<line81>yyss = yyss1;\n<line82>yyvs = yyvs1;\n<line83>}\n<line84># else /* defined YYSTACK_RELOCATE */\n<line85>/* Extend the stack our own way.  */\n<line86>if (YYMAXDEPTH <= yystacksize)\n<line87>YYNOMEM;\n<line88>yystacksize *= 2;\n<line89>if (YYMAXDEPTH < yystacksize)\n<line90>yystacksize = YYMAXDEPTH;\n<line91>{\n<line92>yy_state_t *yyss1 = yyss;\n<line93>union yyalloc *yyptr =\n<line94>YY_CAST (union yyalloc *,\n<line95>YYSTACK_ALLOC (YY_CAST (YYSIZE_T, YYSTACK_BYTES (yystacksize))));\n<line96>if (! yyptr)\n<line97>YYNOMEM;\n<line98>YYSTACK_RELOCATE (yyss_alloc, yyss);\n<line99>YYSTACK_RELOCATE (yyvs_alloc, yyvs);\n<line100>#  undef YYSTACK_RELOCATE\n<line101>if (yyss1 != yyssa)\n<line102>YYSTACK_FREE (yyss1);\n<line103>}\n<line104># endif\n<line105>yyssp = yyss + yysize - 1;\n<line106>yyvsp = yyvs + yysize - 1;\n<line107>YY_IGNORE_USELESS_CAST_BEGIN\n<line108>YYDPRINTF ((stderr, "Stack size increased to %ld\n",\n<line109>YY_CAST (long, yystacksize)));\n<line110>YY_IGNORE_USELESS_CAST_END\n<line111>if (yyss + yystacksize - 1 <= yyssp)\n<line112>YYABORT;\n<line113>}\n<line114>#endif /* !defined yyoverflow && !defined YYSTACK_RELOCATE */\n<line115>if (yystate == YYFINAL)\n<line116>YYACCEPT;\n<line117>goto yybackup;\n<line118>/*-----------.\n<line119>| yybackup.  |\n<line120>`-----------*/\n<line121>yybackup:\n<line122>/* Do appropriate processing given the current state.  Read a\n<line123>lookahead token if we need one and don't already have one.  */\n<line124>/* First try to decide what to do without reference to lookahead token.  */\n<line125>yyn = yypact[yystate];\n<line126>if (yypact_value_is_default (yyn))\n<line127>goto yydefault;\n<line128>/* Not known => get a lookahead token if don't already have one.  */\n<line129>/* YYCHAR is either empty, or end-of-input, or a valid lookahead.  */\n<line130>if (yychar == YYEMPTY)\n<line131>{\n<line132>YYDPRINTF ((stderr, "Reading a token\n"));\n<line133>yychar = yylex (&yylval, pc);\n<line134>}\n<line135>if (yychar <= YYEOF)\n<line136>{\n<line137>yychar = YYEOF;\n<line138>yytoken = YYSYMBOL_YYEOF;\n<line139>YYDPRINTF ((stderr, "Now at end of input.\n"));\n<line140>}\n<line141>else if (yychar == YYerror)\n<line142>{\n<line143>/* The scanner already issued an error message, process directly\n<line144>to error recovery.  But do not keep the error token as\n<line145>lookahead, it is too special and may lead us to an endless\n<line146>loop in error recovery. */\n<line147>yychar = YYUNDEF;\n<line148>yytoken = YYSYMBOL_YYerror;\n<line149>goto yyerrlab1;\n<line150>}\n<line151>else\n<line152>{\n<line153>yytoken = YYTRANSLATE (yychar);\n<line154>YY_SYMBOL_PRINT ("Next token is", yytoken, &yylval, &yylloc);\n<line155>}\n<line156>/* If the proper action on seeing token YYTOKEN is to reduce or to\n<line157>detect an error, take that action.  */\n<line158>yyn += yytoken;\n<line159>if (yyn < 0 || YYLAST < yyn || yycheck[yyn] != yytoken)\n<line160>goto yydefault;\n<line161>yyn = yytable[yyn];\n<line162>if (yyn <= 0)\n<line163>{\n<line164>if (yytable_value_is_error (yyn))\n<line165>goto yyerrlab;\n<line166>yyn = -yyn;\n<line167>goto yyreduce;\n<line168>}\n<line169>/* Count tokens shifted since error; after three, turn off error\n<line170>status.  */\n<line171>if (yyerrstatus)\n<line172>yyerrstatus--;\n<line173>/* Shift the lookahead token.  */\n<line174>YY_SYMBOL_PRINT ("Shifting", yytoken, &yylval, &yylloc);\n<line175>yystate = yyn;\n<line176>YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN\n<line177>*++yyvsp = yylval;\n<line178>YY_IGNORE_MAYBE_UNINITIALIZED_END\n<line179>/* Discard the shifted token.  */\n<line180>yychar = YYEMPTY;\n<line181>goto yynewstate;\n<line182>/*-----------------------------------------------------------.\n<line183>| yydefault -- do the default action for the current state.  |\n<line184>`-----------------------------------------------------------*/\n<line185>yydefault:\n<line186>yyn = yydefact[yystate];\n<line187>if (yyn == 0)\n<line188>goto yyerrlab;\n<line189>goto yyreduce;\n<line190>/*-----------------------------.\n<line191>| yyreduce -- do a reduction.  |\n<line192>`-----------------------------*/\n<line193>yyreduce:\n<line194>/* yyn is the number of a rule to reduce with.  */\n<line195>yylen = yyr2[yyn];\n<line196>/* If YYLEN is nonzero, implement the default value of the action:\n<line197>'$$ = $1'.\n<line198>Otherwise, the following line sets YYVAL to garbage.\n<line199>This behavior is undocumented and Bison\n<line200>users should not rely upon it.  Assigning to YYVAL\n<line201>unconditionally makes the parser a bit smaller, and it avoids a\n<line202>GCC warning that YYVAL may be used uninitialized.  */\n<line203>yyval = yyvsp[1-yylen];\n<line204>YY_REDUCE_PRINT (yyn);\n<line205>switch (yyn)\n<line206>{\n<line207>case 4: /* timespec: '@' seconds  */\n<line208>#line 598 "parse-datetime.y"\n<line209>{\n<line210>pc->seconds = (yyvsp[0].timespec);\n<line211>pc->timespec_seen = true;\n<line212>debug_print_current_time (_("number of seconds"), pc);\n<line213>}\n<line214>#line 1761 "parse-datetime.c"\n<line215>break;\n<line216>case 7: /* item: datetime  */\n<line217>#line 612 "parse-datetime.y"\n<line218>{\n<line219>pc->times_seen++; pc->dates_seen++;\n<line220>debug_print_current_time (_("datetime"), pc);\n<line221>}\n<line222>#line 1770 "parse-datetime.c"\n<line223>break;\n<line224>case 8: /* item: time  */\n<line225>#line 617 "parse-datetime.y"\n<line226>{\n<line227>pc->times_seen++;\n<line228>debug_print_current_time (_("time"), pc);\n<line229>}\n<line230>#line 1779 "parse-datetime.c"\n<line231>break;\n<line232>case 9: /* item: local_zone  */\n<line233>#line 622 "parse-datetime.y"\n<line234>{\n<line235>pc->local_zones_seen++;\n<line236>debug_print_current_time (_("local_zone"), pc);\n<line237>}\n<line238>#line 1788 "parse-datetime.c"\n<line239>break;\n<line240>case 10: /* item: 'J'  */\n<line241>#line 627 "parse-datetime.y"\n<line242>{\n<line243>pc->J_zones_seen++;\n<line244>debug_print_current_time ("J", pc);\n<line245>}\n<line246>#line 1797 "parse-datetime.c"\n<line247>break;\n<line248>case 11: /* item: zone  */\n<line249>#line 632 "parse-datetime.y"\n<line250>{\n<line251>pc->zones_seen++;\n<line252>debug_print_current_time (_("zone"), pc);\n<line253>}\n<line254>#line 1806 "parse-datetime.c"\n<line255>break;\n<line256>case 12: /* item: date  */\n<line257>#line 637 "parse-datetime.y"\n<line258>{\n<line259>pc->dates_seen++;\n<line260>debug_print_current_time (_("date"), pc);\n<line261>}\n<line262>#line 1815 "parse-datetime.c"\n<line263>break;\n<line264>case 13: /* item: day  */\n<line265>#line 642 "parse-datetime.y"\n<line266>{\n<line267>pc->days_seen++;\n<line268>debug_print_current_time (_("day"), pc);\n<line269>}\n<line270>#line 1824 "parse-datetime.c"\n<line271>break;\n<line272>case 14: /* item: rel  */\n<line273>#line 647 "parse-datetime.y"\n<line274>{\n<line275>debug_print_relative_time (_("relative"), pc);\n<line276>}\n<line277>#line 1832 "parse-datetime.c"\n<line278>break;\n<line279>case 15: /* item: number  */\n<line280>#line 651 "parse-datetime.y"\n<line281>{\n<line282>debug_print_current_time (_("number"), pc);\n<line283>}\n<line284>#line 1840 "parse-datetime.c"\n<line285>break;\n<line286>case 16: /* item: hybrid  */\n<line287>#line 655 "parse-datetime.y"\n<line288>{\n<line289>debug_print_relative_time (_("hybrid"), pc);\n<line290>}\n<line291>#line 1848 "parse-datetime.c"\n<line292>break;\n<line293>case 19: /* time: tUNUMBER tMERIDIAN  */\n<line294>#line 670 "parse-datetime.y"\n<line295>{\n<line296>set_hhmmss (pc, (yyvsp[-1].textintval).value, 0, 0, 0);\n<line297>pc->meridian = (yyvsp[0].intval);\n<line298>}\n<line299>#line 1857 "parse-datetime.c"\n<line300>break;\n<line301>case 20: /* time: tUNUMBER ':' tUNUMBER tMERIDIAN  */\n<line302>#line 675 "parse-datetime.y"\n<line303>{\n<line304>set_hhmmss (pc, (yyvsp[-3].textintval).value, (yyvsp[-1].textintval).value, 0, 0);\n<line305>pc->meridian = (yyvsp[0].intval);\n<line306>}\n<line307>#line 1866 "parse-datetime.c"\n<line308>break;\n<line309>case 21: /* time: tUNUMBER ':' tUNUMBER ':' unsigned_seconds tMERIDIAN  */\n<line310>#line 680 "parse-datetime.y"\n<line311>{\n<line312>set_hhmmss (pc, (yyvsp[-5].textintval).value, (yyvsp[-3].textintval).value, (yyvsp[-1].timespec).tv_sec, (yyvsp[-1].timespec).tv_nsec);\n<line313>pc->meridian = (yyvsp[0].intval);\n<line314>}\n<line315>#line 1875 "parse-datetime.c"\n<line316>break;\n<line317>case 23: /* iso_8601_time: tUNUMBER zone_offset  */\n<line318>#line 689 "parse-datetime.y"\n<line319>{\n<line320>set_hhmmss (pc, (yyvsp[-1].textintval).value, 0, 0, 0);\n<line321>pc->meridian = MER24;\n<line322>}\n<line323>#line 1884 "parse-datetime.c"\n<line324>break;\n<line325>case 24: /* iso_8601_time: tUNUMBER ':' tUNUMBER o_zone_offset  */\n<line326>#line 694 "parse-datetime.y"\n<line327>{\n<line328>set_hhmmss (pc, (yyvsp[-3].textintval).value, (yyvsp[-1].textintval).value, 0, 0);\n<line329>pc->meridian = MER24;\n<line330>}\n<line331>#line 1893 "parse-datetime.c"\n<line332>break;\n<line333>case 25: /* iso_8601_time: tUNUMBER ':' tUNUMBER ':' unsigned_seconds o_zone_offset  */\n<line334>#line 699 "parse-datetime.y"\n<line335>{\n<line336>set_hhmmss (pc, (yyvsp[-5].textintval).value, (yyvsp[-3].textintval).value, (yyvsp[-1].timespec).tv_sec, (yyvsp[-1].timespec).tv_nsec);\n<line337>pc->meridian = MER24;\n<line338>}\n<line339>#line 1902 "parse-datetime.c"\n<line340>break;\n<line341>case 28: /* zone_offset: tSNUMBER o_colon_minutes  */\n<line342>#line 712 "parse-datetime.y"\n<line343>{\n<line344>pc->zones_seen++;\n<line345>if (! time_zone_hhmm (pc, (yyvsp[-1].textintval), (yyvsp[0].intval))) YYABORT;\n<line346>}\n<line347>#line 1911 "parse-datetime.c"\n<line348>break;\n<line349>case 29: /* local_zone: tLOCAL_ZONE  */\n<line350>#line 737 "parse-datetime.y"\n<line351>{ pc->local_isdst = (yyvsp[0].intval); }\n<line352>#line 1917 "parse-datetime.c"\n<line353>break;\n<line354>case 30: /* local_zone: tLOCAL_ZONE tDST  */\n<line355>#line 739 "parse-datetime.y"\n<line356>{\n<line357>pc->local_isdst = 1;\n<line358>pc->dsts_seen++;\n<line359>}\n<line360>#line 1926 "parse-datetime.c"\n<line361>break;\n<line362>case 31: /* zone: tZONE  */\n<line363>#line 749 "parse-datetime.y"\n<line364>{ pc->time_zone = (yyvsp[0].intval); }\n<line365>#line 1932 "parse-datetime.c"\n<line366>break;\n<line367>case 32: /* zone: 'T'  */\n<line368>#line 751 "parse-datetime.y"\n<line369>{ pc->time_zone = -HOUR (7); }\n<line370>#line 1938 "parse-datetime.c"\n<line371>break;\n<line372>case 33: /* zone: tZONE relunit_snumber  */\n<line373>#line 753 "parse-datetime.y"\n<line374>{ pc->time_zone = (yyvsp[-1].intval);\n<line375>if (! apply_relative_time (pc, (yyvsp[0].rel), 1)) YYABORT;\n<line376>debug_print_relative_time (_("relative"), pc);\n<line377>}\n<line378>#line 1947 "parse-datetime.c"\n<line379>break;\n<line380>case 34: /* zone: 'T' relunit_snumber  */\n<line381>#line 758 "parse-datetime.y"\n<line382>{ pc->time_zone = -HOUR (7);\n<line383>if (! apply_relative_time (pc, (yyvsp[0].rel), 1)) YYABORT;\n<line384>debug_print_relative_time (_("relative"), pc);\n<line385>}\n<line386>#line 1956 "parse-datetime.c"\n<line387>break;\n<line388>case 35: /* zone: tZONE tSNUMBER o_colon_minutes  */\n<line389>#line 763 "parse-datetime.y"\n<line390>{ if (! time_zone_hhmm (pc, (yyvsp[-1].textintval), (yyvsp[0].intval))) YYABORT;\n<line391>if (ckd_add (&pc->time_zone, pc->time_zone, (yyvsp[-2].intval))) YYABORT; }\n<line392>#line 1963 "parse-datetime.c"\n<line393>break;\n<line394>case 36: /* zone: tDAYZONE  */\n<line395>#line 766 "parse-datetime.y"\n<line396>{ pc->time_zone = (yyvsp[0].intval) + 60 * 60; }\n<line397>#line 1969 "parse-datetime.c"\n<line398>break;\n<line399>case 37: /* zone: tZONE tDST  */\n<line400>#line 768 "parse-datetime.y"\n<line401>{ pc->time_zone = (yyvsp[-1].intval) + 60 * 60; }\n<line402>#line 1975 "parse-datetime.c"\n<line403>break;\n<line404>case 38: /* day: tDAY  */\n<line405>#line 773 "parse-datetime.y"\n<line406>{\n<line407>pc->day_ordinal = 0;\n<line408>pc->day_number = (yyvsp[0].intval);\n<line409>}\n<line410>#line 1984 "parse-datetime.c"\n<line411>break;\n<line412>case 39: /* day: tDAY ','  */\n<line413>#line 778 "parse-datetime.y"\n<line414>{\n<line415>pc->day_ordinal = 0;\n<line416>pc->day_number = (yyvsp[-1].intval);\n<line417>}\n<line418>#line 1993 "parse-datetime.c"\n<line419>break;\n<line420>case 40: /* day: tORDINAL tDAY  */\n<line421>#line 783 "parse-datetime.y"\n<line422>{\n<line423>pc->day_ordinal = (yyvsp[-1].intval);\n<line424>pc->day_number = (yyvsp[0].intval);\n<line425>pc->debug_ordinal_day_seen = true;\n<line426>}\n<line427>#line 2003 "parse-datetime.c"\n<line428>break;\n<line429>case 41: /* day: tUNUMBER tDAY  */\n<line430>#line 789 "parse-datetime.y"\n<line431>{\n<line432>pc->day_ordinal = (yyvsp[-1].textintval).value;\n<line433>pc->day_number = (yyvsp[0].intval);\n<line434>pc->debug_ordinal_day_seen = true;\n<line435>}\n<line436>#line 2013 "parse-datetime.c"\n<line437>break;\n<line438>case 42: /* date: tUNUMBER '/' tUNUMBER  */\n<line439>#line 798 "parse-datetime.y"\n<line440>{\n<line441>pc->month = (yyvsp[-2].textintval).value;\n<line442>pc->day = (yyvsp[0].textintval).value;\n<line443>}\n<line444>#line 2022 "parse-datetime.c"\n<line445>break;\n<line446>case 43: /* date: tUNUMBER '/' tUNUMBER '/' tUNUMBER  */\n<line447>#line 803 "parse-datetime.y"\n<line448>{\n<line449>/* Interpret as YYYY/MM/DD if the first value has 4 or more digits,\n<line450>otherwise as MM/DD/YY.\n<line451>The goal in recognizing YYYY/MM/DD is solely to support legacy\n<line452>machine-generated dates like those in an RCS log listing.  If\n<line453>you want portability, use the ISO 8601 format.  */\n<line454>if (4 <= (yyvsp[-4].textintval).digits)\n<line455>{\n<line456>if (debugging (pc))\n<line457>{\n<line458>intmax_t digits = (yyvsp[-4].textintval).digits;\n<line459>dbg_printf (_("warning: value %"PRIdMAX" has %"PRIdMAX" digits. "\n<line460>"Assuming YYYY/MM/DD\n"),\n<line461>(yyvsp[-4].textintval).value, digits);\n<line462>}\n<line463>pc->year = (yyvsp[-4].textintval);\n<line464>pc->month = (yyvsp[-2].textintval).value;\n<line465>pc->day = (yyvsp[0].textintval).value;\n<line466>}\n<line467>else\n<line468>{\n<line469>if (debugging (pc))\n<line470>dbg_printf (_("warning: value %"PRIdMAX" has less than 4 digits. "\n<line471>"Assuming MM/DD/YY[YY]\n"),\n<line472>(yyvsp[-4].textintval).value);\n<line473>pc->month = (yyvsp[-4].textintval).value;\n<line474>pc->day = (yyvsp[-2].textintval).value;\n<line475>pc->year = (yyvsp[0].textintval);\n<line476>}\n<line477>}\n<line478>#line 2059 "parse-datetime.c"\n<line479>break;\n<line480>case 44: /* date: tUNUMBER tMONTH tSNUMBER  */\n<line481>#line 836 "parse-datetime.y"\n<line482>{\n<line483>/* E.g., 17-JUN-1992.  */\n<line484>pc->day = (yyvsp[-2].textintval).value;\n<line485>pc->month = (yyvsp[-1].intval);\n<line486>if (ckd_sub (&pc->year.value, 0, (yyvsp[0].textintval).value)) YYABORT;\n<line487>pc->year.digits = (yyvsp[0].textintval).digits;\n<line488>}\n<line489>#line 2071 "parse-datetime.c"\n<line490>break;\n<line491>case 45: /* date: tMONTH tSNUMBER tSNUMBER  */\n<line492>#line 844 "parse-datetime.y"\n<line493>{\n<line494>/* E.g., JUN-17-1992.  */\n<line495>pc->month = (yyvsp[-2].intval);\n<line496>if (ckd_sub (&pc->day, 0, (yyvsp[-1].textintval).value)) YYABORT;\n<line497>if (ckd_sub (&pc->year.value, 0, (yyvsp[0].textintval).value)) YYABORT;\n<line498>pc->year.digits = (yyvsp[0].textintval).digits;\n<line499>}\n<line500>#line 2083 "parse-datetime.c"\n<line501>break;\n<line502>case 46: /* date: tMONTH tUNUMBER  */\n<line503>#line 852 "parse-datetime.y"\n<line504>{\n<line505>pc->month = (yyvsp[-1].intval);\n<line506>pc->day = (yyvsp[0].textintval).value;\n<line507>}\n<line508>#line 2092 "parse-datetime.c"\n<line509>break;\n<line510>case 47: /* date: tMONTH tUNUMBER ',' tUNUMBER  */\n<line511>#line 857 "parse-datetime.y"\n<line512>{\n<line513>pc->month = (yyvsp[-3].intval);\n<line514>pc->day = (yyvsp[-2].textintval).value;\n<line515>pc->year = (yyvsp[0].textintval);\n<line516>}\n<line517>#line 2102 "parse-datetime.c"\n<line518>break;\n<line519>case 48: /* date: tUNUMBER tMONTH  */\n<line520>#line 863 "parse-datetime.y"\n<line521>{\n<line522>pc->day = (yyvsp[-1].textintval).value;\n<line523>pc->month = (yyvsp[0].intval);\n<line524>}\n<line525>#line 2111 "parse-datetime.c"\n<line526>break;\n<line527>case 49: /* date: tUNUMBER tMONTH tUNUMBER  */\n<line528>#line 868 "parse-datetime.y"\n<line529>{\n<line530>pc->day = (yyvsp[-2].textintval).value;\n<line531>pc->month = (yyvsp[-1].intval);\n<line532>pc->year = (yyvsp[0].textintval);\n<line533>}\n<line534>#line 2121 "parse-datetime.c"\n<line535>break;\n<line536>case 51: /* iso_8601_date: tUNUMBER tSNUMBER tSNUMBER  */\n<line537>#line 878 "parse-datetime.y"\n<line538>{\n<line539>/* ISO 8601 format.  YYYY-MM-DD.  */\n<line540>pc->year = (yyvsp[-2].textintval);\n<line541>if (ckd_sub (&pc->month, 0, (yyvsp[-1].textintval).value)) YYABORT;\n<line542>if (ckd_sub (&pc->day, 0, (yyvsp[0].textintval).value)) YYABORT;\n<line543>}\n<line544>#line 2132 "parse-datetime.c"\n<line545>break;\n<line546>case 52: /* rel: relunit tAGO  */\n<line547>#line 888 "parse-datetime.y"\n<line548>{ if (! apply_relative_time (pc, (yyvsp[-1].rel), (yyvsp[0].intval))) YYABORT; }\n<line549>#line 2138 "parse-datetime.c"\n<line550>break;\n<line551>case 53: /* rel: relunit  */\n<line552>#line 890 "parse-datetime.y"\n<line553>{ if (! apply_relative_time (pc, (yyvsp[0].rel), 1)) YYABORT; }\n<line554>#line 2144 "parse-datetime.c"\n<line555>break;\n<line556>case 54: /* rel: dayshift  */\n<line557>#line 892 "parse-datetime.y"\n<line558>{ if (! apply_relative_time (pc, (yyvsp[0].rel), 1)) YYABORT; }\n<line559>#line 2150 "parse-datetime.c"\n<line560>break;\n<line561>case 55: /* relunit: tORDINAL tYEAR_UNIT  */\n<line562>#line 897 "parse-datetime.y"\n<line563>{ (yyval.rel) = RELATIVE_TIME_0; (yyval.rel).year = (yyvsp[-1].intval); }\n<line564>#line 2156 "parse-datetime.c"\n<line565>break;\n<line566>case 56: /* relunit: tUNUMBER tYEAR_UNIT  */\n<line567>#line 899 "parse-datetime.y"\n<line568>{ (yyval.rel) = RELATIVE_TIME_0; (yyval.rel).year = (yyvsp[-1].textintval).value; }\n<line569>#line 2162 "parse-datetime.c"\n<line570>break;\n<line571>case 57: /* relunit: tYEAR_UNIT  */\n<line572>#line 901 "parse-datetime.y"\n<line573>{ (yyval.rel) = RELATIVE_TIME_0; (yyval.rel).year = 1; }\n<line574>#line 2168 "parse-datetime.c"\n<line575>break;\n<line576>case 58: /* relunit: tORDINAL tMONTH_UNIT  */\n<line577>#line 903 "parse-datetime.y"\n<line578>{ (yyval.rel) = RELATIVE_TIME_0; (yyval.rel).month = (yyvsp[-1].intval); }\n<line579>#line 2174 "parse-datetime.c"\n<line580>break;\n<line581>case 59: /* relunit: tUNUMBER tMONTH_UNIT  */\n<line582>#line 905 "parse-datetime.y"\n<line583>{ (yyval.rel) = RELATIVE_TIME_0; (yyval.rel).month = (yyvsp[-1].textintval).value; }\n<line584>#line 2180 "parse-datetime.c"\n<line585>break;\n<line586>case 60: /* relunit: tMONTH_UNIT  */\n<line587>#line 907 "parse-datetime.y"\n<line588>{ (yyval.rel) = RELATIVE_TIME_0; (yyval.rel).month = 1; }\n<line589>#line 2186 "parse-datetime.c"\n<line590>break;\n<line591>case 61: /* relunit: tORDINAL tDAY_UNIT  */\n<line592>#line 909 "parse-datetime.y"\n<line593>{ (yyval.rel) = RELATIVE_TIME_0;\n<line594>if (ckd_mul (&(yyval.rel).day, (yyvsp[-1].intval), (yyvsp[0].intval))) YYABORT; }\n<line595>#line 2193 "parse-datetime.c"\n<line596>break;\n<line597>case 62: /* relunit: tUNUMBER tDAY_UNIT  */\n<line598>#line 912 "parse-datetime.y"\n<line599>{ (yyval.rel) = RELATIVE_TIME_0;\n<line600>if (ckd_mul (&(yyval.rel).day, (yyvsp[-1].textintval).value, (yyvsp[0].intval))) YYABORT; }\n<line601>#line 2200 "parse-datetime.c"\n<line602>break;\n<line603>case 63: /* relunit: tDAY_UNIT  */\n<line604>#line 915 "parse-datetime.y"\n<line605>{ (yyval.rel) = RELATIVE_TIME_0; (yyval.rel).day = (yyvsp[0].intval); }\n<line606>#line 2206 "parse-datetime.c"\n<line607>break;\n<line608>case 64: /* relunit: tORDINAL tHOUR_UNIT  */\n<line609>#line 917 "parse-datetime.y"\n<line610>{ (yyval.rel) = RELATIVE_TIME_0; (yyval.rel).hour = (yyvsp[-1].intval); }\n<line611>#line 2212 "parse-datetime.c"\n<line612>break;\n<line613>case 65: /* relunit: tUNUMBER tHOUR_UNIT  */\n<line614>#line 919 "parse-datetime.y"\n<line615>{ (yyval.rel) = RELATIVE_TIME_0; (yyval.rel).hour = (yyvsp[-1].textintval).value; }\n<line616>#line 2218 "parse-datetime.c"\n<line617>break;\n<line618>case 66: /* relunit: tHOUR_UNIT  */\n<line619>#line 921 "parse-datetime.y"\n<line620>{ (yyval.rel) = RELATIVE_TIME_0; (yyval.rel).hour = 1; }\n<line621>#line 2224 "parse-datetime.c"\n<line622>break;\n<line623>case 67: /* relunit: tORDINAL tMINUTE_UNIT  */\n<line624>#line 923 "parse-datetime.y"\n<line625>{ (yyval.rel) = RELATIVE_TIME_0; (yyval.rel).minutes = (yyvsp[-1].intval); }\n<line626>#line 2230 "parse-datetime.c"\n<line627>break;\n<line628>case 68: /* relunit: tUNUMBER tMINUTE_UNIT  */\n<line629>#line 925 "parse-datetime.y"\n<line630>{ (yyval.rel) = RELATIVE_TIME_0; (yyval.rel).minutes = (yyvsp[-1].textintval).value; }\n<line631>#line 2236 "parse-datetime.c"\n<line632>break;\n<line633>case 69: /* relunit: tMINUTE_UNIT  */\n<line634>#line 927 "parse-datetime.y"\n<line635>{ (yyval.rel) = RELATIVE_TIME_0; (yyval.rel).minutes = 1; }\n<line636>#line 2242 "parse-datetime.c"\n<line637>break;\n<line638>case 70: /* relunit: tORDINAL tSEC_UNIT  */\n<line639>#line 929 "parse-datetime.y"\n<line640>{ (yyval.rel) = RELATIVE_TIME_0; (yyval.rel).seconds = (yyvsp[-1].intval); }\n<line641>#line 2248 "parse-datetime.c"\n<line642>break;\n<line643>case 71: /* relunit: tUNUMBER tSEC_UNIT  */\n<line644>#line 931 "parse-datetime.y"\n<line645>{ (yyval.rel) = RELATIVE_TIME_0; (yyval.rel).seconds = (yyvsp[-1].textintval).value; }\n<line646>#line 2254 "parse-datetime.c"\n<line647>break;\n<line648>case 72: /* relunit: tSDECIMAL_NUMBER tSEC_UNIT  */\n<line649>#line 933 "parse-datetime.y"\n<line650>{ (yyval.rel) = RELATIVE_TIME_0; (yyval.rel).seconds = (yyvsp[-1].timespec).tv_sec; (yyval.rel).ns = (yyvsp[-1].timespec).tv_nsec; }\n<line651>#line 2260 "parse-datetime.c"\n<line652>break;\n<line653>case 73: /* relunit: tUDECIMAL_NUMBER tSEC_UNIT  */\n<line654>#line 935 "parse-datetime.y"\n<line655>{ (yyval.rel) = RELATIVE_TIME_0; (yyval.rel).seconds = (yyvsp[-1].timespec).tv_sec; (yyval.rel).ns = (yyvsp[-1].timespec).tv_nsec; }\n<line656>#line 2266 "parse-datetime.c"\n<line657>break;\n<line658>case 74: /* relunit: tSEC_UNIT  */\n<line659>#line 937 "parse-datetime.y"\n<line660>{ (yyval.rel) = RELATIVE_TIME_0; (yyval.rel).seconds = 1; }\n<line661>#line 2272 "parse-datetime.c"\n<line662>break;\n<line663>case 76: /* relunit_snumber: tSNUMBER tYEAR_UNIT  */\n<line664>#line 943 "parse-datetime.y"\n<line665>{ (yyval.rel) = RELATIVE_TIME_0; (yyval.rel).year = (yyvsp[-1].textintval).value; }\n<line666>#line 2278 "parse-datetime.c"\n<line667>break;\n<line668>case 77: /* relunit_snumber: tSNUMBER tMONTH_UNIT  */\n<line669>#line 945 "parse-datetime.y"\n<line670>{ (yyval.rel) = RELATIVE_TIME_0; (yyval.rel).month = (yyvsp[-1].textintval).value; }\n<line671>#line 2284 "parse-datetime.c"\n<line672>break;\n<line673>case 78: /* relunit_snumber: tSNUMBER tDAY_UNIT  */\n<line674>#line 947 "parse-datetime.y"\n<line675>{ (yyval.rel) = RELATIVE_TIME_0;\n<line676>if (ckd_mul (&(yyval.rel).day, (yyvsp[-1].textintval).value, (yyvsp[0].intval))) YYABORT; }\n<line677>#line 2291 "parse-datetime.c"\n<line678>break;\n<line679>case 79: /* relunit_snumber: tSNUMBER tHOUR_UNIT  */\n<line680>#line 950 "parse-datetime.y"\n<line681>{ (yyval.rel) = RELATIVE_TIME_0; (yyval.rel).hour = (yyvsp[-1].textintval).value; }\n<line682>#line 2297 "parse-datetime.c"\n<line683>break;\n<line684>case 80: /* relunit_snumber: tSNUMBER tMINUTE_UNIT  */\n<line685>#line 952 "parse-datetime.y"\n<line686>{ (yyval.rel) = RELATIVE_TIME_0; (yyval.rel).minutes = (yyvsp[-1].textintval).value; }\n<line687>#line 2303 "parse-datetime.c"\n<line688>break;\n<line689>case 81: /* relunit_snumber: tSNUMBER tSEC_UNIT  */\n<line690>#line 954 "parse-datetime.y"\n<line691>{ (yyval.rel) = RELATIVE_TIME_0; (yyval.rel).seconds = (yyvsp[-1].textintval).value; }\n<line692>#line 2309 "parse-datetime.c"\n<line693>break;\n<line694>case 82: /* dayshift: tDAY_SHIFT  */\n<line695>#line 959 "parse-datetime.y"\n<line696>{ (yyval.rel) = RELATIVE_TIME_0; (yyval.rel).day = (yyvsp[0].intval); }\n<line697>#line 2315 "parse-datetime.c"\n<line698>break;\n<line699>case 86: /* signed_seconds: tSNUMBER  */\n<line700>#line 967 "parse-datetime.y"\n<line701>{ if (time_overflow ((yyvsp[0].textintval).value)) YYABORT;\n<line702>(yyval.timespec) = (struct timespec) { .tv_sec = (yyvsp[0].textintval).value }; }\n<line703>#line 2322 "parse-datetime.c"\n<line704>break;\n<line705>case 88: /* unsigned_seconds: tUNUMBER  */\n<line706>#line 974 "parse-datetime.y"\n<line707>{ if (time_overflow ((yyvsp[0].textintval).value)) YYABORT;\n<line708>(yyval.timespec) = (struct timespec) { .tv_sec = (yyvsp[0].textintval).value }; }\n<line709>#line 2329 "parse-datetime.c"\n<line710>break;\n<line711>case 89: /* number: tUNUMBER  */\n<line712>#line 980 "parse-datetime.y"\n<line713>{ digits_to_date_time (pc, (yyvsp[0].textintval)); }\n<line714>#line 2335 "parse-datetime.c"\n<line715>break;\n<line716>case 90: /* hybrid: tUNUMBER relunit_snumber  */\n<line717>#line 985 "parse-datetime.y"\n<line718>{\n<line719>/* Hybrid all-digit and relative offset, so that we accept e.g.,\n<line720>"YYYYMMDD +N days" as well as "YYYYMMDD N days".  */\n<line721>digits_to_date_time (pc, (yyvsp[-1].textintval));\n<line722>if (! apply_relative_time (pc, (yyvsp[0].rel), 1)) YYABORT;\n<line723>}\n<line724>#line 2346 "parse-datetime.c"\n<line725>break;\n<line726>case 91: /* o_colon_minutes: %empty  */\n<line727>#line 995 "parse-datetime.y"\n<line728>{ (yyval.intval) = -1; }\n<line729>#line 2352 "parse-datetime.c"\n<line730>break;\n<line731>case 92: /* o_colon_minutes: ':' tUNUMBER  */\n<line732>#line 997 "parse-datetime.y"\n<line733>{ (yyval.intval) = (yyvsp[0].textintval).value; }\n<line734>#line 2358 "parse-datetime.c"\n<line735>break;\n<line736>#line 2362 "parse-datetime.c"\n<line737>default: break;\n<line738>}\n<line739>/* User semantic actions sometimes alter yychar, and that requires\n<line740>that yytoken be updated with the new translation.  We take the\n<line741>approach of translating immediately before every use of yytoken.\n<line742>One alternative is translating here after every semantic action,\n<line743>but that translation would be missed if the semantic action invokes\n<line744>YYABORT, YYACCEPT, or YYERROR immediately after altering yychar or\n<line745>if it invokes YYBACKUP.  In the case of YYABORT or YYACCEPT, an\n<line746>incorrect destructor might then be invoked immediately.  In the\n<line747>case of YYERROR or YYBACKUP, subsequent parser actions might lead\n<line748>to an incorrect destructor call or verbose syntax error message\n<line749>before the lookahead is translated.  */\n<line750>YY_SYMBOL_PRINT ("-> $$ =", YY_CAST (yysymbol_kind_t, yyr1[yyn]), &yyval, &yyloc);\n<line751>YYPOPSTACK (yylen);\n<line752>yylen = 0;\n<line753>*++yyvsp = yyval;\n<line754>/* Now 'shift' the result of the reduction.  Determine what state\n<line755>that goes to, based on the state we popped back to and the rule\n<line756>number reduced by.  */\n<line757>{\n<line758>const int yylhs = yyr1[yyn] - YYNTOKENS;\n<line759>const int yyi = yypgoto[yylhs] + *yyssp;\n<line760>yystate = (0 <= yyi && yyi <= YYLAST && yycheck[yyi] == *yyssp\n<line761>? yytable[yyi]\n<line762>: yydefgoto[yylhs]);\n<line763>}\n<line764>goto yynewstate;\n<line765>/*--------------------------------------.\n<line766>| yyerrlab -- here on detecting error.  |\n<line767>`--------------------------------------*/\n<line768>yyerrlab:\n<line769>/* Make sure we have latest lookahead translation.  See comments at\n<line770>user semantic actions for why this is necessary.  */\n<line771>yytoken = yychar == YYEMPTY ? YYSYMBOL_YYEMPTY : YYTRANSLATE (yychar);\n<line772>/* If not already recovering from an error, report this error.  */\n<line773>if (!yyerrstatus)\n<line774>{\n<line775>++yynerrs;\n<line776>yyerror (pc, YY_("syntax error"));\n<line777>}\n<line778>if (yyerrstatus == 3)\n<line779>{\n<line780>/* If just tried and failed to reuse lookahead token after an\n<line781>error, discard it.  */\n<line782>if (yychar <= YYEOF)\n<line783>{\n<line784>/* Return failure if at end of input.  */\n<line785>if (yychar == YYEOF)\n<line786>YYABORT;\n<line787>}\n<line788>else\n<line789>{\n<line790>yydestruct ("Error: discarding",\n<line791>yytoken, &yylval, pc);\n<line792>yychar = YYEMPTY;\n<line793>}\n<line794>}\n<line795>/* Else will try to reuse lookahead token after shifting the error\n<line796>token.  */\n<line797>goto yyerrlab1;\n<line798>/*---------------------------------------------------.\n<line799>| yyerrorlab -- error raised explicitly by YYERROR.  |\n<line800>`---------------------------------------------------*/\n<line801>yyerrorlab:\n<line802>/* Pacify compilers when the user code never invokes YYERROR and the\n<line803>label yyerrorlab therefore never appears in user code.  */\n<line804>if (0)\n<line805>YYERROR;\n<line806>++yynerrs;\n<line807>/* Do not reclaim the symbols of the rule whose action triggered\n<line808>this YYERROR.  */\n<line809>YYPOPSTACK (yylen);\n<line810>yylen = 0;\n<line811>YY_STACK_PRINT (yyss, yyssp);\n<line812>yystate = *yyssp;\n<line813>goto yyerrlab1;\n<line814>/*-------------------------------------------------------------.\n<line815>| yyerrlab1 -- common code for both syntax error and YYERROR.  |\n<line816>`-------------------------------------------------------------*/\n<line817>yyerrlab1:\n<line818>yyerrstatus = 3;      /* Each real token shifted decrements this.  */\n<line819>/* Pop stack until we find a state that shifts the error token.  */\n<line820>for (;;)\n<line821>{\n<line822>yyn = yypact[yystate];\n<line823>if (!yypact_value_is_default (yyn))\n<line824>{\n<line825>yyn += YYSYMBOL_YYerror;\n<line826>if (0 <= yyn && yyn <= YYLAST && yycheck[yyn] == YYSYMBOL_YYerror)\n<line827>{\n<line828>yyn = yytable[yyn];\n<line829>if (0 < yyn)\n<line830>break;\n<line831>}\n<line832>}\n<line833>/* Pop the current state because it cannot handle the error token.  */\n<line834>if (yyssp == yyss)\n<line835>YYABORT;\n<line836>yydestruct ("Error: popping",\n<line837>YY_ACCESSING_SYMBOL (yystate), yyvsp, pc);\n<line838>YYPOPSTACK (1);\n<line839>yystate = *yyssp;\n<line840>YY_STACK_PRINT (yyss, yyssp);\n<line841>}\n<line842>YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN\n<line843>*++yyvsp = yylval;\n<line844>YY_IGNORE_MAYBE_UNINITIALIZED_END\n<line845>/* Shift the error token.  */\n<line846>YY_SYMBOL_PRINT ("Shifting", YY_ACCESSING_SYMBOL (yyn), yyvsp, yylsp);\n<line847>yystate = yyn;\n<line848>goto yynewstate;\n<line849>/*-------------------------------------.\n<line850>| yyacceptlab -- YYACCEPT comes here.  |\n<line851>`-------------------------------------*/\n<line852>yyacceptlab:\n<line853>yyresult = 0;\n<line854>goto yyreturnlab;\n<line855>/*-----------------------------------.\n<line856>| yyabortlab -- YYABORT comes here.  |\n<line857>`-----------------------------------*/\n<line858>yyabortlab:\n<line859>yyresult = 1;\n<line860>goto yyreturnlab;\n<line861>/*-----------------------------------------------------------.\n<line862>| yyexhaustedlab -- YYNOMEM (memory exhaustion) comes here.  |\n<line863>`-----------------------------------------------------------*/\n<line864>yyexhaustedlab:\n<line865>yyerror (pc, YY_("memory exhausted"));\n<line866>yyresult = 2;\n<line867>goto yyreturnlab;\n<line868>/*----------------------------------------------------------.\n<line869>| yyreturnlab -- parsing is finished, clean up and return.  |\n<line870>`----------------------------------------------------------*/\n<line871>yyreturnlab:\n<line872>if (yychar != YYEMPTY)\n<line873>{\n<line874>/* Make sure we have latest lookahead translation.  See comments at\n<line875>user semantic actions for why this is necessary.  */\n<line876>yytoken = YYTRANSLATE (yychar);\n<line877>yydestruct ("Cleanup: discarding lookahead",\n<line878>yytoken, &yylval, pc);\n<line879>}\n<line880>/* Do not reclaim the symbols of the rule whose action triggered\n<line881>this YYABORT or YYACCEPT.  */\n<line882>YYPOPSTACK (yylen);\n<line883>YY_STACK_PRINT (yyss, yyssp);\n<line884>while (yyssp != yyss)\n<line885>{\n<line886>yydestruct ("Cleanup: popping",\n<line887>YY_ACCESSING_SYMBOL (+*yyssp), yyvsp, pc);\n<line888>YYPOPSTACK (1);\n<line889>}\n<line890>#ifndef yyoverflow\n<line891>if (yyss != yyssa)\n<line892>YYSTACK_FREE (yyss);\n<line893>#endif\n<line894>return yyresult;\n<line895>}
----------------------------------------
Function: time_zone_hhmm
Content: <line0>static bool\n<line1>time_zone_hhmm (parser_control *pc, textint s, intmax_t mm)\n<line2>{\n<line3>intmax_t n_minutes;\n<line4>bool overflow = false;\n<line5>/* If the length of S is 1 or 2 and no minutes are specified,\n<line6>interpret it as a number of hours.  */\n<line7>if (s.digits <= 2 && mm < 0)\n<line8>s.value *= 100;\n<line9>if (mm < 0)\n<line10>n_minutes = (s.value / 100) * 60 + s.value % 100;\n<line11>else\n<line12>{\n<line13>overflow |= ckd_mul (&n_minutes, s.value, 60);\n<line14>overflow |= (s.negative\n<line15>? ckd_sub (&n_minutes, n_minutes, mm)\n<line16>: ckd_add (&n_minutes, n_minutes, mm));\n<line17>}\n<line18>if (overflow || ! (-24 * 60 <= n_minutes && n_minutes <= 24 * 60))\n<line19>return false;\n<line20>pc->time_zone = n_minutes * 60;\n<line21>return true;\n<line22>}
----------------------------------------
Function: to_hour
Content: <line0>static int\n<line1>to_hour (intmax_t hours, int meridian)\n<line2>{\n<line3>switch (meridian)\n<line4>{\n<line5>default: /* Pacify GCC.  */\n<line6>case MER24:\n<line7>return 0 <= hours && hours < 24 ? hours : -1;\n<line8>case MERam:\n<line9>return 0 < hours && hours < 12 ? hours : hours == 12 ? 0 : -1;\n<line10>case MERpm:\n<line11>return 0 < hours && hours < 12 ? hours + 12 : hours == 12 ? 12 : -1;\n<line12>}\n<line13>}
----------------------------------------
Function: tm_year_str
Content: <line0>static char const *\n<line1>tm_year_str (int tm_year, char buf[TM_YEAR_BUFSIZE])\n<line2>{\n<line3>static_assert (TM_YEAR_BASE % 100 == 0);\n<line4>sprintf (buf, &"-%02d%02d"[-TM_YEAR_BASE <= tm_year],\n<line5>abs (tm_year / 100 + TM_YEAR_BASE / 100),\n<line6>abs (tm_year % 100));\n<line7>return buf;\n<line8>}
----------------------------------------
Function: to_tm_year
Content: <line0>static bool\n<line1>to_tm_year (textint textyear, bool debug, int *tm_year)\n<line2>{\n<line3>intmax_t year = textyear.value;\n<line4>/* XPG4 suggests that years 00-68 map to 2000-2068, and\n<line5>years 69-99 map to 1969-1999.  */\n<line6>if (0 <= year && textyear.digits == 2)\n<line7>{\n<line8>year += year < 69 ? 2000 : 1900;\n<line9>if (debug)\n<line10>dbg_printf (_("warning: adjusting year value %"PRIdMAX\n<line11>" to %"PRIdMAX"\n"),\n<line12>textyear.value, year);\n<line13>}\n<line14>if (year < 0\n<line15>? ckd_sub (tm_year, -TM_YEAR_BASE, year)\n<line16>: ckd_sub (tm_year, year, TM_YEAR_BASE))\n<line17>{\n<line18>if (debug)\n<line19>dbg_printf (_("error: out-of-range year %"PRIdMAX"\n"), year);\n<line20>return false;\n<line21>}\n<line22>return true;\n<line23>}
----------------------------------------
Function: lookup_zone
Content: <line0>static table const * _GL_ATTRIBUTE_PURE\n<line1>lookup_zone (parser_control const *pc, char const *name)\n<line2>{\n<line3>table const *tp;\n<line4>for (tp = universal_time_zone_table; tp->name; tp++)\n<line5>if (strcmp (name, tp->name) == 0)\n<line6>return tp;\n<line7>/* Try local zone abbreviations before those in time_zone_table, as\n<line8>the local ones are more likely to be right.  */\n<line9>for (tp = pc->local_time_zone_table; tp->name; tp++)\n<line10>if (strcmp (name, tp->name) == 0)\n<line11>return tp;\n<line12>for (tp = time_zone_table; tp->name; tp++)\n<line13>if (strcmp (name, tp->name) == 0)\n<line14>return tp;\n<line15>return NULL;\n<line16>}
----------------------------------------
Function: lookup_word
Content: <line0>static table const *\n<line1>lookup_word (parser_control const *pc, char *word)\n<line2>{\n<line3>char *p;\n<line4>char *q;\n<line5>idx_t wordlen;\n<line6>table const *tp;\n<line7>bool period_found;\n<line8>bool abbrev;\n<line9>/* Make it uppercase.  */\n<line10>for (p = word; *p; p++)\n<line11>*p = c_toupper (to_uchar (*p));\n<line12>for (tp = meridian_table; tp->name; tp++)\n<line13>if (strcmp (word, tp->name) == 0)\n<line14>return tp;\n<line15>/* See if we have an abbreviation for a month.  */\n<line16>wordlen = strlen (word);\n<line17>abbrev = wordlen == 3 || (wordlen == 4 && word[3] == '.');\n<line18>for (tp = month_and_day_table; tp->name; tp++)\n<line19>if ((abbrev ? strncmp (word, tp->name, 3) : strcmp (word, tp->name)) == 0)\n<line20>return tp;\n<line21>if ((tp = lookup_zone (pc, word)))\n<line22>return tp;\n<line23>if (strcmp (word, dst_table[0].name) == 0)\n<line24>return dst_table;\n<line25>for (tp = time_units_table; tp->name; tp++)\n<line26>if (strcmp (word, tp->name) == 0)\n<line27>return tp;\n<line28>/* Strip off any plural and try the units table again.  */\n<line29>if (word[wordlen - 1] == 'S')\n<line30>{\n<line31>word[wordlen - 1] = '\0';\n<line32>for (tp = time_units_table; tp->name; tp++)\n<line33>if (strcmp (word, tp->name) == 0)\n<line34>return tp;\n<line35>word[wordlen - 1] = 'S';  /* For "this" in relative_time_table.  */\n<line36>}\n<line37>for (tp = relative_time_table; tp->name; tp++)\n<line38>if (strcmp (word, tp->name) == 0)\n<line39>return tp;\n<line40>/* Military time zones.  */\n<line41>if (wordlen == 1)\n<line42>for (tp = military_table; tp->name; tp++)\n<line43>if (word[0] == tp->name[0])\n<line44>return tp;\n<line45>/* Drop out any periods and try the time zone table again.  */\n<line46>for (period_found = false, p = q = word; (*p = *q); q++)\n<line47>if (*q == '.')\n<line48>period_found = true;\n<line49>else\n<line50>p++;\n<line51>if (period_found && (tp = lookup_zone (pc, word)))\n<line52>return tp;\n<line53>return NULL;\n<line54>}
----------------------------------------
Function: yylex
Content: <line0>static int\n<line1>yylex (union YYSTYPE *lvalp, parser_control *pc)\n<line2>{\n<line3>unsigned char c;\n<line4>for (;;)\n<line5>{\n<line6>while (c = *pc->input, c_isspace (c))\n<line7>pc->input++;\n<line8>if (c_isdigit (c) || c == '-' || c == '+')\n<line9>{\n<line10>char const *p = pc->input;\n<line11>int sign;\n<line12>if (c == '-' || c == '+')\n<line13>{\n<line14>sign = c == '-' ? -1 : 1;\n<line15>while (c = *(pc->input = ++p), c_isspace (c))\n<line16>continue;\n<line17>if (! c_isdigit (c))\n<line18>/* skip the '-' sign */\n<line19>continue;\n<line20>}\n<line21>else\n<line22>sign = 0;\n<line23>time_t value = 0;\n<line24>do\n<line25>{\n<line26>if (ckd_mul (&value, value, 10))\n<line27>return '?';\n<line28>if (ckd_add (&value, value, sign < 0 ? '0' - c : c - '0'))\n<line29>return '?';\n<line30>c = *++p;\n<line31>}\n<line32>while (c_isdigit (c));\n<line33>if ((c == '.' || c == ',') && c_isdigit (p[1]))\n<line34>{\n<line35>time_t s = value;\n<line36>int digits;\n<line37>/* Accumulate fraction, to ns precision.  */\n<line38>p++;\n<line39>int ns = *p++ - '0';\n<line40>for (digits = 2; digits <= LOG10_BILLION; digits++)\n<line41>{\n<line42>ns *= 10;\n<line43>if (c_isdigit (*p))\n<line44>ns += *p++ - '0';\n<line45>}\n<line46>/* Skip excess digits, truncating toward -Infinity.  */\n<line47>if (sign < 0)\n<line48>for (; c_isdigit (*p); p++)\n<line49>if (*p != '0')\n<line50>{\n<line51>ns++;\n<line52>break;\n<line53>}\n<line54>while (c_isdigit (*p))\n<line55>p++;\n<line56>/* Adjust to the timespec convention, which is that\n<line57>tv_nsec is always a positive offset even if tv_sec is\n<line58>negative.  */\n<line59>if (sign < 0 && ns)\n<line60>{\n<line61>if (ckd_sub (&s, s, 1))\n<line62>return '?';\n<line63>ns = BILLION - ns;\n<line64>}\n<line65>lvalp->timespec = (struct timespec) { .tv_sec = s,\n<line66>.tv_nsec = ns };\n<line67>pc->input = p;\n<line68>return sign ? tSDECIMAL_NUMBER : tUDECIMAL_NUMBER;\n<line69>}\n<line70>else\n<line71>{\n<line72>lvalp->textintval.negative = sign < 0;\n<line73>lvalp->textintval.value = value;\n<line74>lvalp->textintval.digits = p - pc->input;\n<line75>pc->input = p;\n<line76>return sign ? tSNUMBER : tUNUMBER;\n<line77>}\n<line78>}\n<line79>if (c_isalpha (c))\n<line80>{\n<line81>char buff[20];\n<line82>char *p = buff;\n<line83>table const *tp;\n<line84>do\n<line85>{\n<line86>if (p < buff + sizeof buff - 1)\n<line87>*p++ = c;\n<line88>c = *++pc->input;\n<line89>}\n<line90>while (c_isalpha (c) || c == '.');\n<line91>*p = '\0';\n<line92>tp = lookup_word (pc, buff);\n<line93>if (! tp)\n<line94>{\n<line95>if (debugging (pc))\n<line96>dbg_printf (_("error: unknown word '%s'\n"), buff);\n<line97>return '?';\n<line98>}\n<line99>lvalp->intval = tp->value;\n<line100>return tp->type;\n<line101>}\n<line102>if (c != '(')\n<line103>return to_uchar (*pc->input++);\n<line104>idx_t count = 0;\n<line105>do\n<line106>{\n<line107>c = *pc->input++;\n<line108>if (c == '\0')\n<line109>return c;\n<line110>if (c == '(')\n<line111>count++;\n<line112>else if (c == ')')\n<line113>count--;\n<line114>}\n<line115>while (count != 0);\n<line116>}\n<line117>}
----------------------------------------
Function: yyerror
Content: <line0>static int\n<line1>yyerror (_GL_UNUSED parser_control const *pc,\n<line2>_GL_UNUSED char const *s)\n<line3>{\n<line4>return 0;\n<line5>}
----------------------------------------
Function: mktime_ok
Content: <line0>static bool\n<line1>mktime_ok (struct tm const *tm0, struct tm const *tm1)\n<line2>{\n<line3>if (tm1->tm_wday < 0)\n<line4>return false;\n<line5>return ! ((tm0->tm_sec ^ tm1->tm_sec)\n<line6>| (tm0->tm_min ^ tm1->tm_min)\n<line7>| (tm0->tm_hour ^ tm1->tm_hour)\n<line8>| (tm0->tm_mday ^ tm1->tm_mday)\n<line9>| (tm0->tm_mon ^ tm1->tm_mon)\n<line10>| (tm0->tm_year ^ tm1->tm_year));\n<line11>}
----------------------------------------
Function: debug_strfdatetime
Content: <line0>static char const *\n<line1>debug_strfdatetime (struct tm const *tm, parser_control const *pc,\n<line2>char *buf, int n)\n<line3>{\n<line4>/* TODO:\n<line5>1. find an optimal way to print date string in a clear and unambiguous\n<line6>format.  Currently, always add '(Y-M-D)' prefix.\n<line7>Consider '2016y01m10d'  or 'year(2016) month(01) day(10)'.\n<line8>If the user needs debug printing, it means he/she already having\n<line9>issues with the parsing - better to avoid formats that could\n<line10>be mis-interpreted (e.g., just YYYY-MM-DD).\n<line11>2. Can strftime be used instead?\n<line12>depends if it is portable and can print invalid dates on all systems.\n<line13>3. Print timezone information ?\n<line14>4. Print DST information ?\n<line15>5. Print nanosecond information ?\n<line16>NOTE:\n<line17>Printed date/time values might not be valid, e.g., '2016-02-31'\n<line18>or '2016-19-2016' .  These are the values as parsed from the user\n<line19>string, before validation.\n<line20>*/\n<line21>int m = nstrftime (buf, n, "(Y-M-D) %Y-%m-%d %H:%M:%S", tm, 0, 0);\n<line22>/* If parser_control information was provided (for timezone),\n<line23>and there's enough space in the buffer, add timezone info.  */\n<line24>if (pc && m < n && pc->zones_seen)\n<line25>{\n<line26>int tz = pc->time_zone;\n<line27>/* Account for DST if tLOCAL_ZONE was seen.  */\n<line28>if (pc->local_zones_seen && !pc->zones_seen && 0 < pc->local_isdst)\n<line29>tz += 60 * 60;\n<line30>char time_zone_buf[TIME_ZONE_BUFSIZE];\n<line31>snprintf (&buf[m], n - m, " TZ=%s", time_zone_str (tz, time_zone_buf));\n<line32>}\n<line33>return buf;\n<line34>}
----------------------------------------
Function: debug_strfdate
Content: <line0>static char const *\n<line1>debug_strfdate (struct tm const *tm, char *buf, int n)\n<line2>{\n<line3>char tm_year_buf[TM_YEAR_BUFSIZE];\n<line4>snprintf (buf, n, "(Y-M-D) %s-%02d-%02d",\n<line5>tm_year_str (tm->tm_year, tm_year_buf),\n<line6>tm->tm_mon + 1, tm->tm_mday);\n<line7>return buf;\n<line8>}
----------------------------------------
Function: debug_strftime
Content: <line0>static char const *\n<line1>debug_strftime (struct tm const *tm, char *buf, int n)\n<line2>{\n<line3>snprintf (buf, n, "%02d:%02d:%02d", tm->tm_hour, tm->tm_min, tm->tm_sec);\n<line4>return buf;\n<line5>}
----------------------------------------
Function: debug_mktime_not_ok
Content: <line0>static void\n<line1>debug_mktime_not_ok (struct tm const *tm0, struct tm const *tm1,\n<line2>parser_control const *pc, bool time_zone_seen)\n<line3>{\n<line4>/* TODO: handle t == -1 (as in 'mktime_ok').  */\n<line5>char tmp[DBGBUFSIZE];\n<line6>int i;\n<line7>const bool eq_sec   = (tm0->tm_sec  == tm1->tm_sec);\n<line8>const bool eq_min   = (tm0->tm_min  == tm1->tm_min);\n<line9>const bool eq_hour  = (tm0->tm_hour == tm1->tm_hour);\n<line10>const bool eq_mday  = (tm0->tm_mday == tm1->tm_mday);\n<line11>const bool eq_month = (tm0->tm_mon  == tm1->tm_mon);\n<line12>const bool eq_year  = (tm0->tm_year == tm1->tm_year);\n<line13>const bool dst_shift = eq_sec && eq_min && !eq_hour\n<line14>&& eq_mday && eq_month && eq_year;\n<line15>if (!debugging (pc))\n<line16>return;\n<line17>dbg_printf (_("error: invalid date/time value:\n"));\n<line18>dbg_printf (_("    user provided time: '%s'\n"),\n<line19>debug_strfdatetime (tm0, pc, tmp, sizeof tmp));\n<line20>dbg_printf (_("       normalized time: '%s'\n"),\n<line21>debug_strfdatetime (tm1, pc, tmp, sizeof tmp));\n<line22>/* The format must be aligned with debug_strfdatetime and the two\n<line23>DEBUG statements above.  This string is not translated.  */\n<line24>i = snprintf (tmp, sizeof tmp,\n<line25>"                                 %4s %2s %2s %2s %2s %2s",\n<line26>eq_year ? "" : "----",\n<line27>eq_month ? "" : "--",\n<line28>eq_mday ? "" : "--",\n<line29>eq_hour ? "" : "--",\n<line30>eq_min ? "" : "--",\n<line31>eq_sec ? "" : "--");\n<line32>/* Trim trailing whitespace.  */\n<line33>if (0 <= i)\n<line34>{\n<line35>if (sizeof tmp - 1 < i)\n<line36>i = sizeof tmp - 1;\n<line37>while (0 < i && tmp[i - 1] == ' ')\n<line38>--i;\n<line39>tmp[i] = '\0';\n<line40>}\n<line41>dbg_printf ("%s\n", tmp);\n<line42>dbg_printf (_("     possible reasons:\n"));\n<line43>if (dst_shift)\n<line44>dbg_printf (_("       nonexistent due to daylight-saving time;\n"));\n<line45>if (!eq_mday && !eq_month)\n<line46>dbg_printf (_("       invalid day/month combination;\n"));\n<line47>dbg_printf (_("       numeric values overflow;\n"));\n<line48>dbg_printf ("       %s\n", (time_zone_seen ? _("incorrect timezone")\n<line49>: _("missing timezone")));\n<line50>}
----------------------------------------
Function: parse_datetime_body
Content: <line0>static bool\n<line1>parse_datetime_body (struct timespec *result, char const *p,\n<line2>struct timespec const *now, unsigned int flags,\n<line3>timezone_t tzdefault, char const *tzstring)\n<line4>{\n<line5>struct tm tm;\n<line6>struct tm tm0;\n<line7>char time_zone_buf[TIME_ZONE_BUFSIZE];\n<line8>char dbg_tm[DBGBUFSIZE];\n<line9>bool ok = false;\n<line10>char const *input_sentinel = p + strlen (p);\n<line11>char *tz1alloc = NULL;\n<line12>/* A reasonable upper bound for the size of ordinary TZ strings.\n<line13>Use heap allocation if TZ's length exceeds this.  */\n<line14>enum { TZBUFSIZE = 100 };\n<line15>char tz1buf[TZBUFSIZE];\n<line16>struct timespec gettime_buffer;\n<line17>if (! now)\n<line18>{\n<line19>gettime (&gettime_buffer);\n<line20>now = &gettime_buffer;\n<line21>}\n<line22>time_t Start = now->tv_sec;\n<line23>int Start_ns = now->tv_nsec;\n<line24>unsigned char c;\n<line25>while (c = *p, c_isspace (c))\n<line26>p++;\n<line27>timezone_t tz = tzdefault;\n<line28>/* Store a local copy prior to first "goto".  Without this, a prior use\n<line29>below of RELATIVE_TIME_0 on the RHS might translate to an assignment-\n<line30>to-temporary, which would trigger a -Wjump-misses-init warning.  */\n<line31>const relative_time rel_time_0 = RELATIVE_TIME_0;\n<line32>if (strncmp (p, "TZ=\"", 4) == 0)\n<line33>{\n<line34>char const *tzbase = p + 4;\n<line35>idx_t tzsize = 1;\n<line36>char const *s;\n<line37>for (s = tzbase; *s; s++, tzsize++)\n<line38>if (*s == '\\')\n<line39>{\n<line40>s++;\n<line41>if (! (*s == '\\' || *s == '"'))\n<line42>break;\n<line43>}\n<line44>else if (*s == '"')\n<line45>{\n<line46>timezone_t tz1;\n<line47>char *tz1string = tz1buf;\n<line48>char *z;\n<line49>if (TZBUFSIZE < tzsize)\n<line50>{\n<line51>tz1alloc = malloc (tzsize);\n<line52>if (!tz1alloc)\n<line53>goto fail;\n<line54>tz1string = tz1alloc;\n<line55>}\n<line56>z = tz1string;\n<line57>for (s = tzbase; *s != '"'; s++)\n<line58>*z++ = *(s += *s == '\\');\n<line59>*z = '\0';\n<line60>tz1 = tzalloc (tz1string);\n<line61>if (!tz1)\n<line62>goto fail;\n<line63>tz = tz1;\n<line64>tzstring = tz1string;\n<line65>p = s + 1;\n<line66>while (c = *p, c_isspace (c))\n<line67>p++;\n<line68>break;\n<line69>}\n<line70>}\n<line71>struct tm tmp;\n<line72>if (! localtime_rz (tz, &now->tv_sec, &tmp))\n<line73>goto fail;\n<line74>/* As documented, be careful to treat the empty string just like\n<line75>a date string of "0".  Without this, an empty string would be\n<line76>declared invalid when parsed during a DST transition.  */\n<line77>if (*p == '\0')\n<line78>p = "0";\n<line79>parser_control pc;\n<line80>pc.input = p;\n<line81>#ifdef GNULIB_PARSE_DATETIME2\n<line82>pc.parse_datetime_debug = (flags & PARSE_DATETIME_DEBUG) != 0;\n<line83>#endif\n<line84>if (ckd_add (&pc.year.value, tmp.tm_year, TM_YEAR_BASE))\n<line85>{\n<line86>if (debugging (&pc))\n<line87>dbg_printf (_("error: initial year out of range\n"));\n<line88>goto fail;\n<line89>}\n<line90>pc.year.digits = 0;\n<line91>pc.month = tmp.tm_mon + 1;\n<line92>pc.day = tmp.tm_mday;\n<line93>pc.hour = tmp.tm_hour;\n<line94>pc.minutes = tmp.tm_min;\n<line95>pc.seconds = (struct timespec) { .tv_sec = tmp.tm_sec, .tv_nsec = Start_ns };\n<line96>tm.tm_isdst = tmp.tm_isdst;\n<line97>pc.meridian = MER24;\n<line98>pc.rel = rel_time_0;\n<line99>pc.timespec_seen = false;\n<line100>pc.rels_seen = false;\n<line101>pc.dates_seen = 0;\n<line102>pc.days_seen = 0;\n<line103>pc.times_seen = 0;\n<line104>pc.J_zones_seen = 0;\n<line105>pc.local_zones_seen = 0;\n<line106>pc.dsts_seen = 0;\n<line107>pc.zones_seen = 0;\n<line108>pc.year_seen = false;\n<line109>pc.debug_dates_seen = false;\n<line110>pc.debug_days_seen = false;\n<line111>pc.debug_times_seen = false;\n<line112>pc.debug_local_zones_seen = false;\n<line113>pc.debug_zones_seen = false;\n<line114>pc.debug_year_seen = false;\n<line115>pc.debug_ordinal_day_seen = false;\n<line116>#if HAVE_STRUCT_TM_TM_ZONE\n<line117>pc.local_time_zone_table[0].name = tmp.tm_zone;\n<line118>pc.local_time_zone_table[0].type = tLOCAL_ZONE;\n<line119>pc.local_time_zone_table[0].value = tmp.tm_isdst;\n<line120>pc.local_time_zone_table[1].name = NULL;\n<line121>/* Probe the names used in the next three calendar quarters, looking\n<line122>for a tm_isdst different from the one we already have.  */\n<line123>{\n<line124>int quarter;\n<line125>for (quarter = 1; quarter <= 3; quarter++)\n<line126>{\n<line127>time_t probe;\n<line128>if (ckd_add (&probe, Start, quarter * (90 * 24 * 60 * 60)))\n<line129>break;\n<line130>struct tm probe_tm;\n<line131>if (localtime_rz (tz, &probe, &probe_tm) && probe_tm.tm_zone\n<line132>&& probe_tm.tm_isdst != pc.local_time_zone_table[0].value)\n<line133>{\n<line134>{\n<line135>pc.local_time_zone_table[1].name = probe_tm.tm_zone;\n<line136>pc.local_time_zone_table[1].type = tLOCAL_ZONE;\n<line137>pc.local_time_zone_table[1].value = probe_tm.tm_isdst;\n<line138>pc.local_time_zone_table[2].name = NULL;\n<line139>}\n<line140>break;\n<line141>}\n<line142>}\n<line143>}\n<line144>#else\n<line145>#if HAVE_TZNAME\n<line146>{\n<line147># if !HAVE_DECL_TZNAME\n<line148>extern char *tzname[];\n<line149># endif\n<line150>int i;\n<line151>for (i = 0; i < 2; i++)\n<line152>{\n<line153>pc.local_time_zone_table[i].name = tzname[i];\n<line154>pc.local_time_zone_table[i].type = tLOCAL_ZONE;\n<line155>pc.local_time_zone_table[i].value = i;\n<line156>}\n<line157>pc.local_time_zone_table[i].name = NULL;\n<line158>}\n<line159>#else\n<line160>pc.local_time_zone_table[0].name = NULL;\n<line161>#endif\n<line162>#endif\n<line163>if (pc.local_time_zone_table[0].name && pc.local_time_zone_table[1].name\n<line164>&& ! strcmp (pc.local_time_zone_table[0].name,\n<line165>pc.local_time_zone_table[1].name))\n<line166>{\n<line167>/* This locale uses the same abbreviation for standard and\n<line168>daylight times.  So if we see that abbreviation, we don't\n<line169>know whether it's daylight time.  */\n<line170>pc.local_time_zone_table[0].value = -1;\n<line171>pc.local_time_zone_table[1].name = NULL;\n<line172>}\n<line173>if (yyparse (&pc) != 0)\n<line174>{\n<line175>if (debugging (&pc))\n<line176>dbg_printf ((input_sentinel <= pc.input\n<line177>? _("error: parsing failed\n")\n<line178>: _("error: parsing failed, stopped at '%s'\n")),\n<line179>pc.input);\n<line180>goto fail;\n<line181>}\n<line182>/* Determine effective timezone source.  */\n<line183>if (debugging (&pc))\n<line184>{\n<line185>dbg_printf (_("input timezone: "));\n<line186>if (pc.timespec_seen)\n<line187>fprintf (stderr, _("'@timespec' - always UTC"));\n<line188>else if (pc.zones_seen)\n<line189>fprintf (stderr, _("parsed date/time string"));\n<line190>else if (tzstring)\n<line191>{\n<line192>if (tz != tzdefault)\n<line193>fprintf (stderr, _("TZ=\"%s\" in date string"), tzstring);\n<line194>else if (STREQ (tzstring, "UTC0"))\n<line195>{\n<line196>/* Special case: 'date -u' sets TZ="UTC0".  */\n<line197>fprintf (stderr, _("TZ=\"UTC0\" environment value or -u"));\n<line198>}\n<line199>else\n<line200>fprintf (stderr, _("TZ=\"%s\" environment value"), tzstring);\n<line201>}\n<line202>else\n<line203>fprintf (stderr, _("system default"));\n<line204>/* Account for DST changes if tLOCAL_ZONE was seen.\n<line205>local timezone only changes DST and is relative to the\n<line206>default timezone.*/\n<line207>if (pc.local_zones_seen && !pc.zones_seen && 0 < pc.local_isdst)\n<line208>fprintf (stderr, ", dst");\n<line209>if (pc.zones_seen)\n<line210>fprintf (stderr, " (%s)", time_zone_str (pc.time_zone, time_zone_buf));\n<line211>fputc ('\n', stderr);\n<line212>}\n<line213>if (pc.timespec_seen)\n<line214>*result = pc.seconds;\n<line215>else\n<line216>{\n<line217>if (1 < (pc.times_seen | pc.dates_seen | pc.days_seen | pc.dsts_seen\n<line218>| (pc.J_zones_seen + pc.local_zones_seen + pc.zones_seen)))\n<line219>{\n<line220>if (debugging (&pc))\n<line221>{\n<line222>if (pc.times_seen > 1)\n<line223>dbg_printf ("error: seen multiple time parts\n");\n<line224>if (pc.dates_seen > 1)\n<line225>dbg_printf ("error: seen multiple date parts\n");\n<line226>if (pc.days_seen > 1)\n<line227>dbg_printf ("error: seen multiple days parts\n");\n<line228>if (pc.dsts_seen > 1)\n<line229>dbg_printf ("error: seen multiple daylight-saving parts\n");\n<line230>if ((pc.J_zones_seen + pc.local_zones_seen + pc.zones_seen) > 1)\n<line231>dbg_printf ("error: seen multiple time-zone parts\n");\n<line232>}\n<line233>goto fail;\n<line234>}\n<line235>if (! to_tm_year (pc.year, debugging (&pc), &tm.tm_year)\n<line236>|| ckd_add (&tm.tm_mon, pc.month, -1)\n<line237>|| ckd_add (&tm.tm_mday, pc.day, 0))\n<line238>{\n<line239>if (debugging (&pc))\n<line240>dbg_printf (_("error: year, month, or day overflow\n"));\n<line241>goto fail;\n<line242>}\n<line243>if (pc.times_seen || (pc.rels_seen && ! pc.dates_seen && ! pc.days_seen))\n<line244>{\n<line245>tm.tm_hour = to_hour (pc.hour, pc.meridian);\n<line246>if (tm.tm_hour < 0)\n<line247>{\n<line248>char const *mrd = (pc.meridian == MERam ? "am"\n<line249>: pc.meridian == MERpm ?"pm" : "");\n<line250>if (debugging (&pc))\n<line251>dbg_printf (_("error: invalid hour %"PRIdMAX"%s\n"),\n<line252>pc.hour, mrd);\n<line253>goto fail;\n<line254>}\n<line255>tm.tm_min = pc.minutes;\n<line256>tm.tm_sec = pc.seconds.tv_sec;\n<line257>if (debugging (&pc))\n<line258>dbg_printf ((pc.times_seen\n<line259>? _("using specified time as starting value: '%s'\n")\n<line260>: _("using current time as starting value: '%s'\n")),\n<line261>debug_strftime (&tm, dbg_tm, sizeof dbg_tm));\n<line262>}\n<line263>else\n<line264>{\n<line265>tm.tm_hour = tm.tm_min = tm.tm_sec = 0;\n<line266>pc.seconds.tv_nsec = 0;\n<line267>if (debugging (&pc))\n<line268>dbg_printf ("warning: using midnight as starting time: 00:00:00\n");\n<line269>}\n<line270>/* Let mktime deduce tm_isdst if we have an absolute timestamp.  */\n<line271>if (pc.dates_seen | pc.days_seen | pc.times_seen)\n<line272>tm.tm_isdst = -1;\n<line273>/* But if the input explicitly specifies local time with or without\n<line274>DST, give mktime that information.  */\n<line275>if (pc.local_zones_seen)\n<line276>tm.tm_isdst = pc.local_isdst;\n<line277>tm0.tm_sec = tm.tm_sec;\n<line278>tm0.tm_min = tm.tm_min;\n<line279>tm0.tm_hour = tm.tm_hour;\n<line280>tm0.tm_mday = tm.tm_mday;\n<line281>tm0.tm_mon = tm.tm_mon;\n<line282>tm0.tm_year = tm.tm_year;\n<line283>tm0.tm_isdst = tm.tm_isdst;\n<line284>tm.tm_wday = -1;\n<line285>Start = mktime_z (tz, &tm);\n<line286>if (! mktime_ok (&tm0, &tm))\n<line287>{\n<line288>bool repaired = false;\n<line289>bool time_zone_seen = pc.zones_seen != 0;\n<line290>if (time_zone_seen)\n<line291>{\n<line292>/* Guard against falsely reporting errors near the time_t\n<line293>boundaries when parsing times in other time zones.  For\n<line294>example, suppose the input string "1969-12-31 23:00:00 -0100",\n<line295>the current time zone is 8 hours ahead of UTC, and the min\n<line296>time_t value is 1970-01-01 00:00:00 UTC.  Then the min\n<line297>localtime value is 1970-01-01 08:00:00, and mktime will\n<line298>therefore fail on 1969-12-31 23:00:00.  To work around the\n<line299>problem, set the time zone to 1 hour behind UTC temporarily\n<line300>by setting TZ="XXX1:00" and try mktime again.  */\n<line301>char tz2buf[sizeof "XXX" - 1 + TIME_ZONE_BUFSIZE];\n<line302>tz2buf[0] = tz2buf[1] = tz2buf[2] = 'X';\n<line303>time_zone_str (pc.time_zone, &tz2buf[3]);\n<line304>timezone_t tz2 = tzalloc (tz2buf);\n<line305>if (!tz2)\n<line306>{\n<line307>if (debugging (&pc))\n<line308>dbg_printf (_("error: tzalloc (\"%s\") failed\n"), tz2buf);\n<line309>goto fail;\n<line310>}\n<line311>tm.tm_sec = tm0.tm_sec;\n<line312>tm.tm_min = tm0.tm_min;\n<line313>tm.tm_hour = tm0.tm_hour;\n<line314>tm.tm_mday = tm0.tm_mday;\n<line315>tm.tm_mon = tm0.tm_mon;\n<line316>tm.tm_year = tm0.tm_year;\n<line317>tm.tm_isdst = tm0.tm_isdst;\n<line318>tm.tm_wday = -1;\n<line319>Start = mktime_z (tz2, &tm);\n<line320>repaired = mktime_ok (&tm0, &tm);\n<line321>tzfree (tz2);\n<line322>}\n<line323>if (! repaired)\n<line324>{\n<line325>debug_mktime_not_ok (&tm0, &tm, &pc, time_zone_seen);\n<line326>goto fail;\n<line327>}\n<line328>}\n<line329>char dbg_ord[DBGBUFSIZE];\n<line330>if (pc.days_seen && ! pc.dates_seen)\n<line331>{\n<line332>intmax_t dayincr;\n<line333>tm.tm_yday = -1;\n<line334>intmax_t day_ordinal = (pc.day_ordinal\n<line335>- (0 < pc.day_ordinal\n<line336>&& tm.tm_wday != pc.day_number));\n<line337>if (! (ckd_mul (&dayincr, day_ordinal, 7)\n<line338>|| ckd_add (&dayincr, (pc.day_number - tm.tm_wday + 7) % 7,\n<line339>dayincr)\n<line340>|| ckd_add (&tm.tm_mday, dayincr, tm.tm_mday)))\n<line341>{\n<line342>tm.tm_isdst = -1;\n<line343>Start = mktime_z (tz, &tm);\n<line344>}\n<line345>if (tm.tm_yday < 0)\n<line346>{\n<line347>if (debugging (&pc))\n<line348>dbg_printf (_("error: day '%s' "\n<line349>"(day ordinal=%"PRIdMAX" number=%d) "\n<line350>"resulted in an invalid date: '%s'\n"),\n<line351>str_days (&pc, dbg_ord, sizeof dbg_ord),\n<line352>pc.day_ordinal, pc.day_number,\n<line353>debug_strfdatetime (&tm, &pc, dbg_tm,\n<line354>sizeof dbg_tm));\n<line355>goto fail;\n<line356>}\n<line357>if (debugging (&pc))\n<line358>dbg_printf (_("new start date: '%s' is '%s'\n"),\n<line359>str_days (&pc, dbg_ord, sizeof dbg_ord),\n<line360>debug_strfdatetime (&tm, &pc, dbg_tm, sizeof dbg_tm));\n<line361>}\n<line362>if (debugging (&pc))\n<line363>{\n<line364>if (!pc.dates_seen && !pc.days_seen)\n<line365>dbg_printf (_("using current date as starting value: '%s'\n"),\n<line366>debug_strfdate (&tm, dbg_tm, sizeof dbg_tm));\n<line367>if (pc.days_seen && pc.dates_seen)\n<line368>dbg_printf (_("warning: day (%s) ignored when explicit dates "\n<line369>"are given\n"),\n<line370>str_days (&pc, dbg_ord, sizeof dbg_ord));\n<line371>dbg_printf (_("starting date/time: '%s'\n"),\n<line372>debug_strfdatetime (&tm, &pc, dbg_tm, sizeof dbg_tm));\n<line373>}\n<line374>/* Add relative date.  */\n<line375>if (pc.rel.year | pc.rel.month | pc.rel.day)\n<line376>{\n<line377>if (debugging (&pc))\n<line378>{\n<line379>if ((pc.rel.year != 0 || pc.rel.month != 0) && tm.tm_mday != 15)\n<line380>dbg_printf (_("warning: when adding relative months/years, "\n<line381>"it is recommended to specify the 15th of the "\n<line382>"months\n"));\n<line383>if (pc.rel.day != 0 && tm.tm_hour != 12)\n<line384>dbg_printf (_("warning: when adding relative days, "\n<line385>"it is recommended to specify noon\n"));\n<line386>}\n<line387>int year, month, day;\n<line388>if (ckd_add (&year, tm.tm_year, pc.rel.year)\n<line389>|| ckd_add (&month, tm.tm_mon, pc.rel.month)\n<line390>|| ckd_add (&day, tm.tm_mday, pc.rel.day))\n<line391>{\n<line392>if (debugging (&pc))\n<line393>dbg_printf (_("error: %s:%d\n"), __FILE__, __LINE__);\n<line394>goto fail;\n<line395>}\n<line396>tm.tm_year = year;\n<line397>tm.tm_mon = month;\n<line398>tm.tm_mday = day;\n<line399>tm.tm_hour = tm0.tm_hour;\n<line400>tm.tm_min = tm0.tm_min;\n<line401>tm.tm_sec = tm0.tm_sec;\n<line402>tm.tm_isdst = tm0.tm_isdst;\n<line403>tm.tm_wday = -1;\n<line404>Start = mktime_z (tz, &tm);\n<line405>if (tm.tm_wday < 0)\n<line406>{\n<line407>if (debugging (&pc))\n<line408>dbg_printf (_("error: adding relative date resulted "\n<line409>"in an invalid date: '%s'\n"),\n<line410>debug_strfdatetime (&tm, &pc, dbg_tm,\n<line411>sizeof dbg_tm));\n<line412>goto fail;\n<line413>}\n<line414>if (debugging (&pc))\n<line415>{\n<line416>dbg_printf (_("after date adjustment "\n<line417>"(%+"PRIdMAX" years, %+"PRIdMAX" months, "\n<line418>"%+"PRIdMAX" days),\n"),\n<line419>pc.rel.year, pc.rel.month, pc.rel.day);\n<line420>dbg_printf (_("    new date/time = '%s'\n"),\n<line421>debug_strfdatetime (&tm, &pc, dbg_tm,\n<line422>sizeof dbg_tm));\n<line423>/* Warn about crossing DST due to time adjustment.\n<line424>Example: https://bugs.gnu.org/8357\n<line425>env TZ=Europe/Helsinki \\n<line426>date --debug \\n<line427>-d 'Mon Mar 28 00:36:07 2011 EEST 1 day ago'\n<line428>This case is different than DST changes due to time adjustment,\n<line429>i.e., "1 day ago" vs "24 hours ago" are calculated in different\n<line430>places.\n<line431>'tm0.tm_isdst' contains the DST of the input date,\n<line432>'tm.tm_isdst' is the normalized result after calling\n<line433>mktime (&tm).\n<line434>*/\n<line435>if (tm0.tm_isdst != -1 && tm.tm_isdst != tm0.tm_isdst)\n<line436>dbg_printf (_("warning: daylight saving time changed after "\n<line437>"date adjustment\n"));\n<line438>/* Warn if the user did not ask to adjust days but mday changed,\n<line439>or\n<line440>user did not ask to adjust months/days but the month changed.\n<line441>Example for first case:\n<line442>2016-05-31 + 1 month => 2016-06-31 => 2016-07-01.\n<line443>User asked to adjust month, but the day changed from 31 to 01.\n<line444>Example for second case:\n<line445>2016-02-29 + 1 year => 2017-02-29 => 2017-03-01.\n<line446>User asked to adjust year, but the month changed from 02 to 03.\n<line447>*/\n<line448>if (pc.rel.day == 0\n<line449>&& (tm.tm_mday != day\n<line450>|| (pc.rel.month == 0 && tm.tm_mon != month)))\n<line451>{\n<line452>dbg_printf (_("warning: month/year adjustment resulted in "\n<line453>"shifted dates:\n"));\n<line454>char tm_year_buf[TM_YEAR_BUFSIZE];\n<line455>dbg_printf (_("     adjusted Y M D: %s %02d %02d\n"),\n<line456>tm_year_str (year, tm_year_buf), month + 1, day);\n<line457>dbg_printf (_("   normalized Y M D: %s %02d %02d\n"),\n<line458>tm_year_str (tm.tm_year, tm_year_buf),\n<line459>tm.tm_mon + 1, tm.tm_mday);\n<line460>}\n<line461>}\n<line462>}\n<line463>/* The only "output" of this if-block is an updated Start value,\n<line464>so this block must follow others that clobber Start.  */\n<line465>if (pc.zones_seen)\n<line466>{\n<line467>bool overflow = false;\n<line468>#ifdef HAVE_TM_GMTOFF\n<line469>long int utcoff = tm.tm_gmtoff;\n<line470>#else\n<line471>time_t t = Start;\n<line472>struct tm gmt;\n<line473>int utcoff = (gmtime_r (&t, &gmt)\n<line474>? tm_diff (&tm, &gmt)\n<line475>: (overflow = true, 0));\n<line476>#endif\n<line477>intmax_t delta;\n<line478>overflow |= ckd_sub (&delta, pc.time_zone, utcoff);\n<line479>time_t t1;\n<line480>overflow |= ckd_sub (&t1, Start, delta);\n<line481>if (overflow)\n<line482>{\n<line483>if (debugging (&pc))\n<line484>dbg_printf (_("error: timezone %d caused time_t overflow\n"),\n<line485>pc.time_zone);\n<line486>goto fail;\n<line487>}\n<line488>Start = t1;\n<line489>}\n<line490>if (debugging (&pc))\n<line491>{\n<line492>intmax_t Starti = Start;\n<line493>dbg_printf (_("'%s' = %"PRIdMAX" epoch-seconds\n"),\n<line494>debug_strfdatetime (&tm, &pc, dbg_tm, sizeof dbg_tm),\n<line495>Starti);\n<line496>}\n<line497>/* Add relative hours, minutes, and seconds.  On hosts that support\n<line498>leap seconds, ignore the possibility of leap seconds; e.g.,\n<line499>"+ 10 minutes" adds 600 seconds, even if one of them is a\n<line500>leap second.  Typically this is not what the user wants, but it's\n<line501>too hard to do it the other way, because the time zone indicator\n<line502>must be applied before relative times, and if mktime is applied\n<line503>again the time zone will be lost.  */\n<line504>{\n<line505>intmax_t orig_ns = pc.seconds.tv_nsec;\n<line506>intmax_t sum_ns = orig_ns + pc.rel.ns;\n<line507>int normalized_ns = (sum_ns % BILLION + BILLION) % BILLION;\n<line508>int d4 = (sum_ns - normalized_ns) / BILLION;\n<line509>intmax_t d1, t1, d2, t2, t3;\n<line510>time_t t4;\n<line511>if (ckd_mul (&d1, pc.rel.hour, 60 * 60)\n<line512>|| ckd_add (&t1, Start, d1)\n<line513>|| ckd_mul (&d2, pc.rel.minutes, 60)\n<line514>|| ckd_add (&t2, t1, d2)\n<line515>|| ckd_add (&t3, t2, pc.rel.seconds)\n<line516>|| ckd_add (&t4, t3, d4))\n<line517>{\n<line518>if (debugging (&pc))\n<line519>dbg_printf (_("error: adding relative time caused an "\n<line520>"overflow\n"));\n<line521>goto fail;\n<line522>}\n<line523>result->tv_sec = t4;\n<line524>result->tv_nsec = normalized_ns;\n<line525>if (debugging (&pc)\n<line526>&& (pc.rel.hour | pc.rel.minutes | pc.rel.seconds | pc.rel.ns))\n<line527>{\n<line528>dbg_printf (_("after time adjustment (%+"PRIdMAX" hours, "\n<line529>"%+"PRIdMAX" minutes, "\n<line530>"%+"PRIdMAX" seconds, %+d ns),\n"),\n<line531>pc.rel.hour, pc.rel.minutes, pc.rel.seconds,\n<line532>pc.rel.ns);\n<line533>intmax_t t4i = t4;\n<line534>dbg_printf (_("    new time = %"PRIdMAX" epoch-seconds\n"), t4i);\n<line535>/* Warn about crossing DST due to time adjustment.\n<line536>Example: https://bugs.gnu.org/8357\n<line537>env TZ=Europe/Helsinki           \\n<line538>date --debug                                             \\n<line539>-d 'Mon Mar 28 00:36:07 2011 EEST 24 hours ago'\n<line540>This case is different than DST changes due to days adjustment,\n<line541>i.e., "1 day ago" vs "24 hours ago" are calculated in different\n<line542>places.\n<line543>'tm.tm_isdst' contains the date after date adjustment.  */\n<line544>struct tm lmt;\n<line545>if (tm.tm_isdst != -1 && localtime_rz (tz, &result->tv_sec, &lmt)\n<line546>&& tm.tm_isdst != lmt.tm_isdst)\n<line547>dbg_printf (_("warning: daylight saving time changed after "\n<line548>"time adjustment\n"));\n<line549>}\n<line550>}\n<line551>}\n<line552>if (debugging (&pc))\n<line553>{\n<line554>/* Special case: using 'date -u' simply set TZ=UTC0 */\n<line555>if (! tzstring)\n<line556>dbg_printf (_("timezone: system default\n"));\n<line557>else if (STREQ (tzstring, "UTC0"))\n<line558>dbg_printf (_("timezone: Universal Time\n"));\n<line559>else\n<line560>dbg_printf (_("timezone: TZ=\"%s\" environment value\n"), tzstring);\n<line561>intmax_t sec = result->tv_sec;\n<line562>int nsec = result->tv_nsec;\n<line563>dbg_printf (_("final: %"PRIdMAX".%09d (epoch-seconds)\n"),\n<line564>sec, nsec);\n<line565>struct tm gmt, lmt;\n<line566>bool got_utc = !!gmtime_r (&result->tv_sec, &gmt);\n<line567>if (got_utc)\n<line568>dbg_printf (_("final: %s (UTC)\n"),\n<line569>debug_strfdatetime (&gmt, NULL,\n<line570>dbg_tm, sizeof dbg_tm));\n<line571>if (localtime_rz (tz, &result->tv_sec, &lmt))\n<line572>{\n<line573>#ifdef HAVE_TM_GMTOFF\n<line574>bool got_utcoff = true;\n<line575>long int utcoff = lmt.tm_gmtoff;\n<line576>#else\n<line577>bool got_utcoff = got_utc;\n<line578>int utcoff;\n<line579>if (got_utcoff)\n<line580>utcoff = tm_diff (&lmt, &gmt);\n<line581>#endif\n<line582>if (got_utcoff)\n<line583>dbg_printf (_("final: %s (UTC%s)\n"),\n<line584>debug_strfdatetime (&lmt, NULL, dbg_tm, sizeof dbg_tm),\n<line585>time_zone_str (utcoff, time_zone_buf));\n<line586>else\n<line587>dbg_printf (_("final: %s (unknown time zone offset)\n"),\n<line588>debug_strfdatetime (&lmt, NULL, dbg_tm, sizeof dbg_tm));\n<line589>}\n<line590>}\n<line591>ok = true;\n<line592>fail:\n<line593>if (tz != tzdefault)\n<line594>tzfree (tz);\n<line595>free (tz1alloc);\n<line596>return ok;\n<line597>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/physmem.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
Function: physmem_total
Content: <line0>double\n<line1>physmem_total (void)\n<line2>{\n<line3>#if defined _SC_PHYS_PAGES && defined _SC_PAGESIZE\n<line4>{ /* This works on linux-gnu, kfreebsd-gnu, solaris2, and cygwin.  */\n<line5>double pages = sysconf (_SC_PHYS_PAGES);\n<line6>double pagesize = sysconf (_SC_PAGESIZE);\n<line7>if (0 <= pages && 0 <= pagesize)\n<line8>return pages * pagesize;\n<line9>}\n<line10>#endif\n<line11>#if HAVE_SYSINFO && HAVE_STRUCT_SYSINFO_MEM_UNIT\n<line12>{ /* This works on linux.  */\n<line13>struct sysinfo si;\n<line14>if (sysinfo(&si) == 0)\n<line15>return (double) si.totalram * si.mem_unit;\n<line16>}\n<line17>#endif\n<line18>#if HAVE_PSTAT_GETSTATIC\n<line19>{ /* This works on hpux11.  */\n<line20>struct pst_static pss;\n<line21>if (0 <= pstat_getstatic (&pss, sizeof pss, 1, 0))\n<line22>{\n<line23>double pages = pss.physical_memory;\n<line24>double pagesize = pss.page_size;\n<line25>if (0 <= pages && 0 <= pagesize)\n<line26>return pages * pagesize;\n<line27>}\n<line28>}\n<line29>#endif\n<line30>#if HAVE_SYSMP && defined MP_SAGET && defined MPSA_RMINFO && defined _SC_PAGESIZE\n<line31>{ /* This works on irix6. */\n<line32>struct rminfo realmem;\n<line33>if (sysmp (MP_SAGET, MPSA_RMINFO, &realmem, sizeof realmem) == 0)\n<line34>{\n<line35>double pagesize = sysconf (_SC_PAGESIZE);\n<line36>double pages = realmem.physmem;\n<line37>if (0 <= pages && 0 <= pagesize)\n<line38>return pages * pagesize;\n<line39>}\n<line40>}\n<line41>#endif\n<line42>#if HAVE_GETSYSINFO && defined GSI_PHYSMEM\n<line43>{ /* This works on Tru64 UNIX V4/5.  */\n<line44>int physmem;\n<line45>if (getsysinfo (GSI_PHYSMEM, (caddr_t) &physmem, sizeof (physmem),\n<line46>NULL, NULL, NULL) == 1)\n<line47>{\n<line48>double kbytes = physmem;\n<line49>if (0 <= kbytes)\n<line50>return kbytes * 1024.0;\n<line51>}\n<line52>}\n<line53>#endif\n<line54>#if HAVE_SYSCTL && !(defined __GLIBC__ && defined __linux__) && defined HW_PHYSMEM\n<line55>{ /* This works on *bsd, kfreebsd-gnu, and darwin.  */\n<line56>unsigned int physmem;\n<line57>size_t len = sizeof physmem;\n<line58>static int mib[2] = { CTL_HW, HW_PHYSMEM };\n<line59>if (sysctl (mib, ARRAY_SIZE (mib), &physmem, &len, NULL, 0) == 0\n<line60>&& len == sizeof (physmem))\n<line61>return (double) physmem;\n<line62>}\n<line63>#endif\n<line64>#if HAVE__SYSTEM_CONFIGURATION\n<line65>/* This works on AIX.  */\n<line66>return _system_configuration.physmem;\n<line67>#endif\n<line68>#if defined _WIN32\n<line69>{ /* this works on windows */\n<line70>PFN_MS_EX pfnex;\n<line71>HMODULE h = GetModuleHandle ("kernel32.dll");\n<line72>if (!h)\n<line73>return 0.0;\n<line74>/*  Use GlobalMemoryStatusEx if available.  */\n<line75>if ((pfnex = (PFN_MS_EX) GetProcAddress (h, "GlobalMemoryStatusEx")))\n<line76>{\n<line77>lMEMORYSTATUSEX lms_ex;\n<line78>lms_ex.dwLength = sizeof lms_ex;\n<line79>if (!pfnex (&lms_ex))\n<line80>return 0.0;\n<line81>return (double) lms_ex.ullTotalPhys;\n<line82>}\n<line83>/*  Fall back to GlobalMemoryStatus which is always available.\n<line84>but returns wrong results for physical memory > 4GB.  */\n<line85>else\n<line86>{\n<line87>MEMORYSTATUS ms;\n<line88>GlobalMemoryStatus (&ms);\n<line89>return (double) ms.dwTotalPhys;\n<line90>}\n<line91>}\n<line92>#endif\n<line93>/* Guess 64 MB.  It's probably an older host, so guess small.  */\n<line94>return 64 * 1024 * 1024;\n<line95>}
----------------------------------------
Function: physmem_available
Content: <line0>double\n<line1>physmem_available (void)\n<line2>{\n<line3>#if defined _SC_AVPHYS_PAGES && defined _SC_PAGESIZE\n<line4>{ /* This works on linux-gnu, kfreebsd-gnu, solaris2, and cygwin.  */\n<line5>double pages = sysconf (_SC_AVPHYS_PAGES);\n<line6>double pagesize = sysconf (_SC_PAGESIZE);\n<line7>if (0 <= pages && 0 <= pagesize)\n<line8>return pages * pagesize;\n<line9>}\n<line10>#endif\n<line11>#if HAVE_SYSINFO && HAVE_STRUCT_SYSINFO_MEM_UNIT\n<line12>{ /* This works on linux.  */\n<line13>struct sysinfo si;\n<line14>if (sysinfo(&si) == 0)\n<line15>return ((double) si.freeram + si.bufferram) * si.mem_unit;\n<line16>}\n<line17>#endif\n<line18>#if HAVE_PSTAT_GETSTATIC && HAVE_PSTAT_GETDYNAMIC\n<line19>{ /* This works on hpux11.  */\n<line20>struct pst_static pss;\n<line21>struct pst_dynamic psd;\n<line22>if (0 <= pstat_getstatic (&pss, sizeof pss, 1, 0)\n<line23>&& 0 <= pstat_getdynamic (&psd, sizeof psd, 1, 0))\n<line24>{\n<line25>double pages = psd.psd_free;\n<line26>double pagesize = pss.page_size;\n<line27>if (0 <= pages && 0 <= pagesize)\n<line28>return pages * pagesize;\n<line29>}\n<line30>}\n<line31>#endif\n<line32>#if HAVE_SYSMP && defined MP_SAGET && defined MPSA_RMINFO && defined _SC_PAGESIZE\n<line33>{ /* This works on irix6. */\n<line34>struct rminfo realmem;\n<line35>if (sysmp (MP_SAGET, MPSA_RMINFO, &realmem, sizeof realmem) == 0)\n<line36>{\n<line37>double pagesize = sysconf (_SC_PAGESIZE);\n<line38>double pages = realmem.availrmem;\n<line39>if (0 <= pages && 0 <= pagesize)\n<line40>return pages * pagesize;\n<line41>}\n<line42>}\n<line43>#endif\n<line44>#if HAVE_TABLE && defined TBL_VMSTATS\n<line45>{ /* This works on Tru64 UNIX V4/5.  */\n<line46>struct tbl_vmstats vmstats;\n<line47>if (table (TBL_VMSTATS, 0, &vmstats, 1, sizeof (vmstats)) == 1)\n<line48>{\n<line49>double pages = vmstats.free_count;\n<line50>double pagesize = vmstats.pagesize;\n<line51>if (0 <= pages && 0 <= pagesize)\n<line52>return pages * pagesize;\n<line53>}\n<line54>}\n<line55>#endif\n<line56>#if HAVE_SYSCTL && !(defined __GLIBC__ && defined __linux__) && defined HW_USERMEM\n<line57>{ /* This works on *bsd, kfreebsd-gnu, and darwin.  */\n<line58>unsigned int usermem;\n<line59>size_t len = sizeof usermem;\n<line60>static int mib[2] = { CTL_HW, HW_USERMEM };\n<line61>if (sysctl (mib, ARRAY_SIZE (mib), &usermem, &len, NULL, 0) == 0\n<line62>&& len == sizeof (usermem))\n<line63>return (double) usermem;\n<line64>}\n<line65>#endif\n<line66>#if defined _WIN32\n<line67>{ /* this works on windows */\n<line68>PFN_MS_EX pfnex;\n<line69>HMODULE h = GetModuleHandle ("kernel32.dll");\n<line70>if (!h)\n<line71>return 0.0;\n<line72>/*  Use GlobalMemoryStatusEx if available.  */\n<line73>if ((pfnex = (PFN_MS_EX) GetProcAddress (h, "GlobalMemoryStatusEx")))\n<line74>{\n<line75>lMEMORYSTATUSEX lms_ex;\n<line76>lms_ex.dwLength = sizeof lms_ex;\n<line77>if (!pfnex (&lms_ex))\n<line78>return 0.0;\n<line79>return (double) lms_ex.ullAvailPhys;\n<line80>}\n<line81>/*  Fall back to GlobalMemoryStatus which is always available.\n<line82>but returns wrong results for physical memory > 4GB  */\n<line83>else\n<line84>{\n<line85>MEMORYSTATUS ms;\n<line86>GlobalMemoryStatus (&ms);\n<line87>return (double) ms.dwAvailPhys;\n<line88>}\n<line89>}\n<line90>#endif\n<line91>/* Guess 25% of physical memory.  */\n<line92>return physmem_total () / 4;\n<line93>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/pipe2.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
Function: rpl_pipe2
Content: <line0>int\n<line1>pipe2 (int fd[2], int flags)\n<line2>{\n<line3>/* Mingw _pipe() corrupts fd on failure; also, if we succeed at\n<line4>creating the pipe but later fail at changing fcntl, we want\n<line5>to leave fd unchanged: http://austingroupbugs.net/view.php?id=467  */\n<line6>int tmp[2];\n<line7>tmp[0] = fd[0];\n<line8>tmp[1] = fd[1];\n<line9>#if HAVE_PIPE2\n<line10># undef pipe2\n<line11>/* Try the system call first, if it exists.  (We may be running with a glibc\n<line12>that has the function but with an older kernel that lacks it.)  */\n<line13>{\n<line14>/* Cache the information whether the system call really exists.  */\n<line15>static int have_pipe2_really; /* 0 = unknown, 1 = yes, -1 = no */\n<line16>if (have_pipe2_really >= 0)\n<line17>{\n<line18>int result = pipe2 (fd, flags);\n<line19>if (!(result < 0 && errno == ENOSYS))\n<line20>{\n<line21>have_pipe2_really = 1;\n<line22>return result;\n<line23>}\n<line24>have_pipe2_really = -1;\n<line25>}\n<line26>}\n<line27>#endif\n<line28>/* Check the supported flags.  */\n<line29>if ((flags & ~(O_CLOEXEC | O_NONBLOCK | O_BINARY | O_TEXT)) != 0)\n<line30>{\n<line31>errno = EINVAL;\n<line32>return -1;\n<line33>}\n<line34>#if defined _WIN32 && ! defined __CYGWIN__\n<line35>/* Native Windows API.  */\n<line36>if (_pipe (fd, 4096, flags & ~O_NONBLOCK) < 0)\n<line37>{\n<line38>fd[0] = tmp[0];\n<line39>fd[1] = tmp[1];\n<line40>return -1;\n<line41>}\n<line42>/* O_NONBLOCK handling.\n<line43>On native Windows platforms, O_NONBLOCK is defined by gnulib.  Use the\n<line44>functions defined by the gnulib module 'nonblocking'.  */\n<line45># if GNULIB_defined_O_NONBLOCK\n<line46>if (flags & O_NONBLOCK)\n<line47>{\n<line48>if (set_nonblocking_flag (fd[0], true) != 0\n<line49>|| set_nonblocking_flag (fd[1], true) != 0)\n<line50>goto fail;\n<line51>}\n<line52># else\n<line53>{\n<line54>static_assert (O_NONBLOCK == 0);\n<line55>}\n<line56># endif\n<line57>return 0;\n<line58>#else\n<line59>/* Unix API.  */\n<line60>if (pipe (fd) < 0)\n<line61>return -1;\n<line62>/* POSIX <https://pubs.opengroup.org/onlinepubs/9699919799/functions/pipe.html>\n<line63>says that initially, the O_NONBLOCK and FD_CLOEXEC flags are cleared on\n<line64>both fd[0] and fd[1].  */\n<line65>/* O_NONBLOCK handling.\n<line66>On Unix platforms, O_NONBLOCK is defined by the system.  Use fcntl().  */\n<line67>if (flags & O_NONBLOCK)\n<line68>{\n<line69>int fcntl_flags;\n<line70>if ((fcntl_flags = fcntl (fd[1], F_GETFL, 0)) < 0\n<line71>|| fcntl (fd[1], F_SETFL, fcntl_flags | O_NONBLOCK) == -1\n<line72>|| (fcntl_flags = fcntl (fd[0], F_GETFL, 0)) < 0\n<line73>|| fcntl (fd[0], F_SETFL, fcntl_flags | O_NONBLOCK) == -1)\n<line74>goto fail;\n<line75>}\n<line76>if (flags & O_CLOEXEC)\n<line77>{\n<line78>int fcntl_flags;\n<line79>if ((fcntl_flags = fcntl (fd[1], F_GETFD, 0)) < 0\n<line80>|| fcntl (fd[1], F_SETFD, fcntl_flags | FD_CLOEXEC) == -1\n<line81>|| (fcntl_flags = fcntl (fd[0], F_GETFD, 0)) < 0\n<line82>|| fcntl (fd[0], F_SETFD, fcntl_flags | FD_CLOEXEC) == -1)\n<line83>goto fail;\n<line84>}\n<line85># if O_BINARY\n<line86>if (flags & O_BINARY)\n<line87>{\n<line88>set_binary_mode (fd[1], O_BINARY);\n<line89>set_binary_mode (fd[0], O_BINARY);\n<line90>}\n<line91>else if (flags & O_TEXT)\n<line92>{\n<line93>set_binary_mode (fd[1], O_TEXT);\n<line94>set_binary_mode (fd[0], O_TEXT);\n<line95>}\n<line96># endif\n<line97>return 0;\n<line98>#endif\n<line99>#if GNULIB_defined_O_NONBLOCK || !(defined _WIN32 && ! defined __CYGWIN__)\n<line100>fail:\n<line101>{\n<line102>int saved_errno = errno;\n<line103>close (fd[0]);\n<line104>close (fd[1]);\n<line105>fd[0] = tmp[0];\n<line106>fd[1] = tmp[1];\n<line107>errno = saved_errno;\n<line108>return -1;\n<line109>}\n<line110>#endif\n<line111>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/posixtm.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
Function: year
Content: <line0>static bool\n<line1>year (struct tm *tm, const int *digit_pair, idx_t n, unsigned int syntax_bits)\n<line2>{\n<line3>switch (n)\n<line4>{\n<line5>case 1:\n<line6>tm->tm_year = *digit_pair;\n<line7>/* Deduce the century based on the year.\n<line8>POSIX requires that 00-68 be interpreted as 2000-2068,\n<line9>and that 69-99 be interpreted as 1969-1999.  */\n<line10>if (digit_pair[0] <= 68)\n<line11>{\n<line12>if (syntax_bits & PDS_PRE_2000)\n<line13>return false;\n<line14>tm->tm_year += 100;\n<line15>}\n<line16>break;\n<line17>case 2:\n<line18>if (! (syntax_bits & PDS_CENTURY))\n<line19>return false;\n<line20>tm->tm_year = digit_pair[0] * 100 + digit_pair[1] - 1900;\n<line21>break;\n<line22>case 0:\n<line23>{\n<line24>/* Use current year.  */\n<line25>time_t now = time (NULL);\n<line26>struct tm *tmp = localtime (&now);\n<line27>if (! tmp)\n<line28>return false;\n<line29>tm->tm_year = tmp->tm_year;\n<line30>}\n<line31>break;\n<line32>default:\n<line33>assume (false);\n<line34>}\n<line35>return true;\n<line36>}
----------------------------------------
Function: posix_time_parse
Content: <line0>static bool\n<line1>posix_time_parse (struct tm *tm, const char *s, unsigned int syntax_bits)\n<line2>{\n<line3>const char *dot = NULL;\n<line4>int pair[6];\n<line5>idx_t s_len = strlen (s);\n<line6>idx_t len = s_len;\n<line7>if (syntax_bits & PDS_SECONDS)\n<line8>{\n<line9>dot = strchr (s, '.');\n<line10>if (dot)\n<line11>{\n<line12>len = dot - s;\n<line13>if (s_len - len != 3)\n<line14>return false;\n<line15>}\n<line16>}\n<line17>if (! (8 <= len && len <= 12 && len % 2 == 0))\n<line18>return false;\n<line19>for (idx_t i = 0; i < len; i++)\n<line20>if (!c_isdigit (s[i]))\n<line21>return false;\n<line22>len /= 2;\n<line23>for (idx_t i = 0; i < len; i++)\n<line24>pair[i] = 10 * (s[2*i] - '0') + s[2*i + 1] - '0';\n<line25>int *p = pair;\n<line26>if (! (syntax_bits & PDS_TRAILING_YEAR))\n<line27>{\n<line28>if (! year (tm, p, len - 4, syntax_bits))\n<line29>return false;\n<line30>p += len - 4;\n<line31>len = 4;\n<line32>}\n<line33>/* Handle 8 digits worth of 'MMDDhhmm'.  */\n<line34>tm->tm_mon = *p++ - 1;\n<line35>tm->tm_mday = *p++;\n<line36>tm->tm_hour = *p++;\n<line37>tm->tm_min = *p++;\n<line38>len -= 4;\n<line39>/* Handle any trailing year.  */\n<line40>if (syntax_bits & PDS_TRAILING_YEAR)\n<line41>{\n<line42>if (! year (tm, p, len, syntax_bits))\n<line43>return false;\n<line44>}\n<line45>/* Handle seconds.  */\n<line46>if (!dot)\n<line47>tm->tm_sec = 0;\n<line48>else if (c_isdigit (dot[1]) && c_isdigit (dot[2]))\n<line49>tm->tm_sec = 10 * (dot[1] - '0') + dot[2] - '0';\n<line50>else\n<line51>return false;\n<line52>return true;\n<line53>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/posixver.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
Function: posix2_version
Content: <line0>int\n<line1>posix2_version (void)\n<line2>{\n<line3>long int v = DEFAULT_POSIX2_VERSION;\n<line4>char const *s = getenv ("_POSIX2_VERSION");\n<line5>if (s && *s)\n<line6>{\n<line7>char *e;\n<line8>long int i = strtol (s, &e, 10);\n<line9>if (! *e)\n<line10>v = i;\n<line11>}\n<line12>return v < INT_MIN ? INT_MIN : v < INT_MAX ? v : INT_MAX;\n<line13>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/printf-frexp.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
========================================
/home/huihui/Downloads/coreutils-9.4/lib/printf-frexpl.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
========================================
/home/huihui/Downloads/coreutils-9.4/lib/priv-set.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
========================================
/home/huihui/Downloads/coreutils-9.4/lib/progname.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
Function: set_program_name
Content: <line0>void\n<line1>set_program_name (const char *argv0)\n<line2>{\n<line3>/* libtool creates a temporary executable whose name is sometimes prefixed\n<line4>with "lt-" (depends on the platform).  It also makes argv[0] absolute.\n<line5>But the name of the temporary executable is a detail that should not be\n<line6>visible to the end user and to the test suite.\n<line7>Remove this "<dirname>/.libs/" or "<dirname>/.libs/lt-" prefix here.  */\n<line8>const char *slash;\n<line9>const char *base;\n<line10>/* Sanity check.  POSIX requires the invoking process to pass a non-NULL\n<line11>argv[0].  */\n<line12>if (argv0 == NULL)\n<line13>{\n<line14>/* It's a bug in the invoking program.  Help diagnosing it.  */\n<line15>fputs ("A NULL argv[0] was passed through an exec system call.\n",\n<line16>stderr);\n<line17>abort ();\n<line18>}\n<line19>slash = strrchr (argv0, '/');\n<line20>base = (slash != NULL ? slash + 1 : argv0);\n<line21>if (base - argv0 >= 7 && strncmp (base - 7, "/.libs/", 7) == 0)\n<line22>{\n<line23>argv0 = base;\n<line24>if (strncmp (base, "lt-", 3) == 0)\n<line25>{\n<line26>argv0 = base + 3;\n<line27>/* On glibc systems, remove the "lt-" prefix from the variable\n<line28>program_invocation_short_name.  */\n<line29>#if HAVE_DECL_PROGRAM_INVOCATION_SHORT_NAME\n<line30>program_invocation_short_name = (char *) argv0;\n<line31>#endif\n<line32>}\n<line33>}\n<line34>/* But don't strip off a leading <dirname>/ in general, because when the user\n<line35>runs\n<line36>/some/hidden/place/bin/cp foo foo\n<line37>he should get the error message\n<line38>/some/hidden/place/bin/cp: `foo' and `foo' are the same file\n<line39>not\n<line40>cp: `foo' and `foo' are the same file\n<line41>*/\n<line42>program_name = argv0;\n<line43>/* On glibc systems, the error() function comes from libc and uses the\n<line44>variable program_invocation_name, not program_name.  So set this variable\n<line45>as well.  */\n<line46>#if HAVE_DECL_PROGRAM_INVOCATION_NAME\n<line47>program_invocation_name = (char *) argv0;\n<line48>#endif\n<line49>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/propername-lite.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
Function: proper_name_lite
Content: <line0>char const *\n<line1>proper_name_lite (char const *name_ascii, char const *name_utf8)\n<line2>{\n<line3>char const *translation = gettext (name_ascii);\n<line4>return (translation != name_ascii ? translation\n<line5>: c_strcasecmp (locale_charset (), "UTF-8") == 0 ? name_utf8\n<line6>: name_ascii);\n<line7>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/qcopy-acl.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
Function: qcopy_acl
Content: <line0>int\n<line1>qcopy_acl (const char *src_name, int source_desc, const char *dst_name,\n<line2>int dest_desc, mode_t mode)\n<line3>{\n<line4>int ret;\n<line5>#ifdef USE_XATTR\n<line6>/* in case no ACLs present and also to set higher mode bits\n<line7>we chmod before setting ACLs as doing it after could overwrite them\n<line8>(especially true for NFSv4, posix ACL has that ugly "mask" hack that\n<line9>nobody understands) */\n<line10>ret = chmod_or_fchmod (dst_name, dest_desc, mode);\n<line11>/* Rather than fiddling with acls one by one, we just copy the whole ACL xattrs\n<line12>(Posix or NFSv4). Of course, that won't address ACLs conversion\n<line13>(i.e. posix <-> nfs4) but we can't do it anyway, so for now, we don't care\n<line14>Functions attr_copy_* return 0 in case we copied something OR nothing\n<line15>to copy */\n<line16>if (ret == 0)\n<line17>ret = source_desc <= 0 || dest_desc <= 0\n<line18>? attr_copy_file (src_name, dst_name, is_attr_permissions, NULL)\n<line19>: attr_copy_fd (src_name, source_desc, dst_name, dest_desc,\n<line20>is_attr_permissions, NULL);\n<line21>#else\n<line22>/* no XATTR, so we proceed the old dusty way */\n<line23>struct permission_context ctx;\n<line24>ret = get_permissions (src_name, source_desc, mode, &ctx);\n<line25>if (ret != 0)\n<line26>return -2;\n<line27>ret = set_permissions (&ctx, dst_name, dest_desc);\n<line28>free_permission_context (&ctx);\n<line29>#endif\n<line30>return ret;\n<line31>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/qset-acl.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
Function: qset_acl
Content: <line0>int\n<line1>qset_acl (char const *name, int desc, mode_t mode)\n<line2>{\n<line3>struct permission_context ctx;\n<line4>int ret;\n<line5>memset (&ctx, 0, sizeof ctx);\n<line6>ctx.mode = mode;\n<line7>ret = set_permissions (&ctx, name, desc);\n<line8>free_permission_context (&ctx);\n<line9>return ret;\n<line10>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/quotearg.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
Function: clone_quoting_options
Content: <line0>struct quoting_options *\n<line1>clone_quoting_options (struct quoting_options *o)\n<line2>{\n<line3>int e = errno;\n<line4>struct quoting_options *p = xmemdup (o ? o : &default_quoting_options,\n<line5>sizeof *o);\n<line6>errno = e;\n<line7>return p;\n<line8>}
----------------------------------------
Function: get_quoting_style
Content: <line0>enum quoting_style\n<line1>get_quoting_style (struct quoting_options const *o)\n<line2>{\n<line3>return (o ? o : &default_quoting_options)->style;\n<line4>}
----------------------------------------
Function: set_quoting_style
Content: <line0>void\n<line1>set_quoting_style (struct quoting_options *o, enum quoting_style s)\n<line2>{\n<line3>(o ? o : &default_quoting_options)->style = s;\n<line4>}
----------------------------------------
Function: set_char_quoting
Content: <line0>int\n<line1>set_char_quoting (struct quoting_options *o, char c, int i)\n<line2>{\n<line3>unsigned char uc = c;\n<line4>unsigned int *p =\n<line5>(o ? o : &default_quoting_options)->quote_these_too + uc / INT_BITS;\n<line6>int shift = uc % INT_BITS;\n<line7>int r = (*p >> shift) & 1;\n<line8>*p ^= ((i & 1) ^ r) << shift;\n<line9>return r;\n<line10>}
----------------------------------------
Function: set_quoting_flags
Content: <line0>int\n<line1>set_quoting_flags (struct quoting_options *o, int i)\n<line2>{\n<line3>int r;\n<line4>if (!o)\n<line5>o = &default_quoting_options;\n<line6>r = o->flags;\n<line7>o->flags = i;\n<line8>return r;\n<line9>}
----------------------------------------
Function: set_custom_quoting
Content: <line0>void\n<line1>set_custom_quoting (struct quoting_options *o,\n<line2>char const *left_quote, char const *right_quote)\n<line3>{\n<line4>if (!o)\n<line5>o = &default_quoting_options;\n<line6>o->style = custom_quoting_style;\n<line7>if (!left_quote || !right_quote)\n<line8>abort ();\n<line9>o->left_quote = left_quote;\n<line10>o->right_quote = right_quote;\n<line11>}
----------------------------------------
Function: quoting_options_from_style
Content: <line0>static struct quoting_options /* NOT PURE!! */\n<line1>quoting_options_from_style (enum quoting_style style)\n<line2>{\n<line3>struct quoting_options o = { literal_quoting_style, 0, { 0 }, NULL, NULL };\n<line4>if (style == custom_quoting_style)\n<line5>abort ();\n<line6>o.style = style;\n<line7>return o;\n<line8>}
----------------------------------------
Function: gettext_quote
Content: <line0>static char const *\n<line1>gettext_quote (char const *msgid, enum quoting_style s)\n<line2>{\n<line3>char const *translation = _(msgid);\n<line4>char const *locale_code;\n<line5>if (translation != msgid)\n<line6>return translation;\n<line7>/* For UTF-8 and GB-18030, use single quotes U+2018 and U+2019.\n<line8>Here is a list of other locales that include U+2018 and U+2019:\n<line9>ISO-8859-7   0xA1                 KOI8-T       0x91\n<line10>CP869        0x8B                 CP874        0x91\n<line11>CP932        0x81 0x65            CP936        0xA1 0xAE\n<line12>CP949        0xA1 0xAE            CP950        0xA1 0xA5\n<line13>CP1250       0x91                 CP1251       0x91\n<line14>CP1252       0x91                 CP1253       0x91\n<line15>CP1254       0x91                 CP1255       0x91\n<line16>CP1256       0x91                 CP1257       0x91\n<line17>EUC-JP       0xA1 0xC6            EUC-KR       0xA1 0xAE\n<line18>EUC-TW       0xA1 0xE4            BIG5         0xA1 0xA5\n<line19>BIG5-HKSCS   0xA1 0xA5            EUC-CN       0xA1 0xAE\n<line20>GBK          0xA1 0xAE            Georgian-PS  0x91\n<line21>PT154        0x91\n<line22>None of these is still in wide use; using iconv is overkill.  */\n<line23>locale_code = locale_charset ();\n<line24>if (STRCASEEQ (locale_code, "UTF-8", 'U','T','F','-','8',0,0,0,0))\n<line25>return msgid[0] == '`' ? "\xe2\x80\x98": "\xe2\x80\x99";\n<line26>if (STRCASEEQ (locale_code, "GB18030", 'G','B','1','8','0','3','0',0,0))\n<line27>return msgid[0] == '`' ? "\xa1\ae": "\xa1\xaf";\n<line28>return (s == clocale_quoting_style ? "\"" : "'");\n<line29>}
----------------------------------------
Function: quotearg_buffer_restyled
Content: <line0>static size_t\n<line1>quotearg_buffer_restyled (char *buffer, size_t buffersize,\n<line2>char const *arg, size_t argsize,\n<line3>enum quoting_style quoting_style, int flags,\n<line4>unsigned int const *quote_these_too,\n<line5>char const *left_quote,\n<line6>char const *right_quote)\n<line7>{\n<line8>size_t i;\n<line9>size_t len = 0;\n<line10>size_t orig_buffersize = 0;\n<line11>char const *quote_string = 0;\n<line12>size_t quote_string_len = 0;\n<line13>bool backslash_escapes = false;\n<line14>bool unibyte_locale = MB_CUR_MAX == 1;\n<line15>bool elide_outer_quotes = (flags & QA_ELIDE_OUTER_QUOTES) != 0;\n<line16>bool pending_shell_escape_end = false;\n<line17>bool encountered_single_quote = false;\n<line18>bool all_c_and_shell_quote_compat = true;\n<line19>#define STORE(c) \\n<line20>do \\n<line21>{ \\n<line22>if (len < buffersize) \\n<line23>buffer[len] = (c); \\n<line24>len++; \\n<line25>} \\n<line26>while (0)\n<line27>#define START_ESC() \\n<line28>do \\n<line29>{ \\n<line30>if (elide_outer_quotes) \\n<line31>goto force_outer_quoting_style; \\n<line32>escaping = true; \\n<line33>if (quoting_style == shell_always_quoting_style \\n<line34>&& ! pending_shell_escape_end) \\n<line35>{ \\n<line36>STORE ('\''); \\n<line37>STORE ('$'); \\n<line38>STORE ('\''); \\n<line39>pending_shell_escape_end = true; \\n<line40>} \\n<line41>STORE ('\\'); \\n<line42>} \\n<line43>while (0)\n<line44>#define END_ESC() \\n<line45>do \\n<line46>{ \\n<line47>if (pending_shell_escape_end && ! escaping) \\n<line48>{ \\n<line49>STORE ('\''); \\n<line50>STORE ('\''); \\n<line51>pending_shell_escape_end = false; \\n<line52>} \\n<line53>} \\n<line54>while (0)\n<line55>process_input:\n<line56>switch (quoting_style)\n<line57>{\n<line58>case c_maybe_quoting_style:\n<line59>quoting_style = c_quoting_style;\n<line60>elide_outer_quotes = true;\n<line61>FALLTHROUGH;\n<line62>case c_quoting_style:\n<line63>if (!elide_outer_quotes)\n<line64>STORE ('"');\n<line65>backslash_escapes = true;\n<line66>quote_string = "\"";\n<line67>quote_string_len = 1;\n<line68>break;\n<line69>case escape_quoting_style:\n<line70>backslash_escapes = true;\n<line71>elide_outer_quotes = false;\n<line72>break;\n<line73>case locale_quoting_style:\n<line74>case clocale_quoting_style:\n<line75>case custom_quoting_style:\n<line76>{\n<line77>if (quoting_style != custom_quoting_style)\n<line78>{\n<line79>/* TRANSLATORS:\n<line80>Get translations for open and closing quotation marks.\n<line81>The message catalog should translate "`" to a left\n<line82>quotation mark suitable for the locale, and similarly for\n<line83>"'".  For example, a French Unicode local should translate\n<line84>these to U+00AB (LEFT-POINTING DOUBLE ANGLE\n<line85>QUOTATION MARK), and U+00BB (RIGHT-POINTING DOUBLE ANGLE\n<line86>QUOTATION MARK), respectively.\n<line87>If the catalog has no translation, we will try to\n<line88>use Unicode U+2018 (LEFT SINGLE QUOTATION MARK) and\n<line89>Unicode U+2019 (RIGHT SINGLE QUOTATION MARK).  If the\n<line90>current locale is not Unicode, locale_quoting_style\n<line91>will quote 'like this', and clocale_quoting_style will\n<line92>quote "like this".  You should always include translations\n<line93>for "`" and "'" even if U+2018 and U+2019 are appropriate\n<line94>for your locale.\n<line95>If you don't know what to put here, please see\n<line96><https://en.wikipedia.org/wiki/Quotation_marks_in_other_languages>\n<line97>and use glyphs suitable for your language.  */\n<line98>left_quote = gettext_quote (N_("`"), quoting_style);\n<line99>right_quote = gettext_quote (N_("'"), quoting_style);\n<line100>}\n<line101>if (!elide_outer_quotes)\n<line102>for (quote_string = left_quote; *quote_string; quote_string++)\n<line103>STORE (*quote_string);\n<line104>backslash_escapes = true;\n<line105>quote_string = right_quote;\n<line106>quote_string_len = strlen (quote_string);\n<line107>}\n<line108>break;\n<line109>case shell_escape_quoting_style:\n<line110>backslash_escapes = true;\n<line111>FALLTHROUGH;\n<line112>case shell_quoting_style:\n<line113>elide_outer_quotes = true;\n<line114>FALLTHROUGH;\n<line115>case shell_escape_always_quoting_style:\n<line116>if (!elide_outer_quotes)\n<line117>backslash_escapes = true;\n<line118>FALLTHROUGH;\n<line119>case shell_always_quoting_style:\n<line120>quoting_style = shell_always_quoting_style;\n<line121>if (!elide_outer_quotes)\n<line122>STORE ('\'');\n<line123>quote_string = "'";\n<line124>quote_string_len = 1;\n<line125>break;\n<line126>case literal_quoting_style:\n<line127>elide_outer_quotes = false;\n<line128>break;\n<line129>default:\n<line130>abort ();\n<line131>}\n<line132>for (i = 0;  ! (argsize == SIZE_MAX ? arg[i] == '\0' : i == argsize);  i++)\n<line133>{\n<line134>unsigned char c;\n<line135>unsigned char esc;\n<line136>bool is_right_quote = false;\n<line137>bool escaping = false;\n<line138>bool c_and_shell_quote_compat = false;\n<line139>if (backslash_escapes\n<line140>&& quoting_style != shell_always_quoting_style\n<line141>&& quote_string_len\n<line142>&& (i + quote_string_len\n<line143><= (argsize == SIZE_MAX && 1 < quote_string_len\n<line144>/* Use strlen only if we must: when argsize is SIZE_MAX,\n<line145>and when the quote string is more than 1 byte long.\n<line146>If we do call strlen, save the result.  */\n<line147>? (argsize = strlen (arg)) : argsize))\n<line148>&& memcmp (arg + i, quote_string, quote_string_len) == 0)\n<line149>{\n<line150>if (elide_outer_quotes)\n<line151>goto force_outer_quoting_style;\n<line152>is_right_quote = true;\n<line153>}\n<line154>c = arg[i];\n<line155>switch (c)\n<line156>{\n<line157>case '\0':\n<line158>if (backslash_escapes)\n<line159>{\n<line160>START_ESC ();\n<line161>/* If quote_string were to begin with digits, we'd need to\n<line162>test for the end of the arg as well.  However, it's\n<line163>hard to imagine any locale that would use digits in\n<line164>quotes, and set_custom_quoting is documented not to\n<line165>accept them.  Use only a single \0 with shell-escape\n<line166>as currently digits are not printed within $'...'  */\n<line167>if (quoting_style != shell_always_quoting_style\n<line168>&& i + 1 < argsize && '0' <= arg[i + 1] && arg[i + 1] <= '9')\n<line169>{\n<line170>STORE ('0');\n<line171>STORE ('0');\n<line172>}\n<line173>c = '0';\n<line174>/* We don't have to worry that this last '0' will be\n<line175>backslash-escaped because, again, quote_string should\n<line176>not start with it and because quote_these_too is\n<line177>documented as not accepting it.  */\n<line178>}\n<line179>else if (flags & QA_ELIDE_NULL_BYTES)\n<line180>continue;\n<line181>break;\n<line182>case '?':\n<line183>switch (quoting_style)\n<line184>{\n<line185>case shell_always_quoting_style:\n<line186>if (elide_outer_quotes)\n<line187>goto force_outer_quoting_style;\n<line188>break;\n<line189>case c_quoting_style:\n<line190>if ((flags & QA_SPLIT_TRIGRAPHS)\n<line191>&& i + 2 < argsize && arg[i + 1] == '?')\n<line192>switch (arg[i + 2])\n<line193>{\n<line194>case '!': case '\'':\n<line195>case '(': case ')': case '-': case '/':\n<line196>case '<': case '=': case '>':\n<line197>/* Escape the second '?' in what would otherwise be\n<line198>a trigraph.  */\n<line199>if (elide_outer_quotes)\n<line200>goto force_outer_quoting_style;\n<line201>c = arg[i + 2];\n<line202>i += 2;\n<line203>STORE ('?');\n<line204>STORE ('"');\n<line205>STORE ('"');\n<line206>STORE ('?');\n<line207>break;\n<line208>default:\n<line209>break;\n<line210>}\n<line211>break;\n<line212>default:\n<line213>break;\n<line214>}\n<line215>break;\n<line216>case '\a': esc = 'a'; goto c_escape;\n<line217>case '\b': esc = 'b'; goto c_escape;\n<line218>case '\f': esc = 'f'; goto c_escape;\n<line219>case '\n': esc = 'n'; goto c_and_shell_escape;\n<line220>case '\r': esc = 'r'; goto c_and_shell_escape;\n<line221>case '\t': esc = 't'; goto c_and_shell_escape;\n<line222>case '\v': esc = 'v'; goto c_escape;\n<line223>case '\\': esc = c;\n<line224>/* Never need to escape '\' in shell case.  */\n<line225>if (quoting_style == shell_always_quoting_style)\n<line226>{\n<line227>if (elide_outer_quotes)\n<line228>goto force_outer_quoting_style;\n<line229>goto store_c;\n<line230>}\n<line231>/* No need to escape the escape if we are trying to elide\n<line232>outer quotes and nothing else is problematic.  */\n<line233>if (backslash_escapes && elide_outer_quotes && quote_string_len)\n<line234>goto store_c;\n<line235>c_and_shell_escape:\n<line236>if (quoting_style == shell_always_quoting_style\n<line237>&& elide_outer_quotes)\n<line238>goto force_outer_quoting_style;\n<line239>/* fall through */\n<line240>c_escape:\n<line241>if (backslash_escapes)\n<line242>{\n<line243>c = esc;\n<line244>goto store_escape;\n<line245>}\n<line246>break;\n<line247>case '{': case '}': /* sometimes special if isolated */\n<line248>if (! (argsize == SIZE_MAX ? arg[1] == '\0' : argsize == 1))\n<line249>break;\n<line250>FALLTHROUGH;\n<line251>case '#': case '~':\n<line252>if (i != 0)\n<line253>break;\n<line254>FALLTHROUGH;\n<line255>case ' ':\n<line256>c_and_shell_quote_compat = true;\n<line257>FALLTHROUGH;\n<line258>case '!': /* special in bash */\n<line259>case '"': case '$': case '&':\n<line260>case '(': case ')': case '*': case ';':\n<line261>case '<':\n<line262>case '=': /* sometimes special in 0th or (with "set -k") later args */\n<line263>case '>': case '[':\n<line264>case '^': /* special in old /bin/sh, e.g., Solaris 10 */\n<line265>case '`': case '|':\n<line266>/* A shell special character.  */\n<line267>if (quoting_style == shell_always_quoting_style\n<line268>&& elide_outer_quotes)\n<line269>goto force_outer_quoting_style;\n<line270>break;\n<line271>case '\'':\n<line272>encountered_single_quote = true;\n<line273>c_and_shell_quote_compat = true;\n<line274>if (quoting_style == shell_always_quoting_style)\n<line275>{\n<line276>if (elide_outer_quotes)\n<line277>goto force_outer_quoting_style;\n<line278>if (buffersize && ! orig_buffersize)\n<line279>{\n<line280>/* Just scan string to see if supports a more concise\n<line281>representation, rather than writing a longer string\n<line282>but returning the length of the more concise form.  */\n<line283>orig_buffersize = buffersize;\n<line284>buffersize = 0;\n<line285>}\n<line286>STORE ('\'');\n<line287>STORE ('\\');\n<line288>STORE ('\'');\n<line289>pending_shell_escape_end = false;\n<line290>}\n<line291>break;\n<line292>case '%': case '+': case ',': case '-': case '.': case '/':\n<line293>case '0': case '1': case '2': case '3': case '4': case '5':\n<line294>case '6': case '7': case '8': case '9': case ':':\n<line295>case 'A': case 'B': case 'C': case 'D': case 'E': case 'F':\n<line296>case 'G': case 'H': case 'I': case 'J': case 'K': case 'L':\n<line297>case 'M': case 'N': case 'O': case 'P': case 'Q': case 'R':\n<line298>case 'S': case 'T': case 'U': case 'V': case 'W': case 'X':\n<line299>case 'Y': case 'Z': case ']': case '_': case 'a': case 'b':\n<line300>case 'c': case 'd': case 'e': case 'f': case 'g': case 'h':\n<line301>case 'i': case 'j': case 'k': case 'l': case 'm': case 'n':\n<line302>case 'o': case 'p': case 'q': case 'r': case 's': case 't':\n<line303>case 'u': case 'v': case 'w': case 'x': case 'y': case 'z':\n<line304>/* These characters don't cause problems, no matter what the\n<line305>quoting style is.  They cannot start multibyte sequences.\n<line306>A digit or a special letter would cause trouble if it\n<line307>appeared at the beginning of quote_string because we'd then\n<line308>escape by prepending a backslash.  However, it's hard to\n<line309>imagine any locale that would use digits or letters as\n<line310>quotes, and set_custom_quoting is documented not to accept\n<line311>them.  Also, a digit or a special letter would cause\n<line312>trouble if it appeared in quote_these_too, but that's also\n<line313>documented as not accepting them.  */\n<line314>c_and_shell_quote_compat = true;\n<line315>break;\n<line316>default:\n<line317>/* If we have a multibyte sequence, copy it until we reach\n<line318>its end, find an error, or come back to the initial shift\n<line319>state.  For C-like styles, if the sequence has\n<line320>unprintable characters, escape the whole sequence, since\n<line321>we can't easily escape single characters within it.  */\n<line322>{\n<line323>/* Length of multibyte sequence found so far.  */\n<line324>size_t m;\n<line325>bool printable;\n<line326>if (unibyte_locale)\n<line327>{\n<line328>m = 1;\n<line329>printable = isprint (c) != 0;\n<line330>}\n<line331>else\n<line332>{\n<line333>mbstate_t mbstate;\n<line334>mbszero (&mbstate);\n<line335>m = 0;\n<line336>printable = true;\n<line337>if (argsize == SIZE_MAX)\n<line338>argsize = strlen (arg);\n<line339>for (;;)\n<line340>{\n<line341>char32_t w;\n<line342>size_t bytes = mbrtoc32 (&w, &arg[i + m],\n<line343>argsize - (i + m), &mbstate);\n<line344>if (bytes == 0)\n<line345>break;\n<line346>else if (bytes == (size_t) -1)\n<line347>{\n<line348>printable = false;\n<line349>break;\n<line350>}\n<line351>else if (bytes == (size_t) -2)\n<line352>{\n<line353>printable = false;\n<line354>while (i + m < argsize && arg[i + m])\n<line355>m++;\n<line356>break;\n<line357>}\n<line358>else\n<line359>{\n<line360>#if !GNULIB_MBRTOC32_REGULAR\n<line361>if (bytes == (size_t) -3)\n<line362>bytes = 0;\n<line363>#endif\n<line364>/* Work around a bug with older shells that "see" a '\'\n<line365>that is really the 2nd byte of a multibyte character.\n<line366>In practice the problem is limited to ASCII\n<line367>chars >= '@' that are shell special chars.  */\n<line368>if ('[' == 0x5b && elide_outer_quotes\n<line369>&& quoting_style == shell_always_quoting_style)\n<line370>{\n<line371>size_t j;\n<line372>for (j = 1; j < bytes; j++)\n<line373>switch (arg[i + m + j])\n<line374>{\n<line375>case '[': case '\\': case '^':\n<line376>case '`': case '|':\n<line377>goto force_outer_quoting_style;\n<line378>default:\n<line379>break;\n<line380>}\n<line381>}\n<line382>if (! c32isprint (w))\n<line383>printable = false;\n<line384>m += bytes;\n<line385>}\n<line386>#if !GNULIB_MBRTOC32_REGULAR\n<line387>if (mbsinit (&mbstate))\n<line388>#endif\n<line389>break;\n<line390>}\n<line391>}\n<line392>c_and_shell_quote_compat = printable;\n<line393>if (1 < m || (backslash_escapes && ! printable))\n<line394>{\n<line395>/* Output a multibyte sequence, or an escaped\n<line396>unprintable unibyte character.  */\n<line397>size_t ilim = i + m;\n<line398>for (;;)\n<line399>{\n<line400>if (backslash_escapes && ! printable)\n<line401>{\n<line402>START_ESC ();\n<line403>STORE ('0' + (c >> 6));\n<line404>STORE ('0' + ((c >> 3) & 7));\n<line405>c = '0' + (c & 7);\n<line406>}\n<line407>else if (is_right_quote)\n<line408>{\n<line409>STORE ('\\');\n<line410>is_right_quote = false;\n<line411>}\n<line412>if (ilim <= i + 1)\n<line413>break;\n<line414>END_ESC ();\n<line415>STORE (c);\n<line416>c = arg[++i];\n<line417>}\n<line418>goto store_c;\n<line419>}\n<line420>}\n<line421>}\n<line422>if (! (((backslash_escapes && quoting_style != shell_always_quoting_style)\n<line423>|| elide_outer_quotes)\n<line424>&& quote_these_too\n<line425>&& quote_these_too[c / INT_BITS] >> (c % INT_BITS) & 1)\n<line426>&& !is_right_quote)\n<line427>goto store_c;\n<line428>store_escape:\n<line429>START_ESC ();\n<line430>store_c:\n<line431>END_ESC ();\n<line432>STORE (c);\n<line433>if (! c_and_shell_quote_compat)\n<line434>all_c_and_shell_quote_compat = false;\n<line435>}\n<line436>if (len == 0 && quoting_style == shell_always_quoting_style\n<line437>&& elide_outer_quotes)\n<line438>goto force_outer_quoting_style;\n<line439>/* Single shell quotes (') are commonly enough used as an apostrophe,\n<line440>that we attempt to minimize the quoting in this case.  Note its\n<line441>better to use the apostrophe modifier "\u02BC" if possible, as that\n<line442>renders better and works with the word match regex \W+ etc.  */\n<line443>if (quoting_style == shell_always_quoting_style && ! elide_outer_quotes\n<line444>&& encountered_single_quote)\n<line445>{\n<line446>if (all_c_and_shell_quote_compat)\n<line447>return quotearg_buffer_restyled (buffer, orig_buffersize, arg, argsize,\n<line448>c_quoting_style,\n<line449>flags, quote_these_too,\n<line450>left_quote, right_quote);\n<line451>else if (! buffersize && orig_buffersize)\n<line452>{\n<line453>/* Disable read-only scan, and reprocess to write quoted string.  */\n<line454>buffersize = orig_buffersize;\n<line455>len = 0;\n<line456>goto process_input;\n<line457>}\n<line458>}\n<line459>if (quote_string && !elide_outer_quotes)\n<line460>for (; *quote_string; quote_string++)\n<line461>STORE (*quote_string);\n<line462>if (len < buffersize)\n<line463>buffer[len] = '\0';\n<line464>return len;\n<line465>force_outer_quoting_style:\n<line466>/* Don't reuse quote_these_too, since the addition of outer quotes\n<line467>sufficiently quotes the specified characters.  */\n<line468>if (quoting_style == shell_always_quoting_style && backslash_escapes)\n<line469>quoting_style = shell_escape_always_quoting_style;\n<line470>return quotearg_buffer_restyled (buffer, buffersize, arg, argsize,\n<line471>quoting_style,\n<line472>flags & ~QA_ELIDE_OUTER_QUOTES, NULL,\n<line473>left_quote, right_quote);\n<line474>}
----------------------------------------
Function: quotearg_buffer
Content: <line0>size_t\n<line1>quotearg_buffer (char *buffer, size_t buffersize,\n<line2>char const *arg, size_t argsize,\n<line3>struct quoting_options const *o)\n<line4>{\n<line5>struct quoting_options const *p = o ? o : &default_quoting_options;\n<line6>int e = errno;\n<line7>size_t r = quotearg_buffer_restyled (buffer, buffersize, arg, argsize,\n<line8>p->style, p->flags, p->quote_these_too,\n<line9>p->left_quote, p->right_quote);\n<line10>errno = e;\n<line11>return r;\n<line12>}
----------------------------------------
Function: quotearg_alloc
Content: <line0>char *\n<line1>quotearg_alloc (char const *arg, size_t argsize,\n<line2>struct quoting_options const *o)\n<line3>{\n<line4>return quotearg_alloc_mem (arg, argsize, NULL, o);\n<line5>}
----------------------------------------
Function: quotearg_alloc_mem
Content: <line0>char *\n<line1>quotearg_alloc_mem (char const *arg, size_t argsize, size_t *size,\n<line2>struct quoting_options const *o)\n<line3>{\n<line4>struct quoting_options const *p = o ? o : &default_quoting_options;\n<line5>int e = errno;\n<line6>/* Elide embedded null bytes if we can't return a size.  */\n<line7>int flags = p->flags | (size ? 0 : QA_ELIDE_NULL_BYTES);\n<line8>size_t bufsize = quotearg_buffer_restyled (0, 0, arg, argsize, p->style,\n<line9>flags, p->quote_these_too,\n<line10>p->left_quote,\n<line11>p->right_quote) + 1;\n<line12>char *buf = xcharalloc (bufsize);\n<line13>quotearg_buffer_restyled (buf, bufsize, arg, argsize, p->style, flags,\n<line14>p->quote_these_too,\n<line15>p->left_quote, p->right_quote);\n<line16>errno = e;\n<line17>if (size)\n<line18>*size = bufsize - 1;\n<line19>return buf;\n<line20>}
----------------------------------------
Function: quotearg_free
Content: <line0>void\n<line1>quotearg_free (void)\n<line2>{\n<line3>struct slotvec *sv = slotvec;\n<line4>int i;\n<line5>for (i = 1; i < nslots; i++)\n<line6>free (sv[i].val);\n<line7>if (sv[0].val != slot0)\n<line8>{\n<line9>free (sv[0].val);\n<line10>slotvec0.size = sizeof slot0;\n<line11>slotvec0.val = slot0;\n<line12>}\n<line13>if (sv != &slotvec0)\n<line14>{\n<line15>free (sv);\n<line16>slotvec = &slotvec0;\n<line17>}\n<line18>nslots = 1;\n<line19>}
----------------------------------------
Function: quotearg_n_options
Content: <line0>static char *\n<line1>quotearg_n_options (int n, char const *arg, size_t argsize,\n<line2>struct quoting_options const *options)\n<line3>{\n<line4>int e = errno;\n<line5>struct slotvec *sv = slotvec;\n<line6>int nslots_max = MIN (INT_MAX, IDX_MAX);\n<line7>if (! (0 <= n && n < nslots_max))\n<line8>abort ();\n<line9>if (nslots <= n)\n<line10>{\n<line11>bool preallocated = (sv == &slotvec0);\n<line12>idx_t new_nslots = nslots;\n<line13>slotvec = sv = xpalloc (preallocated ? NULL : sv, &new_nslots,\n<line14>n - nslots + 1, nslots_max, sizeof *sv);\n<line15>if (preallocated)\n<line16>*sv = slotvec0;\n<line17>memset (sv + nslots, 0, (new_nslots - nslots) * sizeof *sv);\n<line18>nslots = new_nslots;\n<line19>}\n<line20>{\n<line21>size_t size = sv[n].size;\n<line22>char *val = sv[n].val;\n<line23>/* Elide embedded null bytes since we don't return a size.  */\n<line24>int flags = options->flags | QA_ELIDE_NULL_BYTES;\n<line25>size_t qsize = quotearg_buffer_restyled (val, size, arg, argsize,\n<line26>options->style, flags,\n<line27>options->quote_these_too,\n<line28>options->left_quote,\n<line29>options->right_quote);\n<line30>if (size <= qsize)\n<line31>{\n<line32>sv[n].size = size = qsize + 1;\n<line33>if (val != slot0)\n<line34>free (val);\n<line35>sv[n].val = val = xcharalloc (size);\n<line36>quotearg_buffer_restyled (val, size, arg, argsize, options->style,\n<line37>flags, options->quote_these_too,\n<line38>options->left_quote,\n<line39>options->right_quote);\n<line40>}\n<line41>errno = e;\n<line42>return val;\n<line43>}\n<line44>}
----------------------------------------
Function: quotearg_n
Content: <line0>char *\n<line1>quotearg_n (int n, char const *arg)\n<line2>{\n<line3>return quotearg_n_options (n, arg, SIZE_MAX, &default_quoting_options);\n<line4>}
----------------------------------------
Function: quotearg_n_mem
Content: <line0>char *\n<line1>quotearg_n_mem (int n, char const *arg, size_t argsize)\n<line2>{\n<line3>return quotearg_n_options (n, arg, argsize, &default_quoting_options);\n<line4>}
----------------------------------------
Function: quotearg
Content: <line0>char *\n<line1>quotearg (char const *arg)\n<line2>{\n<line3>return quotearg_n (0, arg);\n<line4>}
----------------------------------------
Function: quotearg_mem
Content: <line0>char *\n<line1>quotearg_mem (char const *arg, size_t argsize)\n<line2>{\n<line3>return quotearg_n_mem (0, arg, argsize);\n<line4>}
----------------------------------------
Function: quotearg_n_style
Content: <line0>char *\n<line1>quotearg_n_style (int n, enum quoting_style s, char const *arg)\n<line2>{\n<line3>struct quoting_options const o = quoting_options_from_style (s);\n<line4>return quotearg_n_options (n, arg, SIZE_MAX, &o);\n<line5>}
----------------------------------------
Function: quotearg_n_style_mem
Content: <line0>char *\n<line1>quotearg_n_style_mem (int n, enum quoting_style s,\n<line2>char const *arg, size_t argsize)\n<line3>{\n<line4>struct quoting_options const o = quoting_options_from_style (s);\n<line5>return quotearg_n_options (n, arg, argsize, &o);\n<line6>}
----------------------------------------
Function: quotearg_style
Content: <line0>char *\n<line1>quotearg_style (enum quoting_style s, char const *arg)\n<line2>{\n<line3>return quotearg_n_style (0, s, arg);\n<line4>}
----------------------------------------
Function: quotearg_style_mem
Content: <line0>char *\n<line1>quotearg_style_mem (enum quoting_style s, char const *arg, size_t argsize)\n<line2>{\n<line3>return quotearg_n_style_mem (0, s, arg, argsize);\n<line4>}
----------------------------------------
Function: quotearg_char_mem
Content: <line0>char *\n<line1>quotearg_char_mem (char const *arg, size_t argsize, char ch)\n<line2>{\n<line3>struct quoting_options options;\n<line4>options = default_quoting_options;\n<line5>set_char_quoting (&options, ch, 1);\n<line6>return quotearg_n_options (0, arg, argsize, &options);\n<line7>}
----------------------------------------
Function: quotearg_char
Content: <line0>char *\n<line1>quotearg_char (char const *arg, char ch)\n<line2>{\n<line3>return quotearg_char_mem (arg, SIZE_MAX, ch);\n<line4>}
----------------------------------------
Function: quotearg_colon
Content: <line0>char *\n<line1>quotearg_colon (char const *arg)\n<line2>{\n<line3>return quotearg_char (arg, ':');\n<line4>}
----------------------------------------
Function: quotearg_colon_mem
Content: <line0>char *\n<line1>quotearg_colon_mem (char const *arg, size_t argsize)\n<line2>{\n<line3>return quotearg_char_mem (arg, argsize, ':');\n<line4>}
----------------------------------------
Function: quotearg_n_style_colon
Content: <line0>char *\n<line1>quotearg_n_style_colon (int n, enum quoting_style s, char const *arg)\n<line2>{\n<line3>struct quoting_options options;\n<line4>options = quoting_options_from_style (s);\n<line5>set_char_quoting (&options, ':', 1);\n<line6>return quotearg_n_options (n, arg, SIZE_MAX, &options);\n<line7>}
----------------------------------------
Function: quotearg_n_custom
Content: <line0>char *\n<line1>quotearg_n_custom (int n, char const *left_quote,\n<line2>char const *right_quote, char const *arg)\n<line3>{\n<line4>return quotearg_n_custom_mem (n, left_quote, right_quote, arg,\n<line5>SIZE_MAX);\n<line6>}
----------------------------------------
Function: quotearg_n_custom_mem
Content: <line0>char *\n<line1>quotearg_n_custom_mem (int n, char const *left_quote,\n<line2>char const *right_quote,\n<line3>char const *arg, size_t argsize)\n<line4>{\n<line5>struct quoting_options o = default_quoting_options;\n<line6>set_custom_quoting (&o, left_quote, right_quote);\n<line7>return quotearg_n_options (n, arg, argsize, &o);\n<line8>}
----------------------------------------
Function: quotearg_custom
Content: <line0>char *\n<line1>quotearg_custom (char const *left_quote, char const *right_quote,\n<line2>char const *arg)\n<line3>{\n<line4>return quotearg_n_custom (0, left_quote, right_quote, arg);\n<line5>}
----------------------------------------
Function: quotearg_custom_mem
Content: <line0>char *\n<line1>quotearg_custom_mem (char const *left_quote, char const *right_quote,\n<line2>char const *arg, size_t argsize)\n<line3>{\n<line4>return quotearg_n_custom_mem (0, left_quote, right_quote, arg,\n<line5>argsize);\n<line6>}
----------------------------------------
Function: quote_n_mem
Content: <line0>char const *\n<line1>quote_n_mem (int n, char const *arg, size_t argsize)\n<line2>{\n<line3>return quotearg_n_options (n, arg, argsize, &quote_quoting_options);\n<line4>}
----------------------------------------
Function: quote_mem
Content: <line0>char const *\n<line1>quote_mem (char const *arg, size_t argsize)\n<line2>{\n<line3>return quote_n_mem (0, arg, argsize);\n<line4>}
----------------------------------------
Function: quote_n
Content: <line0>char const *\n<line1>quote_n (int n, char const *arg)\n<line2>{\n<line3>return quote_n_mem (n, arg, SIZE_MAX);\n<line4>}
----------------------------------------
Function: quote
Content: <line0>char const *\n<line1>quote (char const *arg)\n<line2>{\n<line3>return quote_n (0, arg);\n<line4>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/randint.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
Function: randint_new
Content: <line0>struct randint_source *\n<line1>randint_new (struct randread_source *source)\n<line2>{\n<line3>struct randint_source *s = xmalloc (sizeof *s);\n<line4>s->source = source;\n<line5>s->randnum = s->randmax = 0;\n<line6>return s;\n<line7>}
----------------------------------------
Function: randint_all_new
Content: <line0>struct randint_source *\n<line1>randint_all_new (char const *name, size_t bytes_bound)\n<line2>{\n<line3>struct randread_source *source = randread_new (name, bytes_bound);\n<line4>return (source ? randint_new (source) : nullptr);\n<line5>}
----------------------------------------
Function: randint_get_source
Content: <line0>struct randread_source *\n<line1>randint_get_source (struct randint_source const *s)\n<line2>{\n<line3>return s->source;\n<line4>}
----------------------------------------
Function: shift_left
Content: <line0>static inline randint shift_left (randint x)\n<line1>{\n<line2>return HUGE_BYTES ? 0 : x << CHAR_BIT;\n<line3>}
----------------------------------------
Function: randint_genmax
Content: <line0>randint\n<line1>randint_genmax (struct randint_source *s, randint genmax)\n<line2>{\n<line3>struct randread_source *source = s->source;\n<line4>randint randnum = s->randnum;\n<line5>randint randmax = s->randmax;\n<line6>randint choices = genmax + 1;\n<line7>while (1)\n<line8>{\n<line9>if (randmax < genmax)\n<line10>{\n<line11>/* Calculate how many input bytes will be needed, and read\n<line12>the bytes.  */\n<line13>size_t i = 0;\n<line14>randint rmax = randmax;\n<line15>unsigned char buf[sizeof randnum];\n<line16>do\n<line17>{\n<line18>rmax = shift_left (rmax) + UCHAR_MAX;\n<line19>i++;\n<line20>}\n<line21>while (rmax < genmax);\n<line22>randread (source, buf, i);\n<line23>/* Increase RANDMAX by appending random bytes to RANDNUM and\n<line24>UCHAR_MAX to RANDMAX until RANDMAX is no less than\n<line25>GENMAX.  This may lose up to CHAR_BIT bits of information\n<line26>if (HUGE_BYTES ? 0 : RANDINT_MAX >> CHAR_BIT) < GENMAX,\n<line27>but it is not worth the programming hassle of saving\n<line28>these bits since GENMAX is rarely that large in practice.  */\n<line29>i = 0;\n<line30>do\n<line31>{\n<line32>randnum = shift_left (randnum) + buf[i];\n<line33>randmax = shift_left (randmax) + UCHAR_MAX;\n<line34>i++;\n<line35>}\n<line36>while (randmax < genmax);\n<line37>}\n<line38>if (randmax == genmax)\n<line39>{\n<line40>s->randnum = s->randmax = 0;\n<line41>return randnum;\n<line42>}\n<line43>else\n<line44>{\n<line45>/* GENMAX < RANDMAX, so attempt to generate a random number\n<line46>by taking RANDNUM modulo GENMAX+1.  This will choose\n<line47>fairly so long as RANDNUM falls within an integral\n<line48>multiple of GENMAX+1; otherwise, LAST_USABLE_CHOICE < RANDNUM,\n<line49>so discard this attempt and try again.\n<line50>Since GENMAX cannot be RANDINT_MAX, CHOICES cannot be\n<line51>zero and there is no need to worry about dividing by\n<line52>zero.  */\n<line53>randint excess_choices = randmax - genmax;\n<line54>randint unusable_choices = excess_choices % choices;\n<line55>randint last_usable_choice = randmax - unusable_choices;\n<line56>randint reduced_randnum = randnum % choices;\n<line57>if (randnum <= last_usable_choice)\n<line58>{\n<line59>s->randnum = randnum / choices;\n<line60>s->randmax = excess_choices / choices;\n<line61>return reduced_randnum;\n<line62>}\n<line63>/* Retry, but retain the randomness from the fact that RANDNUM fell\n<line64>into the range LAST_USABLE_CHOICE+1 .. RANDMAX.  */\n<line65>randnum = reduced_randnum;\n<line66>randmax = unusable_choices - 1;\n<line67>}\n<line68>}\n<line69>}
----------------------------------------
Function: randint_free
Content: <line0>void\n<line1>randint_free (struct randint_source *s)\n<line2>{\n<line3>explicit_bzero (s, sizeof *s);\n<line4>free (s);\n<line5>}
----------------------------------------
Function: randint_all_free
Content: <line0>int\n<line1>randint_all_free (struct randint_source *s)\n<line2>{\n<line3>int r = randread_free (s->source);\n<line4>int e = errno;\n<line5>randint_free (s);\n<line6>errno = e;\n<line7>return r;\n<line8>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/randperm.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
/home/huihui/Downloads/coreutils-9.4/lib/randperm.c:38:44: warning: '_Static_assert' with no message is a C2x extension [-Wc2x-extensions]
  static_assert (SIZE_WIDTH <= ULLONG_WIDTH);
                                           ^
                                           , ""
2 warnings generated.
Function: randperm_bound
Content: <line0>size_t\n<line1>randperm_bound (size_t h, size_t n)\n<line2>{\n<line3>/* Upper bound on number of bits needed to generate the first number\n<line4>of the permutation.  */\n<line5>uintmax_t lg_n = floor_lg (n) + 1;\n<line6>/* Upper bound on number of bits needed to generated the first H elements.  */\n<line7>uintmax_t ar = lg_n * h;\n<line8>/* Convert the bit count to a byte count.  */\n<line9>size_t bound = (ar + CHAR_BIT - 1) / CHAR_BIT;\n<line10>return bound;\n<line11>}
----------------------------------------
Function: swap
Content: <line0>static void\n<line1>swap (size_t *v, size_t i, size_t j)\n<line2>{\n<line3>size_t t = v[i];\n<line4>v[i] = v[j];\n<line5>v[j] = t;\n<line6>}
----------------------------------------
Function: sparse_hash_
Content: <line0>static size_t\n<line1>sparse_hash_ (void const *x, size_t table_size)\n<line2>{\n<line3>struct sparse_ent_ const *ent = x;\n<line4>return ent->index % table_size;\n<line5>}
----------------------------------------
Function: sparse_cmp_
Content: <line0>static bool\n<line1>sparse_cmp_ (void const *x, void const *y)\n<line2>{\n<line3>struct sparse_ent_ const *ent1 = x;\n<line4>struct sparse_ent_ const *ent2 = y;\n<line5>return ent1->index == ent2->index;\n<line6>}
----------------------------------------
Function: sparse_new
Content: <line0>static sparse_map *\n<line1>sparse_new (size_t size_hint)\n<line2>{\n<line3>return hash_initialize (size_hint, nullptr, sparse_hash_, sparse_cmp_, free);\n<line4>}
----------------------------------------
Function: sparse_swap
Content: <line0>static void\n<line1>sparse_swap (sparse_map *sv, size_t *v, size_t i, size_t j)\n<line2>{\n<line3>struct sparse_ent_ *v1 = hash_remove (sv, &(struct sparse_ent_) {i,0});\n<line4>struct sparse_ent_ *v2 = hash_remove (sv, &(struct sparse_ent_) {j,0});\n<line5>/* FIXME: reduce the frequency of these mallocs.  */\n<line6>if (!v1)\n<line7>{\n<line8>v1 = xmalloc (sizeof *v1);\n<line9>v1->index = v1->val = i;\n<line10>}\n<line11>if (!v2)\n<line12>{\n<line13>v2 = xmalloc (sizeof *v2);\n<line14>v2->index = v2->val = j;\n<line15>}\n<line16>size_t t = v1->val;\n<line17>v1->val = v2->val;\n<line18>v2->val = t;\n<line19>if (!hash_insert (sv, v1))\n<line20>xalloc_die ();\n<line21>if (!hash_insert (sv, v2))\n<line22>xalloc_die ();\n<line23>v[i] = v1->val;\n<line24>}
----------------------------------------
Function: sparse_free
Content: <line0>static void\n<line1>sparse_free (sparse_map *sv)\n<line2>{\n<line3>hash_free (sv);\n<line4>}
----------------------------------------
Function: randperm_new
Content: <line0>size_t *\n<line1>randperm_new (struct randint_source *r, size_t h, size_t n)\n<line2>{\n<line3>size_t *v;\n<line4>switch (h)\n<line5>{\n<line6>case 0:\n<line7>v = nullptr;\n<line8>break;\n<line9>case 1:\n<line10>v = xmalloc (sizeof *v);\n<line11>v[0] = randint_choose (r, n);\n<line12>break;\n<line13>default:\n<line14>{\n<line15>/* The algorithm is essentially the same in both\n<line16>the sparse and non sparse case.  In the sparse case we use\n<line17>a hash to implement sparse storage for the set of n numbers\n<line18>we're shuffling.  When to use the sparse method was\n<line19>determined with the help of this script:\n<line20>#!/bin/sh\n<line21>for n in $(seq 2 32); do\n<line22>for h in $(seq 2 32); do\n<line23>test $h -gt $n && continue\n<line24>for s in o n; do\n<line25>test $s = o && shuf=shuf || shuf=./shuf\n<line26>num=$(env time -f "$s:${h},${n} = %e,%M" \\n<line27>$shuf -i0-$((2**$n-2)) -n$((2**$h-2)) | wc -l)\n<line28>test $num = $((2**$h-2)) || echo "$s:${h},${n} = failed" >&2\n<line29>done\n<line30>done\n<line31>done\n<line32>This showed that if sparseness = n/h, then:\n<line33>sparseness = 128 => .125 mem used, and about same speed\n<line34>sparseness =  64 => .25  mem used, but 1.5 times slower\n<line35>sparseness =  32 => .5   mem used, but 2 times slower\n<line36>Also the memory usage was only significant when n > 128Ki\n<line37>*/\n<line38>bool sparse = (n >= (128 * 1024)) && (n / h >= 32);\n<line39>size_t i;\n<line40>sparse_map *sv;\n<line41>if (sparse)\n<line42>{\n<line43>sv = sparse_new (h * 2);\n<line44>if (sv == nullptr)\n<line45>xalloc_die ();\n<line46>v = xnmalloc (h, sizeof *v);\n<line47>}\n<line48>else\n<line49>{\n<line50>sv = nullptr; /* To placate GCC's -Wuninitialized.  */\n<line51>v = xnmalloc (n, sizeof *v);\n<line52>for (i = 0; i < n; i++)\n<line53>v[i] = i;\n<line54>}\n<line55>for (i = 0; i < h; i++)\n<line56>{\n<line57>size_t j = i + randint_choose (r, n - i);\n<line58>if (sparse)\n<line59>sparse_swap (sv, v, i, j);\n<line60>else\n<line61>swap (v, i, j);\n<line62>}\n<line63>if (sparse)\n<line64>sparse_free (sv);\n<line65>else\n<line66>v = xnrealloc (v, h, sizeof *v);\n<line67>}\n<line68>break;\n<line69>}\n<line70>return v;\n<line71>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/randread.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
Function: randread_error
Content: <line0>static void\n<line1>randread_error (void const *file_name)\n<line2>{\n<line3>affirm (exit_failure);\n<line4>error (exit_failure, errno,\n<line5>errno == 0 ? _("%s: end of file") : _("%s: read error"),\n<line6>quote (file_name));\n<line7>}
----------------------------------------
Function: simple_new
Content: <line0>static struct randread_source *\n<line1>simple_new (FILE *source, void const *handler_arg)\n<line2>{\n<line3>struct randread_source *s = xmalloc (sizeof *s);\n<line4>s->source = source;\n<line5>s->handler = randread_error;\n<line6>s->handler_arg = handler_arg;\n<line7>return s;\n<line8>}
----------------------------------------
Function: get_nonce
Content: <line0>static bool\n<line1>get_nonce (void *buffer, size_t bufsize)\n<line2>{\n<line3>char *buf = buffer, *buflim = buf + bufsize;\n<line4>while (buf < buflim)\n<line5>{\n<line6>#if defined __sun\n<line7># define MAX_GETRANDOM 1024\n<line8>#else\n<line9># define MAX_GETRANDOM SIZE_MAX\n<line10>#endif\n<line11>size_t max_bytes = MIN (buflim - buf, MAX_GETRANDOM);\n<line12>ssize_t nbytes = getrandom (buf, max_bytes, 0);\n<line13>if (0 <= nbytes)\n<line14>buf += nbytes;\n<line15>else if (errno != EINTR)\n<line16>return false;\n<line17>}\n<line18>return true;\n<line19>}
----------------------------------------
Function: randread_free_body
Content: <line0>static int\n<line1>randread_free_body (struct randread_source *s)\n<line2>{\n<line3>FILE *source = s->source;\n<line4>explicit_bzero (s, sizeof *s);\n<line5>free (s);\n<line6>return source ? fclose (source) : 0;\n<line7>}
----------------------------------------
Function: randread_new
Content: <line0>struct randread_source *\n<line1>randread_new (char const *name, size_t bytes_bound)\n<line2>{\n<line3>if (bytes_bound == 0)\n<line4>return simple_new (nullptr, nullptr);\n<line5>else\n<line6>{\n<line7>FILE *source = nullptr;\n<line8>struct randread_source *s;\n<line9>if (name)\n<line10>if (! (source = fopen_safer (name, "rb")))\n<line11>return nullptr;\n<line12>s = simple_new (source, name);\n<line13>if (source)\n<line14>setvbuf (source, s->buf.c, _IOFBF, MIN (sizeof s->buf.c, bytes_bound));\n<line15>else\n<line16>{\n<line17>s->buf.isaac.buffered = 0;\n<line18>if (! get_nonce (s->buf.isaac.state.m,\n<line19>MIN (sizeof s->buf.isaac.state.m, bytes_bound)))\n<line20>{\n<line21>int e = errno;\n<line22>randread_free_body (s);\n<line23>errno = e;\n<line24>return nullptr;\n<line25>}\n<line26>isaac_seed (&s->buf.isaac.state);\n<line27>}\n<line28>return s;\n<line29>}\n<line30>}
----------------------------------------
Function: randread_set_handler
Content: <line0>void\n<line1>randread_set_handler (struct randread_source *s, void (*handler) (void const *))\n<line2>{\n<line3>s->handler = handler;\n<line4>}
----------------------------------------
Function: randread_set_handler_arg
Content: <line0>void\n<line1>randread_set_handler_arg (struct randread_source *s, void const *handler_arg)\n<line2>{\n<line3>s->handler_arg = handler_arg;\n<line4>}
----------------------------------------
Function: readsource
Content: <line0>static void\n<line1>readsource (struct randread_source *s, unsigned char *p, size_t size)\n<line2>{\n<line3>while (true)\n<line4>{\n<line5>size_t inbytes = fread (p, sizeof *p, size, s->source);\n<line6>int fread_errno = errno;\n<line7>p += inbytes;\n<line8>size -= inbytes;\n<line9>if (size == 0)\n<line10>break;\n<line11>errno = (ferror (s->source) ? fread_errno : 0);\n<line12>s->handler (s->handler_arg);\n<line13>}\n<line14>}
----------------------------------------
Function: readisaac
Content: <line0>static void\n<line1>readisaac (struct isaac *isaac, void *p, size_t size)\n<line2>{\n<line3>size_t inbytes = isaac->buffered;\n<line4>while (true)\n<line5>{\n<line6>char *char_p = p;\n<line7>if (size <= inbytes)\n<line8>{\n<line9>memcpy (p, isaac->data.b + ISAAC_BYTES - inbytes, size);\n<line10>isaac->buffered = inbytes - size;\n<line11>return;\n<line12>}\n<line13>memcpy (p, isaac->data.b + ISAAC_BYTES - inbytes, inbytes);\n<line14>p = char_p + inbytes;\n<line15>size -= inbytes;\n<line16>/* If P is aligned, write to *P directly to avoid the overhead\n<line17>of copying from the buffer.  */\n<line18>if (ALIGNED_POINTER (p, isaac_word))\n<line19>{\n<line20>isaac_word *wp = p;\n<line21>while (ISAAC_BYTES <= size)\n<line22>{\n<line23>isaac_refill (&isaac->state, wp);\n<line24>wp += ISAAC_WORDS;\n<line25>size -= ISAAC_BYTES;\n<line26>if (size == 0)\n<line27>{\n<line28>isaac->buffered = 0;\n<line29>return;\n<line30>}\n<line31>}\n<line32>p = wp;\n<line33>}\n<line34>isaac_refill (&isaac->state, isaac->data.w);\n<line35>inbytes = ISAAC_BYTES;\n<line36>}\n<line37>}
----------------------------------------
Function: randread
Content: <line0>void\n<line1>randread (struct randread_source *s, void *buf, size_t size)\n<line2>{\n<line3>if (s->source)\n<line4>readsource (s, buf, size);\n<line5>else\n<line6>readisaac (&s->buf.isaac, buf, size);\n<line7>}
----------------------------------------
Function: randread_free
Content: <line0>int\n<line1>randread_free (struct randread_source *s)\n<line2>{\n<line3>return randread_free_body (s);\n<line4>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/rand-isaac.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
Function: just
Content: <line0>static inline isaac_word\n<line1>just (isaac_word a)\n<line2>{\n<line3>isaac_word desired_bits = ((isaac_word) 1 << 1 << (ISAAC_BITS - 1)) - 1;\n<line4>return a & desired_bits;\n<line5>}
----------------------------------------
Function: ind
Content: <line0>static inline isaac_word\n<line1>ind (isaac_word const *m, isaac_word x)\n<line2>{\n<line3>if (sizeof *m * CHAR_BIT == ISAAC_BITS)\n<line4>{\n<line5>/* The typical case, where words are exactly the right size.\n<line6>Optimize this to a mask, an addition, and an indirect\n<line7>load.  */\n<line8>void const *void_m = m;\n<line9>char const *base_p = void_m;\n<line10>void const *word_p = base_p + (x & ((ISAAC_WORDS - 1) * sizeof *m));\n<line11>isaac_word const *p = word_p;\n<line12>return *p;\n<line13>}\n<line14>else\n<line15>{\n<line16>/* Atypical machines need more work.  */\n<line17>return m[(x / (ISAAC_BITS / CHAR_BIT)) & (ISAAC_WORDS - 1)];\n<line18>}\n<line19>}
----------------------------------------
Function: isaac_refill
Content: <line0>void ATTRIBUTE_NO_WARN_SANITIZE_UNDEFINED\n<line1>isaac_refill (struct isaac_state *s, isaac_word result[ISAAC_WORDS])\n<line2>{\n<line3>/* Caches of S->a and S->b.  */\n<line4>isaac_word a = s->a;\n<line5>isaac_word b = s->b + (++s->c);\n<line6>/* Pointers into state array and into result.  */\n<line7>isaac_word *m = s->m;\n<line8>isaac_word *r = result;\n<line9>enum { HALF = ISAAC_WORDS / 2 };\n<line10>/* The central step.  S->m is the whole state array, while M is a\n<line11>pointer to the current word.  OFF is the offset from M to the\n<line12>word ISAAC_WORDS/2 words away in the SM array, i.e., +/-\n<line13>ISAAC_WORDS/2.  A and B are state variables, and R the result.\n<line14>This updates A, B, M[I], and R[I].  */\n<line15>#define ISAAC_STEP(i, off, mix)                             \\n<line16>{                                                         \\n<line17>isaac_word x, y;                                        \\n<line18>a = (IF32 (a, 0) ^ (mix)) + m[off + (i)];               \\n<line19>x = m[i];                                               \\n<line20>m[i] = y = ind (s->m, x) + a + b;                       \\n<line21>r[i] = b = just (ind (s->m, y >> ISAAC_WORDS_LOG) + x); \\n<line22>}\n<line23>do\n<line24>{\n<line25>ISAAC_STEP (0, HALF, IF32 (      a  << 13, ~ (a ^ (a << 21))));\n<line26>ISAAC_STEP (1, HALF, IF32 (just (a) >>  6, a ^ (just (a) >>  5)));\n<line27>ISAAC_STEP (2, HALF, IF32 (      a  <<  2, a ^ (      a  << 12)));\n<line28>ISAAC_STEP (3, HALF, IF32 (just (a) >> 16, a ^ (just (a) >> 33)));\n<line29>r += 4;\n<line30>}\n<line31>while ((m += 4) < s->m + HALF);\n<line32>do\n<line33>{\n<line34>ISAAC_STEP (0, -HALF, IF32 (      a  << 13, ~ (a ^ (a << 21))));\n<line35>ISAAC_STEP (1, -HALF, IF32 (just (a) >>  6, a ^ (just (a) >>  5)));\n<line36>ISAAC_STEP (2, -HALF, IF32 (      a  <<  2, a ^ (      a  << 12)));\n<line37>ISAAC_STEP (3, -HALF, IF32 (just (a) >> 16, a ^ (just (a) >> 33)));\n<line38>r += 4;\n<line39>}\n<line40>while ((m += 4) < s->m + ISAAC_WORDS);\n<line41>s->a = a;\n<line42>s->b = b;\n<line43>}
----------------------------------------
Function: isaac_seed
Content: <line0>void\n<line1>isaac_seed (struct isaac_state *s)\n<line2>{\n<line3>isaac_word a = IF32 (UINT32_C (0x1367df5a), UINT64_C (0x647c4677a2884b7c));\n<line4>isaac_word b = IF32 (UINT32_C (0x95d90059), UINT64_C (0xb9f8b322c73ac862));\n<line5>isaac_word c = IF32 (UINT32_C (0xc3163e4b), UINT64_C (0x8c0ea5053d4712a0));\n<line6>isaac_word d = IF32 (UINT32_C (0x0f421ad8), UINT64_C (0xb29b2e824a595524));\n<line7>isaac_word e = IF32 (UINT32_C (0xd92a4a78), UINT64_C (0x82f053db8355e0ce));\n<line8>isaac_word f = IF32 (UINT32_C (0xa51a3c49), UINT64_C (0x48fe4a0fa5a09315));\n<line9>isaac_word g = IF32 (UINT32_C (0xc4efea1b), UINT64_C (0xae985bf2cbfc89ed));\n<line10>isaac_word h = IF32 (UINT32_C (0x30609119), UINT64_C (0x98f5704f6c44c0ab));\n<line11>#if 0\n<line12>/* The initialization of a through h is a precomputed form of: */\n<line13>a = b = c = d = e = f = g = h =          /* the golden ratio */\n<line14>IF32 (UINT32_C (0x9e3779b9), UINT64_C (0x9e3779b97f4a7c13));\n<line15>for (int i = 0; i < 4; i++)              /* scramble it */\n<line16>mix (a, b, c, d, e, f, g, h);\n<line17>#endif\n<line18>/* Mix S->m so that every part of the seed affects every part of the\n<line19>state.  */\n<line20>ISAAC_MIX (s, a, b, c, d, e, f, g, h, s->m);\n<line21>ISAAC_MIX (s, a, b, c, d, e, f, g, h, s->m);\n<line22>s->a = s->b = s->c = 0;\n<line23>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/read-file.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
Function: fread_file
Content: <line0>char *\n<line1>fread_file (FILE *stream, int flags, size_t *length)\n<line2>{\n<line3>char *buf = NULL;\n<line4>size_t alloc = BUFSIZ;\n<line5>/* For a regular file, allocate a buffer that has exactly the right\n<line6>size.  This avoids the need to do dynamic reallocations later.  */\n<line7>{\n<line8>struct stat st;\n<line9>if (fstat (fileno (stream), &st) >= 0 && S_ISREG (st.st_mode))\n<line10>{\n<line11>off_t pos = ftello (stream);\n<line12>if (pos >= 0 && pos < st.st_size)\n<line13>{\n<line14>off_t alloc_off = st.st_size - pos;\n<line15>/* '1' below, accounts for the trailing NUL.  */\n<line16>if (PTRDIFF_MAX - 1 < alloc_off)\n<line17>{\n<line18>errno = ENOMEM;\n<line19>return NULL;\n<line20>}\n<line21>alloc = alloc_off + 1;\n<line22>}\n<line23>}\n<line24>}\n<line25>if (!(buf = malloc (alloc)))\n<line26>return NULL; /* errno is ENOMEM.  */\n<line27>{\n<line28>size_t size = 0; /* number of bytes read so far */\n<line29>int save_errno;\n<line30>for (;;)\n<line31>{\n<line32>/* This reads 1 more than the size of a regular file\n<line33>so that we get eof immediately.  */\n<line34>size_t requested = alloc - size;\n<line35>size_t count = fread (buf + size, 1, requested, stream);\n<line36>size += count;\n<line37>if (count != requested)\n<line38>{\n<line39>save_errno = errno;\n<line40>if (ferror (stream))\n<line41>break;\n<line42>/* Shrink the allocated memory if possible.  */\n<line43>if (size < alloc - 1)\n<line44>{\n<line45>if (flags & RF_SENSITIVE)\n<line46>{\n<line47>char *smaller_buf = malloc (size + 1);\n<line48>if (smaller_buf == NULL)\n<line49>memset_explicit (buf + size, 0, alloc - size);\n<line50>else\n<line51>{\n<line52>memcpy (smaller_buf, buf, size);\n<line53>memset_explicit (buf, 0, alloc);\n<line54>free (buf);\n<line55>buf = smaller_buf;\n<line56>}\n<line57>}\n<line58>else\n<line59>{\n<line60>char *smaller_buf = realloc (buf, size + 1);\n<line61>if (smaller_buf != NULL)\n<line62>buf = smaller_buf;\n<line63>}\n<line64>}\n<line65>buf[size] = '\0';\n<line66>*length = size;\n<line67>return buf;\n<line68>}\n<line69>{\n<line70>char *new_buf;\n<line71>size_t save_alloc = alloc;\n<line72>if (alloc == PTRDIFF_MAX)\n<line73>{\n<line74>save_errno = ENOMEM;\n<line75>break;\n<line76>}\n<line77>if (alloc < PTRDIFF_MAX - alloc / 2)\n<line78>alloc = alloc + alloc / 2;\n<line79>else\n<line80>alloc = PTRDIFF_MAX;\n<line81>if (flags & RF_SENSITIVE)\n<line82>{\n<line83>new_buf = malloc (alloc);\n<line84>if (!new_buf)\n<line85>{\n<line86>/* BUF should be cleared below after the loop.  */\n<line87>save_errno = errno;\n<line88>break;\n<line89>}\n<line90>memcpy (new_buf, buf, save_alloc);\n<line91>memset_explicit (buf, 0, save_alloc);\n<line92>free (buf);\n<line93>}\n<line94>else if (!(new_buf = realloc (buf, alloc)))\n<line95>{\n<line96>save_errno = errno;\n<line97>break;\n<line98>}\n<line99>buf = new_buf;\n<line100>}\n<line101>}\n<line102>if (flags & RF_SENSITIVE)\n<line103>memset_explicit (buf, 0, alloc);\n<line104>free (buf);\n<line105>errno = save_errno;\n<line106>return NULL;\n<line107>}\n<line108>}
----------------------------------------
Function: read_file
Content: <line0>char *\n<line1>read_file (const char *filename, int flags, size_t *length)\n<line2>{\n<line3>const char *mode = (flags & RF_BINARY) ? "rbe" : "re";\n<line4>FILE *stream = fopen (filename, mode);\n<line5>char *out;\n<line6>if (!stream)\n<line7>return NULL;\n<line8>if (flags & RF_SENSITIVE)\n<line9>setvbuf (stream, NULL, _IONBF, 0);\n<line10>out = fread_file (stream, flags, length);\n<line11>if (fclose (stream) != 0)\n<line12>{\n<line13>if (out)\n<line14>{\n<line15>if (flags & RF_SENSITIVE)\n<line16>memset_explicit (out, 0, *length);\n<line17>free (out);\n<line18>}\n<line19>return NULL;\n<line20>}\n<line21>return out;\n<line22>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/readtokens.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
Function: init_tokenbuffer
Content: <line0>void\n<line1>init_tokenbuffer (token_buffer *tokenbuffer)\n<line2>{\n<line3>tokenbuffer->size = 0;\n<line4>tokenbuffer->buffer = NULL;\n<line5>}
----------------------------------------
Function: get_nth_bit
Content: <line0>static bool\n<line1>get_nth_bit (size_t n, word const *bitset)\n<line2>{\n<line3>return bitset[n / bits_per_word] >> n % bits_per_word & 1;\n<line4>}
----------------------------------------
Function: set_nth_bit
Content: <line0>static void\n<line1>set_nth_bit (size_t n, word *bitset)\n<line2>{\n<line3>size_t one = 1;\n<line4>bitset[n / bits_per_word] |= one << n % bits_per_word;\n<line5>}
----------------------------------------
Function: readtoken
Content: <line0>size_t\n<line1>readtoken (FILE *stream,\n<line2>const char *delim,\n<line3>size_t n_delim,\n<line4>token_buffer *tokenbuffer)\n<line5>{\n<line6>int c;\n<line7>idx_t i;\n<line8>word isdelim[(UCHAR_MAX + bits_per_word) / bits_per_word];\n<line9>memset (isdelim, 0, sizeof isdelim);\n<line10>for (i = 0; i < n_delim; i++)\n<line11>{\n<line12>unsigned char ch = delim[i];\n<line13>set_nth_bit (ch, isdelim);\n<line14>}\n<line15>/* skip over any leading delimiters */\n<line16>for (c = getc (stream); c >= 0 && get_nth_bit (c, isdelim); c = getc (stream))\n<line17>{\n<line18>/* empty */\n<line19>}\n<line20>char *p = tokenbuffer->buffer;\n<line21>idx_t n = tokenbuffer->size;\n<line22>i = 0;\n<line23>for (;;)\n<line24>{\n<line25>if (c < 0 && i == 0)\n<line26>return -1;\n<line27>if (i == n)\n<line28>p = xpalloc (p, &n, 1, -1, sizeof *p);\n<line29>if (c < 0)\n<line30>{\n<line31>p[i] = 0;\n<line32>break;\n<line33>}\n<line34>if (get_nth_bit (c, isdelim))\n<line35>{\n<line36>p[i] = 0;\n<line37>break;\n<line38>}\n<line39>p[i++] = c;\n<line40>c = getc (stream);\n<line41>}\n<line42>tokenbuffer->buffer = p;\n<line43>tokenbuffer->size = n;\n<line44>return i;\n<line45>}
----------------------------------------
Function: readtokens
Content: <line0>size_t\n<line1>readtokens (FILE *stream,\n<line2>size_t projected_n_tokens,\n<line3>const char *delim,\n<line4>size_t n_delim,\n<line5>char ***tokens_out,\n<line6>size_t **token_lengths)\n<line7>{\n<line8>token_buffer tb, *token = &tb;\n<line9>char **tokens;\n<line10>size_t *lengths;\n<line11>idx_t sz, n_tokens;\n<line12>if (projected_n_tokens == 0)\n<line13>projected_n_tokens = 64;\n<line14>else\n<line15>projected_n_tokens++;       /* add one for trailing NULL pointer */\n<line16>sz = projected_n_tokens;\n<line17>tokens = xnmalloc (sz, sizeof *tokens);\n<line18>lengths = xnmalloc (sz, sizeof *lengths);\n<line19>n_tokens = 0;\n<line20>init_tokenbuffer (token);\n<line21>for (;;)\n<line22>{\n<line23>char *tmp;\n<line24>size_t token_length = readtoken (stream, delim, n_delim, token);\n<line25>if (n_tokens >= sz)\n<line26>{\n<line27>tokens = xpalloc (tokens, &sz, 1, -1, sizeof *tokens);\n<line28>lengths = xreallocarray (lengths, sz, sizeof *lengths);\n<line29>}\n<line30>if (token_length == (size_t) -1)\n<line31>{\n<line32>/* don't increment n_tokens for NULL entry */\n<line33>tokens[n_tokens] = NULL;\n<line34>lengths[n_tokens] = 0;\n<line35>break;\n<line36>}\n<line37>tmp = xnmalloc (token_length + 1, sizeof *tmp);\n<line38>lengths[n_tokens] = token_length;\n<line39>tokens[n_tokens] = memcpy (tmp, token->buffer, token_length + 1);\n<line40>n_tokens++;\n<line41>}\n<line42>free (token->buffer);\n<line43>*tokens_out = tokens;\n<line44>if (token_lengths != NULL)\n<line45>*token_lengths = lengths;\n<line46>else\n<line47>free (lengths);\n<line48>return n_tokens;\n<line49>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/readtokens0.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
Function: readtokens0_init
Content: <line0>void\n<line1>readtokens0_init (struct Tokens *t)\n<line2>{\n<line3>t->n_tok = 0;\n<line4>t->tok = NULL;\n<line5>t->tok_len = NULL;\n<line6>obstack_init (&t->o_data);\n<line7>obstack_init (&t->o_tok);\n<line8>obstack_init (&t->o_tok_len);\n<line9>}
----------------------------------------
Function: readtokens0_free
Content: <line0>void\n<line1>readtokens0_free (struct Tokens *t)\n<line2>{\n<line3>obstack_free (&t->o_data, NULL);\n<line4>obstack_free (&t->o_tok, NULL);\n<line5>obstack_free (&t->o_tok_len, NULL);\n<line6>}
----------------------------------------
Function: save_token
Content: <line0>static void\n<line1>save_token (struct Tokens *t)\n<line2>{\n<line3>/* Don't count the trailing NUL byte in the length.  */\n<line4>size_t len = obstack_object_size (&t->o_data) - 1;\n<line5>char const *s = obstack_finish (&t->o_data);\n<line6>obstack_ptr_grow (&t->o_tok, s);\n<line7>obstack_grow (&t->o_tok_len, &len, sizeof len);\n<line8>t->n_tok++;\n<line9>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/readutmp.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
Function: extract_trimmed_name
Content: <line0>char *\n<line1>extract_trimmed_name (const STRUCT_UTMP *ut)\n<line2>{\n<line3>char const *name = ut->ut_user;\n<line4>idx_t len = strlen (name);\n<line5>char const *p;\n<line6>for (p = name + len; name < p && p[-1] == ' '; p--)\n<line7>continue;\n<line8>return ximemdup0 (name, p - name);\n<line9>}
----------------------------------------
Function: desirable_utmp_entry
Content: <line0>static bool\n<line1>desirable_utmp_entry (STRUCT_UTMP const *ut, int options)\n<line2>{\n<line3># if defined __OpenBSD__ && !HAVE_UTMPX_H\n<line4>/* Eliminate entirely empty entries.  */\n<line5>if (ut->ut_ts.tv_sec == 0 && ut->ut_user[0] == '\0'\n<line6>&& ut->ut_line[0] == '\0' && ut->ut_host[0] == '\0')\n<line7>return false;\n<line8># endif\n<line9>bool boot_time = UT_TYPE_BOOT_TIME (ut);\n<line10>if ((options & READ_UTMP_BOOT_TIME) && !boot_time)\n<line11>return false;\n<line12>if ((options & READ_UTMP_NO_BOOT_TIME) && boot_time)\n<line13>return false;\n<line14>bool user_proc = IS_USER_PROCESS (ut);\n<line15>if ((options & READ_UTMP_USER_PROCESS) && !user_proc)\n<line16>return false;\n<line17># if !(defined __CYGWIN__ || defined _WIN32)\n<line18>if ((options & READ_UTMP_CHECK_PIDS)\n<line19>&& user_proc\n<line20>&& 0 < UT_PID (ut)\n<line21>&& (kill (UT_PID (ut), 0) < 0 && errno == ESRCH))\n<line22>return false;\n<line23># endif\n<line24>return true;\n<line25>}
----------------------------------------
Function: add_utmp
Content: <line0>static struct utmp_alloc\n<line1>add_utmp (struct utmp_alloc a, int options,\n<line2>char const *user, idx_t user_len,\n<line3>char const *id, idx_t id_len,\n<line4>char const *line, idx_t line_len,\n<line5>char const *host, idx_t host_len,\n<line6>pid_t pid, short type, struct timespec ts, long session,\n<line7>int termination, int exit)\n<line8>{\n<line9>int entry_bytes = sizeof (struct gl_utmp);\n<line10>idx_t avail = a.alloc_bytes - (entry_bytes * a.filled + a.string_bytes);\n<line11>idx_t needed_string_bytes =\n<line12>(user_len + 1) + (id_len + 1) + (line_len + 1) + (host_len + 1);\n<line13>idx_t needed = entry_bytes + needed_string_bytes;\n<line14>if (avail < needed)\n<line15>{\n<line16>idx_t old_string_offset = a.alloc_bytes - a.string_bytes;\n<line17>void *new = xpalloc (a.utmp, &a.alloc_bytes, needed - avail, -1, 1);\n<line18>idx_t new_string_offset = a.alloc_bytes - a.string_bytes;\n<line19>a.utmp = new;\n<line20>char *q = new;\n<line21>memmove (q + new_string_offset, q + old_string_offset, a.string_bytes);\n<line22>}\n<line23>struct gl_utmp *ut = &a.utmp[a.filled];\n<line24>char *stringlim = (char *) a.utmp + a.alloc_bytes;\n<line25>char *p = stringlim - a.string_bytes;\n<line26>*--p = '\0'; /* NUL-terminate ut->ut_user */\n<line27>ut->ut_user = p = memcpy (p - user_len, user, user_len);\n<line28>*--p = '\0'; /* NUL-terminate ut->ut_id */\n<line29>ut->ut_id   = p = memcpy (p -   id_len,   id,   id_len);\n<line30>*--p = '\0'; /* NUL-terminate ut->ut_line */\n<line31>ut->ut_line = p = memcpy (p - line_len, line, line_len);\n<line32>*--p = '\0'; /* NUL-terminate ut->ut_host */\n<line33>ut->ut_host =     memcpy (p - host_len, host, host_len);\n<line34>ut->ut_ts = ts;\n<line35>ut->ut_pid = pid;\n<line36>ut->ut_session = session;\n<line37>ut->ut_type = type;\n<line38>ut->ut_exit.e_termination = termination;\n<line39>ut->ut_exit.e_exit = exit;\n<line40>if (desirable_utmp_entry (ut, options))\n<line41>{\n<line42>/* Now that UT has been checked, relocate its string slots to be\n<line43>relative to the end of the allocated storage, so that these\n<line44>slots survive realloc.  The slots will be relocated back just\n<line45>before read_utmp returns.  */\n<line46>ut->ut_user = (char *) (intptr_t) (ut->ut_user - stringlim);\n<line47>ut->ut_id   = (char *) (intptr_t) (ut->ut_id   - stringlim);\n<line48>ut->ut_line = (char *) (intptr_t) (ut->ut_line - stringlim);\n<line49>ut->ut_host = (char *) (intptr_t) (ut->ut_host - stringlim);\n<line50>a.filled++;\n<line51>a.string_bytes += needed_string_bytes;\n<line52>}\n<line53>return a;\n<line54>}
----------------------------------------
Function: finish_utmp
Content: <line0>static struct utmp_alloc\n<line1>finish_utmp (struct utmp_alloc a)\n<line2>{\n<line3>char *stringlim = (char *) a.utmp + a.alloc_bytes;\n<line4>for (idx_t i = 0; i < a.filled; i++)\n<line5>{\n<line6>a.utmp[i].ut_user = (intptr_t) a.utmp[i].ut_user + stringlim;\n<line7>a.utmp[i].ut_id   = (intptr_t) a.utmp[i].ut_id   + stringlim;\n<line8>a.utmp[i].ut_line = (intptr_t) a.utmp[i].ut_line + stringlim;\n<line9>a.utmp[i].ut_host = (intptr_t) a.utmp[i].ut_host + stringlim;\n<line10>}\n<line11>return a;\n<line12>}
----------------------------------------
Function: read_utmp_from_file
Content: <line0>static int\n<line1>read_utmp_from_file (char const *file, idx_t *n_entries, STRUCT_UTMP **utmp_buf,\n<line2>int options)\n<line3>{\n<line4>if ((options & READ_UTMP_BOOT_TIME) != 0\n<line5>&& (options & (READ_UTMP_USER_PROCESS | READ_UTMP_NO_BOOT_TIME)) != 0)\n<line6>{\n<line7>/* No entries can match the given options.  */\n<line8>*n_entries = 0;\n<line9>*utmp_buf = NULL;\n<line10>return 0;\n<line11>}\n<line12>struct utmp_alloc a = {0};\n<line13># if READUTMP_USE_SYSTEMD || HAVE_UTMPX_H || HAVE_UTMP_H\n<line14>#  if defined UTMP_NAME_FUNCTION /* glibc, musl, macOS, FreeBSD, NetBSD, Minix, AIX, IRIX, Solaris, Cygwin, Android */\n<line15>/* Ignore the return value for now.\n<line16>Solaris' utmpname returns 1 upon success -- which is contrary\n<line17>to what the GNU libc version does.  In addition, older GNU libc\n<line18>versions are actually void.   */\n<line19>UTMP_NAME_FUNCTION ((char *) file);\n<line20>SET_UTMP_ENT ();\n<line21>#   if (defined __linux__ && !defined __ANDROID__) || defined __minix\n<line22>bool file_is_utmp = (strcmp (file, UTMP_FILE) == 0);\n<line23>/* Timestamp of the "runlevel" entry, if any.  */\n<line24>struct timespec runlevel_ts = {0};\n<line25>#   endif\n<line26>void const *entry;\n<line27>while ((entry = GET_UTMP_ENT ()) != NULL)\n<line28>{\n<line29>struct UTMP_STRUCT_NAME const *ut = (struct UTMP_STRUCT_NAME const *) entry;\n<line30>struct timespec ts =\n<line31>#if (HAVE_UTMPX_H ? 1 : HAVE_STRUCT_UTMP_UT_TV)\n<line32>{ .tv_sec = ut->ut_tv.tv_sec, .tv_nsec = ut->ut_tv.tv_usec * 1000 };\n<line33>#else\n<line34>{ .tv_sec = ut->ut_time, .tv_nsec = 0 };\n<line35>#endif\n<line36>a = add_utmp (a, options,\n<line37>UT_USER (ut), strnlen (UT_USER (ut), UT_USER_SIZE),\n<line38>#if (HAVE_UTMPX_H ? HAVE_STRUCT_UTMPX_UT_ID : HAVE_STRUCT_UTMP_UT_ID)\n<line39>ut->ut_id, strnlen (ut->ut_id, UT_ID_SIZE),\n<line40>#else\n<line41>"", 0,\n<line42>#endif\n<line43>ut->ut_line, strnlen (ut->ut_line, UT_LINE_SIZE),\n<line44>#if (HAVE_UTMPX_H ? HAVE_STRUCT_UTMPX_UT_HOST : HAVE_STRUCT_UTMP_UT_HOST)\n<line45>ut->ut_host, strnlen (ut->ut_host, UT_HOST_SIZE),\n<line46>#else\n<line47>"", 0,\n<line48>#endif\n<line49>#if (HAVE_UTMPX_H ? HAVE_STRUCT_UTMPX_UT_PID : HAVE_STRUCT_UTMP_UT_PID)\n<line50>ut->ut_pid,\n<line51>#else\n<line52>0,\n<line53>#endif\n<line54>#if (HAVE_UTMPX_H ? HAVE_STRUCT_UTMPX_UT_TYPE : HAVE_STRUCT_UTMP_UT_TYPE)\n<line55>ut->ut_type,\n<line56>#else\n<line57>0,\n<line58>#endif\n<line59>ts,\n<line60>#if (HAVE_UTMPX_H ? HAVE_STRUCT_UTMPX_UT_SESSION : HAVE_STRUCT_UTMP_UT_SESSION)\n<line61>ut->ut_session,\n<line62>#else\n<line63>0,\n<line64>#endif\n<line65>UT_EXIT_E_TERMINATION (ut), UT_EXIT_E_EXIT (ut)\n<line66>);\n<line67>#   if defined __linux__ && !defined __ANDROID__\n<line68>if (file_is_utmp\n<line69>&& memcmp (UT_USER (ut), "runlevel", strlen ("runlevel") + 1) == 0\n<line70>&& memcmp (ut->ut_line, "~", strlen ("~") + 1) == 0)\n<line71>runlevel_ts = ts;\n<line72>#   endif\n<line73>#   if defined __minix\n<line74>if (file_is_utmp\n<line75>&& UT_USER (ut)[0] == '\0'\n<line76>&& memcmp (ut->ut_line, "run-level ", strlen ("run-level ")) == 0)\n<line77>runlevel_ts = ts;\n<line78>#   endif\n<line79>}\n<line80>END_UTMP_ENT ();\n<line81>#   if defined __linux__ && !defined __ANDROID__\n<line82>/* On Alpine Linux, UTMP_FILE is not filled.  It is always empty.\n<line83>So, fake a BOOT_TIME entry, by getting the time stamp of a file that\n<line84>gets touched only during the boot process.\n<line85>On Raspbian, which runs on hardware without a real-time clock, during boot,\n<line86>1. the clock gets set to 1970-01-01 00:00:00,\n<line87>2. an entry gets written into /var/run/utmp, with ut_type = BOOT_TIME,\n<line88>ut_user = "reboot", ut_line = "~", time = 1970-01-01 00:00:05 or so,\n<line89>3. the clock gets set to a correct value through NTP,\n<line90>4. an entry gets written into /var/run/utmp, with\n<line91>ut_user = "runlevel", ut_line = "~", time = correct value.\n<line92>In this case, copy the time from the "runlevel" entry to the "reboot"\n<line93>entry.  */\n<line94>if ((options & (READ_UTMP_USER_PROCESS | READ_UTMP_NO_BOOT_TIME)) == 0\n<line95>&& file_is_utmp)\n<line96>{\n<line97>for (idx_t i = 0; i < a.filled; i++)\n<line98>{\n<line99>struct gl_utmp *ut = &a.utmp[i];\n<line100>if (UT_TYPE_BOOT_TIME (ut))\n<line101>{\n<line102>/* Workaround for Raspbian:  */\n<line103>if (ut->ut_ts.tv_sec <= 60 && runlevel_ts.tv_sec != 0)\n<line104>ut->ut_ts = runlevel_ts;\n<line105>break;\n<line106>}\n<line107>}\n<line108>if (!have_boot_time (a))\n<line109>{\n<line110>/* Workaround for Alpine Linux:  */\n<line111>struct timespec boot_time;\n<line112>if (get_linux_boot_time_fallback (&boot_time) >= 0)\n<line113>a = add_utmp (a, options,\n<line114>"reboot", strlen ("reboot"),\n<line115>"", 0,\n<line116>"~", strlen ("~"),\n<line117>"", 0,\n<line118>0, BOOT_TIME, boot_time, 0, 0, 0);\n<line119>}\n<line120>}\n<line121>#   endif\n<line122>#   if defined __ANDROID__\n<line123>/* On Android, there is no /var, and normal processes don't have access\n<line124>to system files.  Therefore use the kernel's uptime counter, although\n<line125>it produces wrong values after the date has been bumped in the running\n<line126>system.  */\n<line127>if ((options & (READ_UTMP_USER_PROCESS | READ_UTMP_NO_BOOT_TIME)) == 0\n<line128>&& strcmp (file, UTMP_FILE) == 0\n<line129>&& !have_boot_time (a))\n<line130>{\n<line131>struct timespec boot_time;\n<line132>if (get_android_boot_time (&boot_time) >= 0)\n<line133>a = add_utmp (a, options,\n<line134>"reboot", strlen ("reboot"),\n<line135>"", 0,\n<line136>"", 0,\n<line137>"", 0,\n<line138>0, BOOT_TIME, boot_time, 0, 0, 0);\n<line139>}\n<line140>#   endif\n<line141>#   if defined __minix\n<line142>/* On Minix, during boot,\n<line143>1. an entry gets written into /var/run/utmp, with ut_type = BOOT_TIME,\n<line144>ut_user = "", ut_line = "system boot", time = 1970-01-01 00:00:00,\n<line145>2. an entry gets written into /var/run/utmp, with\n<line146>ut_user = "", ut_line = "run-level m", time = correct value.\n<line147>In this case, copy the time from the "run-level m" entry to the\n<line148>"system boot" entry.  */\n<line149>if ((options & (READ_UTMP_USER_PROCESS | READ_UTMP_NO_BOOT_TIME)) == 0\n<line150>&& file_is_utmp)\n<line151>{\n<line152>for (idx_t i = 0; i < a.filled; i++)\n<line153>{\n<line154>struct gl_utmp *ut = &a.utmp[i];\n<line155>if (UT_TYPE_BOOT_TIME (ut))\n<line156>{\n<line157>if (ut->ut_ts.tv_sec <= 60 && runlevel_ts.tv_sec != 0)\n<line158>ut->ut_ts = runlevel_ts;\n<line159>break;\n<line160>}\n<line161>}\n<line162>}\n<line163>#   endif\n<line164>#  else /* old FreeBSD, OpenBSD, HP-UX, Haiku */\n<line165>FILE *f = fopen (file, "re");\n<line166>if (f != NULL)\n<line167>{\n<line168>for (;;)\n<line169>{\n<line170>struct UTMP_STRUCT_NAME ut;\n<line171>if (fread (&ut, sizeof ut, 1, f) == 0)\n<line172>break;\n<line173>a = add_utmp (a, options,\n<line174>UT_USER (&ut), strnlen (UT_USER (&ut), UT_USER_SIZE),\n<line175>#if (HAVE_UTMPX_H ? HAVE_STRUCT_UTMPX_UT_ID : HAVE_STRUCT_UTMP_UT_ID)\n<line176>ut.ut_id, strnlen (ut.ut_id, UT_ID_SIZE),\n<line177>#else\n<line178>"", 0,\n<line179>#endif\n<line180>ut.ut_line, strnlen (ut.ut_line, UT_LINE_SIZE),\n<line181>#if (HAVE_UTMPX_H ? HAVE_STRUCT_UTMPX_UT_HOST : HAVE_STRUCT_UTMP_UT_HOST)\n<line182>ut.ut_host, strnlen (ut.ut_host, UT_HOST_SIZE),\n<line183>#else\n<line184>"", 0,\n<line185>#endif\n<line186>#if (HAVE_UTMPX_H ? HAVE_STRUCT_UTMPX_UT_PID : HAVE_STRUCT_UTMP_UT_PID)\n<line187>ut.ut_pid,\n<line188>#else\n<line189>0,\n<line190>#endif\n<line191>#if (HAVE_UTMPX_H ? HAVE_STRUCT_UTMPX_UT_TYPE : HAVE_STRUCT_UTMP_UT_TYPE)\n<line192>ut.ut_type,\n<line193>#else\n<line194>0,\n<line195>#endif\n<line196>#if (HAVE_UTMPX_H ? 1 : HAVE_STRUCT_UTMP_UT_TV)\n<line197>(struct timespec) { .tv_sec = ut.ut_tv.tv_sec, .tv_nsec = ut.ut_tv.tv_usec * 1000 },\n<line198>#else\n<line199>(struct timespec) { .tv_sec = ut.ut_time, .tv_nsec = 0 },\n<line200>#endif\n<line201>#if (HAVE_UTMPX_H ? HAVE_STRUCT_UTMPX_UT_SESSION : HAVE_STRUCT_UTMP_UT_SESSION)\n<line202>ut.ut_session,\n<line203>#else\n<line204>0,\n<line205>#endif\n<line206>UT_EXIT_E_TERMINATION (&ut), UT_EXIT_E_EXIT (&ut)\n<line207>);\n<line208>}\n<line209>int saved_errno = ferror (f) ? errno : 0;\n<line210>if (fclose (f) != 0)\n<line211>saved_errno = errno;\n<line212>if (saved_errno != 0)\n<line213>{\n<line214>free (a.utmp);\n<line215>errno = saved_errno;\n<line216>return -1;\n<line217>}\n<line218>}\n<line219>else\n<line220>{\n<line221>if (strcmp (file, UTMP_FILE) != 0)\n<line222>{\n<line223>int saved_errno = errno;\n<line224>free (a.utmp);\n<line225>errno = saved_errno;\n<line226>return -1;\n<line227>}\n<line228>}\n<line229>#   if defined __OpenBSD__\n<line230>if ((options & (READ_UTMP_USER_PROCESS | READ_UTMP_NO_BOOT_TIME)) == 0\n<line231>&& strcmp (file, UTMP_FILE) == 0\n<line232>&& !have_boot_time (a))\n<line233>{\n<line234>struct timespec boot_time;\n<line235>if (get_openbsd_boot_time (&boot_time) >= 0)\n<line236>a = add_utmp (a, options,\n<line237>"reboot", strlen ("reboot"),\n<line238>"", 0,\n<line239>"", 0,\n<line240>"", 0,\n<line241>0, BOOT_TIME, boot_time, 0, 0, 0);\n<line242>}\n<line243>#   endif\n<line244>#  endif\n<line245>#  if defined __linux__ && !defined __ANDROID__\n<line246>if ((options & (READ_UTMP_USER_PROCESS | READ_UTMP_NO_BOOT_TIME)) == 0\n<line247>&& strcmp (file, UTMP_FILE) == 0\n<line248>&& !have_boot_time (a))\n<line249>{\n<line250>struct timespec boot_time;\n<line251>if (get_linux_boot_time_final_fallback (&boot_time) >= 0)\n<line252>a = add_utmp (a, options,\n<line253>"reboot", strlen ("reboot"),\n<line254>"", 0,\n<line255>"~", strlen ("~"),\n<line256>"", 0,\n<line257>0, BOOT_TIME, boot_time, 0, 0, 0);\n<line258>}\n<line259>#  endif\n<line260>#  if HAVE_SYS_SYSCTL_H && HAVE_SYSCTL \\n<line261>&& defined CTL_KERN && defined KERN_BOOTTIME \\n<line262>&& !defined __minix\n<line263>if ((options & (READ_UTMP_USER_PROCESS | READ_UTMP_NO_BOOT_TIME)) == 0\n<line264>&& strcmp (file, UTMP_FILE) == 0\n<line265>&& !have_boot_time (a))\n<line266>{\n<line267>struct timespec boot_time;\n<line268>if (get_bsd_boot_time_final_fallback (&boot_time) >= 0)\n<line269>a = add_utmp (a, options,\n<line270>"reboot", strlen ("reboot"),\n<line271>"", 0,\n<line272>"", 0,\n<line273>"", 0,\n<line274>0, BOOT_TIME, boot_time, 0, 0, 0);\n<line275>}\n<line276>#  endif\n<line277>#  if defined __HAIKU__\n<line278>if ((options & (READ_UTMP_USER_PROCESS | READ_UTMP_NO_BOOT_TIME)) == 0\n<line279>&& strcmp (file, UTMP_FILE) == 0\n<line280>&& !have_boot_time (a))\n<line281>{\n<line282>struct timespec boot_time;\n<line283>if (get_haiku_boot_time (&boot_time) >= 0)\n<line284>a = add_utmp (a, options,\n<line285>"reboot", strlen ("reboot"),\n<line286>"", 0,\n<line287>"", 0,\n<line288>"", 0,\n<line289>0, BOOT_TIME, boot_time, 0, 0, 0);\n<line290>}\n<line291>#  endif\n<line292>#  if HAVE_OS_H /* BeOS, Haiku */\n<line293>if ((options & (READ_UTMP_USER_PROCESS | READ_UTMP_NO_BOOT_TIME)) == 0\n<line294>&& strcmp (file, UTMP_FILE) == 0\n<line295>&& !have_boot_time (a))\n<line296>{\n<line297>struct timespec boot_time;\n<line298>if (get_haiku_boot_time_final_fallback (&boot_time) >= 0)\n<line299>a = add_utmp (a, options,\n<line300>"reboot", strlen ("reboot"),\n<line301>"", 0,\n<line302>"", 0,\n<line303>"", 0,\n<line304>0, BOOT_TIME, boot_time, 0, 0, 0);\n<line305>}\n<line306>#  endif\n<line307># endif\n<line308># if defined __CYGWIN__ || defined _WIN32\n<line309>if ((options & (READ_UTMP_USER_PROCESS | READ_UTMP_NO_BOOT_TIME)) == 0\n<line310>&& strcmp (file, UTMP_FILE) == 0\n<line311>&& !have_boot_time (a))\n<line312>{\n<line313>struct timespec boot_time;\n<line314>if (get_windows_boot_time (&boot_time) >= 0)\n<line315>a = add_utmp (a, options,\n<line316>"reboot", strlen ("reboot"),\n<line317>"", 0,\n<line318>"", 0,\n<line319>"", 0,\n<line320>0, BOOT_TIME, boot_time, 0, 0, 0);\n<line321>}\n<line322># endif\n<line323>a = finish_utmp (a);\n<line324>*n_entries = a.filled;\n<line325>*utmp_buf = a.utmp;\n<line326>return 0;\n<line327>}
----------------------------------------
Function: read_utmp
Content: <line0>int\n<line1>read_utmp (char const *file, idx_t *n_entries, STRUCT_UTMP **utmp_buf,\n<line2>int options)\n<line3>{\n<line4># if READUTMP_USE_SYSTEMD\n<line5>if (strcmp (file, UTMP_FILE) == 0)\n<line6>/* Imitate reading UTMP_FILE, using systemd and Linux APIs.  */\n<line7>return read_utmp_from_systemd (n_entries, utmp_buf, options);\n<line8># endif\n<line9>return read_utmp_from_file (file, n_entries, utmp_buf, options);\n<line10>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/renameatu.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
Function: errno_fail
Content: <line0>static int\n<line1>errno_fail (int e)\n<line2>{\n<line3>errno = e;\n<line4>return -1;\n<line5>}
----------------------------------------
Function: renameat2ish
Content: <line0>static int\n<line1>renameat2ish (int fd1, char const *src, int fd2, char const *dst,\n<line2>unsigned int flags)\n<line3>{\n<line4># ifdef RENAME_EXCL\n<line5>if (flags)\n<line6>{\n<line7>int r = renameatx_np (fd1, src, fd2, dst, RENAME_EXCL);\n<line8>if (r == 0 || errno != ENOTSUP)\n<line9>return r;\n<line10>}\n<line11># endif\n<line12>return renameat (fd1, src, fd2, dst);\n<line13>}
----------------------------------------
Function: renameatu
Content: <line0>int\n<line1>renameatu (int fd1, char const *src, int fd2, char const *dst,\n<line2>unsigned int flags)\n<line3>{\n<line4>int ret_val = -1;\n<line5>int err = EINVAL;\n<line6>#ifdef HAVE_RENAMEAT2\n<line7>ret_val = renameat2 (fd1, src, fd2, dst, flags);\n<line8>err = errno;\n<line9>#elif defined SYS_renameat2\n<line10>ret_val = syscall (SYS_renameat2, fd1, src, fd2, dst, flags);\n<line11>err = errno;\n<line12>#endif\n<line13>if (! (ret_val < 0 && (err == EINVAL || err == ENOSYS || err == ENOTSUP)))\n<line14>return ret_val;\n<line15>#if HAVE_RENAMEAT\n<line16>{\n<line17>size_t src_len;\n<line18>size_t dst_len;\n<line19>char *src_temp = (char *) src;\n<line20>char *dst_temp = (char *) dst;\n<line21>bool src_slash;\n<line22>bool dst_slash;\n<line23>int rename_errno = ENOTDIR;\n<line24>struct stat src_st;\n<line25>struct stat dst_st;\n<line26>bool dst_found_nonexistent = false;\n<line27>switch (flags)\n<line28>{\n<line29>case 0:\n<line30>break;\n<line31>case RENAME_NOREPLACE:\n<line32>/* This has a race between the call to fstatat and the calls to\n<line33>renameat below.  This fstatat is needed even if RENAME_EXCL\n<line34>is defined, because RENAME_EXCL is buggy on macOS 11.2:\n<line35>renameatx_np (fd, "X", fd, "X", RENAME_EXCL) incorrectly\n<line36>succeeds when X exists.  */\n<line37>if (fstatat (fd2, dst, &dst_st, AT_SYMLINK_NOFOLLOW) == 0\n<line38>|| errno == EOVERFLOW)\n<line39>return errno_fail (EEXIST);\n<line40>if (errno != ENOENT)\n<line41>return -1;\n<line42>dst_found_nonexistent = true;\n<line43>break;\n<line44>default:\n<line45>return errno_fail (ENOTSUP);\n<line46>}\n<line47>/* Let strace see any ENOENT failure.  */\n<line48>src_len = strlen (src);\n<line49>dst_len = strlen (dst);\n<line50>if (!src_len || !dst_len)\n<line51>return renameat2ish (fd1, src, fd2, dst, flags);\n<line52>src_slash = src[src_len - 1] == '/';\n<line53>dst_slash = dst[dst_len - 1] == '/';\n<line54>if (!src_slash && !dst_slash)\n<line55>return renameat2ish (fd1, src, fd2, dst, flags);\n<line56>/* Presence of a trailing slash requires directory semantics.  If\n<line57>the source does not exist, or if the destination cannot be turned\n<line58>into a directory, give up now.  Otherwise, strip trailing slashes\n<line59>before calling rename.  */\n<line60>if (fstatat (fd1, src, &src_st, AT_SYMLINK_NOFOLLOW))\n<line61>return -1;\n<line62>if (dst_found_nonexistent)\n<line63>{\n<line64>if (!S_ISDIR (src_st.st_mode))\n<line65>return errno_fail (ENOENT);\n<line66>}\n<line67>else if (fstatat (fd2, dst, &dst_st, AT_SYMLINK_NOFOLLOW))\n<line68>{\n<line69>if (errno != ENOENT || !S_ISDIR (src_st.st_mode))\n<line70>return -1;\n<line71>}\n<line72>else if (!S_ISDIR (dst_st.st_mode))\n<line73>return errno_fail (ENOTDIR);\n<line74>else if (!S_ISDIR (src_st.st_mode))\n<line75>return errno_fail (EISDIR);\n<line76># if RENAME_TRAILING_SLASH_SOURCE_BUG\n<line77>/* See the lengthy comment in rename.c why Solaris 9 is forced to\n<line78>GNU behavior, while Solaris 10 is left with POSIX behavior,\n<line79>regarding symlinks with trailing slash.  */\n<line80>ret_val = -1;\n<line81>if (src_slash)\n<line82>{\n<line83>src_temp = strdup (src);\n<line84>if (!src_temp)\n<line85>{\n<line86>/* Rather than rely on strdup-posix, we set errno ourselves.  */\n<line87>rename_errno = ENOMEM;\n<line88>goto out;\n<line89>}\n<line90>strip_trailing_slashes (src_temp);\n<line91>if (fstatat (fd1, src_temp, &src_st, AT_SYMLINK_NOFOLLOW))\n<line92>{\n<line93>rename_errno = errno;\n<line94>goto out;\n<line95>}\n<line96>if (S_ISLNK (src_st.st_mode))\n<line97>goto out;\n<line98>}\n<line99>if (dst_slash)\n<line100>{\n<line101>dst_temp = strdup (dst);\n<line102>if (!dst_temp)\n<line103>{\n<line104>rename_errno = ENOMEM;\n<line105>goto out;\n<line106>}\n<line107>strip_trailing_slashes (dst_temp);\n<line108>char readlink_buf[1];\n<line109>if (readlinkat (fd2, dst_temp, readlink_buf, sizeof readlink_buf) < 0)\n<line110>{\n<line111>if (errno != ENOENT && errno != EINVAL)\n<line112>{\n<line113>rename_errno = errno;\n<line114>goto out;\n<line115>}\n<line116>}\n<line117>else\n<line118>goto out;\n<line119>}\n<line120># endif /* RENAME_TRAILING_SLASH_SOURCE_BUG */\n<line121>/* renameat does not honor trailing / on Solaris 10.  Solve it in a\n<line122>similar manner to rename.  No need to worry about bugs not present\n<line123>on Solaris, since all other systems either lack renameat or honor\n<line124>trailing slash correctly.  */\n<line125>ret_val = renameat2ish (fd1, src_temp, fd2, dst_temp, flags);\n<line126>rename_errno = errno;\n<line127>goto out;\n<line128>out:\n<line129>if (src_temp != src)\n<line130>free (src_temp);\n<line131>if (dst_temp != dst)\n<line132>free (dst_temp);\n<line133>errno = rename_errno;\n<line134>return ret_val;\n<line135>}\n<line136>#else /* !HAVE_RENAMEAT */\n<line137>/* RENAME_NOREPLACE is the only flag currently supported.  */\n<line138>if (flags & ~RENAME_NOREPLACE)\n<line139>return errno_fail (ENOTSUP);\n<line140>return at_func2 (fd1, src, fd2, dst, flags ? rename_noreplace : rename);\n<line141>#endif /* !HAVE_RENAMEAT */\n<line142>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/root-dev-ino.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
Function: get_root_dev_ino
Content: <line0>struct dev_ino *\n<line1>get_root_dev_ino (struct dev_ino *root_d_i)\n<line2>{\n<line3>struct stat statbuf;\n<line4>if (lstat ("/", &statbuf))\n<line5>return nullptr;\n<line6>root_d_i->st_ino = statbuf.st_ino;\n<line7>root_d_i->st_dev = statbuf.st_dev;\n<line8>return root_d_i;\n<line9>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/safe-read.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
Function: safe_read
Content: <line0>size_t\n<line1>safe_rw (int fd, void const *buf, size_t count)\n<line2>{\n<line3>for (;;)\n<line4>{\n<line5>ssize_t result = rw (fd, buf, count);\n<line6>if (0 <= result)\n<line7>return result;\n<line8>else if (IS_EINTR (errno))\n<line9>continue;\n<line10>else if (errno == EINVAL && SYS_BUFSIZE_MAX < count)\n<line11>count = SYS_BUFSIZE_MAX;\n<line12>else\n<line13>return result;\n<line14>}\n<line15>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/safe-write.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
========================================
/home/huihui/Downloads/coreutils-9.4/lib/same.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
In file included from /home/huihui/Downloads/coreutils-9.4/lib/same.c:40:
./lib/error.h:28:3: warning: #include_next in file found relative to primary source file or found by absolute path; will search from start of include path [-Winclude-next-absolute-path]
# include_next <error.h>
  ^
2 warnings generated.
========================================
/home/huihui/Downloads/coreutils-9.4/lib/save-cwd.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
Function: save_cwd
Content: <line0>int\n<line1>save_cwd (struct saved_cwd *cwd)\n<line2>{\n<line3>cwd->name = NULL;\n<line4>cwd->desc = open (".", O_SEARCH | O_CLOEXEC);\n<line5>if (!GNULIB_FCNTL_SAFER)\n<line6>cwd->desc = fd_safer_flag (cwd->desc, O_CLOEXEC);\n<line7>if (cwd->desc < 0)\n<line8>{\n<line9>cwd->name = getcwd (NULL, 0);\n<line10>return cwd->name ? 0 : -1;\n<line11>}\n<line12>return 0;\n<line13>}
----------------------------------------
Function: restore_cwd
Content: <line0>int\n<line1>restore_cwd (const struct saved_cwd *cwd)\n<line2>{\n<line3>if (0 <= cwd->desc)\n<line4>return fchdir (cwd->desc);\n<line5>else\n<line6>return chdir_long (cwd->name);\n<line7>}
----------------------------------------
Function: free_cwd
Content: <line0>void\n<line1>free_cwd (struct saved_cwd *cwd)\n<line2>{\n<line3>if (cwd->desc >= 0)\n<line4>close (cwd->desc);\n<line5>free (cwd->name);\n<line6>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/savedir.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
Function: direntry_cmp_name
Content: <line0>static int\n<line1>direntry_cmp_name (void const *a, void const *b)\n<line2>{\n<line3>direntry_t const *dea = a;\n<line4>direntry_t const *deb = b;\n<line5>return strcmp (dea->name, deb->name);\n<line6>}
----------------------------------------
Function: direntry_cmp_inode
Content: <line0>static int\n<line1>direntry_cmp_inode (void const *a, void const *b)\n<line2>{\n<line3>direntry_t const *dea = a;\n<line4>direntry_t const *deb = b;\n<line5>return _GL_CMP (dea->ino, deb->ino);\n<line6>}
----------------------------------------
Function: streamsavedir
Content: <line0>char *\n<line1>streamsavedir (DIR *dirp, enum savedir_option option)\n<line2>{\n<line3>char *name_space = NULL;\n<line4>idx_t allocated = 0;\n<line5>direntry_t *entries = NULL;\n<line6>idx_t entries_allocated = 0;\n<line7>idx_t entries_used = 0;\n<line8>idx_t used = 0;\n<line9>comparison_function cmp = comparison_function_table[option];\n<line10>if (dirp == NULL)\n<line11>return NULL;\n<line12>for (;;)\n<line13>{\n<line14>struct dirent const *dp;\n<line15>char const *entry;\n<line16>errno = 0;\n<line17>dp = readdir (dirp);\n<line18>if (! dp)\n<line19>break;\n<line20>/* Skip "", ".", and "..".  "" is returned by at least one buggy\n<line21>implementation: Solaris 2.4 readdir on NFS file systems.  */\n<line22>entry = dp->d_name;\n<line23>if (entry[entry[0] != '.' ? 0 : entry[1] != '.' ? 1 : 2] != '\0')\n<line24>{\n<line25>idx_t entry_size = _D_EXACT_NAMLEN (dp) + 1;\n<line26>if (cmp)\n<line27>{\n<line28>if (entries_allocated == entries_used)\n<line29>entries = xpalloc (entries, &entries_allocated, 1, -1,\n<line30>sizeof *entries);\n<line31>entries[entries_used].name = xstrdup (entry);\n<line32>#if D_INO_IN_DIRENT\n<line33>entries[entries_used].ino = dp->d_ino;\n<line34>#endif\n<line35>entries_used++;\n<line36>}\n<line37>else\n<line38>{\n<line39>if (allocated - used <= entry_size)\n<line40>name_space = xpalloc (name_space, &allocated,\n<line41>entry_size - (allocated - used),\n<line42>IDX_MAX - 1, sizeof *name_space);\n<line43>memcpy (name_space + used, entry, entry_size);\n<line44>}\n<line45>used += entry_size;\n<line46>}\n<line47>}\n<line48>if (errno != 0)\n<line49>{\n<line50>free (entries);\n<line51>free (name_space);\n<line52>return NULL;\n<line53>}\n<line54>if (cmp)\n<line55>{\n<line56>if (entries_used)\n<line57>qsort (entries, entries_used, sizeof *entries, cmp);\n<line58>name_space = ximalloc (used + 1);\n<line59>used = 0;\n<line60>for (idx_t i = 0; i < entries_used; i++)\n<line61>{\n<line62>char *dest = name_space + used;\n<line63>used += stpcpy (dest, entries[i].name) - dest + 1;\n<line64>free (entries[i].name);\n<line65>}\n<line66>free (entries);\n<line67>}\n<line68>else if (used == allocated)\n<line69>name_space = xirealloc (name_space, used + 1);\n<line70>name_space[used] = '\0';\n<line71>return name_space;\n<line72>}
----------------------------------------
Function: savedir
Content: <line0>char *\n<line1>savedir (char const *dir, enum savedir_option option)\n<line2>{\n<line3>DIR *dirp = opendir (dir);\n<line4>if (! dirp)\n<line5>return NULL;\n<line6>else\n<line7>{\n<line8>char *name_space = streamsavedir (dirp, option);\n<line9>if (closedir (dirp) != 0)\n<line10>{\n<line11>free (name_space);\n<line12>return NULL;\n<line13>}\n<line14>return name_space;\n<line15>}\n<line16>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/savewd.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
Function: savewd_save
Content: <line0>static bool\n<line1>savewd_save (struct savewd *wd)\n<line2>{\n<line3>switch (wd->state)\n<line4>{\n<line5>case INITIAL_STATE:\n<line6>/* Save the working directory, or prepare to fall back if possible.  */\n<line7>{\n<line8>int fd = open_safer (".", O_SEARCH);\n<line9>if (0 <= fd)\n<line10>{\n<line11>wd->state = FD_STATE;\n<line12>wd->val.fd = fd;\n<line13>break;\n<line14>}\n<line15>if (errno != EACCES && errno != ESTALE)\n<line16>{\n<line17>wd->state = ERROR_STATE;\n<line18>wd->val.errnum = errno;\n<line19>break;\n<line20>}\n<line21>}\n<line22>wd->state = FORKING_STATE;\n<line23>wd->val.child = -1;\n<line24>FALLTHROUGH;\n<line25>case FORKING_STATE:\n<line26>if (wd->val.child < 0)\n<line27>{\n<line28>/* "Save" the initial working directory by forking a new\n<line29>subprocess that will attempt all the work from the chdir\n<line30>until the next savewd_restore.  */\n<line31>wd->val.child = fork ();\n<line32>if (wd->val.child != 0)\n<line33>{\n<line34>if (0 < wd->val.child)\n<line35>return true;\n<line36>wd->state = ERROR_STATE;\n<line37>wd->val.errnum = errno;\n<line38>}\n<line39>}\n<line40>break;\n<line41>case FD_STATE:\n<line42>case FD_POST_CHDIR_STATE:\n<line43>case ERROR_STATE:\n<line44>case FINAL_STATE:\n<line45>break;\n<line46>default:\n<line47>assure (false);\n<line48>}\n<line49>return false;\n<line50>}
----------------------------------------
Function: savewd_chdir
Content: <line0>int\n<line1>savewd_chdir (struct savewd *wd, char const *dir, int options,\n<line2>int open_result[2])\n<line3>{\n<line4>int fd = -1;\n<line5>int result = 0;\n<line6>/* Open the directory if requested, or if avoiding a race condition\n<line7>is requested and possible.  */\n<line8>if (open_result\n<line9>|| (options & (HAVE_WORKING_O_NOFOLLOW ? SAVEWD_CHDIR_NOFOLLOW : 0)))\n<line10>{\n<line11>fd = open (dir,\n<line12>(O_SEARCH | O_DIRECTORY | O_NOCTTY | O_NONBLOCK\n<line13>| (options & SAVEWD_CHDIR_NOFOLLOW ? O_NOFOLLOW : 0)));\n<line14>if (open_result)\n<line15>{\n<line16>open_result[0] = fd;\n<line17>open_result[1] = errno;\n<line18>}\n<line19>if (fd < 0 && errno != EACCES)\n<line20>result = -1;\n<line21>}\n<line22>if (result == 0 && ! (0 <= fd && options & SAVEWD_CHDIR_SKIP_READABLE))\n<line23>{\n<line24>if (savewd_save (wd))\n<line25>{\n<line26>open_result = NULL;\n<line27>result = -2;\n<line28>}\n<line29>else\n<line30>{\n<line31>result = (fd < 0 ? chdir (dir) : fchdir (fd));\n<line32>if (result == 0)\n<line33>switch (wd->state)\n<line34>{\n<line35>case FD_STATE:\n<line36>wd->state = FD_POST_CHDIR_STATE;\n<line37>break;\n<line38>case ERROR_STATE:\n<line39>case FD_POST_CHDIR_STATE:\n<line40>case FINAL_STATE:\n<line41>break;\n<line42>case FORKING_STATE:\n<line43>assure (wd->val.child == 0);\n<line44>break;\n<line45>default:\n<line46>assure (false);\n<line47>}\n<line48>}\n<line49>}\n<line50>if (0 <= fd && ! open_result)\n<line51>{\n<line52>int e = errno;\n<line53>close (fd);\n<line54>errno = e;\n<line55>}\n<line56>return result;\n<line57>}
----------------------------------------
Function: savewd_restore
Content: <line0>int\n<line1>savewd_restore (struct savewd *wd, int status)\n<line2>{\n<line3>switch (wd->state)\n<line4>{\n<line5>case INITIAL_STATE:\n<line6>case FD_STATE:\n<line7>/* The working directory is the desired directory, so there's no\n<line8>work to do.  */\n<line9>break;\n<line10>case FD_POST_CHDIR_STATE:\n<line11>/* Restore the working directory using fchdir.  */\n<line12>if (fchdir (wd->val.fd) == 0)\n<line13>{\n<line14>wd->state = FD_STATE;\n<line15>break;\n<line16>}\n<line17>else\n<line18>{\n<line19>int chdir_errno = errno;\n<line20>close (wd->val.fd);\n<line21>wd->state = ERROR_STATE;\n<line22>wd->val.errnum = chdir_errno;\n<line23>}\n<line24>FALLTHROUGH;\n<line25>case ERROR_STATE:\n<line26>/* Report an error if asked to restore the working directory.  */\n<line27>errno = wd->val.errnum;\n<line28>return -1;\n<line29>case FORKING_STATE:\n<line30>/* "Restore" the working directory by waiting for the subprocess\n<line31>to finish.  */\n<line32>{\n<line33>pid_t child = wd->val.child;\n<line34>if (child == 0)\n<line35>_exit (status);\n<line36>if (0 < child)\n<line37>{\n<line38>int child_status;\n<line39>while (waitpid (child, &child_status, 0) < 0)\n<line40>assure (errno == EINTR);\n<line41>wd->val.child = -1;\n<line42>if (! WIFEXITED (child_status))\n<line43>raise (WTERMSIG (child_status));\n<line44>return WEXITSTATUS (child_status);\n<line45>}\n<line46>}\n<line47>break;\n<line48>default:\n<line49>assure (false);\n<line50>}\n<line51>return 0;\n<line52>}
----------------------------------------
Function: savewd_finish
Content: <line0>void\n<line1>savewd_finish (struct savewd *wd)\n<line2>{\n<line3>switch (wd->state)\n<line4>{\n<line5>case INITIAL_STATE:\n<line6>case ERROR_STATE:\n<line7>break;\n<line8>case FD_STATE:\n<line9>case FD_POST_CHDIR_STATE:\n<line10>close (wd->val.fd);\n<line11>break;\n<line12>case FORKING_STATE:\n<line13>assure (wd->val.child < 0);\n<line14>break;\n<line15>default:\n<line16>assure (false);\n<line17>}\n<line18>wd->state = FINAL_STATE;\n<line19>}
----------------------------------------
Function: savewd_delegating
Content: <line0>static bool\n<line1>savewd_delegating (struct savewd const *wd)\n<line2>{\n<line3>return wd->state == FORKING_STATE && 0 < wd->val.child;\n<line4>}
----------------------------------------
Function: savewd_process_files
Content: <line0>int\n<line1>savewd_process_files (int n_files, char **file,\n<line2>int (*act) (char *, struct savewd *, void *),\n<line3>void *options)\n<line4>{\n<line5>int i = 0;\n<line6>int last_relative;\n<line7>int exit_status = EXIT_SUCCESS;\n<line8>struct savewd wd;\n<line9>savewd_init (&wd);\n<line10>for (last_relative = n_files - 1; 0 <= last_relative; last_relative--)\n<line11>if (! IS_ABSOLUTE_FILE_NAME (file[last_relative]))\n<line12>break;\n<line13>for (; i < last_relative; i++)\n<line14>{\n<line15>if (! savewd_delegating (&wd))\n<line16>{\n<line17>int s = act (file[i], &wd, options);\n<line18>if (exit_status < s)\n<line19>exit_status = s;\n<line20>}\n<line21>if (! IS_ABSOLUTE_FILE_NAME (file[i + 1]))\n<line22>{\n<line23>int r = savewd_restore (&wd, exit_status);\n<line24>if (exit_status < r)\n<line25>exit_status = r;\n<line26>}\n<line27>}\n<line28>savewd_finish (&wd);\n<line29>for (; i < n_files; i++)\n<line30>{\n<line31>int s = act (file[i], &wd, options);\n<line32>if (exit_status < s)\n<line33>exit_status = s;\n<line34>}\n<line35>return exit_status;\n<line36>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/selinux-at.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
========================================
/home/huihui/Downloads/coreutils-9.4/lib/se-context.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
========================================
/home/huihui/Downloads/coreutils-9.4/lib/se-label.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
========================================
/home/huihui/Downloads/coreutils-9.4/lib/se-selinux.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
========================================
/home/huihui/Downloads/coreutils-9.4/lib/setlocale_null.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
Function: setlocale_null_androidfix
Content: <line0>static const char *\n<line1>setlocale_null_androidfix (int category)\n<line2>{\n<line3>const char *result = setlocale (category, NULL);\n<line4>#ifdef __ANDROID__\n<line5>if (result == NULL)\n<line6>switch (category)\n<line7>{\n<line8>case LC_CTYPE:\n<line9>case LC_NUMERIC:\n<line10>case LC_TIME:\n<line11>case LC_COLLATE:\n<line12>case LC_MONETARY:\n<line13>case LC_MESSAGES:\n<line14>case LC_ALL:\n<line15>case LC_PAPER:\n<line16>case LC_NAME:\n<line17>case LC_ADDRESS:\n<line18>case LC_TELEPHONE:\n<line19>case LC_MEASUREMENT:\n<line20>result = "C";\n<line21>break;\n<line22>default:\n<line23>break;\n<line24>}\n<line25>#endif\n<line26>return result;\n<line27>}
----------------------------------------
Function: setlocale_null_unlocked
Content: <line0>static int\n<line1>setlocale_null_unlocked (int category, char *buf, size_t bufsize)\n<line2>{\n<line3>#if defined _WIN32 && !defined __CYGWIN__ && defined _MSC_VER\n<line4>/* On native Windows, nowadays, the setlocale() implementation is based\n<line5>on _wsetlocale() and uses malloc() for the result.  We are better off\n<line6>using _wsetlocale() directly.  */\n<line7>const wchar_t *result = _wsetlocale (category, NULL);\n<line8>if (result == NULL)\n<line9>{\n<line10>/* CATEGORY is invalid.  */\n<line11>if (bufsize > 0)\n<line12>/* Return an empty string in BUF.\n<line13>This is a convenience for callers that don't want to write explicit\n<line14>code for handling EINVAL.  */\n<line15>buf[0] = '\0';\n<line16>return EINVAL;\n<line17>}\n<line18>else\n<line19>{\n<line20>size_t length = wcslen (result);\n<line21>if (length < bufsize)\n<line22>{\n<line23>size_t i;\n<line24>/* Convert wchar_t[] -> char[], assuming plain ASCII.  */\n<line25>for (i = 0; i <= length; i++)\n<line26>buf[i] = result[i];\n<line27>return 0;\n<line28>}\n<line29>else\n<line30>{\n<line31>if (bufsize > 0)\n<line32>{\n<line33>/* Return a truncated result in BUF.\n<line34>This is a convenience for callers that don't want to write\n<line35>explicit code for handling ERANGE.  */\n<line36>size_t i;\n<line37>/* Convert wchar_t[] -> char[], assuming plain ASCII.  */\n<line38>for (i = 0; i < bufsize; i++)\n<line39>buf[i] = result[i];\n<line40>buf[bufsize - 1] = '\0';\n<line41>}\n<line42>return ERANGE;\n<line43>}\n<line44>}\n<line45>#else\n<line46>const char *result = setlocale_null_androidfix (category);\n<line47>if (result == NULL)\n<line48>{\n<line49>/* CATEGORY is invalid.  */\n<line50>if (bufsize > 0)\n<line51>/* Return an empty string in BUF.\n<line52>This is a convenience for callers that don't want to write explicit\n<line53>code for handling EINVAL.  */\n<line54>buf[0] = '\0';\n<line55>return EINVAL;\n<line56>}\n<line57>else\n<line58>{\n<line59>size_t length = strlen (result);\n<line60>if (length < bufsize)\n<line61>{\n<line62>memcpy (buf, result, length + 1);\n<line63>return 0;\n<line64>}\n<line65>else\n<line66>{\n<line67>if (bufsize > 0)\n<line68>{\n<line69>/* Return a truncated result in BUF.\n<line70>This is a convenience for callers that don't want to write\n<line71>explicit code for handling ERANGE.  */\n<line72>memcpy (buf, result, bufsize - 1);\n<line73>buf[bufsize - 1] = '\0';\n<line74>}\n<line75>return ERANGE;\n<line76>}\n<line77>}\n<line78>#endif\n<line79>}
----------------------------------------
Function: setlocale_null_r
Content: <line0>int\n<line1>setlocale_null_r (int category, char *buf, size_t bufsize)\n<line2>{\n<line3>#if SETLOCALE_NULL_ALL_MTSAFE\n<line4># if SETLOCALE_NULL_ONE_MTSAFE\n<line5>return setlocale_null_unlocked (category, buf, bufsize);\n<line6># else\n<line7>if (category == LC_ALL)\n<line8>return setlocale_null_unlocked (category, buf, bufsize);\n<line9>else\n<line10>return setlocale_null_with_lock (category, buf, bufsize);\n<line11># endif\n<line12>#else\n<line13># if SETLOCALE_NULL_ONE_MTSAFE\n<line14>if (category == LC_ALL)\n<line15>return setlocale_null_with_lock (category, buf, bufsize);\n<line16>else\n<line17>return setlocale_null_unlocked (category, buf, bufsize);\n<line18># else\n<line19>return setlocale_null_with_lock (category, buf, bufsize);\n<line20># endif\n<line21>#endif\n<line22>}
----------------------------------------
Function: setlocale_null
Content: <line0>const char *\n<line1>setlocale_null (int category)\n<line2>{\n<line3>#if SETLOCALE_NULL_ALL_MTSAFE && SETLOCALE_NULL_ONE_MTSAFE\n<line4>return setlocale_null_androidfix (category);\n<line5>#else\n<line6>/* This call must be multithread-safe.  To achieve this without using\n<line7>thread-local storage:\n<line8>1. We use a specific static buffer for each possible CATEGORY\n<line9>argument.  So that different threads can call setlocale_mtsafe\n<line10>with different CATEGORY arguments, without interfering.\n<line11>2. We use a simple strcpy or memcpy to fill this static buffer.\n<line12>Filling it through, for example, strcpy + strcat would not be\n<line13>guaranteed to leave the buffer's contents intact if another thread\n<line14>is currently accessing it.  If necessary, the contents is first\n<line15>assembled in a stack-allocated buffer.  */\n<line16>if (category == LC_ALL)\n<line17>{\n<line18># if SETLOCALE_NULL_ALL_MTSAFE\n<line19>return setlocale_null_androidfix (LC_ALL);\n<line20># else\n<line21>char buf[SETLOCALE_NULL_ALL_MAX];\n<line22>static char resultbuf[SETLOCALE_NULL_ALL_MAX];\n<line23>if (setlocale_null_r (LC_ALL, buf, sizeof (buf)))\n<line24>return "C";\n<line25>strcpy (resultbuf, buf);\n<line26>return resultbuf;\n<line27># endif\n<line28>}\n<line29>else\n<line30>{\n<line31># if SETLOCALE_NULL_ONE_MTSAFE\n<line32>return setlocale_null_androidfix (category);\n<line33># else\n<line34>enum\n<line35>{\n<line36>LC_CTYPE_INDEX,\n<line37>LC_NUMERIC_INDEX,\n<line38>LC_TIME_INDEX,\n<line39>LC_COLLATE_INDEX,\n<line40>LC_MONETARY_INDEX,\n<line41>LC_MESSAGES_INDEX,\n<line42>#  ifdef LC_PAPER\n<line43>LC_PAPER_INDEX,\n<line44>#  endif\n<line45>#  ifdef LC_NAME\n<line46>LC_NAME_INDEX,\n<line47>#  endif\n<line48>#  ifdef LC_ADDRESS\n<line49>LC_ADDRESS_INDEX,\n<line50>#  endif\n<line51>#  ifdef LC_TELEPHONE\n<line52>LC_TELEPHONE_INDEX,\n<line53>#  endif\n<line54>#  ifdef LC_MEASUREMENT\n<line55>LC_MEASUREMENT_INDEX,\n<line56>#  endif\n<line57>#  ifdef LC_IDENTIFICATION\n<line58>LC_IDENTIFICATION_INDEX,\n<line59>#  endif\n<line60>LC_INDICES_COUNT\n<line61>}\n<line62>i;\n<line63>char buf[SETLOCALE_NULL_MAX];\n<line64>static char resultbuf[LC_INDICES_COUNT][SETLOCALE_NULL_MAX];\n<line65>int err;\n<line66>err = setlocale_null_r (category, buf, sizeof (buf));\n<line67>if (err == EINVAL)\n<line68>return NULL;\n<line69>if (err)\n<line70>return "C";\n<line71>switch (category)\n<line72>{\n<line73>case LC_CTYPE:          i = LC_CTYPE_INDEX;          break;\n<line74>case LC_NUMERIC:        i = LC_NUMERIC_INDEX;        break;\n<line75>case LC_TIME:           i = LC_TIME_INDEX;           break;\n<line76>case LC_COLLATE:        i = LC_COLLATE_INDEX;        break;\n<line77>case LC_MONETARY:       i = LC_MONETARY_INDEX;       break;\n<line78>case LC_MESSAGES:       i = LC_MESSAGES_INDEX;       break;\n<line79>#  ifdef LC_PAPER\n<line80>case LC_PAPER:          i = LC_PAPER_INDEX;          break;\n<line81>#  endif\n<line82>#  ifdef LC_NAME\n<line83>case LC_NAME:           i = LC_NAME_INDEX;           break;\n<line84>#  endif\n<line85>#  ifdef LC_ADDRESS\n<line86>case LC_ADDRESS:        i = LC_ADDRESS_INDEX;        break;\n<line87>#  endif\n<line88>#  ifdef LC_TELEPHONE\n<line89>case LC_TELEPHONE:      i = LC_TELEPHONE_INDEX;      break;\n<line90>#  endif\n<line91>#  ifdef LC_MEASUREMENT\n<line92>case LC_MEASUREMENT:    i = LC_MEASUREMENT_INDEX;    break;\n<line93>#  endif\n<line94>#  ifdef LC_IDENTIFICATION\n<line95>case LC_IDENTIFICATION: i = LC_IDENTIFICATION_INDEX; break;\n<line96>#  endif\n<line97>default:\n<line98>/* If you get here, a #ifdef LC_xxx is missing.  */\n<line99>abort ();\n<line100>}\n<line101>strcpy (resultbuf[i], buf);\n<line102>return resultbuf[i];\n<line103># endif\n<line104>}\n<line105>#endif\n<line106>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/settime.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
Function: settime
Content: <line0>int\n<line1>settime (struct timespec const *ts)\n<line2>{\n<line3>#if defined CLOCK_REALTIME && HAVE_CLOCK_SETTIME\n<line4>{\n<line5>int r = clock_settime (CLOCK_REALTIME, ts);\n<line6>if (r == 0 || errno == EPERM)\n<line7>return r;\n<line8>}\n<line9>#endif\n<line10>#if HAVE_SETTIMEOFDAY\n<line11>{\n<line12>struct timeval tv = { .tv_sec = ts->tv_sec,\n<line13>.tv_usec = ts->tv_nsec / 1000 };\n<line14>return settimeofday (&tv, 0);\n<line15>}\n<line16>#elif HAVE_STIME\n<line17>/* This fails to compile on OSF1 V5.1, due to stime requiring\n<line18>a 'long int*' and tv_sec is 'int'.  But that system does provide\n<line19>settimeofday.  */\n<line20>return stime (&ts->tv_sec);\n<line21>#else\n<line22>errno = ENOSYS;\n<line23>return -1;\n<line24>#endif\n<line25>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/sig2str.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
Function: str2signum
Content: <line0>static int\n<line1>str2signum (char const *signame)\n<line2>{\n<line3>if (ISDIGIT (*signame))\n<line4>{\n<line5>char *endp;\n<line6>long int n = strtol (signame, &endp, 10);\n<line7>if (! *endp && n <= SIGNUM_BOUND)\n<line8>return n;\n<line9>}\n<line10>else\n<line11>{\n<line12>unsigned int i;\n<line13>for (i = 0; i < NUMNAME_ENTRIES; i++)\n<line14>if (strcmp (numname_table[i].name, signame) == 0)\n<line15>return numname_table[i].num;\n<line16>{\n<line17>char *endp;\n<line18>int rtmin = SIGRTMIN;\n<line19>int rtmax = SIGRTMAX;\n<line20>if (0 < rtmin && strncmp (signame, "RTMIN", 5) == 0)\n<line21>{\n<line22>long int n = strtol (signame + 5, &endp, 10);\n<line23>if (! *endp && 0 <= n && n <= rtmax - rtmin)\n<line24>return rtmin + n;\n<line25>}\n<line26>else if (0 < rtmax && strncmp (signame, "RTMAX", 5) == 0)\n<line27>{\n<line28>long int n = strtol (signame + 5, &endp, 10);\n<line29>if (! *endp && rtmin - rtmax <= n && n <= 0)\n<line30>return rtmax + n;\n<line31>}\n<line32>}\n<line33>}\n<line34>return -1;\n<line35>}
----------------------------------------
Function: str2sig
Content: <line0>int\n<line1>str2sig (char const *signame, int *signum)\n<line2>{\n<line3>*signum = str2signum (signame);\n<line4>return *signum < 0 ? -1 : 0;\n<line5>}
----------------------------------------
Function: sig2str
Content: <line0>int\n<line1>sig2str (int signum, char *signame)\n<line2>{\n<line3>unsigned int i;\n<line4>for (i = 0; i < NUMNAME_ENTRIES; i++)\n<line5>if (numname_table[i].num == signum)\n<line6>{\n<line7>strcpy (signame, numname_table[i].name);\n<line8>return 0;\n<line9>}\n<line10>{\n<line11>int rtmin = SIGRTMIN;\n<line12>int rtmax = SIGRTMAX;\n<line13>int base, delta;\n<line14>if (! (rtmin <= signum && signum <= rtmax))\n<line15>return -1;\n<line16>if (signum <= rtmin + (rtmax - rtmin) / 2)\n<line17>{\n<line18>strcpy (signame, "RTMIN");\n<line19>base = rtmin;\n<line20>}\n<line21>else\n<line22>{\n<line23>strcpy (signame, "RTMAX");\n<line24>base = rtmax;\n<line25>}\n<line26>delta = signum - base;\n<line27>if (delta != 0)\n<line28>sprintf (signame + 5, "%+d", delta);\n<line29>return 0;\n<line30>}\n<line31>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/sig-handler.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
========================================
/home/huihui/Downloads/coreutils-9.4/lib/sockets.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
Function: gl_sockets_startup
Content: <line0>int\n<line1>gl_sockets_startup (_GL_UNUSED int version)\n<line2>{\n<line3>#if WINDOWS_SOCKETS\n<line4>if (version > initialized_sockets_version)\n<line5>{\n<line6>WSADATA data;\n<line7>int err;\n<line8>err = WSAStartup (version, &data);\n<line9>if (err != 0)\n<line10>return 1;\n<line11>if (data.wVersion != version)\n<line12>{\n<line13>WSACleanup ();\n<line14>return 2;\n<line15>}\n<line16>if (initialized_sockets_version == 0)\n<line17>register_fd_hook (close_fd_maybe_socket, ioctl_fd_maybe_socket,\n<line18>&fd_sockets_hook);\n<line19>initialized_sockets_version = version;\n<line20>}\n<line21>#endif\n<line22>return 0;\n<line23>}
----------------------------------------
Function: gl_sockets_cleanup
Content: <line0>int\n<line1>gl_sockets_cleanup (void)\n<line2>{\n<line3>#if WINDOWS_SOCKETS\n<line4>int err;\n<line5>initialized_sockets_version = 0;\n<line6>unregister_fd_hook (&fd_sockets_hook);\n<line7>err = WSACleanup ();\n<line8>if (err != 0)\n<line9>return 1;\n<line10>#endif\n<line11>return 0;\n<line12>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/stat-time.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
========================================
/home/huihui/Downloads/coreutils-9.4/lib/mkstemp-safer.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
Function: mkstemp_safer
Content: <line0>int\n<line1>mkstemp_safer (char *templ)\n<line2>{\n<line3>return fd_safer (mkstemp (templ));\n<line4>}
----------------------------------------
Function: mkostemp_safer
Content: <line0>int\n<line1>mkostemp_safer (char *templ, int flags)\n<line2>{\n<line3>return fd_safer_flag (mkostemp (templ, flags), flags);\n<line4>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/strnlen1.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
Function: strnlen1
Content: <line0>size_t\n<line1>strnlen1 (const char *string, size_t maxlen)\n<line2>{\n<line3>const char *end = (const char *) memchr (string, '\0', maxlen);\n<line4>if (end != NULL)\n<line5>return end - string + 1;\n<line6>else\n<line7>return maxlen;\n<line8>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/strintcmp.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
Function: strintcmp
Content: <line0>int\n<line1>strintcmp (char const *a, char const *b)\n<line2>{\n<line3>return numcompare (a, b, CHAR_MAX + 1, CHAR_MAX + 1);\n<line4>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/strnumcmp.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
Function: strnumcmp
Content: <line0>int\n<line1>strnumcmp (char const *a, char const *b,\n<line2>int decimal_point, int thousands_sep)\n<line3>{\n<line4>return numcompare (a, b, decimal_point, thousands_sep);\n<line5>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/sys_socket.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
========================================
/home/huihui/Downloads/coreutils-9.4/lib/targetdir.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
Function: target_directory_operand
Content: <line0>int\n<line1>target_directory_operand (char const *file, struct stat *st)\n<line2>{\n<line3>if (must_be_working_directory (file))\n<line4>return AT_FDCWD;\n<line5>int fd = -1;\n<line6>int try_to_open = 1;\n<line7>int stat_result;\n<line8>/* On old systems without O_DIRECTORY, like Solaris 10, check with\n<line9>stat first lest we try to open a fifo for example and hang.  */\n<line10>if (!O_DIRECTORY)\n<line11>{\n<line12>stat_result = stat (file, st);\n<line13>if (stat_result == 0)\n<line14>{\n<line15>try_to_open = S_ISDIR (st->st_mode);\n<line16>errno = ENOTDIR;\n<line17>}\n<line18>else\n<line19>{\n<line20>/* On EOVERFLOW failure, give up on checking, as there is no\n<line21>easy way to check.  This should be rare.  */\n<line22>try_to_open = errno == EOVERFLOW;\n<line23>}\n<line24>}\n<line25>if (try_to_open)\n<line26>{\n<line27>fd = open (file, O_PATHSEARCH | O_DIRECTORY);\n<line28>/* On platforms lacking O_PATH, using O_SEARCH | O_DIRECTORY to\n<line29>open an overly-protected non-directory can fail with either\n<line30>EACCES or ENOTDIR.  Prefer ENOTDIR as it makes for better\n<line31>diagnostics.  */\n<line32>if (O_PATHSEARCH == O_SEARCH && fd < 0 && errno == EACCES)\n<line33>errno = (((O_DIRECTORY ? stat (file, st) : stat_result) == 0\n<line34>&& !S_ISDIR (st->st_mode))\n<line35>? ENOTDIR : EACCES);\n<line36>}\n<line37>if (!O_DIRECTORY && 0 <= fd)\n<line38>{\n<line39>/* On old systems like Solaris 10 double check type,\n<line40>to ensure we've opened a directory.  */\n<line41>int err;\n<line42>if (fstat (fd, st) == 0\n<line43>? !S_ISDIR (st->st_mode) && (err = ENOTDIR, true)\n<line44>: (err = errno) != EOVERFLOW)\n<line45>{\n<line46>close (fd);\n<line47>errno = err;\n<line48>fd = -1;\n<line49>}\n<line50>}\n<line51>return fd - (AT_FDCWD == -1 && fd < 0);\n<line52>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/tempname.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
Function: mix_random_values
Content: <line0>static random_value\n<line1>mix_random_values (random_value r, random_value s)\n<line2>{\n<line3>/* As this code is used only when high-quality randomness is neither\n<line4>available nor necessary, there is no need for fancier polynomials\n<line5>such as those in the Linux kernel's 'random' driver.  */\n<line6>return (2862933555777941757 * r + 3037000493) ^ s;\n<line7>}
----------------------------------------
Function: random_bits
Content: <line0>static bool\n<line1>random_bits (random_value *r, random_value s)\n<line2>{\n<line3>/* Without GRND_NONBLOCK it can be blocked for minutes on some systems.  */\n<line4>if (__getrandom (r, sizeof *r, GRND_NONBLOCK) == sizeof *r)\n<line5>return true;\n<line6>/* If getrandom did not work, use ersatz entropy based on low-order\n<line7>clock bits.  On GNU systems getrandom should fail only\n<line8>early in booting, when ersatz should be good enough.\n<line9>Do not use ASLR-based entropy, as that would leak ASLR info into\n<line10>the resulting file name which is typically public.\n<line11>Of course we are in a state of sin here.  */\n<line12>random_value v = s;\n<line13>#if _LIBC || (defined CLOCK_REALTIME && HAVE_CLOCK_GETTIME)\n<line14>struct __timespec64 tv;\n<line15>__clock_gettime64 (CLOCK_REALTIME, &tv);\n<line16>v = mix_random_values (v, tv.tv_sec);\n<line17>v = mix_random_values (v, tv.tv_nsec);\n<line18>#endif\n<line19>*r = mix_random_values (v, clock ());\n<line20>return false;\n<line21>}
----------------------------------------
Function: try_file
Content: <line0>static int\n<line1>try_file (char *tmpl, void *flags)\n<line2>{\n<line3>int *openflags = flags;\n<line4>return __open (tmpl,\n<line5>(*openflags & ~O_ACCMODE)\n<line6>| O_RDWR | O_CREAT | O_EXCL, S_IRUSR | S_IWUSR);\n<line7>}
----------------------------------------
Function: try_dir
Content: <line0>static int\n<line1>try_dir (char *tmpl, _GL_UNUSED void *flags)\n<line2>{\n<line3>return __mkdir (tmpl, S_IRUSR | S_IWUSR | S_IXUSR);\n<line4>}
----------------------------------------
Function: try_nocreate
Content: <line0>static int\n<line1>try_nocreate (char *tmpl, _GL_UNUSED void *flags)\n<line2>{\n<line3>struct_stat64 st;\n<line4>if (__lstat64_time64 (tmpl, &st) == 0 || errno == EOVERFLOW)\n<line5>__set_errno (EEXIST);\n<line6>return errno == ENOENT ? 0 : -1;\n<line7>}
----------------------------------------
Function: gen_tempname_len
Content: <line0>int\n<line1>gen_tempname_len (char *tmpl, int suffixlen, int flags, int kind,\n<line2>size_t x_suffix_len)\n<line3>{\n<line4>static int (*const tryfunc[]) (char *, void *) =\n<line5>{\n<line6>[__GT_FILE] = try_file,\n<line7>[__GT_DIR] = try_dir,\n<line8>[__GT_NOCREATE] = try_nocreate\n<line9>};\n<line10>return try_tempname_len (tmpl, suffixlen, &flags, tryfunc[kind],\n<line11>x_suffix_len);\n<line12>}
----------------------------------------
Function: try_tempname_len
Content: <line0>int\n<line1>try_tempname_len (char *tmpl, int suffixlen, void *args,\n<line2>int (*tryfunc) (char *, void *), size_t x_suffix_len)\n<line3>{\n<line4>size_t len;\n<line5>char *XXXXXX;\n<line6>unsigned int count;\n<line7>int fd = -1;\n<line8>int save_errno = errno;\n<line9>/* A lower bound on the number of temporary files to attempt to\n<line10>generate.  The maximum total number of temporary file names that\n<line11>can exist for a given template is 62**6.  It should never be\n<line12>necessary to try all of these combinations.  Instead if a reasonable\n<line13>number of names is tried (we define reasonable as 62**3) fail to\n<line14>give the system administrator the chance to remove the problems.\n<line15>This value requires that X_SUFFIX_LEN be at least 3.  */\n<line16>#define ATTEMPTS_MIN (62 * 62 * 62)\n<line17>/* The number of times to attempt to generate a temporary file.  To\n<line18>conform to POSIX, this must be no smaller than TMP_MAX.  */\n<line19>#if ATTEMPTS_MIN < TMP_MAX\n<line20>unsigned int attempts = TMP_MAX;\n<line21>#else\n<line22>unsigned int attempts = ATTEMPTS_MIN;\n<line23>#endif\n<line24>/* A random variable.  */\n<line25>random_value v = 0;\n<line26>/* A value derived from the random variable, and how many random\n<line27>base-62 digits can currently be extracted from VDIGBUF.  */\n<line28>random_value vdigbuf;\n<line29>int vdigits = 0;\n<line30>/* Least biased value for V.  If V is less than this, V can generate\n<line31>BASE_62_DIGITS unbiased digits.  Otherwise the digits are biased.  */\n<line32>random_value const biased_min\n<line33>= RANDOM_VALUE_MAX - RANDOM_VALUE_MAX % BASE_62_POWER;\n<line34>len = strlen (tmpl);\n<line35>if (len < x_suffix_len + suffixlen\n<line36>|| strspn (&tmpl[len - x_suffix_len - suffixlen], "X") < x_suffix_len)\n<line37>{\n<line38>__set_errno (EINVAL);\n<line39>return -1;\n<line40>}\n<line41>/* This is where the Xs start.  */\n<line42>XXXXXX = &tmpl[len - x_suffix_len - suffixlen];\n<line43>for (count = 0; count < attempts; ++count)\n<line44>{\n<line45>for (size_t i = 0; i < x_suffix_len; i++)\n<line46>{\n<line47>if (vdigits == 0)\n<line48>{\n<line49>/* Worry about bias only if the bits are high quality.  */\n<line50>while (random_bits (&v, v) && biased_min <= v)\n<line51>continue;\n<line52>vdigbuf = v;\n<line53>vdigits = BASE_62_DIGITS;\n<line54>}\n<line55>XXXXXX[i] = letters[vdigbuf % 62];\n<line56>vdigbuf /= 62;\n<line57>vdigits--;\n<line58>}\n<line59>fd = tryfunc (tmpl, args);\n<line60>if (fd >= 0)\n<line61>{\n<line62>__set_errno (save_errno);\n<line63>return fd;\n<line64>}\n<line65>else if (errno != EEXIST)\n<line66>return -1;\n<line67>}\n<line68>/* We got out of the loop because we ran out of combinations to try.  */\n<line69>__set_errno (EEXIST);\n<line70>return -1;\n<line71>}
----------------------------------------
Function: gen_tempname
Content: <line0>int\n<line1>__gen_tempname (char *tmpl, int suffixlen, int flags, int kind)\n<line2>{\n<line3>return gen_tempname_len (tmpl, suffixlen, flags, kind, 6);\n<line4>}
----------------------------------------
Function: try_tempname
Content: <line0>int\n<line1>try_tempname (char *tmpl, int suffixlen, void *args,\n<line2>int (*tryfunc) (char *, void *))\n<line3>{\n<line4>return try_tempname_len (tmpl, suffixlen, args, tryfunc, 6);\n<line5>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/glthread/threadlib.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
========================================
/home/huihui/Downloads/coreutils-9.4/lib/time.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
Function: rpl_time
Content: <line0>time_t\n<line1>time (time_t *tp)\n<line2>{\n<line3>struct timeval tv;\n<line4>time_t tt;\n<line5>if (gettimeofday (&tv, NULL) < 0)\n<line6>abort ();\n<line7>tt = tv.tv_sec;\n<line8>if (tp)\n<line9>*tp = tt;\n<line10>return tt;\n<line11>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/time_rz.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
Function: extend_abbrs
Content: <line0>static void\n<line1>extend_abbrs (char *abbrs, char const *abbr, size_t abbr_size)\n<line2>{\n<line3>memcpy (abbrs, abbr, abbr_size);\n<line4>abbrs[abbr_size] = '\0';\n<line5>}
----------------------------------------
Function: tzalloc
Content: <line0>timezone_t\n<line1>tzalloc (char const *name)\n<line2>{\n<line3>size_t name_size = name ? strlen (name) + 1 : 0;\n<line4>size_t abbr_size = name_size < ABBR_SIZE_MIN ? ABBR_SIZE_MIN : name_size + 1;\n<line5>timezone_t tz = malloc (FLEXSIZEOF (struct tm_zone, abbrs, abbr_size));\n<line6>if (tz)\n<line7>{\n<line8>tz->next = NULL;\n<line9>#if HAVE_TZNAME && !HAVE_STRUCT_TM_TM_ZONE\n<line10>tz->tzname_copy[0] = tz->tzname_copy[1] = NULL;\n<line11>#endif\n<line12>tz->tz_is_set = !!name;\n<line13>tz->abbrs[0] = '\0';\n<line14>if (name)\n<line15>extend_abbrs (tz->abbrs, name, name_size);\n<line16>}\n<line17>return tz;\n<line18>}
----------------------------------------
Function: save_abbr
Content: <line0>static bool\n<line1>save_abbr (timezone_t tz, struct tm *tm)\n<line2>{\n<line3>#if HAVE_STRUCT_TM_TM_ZONE || HAVE_TZNAME\n<line4>char const *zone = NULL;\n<line5>char *zone_copy = (char *) "";\n<line6># if HAVE_TZNAME\n<line7>int tzname_index = -1;\n<line8># endif\n<line9># if HAVE_STRUCT_TM_TM_ZONE\n<line10>zone = tm->tm_zone;\n<line11># endif\n<line12># if HAVE_TZNAME\n<line13>if (! (zone && *zone) && 0 <= tm->tm_isdst)\n<line14>{\n<line15>tzname_index = tm->tm_isdst != 0;\n<line16>zone = tzname[tzname_index];\n<line17>}\n<line18># endif\n<line19>/* No need to replace null zones, or zones within the struct tm.  */\n<line20>if (!zone || ((char *) tm <= zone && zone < (char *) (tm + 1)))\n<line21>return true;\n<line22>if (*zone)\n<line23>{\n<line24>zone_copy = tz->abbrs;\n<line25>while (strcmp (zone_copy, zone) != 0)\n<line26>{\n<line27>if (! (*zone_copy || (zone_copy == tz->abbrs && tz->tz_is_set)))\n<line28>{\n<line29>idx_t zone_size = strlen (zone) + 1;\n<line30>if (zone_size < tz->abbrs + ABBR_SIZE_MIN - zone_copy)\n<line31>extend_abbrs (zone_copy, zone, zone_size);\n<line32>else\n<line33>{\n<line34>tz = tz->next = tzalloc (zone);\n<line35>if (!tz)\n<line36>return false;\n<line37>tz->tz_is_set = 0;\n<line38>zone_copy = tz->abbrs;\n<line39>}\n<line40>break;\n<line41>}\n<line42>zone_copy += strlen (zone_copy) + 1;\n<line43>if (!*zone_copy && tz->next)\n<line44>{\n<line45>tz = tz->next;\n<line46>zone_copy = tz->abbrs;\n<line47>}\n<line48>}\n<line49>}\n<line50>/* Replace the zone name so that its lifetime matches that of TZ.  */\n<line51># if HAVE_STRUCT_TM_TM_ZONE\n<line52>tm->tm_zone = zone_copy;\n<line53># else\n<line54>if (0 <= tzname_index)\n<line55>tz->tzname_copy[tzname_index] = zone_copy;\n<line56># endif\n<line57>#endif\n<line58>return true;\n<line59>}
----------------------------------------
Function: tzfree
Content: <line0>void\n<line1>tzfree (timezone_t tz)\n<line2>{\n<line3>if (tz != local_tz)\n<line4>while (tz)\n<line5>{\n<line6>timezone_t next = tz->next;\n<line7>free (tz);\n<line8>tz = next;\n<line9>}\n<line10>}
----------------------------------------
Function: getenv_TZ
Content: <line0>static char *\n<line1>getenv_TZ (void)\n<line2>{\n<line3>return getenv ("TZ");\n<line4>}
----------------------------------------
Function: setenv_TZ
Content: <line0>static int\n<line1>setenv_TZ (char const *tz)\n<line2>{\n<line3>return tz ? setenv ("TZ", tz, 1) : unsetenv ("TZ");\n<line4>}
----------------------------------------
Function: change_env
Content: <line0>static bool\n<line1>change_env (timezone_t tz)\n<line2>{\n<line3>if (setenv_TZ (tz->tz_is_set ? tz->abbrs : NULL) != 0)\n<line4>return false;\n<line5>tzset ();\n<line6>return true;\n<line7>}
----------------------------------------
Function: set_tz
Content: <line0>static timezone_t\n<line1>set_tz (timezone_t tz)\n<line2>{\n<line3>char *env_tz = getenv_TZ ();\n<line4>if (env_tz\n<line5>? tz->tz_is_set && strcmp (tz->abbrs, env_tz) == 0\n<line6>: !tz->tz_is_set)\n<line7>return local_tz;\n<line8>else\n<line9>{\n<line10>timezone_t old_tz = tzalloc (env_tz);\n<line11>if (!old_tz)\n<line12>return old_tz;\n<line13>if (! change_env (tz))\n<line14>{\n<line15>int saved_errno = errno;\n<line16>tzfree (old_tz);\n<line17>errno = saved_errno;\n<line18>return NULL;\n<line19>}\n<line20>return old_tz;\n<line21>}\n<line22>}
----------------------------------------
Function: revert_tz
Content: <line0>static bool\n<line1>revert_tz (timezone_t tz)\n<line2>{\n<line3>if (tz == local_tz)\n<line4>return true;\n<line5>else\n<line6>{\n<line7>int saved_errno = errno;\n<line8>bool ok = change_env (tz);\n<line9>if (!ok)\n<line10>saved_errno = errno;\n<line11>tzfree (tz);\n<line12>errno = saved_errno;\n<line13>return ok;\n<line14>}\n<line15>}
----------------------------------------
Function: localtime_rz
Content: <line0>struct tm *\n<line1>localtime_rz (timezone_t tz, time_t const *t, struct tm *tm)\n<line2>{\n<line3>#ifdef HAVE_LOCALTIME_INFLOOP_BUG\n<line4>/* The -67768038400665599 comes from:\n<line5>https://lists.gnu.org/r/bug-gnulib/2017-07/msg00142.html\n<line6>On affected platforms the greatest POSIX-compatible time_t value\n<line7>that could return nonnull is 67768036191766798 (when\n<line8>TZ="XXX24:59:59" it resolves to the year 2**31 - 1 + 1900, on\n<line9>12-31 at 23:59:59), so test for that too while we're in the\n<line10>neighborhood.  */\n<line11>if (! (-67768038400665599 <= *t && *t <= 67768036191766798))\n<line12>{\n<line13>errno = EOVERFLOW;\n<line14>return NULL;\n<line15>}\n<line16>#endif\n<line17>if (!tz)\n<line18>return gmtime_r (t, tm);\n<line19>else\n<line20>{\n<line21>timezone_t old_tz = set_tz (tz);\n<line22>if (old_tz)\n<line23>{\n<line24>bool abbr_saved = localtime_r (t, tm) && save_abbr (tz, tm);\n<line25>if (revert_tz (old_tz) && abbr_saved)\n<line26>return tm;\n<line27>}\n<line28>return NULL;\n<line29>}\n<line30>}
----------------------------------------
Function: mktime_z
Content: <line0>time_t\n<line1>mktime_z (timezone_t tz, struct tm *tm)\n<line2>{\n<line3>if (!tz)\n<line4>return timegm (tm);\n<line5>else\n<line6>{\n<line7>timezone_t old_tz = set_tz (tz);\n<line8>if (old_tz)\n<line9>{\n<line10>struct tm tm_1;\n<line11>tm_1.tm_sec = tm->tm_sec;\n<line12>tm_1.tm_min = tm->tm_min;\n<line13>tm_1.tm_hour = tm->tm_hour;\n<line14>tm_1.tm_mday = tm->tm_mday;\n<line15>tm_1.tm_mon = tm->tm_mon;\n<line16>tm_1.tm_year = tm->tm_year;\n<line17>tm_1.tm_yday = -1;\n<line18>tm_1.tm_isdst = tm->tm_isdst;\n<line19>time_t t = mktime (&tm_1);\n<line20>bool ok = 0 <= tm_1.tm_yday;\n<line21>#if HAVE_STRUCT_TM_TM_ZONE || HAVE_TZNAME\n<line22>ok = ok && save_abbr (tz, &tm_1);\n<line23>#endif\n<line24>if (revert_tz (old_tz) && ok)\n<line25>{\n<line26>*tm = tm_1;\n<line27>return t;\n<line28>}\n<line29>}\n<line30>return -1;\n<line31>}\n<line32>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/timespec.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
========================================
/home/huihui/Downloads/coreutils-9.4/lib/glthread/tls.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
========================================
/home/huihui/Downloads/coreutils-9.4/lib/tmpdir.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
Function: direxists
Content: <line0>static bool\n<line1>direxists (const char *dir)\n<line2>{\n<line3>struct_stat64 buf;\n<line4>return __xstat64 (_STAT_VER, dir, &buf) == 0 && S_ISDIR (buf.st_mode);\n<line5>}
----------------------------------------
Function: path_search
Content: <line0>int\n<line1>path_search (char *tmpl, size_t tmpl_len, const char *dir, const char *pfx,\n<line2>bool try_tmpdir)\n<line3>{\n<line4>const char *d;\n<line5>size_t dlen, plen;\n<line6>bool add_slash;\n<line7>if (!pfx || !pfx[0])\n<line8>{\n<line9>pfx = "file";\n<line10>plen = 4;\n<line11>}\n<line12>else\n<line13>{\n<line14>plen = strlen (pfx);\n<line15>if (plen > 5)\n<line16>plen = 5;\n<line17>}\n<line18>if (try_tmpdir)\n<line19>{\n<line20>d = __libc_secure_getenv ("TMPDIR");\n<line21>if (d != NULL && direxists (d))\n<line22>dir = d;\n<line23>else if (dir != NULL && direxists (dir))\n<line24>/* nothing */ ;\n<line25>else\n<line26>dir = NULL;\n<line27>}\n<line28>if (dir == NULL)\n<line29>{\n<line30>#if defined _WIN32 && ! defined __CYGWIN__\n<line31>char dirbuf[PATH_MAX];\n<line32>DWORD retval;\n<line33>/* Find Windows temporary file directory.\n<line34>We try this before P_tmpdir because Windows defines P_tmpdir to "\\"\n<line35>and will therefore try to put all temporary files in the root\n<line36>directory (unless $TMPDIR is set).  */\n<line37>retval = GetTempPath (PATH_MAX, dirbuf);\n<line38>if (retval > 0 && retval < PATH_MAX && direxists (dirbuf))\n<line39>dir = dirbuf;\n<line40>else\n<line41>#endif\n<line42>if (direxists (P_tmpdir))\n<line43>dir = P_tmpdir;\n<line44>else if (strcmp (P_tmpdir, "/tmp") != 0 && direxists ("/tmp"))\n<line45>dir = "/tmp";\n<line46>else\n<line47>{\n<line48>__set_errno (ENOENT);\n<line49>return -1;\n<line50>}\n<line51>}\n<line52>dlen = strlen (dir);\n<line53>#ifdef __VMS\n<line54>add_slash = 0;\n<line55>#else\n<line56>add_slash = dlen != 0 && !ISSLASH (dir[dlen - 1]);\n<line57>#endif\n<line58>/* check we have room for "${dir}/${pfx}XXXXXX\0" */\n<line59>if (tmpl_len < dlen + add_slash + plen + 6 + 1)\n<line60>{\n<line61>__set_errno (EINVAL);\n<line62>return -1;\n<line63>}\n<line64>memcpy (tmpl, dir, dlen);\n<line65>sprintf (tmpl + dlen, &"/%.*sXXXXXX"[!add_slash], (int) plen, pfx);\n<line66>return 0;\n<line67>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/u64.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
========================================
/home/huihui/Downloads/coreutils-9.4/lib/unicase/tolower.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
========================================
/home/huihui/Downloads/coreutils-9.4/lib/unicodeio.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
Function: unicode_to_mb
Content: <line0>long\n<line1>unicode_to_mb (unsigned int code,\n<line2>long (*success) (const char *buf, size_t buflen,\n<line3>void *callback_arg),\n<line4>long (*failure) (unsigned int code, const char *msg,\n<line5>void *callback_arg),\n<line6>void *callback_arg)\n<line7>{\n<line8>static int initialized;\n<line9>static int is_utf8;\n<line10>#if HAVE_ICONV\n<line11>static iconv_t utf8_to_local;\n<line12>#endif\n<line13>char inbuf[6];\n<line14>int count;\n<line15>if (!initialized)\n<line16>{\n<line17>const char *charset = locale_charset ();\n<line18>is_utf8 = !strcmp (charset, UTF8_NAME);\n<line19>#if HAVE_ICONV\n<line20>if (!is_utf8)\n<line21>{\n<line22>utf8_to_local = iconv_open (charset, UTF8_NAME);\n<line23>if (utf8_to_local == (iconv_t)(-1))\n<line24>/* For an unknown encoding, assume ASCII.  */\n<line25>utf8_to_local = iconv_open ("ASCII", UTF8_NAME);\n<line26>}\n<line27>#endif\n<line28>initialized = 1;\n<line29>}\n<line30>/* Test whether the utf8_to_local converter is available at all.  */\n<line31>if (!is_utf8)\n<line32>{\n<line33>#if HAVE_ICONV\n<line34>if (utf8_to_local == (iconv_t)(-1))\n<line35>return failure (code, N_("iconv function not usable"), callback_arg);\n<line36>#else\n<line37>return failure (code, N_("iconv function not available"), callback_arg);\n<line38>#endif\n<line39>}\n<line40>/* Convert the character to UTF-8.  */\n<line41>count = u8_uctomb ((unsigned char *) inbuf, code, sizeof (inbuf));\n<line42>if (count < 0)\n<line43>return failure (code, N_("character out of range"), callback_arg);\n<line44>#if HAVE_ICONV\n<line45>if (!is_utf8)\n<line46>{\n<line47>char outbuf[25];\n<line48>const char *inptr;\n<line49>size_t inbytesleft;\n<line50>char *outptr;\n<line51>size_t outbytesleft;\n<line52>size_t res;\n<line53>inptr = inbuf;\n<line54>inbytesleft = count;\n<line55>outptr = outbuf;\n<line56>outbytesleft = sizeof (outbuf);\n<line57>/* Convert the character from UTF-8 to the locale's charset.  */\n<line58>res = iconv (utf8_to_local,\n<line59>(ICONV_CONST char **)&inptr, &inbytesleft,\n<line60>&outptr, &outbytesleft);\n<line61>/* Analyze what iconv() actually did and distinguish replacements\n<line62>that are OK (no need to invoke the FAILURE callback), such as\n<line63>- replacing GREEK SMALL LETTER MU with MICRO SIGN, or\n<line64>- replacing FULLWIDTH COLON with ':', or\n<line65>- replacing a Unicode TAG character (U+E00xx) with an empty string,\n<line66>from replacements that are worse than the FAILURE callback, such as\n<line67>- replacing '' with '?' (NetBSD, Solaris 11) or '*' (musl) or\n<line68>NUL (IRIX).  */\n<line69>if (inbytesleft > 0 || res == (size_t)(-1)\n<line70>/* Irix iconv() inserts a NUL byte if it cannot convert.  */\n<line71># if !defined _LIBICONV_VERSION && (defined sgi || defined __sgi)\n<line72>|| (res > 0 && code != 0 && outptr - outbuf == 1 && *outbuf == '\0')\n<line73># endif\n<line74>/* FreeBSD iconv(), NetBSD iconv(), and Solaris 11 iconv() insert\n<line75>a '?' if they cannot convert.  */\n<line76># if !defined _LIBICONV_VERSION\n<line77>|| (res > 0 && outptr - outbuf == 1 && *outbuf == '?')\n<line78># endif\n<line79>/* musl libc iconv() inserts a '*' if it cannot convert.  */\n<line80># if !defined _LIBICONV_VERSION && MUSL_LIBC\n<line81>|| (res > 0 && outptr - outbuf == 1 && *outbuf == '*')\n<line82># endif\n<line83>)\n<line84>return failure (code, NULL, callback_arg);\n<line85>/* Avoid glibc-2.1 bug and Solaris 7 bug.  */\n<line86># if defined _LIBICONV_VERSION \\n<line87>|| !(((__GLIBC__ - 0 == 2 && __GLIBC_MINOR__ - 0 <= 1) \\n<line88>&& !defined __UCLIBC__) \\n<line89>|| defined __sun)\n<line90>/* Get back to the initial shift state.  */\n<line91>res = iconv (utf8_to_local, NULL, NULL, &outptr, &outbytesleft);\n<line92>if (res == (size_t)(-1))\n<line93>return failure (code, NULL, callback_arg);\n<line94># endif\n<line95>return success (outbuf, outptr - outbuf, callback_arg);\n<line96>}\n<line97>#endif\n<line98>/* At this point, is_utf8 is true, so no conversion is needed.  */\n<line99>return success (inbuf, count, callback_arg);\n<line100>}
----------------------------------------
Function: fwrite_success_callback
Content: <line0>long\n<line1>fwrite_success_callback (const char *buf, size_t buflen, void *callback_arg)\n<line2>{\n<line3>FILE *stream = (FILE *) callback_arg;\n<line4>/* The return value of fwrite can be ignored here, because under normal\n<line5>conditions (STREAM is an open stream and not wide-character oriented)\n<line6>when fwrite() returns a value != buflen it also sets STREAM's error\n<line7>indicator.  */\n<line8>fwrite (buf, 1, buflen, stream);\n<line9>return 0;\n<line10>}
----------------------------------------
Function: exit_failure_callback
Content: <line0>static long\n<line1>exit_failure_callback (unsigned int code, const char *msg,\n<line2>_GL_UNUSED void *callback_arg)\n<line3>{\n<line4>if (msg == NULL)\n<line5>error (1, 0, _("cannot convert U+%04X to local character set"), code);\n<line6>else\n<line7>error (1, 0, _("cannot convert U+%04X to local character set: %s"), code,\n<line8>gettext (msg));\n<line9>return -1;\n<line10>}
----------------------------------------
Function: fallback_failure_callback
Content: <line0>static long\n<line1>fallback_failure_callback (unsigned int code,\n<line2>_GL_UNUSED const char *msg,\n<line3>void *callback_arg)\n<line4>{\n<line5>FILE *stream = (FILE *) callback_arg;\n<line6>if (code < 0x10000)\n<line7>fprintf (stream, "\\u%04X", code);\n<line8>else\n<line9>fprintf (stream, "\\U%08X", code);\n<line10>return -1;\n<line11>}
----------------------------------------
Function: print_unicode_char
Content: <line0>void\n<line1>print_unicode_char (FILE *stream, unsigned int code, int exit_on_error)\n<line2>{\n<line3>unicode_to_mb (code, fwrite_success_callback,\n<line4>exit_on_error\n<line5>? exit_failure_callback\n<line6>: fallback_failure_callback,\n<line7>stream);\n<line8>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/unictype/ctype_alnum.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
========================================
/home/huihui/Downloads/coreutils-9.4/lib/unictype/ctype_alpha.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
========================================
/home/huihui/Downloads/coreutils-9.4/lib/unictype/ctype_blank.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
========================================
/home/huihui/Downloads/coreutils-9.4/lib/unictype/ctype_cntrl.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
========================================
/home/huihui/Downloads/coreutils-9.4/lib/unictype/ctype_digit.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
========================================
/home/huihui/Downloads/coreutils-9.4/lib/unictype/ctype_graph.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
========================================
/home/huihui/Downloads/coreutils-9.4/lib/unictype/ctype_lower.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
========================================
/home/huihui/Downloads/coreutils-9.4/lib/unictype/ctype_print.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
========================================
/home/huihui/Downloads/coreutils-9.4/lib/unictype/ctype_punct.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
========================================
/home/huihui/Downloads/coreutils-9.4/lib/unictype/ctype_space.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
========================================
/home/huihui/Downloads/coreutils-9.4/lib/unictype/ctype_upper.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
========================================
/home/huihui/Downloads/coreutils-9.4/lib/unictype/ctype_xdigit.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
========================================
/home/huihui/Downloads/coreutils-9.4/lib/unistd.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
========================================
/home/huihui/Downloads/coreutils-9.4/lib/dup-safer.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
Function: dup_safer
Content: <line0>int\n<line1>dup_safer (int fd)\n<line2>{\n<line3>return fcntl (fd, F_DUPFD, STDERR_FILENO + 1);\n<line4>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/fd-safer.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
Function: fd_safer
Content: <line0>int\n<line1>fd_safer (int fd)\n<line2>{\n<line3>if (STDIN_FILENO <= fd && fd <= STDERR_FILENO)\n<line4>{\n<line5>int f = dup_safer (fd);\n<line6>int e = errno;\n<line7>close (fd);\n<line8>errno = e;\n<line9>fd = f;\n<line10>}\n<line11>return fd;\n<line12>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/pipe-safer.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
Function: pipe_safer
Content: <line0>int\n<line1>pipe_safer (int fd[2])\n<line2>{\n<line3>if (pipe (fd) == 0)\n<line4>{\n<line5>int i;\n<line6>for (i = 0; i < 2; i++)\n<line7>{\n<line8>fd[i] = fd_safer (fd[i]);\n<line9>if (fd[i] < 0)\n<line10>{\n<line11>int saved_errno = errno;\n<line12>close (fd[1 - i]);\n<line13>errno = saved_errno;\n<line14>return -1;\n<line15>}\n<line16>}\n<line17>return 0;\n<line18>}\n<line19>return -1;\n<line20>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/unistr/u32-chr.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
Function: u32_chr
Content: <line0>uint32_t *\n<line1>u32_chr (const uint32_t *s, size_t n, ucs4_t uc)\n<line2>{\n<line3>for (; n > 0; s++, n--)\n<line4>{\n<line5>if (*s == uc)\n<line6>return (uint32_t *) s;\n<line7>}\n<line8>return NULL;\n<line9>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/unistr/u32-cpy.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
========================================
/home/huihui/Downloads/coreutils-9.4/lib/unistr/u32-pcpy.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
========================================
/home/huihui/Downloads/coreutils-9.4/lib/unistr/u32-strcat.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
========================================
/home/huihui/Downloads/coreutils-9.4/lib/unistr/u32-strlen.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
========================================
/home/huihui/Downloads/coreutils-9.4/lib/unistr/u8-mbtoucr.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
Function: u8_mbtoucr
Content: <line0>int\n<line1>u8_mbtoucr (ucs4_t *puc, const uint8_t *s, size_t n)\n<line2>{\n<line3>uint8_t c = *s;\n<line4>if (c < 0x80)\n<line5>{\n<line6>*puc = c;\n<line7>return 1;\n<line8>}\n<line9>else if (c >= 0xc2)\n<line10>{\n<line11>if (c < 0xe0)\n<line12>{\n<line13>if (n >= 2)\n<line14>{\n<line15>if ((s[1] ^ 0x80) < 0x40)\n<line16>{\n<line17>*puc = ((unsigned int) (c & 0x1f) << 6)\n<line18>| (unsigned int) (s[1] ^ 0x80);\n<line19>return 2;\n<line20>}\n<line21>/* invalid multibyte character */\n<line22>}\n<line23>else\n<line24>{\n<line25>/* incomplete multibyte character */\n<line26>*puc = 0xfffd;\n<line27>return -2;\n<line28>}\n<line29>}\n<line30>else if (c < 0xf0)\n<line31>{\n<line32>if (n >= 2)\n<line33>{\n<line34>if ((s[1] ^ 0x80) < 0x40\n<line35>&& (c >= 0xe1 || s[1] >= 0xa0)\n<line36>&& (c != 0xed || s[1] < 0xa0))\n<line37>{\n<line38>if (n >= 3)\n<line39>{\n<line40>if ((s[2] ^ 0x80) < 0x40)\n<line41>{\n<line42>*puc = ((unsigned int) (c & 0x0f) << 12)\n<line43>| ((unsigned int) (s[1] ^ 0x80) << 6)\n<line44>| (unsigned int) (s[2] ^ 0x80);\n<line45>return 3;\n<line46>}\n<line47>/* invalid multibyte character */\n<line48>}\n<line49>else\n<line50>{\n<line51>/* incomplete multibyte character */\n<line52>*puc = 0xfffd;\n<line53>return -2;\n<line54>}\n<line55>}\n<line56>/* invalid multibyte character */\n<line57>}\n<line58>else\n<line59>{\n<line60>/* incomplete multibyte character */\n<line61>*puc = 0xfffd;\n<line62>return -2;\n<line63>}\n<line64>}\n<line65>else if (c <= 0xf4)\n<line66>{\n<line67>if (n >= 2)\n<line68>{\n<line69>if ((s[1] ^ 0x80) < 0x40\n<line70>&& (c >= 0xf1 || s[1] >= 0x90)\n<line71>&& (c < 0xf4 || (/* c == 0xf4 && */ s[1] < 0x90)))\n<line72>{\n<line73>if (n >= 3)\n<line74>{\n<line75>if ((s[2] ^ 0x80) < 0x40)\n<line76>{\n<line77>if (n >= 4)\n<line78>{\n<line79>if ((s[3] ^ 0x80) < 0x40)\n<line80>{\n<line81>*puc = ((unsigned int) (c & 0x07) << 18)\n<line82>| ((unsigned int) (s[1] ^ 0x80) << 12)\n<line83>| ((unsigned int) (s[2] ^ 0x80) << 6)\n<line84>| (unsigned int) (s[3] ^ 0x80);\n<line85>return 4;\n<line86>}\n<line87>/* invalid multibyte character */\n<line88>}\n<line89>else\n<line90>{\n<line91>/* incomplete multibyte character */\n<line92>*puc = 0xfffd;\n<line93>return -2;\n<line94>}\n<line95>}\n<line96>/* invalid multibyte character */\n<line97>}\n<line98>else\n<line99>{\n<line100>/* incomplete multibyte character */\n<line101>*puc = 0xfffd;\n<line102>return -2;\n<line103>}\n<line104>}\n<line105>/* invalid multibyte character */\n<line106>}\n<line107>else\n<line108>{\n<line109>/* incomplete multibyte character */\n<line110>*puc = 0xfffd;\n<line111>return -2;\n<line112>}\n<line113>}\n<line114>}\n<line115>/* invalid multibyte character */\n<line116>*puc = 0xfffd;\n<line117>return -1;\n<line118>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/unistr/u8-uctomb.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
========================================
/home/huihui/Downloads/coreutils-9.4/lib/unistr/u8-uctomb-aux.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
Function: u8_uctomb_aux
Content: <line0>int\n<line1>u8_uctomb_aux (uint8_t *s, ucs4_t uc, ptrdiff_t n)\n<line2>{\n<line3>int count;\n<line4>if (uc < 0x80)\n<line5>/* The case n >= 1 is already handled by the caller.  */\n<line6>return -2;\n<line7>else if (uc < 0x800)\n<line8>count = 2;\n<line9>else if (uc < 0x10000)\n<line10>{\n<line11>if (uc < 0xd800 || uc >= 0xe000)\n<line12>count = 3;\n<line13>else\n<line14>return -1;\n<line15>}\n<line16>else if (uc < 0x110000)\n<line17>count = 4;\n<line18>else\n<line19>return -1;\n<line20>if (n < count)\n<line21>return -2;\n<line22>switch (count) /* note: code falls through cases! */\n<line23>{\n<line24>case 4: s[3] = 0x80 | (uc & 0x3f); uc = uc >> 6; uc |= 0x10000;\n<line25>FALLTHROUGH;\n<line26>case 3: s[2] = 0x80 | (uc & 0x3f); uc = uc >> 6; uc |= 0x800;\n<line27>FALLTHROUGH;\n<line28>case 2: s[1] = 0x80 | (uc & 0x3f); uc = uc >> 6; uc |= 0xc0;\n<line29>/*case 1:*/ s[0] = uc;\n<line30>}\n<line31>return count;\n<line32>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/uniwidth/width.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
Function: uc_width
Content: <line0>int\n<line1>uc_width (ucs4_t uc, const char *encoding)\n<line2>{\n<line3>/* Test for non-spacing or control character.  */\n<line4>if ((uc >> 9) < SIZEOF (nonspacing_table_ind))\n<line5>{\n<line6>int ind = nonspacing_table_ind[uc >> 9];\n<line7>if (ind >= 0)\n<line8>if ((nonspacing_table_data[64*ind + ((uc >> 3) & 63)] >> (uc & 7)) & 1)\n<line9>{\n<line10>if (uc > 0 && uc < 0xa0)\n<line11>return -1;\n<line12>else\n<line13>return 0;\n<line14>}\n<line15>}\n<line16>else if ((uc >> 9) == (0xe0000 >> 9))\n<line17>{\n<line18>if (uc >= 0xe0100)\n<line19>{\n<line20>if (uc <= 0xe01ef)\n<line21>return 0;\n<line22>}\n<line23>else\n<line24>{\n<line25>if (uc >= 0xe0020 ? uc <= 0xe007f : uc == 0xe0001)\n<line26>return 0;\n<line27>}\n<line28>}\n<line29>/* Test for double-width character.  */\n<line30>if (bitmap_lookup (&u_width2, uc))\n<line31>return 2;\n<line32>/* In ancient CJK encodings, Cyrillic and most other characters are\n<line33>double-width as well.  */\n<line34>if (uc >= 0x00A1 && uc < 0xFF61 && uc != 0x20A9\n<line35>&& is_cjk_encoding (encoding))\n<line36>return 2;\n<line37>return 1;\n<line38>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/unlinkdir.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
========================================
/home/huihui/Downloads/coreutils-9.4/lib/userspec.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
Function: parse_with_separator
Content: <line0>static char const *\n<line1>parse_with_separator (char const *spec, char const *separator,\n<line2>uid_t *uid, gid_t *gid,\n<line3>char **username, char **groupname)\n<line4>{\n<line5>const char *error_msg;\n<line6>struct passwd *pwd;\n<line7>struct group *grp;\n<line8>char *u;\n<line9>char const *g;\n<line10>char *gname = NULL;\n<line11>uid_t unum = *uid;\n<line12>gid_t gnum = gid ? *gid : -1;\n<line13>error_msg = NULL;\n<line14>if (username)\n<line15>*username = NULL;\n<line16>if (groupname)\n<line17>*groupname = NULL;\n<line18>/* Set U and G to nonzero length strings corresponding to user and\n<line19>group specifiers or to NULL.  If U is not NULL, it is a newly\n<line20>allocated string.  */\n<line21>u = NULL;\n<line22>if (separator == NULL)\n<line23>{\n<line24>if (*spec)\n<line25>u = xstrdup (spec);\n<line26>}\n<line27>else\n<line28>{\n<line29>idx_t ulen = separator - spec;\n<line30>if (ulen != 0)\n<line31>{\n<line32>u = ximemdup (spec, ulen + 1);\n<line33>u[ulen] = '\0';\n<line34>}\n<line35>}\n<line36>g = (separator == NULL || *(separator + 1) == '\0'\n<line37>? NULL\n<line38>: separator + 1);\n<line39>#ifdef __DJGPP__\n<line40>/* Pretend that we are the user U whose group is G.  This makes\n<line41>pwd and grp functions "know" about the UID and GID of these.  */\n<line42>if (u && !is_number (u))\n<line43>setenv ("USER", u, 1);\n<line44>if (g && !is_number (g))\n<line45>setenv ("GROUP", g, 1);\n<line46>#endif\n<line47>if (u != NULL)\n<line48>{\n<line49>/* If it starts with "+", skip the look-up.  */\n<line50>pwd = (*u == '+' ? NULL : getpwnam (u));\n<line51>if (pwd == NULL)\n<line52>{\n<line53>username = NULL;\n<line54>bool use_login_group = (separator != NULL && g == NULL);\n<line55>if (use_login_group)\n<line56>{\n<line57>/* If there is no group,\n<line58>then there may not be a trailing ":", either.  */\n<line59>error_msg = N_("invalid spec");\n<line60>}\n<line61>else\n<line62>{\n<line63>unsigned long int tmp;\n<line64>if (xstrtoul (u, NULL, 10, &tmp, "") == LONGINT_OK\n<line65>&& tmp <= MAXUID && (uid_t) tmp != (uid_t) -1)\n<line66>unum = tmp;\n<line67>else\n<line68>error_msg = N_("invalid user");\n<line69>}\n<line70>}\n<line71>else\n<line72>{\n<line73>unum = pwd->pw_uid;\n<line74>if (g == NULL && separator != NULL)\n<line75>{\n<line76>/* A separator was given, but a group was not specified,\n<line77>so get the login group.  */\n<line78>char buf[INT_BUFSIZE_BOUND (uintmax_t)];\n<line79>gnum = pwd->pw_gid;\n<line80>grp = getgrgid (gnum);\n<line81>gname = xstrdup (grp ? grp->gr_name : umaxtostr (gnum, buf));\n<line82>endgrent ();\n<line83>}\n<line84>}\n<line85>endpwent ();\n<line86>}\n<line87>if (g != NULL && error_msg == NULL)\n<line88>{\n<line89>/* Explicit group.  */\n<line90>/* If it starts with "+", skip the look-up.  */\n<line91>grp = (*g == '+' ? NULL : getgrnam (g));\n<line92>if (grp == NULL)\n<line93>{\n<line94>groupname = NULL;\n<line95>unsigned long int tmp;\n<line96>if (xstrtoul (g, NULL, 10, &tmp, "") == LONGINT_OK\n<line97>&& tmp <= MAXGID && (gid_t) tmp != (gid_t) -1)\n<line98>gnum = tmp;\n<line99>else\n<line100>error_msg = N_("invalid group");\n<line101>}\n<line102>else\n<line103>gnum = grp->gr_gid;\n<line104>endgrent ();              /* Save a file descriptor.  */\n<line105>gname = xstrdup (g);\n<line106>}\n<line107>if (error_msg == NULL)\n<line108>{\n<line109>*uid = unum;\n<line110>if (gid)\n<line111>*gid = gnum;\n<line112>if (username)\n<line113>{\n<line114>*username = u;\n<line115>u = NULL;\n<line116>}\n<line117>if (groupname)\n<line118>{\n<line119>*groupname = gname;\n<line120>gname = NULL;\n<line121>}\n<line122>}\n<line123>free (u);\n<line124>free (gname);\n<line125>return error_msg ? _(error_msg) : NULL;\n<line126>}
----------------------------------------
Function: parse_user_spec_warn
Content: <line0>char const *\n<line1>parse_user_spec_warn (char const *spec, uid_t *uid, gid_t *gid,\n<line2>char **username, char **groupname, bool *pwarn)\n<line3>{\n<line4>char const *colon = gid ? strchr (spec, ':') : NULL;\n<line5>char const *error_msg =\n<line6>parse_with_separator (spec, colon, uid, gid, username, groupname);\n<line7>bool warn = false;\n<line8>if (gid && !colon && error_msg)\n<line9>{\n<line10>/* If there's no colon but there is a dot, and if looking up the\n<line11>whole spec failed (i.e., the spec is not an owner name that\n<line12>includes a dot), then try again, but interpret the dot as a\n<line13>separator.  This is a compatible extension to POSIX, since\n<line14>the POSIX-required behavior is always tried first.  */\n<line15>char const *dot = strchr (spec, '.');\n<line16>if (dot\n<line17>&& ! parse_with_separator (spec, dot, uid, gid, username, groupname))\n<line18>{\n<line19>warn = true;\n<line20>error_msg = pwarn ? N_("warning: '.' should be ':'") : NULL;\n<line21>}\n<line22>}\n<line23>if (pwarn)\n<line24>*pwarn = warn;\n<line25>return error_msg;\n<line26>}
----------------------------------------
Function: parse_user_spec
Content: <line0>char const *\n<line1>parse_user_spec (char const *spec, uid_t *uid, gid_t *gid,\n<line2>char **username, char **groupname)\n<line3>{\n<line4>return parse_user_spec_warn (spec, uid, gid, username, groupname, NULL);\n<line5>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/utimecmp.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
/home/huihui/Downloads/coreutils-9.4/lib/utimecmp.c:147:42: warning: '_Static_assert' with no message is a C2x extension [-Wc2x-extensions]
  static_assert (TYPE_IS_INTEGER (time_t));
                                         ^
                                         , ""
2 warnings generated.
Function: dev_info_hash
Content: <line0>static size_t\n<line1>dev_info_hash (void const *x, size_t table_size)\n<line2>{\n<line3>struct fs_res const *p = x;\n<line4>/* Beware signed arithmetic gotchas.  */\n<line5>if (TYPE_SIGNED (dev_t) && SIZE_MAX < MAX (INT_MAX, TYPE_MAXIMUM (dev_t)))\n<line6>{\n<line7>uintmax_t dev = p->dev;\n<line8>return dev % table_size;\n<line9>}\n<line10>return p->dev % table_size;\n<line11>}
----------------------------------------
Function: dev_info_compare
Content: <line0>static bool\n<line1>dev_info_compare (void const *x, void const *y)\n<line2>{\n<line3>struct fs_res const *a = x;\n<line4>struct fs_res const *b = y;\n<line5>return a->dev == b->dev;\n<line6>}
----------------------------------------
Function: utimecmp
Content: <line0>int\n<line1>utimecmp (char const *dst_name,\n<line2>struct stat const *dst_stat,\n<line3>struct stat const *src_stat,\n<line4>int options)\n<line5>{\n<line6>return utimecmpat (AT_FDCWD, dst_name, dst_stat, src_stat, options);\n<line7>}
----------------------------------------
Function: utimecmpat
Content: <line0>int\n<line1>utimecmpat (int dfd, char const *dst_name,\n<line2>struct stat const *dst_stat,\n<line3>struct stat const *src_stat,\n<line4>int options)\n<line5>{\n<line6>/* Things to watch out for:\n<line7>The code uses a static hash table internally and is not safe in the\n<line8>presence of signals, multiple threads, etc.  However, memory pressure\n<line9>that prevents use of the hash table is not fatal - we just fall back\n<line10>to redoing the computations on every call in that case.\n<line11>int and long int might be 32 bits.  Many of the calculations store\n<line12>numbers up to 2 billion, and multiply by 10; they have to avoid\n<line13>multiplying 2 billion by 10, as this exceeds 32-bit capabilities.\n<line14>time_t might be unsigned.  */\n<line15>static_assert (TYPE_IS_INTEGER (time_t));\n<line16>/* Destination and source timestamps.  */\n<line17>time_t dst_s = dst_stat->st_mtime;\n<line18>time_t src_s = src_stat->st_mtime;\n<line19>int dst_ns = get_stat_mtime_ns (dst_stat);\n<line20>int src_ns = get_stat_mtime_ns (src_stat);\n<line21>if (options & UTIMECMP_TRUNCATE_SOURCE)\n<line22>{\n<line23>#if defined _AIX\n<line24>/* On AIX 7.2, on a jfs2 file system, the times may differ by up to\n<line25>0.01 seconds in either direction.  But it does not seem to come\n<line26>from clock ticks of 0.01 seconds each.  */\n<line27>long long difference =\n<line28>((long long) dst_s - (long long) src_s) * BILLION\n<line29>+ ((long long) dst_ns - (long long) src_ns);\n<line30>if (difference < 10000000 && difference > -10000000)\n<line31>return 0;\n<line32>#endif\n<line33>/* Look up the timestamp resolution for the destination device.  */\n<line34>/* Hash table for caching information learned about devices.  */\n<line35>static Hash_table *ht;\n<line36>/* Information about the destination file system.  */\n<line37>static struct fs_res *new_dst_res;\n<line38>struct fs_res *dst_res = NULL;\n<line39>struct fs_res tmp_dst_res;\n<line40>/* timestamp resolution in nanoseconds.  */\n<line41>int res;\n<line42>/* Quick exit, if possible.  Since the worst resolution is 2\n<line43>seconds, anything that differs by more than that does not\n<line44>needs source truncation.  */\n<line45>if (dst_s == src_s && dst_ns == src_ns)\n<line46>return 0;\n<line47>if (dst_s <= src_s - 2)\n<line48>return -1;\n<line49>if (src_s <= dst_s - 2)\n<line50>return 1;\n<line51>/* Try to do a hash lookup, but fall back to stack variables and\n<line52>recomputation on low memory situations.  */\n<line53>if (! ht)\n<line54>ht = hash_initialize (16, NULL, dev_info_hash, dev_info_compare, free);\n<line55>if (ht)\n<line56>{\n<line57>if (! new_dst_res)\n<line58>{\n<line59>new_dst_res = malloc (sizeof *new_dst_res);\n<line60>if (!new_dst_res)\n<line61>goto low_memory;\n<line62>new_dst_res->resolution = 2 * BILLION;\n<line63>new_dst_res->exact = false;\n<line64>}\n<line65>new_dst_res->dev = dst_stat->st_dev;\n<line66>dst_res = hash_insert (ht, new_dst_res);\n<line67>if (! dst_res)\n<line68>goto low_memory;\n<line69>if (dst_res == new_dst_res)\n<line70>{\n<line71>/* NEW_DST_RES is now in use in the hash table, so allocate a\n<line72>new entry next time.  */\n<line73>new_dst_res = NULL;\n<line74>}\n<line75>}\n<line76>else\n<line77>{\n<line78>low_memory:\n<line79>if (ht)\n<line80>{\n<line81>tmp_dst_res.dev = dst_stat->st_dev;\n<line82>dst_res = hash_lookup (ht, &tmp_dst_res);\n<line83>}\n<line84>if (!dst_res)\n<line85>{\n<line86>dst_res = &tmp_dst_res;\n<line87>dst_res->resolution = 2 * BILLION;\n<line88>dst_res->exact = false;\n<line89>}\n<line90>}\n<line91>res = dst_res->resolution;\n<line92>#ifdef _PC_TIMESTAMP_RESOLUTION\n<line93>/* If the system will tell us the resolution, we're set!  */\n<line94>if (! dst_res->exact)\n<line95>{\n<line96>res = -1;\n<line97>if (dfd == AT_FDCWD)\n<line98>res = pathconf (dst_name, _PC_TIMESTAMP_RESOLUTION);\n<line99>else\n<line100>{\n<line101>char *dstdir = mdir_name (dst_name);\n<line102>if (dstdir)\n<line103>{\n<line104>int destdirfd = openat (dfd, dstdir,\n<line105>O_SEARCH | O_CLOEXEC | O_DIRECTORY);\n<line106>if (0 <= destdirfd)\n<line107>{\n<line108>res = fpathconf (destdirfd, _PC_TIMESTAMP_RESOLUTION);\n<line109>close (destdirfd);\n<line110>}\n<line111>free (dstdir);\n<line112>}\n<line113>}\n<line114>if (0 < res)\n<line115>{\n<line116>dst_res->resolution = res;\n<line117>dst_res->exact = true;\n<line118>}\n<line119>}\n<line120>#endif\n<line121>if (! dst_res->exact)\n<line122>{\n<line123>/* This file system's resolution is not known exactly.\n<line124>Deduce it, and store the result in the hash table.  */\n<line125>time_t dst_a_s = dst_stat->st_atime;\n<line126>time_t dst_c_s = dst_stat->st_ctime;\n<line127>time_t dst_m_s = dst_s;\n<line128>int dst_a_ns = get_stat_atime_ns (dst_stat);\n<line129>int dst_c_ns = get_stat_ctime_ns (dst_stat);\n<line130>int dst_m_ns = dst_ns;\n<line131>/* Set RES to an upper bound on the file system resolution\n<line132>(after truncation due to SYSCALL_RESOLUTION) by inspecting\n<line133>the atime, ctime and mtime of the existing destination.\n<line134>We don't know of any file system that stores atime or\n<line135>ctime with a higher precision than mtime, so it's valid to\n<line136>look at them too.  */\n<line137>{\n<line138>bool odd_second = (dst_a_s | dst_c_s | dst_m_s) & 1;\n<line139>if (SYSCALL_RESOLUTION == BILLION)\n<line140>{\n<line141>if (odd_second | dst_a_ns | dst_c_ns | dst_m_ns)\n<line142>res = BILLION;\n<line143>}\n<line144>else\n<line145>{\n<line146>int a = dst_a_ns;\n<line147>int c = dst_c_ns;\n<line148>int m = dst_m_ns;\n<line149>/* Write it this way to avoid mistaken GCC warning\n<line150>about integer overflow in constant expression.  */\n<line151>int SR10 = SYSCALL_RESOLUTION;  SR10 *= 10;\n<line152>if ((a % SR10 | c % SR10 | m % SR10) != 0)\n<line153>res = SYSCALL_RESOLUTION;\n<line154>else\n<line155>for (res = SR10, a /= SR10, c /= SR10, m /= SR10;\n<line156>(res < dst_res->resolution\n<line157>&& (a % 10 | c % 10 | m % 10) == 0);\n<line158>res *= 10, a /= 10, c /= 10, m /= 10)\n<line159>if (res == BILLION)\n<line160>{\n<line161>if (! odd_second)\n<line162>res *= 2;\n<line163>break;\n<line164>}\n<line165>}\n<line166>dst_res->resolution = res;\n<line167>}\n<line168>if (SYSCALL_RESOLUTION < res)\n<line169>{\n<line170>struct stat dst_status;\n<line171>/* Ignore source timestamp information that must necessarily\n<line172>be lost when filtered through utimens.  */\n<line173>src_ns -= src_ns % SYSCALL_RESOLUTION;\n<line174>/* If the timestamps disagree widely enough, there's no need\n<line175>to interrogate the file system to deduce the exact\n<line176>timestamp resolution; return the answer directly.  */\n<line177>{\n<line178>time_t s = src_s & ~ (res == 2 * BILLION ? 1 : 0);\n<line179>if (src_s < dst_s || (src_s == dst_s && src_ns <= dst_ns))\n<line180>return 1;\n<line181>if (dst_s < s\n<line182>|| (dst_s == s && dst_ns < src_ns - src_ns % res))\n<line183>return -1;\n<line184>}\n<line185>/* Determine the actual timestamp resolution for the\n<line186>destination file system (after truncation due to\n<line187>SYSCALL_RESOLUTION) by setting the access timestamp of the\n<line188>destination to the existing access time, except with\n<line189>trailing nonzero digits.  */\n<line190>struct timespec timespec[2] = {\n<line191>[0].tv_sec = dst_a_s,\n<line192>[0].tv_nsec = dst_a_ns,\n<line193>[1].tv_sec = dst_m_s | (res == 2 * BILLION),\n<line194>[1].tv_nsec = dst_m_ns + res / 9\n<line195>};\n<line196>if (utimensat (dfd, dst_name, timespec, AT_SYMLINK_NOFOLLOW))\n<line197>return -2;\n<line198>/* Read the modification time that was set.  */\n<line199>{\n<line200>int stat_result\n<line201>= fstatat (dfd, dst_name, &dst_status, AT_SYMLINK_NOFOLLOW);\n<line202>if (stat_result\n<line203>| (dst_status.st_mtime ^ dst_m_s)\n<line204>| (get_stat_mtime_ns (&dst_status) ^ dst_m_ns))\n<line205>{\n<line206>/* The modification time changed, or we can't tell whether\n<line207>it changed.  Change it back as best we can.  */\n<line208>timespec[1].tv_sec = dst_m_s;\n<line209>timespec[1].tv_nsec = dst_m_ns;\n<line210>utimensat (dfd, dst_name, timespec, AT_SYMLINK_NOFOLLOW);\n<line211>}\n<line212>if (stat_result != 0)\n<line213>return -2;\n<line214>}\n<line215>/* Determine the exact resolution from the modification time\n<line216>that was read back.  */\n<line217>{\n<line218>int old_res = res;\n<line219>int a = (BILLION * (dst_status.st_mtime & 1)\n<line220>+ get_stat_mtime_ns (&dst_status));\n<line221>res = SYSCALL_RESOLUTION;\n<line222>for (a /= res; a % 10 == 0; a /= 10)\n<line223>{\n<line224>if (res == BILLION)\n<line225>{\n<line226>res *= 2;\n<line227>break;\n<line228>}\n<line229>res *= 10;\n<line230>if (res == old_res)\n<line231>break;\n<line232>}\n<line233>}\n<line234>}\n<line235>dst_res->resolution = res;\n<line236>dst_res->exact = true;\n<line237>}\n<line238>/* Truncate the source's timestamp according to the resolution.  */\n<line239>src_s &= ~ (res == 2 * BILLION ? 1 : 0);\n<line240>src_ns -= src_ns % res;\n<line241>}\n<line242>/* Compare the timestamps and return -1, 0, 1 accordingly.  */\n<line243>return (_GL_CMP (dst_s, src_s)\n<line244>+ ((dst_s == src_s ? ~0 : 0) & _GL_CMP (dst_ns, src_ns)));\n<line245>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/utimens.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
Function: validate_timespec
Content: <line0>static int\n<line1>validate_timespec (struct timespec timespec[2])\n<line2>{\n<line3>int result = 0;\n<line4>int utime_omit_count = 0;\n<line5>if ((timespec[0].tv_nsec != UTIME_NOW\n<line6>&& timespec[0].tv_nsec != UTIME_OMIT\n<line7>&& ! (0 <= timespec[0].tv_nsec\n<line8>&& timespec[0].tv_nsec < TIMESPEC_HZ))\n<line9>|| (timespec[1].tv_nsec != UTIME_NOW\n<line10>&& timespec[1].tv_nsec != UTIME_OMIT\n<line11>&& ! (0 <= timespec[1].tv_nsec\n<line12>&& timespec[1].tv_nsec < TIMESPEC_HZ)))\n<line13>{\n<line14>errno = EINVAL;\n<line15>return -1;\n<line16>}\n<line17>/* Work around Linux kernel 2.6.25 bug, where utimensat fails with\n<line18>EINVAL if tv_sec is not 0 when using the flag values of tv_nsec.\n<line19>Flag a Linux kernel 2.6.32 bug, where an mtime of UTIME_OMIT\n<line20>fails to bump ctime.  */\n<line21>if (timespec[0].tv_nsec == UTIME_NOW\n<line22>|| timespec[0].tv_nsec == UTIME_OMIT)\n<line23>{\n<line24>timespec[0].tv_sec = 0;\n<line25>result = 1;\n<line26>if (timespec[0].tv_nsec == UTIME_OMIT)\n<line27>utime_omit_count++;\n<line28>}\n<line29>if (timespec[1].tv_nsec == UTIME_NOW\n<line30>|| timespec[1].tv_nsec == UTIME_OMIT)\n<line31>{\n<line32>timespec[1].tv_sec = 0;\n<line33>result = 1;\n<line34>if (timespec[1].tv_nsec == UTIME_OMIT)\n<line35>utime_omit_count++;\n<line36>}\n<line37>return result + (utime_omit_count == 1);\n<line38>}
----------------------------------------
Function: update_timespec
Content: <line0>static bool\n<line1>update_timespec (struct stat const *statbuf, struct timespec **ts)\n<line2>{\n<line3>struct timespec *timespec = *ts;\n<line4>if (timespec[0].tv_nsec == UTIME_OMIT\n<line5>&& timespec[1].tv_nsec == UTIME_OMIT)\n<line6>return true;\n<line7>if (timespec[0].tv_nsec == UTIME_NOW\n<line8>&& timespec[1].tv_nsec == UTIME_NOW)\n<line9>{\n<line10>*ts = NULL;\n<line11>return false;\n<line12>}\n<line13>if (timespec[0].tv_nsec == UTIME_OMIT)\n<line14>timespec[0] = get_stat_atime (statbuf);\n<line15>else if (timespec[0].tv_nsec == UTIME_NOW)\n<line16>gettime (&timespec[0]);\n<line17>if (timespec[1].tv_nsec == UTIME_OMIT)\n<line18>timespec[1] = get_stat_mtime (statbuf);\n<line19>else if (timespec[1].tv_nsec == UTIME_NOW)\n<line20>gettime (&timespec[1]);\n<line21>return false;\n<line22>}
----------------------------------------
Function: fdutimens
Content: <line0>int\n<line1>fdutimens (int fd, char const *file, struct timespec const timespec[2])\n<line2>{\n<line3>struct timespec adjusted_timespec[2];\n<line4>struct timespec *ts = timespec ? adjusted_timespec : NULL;\n<line5>int adjustment_needed = 0;\n<line6>struct stat st;\n<line7>if (ts)\n<line8>{\n<line9>adjusted_timespec[0] = timespec[0];\n<line10>adjusted_timespec[1] = timespec[1];\n<line11>adjustment_needed = validate_timespec (ts);\n<line12>}\n<line13>if (adjustment_needed < 0)\n<line14>return -1;\n<line15>/* Require that at least one of FD or FILE are potentially valid, to avoid\n<line16>a Linux bug where futimens (AT_FDCWD, NULL) changes "." rather\n<line17>than failing.  */\n<line18>if (fd < 0 && !file)\n<line19>{\n<line20>errno = EBADF;\n<line21>return -1;\n<line22>}\n<line23>/* Some Linux-based NFS clients are buggy, and mishandle timestamps\n<line24>of files in NFS file systems in some cases.  We have no\n<line25>configure-time test for this, but please see\n<line26><https://bugs.gentoo.org/show_bug.cgi?id=132673> for references to\n<line27>some of the problems with Linux 2.6.16.  If this affects you,\n<line28>compile with -DHAVE_BUGGY_NFS_TIME_STAMPS; this is reported to\n<line29>help in some cases, albeit at a cost in performance.  But you\n<line30>really should upgrade your kernel to a fixed version, since the\n<line31>problem affects many applications.  */\n<line32>#if HAVE_BUGGY_NFS_TIME_STAMPS\n<line33>if (fd < 0)\n<line34>sync ();\n<line35>else\n<line36>fsync (fd);\n<line37>#endif\n<line38>/* POSIX 2008 added two interfaces to set file timestamps with\n<line39>nanosecond resolution; newer Linux implements both functions via\n<line40>a single syscall.  We provide a fallback for ENOSYS (for example,\n<line41>compiling against Linux 2.6.25 kernel headers and glibc 2.7, but\n<line42>running on Linux 2.6.18 kernel).  */\n<line43>#if HAVE_UTIMENSAT || HAVE_FUTIMENS\n<line44>if (0 <= utimensat_works_really)\n<line45>{\n<line46>int result;\n<line47># if __linux__ || __sun\n<line48>/* As recently as Linux kernel 2.6.32 (Dec 2009), several file\n<line49>systems (xfs, ntfs-3g) have bugs with a single UTIME_OMIT,\n<line50>but work if both times are either explicitly specified or\n<line51>UTIME_NOW.  Work around it with a preparatory [f]stat prior\n<line52>to calling futimens/utimensat; fortunately, there is not much\n<line53>timing impact due to the extra syscall even on file systems\n<line54>where UTIME_OMIT would have worked.\n<line55>The same bug occurs in Solaris 11.1 (Apr 2013).\n<line56>FIXME: Simplify this in 2024, when these file system bugs are\n<line57>no longer common on Gnulib target platforms.  */\n<line58>if (adjustment_needed == 2)\n<line59>{\n<line60>if (fd < 0 ? stat (file, &st) : fstat (fd, &st))\n<line61>return -1;\n<line62>if (ts[0].tv_nsec == UTIME_OMIT)\n<line63>ts[0] = get_stat_atime (&st);\n<line64>else if (ts[1].tv_nsec == UTIME_OMIT)\n<line65>ts[1] = get_stat_mtime (&st);\n<line66>/* Note that st is good, in case utimensat gives ENOSYS.  */\n<line67>adjustment_needed++;\n<line68>}\n<line69># endif\n<line70># if HAVE_UTIMENSAT\n<line71>if (fd < 0)\n<line72>{\n<line73>#  if defined __APPLE__ && defined __MACH__\n<line74>size_t len = strlen (file);\n<line75>if (len > 0 && file[len - 1] == '/')\n<line76>{\n<line77>struct stat statbuf;\n<line78>if (stat (file, &statbuf) < 0)\n<line79>return -1;\n<line80>if (!S_ISDIR (statbuf.st_mode))\n<line81>{\n<line82>errno = ENOTDIR;\n<line83>return -1;\n<line84>}\n<line85>}\n<line86>#  endif\n<line87>result = utimensat (AT_FDCWD, file, ts, 0);\n<line88>#  ifdef __linux__\n<line89>/* Work around a kernel bug:\n<line90>https://bugzilla.redhat.com/show_bug.cgi?id=442352\n<line91>https://bugzilla.redhat.com/show_bug.cgi?id=449910\n<line92>It appears that utimensat can mistakenly return 280 rather\n<line93>than -1 upon ENOSYS failure.\n<line94>FIXME: remove in 2010 or whenever the offending kernels\n<line95>are no longer in common use.  */\n<line96>if (0 < result)\n<line97>errno = ENOSYS;\n<line98>#  endif /* __linux__ */\n<line99>if (result == 0 || errno != ENOSYS)\n<line100>{\n<line101>utimensat_works_really = 1;\n<line102>return result;\n<line103>}\n<line104>}\n<line105># endif /* HAVE_UTIMENSAT */\n<line106># if HAVE_FUTIMENS\n<line107>if (0 <= fd)\n<line108>{\n<line109>result = futimens (fd, ts);\n<line110>#  ifdef __linux__\n<line111>/* Work around the same bug as above.  */\n<line112>if (0 < result)\n<line113>errno = ENOSYS;\n<line114>#  endif /* __linux__ */\n<line115>if (result == 0 || errno != ENOSYS)\n<line116>{\n<line117>utimensat_works_really = 1;\n<line118>return result;\n<line119>}\n<line120>}\n<line121># endif /* HAVE_FUTIMENS */\n<line122>}\n<line123>utimensat_works_really = -1;\n<line124>lutimensat_works_really = -1;\n<line125>#endif /* HAVE_UTIMENSAT || HAVE_FUTIMENS */\n<line126>#ifdef USE_SETFILETIME\n<line127>/* On native Windows, use SetFileTime(). See\n<line128><https://docs.microsoft.com/en-us/windows/desktop/api/fileapi/nf-fileapi-setfiletime>\n<line129><https://docs.microsoft.com/en-us/windows/desktop/api/minwinbase/ns-minwinbase-filetime>  */\n<line130>if (0 <= fd)\n<line131>{\n<line132>HANDLE handle;\n<line133>FILETIME current_time;\n<line134>FILETIME last_access_time;\n<line135>FILETIME last_write_time;\n<line136>handle = (HANDLE) _get_osfhandle (fd);\n<line137>if (handle == INVALID_HANDLE_VALUE)\n<line138>{\n<line139>errno = EBADF;\n<line140>return -1;\n<line141>}\n<line142>if (ts == NULL || ts[0].tv_nsec == UTIME_NOW || ts[1].tv_nsec == UTIME_NOW)\n<line143>{\n<line144>/* GetSystemTimeAsFileTime\n<line145><https://docs.microsoft.com/en-us/windows/desktop/api/sysinfoapi/nf-sysinfoapi-getsystemtimeasfiletime>.\n<line146>It would be overkill to use\n<line147>GetSystemTimePreciseAsFileTime\n<line148><https://docs.microsoft.com/en-us/windows/desktop/api/sysinfoapi/nf-sysinfoapi-getsystemtimepreciseasfiletime>.  */\n<line149>GetSystemTimeAsFileTime (&current_time);\n<line150>}\n<line151>if (ts == NULL || ts[0].tv_nsec == UTIME_NOW)\n<line152>{\n<line153>last_access_time = current_time;\n<line154>}\n<line155>else if (ts[0].tv_nsec == UTIME_OMIT)\n<line156>{\n<line157>last_access_time.dwLowDateTime = 0;\n<line158>last_access_time.dwHighDateTime = 0;\n<line159>}\n<line160>else\n<line161>{\n<line162>ULONGLONG time_since_16010101 =\n<line163>(ULONGLONG) ts[0].tv_sec * 10000000 + ts[0].tv_nsec / 100 + 116444736000000000LL;\n<line164>last_access_time.dwLowDateTime = (DWORD) time_since_16010101;\n<line165>last_access_time.dwHighDateTime = time_since_16010101 >> 32;\n<line166>}\n<line167>if (ts == NULL || ts[1].tv_nsec == UTIME_NOW)\n<line168>{\n<line169>last_write_time = current_time;\n<line170>}\n<line171>else if (ts[1].tv_nsec == UTIME_OMIT)\n<line172>{\n<line173>last_write_time.dwLowDateTime = 0;\n<line174>last_write_time.dwHighDateTime = 0;\n<line175>}\n<line176>else\n<line177>{\n<line178>ULONGLONG time_since_16010101 =\n<line179>(ULONGLONG) ts[1].tv_sec * 10000000 + ts[1].tv_nsec / 100 + 116444736000000000LL;\n<line180>last_write_time.dwLowDateTime = (DWORD) time_since_16010101;\n<line181>last_write_time.dwHighDateTime = time_since_16010101 >> 32;\n<line182>}\n<line183>if (SetFileTime (handle, NULL, &last_access_time, &last_write_time))\n<line184>return 0;\n<line185>else\n<line186>{\n<line187>DWORD sft_error = GetLastError ();\n<line188>#if 0\n<line189>fprintf (stderr, "fdutimens SetFileTime error 0x%x\n", (unsigned int) sft_error);\n<line190>#endif\n<line191>switch (sft_error)\n<line192>{\n<line193>case ERROR_ACCESS_DENIED: /* fd was opened without O_RDWR */\n<line194>errno = EACCES; /* not specified by POSIX */\n<line195>break;\n<line196>default:\n<line197>errno = EINVAL;\n<line198>break;\n<line199>}\n<line200>return -1;\n<line201>}\n<line202>}\n<line203>#endif\n<line204>/* The platform lacks an interface to set file timestamps with\n<line205>nanosecond resolution, so do the best we can, discarding any\n<line206>fractional part of the timestamp.  */\n<line207>if (adjustment_needed || (REPLACE_FUNC_STAT_FILE && fd < 0))\n<line208>{\n<line209>if (adjustment_needed != 3\n<line210>&& (fd < 0 ? stat (file, &st) : fstat (fd, &st)))\n<line211>return -1;\n<line212>if (ts && update_timespec (&st, &ts))\n<line213>return 0;\n<line214>}\n<line215>{\n<line216>#if HAVE_FUTIMESAT || HAVE_WORKING_UTIMES\n<line217>struct timeval timeval[2];\n<line218>struct timeval *t;\n<line219>if (ts)\n<line220>{\n<line221>timeval[0] = (struct timeval) { .tv_sec  = ts[0].tv_sec,\n<line222>.tv_usec = ts[0].tv_nsec / 1000 };\n<line223>timeval[1] = (struct timeval) { .tv_sec  = ts[1].tv_sec,\n<line224>.tv_usec = ts[1].tv_nsec / 1000 };\n<line225>t = timeval;\n<line226>}\n<line227>else\n<line228>t = NULL;\n<line229>if (fd < 0)\n<line230>{\n<line231># if HAVE_FUTIMESAT\n<line232>return futimesat (AT_FDCWD, file, t);\n<line233># endif\n<line234>}\n<line235>else\n<line236>{\n<line237>/* If futimesat or futimes fails here, don't try to speed things\n<line238>up by returning right away.  glibc can incorrectly fail with\n<line239>errno == ENOENT if /proc isn't mounted.  Also, Mandrake 10.0\n<line240>in high security mode doesn't allow ordinary users to read\n<line241>/proc/self, so glibc incorrectly fails with errno == EACCES.\n<line242>If errno == EIO, EPERM, or EROFS, it's probably safe to fail\n<line243>right away, but these cases are rare enough that they're not\n<line244>worth optimizing, and who knows what other messed-up systems\n<line245>are out there?  So play it safe and fall back on the code\n<line246>below.  */\n<line247># if (HAVE_FUTIMESAT && !FUTIMESAT_NULL_BUG) || HAVE_FUTIMES\n<line248>#  if HAVE_FUTIMESAT && !FUTIMESAT_NULL_BUG\n<line249>#   undef futimes\n<line250>#   define futimes(fd, t) futimesat (fd, NULL, t)\n<line251>#  endif\n<line252>if (futimes (fd, t) == 0)\n<line253>{\n<line254>#  if __linux__ && __GLIBC__\n<line255>/* Work around a longstanding glibc bug, still present as\n<line256>of 2010-12-27.  On older Linux kernels that lack both\n<line257>utimensat and utimes, glibc's futimes rounds instead of\n<line258>truncating when falling back on utime.  The same bug\n<line259>occurs in futimesat with a null 2nd arg.  */\n<line260>if (t)\n<line261>{\n<line262>bool abig = 500000 <= t[0].tv_usec;\n<line263>bool mbig = 500000 <= t[1].tv_usec;\n<line264>if ((abig | mbig) && fstat (fd, &st) == 0)\n<line265>{\n<line266>/* If these two subtractions overflow, they'll\n<line267>track the overflows inside the buggy glibc.  */\n<line268>time_t adiff = st.st_atime - t[0].tv_sec;\n<line269>time_t mdiff = st.st_mtime - t[1].tv_sec;\n<line270>struct timeval *tt = NULL;\n<line271>struct timeval truncated_timeval[2];\n<line272>truncated_timeval[0] = t[0];\n<line273>truncated_timeval[1] = t[1];\n<line274>if (abig && adiff == 1 && get_stat_atime_ns (&st) == 0)\n<line275>{\n<line276>tt = truncated_timeval;\n<line277>tt[0].tv_usec = 0;\n<line278>}\n<line279>if (mbig && mdiff == 1 && get_stat_mtime_ns (&st) == 0)\n<line280>{\n<line281>tt = truncated_timeval;\n<line282>tt[1].tv_usec = 0;\n<line283>}\n<line284>if (tt)\n<line285>futimes (fd, tt);\n<line286>}\n<line287>}\n<line288>#  endif\n<line289>return 0;\n<line290>}\n<line291># endif\n<line292>}\n<line293>#endif /* HAVE_FUTIMESAT || HAVE_WORKING_UTIMES */\n<line294>if (!file)\n<line295>{\n<line296>#if ! ((HAVE_FUTIMESAT && !FUTIMESAT_NULL_BUG)          \\n<line297>|| (HAVE_WORKING_UTIMES && HAVE_FUTIMES))\n<line298>errno = ENOSYS;\n<line299>#endif\n<line300>return -1;\n<line301>}\n<line302>#ifdef USE_SETFILETIME\n<line303>return _gl_utimens_windows (file, ts);\n<line304>#elif HAVE_WORKING_UTIMES\n<line305>return utimes (file, t);\n<line306>#else\n<line307>{\n<line308>struct utimbuf utimbuf;\n<line309>struct utimbuf *ut;\n<line310>if (ts)\n<line311>{\n<line312>utimbuf = (struct utimbuf) { .actime  = ts[0].tv_sec,\n<line313>.modtime = ts[1].tv_sec };\n<line314>ut = &utimbuf;\n<line315>}\n<line316>else\n<line317>ut = NULL;\n<line318>return utime (file, ut);\n<line319>}\n<line320>#endif /* !HAVE_WORKING_UTIMES */\n<line321>}\n<line322>}
----------------------------------------
Function: utimens
Content: <line0>int\n<line1>utimens (char const *file, struct timespec const timespec[2])\n<line2>{\n<line3>return fdutimens (-1, file, timespec);\n<line4>}
----------------------------------------
Function: lutimens
Content: <line0>int\n<line1>lutimens (char const *file, struct timespec const timespec[2])\n<line2>{\n<line3>struct timespec adjusted_timespec[2];\n<line4>struct timespec *ts = timespec ? adjusted_timespec : NULL;\n<line5>int adjustment_needed = 0;\n<line6>struct stat st;\n<line7>if (ts)\n<line8>{\n<line9>adjusted_timespec[0] = timespec[0];\n<line10>adjusted_timespec[1] = timespec[1];\n<line11>adjustment_needed = validate_timespec (ts);\n<line12>}\n<line13>if (adjustment_needed < 0)\n<line14>return -1;\n<line15>/* The Linux kernel did not support symlink timestamps until\n<line16>utimensat, in version 2.6.22, so we don't need to mimic\n<line17>fdutimens' worry about buggy NFS clients.  But we do have to\n<line18>worry about bogus return values.  */\n<line19>#if HAVE_UTIMENSAT\n<line20>if (0 <= lutimensat_works_really)\n<line21>{\n<line22>int result;\n<line23># if __linux__ || __sun\n<line24>/* As recently as Linux kernel 2.6.32 (Dec 2009), several file\n<line25>systems (xfs, ntfs-3g) have bugs with a single UTIME_OMIT,\n<line26>but work if both times are either explicitly specified or\n<line27>UTIME_NOW.  Work around it with a preparatory lstat prior to\n<line28>calling utimensat; fortunately, there is not much timing\n<line29>impact due to the extra syscall even on file systems where\n<line30>UTIME_OMIT would have worked.\n<line31>The same bug occurs in Solaris 11.1 (Apr 2013).\n<line32>FIXME: Simplify this for Linux in 2016 and for Solaris in\n<line33>2024, when file system bugs are no longer common.  */\n<line34>if (adjustment_needed == 2)\n<line35>{\n<line36>if (lstat (file, &st))\n<line37>return -1;\n<line38>if (ts[0].tv_nsec == UTIME_OMIT)\n<line39>ts[0] = get_stat_atime (&st);\n<line40>else if (ts[1].tv_nsec == UTIME_OMIT)\n<line41>ts[1] = get_stat_mtime (&st);\n<line42>/* Note that st is good, in case utimensat gives ENOSYS.  */\n<line43>adjustment_needed++;\n<line44>}\n<line45># endif\n<line46>result = utimensat (AT_FDCWD, file, ts, AT_SYMLINK_NOFOLLOW);\n<line47># ifdef __linux__\n<line48>/* Work around a kernel bug:\n<line49>https://bugzilla.redhat.com/show_bug.cgi?id=442352\n<line50>https://bugzilla.redhat.com/show_bug.cgi?id=449910\n<line51>It appears that utimensat can mistakenly return 280 rather\n<line52>than -1 upon ENOSYS failure.\n<line53>FIXME: remove in 2010 or whenever the offending kernels\n<line54>are no longer in common use.  */\n<line55>if (0 < result)\n<line56>errno = ENOSYS;\n<line57># endif\n<line58>if (result == 0 || errno != ENOSYS)\n<line59>{\n<line60>utimensat_works_really = 1;\n<line61>lutimensat_works_really = 1;\n<line62>return result;\n<line63>}\n<line64>}\n<line65>lutimensat_works_really = -1;\n<line66>#endif /* HAVE_UTIMENSAT */\n<line67>/* The platform lacks an interface to set file timestamps with\n<line68>nanosecond resolution, so do the best we can, discarding any\n<line69>fractional part of the timestamp.  */\n<line70>if (adjustment_needed || REPLACE_FUNC_STAT_FILE)\n<line71>{\n<line72>if (adjustment_needed != 3 && lstat (file, &st))\n<line73>return -1;\n<line74>if (ts && update_timespec (&st, &ts))\n<line75>return 0;\n<line76>}\n<line77>/* On Linux, lutimes is a thin wrapper around utimensat, so there is\n<line78>no point trying lutimes if utimensat failed with ENOSYS.  */\n<line79>#if HAVE_LUTIMES && !HAVE_UTIMENSAT\n<line80>{\n<line81>struct timeval timeval[2];\n<line82>struct timeval *t;\n<line83>int result;\n<line84>if (ts)\n<line85>{\n<line86>timeval[0] = (struct timeval) { .tv_sec = ts[0].tv_sec,\n<line87>.tv_usec = ts[0].tv_nsec / 1000 };\n<line88>timeval[1] = (struct timeval) { .tv_sec = ts[1].tv_sec,\n<line89>.tv_usec = ts[1].tv_nsec / 1000 };\n<line90>t = timeval;\n<line91>}\n<line92>else\n<line93>t = NULL;\n<line94>result = lutimes (file, t);\n<line95>if (result == 0 || errno != ENOSYS)\n<line96>return result;\n<line97>}\n<line98>#endif /* HAVE_LUTIMES && !HAVE_UTIMENSAT */\n<line99>/* Out of luck for symlinks, but we still handle regular files.  */\n<line100>if (!(adjustment_needed || REPLACE_FUNC_STAT_FILE) && lstat (file, &st))\n<line101>return -1;\n<line102>if (!S_ISLNK (st.st_mode))\n<line103>return fdutimens (-1, file, ts);\n<line104>errno = ENOSYS;\n<line105>return -1;\n<line106>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/verror.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
In file included from /home/huihui/Downloads/coreutils-9.4/lib/verror.c:28:
./lib/error.h:28:3: warning: #include_next in file found relative to primary source file or found by absolute path; will search from start of include path [-Winclude-next-absolute-path]
# include_next <error.h>
  ^
2 warnings generated.
Function: verror
Content: <line0>void\n<line1>verror (int status, int errnum, const char *format, va_list args)\n<line2>{\n<line3>verror_at_line (status, errnum, NULL, 0, format, args);\n<line4>}
----------------------------------------
Function: verror_at_line
Content: <line0>void\n<line1>verror_at_line (int status, int errnum, const char *file,\n<line2>unsigned int line_number, const char *format, va_list args)\n<line3>{\n<line4>char *message = xvasprintf (format, args);\n<line5>if (message)\n<line6>{\n<line7>/* Until https://sourceware.org/bugzilla/show_bug.cgi?id=2997 is fixed,\n<line8>glibc violates GNU Coding Standards when the file argument to\n<line9>error_at_line is NULL.  */\n<line10>if (file)\n<line11>error_at_line (status, errnum, file, line_number, "%s", message);\n<line12>else\n<line13>error (status, errnum, "%s", message);\n<line14>}\n<line15>else\n<line16>{\n<line17>/* EOVERFLOW, EINVAL, and EILSEQ from xvasprintf are signs of\n<line18>serious programmer errors.  */\n<line19>error (0, errno, _("unable to display error message"));\n<line20>abort ();\n<line21>}\n<line22>free (message);\n<line23>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/version-etc.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
Function: version_etc_arn
Content: <line0>void\n<line1>version_etc_arn (FILE *stream,\n<line2>const char *command_name, const char *package,\n<line3>const char *version,\n<line4>const char * const * authors, size_t n_authors)\n<line5>{\n<line6>if (command_name)\n<line7>fprintf (stream, "%s (%s) %s\n", command_name, package, version);\n<line8>else\n<line9>fprintf (stream, "%s %s\n", package, version);\n<line10>#ifdef PACKAGE_PACKAGER\n<line11># ifdef PACKAGE_PACKAGER_VERSION\n<line12>fprintf (stream, _("Packaged by %s (%s)\n"), PACKAGE_PACKAGER,\n<line13>PACKAGE_PACKAGER_VERSION);\n<line14># else\n<line15>fprintf (stream, _("Packaged by %s\n"), PACKAGE_PACKAGER);\n<line16># endif\n<line17>#endif\n<line18>/* TRANSLATORS: Translate "(C)" to the copyright symbol\n<line19>(C-in-a-circle), if this symbol is available in the user's\n<line20>locale.  Otherwise, do not translate "(C)"; leave it as-is.  */\n<line21>fprintf (stream, version_etc_copyright, _("(C)"), COPYRIGHT_YEAR);\n<line22>fputs ("\n", stream);\n<line23>/* TRANSLATORS: The %s placeholder is the web address of the GPL license.  */\n<line24>fprintf (stream, _("\\n<line25>License GPLv3+: GNU GPL version 3 or later <%s>.\n\\n<line26>This is free software: you are free to change and redistribute it.\n\\n<line27>There is NO WARRANTY, to the extent permitted by law.\n\\n<line28>"),\n<line29>"https://gnu.org/licenses/gpl.html");\n<line30>fputs ("\n", stream);\n<line31>switch (n_authors)\n<line32>{\n<line33>case 0:\n<line34>/* No authors are given.  The caller should output authorship\n<line35>info after calling this function.  */\n<line36>break;\n<line37>case 1:\n<line38>/* TRANSLATORS: %s denotes an author name.  */\n<line39>fprintf (stream, _("Written by %s.\n"), authors[0]);\n<line40>break;\n<line41>case 2:\n<line42>/* TRANSLATORS: Each %s denotes an author name.  */\n<line43>fprintf (stream, _("Written by %s and %s.\n"), authors[0], authors[1]);\n<line44>break;\n<line45>case 3:\n<line46>/* TRANSLATORS: Each %s denotes an author name.  */\n<line47>fprintf (stream, _("Written by %s, %s, and %s.\n"),\n<line48>authors[0], authors[1], authors[2]);\n<line49>break;\n<line50>case 4:\n<line51>/* TRANSLATORS: Each %s denotes an author name.\n<line52>You can use line breaks, estimating that each author name occupies\n<line53>ca. 16 screen columns and that a screen line has ca. 80 columns.  */\n<line54>fprintf (stream, _("Written by %s, %s, %s,\nand %s.\n"),\n<line55>authors[0], authors[1], authors[2], authors[3]);\n<line56>break;\n<line57>case 5:\n<line58>/* TRANSLATORS: Each %s denotes an author name.\n<line59>You can use line breaks, estimating that each author name occupies\n<line60>ca. 16 screen columns and that a screen line has ca. 80 columns.  */\n<line61>fprintf (stream, _("Written by %s, %s, %s,\n%s, and %s.\n"),\n<line62>authors[0], authors[1], authors[2], authors[3], authors[4]);\n<line63>break;\n<line64>case 6:\n<line65>/* TRANSLATORS: Each %s denotes an author name.\n<line66>You can use line breaks, estimating that each author name occupies\n<line67>ca. 16 screen columns and that a screen line has ca. 80 columns.  */\n<line68>fprintf (stream, _("Written by %s, %s, %s,\n%s, %s, and %s.\n"),\n<line69>authors[0], authors[1], authors[2], authors[3], authors[4],\n<line70>authors[5]);\n<line71>break;\n<line72>case 7:\n<line73>/* TRANSLATORS: Each %s denotes an author name.\n<line74>You can use line breaks, estimating that each author name occupies\n<line75>ca. 16 screen columns and that a screen line has ca. 80 columns.  */\n<line76>fprintf (stream, _("Written by %s, %s, %s,\n%s, %s, %s, and %s.\n"),\n<line77>authors[0], authors[1], authors[2], authors[3], authors[4],\n<line78>authors[5], authors[6]);\n<line79>break;\n<line80>case 8:\n<line81>/* TRANSLATORS: Each %s denotes an author name.\n<line82>You can use line breaks, estimating that each author name occupies\n<line83>ca. 16 screen columns and that a screen line has ca. 80 columns.  */\n<line84>fprintf (stream, _("\\n<line85>Written by %s, %s, %s,\n%s, %s, %s, %s,\nand %s.\n"),\n<line86>authors[0], authors[1], authors[2], authors[3], authors[4],\n<line87>authors[5], authors[6], authors[7]);\n<line88>break;\n<line89>case 9:\n<line90>/* TRANSLATORS: Each %s denotes an author name.\n<line91>You can use line breaks, estimating that each author name occupies\n<line92>ca. 16 screen columns and that a screen line has ca. 80 columns.  */\n<line93>fprintf (stream, _("\\n<line94>Written by %s, %s, %s,\n%s, %s, %s, %s,\n%s, and %s.\n"),\n<line95>authors[0], authors[1], authors[2], authors[3], authors[4],\n<line96>authors[5], authors[6], authors[7], authors[8]);\n<line97>break;\n<line98>default:\n<line99>/* 10 or more authors.  Use an abbreviation, since the human reader\n<line100>will probably not want to read the entire list anyway.  */\n<line101>/* TRANSLATORS: Each %s denotes an author name.\n<line102>You can use line breaks, estimating that each author name occupies\n<line103>ca. 16 screen columns and that a screen line has ca. 80 columns.  */\n<line104>fprintf (stream, _("\\n<line105>Written by %s, %s, %s,\n%s, %s, %s, %s,\n%s, %s, and others.\n"),\n<line106>authors[0], authors[1], authors[2], authors[3], authors[4],\n<line107>authors[5], authors[6], authors[7], authors[8]);\n<line108>break;\n<line109>}\n<line110>}
----------------------------------------
Function: version_etc_ar
Content: <line0>void\n<line1>version_etc_ar (FILE *stream,\n<line2>const char *command_name, const char *package,\n<line3>const char *version, const char * const * authors)\n<line4>{\n<line5>size_t n_authors;\n<line6>for (n_authors = 0; authors[n_authors]; n_authors++)\n<line7>;\n<line8>version_etc_arn (stream, command_name, package, version, authors, n_authors);\n<line9>}
----------------------------------------
Function: version_etc_va
Content: <line0>void\n<line1>version_etc_va (FILE *stream,\n<line2>const char *command_name, const char *package,\n<line3>const char *version, va_list authors)\n<line4>{\n<line5>size_t n_authors;\n<line6>const char *authtab[10];\n<line7>for (n_authors = 0;\n<line8>n_authors < 10\n<line9>&& (authtab[n_authors] = va_arg (authors, const char *)) != NULL;\n<line10>n_authors++)\n<line11>;\n<line12>version_etc_arn (stream, command_name, package, version,\n<line13>authtab, n_authors);\n<line14>}
----------------------------------------
Function: version_etc
Content: <line0>void\n<line1>version_etc (FILE *stream,\n<line2>const char *command_name, const char *package,\n<line3>const char *version, /* const char *author1, ...*/ ...)\n<line4>{\n<line5>va_list authors;\n<line6>va_start (authors, version);\n<line7>version_etc_va (stream, command_name, package, version, authors);\n<line8>va_end (authors);\n<line9>}
----------------------------------------
Function: emit_bug_reporting_address
Content: <line0>void\n<line1>emit_bug_reporting_address (void)\n<line2>{\n<line3>fputs ("\n", stdout);\n<line4>/* TRANSLATORS: The placeholder indicates the bug-reporting address\n<line5>for this package.  Please add _another line_ saying\n<line6>"Report translation bugs to <...>\n" with the address for translation\n<line7>bugs (typically your translation team's web or email address).  */\n<line8>printf (_("Report bugs to: %s\n"), PACKAGE_BUGREPORT);\n<line9>#ifdef PACKAGE_PACKAGER_BUG_REPORTS\n<line10>printf (_("Report %s bugs to: %s\n"), PACKAGE_PACKAGER,\n<line11>PACKAGE_PACKAGER_BUG_REPORTS);\n<line12>#endif\n<line13>#ifdef PACKAGE_URL\n<line14>printf (_("%s home page: <%s>\n"), PACKAGE_NAME, PACKAGE_URL);\n<line15>#else\n<line16>printf (_("%s home page: <%s>\n"),\n<line17>PACKAGE_NAME, "https://www.gnu.org/software/" PACKAGE "/");\n<line18>#endif\n<line19>printf (_("General help using GNU software: <%s>\n"),\n<line20>"https://www.gnu.org/gethelp/");\n<line21>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/version-etc-fsf.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
========================================
/home/huihui/Downloads/coreutils-9.4/lib/wctype-h.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
========================================
/home/huihui/Downloads/coreutils-9.4/lib/write-any-file.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
========================================
/home/huihui/Downloads/coreutils-9.4/lib/xalignalloc.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
Function: xalignalloc
Content: <line0>void *\n<line1>xalignalloc (idx_t alignment, idx_t size)\n<line2>{\n<line3>void *p = alignalloc (alignment, size);\n<line4>if (!p)\n<line5>xalloc_die ();\n<line6>return p;\n<line7>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/xmalloc.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
Function: nonnull
Content: <line0>static void * _GL_ATTRIBUTE_PURE\n<line1>nonnull (void *p)\n<line2>{\n<line3>if (!p)\n<line4>xalloc_die ();\n<line5>return p;\n<line6>}
----------------------------------------
Function: xmalloc
Content: <line0>void *\n<line1>xmalloc (size_t s)\n<line2>{\n<line3>return nonnull (malloc (s));\n<line4>}
----------------------------------------
Function: ximalloc
Content: <line0>void *\n<line1>ximalloc (idx_t s)\n<line2>{\n<line3>return nonnull (imalloc (s));\n<line4>}
----------------------------------------
Function: xcharalloc
Content: <line0>char *\n<line1>xcharalloc (size_t n)\n<line2>{\n<line3>return XNMALLOC (n, char);\n<line4>}
----------------------------------------
Function: xrealloc
Content: <line0>void *\n<line1>xrealloc (void *p, size_t s)\n<line2>{\n<line3>void *r = realloc (p, s);\n<line4>if (!r && (!p || s))\n<line5>xalloc_die ();\n<line6>return r;\n<line7>}
----------------------------------------
Function: xirealloc
Content: <line0>void *\n<line1>xirealloc (void *p, idx_t s)\n<line2>{\n<line3>return nonnull (irealloc (p, s));\n<line4>}
----------------------------------------
Function: xreallocarray
Content: <line0>void *\n<line1>xreallocarray (void *p, size_t n, size_t s)\n<line2>{\n<line3>void *r = reallocarray (p, n, s);\n<line4>if (!r && (!p || (n && s)))\n<line5>xalloc_die ();\n<line6>return r;\n<line7>}
----------------------------------------
Function: xireallocarray
Content: <line0>void *\n<line1>xireallocarray (void *p, idx_t n, idx_t s)\n<line2>{\n<line3>return nonnull (ireallocarray (p, n, s));\n<line4>}
----------------------------------------
Function: xnmalloc
Content: <line0>void *\n<line1>xnmalloc (size_t n, size_t s)\n<line2>{\n<line3>return xreallocarray (NULL, n, s);\n<line4>}
----------------------------------------
Function: xinmalloc
Content: <line0>void *\n<line1>xinmalloc (idx_t n, idx_t s)\n<line2>{\n<line3>return xireallocarray (NULL, n, s);\n<line4>}
----------------------------------------
Function: x2realloc
Content: <line0>void *\n<line1>x2realloc (void *p, size_t *ps)\n<line2>{\n<line3>return x2nrealloc (p, ps, 1);\n<line4>}
----------------------------------------
Function: x2nrealloc
Content: <line0>void *\n<line1>x2nrealloc (void *p, size_t *pn, size_t s)\n<line2>{\n<line3>size_t n = *pn;\n<line4>if (! p)\n<line5>{\n<line6>if (! n)\n<line7>{\n<line8>/* The approximate size to use for initial small allocation\n<line9>requests, when the invoking code specifies an old size of\n<line10>zero.  This is the largest "small" request for the GNU C\n<line11>library malloc.  */\n<line12>enum { DEFAULT_MXFAST = 64 * sizeof (size_t) / 4 };\n<line13>n = DEFAULT_MXFAST / s;\n<line14>n += !n;\n<line15>}\n<line16>}\n<line17>else\n<line18>{\n<line19>/* Set N = floor (1.5 * N) + 1 to make progress even if N == 0.  */\n<line20>if (ckd_add (&n, n, (n >> 1) + 1))\n<line21>xalloc_die ();\n<line22>}\n<line23>p = xreallocarray (p, n, s);\n<line24>*pn = n;\n<line25>return p;\n<line26>}
----------------------------------------
Function: xpalloc
Content: <line0>void *\n<line1>xpalloc (void *pa, idx_t *pn, idx_t n_incr_min, ptrdiff_t n_max, idx_t s)\n<line2>{\n<line3>idx_t n0 = *pn;\n<line4>/* The approximate size to use for initial small allocation\n<line5>requests.  This is the largest "small" request for the GNU C\n<line6>library malloc.  */\n<line7>enum { DEFAULT_MXFAST = 64 * sizeof (size_t) / 4 };\n<line8>/* If the array is tiny, grow it to about (but no greater than)\n<line9>DEFAULT_MXFAST bytes.  Otherwise, grow it by about 50%.\n<line10>Adjust the growth according to three constraints: N_INCR_MIN,\n<line11>N_MAX, and what the C language can represent safely.  */\n<line12>idx_t n;\n<line13>if (ckd_add (&n, n0, n0 >> 1))\n<line14>n = IDX_MAX;\n<line15>if (0 <= n_max && n_max < n)\n<line16>n = n_max;\n<line17>/* NBYTES is of a type suitable for holding the count of bytes in an object.\n<line18>This is typically idx_t, but it should be size_t on (theoretical?)\n<line19>platforms where SIZE_MAX < IDX_MAX so xpalloc does not pass\n<line20>values greater than SIZE_MAX to xrealloc.  */\n<line21>#if IDX_MAX <= SIZE_MAX\n<line22>idx_t nbytes;\n<line23>#else\n<line24>size_t nbytes;\n<line25>#endif\n<line26>idx_t adjusted_nbytes\n<line27>= (ckd_mul (&nbytes, n, s)\n<line28>? MIN (IDX_MAX, SIZE_MAX)\n<line29>: nbytes < DEFAULT_MXFAST ? DEFAULT_MXFAST : 0);\n<line30>if (adjusted_nbytes)\n<line31>{\n<line32>n = adjusted_nbytes / s;\n<line33>nbytes = adjusted_nbytes - adjusted_nbytes % s;\n<line34>}\n<line35>if (! pa)\n<line36>*pn = 0;\n<line37>if (n - n0 < n_incr_min\n<line38>&& (ckd_add (&n, n0, n_incr_min)\n<line39>|| (0 <= n_max && n_max < n)\n<line40>|| ckd_mul (&nbytes, n, s)))\n<line41>xalloc_die ();\n<line42>pa = xrealloc (pa, nbytes);\n<line43>*pn = n;\n<line44>return pa;\n<line45>}
----------------------------------------
Function: xzalloc
Content: <line0>void *\n<line1>xzalloc (size_t s)\n<line2>{\n<line3>return xcalloc (s, 1);\n<line4>}
----------------------------------------
Function: xizalloc
Content: <line0>void *\n<line1>xizalloc (idx_t s)\n<line2>{\n<line3>return xicalloc (s, 1);\n<line4>}
----------------------------------------
Function: xcalloc
Content: <line0>void *\n<line1>xcalloc (size_t n, size_t s)\n<line2>{\n<line3>return nonnull (calloc (n, s));\n<line4>}
----------------------------------------
Function: xicalloc
Content: <line0>void *\n<line1>xicalloc (idx_t n, idx_t s)\n<line2>{\n<line3>return nonnull (icalloc (n, s));\n<line4>}
----------------------------------------
Function: xmemdup
Content: <line0>void *\n<line1>xmemdup (void const *p, size_t s)\n<line2>{\n<line3>return memcpy (xmalloc (s), p, s);\n<line4>}
----------------------------------------
Function: ximemdup
Content: <line0>void *\n<line1>ximemdup (void const *p, idx_t s)\n<line2>{\n<line3>return memcpy (ximalloc (s), p, s);\n<line4>}
----------------------------------------
Function: ximemdup0
Content: <line0>char *\n<line1>ximemdup0 (void const *p, idx_t s)\n<line2>{\n<line3>char *result = ximalloc (s + 1);\n<line4>result[s] = 0;\n<line5>return memcpy (result, p, s);\n<line6>}
----------------------------------------
Function: xstrdup
Content: <line0>char *\n<line1>xstrdup (char const *string)\n<line2>{\n<line3>return xmemdup (string, strlen (string) + 1);\n<line4>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/xalloc-die.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
In file included from /home/huihui/Downloads/coreutils-9.4/lib/xalloc-die.c:25:
./lib/error.h:28:3: warning: #include_next in file found relative to primary source file or found by absolute path; will search from start of include path [-Winclude-next-absolute-path]
# include_next <error.h>
  ^
2 warnings generated.
Function: xalloc_die
Content: <line0>void\n<line1>xalloc_die (void)\n<line2>{\n<line3>error (exit_failure, 0, "%s", _("memory exhausted"));\n<line4>/* _Noreturn cannot be given to error, since it may return if\n<line5>its first argument is 0.  To help compilers understand the\n<line6>xalloc_die does not return, call abort.  Also, the abort is a\n<line7>safety feature if exit_failure is 0 (which shouldn't happen).  */\n<line8>abort ();\n<line9>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/xbinary-io.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
========================================
/home/huihui/Downloads/coreutils-9.4/lib/xdectoimax.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
In file included from /home/huihui/Downloads/coreutils-9.4/lib/xdectoimax.c:6:
In file included from ./lib/xdectoint.c:27:
./lib/error.h:28:3: warning: #include_next in file found relative to primary source file or found by absolute path; will search from start of include path [-Winclude-next-absolute-path]
# include_next <error.h>
  ^
2 warnings generated.
========================================
/home/huihui/Downloads/coreutils-9.4/lib/xdectoumax.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
In file included from /home/huihui/Downloads/coreutils-9.4/lib/xdectoumax.c:6:
In file included from ./lib/xdectoint.c:27:
./lib/error.h:28:3: warning: #include_next in file found relative to primary source file or found by absolute path; will search from start of include path [-Winclude-next-absolute-path]
# include_next <error.h>
  ^
2 warnings generated.
========================================
/home/huihui/Downloads/coreutils-9.4/lib/xfts.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
In file included from /home/huihui/Downloads/coreutils-9.4/lib/xfts.c:27:
In file included from ./lib/xfts.h:1:
In file included from ./lib/fts_.h:83:
./lib/i-ring.h:24:32: warning: '_Static_assert' with no message is a C2x extension [-Wc2x-extensions]
static_assert (1 <= I_RING_SIZE);
                               ^
                               , ""
2 warnings generated.
Function: xfts_open
Content: <line0>FTS *\n<line1>xfts_open (char * const *argv, int options,\n<line2>int (*compar) (const FTSENT **, const FTSENT **))\n<line3>{\n<line4>FTS *fts = fts_open (argv, options | FTS_CWDFD, compar);\n<line5>if (fts == nullptr)\n<line6>{\n<line7>/* This can fail in two ways: out of memory or with errno==EINVAL,\n<line8>which indicates it was called with invalid bit_flags.  */\n<line9>affirm (errno != EINVAL);\n<line10>xalloc_die ();\n<line11>}\n<line12>return fts;\n<line13>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/xgetcwd.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
Function: xgetcwd
Content: <line0>char *\n<line1>xgetcwd (void)\n<line2>{\n<line3>char *cwd = getcwd (NULL, 0);\n<line4>if (! cwd && errno == ENOMEM)\n<line5>xalloc_die ();\n<line6>return cwd;\n<line7>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/xgetgroups.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
Function: xgetgroups
Content: <line0>int\n<line1>xgetgroups (char const *username, gid_t gid, gid_t **groups)\n<line2>{\n<line3>int result = mgetgroups (username, gid, groups);\n<line4>if (result == -1 && errno == ENOMEM)\n<line5>xalloc_die ();\n<line6>return result;\n<line7>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/xgethostname.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
========================================
/home/huihui/Downloads/coreutils-9.4/lib/xmemcoll.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
In file included from /home/huihui/Downloads/coreutils-9.4/lib/xmemcoll.c:28:
./lib/error.h:28:3: warning: #include_next in file found relative to primary source file or found by absolute path; will search from start of include path [-Winclude-next-absolute-path]
# include_next <error.h>
  ^
2 warnings generated.
Function: collate_error
Content: <line0>static void\n<line1>collate_error (int collation_errno,\n<line2>char const *s1, size_t s1len,\n<line3>char const *s2, size_t s2len)\n<line4>{\n<line5>error (0, collation_errno, _("string comparison failed"));\n<line6>error (0, 0, _("Set LC_ALL='C' to work around the problem."));\n<line7>error (exit_failure, 0,\n<line8>_("The strings compared were %s and %s."),\n<line9>quotearg_n_style_mem (0, locale_quoting_style, s1, s1len),\n<line10>quotearg_n_style_mem (1, locale_quoting_style, s2, s2len));\n<line11>}
----------------------------------------
Function: xmemcoll
Content: <line0>int\n<line1>xmemcoll (char *s1, size_t s1len, char *s2, size_t s2len)\n<line2>{\n<line3>int diff = memcoll (s1, s1len, s2, s2len);\n<line4>int collation_errno = errno;\n<line5>if (collation_errno)\n<line6>collate_error (collation_errno, s1, s1len, s2, s2len);\n<line7>return diff;\n<line8>}
----------------------------------------
Function: xmemcoll0
Content: <line0>int\n<line1>xmemcoll0 (char const *s1, size_t s1size, char const *s2, size_t s2size)\n<line2>{\n<line3>int diff = memcoll0 (s1, s1size, s2, s2size);\n<line4>int collation_errno = errno;\n<line5>if (collation_errno)\n<line6>collate_error (collation_errno, s1, s1size - 1, s2, s2size - 1);\n<line7>return diff;\n<line8>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/xnanosleep.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
Function: xnanosleep
Content: <line0>int\n<line1>xnanosleep (double seconds)\n<line2>{\n<line3>#if HAVE_PAUSE\n<line4>if (1.0 + TYPE_MAXIMUM (time_t) <= seconds)\n<line5>{\n<line6>do\n<line7>pause ();\n<line8>while (errno == EINTR);\n<line9>/* pause failed (!); fall back on repeated nanosleep calls.  */\n<line10>}\n<line11>#endif\n<line12>struct timespec ts_sleep = dtotimespec (seconds);\n<line13>for (;;)\n<line14>{\n<line15>/* Linux-2.6.8.1's nanosleep returns -1, but doesn't set errno\n<line16>when resumed after being suspended.  Earlier versions would\n<line17>set errno to EINTR.  nanosleep from linux-2.6.10, as well as\n<line18>implementations by (all?) other vendors, doesn't return -1\n<line19>in that case;  either it continues sleeping (if time remains)\n<line20>or it returns zero (if the wake-up time has passed).\n<line21>Gnulib's replacement nanosleep sometimes does not update\n<line22>TS_SLEEP, and it is possible some kernels have a similar bug.\n<line23>However, this merely causes xnanosleep to sleep longer than\n<line24>necessary, which is not a correctness bug.  */\n<line25>errno = 0;\n<line26>if (nanosleep (&ts_sleep, &ts_sleep) == 0)\n<line27>break;\n<line28>if (errno != EINTR && errno != 0)\n<line29>return -1;\n<line30>}\n<line31>return 0;\n<line32>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/xprintf.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
In file included from /home/huihui/Downloads/coreutils-9.4/lib/xprintf.c:23:
./lib/error.h:28:3: warning: #include_next in file found relative to primary source file or found by absolute path; will search from start of include path [-Winclude-next-absolute-path]
# include_next <error.h>
  ^
2 warnings generated.
Function: xprintf
Content: <line0>int\n<line1>xprintf (char const *restrict format, ...)\n<line2>{\n<line3>va_list args;\n<line4>int retval;\n<line5>va_start (args, format);\n<line6>retval = xvprintf (format, args);\n<line7>va_end (args);\n<line8>return retval;\n<line9>}
----------------------------------------
Function: xvprintf
Content: <line0>int\n<line1>xvprintf (char const *restrict format, va_list args)\n<line2>{\n<line3>int retval = vprintf (format, args);\n<line4>if (retval < 0 && ! ferror (stdout))\n<line5>error (exit_failure, errno, gettext ("cannot perform formatted output"));\n<line6>return retval;\n<line7>}
----------------------------------------
Function: xfprintf
Content: <line0>int\n<line1>xfprintf (FILE *restrict stream, char const *restrict format, ...)\n<line2>{\n<line3>va_list args;\n<line4>int retval;\n<line5>va_start (args, format);\n<line6>retval = xvfprintf (stream, format, args);\n<line7>va_end (args);\n<line8>return retval;\n<line9>}
----------------------------------------
Function: xvfprintf
Content: <line0>int\n<line1>xvfprintf (FILE *restrict stream, char const *restrict format, va_list args)\n<line2>{\n<line3>int retval = vfprintf (stream, format, args);\n<line4>if (retval < 0 && ! ferror (stream))\n<line5>error (exit_failure, errno, gettext ("cannot perform formatted output"));\n<line6>return retval;\n<line7>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/xreadlink.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
Function: xreadlink
Content: <line0>char *\n<line1>xreadlink (char const *filename)\n<line2>{\n<line3>char *result = areadlink (filename);\n<line4>if (result == NULL && errno == ENOMEM)\n<line5>xalloc_die ();\n<line6>return result;\n<line7>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/xsize.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
========================================
/home/huihui/Downloads/coreutils-9.4/lib/xstrtod.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
========================================
/home/huihui/Downloads/coreutils-9.4/lib/xstrtoimax.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
========================================
/home/huihui/Downloads/coreutils-9.4/lib/xstrtol.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
Function: bkm_scale
Content: <line0>static strtol_error\n<line1>bkm_scale (__strtol_t *x, int scale_factor)\n<line2>{\n<line3>__strtol_t scaled;\n<line4>if (ckd_mul (&scaled, *x, scale_factor))\n<line5>{\n<line6>*x = *x < 0 ? TYPE_MINIMUM (__strtol_t) : TYPE_MAXIMUM (__strtol_t);\n<line7>return LONGINT_OVERFLOW;\n<line8>}\n<line9>*x = scaled;\n<line10>return LONGINT_OK;\n<line11>}
----------------------------------------
Function: bkm_scale_by_power
Content: <line0>static strtol_error\n<line1>bkm_scale_by_power (__strtol_t *x, int base, int power)\n<line2>{\n<line3>strtol_error err = LONGINT_OK;\n<line4>while (power--)\n<line5>err |= bkm_scale (x, base);\n<line6>return err;\n<line7>}
----------------------------------------
Function: xstrtol
Content: <line0>strtol_error\n<line1>__xstrtol (const char *s, char **ptr, int strtol_base,\n<line2>__strtol_t *val, const char *valid_suffixes)\n<line3>{\n<line4>char *t_ptr;\n<line5>char **p;\n<line6>__strtol_t tmp;\n<line7>strtol_error err = LONGINT_OK;\n<line8>assure (0 <= strtol_base && strtol_base <= 36);\n<line9>p = (ptr ? ptr : &t_ptr);\n<line10>errno = 0;\n<line11>if (! TYPE_SIGNED (__strtol_t))\n<line12>{\n<line13>const char *q = s;\n<line14>unsigned char ch = *q;\n<line15>while (isspace (ch))\n<line16>ch = *++q;\n<line17>if (ch == '-')\n<line18>return LONGINT_INVALID;\n<line19>}\n<line20>tmp = __strtol (s, p, strtol_base);\n<line21>if (*p == s)\n<line22>{\n<line23>/* If there is no number but there is a valid suffix, assume the\n<line24>number is 1.  The string is invalid otherwise.  */\n<line25>if (valid_suffixes && **p && strchr (valid_suffixes, **p))\n<line26>tmp = 1;\n<line27>else\n<line28>return LONGINT_INVALID;\n<line29>}\n<line30>else if (errno != 0)\n<line31>{\n<line32>if (errno != ERANGE)\n<line33>return LONGINT_INVALID;\n<line34>err = LONGINT_OVERFLOW;\n<line35>}\n<line36>/* Let valid_suffixes == NULL mean "allow any suffix".  */\n<line37>/* FIXME: update all callers except the ones that allow suffixes\n<line38>after the number, changing last parameter NULL to "".  */\n<line39>if (!valid_suffixes)\n<line40>{\n<line41>*val = tmp;\n<line42>return err;\n<line43>}\n<line44>if (**p != '\0')\n<line45>{\n<line46>int base = 1024;\n<line47>int suffixes = 1;\n<line48>strtol_error overflow;\n<line49>if (!strchr (valid_suffixes, **p))\n<line50>{\n<line51>*val = tmp;\n<line52>return err | LONGINT_INVALID_SUFFIX_CHAR;\n<line53>}\n<line54>switch (**p)\n<line55>{\n<line56>case 'E': case 'G': case 'g': case 'k': case 'K': case 'M': case 'm':\n<line57>case 'P': case 'Q': case 'R': case 'T': case 't': case 'Y': case 'Z':\n<line58>/* The "valid suffix" '0' is a special flag meaning that\n<line59>an optional second suffix is allowed, which can change\n<line60>the base.  A suffix "B" (e.g. "100MB") stands for a power\n<line61>of 1000, whereas a suffix "iB" (e.g. "100MiB") stands for\n<line62>a power of 1024.  If no suffix (e.g. "100M"), assume\n<line63>power-of-1024.  */\n<line64>if (strchr (valid_suffixes, '0'))\n<line65>switch (p[0][1])\n<line66>{\n<line67>case 'i':\n<line68>if (p[0][2] == 'B')\n<line69>suffixes += 2;\n<line70>break;\n<line71>case 'B':\n<line72>case 'D': /* 'D' is obsolescent */\n<line73>base = 1000;\n<line74>suffixes++;\n<line75>break;\n<line76>}\n<line77>}\n<line78>switch (**p)\n<line79>{\n<line80>case 'b':\n<line81>overflow = bkm_scale (&tmp, 512);\n<line82>break;\n<line83>case 'B':\n<line84>/* This obsolescent first suffix is distinct from the 'B'\n<line85>second suffix above.  E.g., 'tar -L 1000B' means change\n<line86>the tape after writing 1000 KiB of data.  */\n<line87>overflow = bkm_scale (&tmp, 1024);\n<line88>break;\n<line89>case 'c':\n<line90>overflow = LONGINT_OK;\n<line91>break;\n<line92>case 'E': /* exa or exbi */\n<line93>overflow = bkm_scale_by_power (&tmp, base, 6);\n<line94>break;\n<line95>case 'G': /* giga or gibi */\n<line96>case 'g': /* 'g' is undocumented; for compatibility only */\n<line97>overflow = bkm_scale_by_power (&tmp, base, 3);\n<line98>break;\n<line99>case 'k': /* kilo */\n<line100>case 'K': /* kibi */\n<line101>overflow = bkm_scale_by_power (&tmp, base, 1);\n<line102>break;\n<line103>case 'M': /* mega or mebi */\n<line104>case 'm': /* 'm' is undocumented; for compatibility only */\n<line105>overflow = bkm_scale_by_power (&tmp, base, 2);\n<line106>break;\n<line107>case 'P': /* peta or pebi */\n<line108>overflow = bkm_scale_by_power (&tmp, base, 5);\n<line109>break;\n<line110>case 'Q': /* quetta or 2**100 */\n<line111>overflow = bkm_scale_by_power (&tmp, base, 10);\n<line112>break;\n<line113>case 'R': /* ronna or 2**90 */\n<line114>overflow = bkm_scale_by_power (&tmp, base, 9);\n<line115>break;\n<line116>case 'T': /* tera or tebi */\n<line117>case 't': /* 't' is undocumented; for compatibility only */\n<line118>overflow = bkm_scale_by_power (&tmp, base, 4);\n<line119>break;\n<line120>case 'w':\n<line121>overflow = bkm_scale (&tmp, 2);\n<line122>break;\n<line123>case 'Y': /* yotta or 2**80 */\n<line124>overflow = bkm_scale_by_power (&tmp, base, 8);\n<line125>break;\n<line126>case 'Z': /* zetta or 2**70 */\n<line127>overflow = bkm_scale_by_power (&tmp, base, 7);\n<line128>break;\n<line129>default:\n<line130>*val = tmp;\n<line131>return err | LONGINT_INVALID_SUFFIX_CHAR;\n<line132>}\n<line133>err |= overflow;\n<line134>*p += suffixes;\n<line135>if (**p)\n<line136>err |= LONGINT_INVALID_SUFFIX_CHAR;\n<line137>}\n<line138>*val = tmp;\n<line139>return err;\n<line140>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/xstrtoul.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
========================================
/home/huihui/Downloads/coreutils-9.4/lib/xstrtol-error.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
In file included from /home/huihui/Downloads/coreutils-9.4/lib/xstrtol-error.c:24:
./lib/error.h:28:3: warning: #include_next in file found relative to primary source file or found by absolute path; will search from start of include path [-Winclude-next-absolute-path]
# include_next <error.h>
  ^
2 warnings generated.
Function: xstrtol_error
Content: <line0>static void\n<line1>xstrtol_error (enum strtol_error err,\n<line2>int opt_idx, char c, struct option const *long_options,\n<line3>char const *arg,\n<line4>int exit_status)\n<line5>{\n<line6>char const *hyphens = "--";\n<line7>char const *msgid;\n<line8>char const *option;\n<line9>char option_buffer[2];\n<line10>switch (err)\n<line11>{\n<line12>default:\n<line13>abort ();\n<line14>case LONGINT_INVALID:\n<line15>msgid = N_("invalid %s%s argument '%s'");\n<line16>break;\n<line17>case LONGINT_INVALID_SUFFIX_CHAR:\n<line18>case LONGINT_INVALID_SUFFIX_CHAR_WITH_OVERFLOW:\n<line19>msgid = N_("invalid suffix in %s%s argument '%s'");\n<line20>break;\n<line21>case LONGINT_OVERFLOW:\n<line22>msgid = N_("%s%s argument '%s' too large");\n<line23>break;\n<line24>}\n<line25>if (opt_idx < 0)\n<line26>{\n<line27>hyphens -= opt_idx;\n<line28>option_buffer[0] = c;\n<line29>option_buffer[1] = '\0';\n<line30>option = option_buffer;\n<line31>}\n<line32>else\n<line33>option = long_options[opt_idx].name;\n<line34>error (exit_status, 0, gettext (msgid), hyphens, option, arg);\n<line35>}
----------------------------------------
Function: xstrtol_fatal
Content: <line0>void\n<line1>xstrtol_fatal (enum strtol_error err,\n<line2>int opt_idx, char c, struct option const *long_options,\n<line3>char const *arg)\n<line4>{\n<line5>xstrtol_error (err, opt_idx, c, long_options, arg, exit_failure);\n<line6>abort ();\n<line7>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/xstrtold.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
========================================
/home/huihui/Downloads/coreutils-9.4/lib/xstrtoumax.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
========================================
/home/huihui/Downloads/coreutils-9.4/lib/xvasprintf.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
Function: xstrcat
Content: <line0>static char *\n<line1>xstrcat (size_t argcount, va_list args)\n<line2>{\n<line3>char *result;\n<line4>va_list ap;\n<line5>size_t totalsize;\n<line6>size_t i;\n<line7>char *p;\n<line8>/* Determine the total size.  */\n<line9>totalsize = 0;\n<line10>va_copy (ap, args);\n<line11>for (i = argcount; i > 0; i--)\n<line12>{\n<line13>const char *next = va_arg (ap, const char *);\n<line14>totalsize = xsum (totalsize, strlen (next));\n<line15>}\n<line16>va_end (ap);\n<line17>/* Test for overflow in the summing pass above or in (totalsize + 1) below.\n<line18>Also, don't return a string longer than INT_MAX, for consistency with\n<line19>vasprintf().  */\n<line20>if (totalsize == SIZE_MAX || totalsize > INT_MAX)\n<line21>{\n<line22>errno = EOVERFLOW;\n<line23>return NULL;\n<line24>}\n<line25>/* Allocate and fill the result string.  */\n<line26>result = XNMALLOC (totalsize + 1, char);\n<line27>p = result;\n<line28>for (i = argcount; i > 0; i--)\n<line29>{\n<line30>const char *next = va_arg (args, const char *);\n<line31>size_t len = strlen (next);\n<line32>memcpy (p, next, len);\n<line33>p += len;\n<line34>}\n<line35>*p = '\0';\n<line36>return result;\n<line37>}
----------------------------------------
Function: xvasprintf
Content: <line0>char *\n<line1>xvasprintf (const char *format, va_list args)\n<line2>{\n<line3>char *result;\n<line4>/* Recognize the special case format = "%s...%s".  It is a frequently used\n<line5>idiom for string concatenation and needs to be fast.  We don't want to\n<line6>have a separate function xstrcat() for this purpose.  */\n<line7>{\n<line8>size_t argcount = 0;\n<line9>const char *f;\n<line10>for (f = format;;)\n<line11>{\n<line12>if (*f == '\0')\n<line13>/* Recognized the special case of string concatenation.  */\n<line14>return xstrcat (argcount, args);\n<line15>if (*f != '%')\n<line16>break;\n<line17>f++;\n<line18>if (*f != 's')\n<line19>break;\n<line20>f++;\n<line21>argcount++;\n<line22>}\n<line23>}\n<line24>if (vasprintf (&result, format, args) < 0)\n<line25>{\n<line26>if (errno == ENOMEM)\n<line27>xalloc_die ();\n<line28>return NULL;\n<line29>}\n<line30>return result;\n<line31>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/xasprintf.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
Function: xasprintf
Content: <line0>char *\n<line1>xasprintf (const char *format, ...)\n<line2>{\n<line3>va_list args;\n<line4>char *result;\n<line5>va_start (args, format);\n<line6>result = xvasprintf (format, args);\n<line7>va_end (args);\n<line8>return result;\n<line9>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/yesno.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
========================================
/home/huihui/Downloads/coreutils-9.4/lib/asnprintf.c
========================================
Function: asnprintf
Content: <line0>char *\n<line1>asnprintf (char *resultbuf, size_t *lengthp, const char *format, ...)\n<line2>{\n<line3>va_list args;\n<line4>char *result;\n<line5>va_start (args, format);\n<line6>result = vasnprintf (resultbuf, lengthp, format, args);\n<line7>va_end (args);\n<line8>return result;\n<line9>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/asprintf.c
========================================
Function: rpl_asprintf
Content: <line0>int\n<line1>asprintf (char **resultp, const char *format, ...)\n<line2>{\n<line3>va_list args;\n<line4>int result;\n<line5>va_start (args, format);\n<line6>result = vasprintf (resultp, format, args);\n<line7>va_end (args);\n<line8>return result;\n<line9>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/fopen.c
========================================
Function: orig_fopen
Content: <line0>static FILE *\n<line1>orig_fopen (const char *filename, const char *mode)\n<line2>{\n<line3>return fopen (filename, mode);\n<line4>}
----------------------------------------
Function: rpl_fopen
Content: <line0>FILE *\n<line1>rpl_fopen (const char *filename, const char *mode)\n<line2>{\n<line3>int open_direction;\n<line4>int open_flags;\n<line5>#if GNULIB_FOPEN_GNU\n<line6>bool open_flags_gnu;\n<line7># define BUF_SIZE 80\n<line8>char fdopen_mode_buf[BUF_SIZE + 1];\n<line9>#endif\n<line10>#if defined _WIN32 && ! defined __CYGWIN__\n<line11>if (strcmp (filename, "/dev/null") == 0)\n<line12>filename = "NUL";\n<line13>#endif\n<line14>/* Parse the mode.  */\n<line15>open_direction = 0;\n<line16>open_flags = 0;\n<line17>#if GNULIB_FOPEN_GNU\n<line18>open_flags_gnu = false;\n<line19>#endif\n<line20>{\n<line21>const char *p = mode;\n<line22>#if GNULIB_FOPEN_GNU\n<line23>char *q = fdopen_mode_buf;\n<line24>#endif\n<line25>for (; *p != '\0'; p++)\n<line26>{\n<line27>switch (*p)\n<line28>{\n<line29>case 'r':\n<line30>open_direction = O_RDONLY;\n<line31>#if GNULIB_FOPEN_GNU\n<line32>if (q < fdopen_mode_buf + BUF_SIZE)\n<line33>*q++ = *p;\n<line34>#endif\n<line35>continue;\n<line36>case 'w':\n<line37>open_direction = O_WRONLY;\n<line38>open_flags |= O_CREAT | O_TRUNC;\n<line39>#if GNULIB_FOPEN_GNU\n<line40>if (q < fdopen_mode_buf + BUF_SIZE)\n<line41>*q++ = *p;\n<line42>#endif\n<line43>continue;\n<line44>case 'a':\n<line45>open_direction = O_WRONLY;\n<line46>open_flags |= O_CREAT | O_APPEND;\n<line47>#if GNULIB_FOPEN_GNU\n<line48>if (q < fdopen_mode_buf + BUF_SIZE)\n<line49>*q++ = *p;\n<line50>#endif\n<line51>continue;\n<line52>case 'b':\n<line53>/* While it is non-standard, O_BINARY is guaranteed by\n<line54>gnulib <fcntl.h>.  We can also assume that orig_fopen\n<line55>supports the 'b' flag.  */\n<line56>open_flags |= O_BINARY;\n<line57>#if GNULIB_FOPEN_GNU\n<line58>if (q < fdopen_mode_buf + BUF_SIZE)\n<line59>*q++ = *p;\n<line60>#endif\n<line61>continue;\n<line62>case '+':\n<line63>open_direction = O_RDWR;\n<line64>#if GNULIB_FOPEN_GNU\n<line65>if (q < fdopen_mode_buf + BUF_SIZE)\n<line66>*q++ = *p;\n<line67>#endif\n<line68>continue;\n<line69>#if GNULIB_FOPEN_GNU\n<line70>case 'x':\n<line71>open_flags |= O_EXCL;\n<line72>open_flags_gnu = true;\n<line73>continue;\n<line74>case 'e':\n<line75>open_flags |= O_CLOEXEC;\n<line76>open_flags_gnu = true;\n<line77>continue;\n<line78>#endif\n<line79>default:\n<line80>break;\n<line81>}\n<line82>#if GNULIB_FOPEN_GNU\n<line83>/* The rest of the mode string can be a platform-dependent extension.\n<line84>Copy it unmodified.  */\n<line85>{\n<line86>size_t len = strlen (p);\n<line87>if (len > fdopen_mode_buf + BUF_SIZE - q)\n<line88>len = fdopen_mode_buf + BUF_SIZE - q;\n<line89>memcpy (q, p, len);\n<line90>q += len;\n<line91>}\n<line92>#endif\n<line93>break;\n<line94>}\n<line95>#if GNULIB_FOPEN_GNU\n<line96>*q = '\0';\n<line97>#endif\n<line98>}\n<line99>#if FOPEN_TRAILING_SLASH_BUG\n<line100>/* Fail if the mode requires write access and the filename ends in a slash,\n<line101>as POSIX says such a filename must name a directory\n<line102><https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap04.html#tag_04_13>:\n<line103>"A pathname that contains at least one non-<slash> character and that\n<line104>ends with one or more trailing <slash> characters shall not be resolved\n<line105>successfully unless the last pathname component before the trailing\n<line106><slash> characters names an existing directory"\n<line107>If the named file already exists as a directory, then if a mode that\n<line108>requires write access is specified, fopen() must fail because POSIX\n<line109><https://pubs.opengroup.org/onlinepubs/9699919799/functions/fopen.html>\n<line110>says that it fails with errno = EISDIR in this case.\n<line111>If the named file does not exist or does not name a directory, then\n<line112>fopen() must fail since the file does not contain a '.' directory.  */\n<line113>{\n<line114>size_t len = strlen (filename);\n<line115>if (len > 0 && filename[len - 1] == '/')\n<line116>{\n<line117>int fd;\n<line118>struct stat statbuf;\n<line119>FILE *fp;\n<line120>if (open_direction != O_RDONLY)\n<line121>{\n<line122>errno = EISDIR;\n<line123>return NULL;\n<line124>}\n<line125>fd = open (filename, open_direction | open_flags,\n<line126>S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH);\n<line127>if (fd < 0)\n<line128>return NULL;\n<line129>if (fstat (fd, &statbuf) >= 0 && !S_ISDIR (statbuf.st_mode))\n<line130>{\n<line131>close (fd);\n<line132>errno = ENOTDIR;\n<line133>return NULL;\n<line134>}\n<line135># if GNULIB_FOPEN_GNU\n<line136>fp = fdopen (fd, fdopen_mode_buf);\n<line137># else\n<line138>fp = fdopen (fd, mode);\n<line139># endif\n<line140>if (fp == NULL)\n<line141>{\n<line142>int saved_errno = errno;\n<line143>close (fd);\n<line144>errno = saved_errno;\n<line145>}\n<line146>return fp;\n<line147>}\n<line148>}\n<line149>#endif\n<line150>#if GNULIB_FOPEN_GNU\n<line151>if (open_flags_gnu)\n<line152>{\n<line153>int fd;\n<line154>FILE *fp;\n<line155>fd = open (filename, open_direction | open_flags,\n<line156>S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH);\n<line157>if (fd < 0)\n<line158>return NULL;\n<line159>fp = fdopen (fd, fdopen_mode_buf);\n<line160>if (fp == NULL)\n<line161>{\n<line162>int saved_errno = errno;\n<line163>close (fd);\n<line164>errno = saved_errno;\n<line165>}\n<line166>return fp;\n<line167>}\n<line168>#endif\n<line169>/* open_direction is sometimes used, sometimes unused.\n<line170>Silence gcc's warning about this situation.  */\n<line171>(void) open_direction;\n<line172>return orig_fopen (filename, mode);\n<line173>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/mbsrtoc32s-state.c
========================================
========================================
/home/huihui/Downloads/coreutils-9.4/lib/mbsrtowcs-state.c
========================================
========================================
/home/huihui/Downloads/coreutils-9.4/lib/mktime.c
========================================
Function: shr
Content: <line0>static long_int\n<line1>shr (long_int a, int b)\n<line2>{\n<line3>long_int one = 1;\n<line4>return (-one >> 1 == -1\n<line5>? a >> b\n<line6>: (a + (a < 0)) / (one << b) - (a < 0));\n<line7>}
----------------------------------------
Function: leapyear
Content: <line0>static bool\n<line1>leapyear (long_int year)\n<line2>{\n<line3>/* Don't add YEAR to TM_YEAR_BASE, as that might overflow.\n<line4>Also, work even if YEAR is negative.  */\n<line5>return\n<line6>((year & 3) == 0\n<line7>&& (year % 100 != 0\n<line8>|| ((year / 100) & 3) == (- (TM_YEAR_BASE / 100) & 3)));\n<line9>}
----------------------------------------
Function: isdst_differ
Content: <line0>static bool\n<line1>isdst_differ (int a, int b)\n<line2>{\n<line3>return (!a != !b) && (0 <= a) && (0 <= b);\n<line4>}
----------------------------------------
Function: ydhms_diff
Content: <line0>static long_int\n<line1>ydhms_diff (long_int year1, long_int yday1, int hour1, int min1, int sec1,\n<line2>int year0, int yday0, int hour0, int min0, int sec0)\n<line3>{\n<line4>verify (-1 / 2 == 0);\n<line5>/* Compute intervening leap days correctly even if year is negative.\n<line6>Take care to avoid integer overflow here.  */\n<line7>int a4 = shr (year1, 2) + shr (TM_YEAR_BASE, 2) - ! (year1 & 3);\n<line8>int b4 = shr (year0, 2) + shr (TM_YEAR_BASE, 2) - ! (year0 & 3);\n<line9>int a100 = (a4 + (a4 < 0)) / 25 - (a4 < 0);\n<line10>int b100 = (b4 + (b4 < 0)) / 25 - (b4 < 0);\n<line11>int a400 = shr (a100, 2);\n<line12>int b400 = shr (b100, 2);\n<line13>int intervening_leap_days = (a4 - b4) - (a100 - b100) + (a400 - b400);\n<line14>/* Compute the desired time without overflowing.  */\n<line15>long_int years = year1 - year0;\n<line16>long_int days = 365 * years + yday1 - yday0 + intervening_leap_days;\n<line17>long_int hours = 24 * days + hour1 - hour0;\n<line18>long_int minutes = 60 * hours + min1 - min0;\n<line19>long_int seconds = 60 * minutes + sec1 - sec0;\n<line20>return seconds;\n<line21>}
----------------------------------------
Function: long_int_avg
Content: <line0>static long_int\n<line1>long_int_avg (long_int a, long_int b)\n<line2>{\n<line3>return shr (a, 1) + shr (b, 1) + ((a | b) & 1);\n<line4>}
----------------------------------------
Function: tm_diff
Content: <line0>static long_int\n<line1>tm_diff (long_int year, long_int yday, int hour, int min, int sec,\n<line2>struct tm const *tp)\n<line3>{\n<line4>return ydhms_diff (year, yday, hour, min, sec,\n<line5>tp->tm_year, tp->tm_yday,\n<line6>tp->tm_hour, tp->tm_min, tp->tm_sec);\n<line7>}
----------------------------------------
Function: convert_time
Content: <line0>static struct tm *\n<line1>convert_time (struct tm *(*convert) (const __time64_t *, struct tm *),\n<line2>long_int t, struct tm *tm)\n<line3>{\n<line4>__time64_t x = t;\n<line5>return convert (&x, tm);\n<line6>}
----------------------------------------
Function: ranged_convert
Content: <line0>static struct tm *\n<line1>ranged_convert (struct tm *(*convert) (const __time64_t *, struct tm *),\n<line2>long_int *t, struct tm *tp)\n<line3>{\n<line4>long_int t1 = (*t < mktime_min ? mktime_min\n<line5>: *t <= mktime_max ? *t : mktime_max);\n<line6>struct tm *r = convert_time (convert, t1, tp);\n<line7>if (r)\n<line8>{\n<line9>*t = t1;\n<line10>return r;\n<line11>}\n<line12>if (errno != EOVERFLOW)\n<line13>return NULL;\n<line14>long_int bad = t1;\n<line15>long_int ok = 0;\n<line16>struct tm oktm; oktm.tm_sec = -1;\n<line17>/* BAD is a known out-of-range value, and OK is a known in-range one.\n<line18>Use binary search to narrow the range between BAD and OK until\n<line19>they differ by 1.  */\n<line20>while (true)\n<line21>{\n<line22>long_int mid = long_int_avg (ok, bad);\n<line23>if (mid == ok || mid == bad)\n<line24>break;\n<line25>if (convert_time (convert, mid, tp))\n<line26>ok = mid, oktm = *tp;\n<line27>else if (errno != EOVERFLOW)\n<line28>return NULL;\n<line29>else\n<line30>bad = mid;\n<line31>}\n<line32>if (oktm.tm_sec < 0)\n<line33>return NULL;\n<line34>*t = ok;\n<line35>*tp = oktm;\n<line36>return tp;\n<line37>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/printf-args.c
========================================
Function: printf_fetchargs
Content: <line0>int\n<line1>PRINTF_FETCHARGS (va_list args, arguments *a)\n<line2>{\n<line3>size_t i;\n<line4>argument *ap;\n<line5>for (i = 0, ap = &a->arg[0]; i < a->count; i++, ap++)\n<line6>switch (ap->type)\n<line7>{\n<line8>case TYPE_SCHAR:\n<line9>ap->a.a_schar = va_arg (args, /*signed char*/ int);\n<line10>break;\n<line11>case TYPE_UCHAR:\n<line12>ap->a.a_uchar = va_arg (args, /*unsigned char*/ int);\n<line13>break;\n<line14>case TYPE_SHORT:\n<line15>ap->a.a_short = va_arg (args, /*short*/ int);\n<line16>break;\n<line17>case TYPE_USHORT:\n<line18>ap->a.a_ushort = va_arg (args, /*unsigned short*/ int);\n<line19>break;\n<line20>case TYPE_INT:\n<line21>ap->a.a_int = va_arg (args, int);\n<line22>break;\n<line23>case TYPE_UINT:\n<line24>ap->a.a_uint = va_arg (args, unsigned int);\n<line25>break;\n<line26>case TYPE_LONGINT:\n<line27>ap->a.a_longint = va_arg (args, long int);\n<line28>break;\n<line29>case TYPE_ULONGINT:\n<line30>ap->a.a_ulongint = va_arg (args, unsigned long int);\n<line31>break;\n<line32>case TYPE_LONGLONGINT:\n<line33>ap->a.a_longlongint = va_arg (args, long long int);\n<line34>break;\n<line35>case TYPE_ULONGLONGINT:\n<line36>ap->a.a_ulonglongint = va_arg (args, unsigned long long int);\n<line37>break;\n<line38>case TYPE_INT8_T:\n<line39>#if INT8_WIDTH < INT_WIDTH\n<line40>ap->a.a_int8_t = va_arg (args, /* int8_t */ int);\n<line41>#else\n<line42>ap->a.a_int8_t = va_arg (args, int8_t);\n<line43>#endif\n<line44>break;\n<line45>case TYPE_UINT8_T:\n<line46>#if UINT8_WIDTH < INT_WIDTH\n<line47>ap->a.a_uint8_t = va_arg (args, /* uint8_t */ int);\n<line48>#else\n<line49>ap->a.a_uint8_t = va_arg (args, uint8_t);\n<line50>#endif\n<line51>break;\n<line52>case TYPE_INT16_T:\n<line53>#if INT16_WIDTH < INT_WIDTH\n<line54>ap->a.a_int16_t = va_arg (args, /* int16_t */ int);\n<line55>#else\n<line56>ap->a.a_int16_t = va_arg (args, int16_t);\n<line57>#endif\n<line58>break;\n<line59>case TYPE_UINT16_T:\n<line60>#if UINT16_WIDTH < INT_WIDTH\n<line61>ap->a.a_uint16_t = va_arg (args, /* uint16_t */ int);\n<line62>#else\n<line63>ap->a.a_uint16_t = va_arg (args, uint16_t);\n<line64>#endif\n<line65>break;\n<line66>case TYPE_INT32_T:\n<line67>#if INT32_WIDTH < INT_WIDTH\n<line68>ap->a.a_int32_t = va_arg (args, /* int32_t */ int);\n<line69>#else\n<line70>ap->a.a_int32_t = va_arg (args, int32_t);\n<line71>#endif\n<line72>break;\n<line73>case TYPE_UINT32_T:\n<line74>#if UINT32_WIDTH < INT_WIDTH\n<line75>ap->a.a_uint32_t = va_arg (args, /* uint32_t */ int);\n<line76>#else\n<line77>ap->a.a_uint32_t = va_arg (args, uint32_t);\n<line78>#endif\n<line79>break;\n<line80>case TYPE_INT64_T:\n<line81>ap->a.a_int64_t = va_arg (args, int64_t);\n<line82>break;\n<line83>case TYPE_UINT64_T:\n<line84>ap->a.a_uint64_t = va_arg (args, uint64_t);\n<line85>break;\n<line86>case TYPE_INT_FAST8_T:\n<line87>#if INT_FAST8_WIDTH < INT_WIDTH\n<line88>ap->a.a_int_fast8_t = va_arg (args, /* int_fast8_t */ int);\n<line89>#else\n<line90>ap->a.a_int_fast8_t = va_arg (args, int_fast8_t);\n<line91>#endif\n<line92>break;\n<line93>case TYPE_UINT_FAST8_T:\n<line94>#if UINT_FAST8_WIDTH < INT_WIDTH\n<line95>ap->a.a_uint_fast8_t = va_arg (args, /* uint_fast8_t */ int);\n<line96>#else\n<line97>ap->a.a_uint_fast8_t = va_arg (args, uint_fast8_t);\n<line98>#endif\n<line99>break;\n<line100>case TYPE_INT_FAST16_T:\n<line101>#if INT_FAST16_WIDTH < INT_WIDTH\n<line102>ap->a.a_int_fast16_t = va_arg (args, /* int_fast16_t */ int);\n<line103>#else\n<line104>ap->a.a_int_fast16_t = va_arg (args, int_fast16_t);\n<line105>#endif\n<line106>break;\n<line107>case TYPE_UINT_FAST16_T:\n<line108>#if UINT_FAST16_WIDTH < INT_WIDTH\n<line109>ap->a.a_uint_fast16_t = va_arg (args, /* uint_fast16_t */ int);\n<line110>#else\n<line111>ap->a.a_uint_fast16_t = va_arg (args, uint_fast16_t);\n<line112>#endif\n<line113>break;\n<line114>case TYPE_INT_FAST32_T:\n<line115>#if INT_FAST32_WIDTH < INT_WIDTH\n<line116>ap->a.a_int_fast32_t = va_arg (args, /* int_fast32_t */ int);\n<line117>#else\n<line118>ap->a.a_int_fast32_t = va_arg (args, int_fast32_t);\n<line119>#endif\n<line120>break;\n<line121>case TYPE_UINT_FAST32_T:\n<line122>#if UINT_FAST32_WIDTH < INT_WIDTH\n<line123>ap->a.a_uint_fast32_t = va_arg (args, /* uint_fast32_t */ int);\n<line124>#else\n<line125>ap->a.a_uint_fast32_t = va_arg (args, uint_fast32_t);\n<line126>#endif\n<line127>break;\n<line128>case TYPE_INT_FAST64_T:\n<line129>ap->a.a_int_fast64_t = va_arg (args, int_fast64_t);\n<line130>break;\n<line131>case TYPE_UINT_FAST64_T:\n<line132>ap->a.a_uint_fast64_t = va_arg (args, uint_fast64_t);\n<line133>break;\n<line134>case TYPE_DOUBLE:\n<line135>ap->a.a_double = va_arg (args, double);\n<line136>break;\n<line137>case TYPE_LONGDOUBLE:\n<line138>ap->a.a_longdouble = va_arg (args, long double);\n<line139>break;\n<line140>case TYPE_CHAR:\n<line141>ap->a.a_char = va_arg (args, int);\n<line142>break;\n<line143>#if HAVE_WINT_T\n<line144>case TYPE_WIDE_CHAR:\n<line145>/* Although ISO C 99 7.24.1.(2) says that wint_t is "unchanged by\n<line146>default argument promotions", this is not the case in mingw32,\n<line147>where wint_t is 'unsigned short'.  */\n<line148>ap->a.a_wide_char =\n<line149>(sizeof (wint_t) < sizeof (int)\n<line150>? (wint_t) va_arg (args, int)\n<line151>: va_arg (args, wint_t));\n<line152>break;\n<line153>#endif\n<line154>case TYPE_STRING:\n<line155>ap->a.a_string = va_arg (args, const char *);\n<line156>/* A null pointer is an invalid argument for "%s", but in practice\n<line157>it occurs quite frequently in printf statements that produce\n<line158>debug output.  Use a fallback in this case.  */\n<line159>if (ap->a.a_string == NULL)\n<line160>ap->a.a_string = "(NULL)";\n<line161>break;\n<line162>#if HAVE_WCHAR_T\n<line163>case TYPE_WIDE_STRING:\n<line164>ap->a.a_wide_string = va_arg (args, const wchar_t *);\n<line165>/* A null pointer is an invalid argument for "%ls", but in practice\n<line166>it occurs quite frequently in printf statements that produce\n<line167>debug output.  Use a fallback in this case.  */\n<line168>if (ap->a.a_wide_string == NULL)\n<line169>{\n<line170>static const wchar_t wide_null_string[] =\n<line171>{\n<line172>(wchar_t)'(',\n<line173>(wchar_t)'N', (wchar_t)'U', (wchar_t)'L', (wchar_t)'L',\n<line174>(wchar_t)')',\n<line175>(wchar_t)0\n<line176>};\n<line177>ap->a.a_wide_string = wide_null_string;\n<line178>}\n<line179>break;\n<line180>#endif\n<line181>case TYPE_POINTER:\n<line182>ap->a.a_pointer = va_arg (args, void *);\n<line183>break;\n<line184>case TYPE_COUNT_SCHAR_POINTER:\n<line185>ap->a.a_count_schar_pointer = va_arg (args, signed char *);\n<line186>break;\n<line187>case TYPE_COUNT_SHORT_POINTER:\n<line188>ap->a.a_count_short_pointer = va_arg (args, short *);\n<line189>break;\n<line190>case TYPE_COUNT_INT_POINTER:\n<line191>ap->a.a_count_int_pointer = va_arg (args, int *);\n<line192>break;\n<line193>case TYPE_COUNT_LONGINT_POINTER:\n<line194>ap->a.a_count_longint_pointer = va_arg (args, long int *);\n<line195>break;\n<line196>case TYPE_COUNT_LONGLONGINT_POINTER:\n<line197>ap->a.a_count_longlongint_pointer = va_arg (args, long long int *);\n<line198>break;\n<line199>case TYPE_COUNT_INT8_T_POINTER:\n<line200>ap->a.a_count_int8_t_pointer = va_arg (args, int8_t *);\n<line201>break;\n<line202>case TYPE_COUNT_INT16_T_POINTER:\n<line203>ap->a.a_count_int16_t_pointer = va_arg (args, int16_t *);\n<line204>break;\n<line205>case TYPE_COUNT_INT32_T_POINTER:\n<line206>ap->a.a_count_int32_t_pointer = va_arg (args, int32_t *);\n<line207>break;\n<line208>case TYPE_COUNT_INT64_T_POINTER:\n<line209>ap->a.a_count_int64_t_pointer = va_arg (args, int64_t *);\n<line210>break;\n<line211>case TYPE_COUNT_INT_FAST8_T_POINTER:\n<line212>ap->a.a_count_int_fast8_t_pointer = va_arg (args, int_fast8_t *);\n<line213>break;\n<line214>case TYPE_COUNT_INT_FAST16_T_POINTER:\n<line215>ap->a.a_count_int_fast16_t_pointer = va_arg (args, int_fast16_t *);\n<line216>break;\n<line217>case TYPE_COUNT_INT_FAST32_T_POINTER:\n<line218>ap->a.a_count_int_fast32_t_pointer = va_arg (args, int_fast32_t *);\n<line219>break;\n<line220>case TYPE_COUNT_INT_FAST64_T_POINTER:\n<line221>ap->a.a_count_int_fast64_t_pointer = va_arg (args, int_fast64_t *);\n<line222>break;\n<line223>#if ENABLE_UNISTDIO\n<line224>/* The unistdio extensions.  */\n<line225>case TYPE_U8_STRING:\n<line226>ap->a.a_u8_string = va_arg (args, const uint8_t *);\n<line227>/* A null pointer is an invalid argument for "%U", but in practice\n<line228>it occurs quite frequently in printf statements that produce\n<line229>debug output.  Use a fallback in this case.  */\n<line230>if (ap->a.a_u8_string == NULL)\n<line231>{\n<line232>static const uint8_t u8_null_string[] =\n<line233>{ '(', 'N', 'U', 'L', 'L', ')', 0 };\n<line234>ap->a.a_u8_string = u8_null_string;\n<line235>}\n<line236>break;\n<line237>case TYPE_U16_STRING:\n<line238>ap->a.a_u16_string = va_arg (args, const uint16_t *);\n<line239>/* A null pointer is an invalid argument for "%lU", but in practice\n<line240>it occurs quite frequently in printf statements that produce\n<line241>debug output.  Use a fallback in this case.  */\n<line242>if (ap->a.a_u16_string == NULL)\n<line243>{\n<line244>static const uint16_t u16_null_string[] =\n<line245>{ '(', 'N', 'U', 'L', 'L', ')', 0 };\n<line246>ap->a.a_u16_string = u16_null_string;\n<line247>}\n<line248>break;\n<line249>case TYPE_U32_STRING:\n<line250>ap->a.a_u32_string = va_arg (args, const uint32_t *);\n<line251>/* A null pointer is an invalid argument for "%llU", but in practice\n<line252>it occurs quite frequently in printf statements that produce\n<line253>debug output.  Use a fallback in this case.  */\n<line254>if (ap->a.a_u32_string == NULL)\n<line255>{\n<line256>static const uint32_t u32_null_string[] =\n<line257>{ '(', 'N', 'U', 'L', 'L', ')', 0 };\n<line258>ap->a.a_u32_string = u32_null_string;\n<line259>}\n<line260>break;\n<line261>#endif\n<line262>default:\n<line263>/* Unknown type.  */\n<line264>return -1;\n<line265>}\n<line266>return 0;\n<line267>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/printf-parse.c
========================================
Function: printf_parse
Content: <line0>int\n<line1>PRINTF_PARSE (const CHAR_T *format, DIRECTIVES *d, arguments *a)\n<line2>{\n<line3>const CHAR_T *cp = format;    /* pointer into format */\n<line4>size_t arg_posn = 0;          /* number of regular arguments consumed */\n<line5>size_t d_allocated;           /* allocated elements of d->dir */\n<line6>size_t a_allocated;           /* allocated elements of a->arg */\n<line7>size_t max_width_length = 0;\n<line8>size_t max_precision_length = 0;\n<line9>d->count = 0;\n<line10>d_allocated = N_DIRECT_ALLOC_DIRECTIVES;\n<line11>d->dir = d->direct_alloc_dir;\n<line12>a->count = 0;\n<line13>a_allocated = N_DIRECT_ALLOC_ARGUMENTS;\n<line14>a->arg = a->direct_alloc_arg;\n<line15>#define REGISTER_ARG(_index_,_type_) \\n<line16>{                                                                     \\n<line17>size_t n = (_index_);                                               \\n<line18>if (n >= a_allocated)                                               \\n<line19>{                                                                 \\n<line20>size_t memory_size;                                             \\n<line21>argument *memory;                                               \\n<line22>\\n<line23>a_allocated = xtimes (a_allocated, 2);                          \\n<line24>if (a_allocated <= n)                                           \\n<line25>a_allocated = xsum (n, 1);                                    \\n<line26>memory_size = xtimes (a_allocated, sizeof (argument));          \\n<line27>if (size_overflow_p (memory_size))                              \\n<line28>/* Overflow, would lead to out of memory.  */                 \\n<line29>goto out_of_memory;                                           \\n<line30>memory = (argument *) (a->arg != a->direct_alloc_arg            \\n<line31>? realloc (a->arg, memory_size)          \\n<line32>: malloc (memory_size));                 \\n<line33>if (memory == NULL)                                             \\n<line34>/* Out of memory.  */                                         \\n<line35>goto out_of_memory;                                           \\n<line36>if (a->arg == a->direct_alloc_arg)                              \\n<line37>memcpy (memory, a->arg, a->count * sizeof (argument));        \\n<line38>a->arg = memory;                                                \\n<line39>}                                                                 \\n<line40>while (a->count <= n)                                               \\n<line41>a->arg[a->count++].type = TYPE_NONE;                              \\n<line42>if (a->arg[n].type == TYPE_NONE)                                    \\n<line43>a->arg[n].type = (_type_);                                        \\n<line44>else if (a->arg[n].type != (_type_))                                \\n<line45>/* Ambiguous type for positional argument.  */                    \\n<line46>goto error;                                                       \\n<line47>}\n<line48>while (*cp != '\0')\n<line49>{\n<line50>CHAR_T c = *cp++;\n<line51>if (c == '%')\n<line52>{\n<line53>size_t arg_index = ARG_NONE;\n<line54>DIRECTIVE *dp = &d->dir[d->count]; /* pointer to next directive */\n<line55>/* Initialize the next directive.  */\n<line56>dp->dir_start = cp - 1;\n<line57>dp->flags = 0;\n<line58>dp->width_start = NULL;\n<line59>dp->width_end = NULL;\n<line60>dp->width_arg_index = ARG_NONE;\n<line61>dp->precision_start = NULL;\n<line62>dp->precision_end = NULL;\n<line63>dp->precision_arg_index = ARG_NONE;\n<line64>dp->arg_index = ARG_NONE;\n<line65>/* Test for positional argument.  */\n<line66>if (*cp >= '0' && *cp <= '9')\n<line67>{\n<line68>const CHAR_T *np;\n<line69>for (np = cp; *np >= '0' && *np <= '9'; np++)\n<line70>;\n<line71>if (*np == '$')\n<line72>{\n<line73>size_t n = 0;\n<line74>for (np = cp; *np >= '0' && *np <= '9'; np++)\n<line75>n = xsum (xtimes (n, 10), *np - '0');\n<line76>if (n == 0)\n<line77>/* Positional argument 0.  */\n<line78>goto error;\n<line79>if (size_overflow_p (n))\n<line80>/* n too large, would lead to out of memory later.  */\n<line81>goto error;\n<line82>arg_index = n - 1;\n<line83>cp = np + 1;\n<line84>}\n<line85>}\n<line86>/* Read the flags.  */\n<line87>for (;;)\n<line88>{\n<line89>if (*cp == '\'')\n<line90>{\n<line91>dp->flags |= FLAG_GROUP;\n<line92>cp++;\n<line93>}\n<line94>else if (*cp == '-')\n<line95>{\n<line96>dp->flags |= FLAG_LEFT;\n<line97>cp++;\n<line98>}\n<line99>else if (*cp == '+')\n<line100>{\n<line101>dp->flags |= FLAG_SHOWSIGN;\n<line102>cp++;\n<line103>}\n<line104>else if (*cp == ' ')\n<line105>{\n<line106>dp->flags |= FLAG_SPACE;\n<line107>cp++;\n<line108>}\n<line109>else if (*cp == '#')\n<line110>{\n<line111>dp->flags |= FLAG_ALT;\n<line112>cp++;\n<line113>}\n<line114>else if (*cp == '0')\n<line115>{\n<line116>dp->flags |= FLAG_ZERO;\n<line117>cp++;\n<line118>}\n<line119>#if __GLIBC__ >= 2 && !defined __UCLIBC__\n<line120>else if (*cp == 'I')\n<line121>{\n<line122>dp->flags |= FLAG_LOCALIZED;\n<line123>cp++;\n<line124>}\n<line125>#endif\n<line126>else\n<line127>break;\n<line128>}\n<line129>/* Parse the field width.  */\n<line130>if (*cp == '*')\n<line131>{\n<line132>dp->width_start = cp;\n<line133>cp++;\n<line134>dp->width_end = cp;\n<line135>if (max_width_length < 1)\n<line136>max_width_length = 1;\n<line137>/* Test for positional argument.  */\n<line138>if (*cp >= '0' && *cp <= '9')\n<line139>{\n<line140>const CHAR_T *np;\n<line141>for (np = cp; *np >= '0' && *np <= '9'; np++)\n<line142>;\n<line143>if (*np == '$')\n<line144>{\n<line145>size_t n = 0;\n<line146>for (np = cp; *np >= '0' && *np <= '9'; np++)\n<line147>n = xsum (xtimes (n, 10), *np - '0');\n<line148>if (n == 0)\n<line149>/* Positional argument 0.  */\n<line150>goto error;\n<line151>if (size_overflow_p (n))\n<line152>/* n too large, would lead to out of memory later.  */\n<line153>goto error;\n<line154>dp->width_arg_index = n - 1;\n<line155>cp = np + 1;\n<line156>}\n<line157>}\n<line158>if (dp->width_arg_index == ARG_NONE)\n<line159>{\n<line160>dp->width_arg_index = arg_posn++;\n<line161>if (dp->width_arg_index == ARG_NONE)\n<line162>/* arg_posn wrapped around.  */\n<line163>goto error;\n<line164>}\n<line165>REGISTER_ARG (dp->width_arg_index, TYPE_INT);\n<line166>}\n<line167>else if (*cp >= '0' && *cp <= '9')\n<line168>{\n<line169>size_t width_length;\n<line170>dp->width_start = cp;\n<line171>for (; *cp >= '0' && *cp <= '9'; cp++)\n<line172>;\n<line173>dp->width_end = cp;\n<line174>width_length = dp->width_end - dp->width_start;\n<line175>if (max_width_length < width_length)\n<line176>max_width_length = width_length;\n<line177>}\n<line178>/* Parse the precision.  */\n<line179>if (*cp == '.')\n<line180>{\n<line181>cp++;\n<line182>if (*cp == '*')\n<line183>{\n<line184>dp->precision_start = cp - 1;\n<line185>cp++;\n<line186>dp->precision_end = cp;\n<line187>if (max_precision_length < 2)\n<line188>max_precision_length = 2;\n<line189>/* Test for positional argument.  */\n<line190>if (*cp >= '0' && *cp <= '9')\n<line191>{\n<line192>const CHAR_T *np;\n<line193>for (np = cp; *np >= '0' && *np <= '9'; np++)\n<line194>;\n<line195>if (*np == '$')\n<line196>{\n<line197>size_t n = 0;\n<line198>for (np = cp; *np >= '0' && *np <= '9'; np++)\n<line199>n = xsum (xtimes (n, 10), *np - '0');\n<line200>if (n == 0)\n<line201>/* Positional argument 0.  */\n<line202>goto error;\n<line203>if (size_overflow_p (n))\n<line204>/* n too large, would lead to out of memory\n<line205>later.  */\n<line206>goto error;\n<line207>dp->precision_arg_index = n - 1;\n<line208>cp = np + 1;\n<line209>}\n<line210>}\n<line211>if (dp->precision_arg_index == ARG_NONE)\n<line212>{\n<line213>dp->precision_arg_index = arg_posn++;\n<line214>if (dp->precision_arg_index == ARG_NONE)\n<line215>/* arg_posn wrapped around.  */\n<line216>goto error;\n<line217>}\n<line218>REGISTER_ARG (dp->precision_arg_index, TYPE_INT);\n<line219>}\n<line220>else\n<line221>{\n<line222>size_t precision_length;\n<line223>dp->precision_start = cp - 1;\n<line224>for (; *cp >= '0' && *cp <= '9'; cp++)\n<line225>;\n<line226>dp->precision_end = cp;\n<line227>precision_length = dp->precision_end - dp->precision_start;\n<line228>if (max_precision_length < precision_length)\n<line229>max_precision_length = precision_length;\n<line230>}\n<line231>}\n<line232>{\n<line233>arg_type type;\n<line234>/* Parse argument type/size specifiers.  */\n<line235>/* Relevant for the conversion characters d, i.  */\n<line236>arg_type signed_type = TYPE_INT;\n<line237>/* Relevant for the conversion characters b, o, u, x, X.  */\n<line238>arg_type unsigned_type = TYPE_UINT;\n<line239>/* Relevant for the conversion characters n.  */\n<line240>arg_type pointer_type = TYPE_COUNT_INT_POINTER;\n<line241>/* Relevant for the conversion characters a, A, e, E, f, F, g, G.  */\n<line242>arg_type floatingpoint_type = TYPE_DOUBLE;\n<line243>if (*cp == 'h')\n<line244>{\n<line245>if (cp[1] == 'h')\n<line246>{\n<line247>signed_type = TYPE_SCHAR;\n<line248>unsigned_type = TYPE_UCHAR;\n<line249>pointer_type = TYPE_COUNT_SCHAR_POINTER;\n<line250>cp += 2;\n<line251>}\n<line252>else\n<line253>{\n<line254>signed_type = TYPE_SHORT;\n<line255>unsigned_type = TYPE_USHORT;\n<line256>pointer_type = TYPE_COUNT_SHORT_POINTER;\n<line257>cp++;\n<line258>}\n<line259>}\n<line260>else if (*cp == 'l')\n<line261>{\n<line262>if (cp[1] == 'l')\n<line263>{\n<line264>signed_type = TYPE_LONGLONGINT;\n<line265>unsigned_type = TYPE_ULONGLONGINT;\n<line266>pointer_type = TYPE_COUNT_LONGLONGINT_POINTER;\n<line267>/* For backward compatibility only.  */\n<line268>floatingpoint_type = TYPE_LONGDOUBLE;\n<line269>cp += 2;\n<line270>}\n<line271>else\n<line272>{\n<line273>signed_type = TYPE_LONGINT;\n<line274>unsigned_type = TYPE_ULONGINT;\n<line275>pointer_type = TYPE_COUNT_LONGINT_POINTER;\n<line276>cp++;\n<line277>}\n<line278>}\n<line279>else if (*cp == 'j')\n<line280>{\n<line281>if (sizeof (intmax_t) > sizeof (long))\n<line282>{\n<line283>/* intmax_t = long long */\n<line284>signed_type = TYPE_LONGLONGINT;\n<line285>unsigned_type = TYPE_ULONGLONGINT;\n<line286>pointer_type = TYPE_COUNT_LONGLONGINT_POINTER;\n<line287>/* For backward compatibility only.  */\n<line288>floatingpoint_type = TYPE_LONGDOUBLE;\n<line289>}\n<line290>else if (sizeof (intmax_t) > sizeof (int))\n<line291>{\n<line292>/* intmax_t = long */\n<line293>signed_type = TYPE_LONGINT;\n<line294>unsigned_type = TYPE_ULONGINT;\n<line295>pointer_type = TYPE_COUNT_LONGINT_POINTER;\n<line296>}\n<line297>cp++;\n<line298>}\n<line299>else if (*cp == 'z' || *cp == 'Z')\n<line300>{\n<line301>/* 'z' is standardized in ISO C 99, but glibc uses 'Z'\n<line302>because the warning facility in gcc-2.95.2 understands\n<line303>only 'Z' (see gcc-2.95.2/gcc/c-common.c:1784).  */\n<line304>if (sizeof (size_t) > sizeof (long))\n<line305>{\n<line306>/* size_t = unsigned long long */\n<line307>signed_type = TYPE_LONGLONGINT;\n<line308>unsigned_type = TYPE_ULONGLONGINT;\n<line309>pointer_type = TYPE_COUNT_LONGLONGINT_POINTER;\n<line310>/* For backward compatibility only.  */\n<line311>floatingpoint_type = TYPE_LONGDOUBLE;\n<line312>}\n<line313>else if (sizeof (size_t) > sizeof (int))\n<line314>{\n<line315>/* size_t = unsigned long */\n<line316>signed_type = TYPE_LONGINT;\n<line317>unsigned_type = TYPE_ULONGINT;\n<line318>pointer_type = TYPE_COUNT_LONGINT_POINTER;\n<line319>}\n<line320>cp++;\n<line321>}\n<line322>else if (*cp == 't')\n<line323>{\n<line324>if (sizeof (ptrdiff_t) > sizeof (long))\n<line325>{\n<line326>/* ptrdiff_t = long long */\n<line327>signed_type = TYPE_LONGLONGINT;\n<line328>unsigned_type = TYPE_ULONGLONGINT;\n<line329>pointer_type = TYPE_COUNT_LONGLONGINT_POINTER;\n<line330>/* For backward compatibility only.  */\n<line331>floatingpoint_type = TYPE_LONGDOUBLE;\n<line332>}\n<line333>else if (sizeof (ptrdiff_t) > sizeof (int))\n<line334>{\n<line335>/* ptrdiff_t = long */\n<line336>signed_type = TYPE_LONGINT;\n<line337>unsigned_type = TYPE_ULONGINT;\n<line338>pointer_type = TYPE_COUNT_LONGINT_POINTER;\n<line339>}\n<line340>cp++;\n<line341>}\n<line342>else if (*cp == 'w')\n<line343>{\n<line344>/* wN and wfN are standardized in ISO C 23.  */\n<line345>if (cp[1] == 'f')\n<line346>{\n<line347>if (cp[2] == '8')\n<line348>{\n<line349>signed_type = TYPE_INT_FAST8_T;\n<line350>unsigned_type = TYPE_UINT_FAST8_T;\n<line351>pointer_type = TYPE_COUNT_INT_FAST8_T_POINTER;\n<line352>cp += 3;\n<line353>}\n<line354>else if (cp[2] == '1' && cp[3] == '6')\n<line355>{\n<line356>signed_type = TYPE_INT_FAST16_T;\n<line357>unsigned_type = TYPE_UINT_FAST16_T;\n<line358>pointer_type = TYPE_COUNT_INT_FAST16_T_POINTER;\n<line359>cp += 4;\n<line360>}\n<line361>else if (cp[2] == '3' && cp[3] == '2')\n<line362>{\n<line363>signed_type = TYPE_INT_FAST32_T;\n<line364>unsigned_type = TYPE_UINT_FAST32_T;\n<line365>pointer_type = TYPE_COUNT_INT_FAST32_T_POINTER;\n<line366>cp += 4;\n<line367>}\n<line368>else if (cp[2] == '6' && cp[3] == '4')\n<line369>{\n<line370>signed_type = TYPE_INT_FAST64_T;\n<line371>unsigned_type = TYPE_UINT_FAST64_T;\n<line372>pointer_type = TYPE_COUNT_INT_FAST64_T_POINTER;\n<line373>cp += 4;\n<line374>}\n<line375>}\n<line376>else\n<line377>{\n<line378>if (cp[1] == '8')\n<line379>{\n<line380>signed_type = TYPE_INT8_T;\n<line381>unsigned_type = TYPE_UINT8_T;\n<line382>pointer_type = TYPE_COUNT_INT8_T_POINTER;\n<line383>cp += 2;\n<line384>}\n<line385>else if (cp[1] == '1' && cp[2] == '6')\n<line386>{\n<line387>signed_type = TYPE_INT16_T;\n<line388>unsigned_type = TYPE_UINT16_T;\n<line389>pointer_type = TYPE_COUNT_INT16_T_POINTER;\n<line390>cp += 3;\n<line391>}\n<line392>else if (cp[1] == '3' && cp[2] == '2')\n<line393>{\n<line394>signed_type = TYPE_INT32_T;\n<line395>unsigned_type = TYPE_UINT32_T;\n<line396>pointer_type = TYPE_COUNT_INT32_T_POINTER;\n<line397>cp += 3;\n<line398>}\n<line399>else if (cp[1] == '6' && cp[2] == '4')\n<line400>{\n<line401>signed_type = TYPE_INT64_T;\n<line402>unsigned_type = TYPE_UINT64_T;\n<line403>pointer_type = TYPE_COUNT_INT64_T_POINTER;\n<line404>cp += 3;\n<line405>}\n<line406>}\n<line407>}\n<line408>else if (*cp == 'L')\n<line409>{\n<line410>signed_type = TYPE_LONGLONGINT;\n<line411>unsigned_type = TYPE_ULONGLONGINT;\n<line412>pointer_type = TYPE_COUNT_LONGLONGINT_POINTER;\n<line413>floatingpoint_type = TYPE_LONGDOUBLE;\n<line414>cp++;\n<line415>}\n<line416>#if defined __APPLE__ && defined __MACH__\n<line417>/* On Mac OS X 10.3, PRIdMAX is defined as "qd".\n<line418>We cannot change it to "lld" because PRIdMAX must also\n<line419>be understood by the system's printf routines.  */\n<line420>else if (*cp == 'q')\n<line421>{\n<line422>if (64 / 8 > sizeof (long))\n<line423>{\n<line424>/* int64_t = long long */\n<line425>signed_type = TYPE_LONGLONGINT;\n<line426>unsigned_type = TYPE_ULONGLONGINT;\n<line427>pointer_type = TYPE_COUNT_LONGLONGINT_POINTER;\n<line428>/* For backward compatibility only.  */\n<line429>floatingpoint_type = TYPE_LONGDOUBLE;\n<line430>}\n<line431>else\n<line432>{\n<line433>/* int64_t = long */\n<line434>signed_type = TYPE_LONGINT;\n<line435>unsigned_type = TYPE_ULONGINT;\n<line436>pointer_type = TYPE_COUNT_LONGINT_POINTER;\n<line437>}\n<line438>cp++;\n<line439>}\n<line440>#endif\n<line441>#if defined _WIN32 && ! defined __CYGWIN__\n<line442>/* On native Windows, PRIdMAX is defined as "I64d".\n<line443>We cannot change it to "lld" because PRIdMAX must also\n<line444>be understood by the system's printf routines.  */\n<line445>else if (*cp == 'I' && cp[1] == '6' && cp[2] == '4')\n<line446>{\n<line447>if (64 / 8 > sizeof (long))\n<line448>{\n<line449>/* __int64_t = long long */\n<line450>signed_type = TYPE_LONGLONGINT;\n<line451>unsigned_type = TYPE_ULONGLONGINT;\n<line452>pointer_type = TYPE_COUNT_LONGLONGINT_POINTER;\n<line453>/* For backward compatibility only.  */\n<line454>floatingpoint_type = TYPE_LONGDOUBLE;\n<line455>}\n<line456>else\n<line457>{\n<line458>/* __int64_t = long */\n<line459>signed_type = TYPE_LONGINT;\n<line460>unsigned_type = TYPE_ULONGINT;\n<line461>pointer_type = TYPE_COUNT_LONGINT_POINTER;\n<line462>}\n<line463>cp++;\n<line464>}\n<line465>#endif\n<line466>/* Read the conversion character.  */\n<line467>c = *cp++;\n<line468>switch (c)\n<line469>{\n<line470>case 'd': case 'i':\n<line471>type = signed_type;\n<line472>break;\n<line473>case 'b': case 'o': case 'u': case 'x': case 'X':\n<line474>#if SUPPORT_GNU_PRINTF_DIRECTIVES \\n<line475>|| (__GLIBC__ + (__GLIBC_MINOR__ >= 35) > 2)\n<line476>case 'B':\n<line477>#endif\n<line478>type = unsigned_type;\n<line479>break;\n<line480>case 'f': case 'F': case 'e': case 'E': case 'g': case 'G':\n<line481>case 'a': case 'A':\n<line482>type = floatingpoint_type;\n<line483>break;\n<line484>case 'c':\n<line485>if (signed_type == TYPE_LONGINT\n<line486>/* For backward compatibility only.  */\n<line487>|| signed_type == TYPE_LONGLONGINT)\n<line488>#if HAVE_WINT_T\n<line489>type = TYPE_WIDE_CHAR;\n<line490>#else\n<line491>goto error;\n<line492>#endif\n<line493>else\n<line494>type = TYPE_CHAR;\n<line495>break;\n<line496>#if HAVE_WINT_T\n<line497>case 'C':\n<line498>type = TYPE_WIDE_CHAR;\n<line499>c = 'c';\n<line500>break;\n<line501>#endif\n<line502>case 's':\n<line503>if (signed_type == TYPE_LONGINT\n<line504>/* For backward compatibility only.  */\n<line505>|| signed_type == TYPE_LONGLONGINT)\n<line506>#if HAVE_WCHAR_T\n<line507>type = TYPE_WIDE_STRING;\n<line508>#else\n<line509>goto error;\n<line510>#endif\n<line511>else\n<line512>type = TYPE_STRING;\n<line513>break;\n<line514>#if HAVE_WCHAR_T\n<line515>case 'S':\n<line516>type = TYPE_WIDE_STRING;\n<line517>c = 's';\n<line518>break;\n<line519>#endif\n<line520>case 'p':\n<line521>type = TYPE_POINTER;\n<line522>break;\n<line523>case 'n':\n<line524>type = pointer_type;\n<line525>break;\n<line526>#if ENABLE_UNISTDIO\n<line527>/* The unistdio extensions.  */\n<line528>case 'U':\n<line529>if (signed_type == TYPE_LONGLONGINT)\n<line530>type = TYPE_U32_STRING;\n<line531>else if (signed_type == TYPE_LONGINT)\n<line532>type = TYPE_U16_STRING;\n<line533>else\n<line534>type = TYPE_U8_STRING;\n<line535>break;\n<line536>#endif\n<line537>case '%':\n<line538>type = TYPE_NONE;\n<line539>break;\n<line540>default:\n<line541>/* Unknown conversion character.  */\n<line542>goto error;\n<line543>}\n<line544>if (type != TYPE_NONE)\n<line545>{\n<line546>dp->arg_index = arg_index;\n<line547>if (dp->arg_index == ARG_NONE)\n<line548>{\n<line549>dp->arg_index = arg_posn++;\n<line550>if (dp->arg_index == ARG_NONE)\n<line551>/* arg_posn wrapped around.  */\n<line552>goto error;\n<line553>}\n<line554>REGISTER_ARG (dp->arg_index, type);\n<line555>}\n<line556>dp->conversion = c;\n<line557>dp->dir_end = cp;\n<line558>}\n<line559>d->count++;\n<line560>if (d->count >= d_allocated)\n<line561>{\n<line562>size_t memory_size;\n<line563>DIRECTIVE *memory;\n<line564>d_allocated = xtimes (d_allocated, 2);\n<line565>memory_size = xtimes (d_allocated, sizeof (DIRECTIVE));\n<line566>if (size_overflow_p (memory_size))\n<line567>/* Overflow, would lead to out of memory.  */\n<line568>goto out_of_memory;\n<line569>memory = (DIRECTIVE *) (d->dir != d->direct_alloc_dir\n<line570>? realloc (d->dir, memory_size)\n<line571>: malloc (memory_size));\n<line572>if (memory == NULL)\n<line573>/* Out of memory.  */\n<line574>goto out_of_memory;\n<line575>if (d->dir == d->direct_alloc_dir)\n<line576>memcpy (memory, d->dir, d->count * sizeof (DIRECTIVE));\n<line577>d->dir = memory;\n<line578>}\n<line579>}\n<line580>#if CHAR_T_ONLY_ASCII\n<line581>else if (!c_isascii (c))\n<line582>{\n<line583>/* Non-ASCII character.  Not supported.  */\n<line584>goto error;\n<line585>}\n<line586>#endif\n<line587>}\n<line588>d->dir[d->count].dir_start = cp;\n<line589>d->max_width_length = max_width_length;\n<line590>d->max_precision_length = max_precision_length;\n<line591>return 0;\n<line592>error:\n<line593>if (a->arg != a->direct_alloc_arg)\n<line594>free (a->arg);\n<line595>if (d->dir != d->direct_alloc_dir)\n<line596>free (d->dir);\n<line597>errno = EINVAL;\n<line598>return -1;\n<line599>out_of_memory:\n<line600>if (a->arg != a->direct_alloc_arg)\n<line601>free (a->arg);\n<line602>if (d->dir != d->direct_alloc_dir)\n<line603>free (d->dir);\n<line604>errno = ENOMEM;\n<line605>return -1;\n<line606>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/vasnprintf.c
========================================
========================================
/home/huihui/Downloads/coreutils-9.4/lib/vasprintf.c
========================================
Function: rpl_vasprintf
Content: <line0>int\n<line1>vasprintf (char **resultp, const char *format, va_list args)\n<line2>{\n<line3>size_t length;\n<line4>char *result = vasnprintf (NULL, &length, format, args);\n<line5>if (result == NULL)\n<line6>return -1;\n<line7>if (length > INT_MAX)\n<line8>{\n<line9>free (result);\n<line10>errno = EOVERFLOW;\n<line11>return -1;\n<line12>}\n<line13>*resultp = result;\n<line14>/* Return the number of resulting bytes, excluding the trailing NUL.  */\n<line15>return length;\n<line16>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/vfprintf.c
========================================
Function: rpl_vfprintf
Content: <line0>int\n<line1>vfprintf (FILE *fp, const char *format, va_list args)\n<line2>{\n<line3>char buf[2000];\n<line4>char *output;\n<line5>size_t len;\n<line6>size_t lenbuf = sizeof (buf);\n<line7>output = vasnprintf (buf, &lenbuf, format, args);\n<line8>len = lenbuf;\n<line9>if (!output)\n<line10>{\n<line11>fseterr (fp);\n<line12>return -1;\n<line13>}\n<line14>if (fwrite (output, 1, len, fp) < len)\n<line15>{\n<line16>if (output != buf)\n<line17>free (output);\n<line18>return -1;\n<line19>}\n<line20>if (output != buf)\n<line21>free (output);\n<line22>if (len > INT_MAX)\n<line23>{\n<line24>errno = EOVERFLOW;\n<line25>fseterr (fp);\n<line26>return -1;\n<line27>}\n<line28>return len;\n<line29>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/lib/vprintf.c
========================================
Function: rpl_vprintf
Content: <line0>int\n<line1>vprintf (const char *format, va_list args)\n<line2>{\n<line3>return vfprintf (stdout, format, args);\n<line4>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/src/hostid.c
========================================
Function: usage
Content: <line0>void\n<line1>usage (int status)\n<line2>{\n<line3>if (status != EXIT_SUCCESS)\n<line4>emit_try_help ();\n<line5>else\n<line6>{\n<line7>printf (_("\\n<line8>Usage: %s [OPTION]\n\\n<line9>Print the numeric identifier (in hexadecimal) for the current host.\n\\n<line10>\n\\n<line11>"), program_name);\n<line12>fputs (HELP_OPTION_DESCRIPTION, stdout);\n<line13>fputs (VERSION_OPTION_DESCRIPTION, stdout);\n<line14>emit_ancillary_info (PROGRAM_NAME);\n<line15>}\n<line16>exit (status);\n<line17>}
----------------------------------------
Function: main
Content: <line0>int\n<line1>main (int argc, char **argv)\n<line2>{\n<line3>unsigned int id;\n<line4>initialize_main (&argc, &argv);\n<line5>set_program_name (argv[0]);\n<line6>setlocale (LC_ALL, "");\n<line7>bindtextdomain (PACKAGE, LOCALEDIR);\n<line8>textdomain (PACKAGE);\n<line9>atexit (close_stdout);\n<line10>parse_gnu_standard_options_only (argc, argv, PROGRAM_NAME, PACKAGE_NAME,\n<line11>Version, true, usage, AUTHORS,\n<line12>(char const *) nullptr);\n<line13>if (optind < argc)\n<line14>{\n<line15>error (0, 0, _("extra operand %s"), quote (argv[optind]));\n<line16>usage (EXIT_FAILURE);\n<line17>}\n<line18>id = gethostid ();\n<line19>/* POSIX says gethostid returns a "32-bit identifier" but is silent\n<line20>whether it's sign-extended.  Turn off any sign-extension.  This\n<line21>is a no-op unless unsigned int is wider than 32 bits.  */\n<line22>id &= 0xffffffff;\n<line23>printf ("%08x\n", id);\n<line24>return EXIT_SUCCESS;\n<line25>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/src/timeout.c
========================================
Function: settimeout
Content: <line0>static void\n<line1>settimeout (double duration, bool warn)\n<line2>{\n<line3>#if HAVE_TIMER_SETTIME\n<line4>/* timer_settime() provides potentially nanosecond resolution.  */\n<line5>struct timespec ts = dtotimespec (duration);\n<line6>struct itimerspec its = { {0, 0}, ts };\n<line7>timer_t timerid;\n<line8>if (timer_create (CLOCK_REALTIME, nullptr, &timerid) == 0)\n<line9>{\n<line10>if (timer_settime (timerid, 0, &its, nullptr) == 0)\n<line11>return;\n<line12>else\n<line13>{\n<line14>if (warn)\n<line15>error (0, errno, _("warning: timer_settime"));\n<line16>timer_delete (timerid);\n<line17>}\n<line18>}\n<line19>else if (warn && errno != ENOSYS)\n<line20>error (0, errno, _("warning: timer_create"));\n<line21>#elif HAVE_SETITIMER\n<line22>/* setitimer() is more portable (to Darwin for example),\n<line23>but only provides microsecond resolution.  */\n<line24>struct timeval tv;\n<line25>struct timespec ts = dtotimespec (duration);\n<line26>tv.tv_sec = ts.tv_sec;\n<line27>tv.tv_usec = (ts.tv_nsec + 999) / 1000;\n<line28>if (tv.tv_usec == 1000 * 1000)\n<line29>{\n<line30>if (tv.tv_sec != TYPE_MAXIMUM (time_t))\n<line31>{\n<line32>tv.tv_sec++;\n<line33>tv.tv_usec = 0;\n<line34>}\n<line35>else\n<line36>tv.tv_usec--;\n<line37>}\n<line38>struct itimerval it = { {0, 0}, tv };\n<line39>if (setitimer (ITIMER_REAL, &it, nullptr) == 0)\n<line40>return;\n<line41>else\n<line42>{\n<line43>if (warn && errno != ENOSYS)\n<line44>error (0, errno, _("warning: setitimer"));\n<line45>}\n<line46>#endif\n<line47>/* fallback to single second resolution provided by alarm().  */\n<line48>unsigned int timeint;\n<line49>if (UINT_MAX <= duration)\n<line50>timeint = UINT_MAX;\n<line51>else\n<line52>{\n<line53>unsigned int duration_floor = duration;\n<line54>timeint = duration_floor + (duration_floor < duration);\n<line55>}\n<line56>alarm (timeint);\n<line57>}
----------------------------------------
Function: send_sig
Content: <line0>static int\n<line1>send_sig (pid_t where, int sig)\n<line2>{\n<line3>/* If sending to the group, then ignore the signal,\n<line4>so we don't go into a signal loop.  Note that this will ignore any of the\n<line5>signals registered in install_cleanup(), that are sent after we\n<line6>propagate the first one, which hopefully won't be an issue.  Note this\n<line7>process can be implicitly multithreaded due to some timer_settime()\n<line8>implementations, therefore a signal sent to the group, can be sent\n<line9>multiple times to this process.  */\n<line10>if (where == 0)\n<line11>signal (sig, SIG_IGN);\n<line12>return kill (where, sig);\n<line13>}
----------------------------------------
Function: chld
Content: <line0>static void\n<line1>chld (int sig)\n<line2>{\n<line3>}
----------------------------------------
Function: cleanup
Content: <line0>static void\n<line1>cleanup (int sig)\n<line2>{\n<line3>if (sig == SIGALRM)\n<line4>{\n<line5>timed_out = 1;\n<line6>sig = term_signal;\n<line7>}\n<line8>if (monitored_pid)\n<line9>{\n<line10>if (kill_after)\n<line11>{\n<line12>int saved_errno = errno; /* settimeout may reset.  */\n<line13>/* Start a new timeout after which we'll send SIGKILL.  */\n<line14>term_signal = SIGKILL;\n<line15>settimeout (kill_after, false);\n<line16>kill_after = 0; /* Don't let later signals reset kill alarm.  */\n<line17>errno = saved_errno;\n<line18>}\n<line19>/* Send the signal directly to the monitored child,\n<line20>in case it has itself become group leader,\n<line21>or is not running in a separate group.  */\n<line22>if (verbose)\n<line23>{\n<line24>char signame[MAX (SIG2STR_MAX, INT_BUFSIZE_BOUND (int))];\n<line25>if (sig2str (sig, signame) != 0)\n<line26>snprintf (signame, sizeof signame, "%d", sig);\n<line27>error (0, 0, _("sending signal %s to command %s"),\n<line28>signame, quote (command));\n<line29>}\n<line30>send_sig (monitored_pid, sig);\n<line31>/* The normal case is the job has remained in our\n<line32>newly created process group, so send to all processes in that.  */\n<line33>if (!foreground)\n<line34>{\n<line35>send_sig (0, sig);\n<line36>if (sig != SIGKILL && sig != SIGCONT)\n<line37>{\n<line38>send_sig (monitored_pid, SIGCONT);\n<line39>send_sig (0, SIGCONT);\n<line40>}\n<line41>}\n<line42>}\n<line43>else /* we're the child or the child is not exec'd yet.  */\n<line44>_exit (128 + sig);\n<line45>}
----------------------------------------
Function: usage
Content: <line0>void\n<line1>usage (int status)\n<line2>{\n<line3>if (status != EXIT_SUCCESS)\n<line4>emit_try_help ();\n<line5>else\n<line6>{\n<line7>printf (_("\\n<line8>Usage: %s [OPTION] DURATION COMMAND [ARG]...\n\\n<line9>or:  %s [OPTION]\n"), program_name, program_name);\n<line10>fputs (_("\\n<line11>Start COMMAND, and kill it if still running after DURATION.\n\\n<line12>"), stdout);\n<line13>emit_mandatory_arg_note ();\n<line14>fputs (_("\\n<line15>--preserve-status\n\\n<line16>exit with the same status as COMMAND, even when the\n\\n<line17>command times out\n\\n<line18>--foreground\n\\n<line19>when not running timeout directly from a shell prompt,\n\\n<line20>allow COMMAND to read from the TTY and get TTY signals;\n\\n<line21>in this mode, children of COMMAND will not be timed out\n\\n<line22>-k, --kill-after=DURATION\n\\n<line23>also send a KILL signal if COMMAND is still running\n\\n<line24>this long after the initial signal was sent\n\\n<line25>-s, --signal=SIGNAL\n\\n<line26>specify the signal to be sent on timeout;\n\\n<line27>SIGNAL may be a name like 'HUP' or a number;\n\\n<line28>see 'kill -l' for a list of signals\n"), stdout);\n<line29>fputs (_("\\n<line30>-v, --verbose  diagnose to stderr any signal sent upon timeout\n"), stdout);\n<line31>fputs (HELP_OPTION_DESCRIPTION, stdout);\n<line32>fputs (VERSION_OPTION_DESCRIPTION, stdout);\n<line33>fputs (_("\n\\n<line34>DURATION is a floating point number with an optional suffix:\n\\n<line35>'s' for seconds (the default), 'm' for minutes, 'h' for hours or \\n<line36>'d' for days.\nA duration of 0 disables the associated timeout.\n"), stdout);\n<line37>fputs (_("\n\\n<line38>Upon timeout, send the TERM signal to COMMAND, if no other SIGNAL specified.\n\\n<line39>The TERM signal kills any process that does not block or catch that signal.\n\\n<line40>It may be necessary to use the KILL signal, since this signal can't be caught.\\n<line41>\n"), stdout);\n<line42>fputs (_("\n\\n<line43>Exit status:\n\\n<line44>124  if COMMAND times out, and --preserve-status is not specified\n\\n<line45>125  if the timeout command itself fails\n\\n<line46>126  if COMMAND is found but cannot be invoked\n\\n<line47>127  if COMMAND cannot be found\n\\n<line48>137  if COMMAND (or timeout itself) is sent the KILL (9) signal (128+9)\n\\n<line49>-    the exit status of COMMAND otherwise\n\\n<line50>"), stdout);\n<line51>emit_ancillary_info (PROGRAM_NAME);\n<line52>}\n<line53>exit (status);\n<line54>}
----------------------------------------
Function: apply_time_suffix
Content: <line0>static bool\n<line1>apply_time_suffix (double *x, char suffix_char)\n<line2>{\n<line3>int multiplier;\n<line4>switch (suffix_char)\n<line5>{\n<line6>case 0:\n<line7>case 's':\n<line8>multiplier = 1;\n<line9>break;\n<line10>case 'm':\n<line11>multiplier = 60;\n<line12>break;\n<line13>case 'h':\n<line14>multiplier = 60 * 60;\n<line15>break;\n<line16>case 'd':\n<line17>multiplier = 60 * 60 * 24;\n<line18>break;\n<line19>default:\n<line20>return false;\n<line21>}\n<line22>*x *= multiplier;\n<line23>return true;\n<line24>}
----------------------------------------
Function: parse_duration
Content: <line0>static double\n<line1>parse_duration (char const *str)\n<line2>{\n<line3>double duration;\n<line4>char const *ep;\n<line5>if (! (xstrtod (str, &ep, &duration, cl_strtod) || errno == ERANGE)\n<line6>/* Nonnegative interval.  */\n<line7>|| ! (0 <= duration)\n<line8>/* No extra chars after the number and an optional s,m,h,d char.  */\n<line9>|| (*ep && *(ep + 1))\n<line10>/* Check any suffix char and update timeout based on the suffix.  */\n<line11>|| !apply_time_suffix (&duration, *ep))\n<line12>{\n<line13>error (0, 0, _("invalid time interval %s"), quote (str));\n<line14>usage (EXIT_CANCELED);\n<line15>}\n<line16>return duration;\n<line17>}
----------------------------------------
Function: unblock_signal
Content: <line0>static void\n<line1>unblock_signal (int sig)\n<line2>{\n<line3>sigset_t unblock_set;\n<line4>sigemptyset (&unblock_set);\n<line5>sigaddset (&unblock_set, sig);\n<line6>if (sigprocmask (SIG_UNBLOCK, &unblock_set, nullptr) != 0)\n<line7>error (0, errno, _("warning: sigprocmask"));\n<line8>}
----------------------------------------
Function: install_sigchld
Content: <line0>static void\n<line1>install_sigchld (void)\n<line2>{\n<line3>struct sigaction sa;\n<line4>sigemptyset (&sa.sa_mask);  /* Allow concurrent calls to handler */\n<line5>sa.sa_handler = chld;\n<line6>sa.sa_flags = SA_RESTART;   /* Restart syscalls if possible, as that's\n<line7>more likely to work cleanly.  */\n<line8>sigaction (SIGCHLD, &sa, nullptr);\n<line9>/* We inherit the signal mask from our parent process,\n<line10>so ensure SIGCHLD is not blocked. */\n<line11>unblock_signal (SIGCHLD);\n<line12>}
----------------------------------------
Function: install_cleanup
Content: <line0>static void\n<line1>install_cleanup (int sigterm)\n<line2>{\n<line3>struct sigaction sa;\n<line4>sigemptyset (&sa.sa_mask);  /* Allow concurrent calls to handler */\n<line5>sa.sa_handler = cleanup;\n<line6>sa.sa_flags = SA_RESTART;   /* Restart syscalls if possible, as that's\n<line7>more likely to work cleanly.  */\n<line8>sigaction (SIGALRM, &sa, nullptr); /* our timeout.  */\n<line9>sigaction (SIGINT, &sa, nullptr);  /* Ctrl-C at terminal for example.  */\n<line10>sigaction (SIGQUIT, &sa, nullptr); /* Ctrl-\ at terminal for example.  */\n<line11>sigaction (SIGHUP, &sa, nullptr);  /* terminal closed for example.  */\n<line12>sigaction (SIGTERM, &sa, nullptr); /* if killed, stop monitored proc.  */\n<line13>sigaction (sigterm, &sa, nullptr); /* user specified termination signal.  */\n<line14>}
----------------------------------------
Function: block_cleanup_and_chld
Content: <line0>static void\n<line1>block_cleanup_and_chld (int sigterm, sigset_t *old_set)\n<line2>{\n<line3>sigset_t block_set;\n<line4>sigemptyset (&block_set);\n<line5>sigaddset (&block_set, SIGALRM);\n<line6>sigaddset (&block_set, SIGINT);\n<line7>sigaddset (&block_set, SIGQUIT);\n<line8>sigaddset (&block_set, SIGHUP);\n<line9>sigaddset (&block_set, SIGTERM);\n<line10>sigaddset (&block_set, sigterm);\n<line11>sigaddset (&block_set, SIGCHLD);\n<line12>if (sigprocmask (SIG_BLOCK, &block_set, old_set) != 0)\n<line13>error (0, errno, _("warning: sigprocmask"));\n<line14>}
----------------------------------------
Function: disable_core_dumps
Content: <line0>static bool\n<line1>disable_core_dumps (void)\n<line2>{\n<line3>#if HAVE_PRCTL && defined PR_SET_DUMPABLE\n<line4>if (prctl (PR_SET_DUMPABLE, 0) == 0)\n<line5>return true;\n<line6>#elif HAVE_SETRLIMIT && defined RLIMIT_CORE\n<line7>/* Note this doesn't disable processing by a filter in\n<line8>/proc/sys/kernel/core_pattern on Linux.  */\n<line9>if (setrlimit (RLIMIT_CORE, &(struct rlimit) {0,0}) == 0)\n<line10>return true;\n<line11>#else\n<line12>return false;\n<line13>#endif\n<line14>error (0, errno, _("warning: disabling core dumps failed"));\n<line15>return false;\n<line16>}
----------------------------------------
Function: main
Content: <line0>int\n<line1>main (int argc, char **argv)\n<line2>{\n<line3>double timeout;\n<line4>char signame[SIG2STR_MAX];\n<line5>int c;\n<line6>initialize_main (&argc, &argv);\n<line7>set_program_name (argv[0]);\n<line8>setlocale (LC_ALL, "");\n<line9>bindtextdomain (PACKAGE, LOCALEDIR);\n<line10>textdomain (PACKAGE);\n<line11>initialize_exit_failure (EXIT_CANCELED);\n<line12>atexit (close_stdout);\n<line13>while ((c = getopt_long (argc, argv, "+k:s:v", long_options, nullptr)) != -1)\n<line14>{\n<line15>switch (c)\n<line16>{\n<line17>case 'k':\n<line18>kill_after = parse_duration (optarg);\n<line19>break;\n<line20>case 's':\n<line21>term_signal = operand2sig (optarg, signame);\n<line22>if (term_signal == -1)\n<line23>usage (EXIT_CANCELED);\n<line24>break;\n<line25>case 'v':\n<line26>verbose = true;\n<line27>break;\n<line28>case FOREGROUND_OPTION:\n<line29>foreground = true;\n<line30>break;\n<line31>case PRESERVE_STATUS_OPTION:\n<line32>preserve_status = true;\n<line33>break;\n<line34>case_GETOPT_HELP_CHAR;\n<line35>case_GETOPT_VERSION_CHAR (PROGRAM_NAME, AUTHORS);\n<line36>default:\n<line37>usage (EXIT_CANCELED);\n<line38>break;\n<line39>}\n<line40>}\n<line41>if (argc - optind < 2)\n<line42>usage (EXIT_CANCELED);\n<line43>timeout = parse_duration (argv[optind++]);\n<line44>argv += optind;\n<line45>command = argv[0];\n<line46>/* Ensure we're in our own group so all subprocesses can be killed.\n<line47>Note we don't just put the child in a separate group as\n<line48>then we would need to worry about foreground and background groups\n<line49>and propagating signals between them.  */\n<line50>if (!foreground)\n<line51>setpgid (0, 0);\n<line52>/* Setup handlers before fork() so that we\n<line53>handle any signals caused by child, without races.  */\n<line54>install_cleanup (term_signal);\n<line55>signal (SIGTTIN, SIG_IGN);   /* Don't stop if background child needs tty.  */\n<line56>signal (SIGTTOU, SIG_IGN);   /* Don't stop if background child needs tty.  */\n<line57>install_sigchld ();          /* Interrupt sigsuspend() when child exits.   */\n<line58>monitored_pid = fork ();\n<line59>if (monitored_pid == -1)\n<line60>{\n<line61>error (0, errno, _("fork system call failed"));\n<line62>return EXIT_CANCELED;\n<line63>}\n<line64>else if (monitored_pid == 0)\n<line65>{                           /* child */\n<line66>/* exec doesn't reset SIG_IGN -> SIG_DFL.  */\n<line67>signal (SIGTTIN, SIG_DFL);\n<line68>signal (SIGTTOU, SIG_DFL);\n<line69>execvp (argv[0], argv);\n<line70>/* exit like sh, env, nohup, ...  */\n<line71>int exit_status = errno == ENOENT ? EXIT_ENOENT : EXIT_CANNOT_INVOKE;\n<line72>error (0, errno, _("failed to run command %s"), quote (command));\n<line73>return exit_status;\n<line74>}\n<line75>else\n<line76>{\n<line77>pid_t wait_result;\n<line78>int status;\n<line79>/* We configure timers so that SIGALRM is sent on expiry.\n<line80>Therefore ensure we don't inherit a mask blocking SIGALRM.  */\n<line81>unblock_signal (SIGALRM);\n<line82>settimeout (timeout, true);\n<line83>/* Ensure we don't cleanup() after waitpid() reaps the child,\n<line84>to avoid sending signals to a possibly different process.  */\n<line85>sigset_t cleanup_set;\n<line86>block_cleanup_and_chld (term_signal, &cleanup_set);\n<line87>while ((wait_result = waitpid (monitored_pid, &status, WNOHANG)) == 0)\n<line88>sigsuspend (&cleanup_set);  /* Wait with cleanup signals unblocked.  */\n<line89>if (wait_result < 0)\n<line90>{\n<line91>/* shouldn't happen.  */\n<line92>error (0, errno, _("error waiting for command"));\n<line93>status = EXIT_CANCELED;\n<line94>}\n<line95>else\n<line96>{\n<line97>if (WIFEXITED (status))\n<line98>status = WEXITSTATUS (status);\n<line99>else if (WIFSIGNALED (status))\n<line100>{\n<line101>int sig = WTERMSIG (status);\n<line102>if (WCOREDUMP (status))\n<line103>error (0, 0, _("the monitored command dumped core"));\n<line104>if (!timed_out && disable_core_dumps ())\n<line105>{\n<line106>/* exit with the signal flag set.  */\n<line107>signal (sig, SIG_DFL);\n<line108>unblock_signal (sig);\n<line109>raise (sig);\n<line110>}\n<line111>/* Allow users to distinguish if command was forcibly killed.\n<line112>Needed with --foreground where we don't send SIGKILL to\n<line113>the timeout process itself.  */\n<line114>if (timed_out && sig == SIGKILL)\n<line115>preserve_status = true;\n<line116>status = sig + 128; /* what sh returns for signaled processes.  */\n<line117>}\n<line118>else\n<line119>{\n<line120>/* shouldn't happen.  */\n<line121>error (0, 0, _("unknown status from command (%d)"), status);\n<line122>status = EXIT_FAILURE;\n<line123>}\n<line124>}\n<line125>if (timed_out && !preserve_status)\n<line126>status = EXIT_TIMEDOUT;\n<line127>return status;\n<line128>}\n<line129>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/src/operand2sig.c
========================================
Function: operand2sig
Content: <line0>extern int\n<line1>operand2sig (char const *operand, char *signame)\n<line2>{\n<line3>int signum;\n<line4>if (ISDIGIT (*operand))\n<line5>{\n<line6>/* Note we don't put a limit on the maximum value passed,\n<line7>because we're checking shell $? values here, and ksh for\n<line8>example will add 256 to the signal value, thus being wider\n<line9>than the number of WEXITSTATUS bits.\n<line10>We could validate that values were not above say\n<line11>((WEXITSTATUS (~0) << 1) + 1), which would cater for ksh.\n<line12>But some shells may use other adjustments in future to be\n<line13>(forward) compatible with systems that support\n<line14>wider exit status values as discussed at\n<line15>https://austingroupbugs.net/view.php?id=947  */\n<line16>char *endp;\n<line17>long int l = (errno = 0, strtol (operand, &endp, 10));\n<line18>int i = l;\n<line19>signum = (operand == endp || *endp || errno || i != l ? -1 : i);\n<line20>if (signum != -1)\n<line21>{\n<line22>/* Note AIX uses a different bit pattern for status returned\n<line23>from shell and wait(), so we can't use WTERMSIG etc. here.\n<line24>Also ksh returns 0xFF + signal number.  */\n<line25>signum &= signum >= 0xFF ? 0xFF : 0x7F;\n<line26>}\n<line27>}\n<line28>else\n<line29>{\n<line30>/* Convert signal to upper case in the C locale, not in the\n<line31>current locale.  Don't assume ASCII; it might be EBCDIC.  */\n<line32>char *upcased = xstrdup (operand);\n<line33>char *p;\n<line34>for (p = upcased; *p; p++)\n<line35>if (strchr ("abcdefghijklmnopqrstuvwxyz", *p))\n<line36>*p += 'A' - 'a';\n<line37>/* Look for the signal name, possibly prefixed by "SIG",\n<line38>and possibly lowercased.  */\n<line39>if (!(str2sig (upcased, &signum) == 0\n<line40>|| (upcased[0] == 'S' && upcased[1] == 'I' && upcased[2] == 'G'\n<line41>&& str2sig (upcased + 3, &signum) == 0)))\n<line42>signum = -1;\n<line43>free (upcased);\n<line44>}\n<line45>if (signum < 0 || sig2str (signum, signame) != 0)\n<line46>{\n<line47>error (0, 0, _("%s: invalid signal"), quote (operand));\n<line48>return -1;\n<line49>}\n<line50>return signum;\n<line51>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/src/nice.c
========================================
Function: usage
Content: <line0>void\n<line1>usage (int status)\n<line2>{\n<line3>if (status != EXIT_SUCCESS)\n<line4>emit_try_help ();\n<line5>else\n<line6>{\n<line7>printf (_("Usage: %s [OPTION] [COMMAND [ARG]...]\n"), program_name);\n<line8>printf (_("\\n<line9>Run COMMAND with an adjusted niceness, which affects process scheduling.\n\\n<line10>With no COMMAND, print the current niceness.  Niceness values range from\n\\n<line11>%d (most favorable to the process) to %d (least favorable to the process).\n\\n<line12>"),\n<line13>- NZERO, NZERO - 1);\n<line14>emit_mandatory_arg_note ();\n<line15>fputs (_("\\n<line16>-n, --adjustment=N   add integer N to the niceness (default 10)\n\\n<line17>"), stdout);\n<line18>fputs (HELP_OPTION_DESCRIPTION, stdout);\n<line19>fputs (VERSION_OPTION_DESCRIPTION, stdout);\n<line20>printf (USAGE_BUILTIN_WARNING, PROGRAM_NAME);\n<line21>emit_exec_status (PROGRAM_NAME);\n<line22>emit_ancillary_info (PROGRAM_NAME);\n<line23>}\n<line24>exit (status);\n<line25>}
----------------------------------------
Function: perm_related_errno
Content: <line0>static bool\n<line1>perm_related_errno (int err)\n<line2>{\n<line3>return err == EACCES || err == EPERM;\n<line4>}
----------------------------------------
Function: main
Content: <line0>int\n<line1>main (int argc, char **argv)\n<line2>{\n<line3>int current_niceness;\n<line4>int adjustment = 10;\n<line5>char const *adjustment_given = nullptr;\n<line6>bool ok;\n<line7>int i;\n<line8>initialize_main (&argc, &argv);\n<line9>set_program_name (argv[0]);\n<line10>setlocale (LC_ALL, "");\n<line11>bindtextdomain (PACKAGE, LOCALEDIR);\n<line12>textdomain (PACKAGE);\n<line13>initialize_exit_failure (EXIT_CANCELED);\n<line14>atexit (close_stdout);\n<line15>for (i = 1; i < argc; /* empty */)\n<line16>{\n<line17>char const *s = argv[i];\n<line18>if (s[0] == '-' && ISDIGIT (s[1 + (s[1] == '-' || s[1] == '+')]))\n<line19>{\n<line20>adjustment_given = s + 1;\n<line21>++i;\n<line22>}\n<line23>else\n<line24>{\n<line25>int c;\n<line26>int fake_argc = argc - (i - 1);\n<line27>char **fake_argv = argv + (i - 1);\n<line28>/* Ensure that any getopt diagnostics use the right name.  */\n<line29>fake_argv[0] = argv[0];\n<line30>/* Initialize getopt_long's internal state.  */\n<line31>optind = 0;\n<line32>c = getopt_long (fake_argc, fake_argv, "+n:", longopts, nullptr);\n<line33>i += optind - 1;\n<line34>switch (c)\n<line35>{\n<line36>case 'n':\n<line37>adjustment_given = optarg;\n<line38>break;\n<line39>case -1:\n<line40>break;\n<line41>case_GETOPT_HELP_CHAR;\n<line42>case_GETOPT_VERSION_CHAR (PROGRAM_NAME, AUTHORS);\n<line43>default:\n<line44>usage (EXIT_CANCELED);\n<line45>break;\n<line46>}\n<line47>if (c == -1)\n<line48>break;\n<line49>}\n<line50>}\n<line51>if (adjustment_given)\n<line52>{\n<line53>/* If the requested adjustment is outside the valid range,\n<line54>silently bring it to just within range; this mimics what\n<line55>"setpriority" and "nice" do.  */\n<line56>enum { MIN_ADJUSTMENT = 1 - 2 * NZERO, MAX_ADJUSTMENT = 2 * NZERO - 1 };\n<line57>long int tmp;\n<line58>if (LONGINT_OVERFLOW < xstrtol (adjustment_given, nullptr, 10, &tmp, ""))\n<line59>error (EXIT_CANCELED, 0, _("invalid adjustment %s"),\n<line60>quote (adjustment_given));\n<line61>adjustment = MAX (MIN_ADJUSTMENT, MIN (tmp, MAX_ADJUSTMENT));\n<line62>}\n<line63>if (i == argc)\n<line64>{\n<line65>if (adjustment_given)\n<line66>{\n<line67>error (0, 0, _("a command must be given with an adjustment"));\n<line68>usage (EXIT_CANCELED);\n<line69>}\n<line70>/* No command given; print the niceness.  */\n<line71>errno = 0;\n<line72>current_niceness = GET_NICENESS ();\n<line73>if (current_niceness == -1 && errno != 0)\n<line74>error (EXIT_CANCELED, errno, _("cannot get niceness"));\n<line75>printf ("%d\n", current_niceness);\n<line76>return EXIT_SUCCESS;\n<line77>}\n<line78>errno = 0;\n<line79>#if HAVE_NICE\n<line80>ok = (nice (adjustment) != -1 || errno == 0);\n<line81>#else\n<line82>current_niceness = GET_NICENESS ();\n<line83>if (current_niceness == -1 && errno != 0)\n<line84>error (EXIT_CANCELED, errno, _("cannot get niceness"));\n<line85>ok = (setpriority (PRIO_PROCESS, 0, current_niceness + adjustment) == 0);\n<line86>#endif\n<line87>if (!ok)\n<line88>{\n<line89>error (perm_related_errno (errno) ? 0\n<line90>: EXIT_CANCELED, errno, _("cannot set niceness"));\n<line91>/* error() flushes stderr, but does not check for write failure.\n<line92>Normally, we would catch this via our atexit() hook of\n<line93>close_stdout, but execvp() gets in the way.  If stderr\n<line94>encountered a write failure, there is no need to try calling\n<line95>error() again.  */\n<line96>if (ferror (stderr))\n<line97>return EXIT_CANCELED;\n<line98>}\n<line99>execvp (argv[i], &argv[i]);\n<line100>int exit_status = errno == ENOENT ? EXIT_ENOENT : EXIT_CANNOT_INVOKE;\n<line101>error (0, errno, "%s", quote (argv[i]));\n<line102>return exit_status;\n<line103>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/src/who.c
========================================
Function: idle_string
Content: <line0>static char const *\n<line1>idle_string (time_t when, time_t boottime)\n<line2>{\n<line3>static time_t now = TYPE_MINIMUM (time_t);\n<line4>if (now == TYPE_MINIMUM (time_t))\n<line5>time (&now);\n<line6>int seconds_idle;\n<line7>if (boottime < when && when <= now\n<line8>&& ! ckd_sub (&seconds_idle, now, when)\n<line9>&& seconds_idle < 24 * 60 * 60)\n<line10>{\n<line11>if (seconds_idle < 60)\n<line12>return "  .  ";\n<line13>else\n<line14>{\n<line15>static char idle_hhmm[IDLESTR_LEN];\n<line16>sprintf (idle_hhmm, "%02d:%02d",\n<line17>seconds_idle / (60 * 60),\n<line18>(seconds_idle % (60 * 60)) / 60);\n<line19>return idle_hhmm;\n<line20>}\n<line21>}\n<line22>return _(" old ");\n<line23>}
----------------------------------------
Function: time_string
Content: <line0>static char const *\n<line1>time_string (struct gl_utmp const *utmp_ent)\n<line2>{\n<line3>static char buf[INT_STRLEN_BOUND (intmax_t) + sizeof "-%m-%d %H:%M"];\n<line4>struct tm *tmp = localtime (&utmp_ent->ut_ts.tv_sec);\n<line5>if (tmp)\n<line6>{\n<line7>strftime (buf, sizeof buf, time_format, tmp);\n<line8>return buf;\n<line9>}\n<line10>else\n<line11>return timetostr (utmp_ent->ut_ts.tv_sec, buf);\n<line12>}
----------------------------------------
Function: print_line
Content: <line0>static void\n<line1>print_line (char const *user, const char state,\n<line2>char const *line,\n<line3>char const *time_str, char const *idle, char const *pid,\n<line4>char const *comment, char const *exitstr)\n<line5>{\n<line6>static char mesg[3] = { ' ', 'x', '\0' };\n<line7>char *buf;\n<line8>char x_idle[1 + IDLESTR_LEN + 1];\n<line9>char x_pid[1 + INT_STRLEN_BOUND (pid_t) + 1];\n<line10>char *x_exitstr;\n<line11>int err;\n<line12>mesg[1] = state;\n<line13>if (include_idle && !short_output && strlen (idle) < sizeof x_idle - 1)\n<line14>sprintf (x_idle, " %-6s", idle);\n<line15>else\n<line16>*x_idle = '\0';\n<line17>if (!short_output && strlen (pid) < sizeof x_pid - 1)\n<line18>sprintf (x_pid, " %10s", pid);\n<line19>else\n<line20>*x_pid = '\0';\n<line21>x_exitstr = xmalloc (include_exit ? 1 + MAX (12, strlen (exitstr)) + 1 : 1);\n<line22>if (include_exit)\n<line23>sprintf (x_exitstr, " %-12s", exitstr);\n<line24>else\n<line25>*x_exitstr = '\0';\n<line26>err = asprintf (&buf,\n<line27>"%-8s"\n<line28>"%s"\n<line29>" %-12s"\n<line30>" %-*s"\n<line31>"%s"\n<line32>"%s"\n<line33>" %-8s"\n<line34>"%s"\n<line35>,\n<line36>user ? user : "   .",\n<line37>include_mesg ? mesg : "",\n<line38>line,\n<line39>time_format_width,\n<line40>time_str,\n<line41>x_idle,\n<line42>x_pid,\n<line43>/* FIXME: it's not really clear whether the following\n<line44>field should be in the short_output.  A strict reading\n<line45>of SUSv2 would suggest not, but I haven't seen any\n<line46>implementations that actually work that way... */\n<line47>comment,\n<line48>x_exitstr\n<line49>);\n<line50>if (err == -1)\n<line51>xalloc_die ();\n<line52>{\n<line53>/* Remove any trailing spaces.  */\n<line54>char *p = buf + strlen (buf);\n<line55>while (*--p == ' ')\n<line56>/* empty */;\n<line57>*(p + 1) = '\0';\n<line58>}\n<line59>puts (buf);\n<line60>free (buf);\n<line61>free (x_exitstr);\n<line62>}
----------------------------------------
Function: is_tty_writable
Content: <line0>static bool\n<line1>is_tty_writable (struct stat const *pstat)\n<line2>{\n<line3>#ifdef TTY_GROUP_NAME\n<line4>/* Ensure the group of the TTY device matches TTY_GROUP_NAME, more info at\n<line5>https://bugzilla.redhat.com/454261 */\n<line6>struct group *ttygr = getgrnam (TTY_GROUP_NAME);\n<line7>if (!ttygr || (pstat->st_gid != ttygr->gr_gid))\n<line8>return false;\n<line9>#endif\n<line10>return pstat->st_mode & S_IWGRP;\n<line11>}
----------------------------------------
Function: print_user
Content: <line0>static void\n<line1>print_user (struct gl_utmp const *utmp_ent, time_t boottime)\n<line2>{\n<line3>struct stat stats;\n<line4>time_t last_change;\n<line5>char mesg;\n<line6>char idlestr[IDLESTR_LEN + 1];\n<line7>PIDSTR_DECL_AND_INIT (pidstr, utmp_ent);\n<line8>static char *hoststr;\n<line9>#if HAVE_STRUCT_XTMP_UT_HOST\n<line10>static idx_t hostlen;\n<line11>#endif\n<line12>/* If ut_line contains a space, the device name starts after the space.  */\n<line13>char *line = utmp_ent->ut_line;\n<line14>char *space = strchr (line, ' ');\n<line15>line = space ? space + 1 : line;\n<line16>int dirfd;\n<line17>if (IS_ABSOLUTE_FILE_NAME (line))\n<line18>dirfd = AT_FDCWD;\n<line19>else\n<line20>{\n<line21>static int dev_dirfd;\n<line22>if (!dev_dirfd)\n<line23>{\n<line24>dev_dirfd = open ("/dev", O_PATHSEARCH | O_DIRECTORY);\n<line25>if (dev_dirfd < 0)\n<line26>dev_dirfd = AT_FDCWD - 1;\n<line27>}\n<line28>dirfd = dev_dirfd;\n<line29>}\n<line30>if (AT_FDCWD <= dirfd && fstatat (dirfd, line, &stats, 0) == 0)\n<line31>{\n<line32>mesg = is_tty_writable (&stats) ? '+' : '-';\n<line33>last_change = stats.st_atime;\n<line34>}\n<line35>else\n<line36>{\n<line37>mesg = '?';\n<line38>last_change = 0;\n<line39>}\n<line40>if (last_change)\n<line41>sprintf (idlestr, "%.*s", IDLESTR_LEN, idle_string (last_change, boottime));\n<line42>else\n<line43>sprintf (idlestr, "  ?");\n<line44>#if HAVE_STRUCT_XTMP_UT_HOST\n<line45>if (utmp_ent->ut_host[0])\n<line46>{\n<line47>char *host = nullptr;\n<line48>char *display = nullptr;\n<line49>char *ut_host = utmp_ent->ut_host;\n<line50>/* Look for an X display.  */\n<line51>display = strchr (ut_host, ':');\n<line52>if (display)\n<line53>*display++ = '\0';\n<line54>if (*ut_host && do_lookup)\n<line55>{\n<line56>/* See if we can canonicalize it.  */\n<line57>host = canon_host (ut_host);\n<line58>}\n<line59>if (! host)\n<line60>host = ut_host;\n<line61>if (display)\n<line62>{\n<line63>idx_t needed = strlen (host) + strlen (display) + 4;\n<line64>if (hostlen < needed)\n<line65>{\n<line66>free (hoststr);\n<line67>hoststr = xpalloc (nullptr, &hostlen, needed - hostlen, -1, 1);\n<line68>}\n<line69>char *p = hoststr;\n<line70>*p++ = '(';\n<line71>p = stpcpy (p, host);\n<line72>*p++ = ':';\n<line73>strcpy (stpcpy (p, display), ")");\n<line74>}\n<line75>else\n<line76>{\n<line77>idx_t needed = strlen (host) + 3;\n<line78>if (hostlen < needed)\n<line79>{\n<line80>free (hoststr);\n<line81>hoststr = xpalloc (nullptr, &hostlen, needed - hostlen, -1, 1);\n<line82>}\n<line83>char *p = hoststr;\n<line84>*p++ = '(';\n<line85>strcpy (stpcpy (p, host), ")");\n<line86>}\n<line87>if (host != ut_host)\n<line88>free (host);\n<line89>}\n<line90>else\n<line91>{\n<line92>if (hostlen < 1)\n<line93>hoststr = xpalloc (hoststr, &hostlen, 1, -1, 1);\n<line94>*hoststr = '\0';\n<line95>}\n<line96>#endif\n<line97>print_line (utmp_ent->ut_user, mesg,\n<line98>utmp_ent->ut_line,\n<line99>time_string (utmp_ent), idlestr, pidstr,\n<line100>hoststr ? hoststr : "", "");\n<line101>}
----------------------------------------
Function: print_boottime
Content: <line0>static void\n<line1>print_boottime (struct gl_utmp const *utmp_ent)\n<line2>{\n<line3>print_line ("", ' ', _("system boot"),\n<line4>time_string (utmp_ent), "", "", "", "");\n<line5>}
----------------------------------------
Function: make_id_equals_comment
Content: <line0>static char *\n<line1>make_id_equals_comment (struct gl_utmp const *utmp_ent)\n<line2>{\n<line3>char const *id = UT_ID (utmp_ent);\n<line4>idx_t idlen = strlen (id);\n<line5>char const *prefix = _("id=");\n<line6>idx_t prefixlen = strlen (prefix);\n<line7>char *comment = xmalloc (prefixlen + idlen + 1);\n<line8>char *p = mempcpy (comment, prefix, prefixlen);\n<line9>p = mempcpy (p, id, idlen);\n<line10>*p = '\0';\n<line11>return comment;\n<line12>}
----------------------------------------
Function: print_deadprocs
Content: <line0>static void\n<line1>print_deadprocs (struct gl_utmp const *utmp_ent)\n<line2>{\n<line3>static char *exitstr;\n<line4>char *comment = make_id_equals_comment (utmp_ent);\n<line5>PIDSTR_DECL_AND_INIT (pidstr, utmp_ent);\n<line6>if (!exitstr)\n<line7>exitstr = xmalloc (strlen (_("term="))\n<line8>+ INT_STRLEN_BOUND (utmp_ent->ut_exit.e_termination) + 1\n<line9>+ strlen (_("exit="))\n<line10>+ INT_STRLEN_BOUND (utmp_ent->ut_exit.e_exit)\n<line11>+ 1);\n<line12>sprintf (exitstr, "%s%d %s%d", _("term="), utmp_ent->ut_exit.e_termination,\n<line13>_("exit="), utmp_ent->ut_exit.e_exit);\n<line14>/* FIXME: add idle time? */\n<line15>print_line ("", ' ', utmp_ent->ut_line,\n<line16>time_string (utmp_ent), "", pidstr, comment, exitstr);\n<line17>free (comment);\n<line18>}
----------------------------------------
Function: print_login
Content: <line0>static void\n<line1>print_login (struct gl_utmp const *utmp_ent)\n<line2>{\n<line3>char *comment = make_id_equals_comment (utmp_ent);\n<line4>PIDSTR_DECL_AND_INIT (pidstr, utmp_ent);\n<line5>/* FIXME: add idle time? */\n<line6>print_line (_("LOGIN"), ' ', utmp_ent->ut_line,\n<line7>time_string (utmp_ent), "", pidstr, comment, "");\n<line8>free (comment);\n<line9>}
----------------------------------------
Function: print_initspawn
Content: <line0>static void\n<line1>print_initspawn (struct gl_utmp const *utmp_ent)\n<line2>{\n<line3>char *comment = make_id_equals_comment (utmp_ent);\n<line4>PIDSTR_DECL_AND_INIT (pidstr, utmp_ent);\n<line5>print_line ("", ' ', utmp_ent->ut_line,\n<line6>time_string (utmp_ent), "", pidstr, comment, "");\n<line7>free (comment);\n<line8>}
----------------------------------------
Function: print_clockchange
Content: <line0>static void\n<line1>print_clockchange (struct gl_utmp const *utmp_ent)\n<line2>{\n<line3>/* FIXME: handle NEW_TIME & OLD_TIME both */\n<line4>print_line ("", ' ', _("clock change"),\n<line5>time_string (utmp_ent), "", "", "", "");\n<line6>}
----------------------------------------
Function: print_runlevel
Content: <line0>static void\n<line1>print_runlevel (struct gl_utmp const *utmp_ent)\n<line2>{\n<line3>static char *runlevline, *comment;\n<line4>unsigned char last = utmp_ent->ut_pid / 256;\n<line5>unsigned char curr = utmp_ent->ut_pid % 256;\n<line6>if (!runlevline)\n<line7>runlevline = xmalloc (strlen (_("run-level")) + 3);\n<line8>sprintf (runlevline, "%s %c", _("run-level"), curr);\n<line9>if (!comment)\n<line10>comment = xmalloc (strlen (_("last=")) + 2);\n<line11>sprintf (comment, "%s%c", _("last="), (last == 'N') ? 'S' : last);\n<line12>print_line ("", ' ', runlevline, time_string (utmp_ent),\n<line13>"", "", c_isprint (last) ? comment : "", "");\n<line14>return;\n<line15>}
----------------------------------------
Function: list_entries_who
Content: <line0>static void\n<line1>list_entries_who (idx_t n, struct gl_utmp const *utmp_buf)\n<line2>{\n<line3>idx_t entries = 0;\n<line4>char const *separator = "";\n<line5>while (n--)\n<line6>{\n<line7>if (IS_USER_PROCESS (utmp_buf))\n<line8>{\n<line9>char *trimmed_name;\n<line10>trimmed_name = extract_trimmed_name (utmp_buf);\n<line11>printf ("%s%s", separator, trimmed_name);\n<line12>free (trimmed_name);\n<line13>separator = " ";\n<line14>entries++;\n<line15>}\n<line16>utmp_buf++;\n<line17>}\n<line18>printf (_("\n# users=%td\n"), entries);\n<line19>}
----------------------------------------
Function: print_heading
Content: <line0>static void\n<line1>print_heading (void)\n<line2>{\n<line3>print_line (_("NAME"), ' ', _("LINE"), _("TIME"), _("IDLE"),\n<line4>_("PID"), _("COMMENT"), _("EXIT"));\n<line5>}
----------------------------------------
Function: scan_entries
Content: <line0>static void\n<line1>scan_entries (idx_t n, struct gl_utmp const *utmp_buf)\n<line2>{\n<line3>char *ttyname_b IF_LINT ( = nullptr);\n<line4>time_t boottime = TYPE_MINIMUM (time_t);\n<line5>if (include_heading)\n<line6>print_heading ();\n<line7>if (my_line_only)\n<line8>{\n<line9>ttyname_b = ttyname (STDIN_FILENO);\n<line10>if (!ttyname_b)\n<line11>return;\n<line12>if (STRNCMP_LIT (ttyname_b, "/dev/") == 0)\n<line13>ttyname_b += sizeof "/dev/" - 1;	/* Discard /dev/ prefix.  */\n<line14>}\n<line15>while (n--)\n<line16>{\n<line17>if (!my_line_only\n<line18>|| STREQ (ttyname_b, utmp_buf->ut_line))\n<line19>{\n<line20>if (need_users && IS_USER_PROCESS (utmp_buf))\n<line21>print_user (utmp_buf, boottime);\n<line22>else if (need_runlevel && UT_TYPE_RUN_LVL (utmp_buf))\n<line23>print_runlevel (utmp_buf);\n<line24>else if (need_boottime && UT_TYPE_BOOT_TIME (utmp_buf))\n<line25>print_boottime (utmp_buf);\n<line26>/* I've never seen one of these, so I don't know what it should\n<line27>look like :^)\n<line28>FIXME: handle OLD_TIME also, perhaps show the delta? */\n<line29>else if (need_clockchange && UT_TYPE_NEW_TIME (utmp_buf))\n<line30>print_clockchange (utmp_buf);\n<line31>else if (need_initspawn && UT_TYPE_INIT_PROCESS (utmp_buf))\n<line32>print_initspawn (utmp_buf);\n<line33>else if (need_login && UT_TYPE_LOGIN_PROCESS (utmp_buf))\n<line34>print_login (utmp_buf);\n<line35>else if (need_deadprocs && UT_TYPE_DEAD_PROCESS (utmp_buf))\n<line36>print_deadprocs (utmp_buf);\n<line37>}\n<line38>if (UT_TYPE_BOOT_TIME (utmp_buf))\n<line39>boottime = utmp_buf->ut_ts.tv_sec;\n<line40>utmp_buf++;\n<line41>}\n<line42>}
----------------------------------------
Function: who
Content: <line0>static void\n<line1>who (char const *filename, int options)\n<line2>{\n<line3>idx_t n_users;\n<line4>struct gl_utmp *utmp_buf;\n<line5>if (short_list)\n<line6>options |= READ_UTMP_USER_PROCESS;\n<line7>if (read_utmp (filename, &n_users, &utmp_buf, options) != 0)\n<line8>error (EXIT_FAILURE, errno, "%s", quotef (filename));\n<line9>if (short_list)\n<line10>list_entries_who (n_users, utmp_buf);\n<line11>else\n<line12>scan_entries (n_users, utmp_buf);\n<line13>free (utmp_buf);\n<line14>}
----------------------------------------
Function: usage
Content: <line0>void\n<line1>usage (int status)\n<line2>{\n<line3>if (status != EXIT_SUCCESS)\n<line4>emit_try_help ();\n<line5>else\n<line6>{\n<line7>printf (_("Usage: %s [OPTION]... [ FILE | ARG1 ARG2 ]\n"), program_name);\n<line8>fputs (_("\\n<line9>Print information about users who are currently logged in.\n\\n<line10>"), stdout);\n<line11>fputs (_("\\n<line12>\n\\n<line13>-a, --all         same as -b -d --login -p -r -t -T -u\n\\n<line14>-b, --boot        time of last system boot\n\\n<line15>-d, --dead        print dead processes\n\\n<line16>-H, --heading     print line of column headings\n\\n<line17>"), stdout);\n<line18>fputs (_("\\n<line19>-l, --login       print system login processes\n\\n<line20>"), stdout);\n<line21>fputs (_("\\n<line22>--lookup      attempt to canonicalize hostnames via DNS\n\\n<line23>-m                only hostname and user associated with stdin\n\\n<line24>-p, --process     print active processes spawned by init\n\\n<line25>"), stdout);\n<line26>fputs (_("\\n<line27>-q, --count       all login names and number of users logged on\n\\n<line28>-r, --runlevel    print current runlevel\n\\n<line29>-s, --short       print only name, line, and time (default)\n\\n<line30>-t, --time        print last system clock change\n\\n<line31>"), stdout);\n<line32>fputs (_("\\n<line33>-T, -w, --mesg    add user's message status as +, - or ?\n\\n<line34>-u, --users       list users logged in\n\\n<line35>--message     same as -T\n\\n<line36>--writable    same as -T\n\\n<line37>"), stdout);\n<line38>fputs (HELP_OPTION_DESCRIPTION, stdout);\n<line39>fputs (VERSION_OPTION_DESCRIPTION, stdout);\n<line40>printf (_("\\n<line41>\n\\n<line42>If FILE is not specified, use %s.  %s as FILE is common.\n\\n<line43>If ARG1 ARG2 given, -m presumed: 'am i' or 'mom likes' are usual.\n\\n<line44>"), UTMP_FILE, WTMP_FILE);\n<line45>emit_ancillary_info (PROGRAM_NAME);\n<line46>}\n<line47>exit (status);\n<line48>}
----------------------------------------
Function: main
Content: <line0>int\n<line1>main (int argc, char **argv)\n<line2>{\n<line3>int optc;\n<line4>bool assumptions = true;\n<line5>initialize_main (&argc, &argv);\n<line6>set_program_name (argv[0]);\n<line7>setlocale (LC_ALL, "");\n<line8>bindtextdomain (PACKAGE, LOCALEDIR);\n<line9>textdomain (PACKAGE);\n<line10>atexit (close_stdout);\n<line11>while ((optc = getopt_long (argc, argv, "abdlmpqrstuwHT", longopts, nullptr))\n<line12>!= -1)\n<line13>{\n<line14>switch (optc)\n<line15>{\n<line16>case 'a':\n<line17>need_boottime = true;\n<line18>need_deadprocs = true;\n<line19>need_login = true;\n<line20>need_initspawn = true;\n<line21>need_runlevel = true;\n<line22>need_clockchange = true;\n<line23>need_users = true;\n<line24>include_mesg = true;\n<line25>include_idle = true;\n<line26>include_exit = true;\n<line27>assumptions = false;\n<line28>break;\n<line29>case 'b':\n<line30>need_boottime = true;\n<line31>assumptions = false;\n<line32>break;\n<line33>case 'd':\n<line34>need_deadprocs = true;\n<line35>include_idle = true;\n<line36>include_exit = true;\n<line37>assumptions = false;\n<line38>break;\n<line39>case 'H':\n<line40>include_heading = true;\n<line41>break;\n<line42>case 'l':\n<line43>need_login = true;\n<line44>include_idle = true;\n<line45>assumptions = false;\n<line46>break;\n<line47>case 'm':\n<line48>my_line_only = true;\n<line49>break;\n<line50>case 'p':\n<line51>need_initspawn = true;\n<line52>assumptions = false;\n<line53>break;\n<line54>case 'q':\n<line55>short_list = true;\n<line56>break;\n<line57>case 'r':\n<line58>need_runlevel = true;\n<line59>include_idle = true;\n<line60>assumptions = false;\n<line61>break;\n<line62>case 's':\n<line63>short_output = true;\n<line64>break;\n<line65>case 't':\n<line66>need_clockchange = true;\n<line67>assumptions = false;\n<line68>break;\n<line69>case 'T':\n<line70>case 'w':\n<line71>include_mesg = true;\n<line72>break;\n<line73>case 'u':\n<line74>need_users = true;\n<line75>include_idle = true;\n<line76>assumptions = false;\n<line77>break;\n<line78>case LOOKUP_OPTION:\n<line79>do_lookup = true;\n<line80>break;\n<line81>case_GETOPT_HELP_CHAR;\n<line82>case_GETOPT_VERSION_CHAR (PROGRAM_NAME, AUTHORS);\n<line83>default:\n<line84>usage (EXIT_FAILURE);\n<line85>}\n<line86>}\n<line87>if (assumptions)\n<line88>{\n<line89>need_users = true;\n<line90>short_output = true;\n<line91>}\n<line92>if (include_exit)\n<line93>{\n<line94>short_output = false;\n<line95>}\n<line96>if (hard_locale (LC_TIME))\n<line97>{\n<line98>time_format = "%Y-%m-%d %H:%M";\n<line99>time_format_width = 4 + 1 + 2 + 1 + 2 + 1 + 2 + 1 + 2;\n<line100>}\n<line101>else\n<line102>{\n<line103>time_format = "%b %e %H:%M";\n<line104>time_format_width = 3 + 1 + 2 + 1 + 2 + 1 + 2;\n<line105>}\n<line106>switch (argc - optind)\n<line107>{\n<line108>case 2:			/* who <blurf> <glop> */\n<line109>my_line_only = true;\n<line110>FALLTHROUGH;\n<line111>case -1:\n<line112>case 0:			/* who */\n<line113>who (UTMP_FILE, READ_UTMP_CHECK_PIDS);\n<line114>break;\n<line115>case 1:			/* who <utmp file> */\n<line116>who (argv[optind], 0);\n<line117>break;\n<line118>default:			/* lose */\n<line119>error (0, 0, _("extra operand %s"), quote (argv[optind + 2]));\n<line120>usage (EXIT_FAILURE);\n<line121>}\n<line122>return EXIT_SUCCESS;\n<line123>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/src/users.c
========================================
Function: userid_compare
Content: <line0>static int\n<line1>userid_compare (const void *v_a, const void *v_b)\n<line2>{\n<line3>char **a = (char **) v_a;\n<line4>char **b = (char **) v_b;\n<line5>return strcmp (*a, *b);\n<line6>}
----------------------------------------
Function: list_entries_users
Content: <line0>static void\n<line1>list_entries_users (idx_t n, struct gl_utmp const *this)\n<line2>{\n<line3>char **u = xinmalloc (n, sizeof *u);\n<line4>idx_t i;\n<line5>idx_t n_entries = 0;\n<line6>while (n--)\n<line7>{\n<line8>if (IS_USER_PROCESS (this))\n<line9>{\n<line10>char *trimmed_name;\n<line11>trimmed_name = extract_trimmed_name (this);\n<line12>u[n_entries] = trimmed_name;\n<line13>++n_entries;\n<line14>}\n<line15>this++;\n<line16>}\n<line17>qsort (u, n_entries, sizeof (u[0]), userid_compare);\n<line18>for (i = 0; i < n_entries; i++)\n<line19>{\n<line20>char c = (i < n_entries - 1 ? ' ' : '\n');\n<line21>fputs (u[i], stdout);\n<line22>putchar (c);\n<line23>}\n<line24>for (i = 0; i < n_entries; i++)\n<line25>free (u[i]);\n<line26>free (u);\n<line27>}
----------------------------------------
Function: users
Content: <line0>static void\n<line1>users (char const *filename, int options)\n<line2>{\n<line3>idx_t n_users;\n<line4>struct gl_utmp *utmp_buf;\n<line5>options |= READ_UTMP_USER_PROCESS;\n<line6>if (read_utmp (filename, &n_users, &utmp_buf, options) != 0)\n<line7>error (EXIT_FAILURE, errno, "%s", quotef (filename));\n<line8>list_entries_users (n_users, utmp_buf);\n<line9>free (utmp_buf);\n<line10>}
----------------------------------------
Function: usage
Content: <line0>void\n<line1>usage (int status)\n<line2>{\n<line3>if (status != EXIT_SUCCESS)\n<line4>emit_try_help ();\n<line5>else\n<line6>{\n<line7>printf (_("Usage: %s [OPTION]... [FILE]\n"), program_name);\n<line8>printf (_("\\n<line9>Output who is currently logged in according to FILE.\n\\n<line10>If FILE is not specified, use %s.  %s as FILE is common.\n\\n<line11>\n\\n<line12>"),\n<line13>UTMP_FILE, WTMP_FILE);\n<line14>fputs (HELP_OPTION_DESCRIPTION, stdout);\n<line15>fputs (VERSION_OPTION_DESCRIPTION, stdout);\n<line16>emit_ancillary_info (PROGRAM_NAME);\n<line17>}\n<line18>exit (status);\n<line19>}
----------------------------------------
Function: main
Content: <line0>int\n<line1>main (int argc, char **argv)\n<line2>{\n<line3>initialize_main (&argc, &argv);\n<line4>set_program_name (argv[0]);\n<line5>setlocale (LC_ALL, "");\n<line6>bindtextdomain (PACKAGE, LOCALEDIR);\n<line7>textdomain (PACKAGE);\n<line8>atexit (close_stdout);\n<line9>parse_gnu_standard_options_only (argc, argv, PROGRAM_NAME, PACKAGE_NAME,\n<line10>Version, true, usage, AUTHORS,\n<line11>(char const *) nullptr);\n<line12>switch (argc - optind)\n<line13>{\n<line14>case 0:			/* users */\n<line15>users (UTMP_FILE, READ_UTMP_CHECK_PIDS);\n<line16>break;\n<line17>case 1:			/* users <utmp file> */\n<line18>users (argv[optind], 0);\n<line19>break;\n<line20>default:			/* lose */\n<line21>error (0, 0, _("extra operand %s"), quote (argv[optind + 1]));\n<line22>usage (EXIT_FAILURE);\n<line23>}\n<line24>return EXIT_SUCCESS;\n<line25>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/src/pinky.c
========================================
Function: create_fullname
Content: <line0>static char *\n<line1>create_fullname (char const *gecos_name, char const *user_name)\n<line2>{\n<line3>size_t rsize = strlen (gecos_name) + 1;\n<line4>char *result;\n<line5>char *r;\n<line6>size_t ampersands = count_ampersands (gecos_name);\n<line7>if (ampersands != 0)\n<line8>{\n<line9>size_t ulen = strlen (user_name);\n<line10>size_t product;\n<line11>if (ckd_mul (&product, ulen, ampersands - 1)\n<line12>|| ckd_add (&rsize, rsize, product))\n<line13>xalloc_die ();\n<line14>}\n<line15>r = result = xmalloc (rsize);\n<line16>while (*gecos_name)\n<line17>{\n<line18>if (*gecos_name == '&')\n<line19>{\n<line20>char const *uname = user_name;\n<line21>if (islower (to_uchar (*uname)))\n<line22>*r++ = toupper (to_uchar (*uname++));\n<line23>while (*uname)\n<line24>*r++ = *uname++;\n<line25>}\n<line26>else\n<line27>{\n<line28>*r++ = *gecos_name;\n<line29>}\n<line30>gecos_name++;\n<line31>}\n<line32>*r = 0;\n<line33>return result;\n<line34>}
----------------------------------------
Function: idle_string
Content: <line0>static char const *\n<line1>idle_string (time_t when)\n<line2>{\n<line3>static time_t now = 0;\n<line4>static char buf[INT_STRLEN_BOUND (intmax_t) + sizeof "d"];\n<line5>time_t seconds_idle;\n<line6>if (now == 0)\n<line7>time (&now);\n<line8>seconds_idle = now - when;\n<line9>if (seconds_idle < 60)	/* One minute. */\n<line10>return "     ";\n<line11>if (seconds_idle < (24 * 60 * 60))	/* One day. */\n<line12>{\n<line13>int hours = seconds_idle / (60 * 60);\n<line14>int minutes = (seconds_idle % (60 * 60)) / 60;\n<line15>sprintf (buf, "%02d:%02d", hours, minutes);\n<line16>}\n<line17>else\n<line18>{\n<line19>intmax_t days = seconds_idle / (24 * 60 * 60);\n<line20>sprintf (buf, "%"PRIdMAX"d", days);\n<line21>}\n<line22>return buf;\n<line23>}
----------------------------------------
Function: time_string
Content: <line0>static char const *\n<line1>time_string (struct gl_utmp const *utmp_ent)\n<line2>{\n<line3>static char buf[INT_STRLEN_BOUND (intmax_t) + sizeof "-%m-%d %H:%M"];\n<line4>struct tm *tmp = localtime (&utmp_ent->ut_ts.tv_sec);\n<line5>if (tmp)\n<line6>{\n<line7>strftime (buf, sizeof buf, time_format, tmp);\n<line8>return buf;\n<line9>}\n<line10>else\n<line11>return timetostr (utmp_ent->ut_ts.tv_sec, buf);\n<line12>}
----------------------------------------
Function: print_entry
Content: <line0>static void\n<line1>print_entry (struct gl_utmp const *utmp_ent)\n<line2>{\n<line3>struct stat stats;\n<line4>time_t last_change;\n<line5>char mesg;\n<line6>/* If ut_line contains a space, the device name starts after the space.  */\n<line7>char *line = utmp_ent->ut_line;\n<line8>char *space = strchr (line, ' ');\n<line9>line = space ? space + 1 : line;\n<line10>int dirfd;\n<line11>if (IS_ABSOLUTE_FILE_NAME (line))\n<line12>dirfd = AT_FDCWD;\n<line13>else\n<line14>{\n<line15>static int dev_dirfd;\n<line16>if (!dev_dirfd)\n<line17>{\n<line18>dev_dirfd = open ("/dev", O_PATHSEARCH | O_DIRECTORY);\n<line19>if (dev_dirfd < 0)\n<line20>dev_dirfd = AT_FDCWD - 1;\n<line21>}\n<line22>dirfd = dev_dirfd;\n<line23>}\n<line24>if (AT_FDCWD <= dirfd && fstatat (dirfd, line, &stats, 0) == 0)\n<line25>{\n<line26>mesg = (stats.st_mode & S_IWGRP) ? ' ' : '*';\n<line27>last_change = stats.st_atime;\n<line28>}\n<line29>else\n<line30>{\n<line31>mesg = '?';\n<line32>last_change = 0;\n<line33>}\n<line34>char *ut_user = utmp_ent->ut_user;\n<line35>if (strnlen (ut_user, 8) < 8)\n<line36>printf ("%-8s", ut_user);\n<line37>else\n<line38>fputs (ut_user, stdout);\n<line39>if (include_fullname)\n<line40>{\n<line41>struct passwd *pw = getpwnam (ut_user);\n<line42>if (pw == nullptr)\n<line43>/* TRANSLATORS: Real name is unknown; at most 19 characters. */\n<line44>printf (" %19s", _("        ???"));\n<line45>else\n<line46>{\n<line47>char *const comma = strchr (pw->pw_gecos, ',');\n<line48>char *result;\n<line49>if (comma)\n<line50>*comma = '\0';\n<line51>result = create_fullname (pw->pw_gecos, pw->pw_name);\n<line52>printf (" %-19.19s", result);\n<line53>free (result);\n<line54>}\n<line55>}\n<line56>fputc (' ', stdout);\n<line57>fputc (mesg, stdout);\n<line58>if (strnlen (utmp_ent->ut_line, 8) < 8)\n<line59>printf ("%-8s", utmp_ent->ut_line);\n<line60>else\n<line61>fputs (utmp_ent->ut_line, stdout);\n<line62>if (include_idle)\n<line63>{\n<line64>if (last_change)\n<line65>printf (" %-6s", idle_string (last_change));\n<line66>else\n<line67>/* TRANSLATORS: Idle time is unknown; at most 5 characters. */\n<line68>printf (" %-6s", _("?????"));\n<line69>}\n<line70>printf (" %s", time_string (utmp_ent));\n<line71>#ifdef HAVE_STRUCT_XTMP_UT_HOST\n<line72>if (include_where && utmp_ent->ut_host[0])\n<line73>{\n<line74>char *host = nullptr;\n<line75>char *display = nullptr;\n<line76>char *ut_host = utmp_ent->ut_host;\n<line77>/* Look for an X display.  */\n<line78>display = strchr (ut_host, ':');\n<line79>if (display)\n<line80>*display++ = '\0';\n<line81>if (*ut_host)\n<line82>/* See if we can canonicalize it.  */\n<line83>host = canon_host (ut_host);\n<line84>if ( ! host)\n<line85>host = ut_host;\n<line86>fputc (' ', stdout);\n<line87>fputs (host, stdout);\n<line88>if (display)\n<line89>{\n<line90>fputc (':', stdout);\n<line91>fputs (display, stdout);\n<line92>}\n<line93>if (host != ut_host)\n<line94>free (host);\n<line95>}\n<line96>#endif\n<line97>putchar ('\n');\n<line98>}
----------------------------------------
Function: print_long_entry
Content: <line0>static void\n<line1>print_long_entry (const char name[])\n<line2>{\n<line3>struct passwd *pw;\n<line4>pw = getpwnam (name);\n<line5>printf (_("Login name: "));\n<line6>printf ("%-28s", name);\n<line7>printf (_("In real life: "));\n<line8>if (pw == nullptr)\n<line9>{\n<line10>/* TRANSLATORS: Real name is unknown; no hard limit. */\n<line11>printf (" %s", _("???\n"));\n<line12>return;\n<line13>}\n<line14>else\n<line15>{\n<line16>char *const comma = strchr (pw->pw_gecos, ',');\n<line17>char *result;\n<line18>if (comma)\n<line19>*comma = '\0';\n<line20>result = create_fullname (pw->pw_gecos, pw->pw_name);\n<line21>printf (" %s", result);\n<line22>free (result);\n<line23>}\n<line24>putchar ('\n');\n<line25>if (include_home_and_shell)\n<line26>{\n<line27>printf (_("Directory: "));\n<line28>printf ("%-29s", pw->pw_dir);\n<line29>printf (_("Shell: "));\n<line30>printf (" %s", pw->pw_shell);\n<line31>putchar ('\n');\n<line32>}\n<line33>if (include_project)\n<line34>{\n<line35>FILE *stream;\n<line36>char buf[1024];\n<line37>char const *const baseproject = "/.project";\n<line38>char *const project =\n<line39>xmalloc (strlen (pw->pw_dir) + strlen (baseproject) + 1);\n<line40>stpcpy (stpcpy (project, pw->pw_dir), baseproject);\n<line41>stream = fopen (project, "r");\n<line42>if (stream)\n<line43>{\n<line44>size_t bytes;\n<line45>printf (_("Project: "));\n<line46>while ((bytes = fread (buf, 1, sizeof (buf), stream)) > 0)\n<line47>fwrite (buf, 1, bytes, stdout);\n<line48>fclose (stream);\n<line49>}\n<line50>free (project);\n<line51>}\n<line52>if (include_plan)\n<line53>{\n<line54>FILE *stream;\n<line55>char buf[1024];\n<line56>char const *const baseplan = "/.plan";\n<line57>char *const plan =\n<line58>xmalloc (strlen (pw->pw_dir) + strlen (baseplan) + 1);\n<line59>stpcpy (stpcpy (plan, pw->pw_dir), baseplan);\n<line60>stream = fopen (plan, "r");\n<line61>if (stream)\n<line62>{\n<line63>size_t bytes;\n<line64>printf (_("Plan:\n"));\n<line65>while ((bytes = fread (buf, 1, sizeof (buf), stream)) > 0)\n<line66>fwrite (buf, 1, bytes, stdout);\n<line67>fclose (stream);\n<line68>}\n<line69>free (plan);\n<line70>}\n<line71>putchar ('\n');\n<line72>}
----------------------------------------
Function: print_heading
Content: <line0>static void\n<line1>print_heading (void)\n<line2>{\n<line3>printf ("%-8s", _("Login"));\n<line4>if (include_fullname)\n<line5>printf (" %-19s", _("Name"));\n<line6>printf (" %-9s", _(" TTY"));\n<line7>if (include_idle)\n<line8>printf (" %-6s", _("Idle"));\n<line9>printf (" %-*s", time_format_width, _("When"));\n<line10>#ifdef HAVE_STRUCT_XTMP_UT_HOST\n<line11>if (include_where)\n<line12>printf (" %s", _("Where"));\n<line13>#endif\n<line14>putchar ('\n');\n<line15>}
----------------------------------------
Function: scan_entries
Content: <line0>static void\n<line1>scan_entries (idx_t n, struct gl_utmp const *utmp_buf,\n<line2>const int argc_names, char *const argv_names[])\n<line3>{\n<line4>if (hard_locale (LC_TIME))\n<line5>{\n<line6>time_format = "%Y-%m-%d %H:%M";\n<line7>time_format_width = 4 + 1 + 2 + 1 + 2 + 1 + 2 + 1 + 2;\n<line8>}\n<line9>else\n<line10>{\n<line11>time_format = "%b %e %H:%M";\n<line12>time_format_width = 3 + 1 + 2 + 1 + 2 + 1 + 2;\n<line13>}\n<line14>if (include_heading)\n<line15>print_heading ();\n<line16>while (n--)\n<line17>{\n<line18>if (IS_USER_PROCESS (utmp_buf))\n<line19>{\n<line20>if (argc_names)\n<line21>{\n<line22>for (int i = 0; i < argc_names; i++)\n<line23>if (STREQ (utmp_buf->ut_user, argv_names[i]))\n<line24>{\n<line25>print_entry (utmp_buf);\n<line26>break;\n<line27>}\n<line28>}\n<line29>else\n<line30>print_entry (utmp_buf);\n<line31>}\n<line32>utmp_buf++;\n<line33>}\n<line34>}
----------------------------------------
Function: short_pinky
Content: <line0>static void\n<line1>short_pinky (char const *filename,\n<line2>const int argc_names, char *const argv_names[])\n<line3>{\n<line4>idx_t n_users;\n<line5>struct gl_utmp *utmp_buf;\n<line6>if (read_utmp (filename, &n_users, &utmp_buf, READ_UTMP_USER_PROCESS) != 0)\n<line7>error (EXIT_FAILURE, errno, "%s", quotef (filename));\n<line8>scan_entries (n_users, utmp_buf, argc_names, argv_names);\n<line9>exit (EXIT_SUCCESS);\n<line10>}
----------------------------------------
Function: long_pinky
Content: <line0>static void\n<line1>long_pinky (const int argc_names, char *const argv_names[])\n<line2>{\n<line3>for (int i = 0; i < argc_names; i++)\n<line4>print_long_entry (argv_names[i]);\n<line5>}
----------------------------------------
Function: usage
Content: <line0>void\n<line1>usage (int status)\n<line2>{\n<line3>if (status != EXIT_SUCCESS)\n<line4>emit_try_help ();\n<line5>else\n<line6>{\n<line7>printf (_("Usage: %s [OPTION]... [USER]...\n"), program_name);\n<line8>fputs (_("\\n<line9>\n\\n<line10>-l              produce long format output for the specified USERs\n\\n<line11>-b              omit the user's home directory and shell in long format\n\\n<line12>-h              omit the user's project file in long format\n\\n<line13>-p              omit the user's plan file in long format\n\\n<line14>-s              do short format output, this is the default\n\\n<line15>"), stdout);\n<line16>fputs (_("\\n<line17>-f              omit the line of column headings in short format\n\\n<line18>-w              omit the user's full name in short format\n\\n<line19>-i              omit the user's full name and remote host in short format\n\\n<line20>-q              omit the user's full name, remote host and idle time\n\\n<line21>in short format\n\\n<line22>"), stdout);\n<line23>fputs (HELP_OPTION_DESCRIPTION, stdout);\n<line24>fputs (VERSION_OPTION_DESCRIPTION, stdout);\n<line25>printf (_("\\n<line26>\n\\n<line27>A lightweight 'finger' program;  print user information.\n\\n<line28>The utmp file will be %s.\n\\n<line29>"), UTMP_FILE);\n<line30>emit_ancillary_info (PROGRAM_NAME);\n<line31>}\n<line32>exit (status);\n<line33>}
----------------------------------------
Function: main
Content: <line0>int\n<line1>main (int argc, char **argv)\n<line2>{\n<line3>int optc;\n<line4>int n_users;\n<line5>initialize_main (&argc, &argv);\n<line6>set_program_name (argv[0]);\n<line7>setlocale (LC_ALL, "");\n<line8>bindtextdomain (PACKAGE, LOCALEDIR);\n<line9>textdomain (PACKAGE);\n<line10>atexit (close_stdout);\n<line11>while ((optc = getopt_long (argc, argv, "sfwiqbhlp", longopts, nullptr))\n<line12>!= -1)\n<line13>{\n<line14>switch (optc)\n<line15>{\n<line16>case 's':\n<line17>do_short_format = true;\n<line18>break;\n<line19>case 'l':\n<line20>do_short_format = false;\n<line21>break;\n<line22>case 'f':\n<line23>include_heading = false;\n<line24>break;\n<line25>case 'w':\n<line26>include_fullname = false;\n<line27>break;\n<line28>case 'i':\n<line29>include_fullname = false;\n<line30>#ifdef HAVE_STRUCT_XTMP_UT_HOST\n<line31>include_where = false;\n<line32>#endif\n<line33>break;\n<line34>case 'q':\n<line35>include_fullname = false;\n<line36>#ifdef HAVE_STRUCT_XTMP_UT_HOST\n<line37>include_where = false;\n<line38>#endif\n<line39>include_idle = false;\n<line40>break;\n<line41>case 'h':\n<line42>include_project = false;\n<line43>break;\n<line44>case 'p':\n<line45>include_plan = false;\n<line46>break;\n<line47>case 'b':\n<line48>include_home_and_shell = false;\n<line49>break;\n<line50>case_GETOPT_HELP_CHAR;\n<line51>case_GETOPT_VERSION_CHAR (PROGRAM_NAME, AUTHORS);\n<line52>default:\n<line53>usage (EXIT_FAILURE);\n<line54>}\n<line55>}\n<line56>n_users = argc - optind;\n<line57>if (!do_short_format && n_users == 0)\n<line58>{\n<line59>error (0, 0, _("no username specified; at least one must be\\n<line60>specified when using -l"));\n<line61>usage (EXIT_FAILURE);\n<line62>}\n<line63>if (do_short_format)\n<line64>short_pinky (UTMP_FILE, n_users, argv + optind);\n<line65>else\n<line66>long_pinky (n_users, argv + optind);\n<line67>return EXIT_SUCCESS;\n<line68>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/src/stty.c
========================================
Function: usage
Content: <line0>void\n<line1>usage (int status)\n<line2>{\n<line3>if (status != EXIT_SUCCESS)\n<line4>emit_try_help ();\n<line5>else\n<line6>{\n<line7>printf (_("\\n<line8>Usage: %s [-F DEVICE | --file=DEVICE] [SETTING]...\n\\n<line9>or:  %s [-F DEVICE | --file=DEVICE] [-a|--all]\n\\n<line10>or:  %s [-F DEVICE | --file=DEVICE] [-g|--save]\n\\n<line11>"),\n<line12>program_name, program_name, program_name);\n<line13>fputs (_("\\n<line14>Print or change terminal characteristics.\n\\n<line15>"), stdout);\n<line16>emit_mandatory_arg_note ();\n<line17>fputs (_("\\n<line18>-a, --all          print all current settings in human-readable form\n\\n<line19>-g, --save         print all current settings in a stty-readable form\n\\n<line20>-F, --file=DEVICE  open and use the specified DEVICE instead of stdin\n\\n<line21>"), stdout);\n<line22>fputs (HELP_OPTION_DESCRIPTION, stdout);\n<line23>fputs (VERSION_OPTION_DESCRIPTION, stdout);\n<line24>fputs (_("\\n<line25>\n\\n<line26>Optional - before SETTING indicates negation.  An * marks non-POSIX\n\\n<line27>settings.  The underlying system defines which settings are available.\n\\n<line28>"), stdout);\n<line29>fputs (_("\\n<line30>\n\\n<line31>Special characters:\n"), stdout);\n<line32>#ifdef VFLUSHO\n<line33>fputs (_("\\n<line34>* discard CHAR  CHAR will toggle discarding of output\n\\n<line35>"), stdout);\n<line36>#endif\n<line37>#ifdef VDSUSP\n<line38>fputs (_("\\n<line39>* dsusp CHAR    CHAR will send a terminal stop signal once input flushed\n\\n<line40>"), stdout);\n<line41>#endif\n<line42>fputs (_("\\n<line43>eof CHAR      CHAR will send an end of file (terminate the input)\n\\n<line44>eol CHAR      CHAR will end the line\n\\n<line45>"), stdout);\n<line46>#ifdef VEOL2\n<line47>fputs (_("\\n<line48>* eol2 CHAR     alternate CHAR for ending the line\n\\n<line49>"), stdout);\n<line50>#endif\n<line51>fputs (_("\\n<line52>erase CHAR    CHAR will erase the last character typed\n\\n<line53>intr CHAR     CHAR will send an interrupt signal\n\\n<line54>kill CHAR     CHAR will erase the current line\n\\n<line55>"), stdout);\n<line56>#ifdef VLNEXT\n<line57>fputs (_("\\n<line58>* lnext CHAR    CHAR will enter the next character quoted\n\\n<line59>"), stdout);\n<line60>#endif\n<line61>#ifdef VSTATUS\n<line62>fputs (_("\\n<line63>* status CHAR   CHAR will send an info signal\n\\n<line64>"), stdout);\n<line65>#endif\n<line66>fputs (_("\\n<line67>quit CHAR     CHAR will send a quit signal\n\\n<line68>"), stdout);\n<line69>#if defined CREPRINT || defined VREPRINT\n<line70>fputs (_("\\n<line71>* rprnt CHAR    CHAR will redraw the current line\n\\n<line72>"), stdout);\n<line73>#endif\n<line74>fputs (_("\\n<line75>start CHAR    CHAR will restart the output after stopping it\n\\n<line76>stop CHAR     CHAR will stop the output\n\\n<line77>susp CHAR     CHAR will send a terminal stop signal\n\\n<line78>"), stdout);\n<line79>#ifdef VSWTCH\n<line80>fputs (_("\\n<line81>* swtch CHAR    CHAR will switch to a different shell layer\n\\n<line82>"), stdout);\n<line83>#endif\n<line84>#ifdef VWERASE\n<line85>fputs (_("\\n<line86>* werase CHAR   CHAR will erase the last word typed\n\\n<line87>"), stdout);\n<line88>#endif\n<line89>fputs (_("\\n<line90>\n\\n<line91>Special settings:\n\\n<line92>N             set the input and output speeds to N bauds\n\\n<line93>"), stdout);\n<line94>#ifdef TIOCGWINSZ\n<line95>fputs (_("\\n<line96>* cols N        tell the kernel that the terminal has N columns\n\\n<line97>* columns N     same as cols N\n\\n<line98>"), stdout);\n<line99>#endif\n<line100>printf (_("\\n<line101>* [-]drain      wait for transmission before applying settings (%s by default)\\n<line102>\n"), tcsetattr_options == TCSADRAIN ? _("on") : _("off"));\n<line103>fputs (_("\\n<line104>ispeed N      set the input speed to N\n\\n<line105>"), stdout);\n<line106>#ifdef HAVE_C_LINE\n<line107>fputs (_("\\n<line108>* line N        use line discipline N\n\\n<line109>"), stdout);\n<line110>#endif\n<line111>fputs (_("\\n<line112>min N         with -icanon, set N characters minimum for a completed read\n\\n<line113>ospeed N      set the output speed to N\n\\n<line114>"), stdout);\n<line115>#ifdef TIOCGWINSZ\n<line116>fputs (_("\\n<line117>* rows N        tell the kernel that the terminal has N rows\n\\n<line118>* size          print the number of rows and columns according to the kernel\n\\n<line119>"), stdout);\n<line120>#endif\n<line121>fputs (_("\\n<line122>speed         print the terminal speed\n\\n<line123>time N        with -icanon, set read timeout of N tenths of a second\n\\n<line124>"), stdout);\n<line125>fputs (_("\\n<line126>\n\\n<line127>Control settings:\n\\n<line128>[-]clocal     disable modem control signals\n\\n<line129>[-]cread      allow input to be received\n\\n<line130>"), stdout);\n<line131>#ifdef CRTSCTS\n<line132>fputs (_("\\n<line133>* [-]crtscts    enable RTS/CTS handshaking\n\\n<line134>"), stdout);\n<line135>#endif\n<line136>#ifdef CDTRDSR\n<line137>fputs (_("\\n<line138>* [-]cdtrdsr    enable DTR/DSR handshaking\n\\n<line139>"), stdout);\n<line140>#endif\n<line141>fputs (_("\\n<line142>csN           set character size to N bits, N in [5..8]\n\\n<line143>"), stdout);\n<line144>fputs (_("\\n<line145>[-]cstopb     use two stop bits per character (one with '-')\n\\n<line146>[-]hup        send a hangup signal when the last process closes the tty\n\\n<line147>[-]hupcl      same as [-]hup\n\\n<line148>[-]parenb     generate parity bit in output and expect parity bit in input\n\\n<line149>[-]parodd     set odd parity (or even parity with '-')\n\\n<line150>"), stdout);\n<line151>#ifdef CMSPAR\n<line152>fputs (_("\\n<line153>* [-]cmspar     use \"stick\" (mark/space) parity\n\\n<line154>"), stdout);\n<line155>#endif\n<line156>fputs (_("\\n<line157>\n\\n<line158>Input settings:\n\\n<line159>[-]brkint     breaks cause an interrupt signal\n\\n<line160>[-]icrnl      translate carriage return to newline\n\\n<line161>[-]ignbrk     ignore break characters\n\\n<line162>[-]igncr      ignore carriage return\n\\n<line163>[-]ignpar     ignore characters with parity errors\n\\n<line164>"), stdout);\n<line165>#ifdef IMAXBEL\n<line166>fputs (_("\\n<line167>* [-]imaxbel    beep and do not flush a full input buffer on a character\n\\n<line168>"), stdout);\n<line169>#endif\n<line170>fputs (_("\\n<line171>[-]inlcr      translate newline to carriage return\n\\n<line172>[-]inpck      enable input parity checking\n\\n<line173>[-]istrip     clear high (8th) bit of input characters\n\\n<line174>"), stdout);\n<line175>#ifdef IUTF8\n<line176>fputs (_("\\n<line177>* [-]iutf8      assume input characters are UTF-8 encoded\n\\n<line178>"), stdout);\n<line179>#endif\n<line180>#ifdef IUCLC\n<line181>fputs (_("\\n<line182>* [-]iuclc      translate uppercase characters to lowercase\n\\n<line183>"), stdout);\n<line184>#endif\n<line185>#ifdef IXANY\n<line186>fputs (_("\\n<line187>* [-]ixany      let any character restart output, not only start character\n\\n<line188>"), stdout);\n<line189>#endif\n<line190>fputs (_("\\n<line191>[-]ixoff      enable sending of start/stop characters\n\\n<line192>[-]ixon       enable XON/XOFF flow control\n\\n<line193>[-]parmrk     mark parity errors (with a 255-0-character sequence)\n\\n<line194>[-]tandem     same as [-]ixoff\n\\n<line195>"), stdout);\n<line196>fputs (_("\\n<line197>\n\\n<line198>Output settings:\n\\n<line199>"), stdout);\n<line200>#ifdef BSDLY\n<line201>fputs (_("\\n<line202>* bsN           backspace delay style, N in [0..1]\n\\n<line203>"), stdout);\n<line204>#endif\n<line205>#ifdef CRDLY\n<line206>fputs (_("\\n<line207>* crN           carriage return delay style, N in [0..3]\n\\n<line208>"), stdout);\n<line209>#endif\n<line210>#ifdef FFDLY\n<line211>fputs (_("\\n<line212>* ffN           form feed delay style, N in [0..1]\n\\n<line213>"), stdout);\n<line214>#endif\n<line215>#ifdef NLDLY\n<line216>fputs (_("\\n<line217>* nlN           newline delay style, N in [0..1]\n\\n<line218>"), stdout);\n<line219>#endif\n<line220>#ifdef OCRNL\n<line221>fputs (_("\\n<line222>* [-]ocrnl      translate carriage return to newline\n\\n<line223>"), stdout);\n<line224>#endif\n<line225>#ifdef OFDEL\n<line226>fputs (_("\\n<line227>* [-]ofdel      use delete characters for fill instead of NUL characters\n\\n<line228>"), stdout);\n<line229>#endif\n<line230>#ifdef OFILL\n<line231>fputs (_("\\n<line232>* [-]ofill      use fill (padding) characters instead of timing for delays\n\\n<line233>"), stdout);\n<line234>#endif\n<line235>#ifdef OLCUC\n<line236>fputs (_("\\n<line237>* [-]olcuc      translate lowercase characters to uppercase\n\\n<line238>"), stdout);\n<line239>#endif\n<line240>#ifdef ONLCR\n<line241>fputs (_("\\n<line242>* [-]onlcr      translate newline to carriage return-newline\n\\n<line243>"), stdout);\n<line244>#endif\n<line245>#ifdef ONLRET\n<line246>fputs (_("\\n<line247>* [-]onlret     newline performs a carriage return\n\\n<line248>"), stdout);\n<line249>#endif\n<line250>#ifdef ONOCR\n<line251>fputs (_("\\n<line252>* [-]onocr      do not print carriage returns in the first column\n\\n<line253>"), stdout);\n<line254>#endif\n<line255>fputs (_("\\n<line256>[-]opost      postprocess output\n\\n<line257>"), stdout);\n<line258>#if defined TABDLY || defined OXTABS\n<line259>fputs (_("\\n<line260>* tabN          horizontal tab delay style, N in [0..3]\n\\n<line261>* tabs          same as tab0\n\\n<line262>* -tabs         same as tab3\n\\n<line263>"), stdout);\n<line264>#endif\n<line265>#ifdef VTDLY\n<line266>fputs (_("\\n<line267>* vtN           vertical tab delay style, N in [0..1]\n\\n<line268>"), stdout);\n<line269>#endif\n<line270>fputs (_("\\n<line271>\n\\n<line272>Local settings:\n\\n<line273>[-]crterase   echo erase characters as backspace-space-backspace\n\\n<line274>"), stdout);\n<line275>#ifdef ECHOKE\n<line276>fputs (_("\\n<line277>* crtkill       kill all line by obeying the echoprt and echoe settings\n\\n<line278>* -crtkill      kill all line by obeying the echoctl and echok settings\n\\n<line279>"), stdout);\n<line280>#endif\n<line281>#ifdef ECHOCTL\n<line282>fputs (_("\\n<line283>* [-]ctlecho    echo control characters in hat notation ('^c')\n\\n<line284>"), stdout);\n<line285>#endif\n<line286>fputs (_("\\n<line287>[-]echo       echo input characters\n\\n<line288>"), stdout);\n<line289>#ifdef ECHOCTL\n<line290>fputs (_("\\n<line291>* [-]echoctl    same as [-]ctlecho\n\\n<line292>"), stdout);\n<line293>#endif\n<line294>fputs (_("\\n<line295>[-]echoe      same as [-]crterase\n\\n<line296>[-]echok      echo a newline after a kill character\n\\n<line297>"), stdout);\n<line298>#ifdef ECHOKE\n<line299>fputs (_("\\n<line300>* [-]echoke     same as [-]crtkill\n\\n<line301>"), stdout);\n<line302>#endif\n<line303>fputs (_("\\n<line304>[-]echonl     echo newline even if not echoing other characters\n\\n<line305>"), stdout);\n<line306>#ifdef ECHOPRT\n<line307>fputs (_("\\n<line308>* [-]echoprt    echo erased characters backward, between '\\' and '/'\n\\n<line309>"), stdout);\n<line310>#endif\n<line311>#if defined EXTPROC || defined TIOCEXT\n<line312>fputs (_("\\n<line313>* [-]extproc    enable \"LINEMODE\"; useful with high latency links\n\\n<line314>"), stdout);\n<line315>#endif\n<line316>#if defined FLUSHO\n<line317>fputs (_("\\n<line318>* [-]flusho     discard output\n\\n<line319>"), stdout);\n<line320>#endif\n<line321>printf (_("\\n<line322>[-]icanon     enable special characters: %s\n\\n<line323>[-]iexten     enable non-POSIX special characters\n\\n<line324>"), "erase, kill"\n<line325>#ifdef VWERASE\n<line326>", werase"\n<line327>#endif\n<line328>#if defined CREPRINT || defined VREPRINT\n<line329>", rprnt"\n<line330>#endif\n<line331>);\n<line332>fputs (_("\\n<line333>[-]isig       enable interrupt, quit, and suspend special characters\n\\n<line334>[-]noflsh     disable flushing after interrupt and quit special characters\n\\n<line335>"), stdout);\n<line336>#ifdef ECHOPRT\n<line337>fputs (_("\\n<line338>* [-]prterase   same as [-]echoprt\n\\n<line339>"), stdout);\n<line340>#endif\n<line341>#ifdef TOSTOP\n<line342>fputs (_("\\n<line343>* [-]tostop     stop background jobs that try to write to the terminal\n\\n<line344>"), stdout);\n<line345>#endif\n<line346>#ifdef XCASE\n<line347>fputs (_("\\n<line348>* [-]xcase      with icanon, escape with '\\' for uppercase characters\n\\n<line349>"), stdout);\n<line350>#endif\n<line351>fputs (_("\\n<line352>\n\\n<line353>Combination settings:\n\\n<line354>"), stdout);\n<line355>#if defined XCASE && defined IUCLC && defined OLCUC\n<line356>fputs (_("\\n<line357>* [-]LCASE      same as [-]lcase\n\\n<line358>"), stdout);\n<line359>#endif\n<line360>fputs (_("\\n<line361>cbreak        same as -icanon\n\\n<line362>-cbreak       same as icanon\n\\n<line363>"), stdout);\n<line364>fputs (_("\\n<line365>cooked        same as brkint ignpar istrip icrnl ixon opost isig\n\\n<line366>icanon, eof and eol characters to their default values\n\\n<line367>-cooked       same as raw\n\\n<line368>"), stdout);\n<line369>printf (_("\\n<line370>crt           same as %s\n\\n<line371>"), "echoe"\n<line372>#ifdef ECHOCTL\n<line373>" echoctl"\n<line374>#endif\n<line375>#ifdef ECHOKE\n<line376>" echoke"\n<line377>#endif\n<line378>);\n<line379>printf (_("\\n<line380>dec           same as %s intr ^c erase 0177\n\\n<line381>kill ^u\n\\n<line382>"), "echoe"\n<line383>#ifdef ECHOCTL\n<line384>" echoctl"\n<line385>#endif\n<line386>#ifdef ECHOKE\n<line387>" echoke"\n<line388>#endif\n<line389>#ifdef IXANY\n<line390>" -ixany"\n<line391>#endif\n<line392>);\n<line393>#ifdef IXANY\n<line394>fputs (_("\\n<line395>* [-]decctlq    same as [-]ixany\n\\n<line396>"), stdout);\n<line397>#endif\n<line398>fputs (_("\\n<line399>ek            erase and kill characters to their default values\n\\n<line400>evenp         same as parenb -parodd cs7\n\\n<line401>-evenp        same as -parenb cs8\n\\n<line402>"), stdout);\n<line403>#if defined XCASE && defined IUCLC && defined OLCUC\n<line404>fputs (_("\\n<line405>* [-]lcase      same as xcase iuclc olcuc\n\\n<line406>"), stdout);\n<line407>#endif\n<line408>fputs (_("\\n<line409>litout        same as -parenb -istrip -opost cs8\n\\n<line410>-litout       same as parenb istrip opost cs7\n\\n<line411>"), stdout);\n<line412>printf (_("\\n<line413>nl            same as %s\n\\n<line414>-nl           same as %s\n\\n<line415>"), "-icrnl"\n<line416>#ifdef ONLCR\n<line417>" -onlcr"\n<line418>#endif\n<line419>, "icrnl -inlcr -igncr"\n<line420>#ifdef ONLCR\n<line421>" onlcr"\n<line422>#endif\n<line423>#ifdef OCRNL\n<line424>" -ocrnl"\n<line425>#endif\n<line426>#ifdef ONLRET\n<line427>" -onlret"\n<line428>#endif\n<line429>);\n<line430>fputs (_("\\n<line431>oddp          same as parenb parodd cs7\n\\n<line432>-oddp         same as -parenb cs8\n\\n<line433>[-]parity     same as [-]evenp\n\\n<line434>pass8         same as -parenb -istrip cs8\n\\n<line435>-pass8        same as parenb istrip cs7\n\\n<line436>"), stdout);\n<line437>printf (_("\\n<line438>raw           same as -ignbrk -brkint -ignpar -parmrk -inpck -istrip\n\\n<line439>-inlcr -igncr -icrnl -ixon -ixoff -icanon -opost\n\\n<line440>-isig%s min 1 time 0\n\\n<line441>-raw          same as cooked\n\\n<line442>"),\n<line443>#ifdef IUCLC\n<line444>" -iuclc"\n<line445>#endif\n<line446>#ifdef IXANY\n<line447>" -ixany"\n<line448>#endif\n<line449>#ifdef IMAXBEL\n<line450>" -imaxbel"\n<line451>#endif\n<line452>#ifdef XCASE\n<line453>" -xcase"\n<line454>#endif\n<line455>);\n<line456>printf (_("\\n<line457>sane          same as cread -ignbrk brkint -inlcr -igncr icrnl\n\\n<line458>icanon iexten echo echoe echok -echonl -noflsh\n\\n<line459>%s\n\\n<line460>%s\n\\n<line461>%s,\n\\n<line462>all special characters to their default values\n\\n<line463>"),\n<line464>"-ixoff"\n<line465>#ifdef IUTF8\n<line466>" -iutf8"\n<line467>#endif\n<line468>#ifdef IUCLC\n<line469>" -iuclc"\n<line470>#endif\n<line471>#ifdef IXANY\n<line472>" -ixany"\n<line473>#endif\n<line474>#ifdef IMAXBEL\n<line475>" imaxbel"\n<line476>#endif\n<line477>#ifdef XCASE\n<line478>" -xcase"\n<line479>#endif\n<line480>#ifdef OLCUC\n<line481>" -olcuc"\n<line482>#endif\n<line483>#ifdef OCRNL\n<line484>" -ocrnl"\n<line485>#endif\n<line486>, "opost"\n<line487>#ifdef OFILL\n<line488>" -ofill"\n<line489>#endif\n<line490>#ifdef ONLCR\n<line491>" onlcr"\n<line492>#endif\n<line493>#ifdef ONOCR\n<line494>" -onocr"\n<line495>#endif\n<line496>#ifdef ONLRET\n<line497>" -onlret"\n<line498>#endif\n<line499>#ifdef NLDLY\n<line500>" nl0"\n<line501>#endif\n<line502>#ifdef CRDLY\n<line503>" cr0"\n<line504>#endif\n<line505>#ifdef TAB0\n<line506>" tab0"\n<line507>#endif\n<line508>#ifdef BSDLY\n<line509>" bs0"\n<line510>#endif\n<line511>#ifdef VTDLY\n<line512>" vt0"\n<line513>#endif\n<line514>#ifdef FFDLY\n<line515>" ff0"\n<line516>#endif\n<line517>, "isig"\n<line518>#ifdef TOSTOP\n<line519>" -tostop"\n<line520>#endif\n<line521>#ifdef OFDEL\n<line522>" -ofdel"\n<line523>#endif\n<line524>#ifdef ECHOPRT\n<line525>" -echoprt"\n<line526>#endif\n<line527>#ifdef ECHOCTL\n<line528>" echoctl"\n<line529>#endif\n<line530>#ifdef ECHOKE\n<line531>" echoke"\n<line532>#endif\n<line533>#ifdef EXTPROC\n<line534>" -extproc"\n<line535>#endif\n<line536>#ifdef FLUSHO\n<line537>" -flusho"\n<line538>#endif\n<line539>);\n<line540>fputs (_("\\n<line541>\n\\n<line542>Handle the tty line connected to standard input.  Without arguments,\n\\n<line543>prints baud rate, line discipline, and deviations from stty sane.  In\n\\n<line544>settings, CHAR is taken literally, or coded as in ^c, 0x37, 0177 or\n\\n<line545>127; special values ^- or undef used to disable special characters.\n\\n<line546>"), stdout);\n<line547>emit_ancillary_info (PROGRAM_NAME);\n<line548>}\n<line549>exit (status);\n<line550>}
----------------------------------------
Function: apply_settings
Content: <line0>static void\n<line1>apply_settings (bool checking, char const *device_name,\n<line2>char * const *settings, int n_settings,\n<line3>struct termios *mode, bool *require_set_attr)\n<line4>{\n<line5>#define check_argument(arg)						\\n<line6>do									\\n<line7>{									\\n<line8>if (k == n_settings - 1 || ! settings[k + 1])			\\n<line9>{								\\n<line10>error (0, 0, _("missing argument to %s"), quote (arg));	\\n<line11>usage (EXIT_FAILURE);						\\n<line12>}								\\n<line13>}									\\n<line14>while (0)\n<line15>for (int k = 1; k < n_settings; k++)\n<line16>{\n<line17>char const *arg = settings[k];\n<line18>bool match_found = false;\n<line19>bool not_set_attr = false;\n<line20>bool reversed = false;\n<line21>int i;\n<line22>if (! arg)\n<line23>continue;\n<line24>if (arg[0] == '-')\n<line25>{\n<line26>++arg;\n<line27>reversed = true;\n<line28>}\n<line29>if (STREQ (arg, "drain"))\n<line30>{\n<line31>tcsetattr_options = reversed ? TCSANOW : TCSADRAIN;\n<line32>continue;\n<line33>}\n<line34>for (i = 0; mode_info[i].name != nullptr; ++i)\n<line35>{\n<line36>if (STREQ (arg, mode_info[i].name))\n<line37>{\n<line38>if ((mode_info[i].flags & NO_SETATTR) == 0)\n<line39>{\n<line40>match_found = set_mode (&mode_info[i], reversed, mode);\n<line41>*require_set_attr = true;\n<line42>}\n<line43>else\n<line44>match_found = not_set_attr = true;\n<line45>break;\n<line46>}\n<line47>}\n<line48>if (!match_found && reversed)\n<line49>{\n<line50>error (0, 0, _("invalid argument %s"), quote (arg - 1));\n<line51>usage (EXIT_FAILURE);\n<line52>}\n<line53>if (!match_found)\n<line54>{\n<line55>for (i = 0; control_info[i].name != nullptr; ++i)\n<line56>{\n<line57>if (STREQ (arg, control_info[i].name))\n<line58>{\n<line59>check_argument (arg);\n<line60>match_found = true;\n<line61>++k;\n<line62>set_control_char (&control_info[i], settings[k], mode);\n<line63>*require_set_attr = true;\n<line64>break;\n<line65>}\n<line66>}\n<line67>}\n<line68>if (!match_found || not_set_attr)\n<line69>{\n<line70>if (STREQ (arg, "ispeed"))\n<line71>{\n<line72>check_argument (arg);\n<line73>++k;\n<line74>if (string_to_baud (settings[k]) == (speed_t) -1)\n<line75>{\n<line76>error (0, 0, _("invalid ispeed %s"), quote (settings[k]));\n<line77>usage (EXIT_FAILURE);\n<line78>}\n<line79>set_speed (input_speed, settings[k], mode);\n<line80>if (checking)\n<line81>continue;\n<line82>*require_set_attr = true;\n<line83>}\n<line84>else if (STREQ (arg, "ospeed"))\n<line85>{\n<line86>check_argument (arg);\n<line87>++k;\n<line88>if (string_to_baud (settings[k]) == (speed_t) -1)\n<line89>{\n<line90>error (0, 0, _("invalid ospeed %s"), quote (settings[k]));\n<line91>usage (EXIT_FAILURE);\n<line92>}\n<line93>set_speed (output_speed, settings[k], mode);\n<line94>if (checking)\n<line95>continue;\n<line96>*require_set_attr = true;\n<line97>}\n<line98>#ifdef TIOCEXT\n<line99>/* This is the BSD interface to "extproc".\n<line100>Even though it's an lflag, an ioctl is used to set it.  */\n<line101>else if (STREQ (arg, "extproc"))\n<line102>{\n<line103>int val = ! reversed;\n<line104>if (checking)\n<line105>continue;\n<line106>if (ioctl (STDIN_FILENO, TIOCEXT, &val) != 0)\n<line107>error (EXIT_FAILURE, errno, _("%s: error setting %s"),\n<line108>quotef_n (0, device_name), quote_n (1, arg));\n<line109>}\n<line110>#endif\n<line111>#ifdef TIOCGWINSZ\n<line112>else if (STREQ (arg, "rows"))\n<line113>{\n<line114>check_argument (arg);\n<line115>++k;\n<line116>if (checking)\n<line117>continue;\n<line118>set_window_size (integer_arg (settings[k], INT_MAX), -1,\n<line119>device_name);\n<line120>}\n<line121>else if (STREQ (arg, "cols")\n<line122>|| STREQ (arg, "columns"))\n<line123>{\n<line124>check_argument (arg);\n<line125>++k;\n<line126>if (checking)\n<line127>continue;\n<line128>set_window_size (-1, integer_arg (settings[k], INT_MAX),\n<line129>device_name);\n<line130>}\n<line131>else if (STREQ (arg, "size"))\n<line132>{\n<line133>if (checking)\n<line134>continue;\n<line135>max_col = screen_columns ();\n<line136>current_col = 0;\n<line137>display_window_size (false, device_name);\n<line138>}\n<line139>#endif\n<line140>#ifdef HAVE_C_LINE\n<line141>else if (STREQ (arg, "line"))\n<line142>{\n<line143>unsigned long int value;\n<line144>check_argument (arg);\n<line145>++k;\n<line146>mode->c_line = value = integer_arg (settings[k], ULONG_MAX);\n<line147>if (mode->c_line != value)\n<line148>error (0, 0, _("invalid line discipline %s"),\n<line149>quote (settings[k]));\n<line150>*require_set_attr = true;\n<line151>}\n<line152>#endif\n<line153>else if (STREQ (arg, "speed"))\n<line154>{\n<line155>if (checking)\n<line156>continue;\n<line157>max_col = screen_columns ();\n<line158>display_speed (mode, false);\n<line159>}\n<line160>else if (string_to_baud (arg) != (speed_t) -1)\n<line161>{\n<line162>set_speed (both_speeds, arg, mode);\n<line163>if (checking)\n<line164>continue;\n<line165>*require_set_attr = true;\n<line166>}\n<line167>else\n<line168>{\n<line169>if (! recover_mode (arg, mode))\n<line170>{\n<line171>error (0, 0, _("invalid argument %s"), quote (arg));\n<line172>usage (EXIT_FAILURE);\n<line173>}\n<line174>*require_set_attr = true;\n<line175>}\n<line176>}\n<line177>}\n<line178>if (checking)\n<line179>check_speed (mode);\n<line180>}
----------------------------------------
Function: main
Content: <line0>int\n<line1>main (int argc, char **argv)\n<line2>{\n<line3>/* Initialize to all zeroes so there is no risk memcmp will report a\n<line4>spurious difference in an uninitialized portion of the structure.  */\n<line5>static struct termios mode;\n<line6>enum output_type output_type;\n<line7>int optc;\n<line8>int argi = 0;\n<line9>int opti = 1;\n<line10>bool require_set_attr;\n<line11>bool verbose_output;\n<line12>bool recoverable_output;\n<line13>bool noargs = true;\n<line14>char *file_name = nullptr;\n<line15>char const *device_name;\n<line16>initialize_main (&argc, &argv);\n<line17>set_program_name (argv[0]);\n<line18>setlocale (LC_ALL, "");\n<line19>bindtextdomain (PACKAGE, LOCALEDIR);\n<line20>textdomain (PACKAGE);\n<line21>atexit (close_stdout);\n<line22>output_type = changed;\n<line23>verbose_output = false;\n<line24>recoverable_output = false;\n<line25>/* Don't print error messages for unrecognized options.  */\n<line26>opterr = 0;\n<line27>/* If any new options are ever added to stty, the short options MUST\n<line28>NOT allow any ambiguity with the stty settings.  For example, the\n<line29>stty setting "-gagFork" would not be feasible, since it will be\n<line30>parsed as "-g -a -g -F ork".  If you change anything about how\n<line31>stty parses options, be sure it still works with combinations of\n<line32>short and long options, --, POSIXLY_CORRECT, etc.  */\n<line33>while ((optc = getopt_long (argc - argi, argv + argi, "-agF:",\n<line34>longopts, nullptr))\n<line35>!= -1)\n<line36>{\n<line37>switch (optc)\n<line38>{\n<line39>case 'a':\n<line40>verbose_output = true;\n<line41>output_type = all;\n<line42>break;\n<line43>case 'g':\n<line44>recoverable_output = true;\n<line45>output_type = recoverable;\n<line46>break;\n<line47>case 'F':\n<line48>if (file_name)\n<line49>error (EXIT_FAILURE, 0, _("only one device may be specified"));\n<line50>file_name = optarg;\n<line51>break;\n<line52>case DEV_DEBUG_OPTION:\n<line53>dev_debug = true;\n<line54>break;\n<line55>case_GETOPT_HELP_CHAR;\n<line56>case_GETOPT_VERSION_CHAR (PROGRAM_NAME, AUTHORS);\n<line57>default:\n<line58>/* Consider "drain" as an option rather than a setting,\n<line59>to support: alias stty='stty -drain'  etc.  */\n<line60>if (! STREQ (argv[argi + opti], "-drain")\n<line61>&& ! STREQ (argv[argi + opti], "drain"))\n<line62>noargs = false;\n<line63>/* Skip the argument containing this unrecognized option;\n<line64>the 2nd pass will analyze it.  */\n<line65>argi += opti;\n<line66>/* Restart getopt_long from the first unskipped argument.  */\n<line67>opti = 1;\n<line68>optind = 0;\n<line69>break;\n<line70>}\n<line71>/* Clear fully-parsed arguments, so they don't confuse the 2nd pass.  */\n<line72>while (opti < optind)\n<line73>argv[argi + opti++] = nullptr;\n<line74>}\n<line75>/* Specifying both -a and -g gets an error.  */\n<line76>if (verbose_output && recoverable_output)\n<line77>error (EXIT_FAILURE, 0,\n<line78>_("the options for verbose and stty-readable output styles are\n"\n<line79>"mutually exclusive"));\n<line80>/* Specifying any other arguments with -a or -g gets an error.  */\n<line81>if (!noargs && (verbose_output || recoverable_output))\n<line82>error (EXIT_FAILURE, 0,\n<line83>_("when specifying an output style, modes may not be set"));\n<line84>device_name = file_name ? file_name : _("standard input");\n<line85>if (!noargs && !verbose_output && !recoverable_output)\n<line86>{\n<line87>static struct termios check_mode;\n<line88>apply_settings (/* checking= */ true, device_name, argv, argc,\n<line89>&check_mode, &require_set_attr);\n<line90>}\n<line91>if (file_name)\n<line92>{\n<line93>int fdflags;\n<line94>if (fd_reopen (STDIN_FILENO, device_name, O_RDONLY | O_NONBLOCK, 0) < 0)\n<line95>error (EXIT_FAILURE, errno, "%s", quotef (device_name));\n<line96>if ((fdflags = fcntl (STDIN_FILENO, F_GETFL)) == -1\n<line97>|| fcntl (STDIN_FILENO, F_SETFL, fdflags & ~O_NONBLOCK) < 0)\n<line98>error (EXIT_FAILURE, errno, _("%s: couldn't reset non-blocking mode"),\n<line99>quotef (device_name));\n<line100>}\n<line101>if (tcgetattr (STDIN_FILENO, &mode))\n<line102>error (EXIT_FAILURE, errno, "%s", quotef (device_name));\n<line103>if (verbose_output || recoverable_output || noargs)\n<line104>{\n<line105>max_col = screen_columns ();\n<line106>current_col = 0;\n<line107>display_settings (output_type, &mode, device_name);\n<line108>return EXIT_SUCCESS;\n<line109>}\n<line110>require_set_attr = false;\n<line111>apply_settings (/* checking= */ false, device_name, argv, argc,\n<line112>&mode, &require_set_attr);\n<line113>if (require_set_attr)\n<line114>{\n<line115>/* Initialize to all zeroes so there is no risk memcmp will report a\n<line116>spurious difference in an uninitialized portion of the structure.  */\n<line117>static struct termios new_mode;\n<line118>if (tcsetattr (STDIN_FILENO, tcsetattr_options, &mode))\n<line119>error (EXIT_FAILURE, errno, "%s", quotef (device_name));\n<line120>/* POSIX (according to Zlotnick's book) tcsetattr returns zero if\n<line121>it performs *any* of the requested operations.  This means it\n<line122>can report 'success' when it has actually failed to perform\n<line123>some proper subset of the requested operations.  To detect\n<line124>this partial failure, get the current terminal attributes and\n<line125>compare them to the requested ones.  */\n<line126>if (tcgetattr (STDIN_FILENO, &new_mode))\n<line127>error (EXIT_FAILURE, errno, "%s", quotef (device_name));\n<line128>if (! eq_mode (&mode, &new_mode))\n<line129>{\n<line130>if (dev_debug)\n<line131>{\n<line132>error (0, 0, _("indx: mode: actual mode"));\n<line133>for (unsigned int i = 0; i < sizeof (new_mode); i++)\n<line134>{\n<line135>unsigned int newc = *(((unsigned char *) &new_mode) + i);\n<line136>unsigned int oldc = *(((unsigned char *) &mode) + i);\n<line137>error (0, 0, "0x%02x, 0x%02x: 0x%02x%s", i, oldc, newc,\n<line138>newc == oldc ? "" : " *");\n<line139>}\n<line140>}\n<line141>error (EXIT_FAILURE, 0,\n<line142>_("%s: unable to perform all requested operations"),\n<line143>quotef (device_name));\n<line144>}\n<line145>}\n<line146>return EXIT_SUCCESS;\n<line147>}
----------------------------------------
Function: eq_mode
Content: <line0>static bool\n<line1>eq_mode (struct termios *mode1, struct termios *mode2)\n<line2>{\n<line3>return mode1->c_iflag == mode2->c_iflag\n<line4>&& mode1->c_oflag == mode2->c_oflag\n<line5>&& mode1->c_cflag == mode2->c_cflag\n<line6>&& mode1->c_lflag == mode2->c_lflag\n<line7>#ifdef HAVE_C_LINE\n<line8>&& mode1->c_line == mode2->c_line\n<line9>#endif\n<line10>&& memcmp (mode1->c_cc, mode2->c_cc, sizeof (mode1->c_cc)) == 0\n<line11>&& cfgetispeed (mode1) == cfgetispeed (mode2)\n<line12>&& cfgetospeed (mode1) == cfgetospeed (mode2);\n<line13>}
----------------------------------------
Function: set_mode
Content: <line0>static bool\n<line1>set_mode (struct mode_info const *info, bool reversed, struct termios *mode)\n<line2>{\n<line3>tcflag_t *bitsp;\n<line4>if (reversed && (info->flags & REV) == 0)\n<line5>return false;\n<line6>bitsp = mode_type_flag (info->type, mode);\n<line7>if (bitsp == nullptr)\n<line8>{\n<line9>/* Combination mode. */\n<line10>if (STREQ (info->name, "evenp") || STREQ (info->name, "parity"))\n<line11>{\n<line12>if (reversed)\n<line13>mode->c_cflag = (mode->c_cflag & ~PARENB & ~CSIZE) | CS8;\n<line14>else\n<line15>mode->c_cflag = (mode->c_cflag & ~PARODD & ~CSIZE) | PARENB | CS7;\n<line16>}\n<line17>else if (STREQ (info->name, "oddp"))\n<line18>{\n<line19>if (reversed)\n<line20>mode->c_cflag = (mode->c_cflag & ~PARENB & ~CSIZE) | CS8;\n<line21>else\n<line22>mode->c_cflag = (mode->c_cflag & ~CSIZE) | CS7 | PARODD | PARENB;\n<line23>}\n<line24>else if (STREQ (info->name, "nl"))\n<line25>{\n<line26>if (reversed)\n<line27>{\n<line28>mode->c_iflag = (mode->c_iflag | ICRNL) & ~INLCR & ~IGNCR;\n<line29>mode->c_oflag = (mode->c_oflag\n<line30>#ifdef ONLCR\n<line31>| ONLCR\n<line32>#endif\n<line33>)\n<line34>#ifdef OCRNL\n<line35>& ~OCRNL\n<line36>#endif\n<line37>#ifdef ONLRET\n<line38>& ~ONLRET\n<line39>#endif\n<line40>;\n<line41>}\n<line42>else\n<line43>{\n<line44>mode->c_iflag = mode->c_iflag & ~ICRNL;\n<line45>#ifdef ONLCR\n<line46>mode->c_oflag = mode->c_oflag & ~ONLCR;\n<line47>#endif\n<line48>}\n<line49>}\n<line50>else if (STREQ (info->name, "ek"))\n<line51>{\n<line52>mode->c_cc[VERASE] = CERASE;\n<line53>mode->c_cc[VKILL] = CKILL;\n<line54>}\n<line55>else if (STREQ (info->name, "sane"))\n<line56>sane_mode (mode);\n<line57>else if (STREQ (info->name, "cbreak"))\n<line58>{\n<line59>if (reversed)\n<line60>mode->c_lflag |= ICANON;\n<line61>else\n<line62>mode->c_lflag &= ~ICANON;\n<line63>}\n<line64>else if (STREQ (info->name, "pass8"))\n<line65>{\n<line66>if (reversed)\n<line67>{\n<line68>mode->c_cflag = (mode->c_cflag & ~CSIZE) | CS7 | PARENB;\n<line69>mode->c_iflag |= ISTRIP;\n<line70>}\n<line71>else\n<line72>{\n<line73>mode->c_cflag = (mode->c_cflag & ~PARENB & ~CSIZE) | CS8;\n<line74>mode->c_iflag &= ~ISTRIP;\n<line75>}\n<line76>}\n<line77>else if (STREQ (info->name, "litout"))\n<line78>{\n<line79>if (reversed)\n<line80>{\n<line81>mode->c_cflag = (mode->c_cflag & ~CSIZE) | CS7 | PARENB;\n<line82>mode->c_iflag |= ISTRIP;\n<line83>mode->c_oflag |= OPOST;\n<line84>}\n<line85>else\n<line86>{\n<line87>mode->c_cflag = (mode->c_cflag & ~PARENB & ~CSIZE) | CS8;\n<line88>mode->c_iflag &= ~ISTRIP;\n<line89>mode->c_oflag &= ~OPOST;\n<line90>}\n<line91>}\n<line92>else if (STREQ (info->name, "raw") || STREQ (info->name, "cooked"))\n<line93>{\n<line94>if ((info->name[0] == 'r' && reversed)\n<line95>|| (info->name[0] == 'c' && !reversed))\n<line96>{\n<line97>/* Cooked mode. */\n<line98>mode->c_iflag |= BRKINT | IGNPAR | ISTRIP | ICRNL | IXON;\n<line99>mode->c_oflag |= OPOST;\n<line100>mode->c_lflag |= ISIG | ICANON;\n<line101>#if VMIN == VEOF\n<line102>mode->c_cc[VEOF] = CEOF;\n<line103>#endif\n<line104>#if VTIME == VEOL\n<line105>mode->c_cc[VEOL] = CEOL;\n<line106>#endif\n<line107>}\n<line108>else\n<line109>{\n<line110>/* Raw mode. */\n<line111>mode->c_iflag = 0;\n<line112>mode->c_oflag &= ~OPOST;\n<line113>mode->c_lflag &= ~(ISIG | ICANON\n<line114>#ifdef XCASE\n<line115>| XCASE\n<line116>#endif\n<line117>);\n<line118>mode->c_cc[VMIN] = 1;\n<line119>mode->c_cc[VTIME] = 0;\n<line120>}\n<line121>}\n<line122>#ifdef IXANY\n<line123>else if (STREQ (info->name, "decctlq"))\n<line124>{\n<line125>if (reversed)\n<line126>mode->c_iflag |= IXANY;\n<line127>else\n<line128>mode->c_iflag &= ~IXANY;\n<line129>}\n<line130>#endif\n<line131>#ifdef TABDLY\n<line132>else if (STREQ (info->name, "tabs"))\n<line133>{\n<line134>if (reversed)\n<line135>mode->c_oflag = (mode->c_oflag & ~TABDLY) | TAB3;\n<line136>else\n<line137>mode->c_oflag = (mode->c_oflag & ~TABDLY) | TAB0;\n<line138>}\n<line139>#else\n<line140># ifdef OXTABS\n<line141>else if (STREQ (info->name, "tabs"))\n<line142>{\n<line143>if (reversed)\n<line144>mode->c_oflag = mode->c_oflag | OXTABS;\n<line145>else\n<line146>mode->c_oflag = mode->c_oflag & ~OXTABS;\n<line147>}\n<line148># endif\n<line149>#endif\n<line150>#if defined XCASE && defined IUCLC && defined OLCUC\n<line151>else if (STREQ (info->name, "lcase")\n<line152>|| STREQ (info->name, "LCASE"))\n<line153>{\n<line154>if (reversed)\n<line155>{\n<line156>mode->c_lflag &= ~XCASE;\n<line157>mode->c_iflag &= ~IUCLC;\n<line158>mode->c_oflag &= ~OLCUC;\n<line159>}\n<line160>else\n<line161>{\n<line162>mode->c_lflag |= XCASE;\n<line163>mode->c_iflag |= IUCLC;\n<line164>mode->c_oflag |= OLCUC;\n<line165>}\n<line166>}\n<line167>#endif\n<line168>else if (STREQ (info->name, "crt"))\n<line169>mode->c_lflag |= ECHOE\n<line170>#ifdef ECHOCTL\n<line171>| ECHOCTL\n<line172>#endif\n<line173>#ifdef ECHOKE\n<line174>| ECHOKE\n<line175>#endif\n<line176>;\n<line177>else if (STREQ (info->name, "dec"))\n<line178>{\n<line179>mode->c_cc[VINTR] = 3;	/* ^C */\n<line180>mode->c_cc[VERASE] = 127;	/* DEL */\n<line181>mode->c_cc[VKILL] = 21;	/* ^U */\n<line182>mode->c_lflag |= ECHOE\n<line183>#ifdef ECHOCTL\n<line184>| ECHOCTL\n<line185>#endif\n<line186>#ifdef ECHOKE\n<line187>| ECHOKE\n<line188>#endif\n<line189>;\n<line190>#ifdef IXANY\n<line191>mode->c_iflag &= ~IXANY;\n<line192>#endif\n<line193>}\n<line194>}\n<line195>else if (reversed)\n<line196>*bitsp = *bitsp & ~info->mask & ~info->bits;\n<line197>else\n<line198>*bitsp = (*bitsp & ~info->mask) | info->bits;\n<line199>return true;\n<line200>}
----------------------------------------
Function: set_control_char
Content: <line0>static void\n<line1>set_control_char (struct control_info const *info, char const *arg,\n<line2>struct termios *mode)\n<line3>{\n<line4>unsigned long int value;\n<line5>if (STREQ (info->name, "min") || STREQ (info->name, "time"))\n<line6>value = integer_arg (arg, TYPE_MAXIMUM (cc_t));\n<line7>else if (arg[0] == '\0' || arg[1] == '\0')\n<line8>value = to_uchar (arg[0]);\n<line9>else if (STREQ (arg, "^-") || STREQ (arg, "undef"))\n<line10>value = _POSIX_VDISABLE;\n<line11>else if (arg[0] == '^' && arg[1] != '\0')	/* Ignore any trailing junk. */\n<line12>{\n<line13>if (arg[1] == '?')\n<line14>value = 127;\n<line15>else\n<line16>value = to_uchar (arg[1]) & ~0140; /* Non-letters get weird results. */\n<line17>}\n<line18>else\n<line19>value = integer_arg (arg, TYPE_MAXIMUM (cc_t));\n<line20>mode->c_cc[info->offset] = value;\n<line21>}
----------------------------------------
Function: set_speed
Content: <line0>static void\n<line1>set_speed (enum speed_setting type, char const *arg, struct termios *mode)\n<line2>{\n<line3>/* Note cfset[io]speed(), do not check with the device,\n<line4>and only check whether the system logic supports the specified speed.\n<line5>Therefore we don't report the device name in any errors.  */\n<line6>speed_t baud = string_to_baud (arg);\n<line7>affirm (baud != (speed_t) -1);\n<line8>if (type == input_speed || type == both_speeds)\n<line9>{\n<line10>last_ibaud = baud;\n<line11>if (cfsetispeed (mode, baud))\n<line12>error (EXIT_FAILURE, 0, _("unsupported ispeed %s"), quoteaf (arg));\n<line13>}\n<line14>if (type == output_speed || type == both_speeds)\n<line15>{\n<line16>last_obaud = baud;\n<line17>if (cfsetospeed (mode, baud))\n<line18>error (EXIT_FAILURE, 0, _("unsupported ospeed %s"), quoteaf (arg));\n<line19>}\n<line20>}
----------------------------------------
Function: get_win_size
Content: <line0>static int\n<line1>get_win_size (int fd, struct winsize *win)\n<line2>{\n<line3>int err = ioctl (fd, TIOCGWINSZ, (char *) win);\n<line4>return err;\n<line5>}
----------------------------------------
Function: set_window_size
Content: <line0>static void\n<line1>set_window_size (int rows, int cols, char const *device_name)\n<line2>{\n<line3>struct winsize win;\n<line4>if (get_win_size (STDIN_FILENO, &win))\n<line5>{\n<line6>if (errno != EINVAL)\n<line7>error (EXIT_FAILURE, errno, "%s", quotef (device_name));\n<line8>memset (&win, 0, sizeof (win));\n<line9>}\n<line10>if (rows >= 0)\n<line11>win.ws_row = rows;\n<line12>if (cols >= 0)\n<line13>win.ws_col = cols;\n<line14># ifdef TIOCSSIZE\n<line15>/* Alexander Dupuy <dupuy@cs.columbia.edu> wrote:\n<line16>The following code deals with a bug in the SunOS 4.x (and 3.x?) kernel.\n<line17>This comment from sys/ttold.h describes Sun's twisted logic - a better\n<line18>test would have been (ts_lines > 64k || ts_cols > 64k || ts_cols == 0).\n<line19>At any rate, the problem is gone in Solaris 2.x.\n<line20>Unfortunately, the old TIOCSSIZE code does collide with TIOCSWINSZ,\n<line21>but they can be disambiguated by checking whether a "struct ttysize"\n<line22>structure's "ts_lines" field is greater than 64K or not.  If so,\n<line23>it's almost certainly a "struct winsize" instead.\n<line24>At any rate, the bug manifests itself when ws_row == 0; the symptom is\n<line25>that ws_row is set to ws_col, and ws_col is set to (ws_xpixel<<16)\n<line26>+ ws_ypixel.  Since GNU stty sets rows and columns separately, this bug\n<line27>caused "stty rows 0 cols 0" to set rows to cols and cols to 0, while\n<line28>"stty cols 0 rows 0" would do the right thing.  On a little-endian\n<line29>machine like the sun386i, the problem is the same, but for ws_col == 0.\n<line30>The workaround is to do the ioctl once with row and col = 1 to set the\n<line31>pixel info, and then do it again using a TIOCSSIZE to set rows/cols.  */\n<line32>if (win.ws_row == 0 || win.ws_col == 0)\n<line33>{\n<line34>struct ttysize ttysz;\n<line35>ttysz.ts_lines = win.ws_row;\n<line36>ttysz.ts_cols = win.ws_col;\n<line37>win.ws_row = 1;\n<line38>win.ws_col = 1;\n<line39>if (ioctl (STDIN_FILENO, TIOCSWINSZ, (char *) &win))\n<line40>error (EXIT_FAILURE, errno, "%s", quotef (device_name));\n<line41>if (ioctl (STDIN_FILENO, TIOCSSIZE, (char *) &ttysz))\n<line42>error (EXIT_FAILURE, errno, "%s", quotef (device_name));\n<line43>return;\n<line44>}\n<line45># endif\n<line46>if (ioctl (STDIN_FILENO, TIOCSWINSZ, (char *) &win))\n<line47>error (EXIT_FAILURE, errno, "%s", quotef (device_name));\n<line48>}
----------------------------------------
Function: display_window_size
Content: <line0>static void\n<line1>display_window_size (bool fancy, char const *device_name)\n<line2>{\n<line3>struct winsize win;\n<line4>if (get_win_size (STDIN_FILENO, &win))\n<line5>{\n<line6>if (errno != EINVAL)\n<line7>error (EXIT_FAILURE, errno, "%s", quotef (device_name));\n<line8>if (!fancy)\n<line9>error (EXIT_FAILURE, 0,\n<line10>_("%s: no size information for this device"),\n<line11>quotef (device_name));\n<line12>}\n<line13>else\n<line14>{\n<line15>wrapf (fancy ? "rows %d; columns %d;" : "%d %d\n",\n<line16>win.ws_row, win.ws_col);\n<line17>if (!fancy)\n<line18>current_col = 0;\n<line19>}\n<line20>}
----------------------------------------
Function: screen_columns
Content: <line0>static int\n<line1>screen_columns (void)\n<line2>{\n<line3>#ifdef TIOCGWINSZ\n<line4>struct winsize win;\n<line5>/* With Solaris 2.[123], this ioctl fails and errno is set to\n<line6>EINVAL for telnet (but not rlogin) sessions.\n<line7>On ISC 3.0, it fails for the console and the serial port\n<line8>(but it works for ptys).\n<line9>It can also fail on any system when stdout isn't a tty.\n<line10>In case of any failure, just use the default.  */\n<line11>if (get_win_size (STDOUT_FILENO, &win) == 0 && 0 < win.ws_col)\n<line12>return win.ws_col;\n<line13>#endif\n<line14>{\n<line15>/* Use $COLUMNS if it's in [1..INT_MAX].  */\n<line16>char *col_string = getenv ("COLUMNS");\n<line17>long int n_columns;\n<line18>if (!(col_string != nullptr\n<line19>&& xstrtol (col_string, nullptr, 0, &n_columns, "") == LONGINT_OK\n<line20>&& 0 < n_columns\n<line21>&& n_columns <= INT_MAX))\n<line22>n_columns = 80;\n<line23>return n_columns;\n<line24>}\n<line25>}
----------------------------------------
Function: display_settings
Content: <line0>static void\n<line1>display_settings (enum output_type output_type, struct termios *mode,\n<line2>char const *device_name)\n<line3>{\n<line4>switch (output_type)\n<line5>{\n<line6>case changed:\n<line7>display_changed (mode);\n<line8>break;\n<line9>case all:\n<line10>display_all (mode, device_name);\n<line11>break;\n<line12>case recoverable:\n<line13>display_recoverable (mode);\n<line14>break;\n<line15>}\n<line16>}
----------------------------------------
Function: display_changed
Content: <line0>static void\n<line1>display_changed (struct termios *mode)\n<line2>{\n<line3>int i;\n<line4>bool empty_line;\n<line5>tcflag_t *bitsp;\n<line6>unsigned long mask;\n<line7>enum mode_type prev_type = control;\n<line8>display_speed (mode, true);\n<line9>#ifdef HAVE_C_LINE\n<line10>wrapf ("line = %d;", mode->c_line);\n<line11>#endif\n<line12>putchar ('\n');\n<line13>current_col = 0;\n<line14>empty_line = true;\n<line15>for (i = 0; !STREQ (control_info[i].name, "min"); ++i)\n<line16>{\n<line17>if (mode->c_cc[control_info[i].offset] == control_info[i].saneval)\n<line18>continue;\n<line19>#ifdef VFLUSHO\n<line20>/* 'flush' is the deprecated equivalent of 'discard'.  */\n<line21>if (STREQ (control_info[i].name, "flush"))\n<line22>continue;\n<line23>#endif\n<line24>/* If swtch is the same as susp, don't print both.  */\n<line25>#if VSWTCH == VSUSP\n<line26>if (STREQ (control_info[i].name, "swtch"))\n<line27>continue;\n<line28>#endif\n<line29>/* If eof uses the same slot as min, only print whichever applies.  */\n<line30>#if VEOF == VMIN\n<line31>if ((mode->c_lflag & ICANON) == 0\n<line32>&& (STREQ (control_info[i].name, "eof")\n<line33>|| STREQ (control_info[i].name, "eol")))\n<line34>continue;\n<line35>#endif\n<line36>empty_line = false;\n<line37>wrapf ("%s = %s;", control_info[i].name,\n<line38>visible (mode->c_cc[control_info[i].offset]));\n<line39>}\n<line40>if ((mode->c_lflag & ICANON) == 0)\n<line41>{\n<line42>wrapf ("min = %lu; time = %lu;\n",\n<line43>(unsigned long int) mode->c_cc[VMIN],\n<line44>(unsigned long int) mode->c_cc[VTIME]);\n<line45>}\n<line46>else if (!empty_line)\n<line47>putchar ('\n');\n<line48>current_col = 0;\n<line49>empty_line = true;\n<line50>for (i = 0; mode_info[i].name != nullptr; ++i)\n<line51>{\n<line52>if (mode_info[i].flags & OMIT)\n<line53>continue;\n<line54>if (mode_info[i].type != prev_type)\n<line55>{\n<line56>if (!empty_line)\n<line57>{\n<line58>putchar ('\n');\n<line59>current_col = 0;\n<line60>empty_line = true;\n<line61>}\n<line62>prev_type = mode_info[i].type;\n<line63>}\n<line64>bitsp = mode_type_flag (mode_info[i].type, mode);\n<line65>mask = mode_info[i].mask ? mode_info[i].mask : mode_info[i].bits;\n<line66>if ((*bitsp & mask) == mode_info[i].bits)\n<line67>{\n<line68>if (mode_info[i].flags & SANE_UNSET)\n<line69>{\n<line70>wrapf ("%s", mode_info[i].name);\n<line71>empty_line = false;\n<line72>}\n<line73>}\n<line74>else if ((mode_info[i].flags & (SANE_SET | REV)) == (SANE_SET | REV))\n<line75>{\n<line76>wrapf ("-%s", mode_info[i].name);\n<line77>empty_line = false;\n<line78>}\n<line79>}\n<line80>if (!empty_line)\n<line81>putchar ('\n');\n<line82>current_col = 0;\n<line83>}
----------------------------------------
Function: display_all
Content: <line0>static void\n<line1>display_all (struct termios *mode, char const *device_name)\n<line2>{\n<line3>int i;\n<line4>tcflag_t *bitsp;\n<line5>unsigned long mask;\n<line6>enum mode_type prev_type = control;\n<line7>display_speed (mode, true);\n<line8>#ifdef TIOCGWINSZ\n<line9>display_window_size (true, device_name);\n<line10>#endif\n<line11>#ifdef HAVE_C_LINE\n<line12>wrapf ("line = %d;", mode->c_line);\n<line13>#endif\n<line14>putchar ('\n');\n<line15>current_col = 0;\n<line16>for (i = 0; ! STREQ (control_info[i].name, "min"); ++i)\n<line17>{\n<line18>#ifdef VFLUSHO\n<line19>/* 'flush' is the deprecated equivalent of 'discard'.  */\n<line20>if (STREQ (control_info[i].name, "flush"))\n<line21>continue;\n<line22>#endif\n<line23>/* If swtch is the same as susp, don't print both.  */\n<line24>#if VSWTCH == VSUSP\n<line25>if (STREQ (control_info[i].name, "swtch"))\n<line26>continue;\n<line27>#endif\n<line28>/* If eof uses the same slot as min, only print whichever applies.  */\n<line29>#if VEOF == VMIN\n<line30>if ((mode->c_lflag & ICANON) == 0\n<line31>&& (STREQ (control_info[i].name, "eof")\n<line32>|| STREQ (control_info[i].name, "eol")))\n<line33>continue;\n<line34>#endif\n<line35>wrapf ("%s = %s;", control_info[i].name,\n<line36>visible (mode->c_cc[control_info[i].offset]));\n<line37>}\n<line38>#if VEOF == VMIN\n<line39>if ((mode->c_lflag & ICANON) == 0)\n<line40>#endif\n<line41>wrapf ("min = %lu; time = %lu;",\n<line42>(unsigned long int) mode->c_cc[VMIN],\n<line43>(unsigned long int) mode->c_cc[VTIME]);\n<line44>if (current_col != 0)\n<line45>putchar ('\n');\n<line46>current_col = 0;\n<line47>for (i = 0; mode_info[i].name != nullptr; ++i)\n<line48>{\n<line49>if (mode_info[i].flags & OMIT)\n<line50>continue;\n<line51>if (mode_info[i].type != prev_type)\n<line52>{\n<line53>putchar ('\n');\n<line54>current_col = 0;\n<line55>prev_type = mode_info[i].type;\n<line56>}\n<line57>bitsp = mode_type_flag (mode_info[i].type, mode);\n<line58>mask = mode_info[i].mask ? mode_info[i].mask : mode_info[i].bits;\n<line59>if ((*bitsp & mask) == mode_info[i].bits)\n<line60>wrapf ("%s", mode_info[i].name);\n<line61>else if (mode_info[i].flags & REV)\n<line62>wrapf ("-%s", mode_info[i].name);\n<line63>}\n<line64>putchar ('\n');\n<line65>current_col = 0;\n<line66>}
----------------------------------------
Function: check_speed
Content: <line0>static void\n<line1>check_speed (struct termios *mode)\n<line2>{\n<line3>if (last_ibaud != -1 && last_obaud != -1)\n<line4>{\n<line5>if (cfgetispeed (mode) != last_ibaud\n<line6>|| cfgetospeed (mode) != last_obaud)\n<line7>error (EXIT_FAILURE, 0,\n<line8>_("asymmetric input (%lu), output (%lu) speeds not supported"),\n<line9>baud_to_value (last_ibaud), baud_to_value (last_obaud));\n<line10>}\n<line11>}
----------------------------------------
Function: display_speed
Content: <line0>static void\n<line1>display_speed (struct termios *mode, bool fancy)\n<line2>{\n<line3>if (cfgetispeed (mode) == 0 || cfgetispeed (mode) == cfgetospeed (mode))\n<line4>wrapf (fancy ? "speed %lu baud;" : "%lu\n",\n<line5>baud_to_value (cfgetospeed (mode)));\n<line6>else\n<line7>wrapf (fancy ? "ispeed %lu baud; ospeed %lu baud;" : "%lu %lu\n",\n<line8>baud_to_value (cfgetispeed (mode)),\n<line9>baud_to_value (cfgetospeed (mode)));\n<line10>if (!fancy)\n<line11>current_col = 0;\n<line12>}
----------------------------------------
Function: display_recoverable
Content: <line0>static void\n<line1>display_recoverable (struct termios *mode)\n<line2>{\n<line3>printf ("%lx:%lx:%lx:%lx",\n<line4>(unsigned long int) mode->c_iflag,\n<line5>(unsigned long int) mode->c_oflag,\n<line6>(unsigned long int) mode->c_cflag,\n<line7>(unsigned long int) mode->c_lflag);\n<line8>for (size_t i = 0; i < NCCS; ++i)\n<line9>printf (":%lx", (unsigned long int) mode->c_cc[i]);\n<line10>putchar ('\n');\n<line11>}
----------------------------------------
Function: strtoul_tcflag_t
Content: <line0>static int\n<line1>strtoul_tcflag_t (char const *s, int base, char **p, tcflag_t *result,\n<line2>char delim)\n<line3>{\n<line4>unsigned long ul;\n<line5>errno = 0;\n<line6>ul = strtoul (s, p, base);\n<line7>if (errno || **p != delim || *p == s || (tcflag_t) ul != ul)\n<line8>return -1;\n<line9>*result = ul;\n<line10>return 0;\n<line11>}
----------------------------------------
Function: strtoul_cc_t
Content: <line0>static int\n<line1>strtoul_cc_t (char const *s, int base, char **p, cc_t *result, char delim)\n<line2>{\n<line3>unsigned long ul;\n<line4>errno = 0;\n<line5>ul = strtoul (s, p, base);\n<line6>if (errno || **p != delim || *p == s || (cc_t) ul != ul)\n<line7>return -1;\n<line8>*result = ul;\n<line9>return 0;\n<line10>}
----------------------------------------
Function: recover_mode
Content: <line0>static bool\n<line1>recover_mode (char const *arg, struct termios *mode)\n<line2>{\n<line3>tcflag_t flag[4];\n<line4>char const *s = arg;\n<line5>size_t i;\n<line6>for (i = 0; i < 4; i++)\n<line7>{\n<line8>char *p;\n<line9>if (strtoul_tcflag_t (s, 16, &p, flag + i, ':') != 0)\n<line10>return false;\n<line11>s = p + 1;\n<line12>}\n<line13>mode->c_iflag = flag[0];\n<line14>mode->c_oflag = flag[1];\n<line15>mode->c_cflag = flag[2];\n<line16>mode->c_lflag = flag[3];\n<line17>for (i = 0; i < NCCS; ++i)\n<line18>{\n<line19>char *p;\n<line20>char delim = i < NCCS - 1 ? ':' : '\0';\n<line21>if (strtoul_cc_t (s, 16, &p, mode->c_cc + i, delim) != 0)\n<line22>return false;\n<line23>s = p + 1;\n<line24>}\n<line25>return true;\n<line26>}
----------------------------------------
Function: sane_mode
Content: <line0>static void\n<line1>sane_mode (struct termios *mode)\n<line2>{\n<line3>int i;\n<line4>tcflag_t *bitsp;\n<line5>for (i = 0; control_info[i].name; ++i)\n<line6>{\n<line7>#if VMIN == VEOF\n<line8>if (STREQ (control_info[i].name, "min"))\n<line9>break;\n<line10>#endif\n<line11>mode->c_cc[control_info[i].offset] = control_info[i].saneval;\n<line12>}\n<line13>for (i = 0; mode_info[i].name != nullptr; ++i)\n<line14>{\n<line15>if (mode_info[i].flags & NO_SETATTR)\n<line16>continue;\n<line17>if (mode_info[i].flags & SANE_SET)\n<line18>{\n<line19>bitsp = mode_type_flag (mode_info[i].type, mode);\n<line20>assume (bitsp); /* combination modes will not have SANE_SET.  */\n<line21>*bitsp = (*bitsp & ~mode_info[i].mask) | mode_info[i].bits;\n<line22>}\n<line23>else if (mode_info[i].flags & SANE_UNSET)\n<line24>{\n<line25>bitsp = mode_type_flag (mode_info[i].type, mode);\n<line26>assume (bitsp); /* combination modes will not have SANE_UNSET.  */\n<line27>*bitsp = *bitsp & ~mode_info[i].mask & ~mode_info[i].bits;\n<line28>}\n<line29>}\n<line30>}
----------------------------------------
Function: visible
Content: <line0>static char const *\n<line1>visible (cc_t ch)\n<line2>{\n<line3>static char buf[10];\n<line4>char *bpout = buf;\n<line5>if (ch == _POSIX_VDISABLE)\n<line6>return "<undef>";\n<line7>if (ch >= 32)\n<line8>{\n<line9>if (ch < 127)\n<line10>*bpout++ = ch;\n<line11>else if (ch == 127)\n<line12>{\n<line13>*bpout++ = '^';\n<line14>*bpout++ = '?';\n<line15>}\n<line16>else\n<line17>{\n<line18>*bpout++ = 'M';\n<line19>*bpout++ = '-';\n<line20>if (ch >= 128 + 32)\n<line21>{\n<line22>if (ch < 128 + 127)\n<line23>*bpout++ = ch - 128;\n<line24>else\n<line25>{\n<line26>*bpout++ = '^';\n<line27>*bpout++ = '?';\n<line28>}\n<line29>}\n<line30>else\n<line31>{\n<line32>*bpout++ = '^';\n<line33>*bpout++ = ch - 128 + 64;\n<line34>}\n<line35>}\n<line36>}\n<line37>else\n<line38>{\n<line39>*bpout++ = '^';\n<line40>*bpout++ = ch + 64;\n<line41>}\n<line42>*bpout = '\0';\n<line43>return (char const *) buf;\n<line44>}
----------------------------------------
Function: integer_arg
Content: <line0>static unsigned long int\n<line1>integer_arg (char const *s, unsigned long int maxval)\n<line2>{\n<line3>return xnumtoumax (s, 0, 0, maxval, "bB", _("invalid integer argument"), 0);\n<line4>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/src/df.c
========================================
Function: automount_stat_err
Content: <line0>static int\n<line1>automount_stat_err (char const *file, struct stat *st)\n<line2>{\n<line3>int fd = open (file, O_RDONLY | O_NOCTTY | O_NONBLOCK);\n<line4>if (fd < 0)\n<line5>{\n<line6>if (errno == ENOENT || errno == ENOTDIR)\n<line7>return errno;\n<line8>return stat (file, st) == 0 ? 0 : errno;\n<line9>}\n<line10>else\n<line11>{\n<line12>int err = fstat (fd, st) == 0 ? 0 : errno;\n<line13>close (fd);\n<line14>return err;\n<line15>}\n<line16>}
----------------------------------------
Function: replace_control_chars
Content: <line0>static void\n<line1>replace_control_chars (char *cell)\n<line2>{\n<line3>char *p = cell;\n<line4>while (*p)\n<line5>{\n<line6>if (c_iscntrl (to_uchar (*p)))\n<line7>*p = '?';\n<line8>p++;\n<line9>}\n<line10>}
----------------------------------------
Function: replace_invalid_chars
Content: <line0>static void\n<line1>replace_invalid_chars (char *cell)\n<line2>{\n<line3>char *srcend = cell + strlen (cell);\n<line4>char *dst = cell;\n<line5>mbstate_t mbstate = { 0, };\n<line6>size_t n;\n<line7>for (char *src = cell; src != srcend; src += n)\n<line8>{\n<line9>wchar_t wc;\n<line10>size_t srcbytes = srcend - src;\n<line11>n = mbrtowc (&wc, src, srcbytes, &mbstate);\n<line12>bool ok = n <= srcbytes;\n<line13>if (ok)\n<line14>ok = !iswcntrl (wc);\n<line15>else\n<line16>n = 1;\n<line17>if (ok)\n<line18>{\n<line19>memmove (dst, src, n);\n<line20>dst += n;\n<line21>}\n<line22>else\n<line23>{\n<line24>*dst++ = '?';\n<line25>memset (&mbstate, 0, sizeof mbstate);\n<line26>}\n<line27>}\n<line28>*dst = '\0';\n<line29>}
----------------------------------------
Function: replace_problematic_chars
Content: <line0>static void\n<line1>replace_problematic_chars (char *cell)\n<line2>{\n<line3>static int tty_out = -1;\n<line4>if (tty_out < 0)\n<line5>tty_out = isatty (STDOUT_FILENO);\n<line6>(tty_out ? replace_invalid_chars : replace_control_chars) (cell) ;\n<line7>}
----------------------------------------
Function: alloc_table_row
Content: <line0>static void\n<line1>alloc_table_row (void)\n<line2>{\n<line3>nrows++;\n<line4>table = xnrealloc (table, nrows, sizeof (char **));\n<line5>table[nrows - 1] = xnmalloc (ncolumns, sizeof (char *));\n<line6>}
----------------------------------------
Function: print_table
Content: <line0>static void\n<line1>print_table (void)\n<line2>{\n<line3>size_t row;\n<line4>for (row = 0; row < nrows; row++)\n<line5>{\n<line6>size_t col;\n<line7>for (col = 0; col < ncolumns; col++)\n<line8>{\n<line9>char *cell = table[row][col];\n<line10>/* Note the SOURCE_FIELD used to be displayed on it's own line\n<line11>if (!posix_format && mbswidth (cell) > 20), but that\n<line12>functionality was probably more problematic than helpful,\n<line13>hence changed in commit v8.10-40-g99679ff.  */\n<line14>if (col != 0)\n<line15>putchar (' ');\n<line16>int flags = 0;\n<line17>if (col == ncolumns - 1) /* The last one.  */\n<line18>flags = MBA_NO_RIGHT_PAD;\n<line19>size_t width = columns[col]->width;\n<line20>cell = ambsalign (cell, &width, columns[col]->align, flags);\n<line21>/* When ambsalign fails, output unaligned data.  */\n<line22>fputs (cell ? cell : table[row][col], stdout);\n<line23>free (cell);\n<line24>}\n<line25>putchar ('\n');\n<line26>}\n<line27>}
----------------------------------------
Function: alloc_field
Content: <line0>static void\n<line1>alloc_field (int f, char const *c)\n<line2>{\n<line3>ncolumns++;\n<line4>columns = xnrealloc (columns, ncolumns, sizeof (struct field_data_t *));\n<line5>columns[ncolumns - 1] = &field_data[f];\n<line6>if (c != nullptr)\n<line7>columns[ncolumns - 1]->caption = c;\n<line8>affirm (!field_data[f].used);\n<line9>/* Mark field as used.  */\n<line10>field_data[f].used = true;\n<line11>}
----------------------------------------
Function: decode_output_arg
Content: <line0>static void\n<line1>decode_output_arg (char const *arg)\n<line2>{\n<line3>char *arg_writable = xstrdup (arg);\n<line4>char *s = arg_writable;\n<line5>do\n<line6>{\n<line7>/* find next comma */\n<line8>char *comma = strchr (s, ',');\n<line9>/* If we found a comma, put a NUL in its place and advance.  */\n<line10>if (comma)\n<line11>*comma++ = 0;\n<line12>/* process S.  */\n<line13>display_field_t field = INVALID_FIELD;\n<line14>for (idx_t i = 0; i < ARRAY_CARDINALITY (field_data); i++)\n<line15>{\n<line16>if (STREQ (field_data[i].arg, s))\n<line17>{\n<line18>field = i;\n<line19>break;\n<line20>}\n<line21>}\n<line22>if (field == INVALID_FIELD)\n<line23>{\n<line24>error (0, 0, _("option --output: field %s unknown"), quote (s));\n<line25>usage (EXIT_FAILURE);\n<line26>}\n<line27>if (field_data[field].used)\n<line28>{\n<line29>/* Prevent the fields from being used more than once.  */\n<line30>error (0, 0, _("option --output: field %s used more than once"),\n<line31>quote (field_data[field].arg));\n<line32>usage (EXIT_FAILURE);\n<line33>}\n<line34>switch (field)\n<line35>{\n<line36>case SOURCE_FIELD:\n<line37>case FSTYPE_FIELD:\n<line38>case USED_FIELD:\n<line39>case PCENT_FIELD:\n<line40>case ITOTAL_FIELD:\n<line41>case IUSED_FIELD:\n<line42>case IAVAIL_FIELD:\n<line43>case IPCENT_FIELD:\n<line44>case TARGET_FIELD:\n<line45>case FILE_FIELD:\n<line46>alloc_field (field, nullptr);\n<line47>break;\n<line48>case SIZE_FIELD:\n<line49>alloc_field (field, N_("Size"));\n<line50>break;\n<line51>case AVAIL_FIELD:\n<line52>alloc_field (field, N_("Avail"));\n<line53>break;\n<line54>default:\n<line55>affirm (!"invalid field");\n<line56>}\n<line57>s = comma;\n<line58>}\n<line59>while (s);\n<line60>free (arg_writable);\n<line61>}
----------------------------------------
Function: get_field_list
Content: <line0>static void\n<line1>get_field_list (void)\n<line2>{\n<line3>switch (header_mode)\n<line4>{\n<line5>case DEFAULT_MODE:\n<line6>alloc_field (SOURCE_FIELD, nullptr);\n<line7>if (print_type)\n<line8>alloc_field (FSTYPE_FIELD, nullptr);\n<line9>alloc_field (SIZE_FIELD,   nullptr);\n<line10>alloc_field (USED_FIELD,   nullptr);\n<line11>alloc_field (AVAIL_FIELD,  nullptr);\n<line12>alloc_field (PCENT_FIELD,  nullptr);\n<line13>alloc_field (TARGET_FIELD, nullptr);\n<line14>break;\n<line15>case HUMAN_MODE:\n<line16>alloc_field (SOURCE_FIELD, nullptr);\n<line17>if (print_type)\n<line18>alloc_field (FSTYPE_FIELD, nullptr);\n<line19>alloc_field (SIZE_FIELD,   N_("Size"));\n<line20>alloc_field (USED_FIELD,   nullptr);\n<line21>alloc_field (AVAIL_FIELD,  N_("Avail"));\n<line22>alloc_field (PCENT_FIELD,  nullptr);\n<line23>alloc_field (TARGET_FIELD, nullptr);\n<line24>break;\n<line25>case INODES_MODE:\n<line26>alloc_field (SOURCE_FIELD, nullptr);\n<line27>if (print_type)\n<line28>alloc_field (FSTYPE_FIELD, nullptr);\n<line29>alloc_field (ITOTAL_FIELD,  nullptr);\n<line30>alloc_field (IUSED_FIELD,   nullptr);\n<line31>alloc_field (IAVAIL_FIELD,  nullptr);\n<line32>alloc_field (IPCENT_FIELD,  nullptr);\n<line33>alloc_field (TARGET_FIELD,  nullptr);\n<line34>break;\n<line35>case POSIX_MODE:\n<line36>alloc_field (SOURCE_FIELD, nullptr);\n<line37>if (print_type)\n<line38>alloc_field (FSTYPE_FIELD, nullptr);\n<line39>alloc_field (SIZE_FIELD,   nullptr);\n<line40>alloc_field (USED_FIELD,   nullptr);\n<line41>alloc_field (AVAIL_FIELD,  nullptr);\n<line42>alloc_field (PCENT_FIELD,  N_("Capacity"));\n<line43>alloc_field (TARGET_FIELD, nullptr);\n<line44>break;\n<line45>case OUTPUT_MODE:\n<line46>if (!ncolumns)\n<line47>{\n<line48>/* Add all fields if --output was given without a field list.  */\n<line49>decode_output_arg (all_args_string);\n<line50>}\n<line51>break;\n<line52>default:\n<line53>unreachable ();\n<line54>}\n<line55>}
----------------------------------------
Function: get_header
Content: <line0>static void\n<line1>get_header (void)\n<line2>{\n<line3>size_t col;\n<line4>alloc_table_row ();\n<line5>for (col = 0; col < ncolumns; col++)\n<line6>{\n<line7>char *cell = nullptr;\n<line8>char const *header = _(columns[col]->caption);\n<line9>if (columns[col]->field == SIZE_FIELD\n<line10>&& (header_mode == DEFAULT_MODE\n<line11>|| (header_mode == OUTPUT_MODE\n<line12>&& !(human_output_opts & human_autoscale))))\n<line13>{\n<line14>char buf[LONGEST_HUMAN_READABLE + 1];\n<line15>int opts = (human_suppress_point_zero\n<line16>| human_autoscale | human_SI\n<line17>| (human_output_opts\n<line18>& (human_group_digits | human_base_1024 | human_B)));\n<line19>/* Prefer the base that makes the human-readable value more exact,\n<line20>if there is a difference.  */\n<line21>uintmax_t q1000 = output_block_size;\n<line22>uintmax_t q1024 = output_block_size;\n<line23>bool divisible_by_1000;\n<line24>bool divisible_by_1024;\n<line25>do\n<line26>{\n<line27>divisible_by_1000 = q1000 % 1000 == 0;  q1000 /= 1000;\n<line28>divisible_by_1024 = q1024 % 1024 == 0;  q1024 /= 1024;\n<line29>}\n<line30>while (divisible_by_1000 & divisible_by_1024);\n<line31>if (divisible_by_1000 < divisible_by_1024)\n<line32>opts |= human_base_1024;\n<line33>if (divisible_by_1024 < divisible_by_1000)\n<line34>opts &= ~human_base_1024;\n<line35>if (! (opts & human_base_1024))\n<line36>opts |= human_B;\n<line37>char *num = human_readable (output_block_size, buf, opts, 1, 1);\n<line38>/* Reset the header back to the default in OUTPUT_MODE.  */\n<line39>header = _("blocks");\n<line40>/* TRANSLATORS: this is the "1K-blocks" header in "df" output.  */\n<line41>if (asprintf (&cell, _("%s-%s"), num, header) == -1)\n<line42>cell = nullptr;\n<line43>}\n<line44>else if (header_mode == POSIX_MODE && columns[col]->field == SIZE_FIELD)\n<line45>{\n<line46>char buf[INT_BUFSIZE_BOUND (uintmax_t)];\n<line47>char *num = umaxtostr (output_block_size, buf);\n<line48>/* TRANSLATORS: this is the "1024-blocks" header in "df -P".  */\n<line49>if (asprintf (&cell, _("%s-%s"), num, header) == -1)\n<line50>cell = nullptr;\n<line51>}\n<line52>else\n<line53>cell = strdup (header);\n<line54>if (!cell)\n<line55>xalloc_die ();\n<line56>replace_problematic_chars (cell);\n<line57>table[nrows - 1][col] = cell;\n<line58>size_t cell_width = mbswidth (cell, 0);\n<line59>columns[col]->width = MAX (columns[col]->width, cell_width);\n<line60>}\n<line61>}
----------------------------------------
Function: devlist_hash
Content: <line0>static size_t\n<line1>devlist_hash (void const *x, size_t table_size)\n<line2>{\n<line3>struct devlist const *p = x;\n<line4>return (uintmax_t) p->dev_num % table_size;\n<line5>}
----------------------------------------
Function: devlist_compare
Content: <line0>static bool\n<line1>devlist_compare (void const *x, void const *y)\n<line2>{\n<line3>struct devlist const *a = x;\n<line4>struct devlist const *b = y;\n<line5>return a->dev_num == b->dev_num;\n<line6>}
----------------------------------------
Function: devlist_for_dev
Content: <line0>static struct devlist *\n<line1>devlist_for_dev (dev_t dev)\n<line2>{\n<line3>if (devlist_table == nullptr)\n<line4>return nullptr;\n<line5>struct devlist dev_entry;\n<line6>dev_entry.dev_num = dev;\n<line7>struct devlist *found = hash_lookup (devlist_table, &dev_entry);\n<line8>if (found == nullptr)\n<line9>return nullptr;\n<line10>/* Return the last devlist entry we have seen with this dev_num */\n<line11>return found->seen_last;\n<line12>}
----------------------------------------
Function: filter_mount_list
Content: <line0>static void\n<line1>filter_mount_list (bool devices_only)\n<line2>{\n<line3>struct mount_entry *me;\n<line4>/* Temporary list to keep entries ordered.  */\n<line5>struct devlist *device_list = nullptr;\n<line6>int mount_list_size = 0;\n<line7>for (me = mount_list; me; me = me->me_next)\n<line8>mount_list_size++;\n<line9>devlist_table = hash_initialize (mount_list_size, nullptr,\n<line10>devlist_hash, devlist_compare, nullptr);\n<line11>if (devlist_table == nullptr)\n<line12>xalloc_die ();\n<line13>/* Sort all 'wanted' entries into the list device_list.  */\n<line14>for (me = mount_list; me;)\n<line15>{\n<line16>struct stat buf;\n<line17>struct mount_entry *discard_me = nullptr;\n<line18>/* Avoid stating remote file systems as that may hang.\n<line19>On Linux we probably have me_dev populated from /proc/self/mountinfo,\n<line20>however we still stat() in case another device was mounted later.  */\n<line21>if ((me->me_remote && show_local_fs)\n<line22>|| (me->me_dummy && !show_all_fs && !show_listed_fs)\n<line23>|| (!selected_fstype (me->me_type) || excluded_fstype (me->me_type))\n<line24>|| -1 == stat (me->me_mountdir, &buf))\n<line25>{\n<line26>/* If remote, and showing just local, or FS type is excluded,\n<line27>add ME for filtering later.\n<line28>If stat failed; add ME to be able to complain about it later.  */\n<line29>buf.st_dev = me->me_dev;\n<line30>}\n<line31>else\n<line32>{\n<line33>/* If we've already seen this device...  */\n<line34>struct devlist *seen_dev = devlist_for_dev (buf.st_dev);\n<line35>if (seen_dev)\n<line36>{\n<line37>bool target_nearer_root = strlen (seen_dev->me->me_mountdir)\n<line38>> strlen (me->me_mountdir);\n<line39>/* With bind mounts, prefer items nearer the root of the source */\n<line40>bool source_below_root = seen_dev->me->me_mntroot != nullptr\n<line41>&& me->me_mntroot != nullptr\n<line42>&& (strlen (seen_dev->me->me_mntroot)\n<line43>< strlen (me->me_mntroot));\n<line44>if (! print_grand_total\n<line45>&& me->me_remote && seen_dev->me->me_remote\n<line46>&& ! STREQ (seen_dev->me->me_devname, me->me_devname))\n<line47>{\n<line48>/* Don't discard remote entries with different locations,\n<line49>as these are more likely to be explicitly mounted.\n<line50>However avoid this when producing a total to give\n<line51>a more accurate value in that case.  */\n<line52>}\n<line53>else if ((strchr (me->me_devname, '/')\n<line54>/* let "real" devices with '/' in the name win.  */\n<line55>&& ! strchr (seen_dev->me->me_devname, '/'))\n<line56>/* let points towards the root of the device win.  */\n<line57>|| (target_nearer_root && ! source_below_root)\n<line58>/* let an entry overmounted on a new device win...  */\n<line59>|| (! STREQ (seen_dev->me->me_devname, me->me_devname)\n<line60>/* ... but only when matching an existing mnt point,\n<line61>to avoid problematic replacement when given\n<line62>inaccurate mount lists, seen with some chroot\n<line63>environments for example.  */\n<line64>&& STREQ (me->me_mountdir,\n<line65>seen_dev->me->me_mountdir)))\n<line66>{\n<line67>/* Discard mount entry for existing device.  */\n<line68>discard_me = seen_dev->me;\n<line69>seen_dev->me = me;\n<line70>}\n<line71>else\n<line72>{\n<line73>/* Discard mount entry currently being processed.  */\n<line74>discard_me = me;\n<line75>}\n<line76>}\n<line77>}\n<line78>if (discard_me)\n<line79>{\n<line80>me = me->me_next;\n<line81>if (! devices_only)\n<line82>free_mount_entry (discard_me);\n<line83>}\n<line84>else\n<line85>{\n<line86>/* Add the device number to the device_table.  */\n<line87>struct devlist *devlist = xmalloc (sizeof *devlist);\n<line88>devlist->me = me;\n<line89>devlist->dev_num = buf.st_dev;\n<line90>devlist->next = device_list;\n<line91>device_list = devlist;\n<line92>struct devlist *hash_entry = hash_insert (devlist_table, devlist);\n<line93>if (hash_entry == nullptr)\n<line94>xalloc_die ();\n<line95>/* Ensure lookups use this latest devlist.  */\n<line96>hash_entry->seen_last = devlist;\n<line97>me = me->me_next;\n<line98>}\n<line99>}\n<line100>/* Finally rebuild the mount_list from the devlist.  */\n<line101>if (! devices_only) {\n<line102>mount_list = nullptr;\n<line103>while (device_list)\n<line104>{\n<line105>/* Add the mount entry.  */\n<line106>me = device_list->me;\n<line107>me->me_next = mount_list;\n<line108>mount_list = me;\n<line109>struct devlist *next = device_list->next;\n<line110>free (device_list);\n<line111>device_list = next;\n<line112>}\n<line113>hash_free (devlist_table);\n<line114>devlist_table = nullptr;\n<line115>}\n<line116>}
----------------------------------------
Function: known_value
Content: <line0>static bool\n<line1>known_value (uintmax_t n)\n<line2>{\n<line3>return n < UINTMAX_MAX - 1;\n<line4>}
----------------------------------------
Function: df_readable
Content: <line0>static char const *\n<line1>df_readable (bool negative, uintmax_t n, char *buf,\n<line2>uintmax_t input_units, uintmax_t output_units)\n<line3>{\n<line4>if (! known_value (n) && !negative)\n<line5>return "-";\n<line6>else\n<line7>{\n<line8>char *p = human_readable (negative ? -n : n, buf + negative,\n<line9>human_output_opts, input_units, output_units);\n<line10>if (negative)\n<line11>*--p = '-';\n<line12>return p;\n<line13>}\n<line14>}
----------------------------------------
Function: add_uint_with_neg_flag
Content: <line0>static void\n<line1>add_uint_with_neg_flag (uintmax_t *dest, bool *dest_neg,\n<line2>uintmax_t src, bool src_neg)\n<line3>{\n<line4>if (*dest_neg == src_neg)\n<line5>{\n<line6>*dest += src;\n<line7>return;\n<line8>}\n<line9>if (*dest_neg)\n<line10>*dest = -*dest;\n<line11>if (src_neg)\n<line12>src = -src;\n<line13>if (src < *dest)\n<line14>*dest -= src;\n<line15>else\n<line16>{\n<line17>*dest = src - *dest;\n<line18>*dest_neg = src_neg;\n<line19>}\n<line20>if (*dest_neg)\n<line21>*dest = -*dest;\n<line22>}
----------------------------------------
Function: get_field_values
Content: <line0>static void\n<line1>get_field_values (struct field_values_t *bv,\n<line2>struct field_values_t *iv,\n<line3>const struct fs_usage *fsu)\n<line4>{\n<line5>/* Inode values.  */\n<line6>iv->input_units = iv->output_units = 1;\n<line7>iv->total = fsu->fsu_files;\n<line8>iv->available = iv->available_to_root = fsu->fsu_ffree;\n<line9>iv->negate_available = false;\n<line10>iv->used = UINTMAX_MAX;\n<line11>iv->negate_used = false;\n<line12>if (known_value (iv->total) && known_value (iv->available_to_root))\n<line13>{\n<line14>iv->used = iv->total - iv->available_to_root;\n<line15>iv->negate_used = (iv->total < iv->available_to_root);\n<line16>}\n<line17>/* Block values.  */\n<line18>bv->input_units = fsu->fsu_blocksize;\n<line19>bv->output_units = output_block_size;\n<line20>bv->total = fsu->fsu_blocks;\n<line21>bv->available = fsu->fsu_bavail;\n<line22>bv->available_to_root = fsu->fsu_bfree;\n<line23>bv->negate_available = (fsu->fsu_bavail_top_bit_set\n<line24>&& known_value (fsu->fsu_bavail));\n<line25>bv->used = UINTMAX_MAX;\n<line26>bv->negate_used = false;\n<line27>if (known_value (bv->total) && known_value (bv->available_to_root))\n<line28>{\n<line29>bv->used = bv->total - bv->available_to_root;\n<line30>bv->negate_used = (bv->total < bv->available_to_root);\n<line31>}\n<line32>}
----------------------------------------
Function: add_to_grand_total
Content: <line0>static void\n<line1>add_to_grand_total (struct field_values_t *bv, struct field_values_t *iv)\n<line2>{\n<line3>if (known_value (iv->total))\n<line4>grand_fsu.fsu_files += iv->total;\n<line5>if (known_value (iv->available))\n<line6>grand_fsu.fsu_ffree += iv->available;\n<line7>if (known_value (bv->total))\n<line8>grand_fsu.fsu_blocks += bv->input_units * bv->total;\n<line9>if (known_value (bv->available_to_root))\n<line10>grand_fsu.fsu_bfree += bv->input_units * bv->available_to_root;\n<line11>if (known_value (bv->available))\n<line12>add_uint_with_neg_flag (&grand_fsu.fsu_bavail,\n<line13>&grand_fsu.fsu_bavail_top_bit_set,\n<line14>bv->input_units * bv->available,\n<line15>bv->negate_available);\n<line16>}
----------------------------------------
Function: get_dev
Content: <line0>static void\n<line1>get_dev (char const *device, char const *mount_point, char const *file,\n<line2>char const *stat_file, char const *fstype,\n<line3>bool me_dummy, bool me_remote,\n<line4>const struct fs_usage *force_fsu,\n<line5>bool process_all)\n<line6>{\n<line7>if (me_remote && show_local_fs)\n<line8>return;\n<line9>if (me_dummy && !show_all_fs && !show_listed_fs)\n<line10>return;\n<line11>if (!selected_fstype (fstype) || excluded_fstype (fstype))\n<line12>return;\n<line13>/* Ignore relative MOUNT_POINTs, which are present for example\n<line14>in /proc/mounts on Linux with network namespaces.  */\n<line15>if (!force_fsu && mount_point && ! IS_ABSOLUTE_FILE_NAME (mount_point))\n<line16>return;\n<line17>/* If MOUNT_POINT is null, then the file system is not mounted, and this\n<line18>program reports on the file system that the special file is on.\n<line19>It would be better to report on the unmounted file system,\n<line20>but statfs doesn't do that on most systems.  */\n<line21>if (!stat_file)\n<line22>stat_file = mount_point ? mount_point : device;\n<line23>struct fs_usage fsu;\n<line24>if (force_fsu)\n<line25>fsu = *force_fsu;\n<line26>else if (get_fs_usage (stat_file, device, &fsu))\n<line27>{\n<line28>/* If we can't access a system provided entry due\n<line29>to it not being present (now), or due to permissions,\n<line30>just output placeholder values rather than failing.  */\n<line31>if (process_all && (errno == EACCES || errno == ENOENT))\n<line32>{\n<line33>if (! show_all_fs)\n<line34>return;\n<line35>fstype = "-";\n<line36>fsu.fsu_bavail_top_bit_set = false;\n<line37>fsu.fsu_blocksize = fsu.fsu_blocks = fsu.fsu_bfree =\n<line38>fsu.fsu_bavail = fsu.fsu_files = fsu.fsu_ffree = UINTMAX_MAX;\n<line39>}\n<line40>else\n<line41>{\n<line42>error (0, errno, "%s", quotef (stat_file));\n<line43>exit_status = EXIT_FAILURE;\n<line44>return;\n<line45>}\n<line46>}\n<line47>else if (process_all && show_all_fs)\n<line48>{\n<line49>/* Ensure we don't output incorrect stats for over-mounted directories.\n<line50>Discard stats when the device name doesn't match.  Though don't\n<line51>discard when used and current mount entries are both remote due\n<line52>to the possibility of aliased host names or exports.  */\n<line53>struct stat sb;\n<line54>if (stat (stat_file, &sb) == 0)\n<line55>{\n<line56>struct mount_entry const * dev_me = me_for_dev (sb.st_dev);\n<line57>if (dev_me && ! STREQ (dev_me->me_devname, device)\n<line58>&& (! dev_me->me_remote || ! me_remote))\n<line59>{\n<line60>fstype = "-";\n<line61>fsu.fsu_bavail_top_bit_set = false;\n<line62>fsu.fsu_blocksize = fsu.fsu_blocks = fsu.fsu_bfree =\n<line63>fsu.fsu_bavail = fsu.fsu_files = fsu.fsu_ffree = UINTMAX_MAX;\n<line64>}\n<line65>}\n<line66>}\n<line67>if (fsu.fsu_blocks == 0 && !show_all_fs && !show_listed_fs)\n<line68>return;\n<line69>if (! force_fsu)\n<line70>file_systems_processed = true;\n<line71>alloc_table_row ();\n<line72>if (! device)\n<line73>device = "-";		/* unknown */\n<line74>if (! file)\n<line75>file = "-";			/* unspecified */\n<line76>char *dev_name = xstrdup (device);\n<line77>char *resolved_dev;\n<line78>/* On some systems, dev_name is a long-named symlink like\n<line79>/dev/disk/by-uuid/828fc648-9f30-43d8-a0b1-f7196a2edb66 pointing to a\n<line80>much shorter and more useful name like /dev/sda1.  It may also look\n<line81>like /dev/mapper/luks-828fc648-9f30-43d8-a0b1-f7196a2edb66 and point to\n<line82>/dev/dm-0.  When process_all is true and dev_name is a symlink whose\n<line83>name ends with a UUID use the resolved name instead.  */\n<line84>if (process_all\n<line85>&& has_uuid_suffix (dev_name)\n<line86>&& (resolved_dev = canonicalize_filename_mode (dev_name, CAN_EXISTING)))\n<line87>{\n<line88>free (dev_name);\n<line89>dev_name = resolved_dev;\n<line90>}\n<line91>if (! fstype)\n<line92>fstype = "-";		/* unknown */\n<line93>struct field_values_t block_values;\n<line94>struct field_values_t inode_values;\n<line95>get_field_values (&block_values, &inode_values, &fsu);\n<line96>/* Add to grand total unless processing grand total line.  */\n<line97>if (print_grand_total && ! force_fsu)\n<line98>add_to_grand_total (&block_values, &inode_values);\n<line99>size_t col;\n<line100>for (col = 0; col < ncolumns; col++)\n<line101>{\n<line102>char buf[LONGEST_HUMAN_READABLE + 2];\n<line103>char *cell;\n<line104>struct field_values_t *v;\n<line105>switch (columns[col]->field_type)\n<line106>{\n<line107>case BLOCK_FLD:\n<line108>v = &block_values;\n<line109>break;\n<line110>case INODE_FLD:\n<line111>v = &inode_values;\n<line112>break;\n<line113>case OTHER_FLD:\n<line114>v = nullptr;\n<line115>break;\n<line116>default:\n<line117>affirm (!"bad field_type");\n<line118>}\n<line119>switch (columns[col]->field)\n<line120>{\n<line121>case SOURCE_FIELD:\n<line122>cell = xstrdup (dev_name);\n<line123>break;\n<line124>case FSTYPE_FIELD:\n<line125>cell = xstrdup (fstype);\n<line126>break;\n<line127>case SIZE_FIELD:\n<line128>case ITOTAL_FIELD:\n<line129>cell = xstrdup (df_readable (false, v->total, buf,\n<line130>v->input_units, v->output_units));\n<line131>break;\n<line132>case USED_FIELD:\n<line133>case IUSED_FIELD:\n<line134>cell = xstrdup (df_readable (v->negate_used, v->used, buf,\n<line135>v->input_units, v->output_units));\n<line136>break;\n<line137>case AVAIL_FIELD:\n<line138>case IAVAIL_FIELD:\n<line139>cell = xstrdup (df_readable (v->negate_available, v->available, buf,\n<line140>v->input_units, v->output_units));\n<line141>break;\n<line142>case PCENT_FIELD:\n<line143>case IPCENT_FIELD:\n<line144>{\n<line145>double pct = -1;\n<line146>if (! known_value (v->used) || ! known_value (v->available))\n<line147>;\n<line148>else if (!v->negate_used\n<line149>&& v->used <= TYPE_MAXIMUM (uintmax_t) / 100\n<line150>&& v->used + v->available != 0\n<line151>&& (v->used + v->available < v->used)\n<line152>== v->negate_available)\n<line153>{\n<line154>uintmax_t u100 = v->used * 100;\n<line155>uintmax_t nonroot_total = v->used + v->available;\n<line156>pct = u100 / nonroot_total + (u100 % nonroot_total != 0);\n<line157>}\n<line158>else\n<line159>{\n<line160>/* The calculation cannot be done easily with integer\n<line161>arithmetic.  Fall back on floating point.  This can suffer\n<line162>from minor rounding errors, but doing it exactly requires\n<line163>multiple precision arithmetic, and it's not worth the\n<line164>aggravation.  */\n<line165>double u = v->negate_used ? - (double) - v->used : v->used;\n<line166>double a = v->negate_available\n<line167>? - (double) - v->available : v->available;\n<line168>double nonroot_total = u + a;\n<line169>if (nonroot_total)\n<line170>{\n<line171>long int lipct = pct = u * 100 / nonroot_total;\n<line172>double ipct = lipct;\n<line173>/* Like 'pct = ceil (dpct);', but avoid ceil so that\n<line174>the math library needn't be linked.  */\n<line175>if (ipct - 1 < pct && pct <= ipct + 1)\n<line176>pct = ipct + (ipct < pct);\n<line177>}\n<line178>}\n<line179>if (0 <= pct)\n<line180>{\n<line181>if (asprintf (&cell, "%.0f%%", pct) == -1)\n<line182>cell = nullptr;\n<line183>}\n<line184>else\n<line185>cell = strdup ("-");\n<line186>if (!cell)\n<line187>xalloc_die ();\n<line188>break;\n<line189>}\n<line190>case FILE_FIELD:\n<line191>cell = xstrdup (file);\n<line192>break;\n<line193>case TARGET_FIELD:\n<line194>#ifdef HIDE_AUTOMOUNT_PREFIX\n<line195>/* Don't print the first directory name in MOUNT_POINT if it's an\n<line196>artifact of an automounter.  This is a bit too aggressive to be\n<line197>the default.  */\n<line198>if (STRNCMP_LIT (mount_point, "/auto/") == 0)\n<line199>mount_point += 5;\n<line200>else if (STRNCMP_LIT (mount_point, "/tmp_mnt/") == 0)\n<line201>mount_point += 8;\n<line202>#endif\n<line203>cell = xstrdup (mount_point);\n<line204>break;\n<line205>default:\n<line206>affirm (!"unhandled field");\n<line207>}\n<line208>affirm (cell);\n<line209>replace_problematic_chars (cell);\n<line210>size_t cell_width = mbswidth (cell, 0);\n<line211>columns[col]->width = MAX (columns[col]->width, cell_width);\n<line212>table[nrows - 1][col] = cell;\n<line213>}\n<line214>free (dev_name);\n<line215>}
----------------------------------------
Function: last_device_for_mount
Content: <line0>static char *\n<line1>last_device_for_mount (char const *mount)\n<line2>{\n<line3>struct mount_entry const *me;\n<line4>struct mount_entry const *le = nullptr;\n<line5>for (me = mount_list; me; me = me->me_next)\n<line6>{\n<line7>if (STREQ (me->me_mountdir, mount))\n<line8>le = me;\n<line9>}\n<line10>if (le)\n<line11>{\n<line12>char *devname = le->me_devname;\n<line13>char *canon_dev = canonicalize_file_name (devname);\n<line14>if (canon_dev && IS_ABSOLUTE_FILE_NAME (canon_dev))\n<line15>return canon_dev;\n<line16>free (canon_dev);\n<line17>return xstrdup (le->me_devname);\n<line18>}\n<line19>else\n<line20>return nullptr;\n<line21>}
----------------------------------------
Function: get_device
Content: <line0>static bool\n<line1>get_device (char const *device)\n<line2>{\n<line3>struct mount_entry const *me;\n<line4>struct mount_entry const *best_match = nullptr;\n<line5>bool best_match_accessible = false;\n<line6>bool eclipsed_device = false;\n<line7>char const *file = device;\n<line8>char *resolved = canonicalize_file_name (device);\n<line9>if (resolved && IS_ABSOLUTE_FILE_NAME (resolved))\n<line10>device = resolved;\n<line11>size_t best_match_len = SIZE_MAX;\n<line12>for (me = mount_list; me; me = me->me_next)\n<line13>{\n<line14>/* TODO: Should cache canon_dev in the mount_entry struct.  */\n<line15>char *devname = me->me_devname;\n<line16>char *canon_dev = canonicalize_file_name (me->me_devname);\n<line17>if (canon_dev && IS_ABSOLUTE_FILE_NAME (canon_dev))\n<line18>devname = canon_dev;\n<line19>if (STREQ (device, devname))\n<line20>{\n<line21>char *last_device = last_device_for_mount (me->me_mountdir);\n<line22>eclipsed_device = last_device && ! STREQ (last_device, devname);\n<line23>size_t len = strlen (me->me_mountdir);\n<line24>if (! eclipsed_device\n<line25>&& (! best_match_accessible || len < best_match_len))\n<line26>{\n<line27>struct stat device_stats;\n<line28>bool this_match_accessible = false;\n<line29>if (stat (me->me_mountdir, &device_stats) == 0)\n<line30>best_match_accessible = this_match_accessible = true;\n<line31>if (this_match_accessible\n<line32>|| (! best_match_accessible && len < best_match_len))\n<line33>{\n<line34>best_match = me;\n<line35>if (len == 1) /* Traditional root.  */\n<line36>{\n<line37>free (last_device);\n<line38>free (canon_dev);\n<line39>break;\n<line40>}\n<line41>else\n<line42>best_match_len = len;\n<line43>}\n<line44>}\n<line45>free (last_device);\n<line46>}\n<line47>free (canon_dev);\n<line48>}\n<line49>free (resolved);\n<line50>if (best_match)\n<line51>{\n<line52>get_dev (best_match->me_devname, best_match->me_mountdir, file, nullptr,\n<line53>best_match->me_type, best_match->me_dummy,\n<line54>best_match->me_remote, nullptr, false);\n<line55>return true;\n<line56>}\n<line57>else if (eclipsed_device)\n<line58>{\n<line59>error (0, 0, _("cannot access %s: over-mounted by another device"),\n<line60>quoteaf (file));\n<line61>exit_status = EXIT_FAILURE;\n<line62>return true;\n<line63>}\n<line64>return false;\n<line65>}
----------------------------------------
Function: get_point
Content: <line0>static void\n<line1>get_point (char const *point, const struct stat *statp)\n<line2>{\n<line3>struct stat device_stats;\n<line4>struct mount_entry *me;\n<line5>struct mount_entry const *best_match = nullptr;\n<line6>/* Calculate the real absolute file name for POINT, and use that to find\n<line7>the mount point.  This avoids statting unavailable mount points,\n<line8>which can hang df.  */\n<line9>char *resolved = canonicalize_file_name (point);\n<line10>if (resolved && resolved[0] == '/')\n<line11>{\n<line12>size_t resolved_len = strlen (resolved);\n<line13>size_t best_match_len = 0;\n<line14>for (me = mount_list; me; me = me->me_next)\n<line15>{\n<line16>if (!STREQ (me->me_type, "lofs")\n<line17>&& (!best_match || best_match->me_dummy || !me->me_dummy))\n<line18>{\n<line19>size_t len = strlen (me->me_mountdir);\n<line20>if (best_match_len <= len && len <= resolved_len\n<line21>&& (len == 1 /* root file system */\n<line22>|| ((len == resolved_len || resolved[len] == '/')\n<line23>&& STREQ_LEN (me->me_mountdir, resolved, len))))\n<line24>{\n<line25>best_match = me;\n<line26>best_match_len = len;\n<line27>}\n<line28>}\n<line29>}\n<line30>}\n<line31>free (resolved);\n<line32>if (best_match\n<line33>&& (stat (best_match->me_mountdir, &device_stats) != 0\n<line34>|| device_stats.st_dev != statp->st_dev))\n<line35>best_match = nullptr;\n<line36>if (! best_match)\n<line37>for (me = mount_list; me; me = me->me_next)\n<line38>{\n<line39>if (me->me_dev == (dev_t) -1)\n<line40>{\n<line41>if (stat (me->me_mountdir, &device_stats) == 0)\n<line42>me->me_dev = device_stats.st_dev;\n<line43>else\n<line44>{\n<line45>/* Report only I/O errors.  Other errors might be\n<line46>caused by shadowed mount points, which means POINT\n<line47>can't possibly be on this file system.  */\n<line48>if (errno == EIO)\n<line49>{\n<line50>error (0, errno, "%s", quotef (me->me_mountdir));\n<line51>exit_status = EXIT_FAILURE;\n<line52>}\n<line53>/* So we won't try and fail repeatedly.  */\n<line54>me->me_dev = (dev_t) -2;\n<line55>}\n<line56>}\n<line57>if (statp->st_dev == me->me_dev\n<line58>&& !STREQ (me->me_type, "lofs")\n<line59>&& (!best_match || best_match->me_dummy || !me->me_dummy))\n<line60>{\n<line61>/* Skip bogus mtab entries.  */\n<line62>if (stat (me->me_mountdir, &device_stats) != 0\n<line63>|| device_stats.st_dev != me->me_dev)\n<line64>me->me_dev = (dev_t) -2;\n<line65>else\n<line66>best_match = me;\n<line67>}\n<line68>}\n<line69>if (best_match)\n<line70>get_dev (best_match->me_devname, best_match->me_mountdir, point, point,\n<line71>best_match->me_type, best_match->me_dummy, best_match->me_remote,\n<line72>nullptr, false);\n<line73>else\n<line74>{\n<line75>/* We couldn't find the mount entry corresponding to POINT.  Go ahead and\n<line76>print as much info as we can; methods that require the device to be\n<line77>present will fail at a later point.  */\n<line78>/* Find the actual mount point.  */\n<line79>char *mp = find_mount_point (point, statp);\n<line80>if (mp)\n<line81>{\n<line82>get_dev (nullptr, mp, point, nullptr, nullptr,\n<line83>false, false, nullptr, false);\n<line84>free (mp);\n<line85>}\n<line86>}\n<line87>}
----------------------------------------
Function: get_entry
Content: <line0>static void\n<line1>get_entry (char const *name, struct stat const *statp)\n<line2>{\n<line3>if ((S_ISBLK (statp->st_mode) || S_ISCHR (statp->st_mode))\n<line4>&& get_device (name))\n<line5>return;\n<line6>get_point (name, statp);\n<line7>}
----------------------------------------
Function: get_all_entries
Content: <line0>static void\n<line1>get_all_entries (void)\n<line2>{\n<line3>struct mount_entry *me;\n<line4>filter_mount_list (show_all_fs);\n<line5>for (me = mount_list; me; me = me->me_next)\n<line6>get_dev (me->me_devname, me->me_mountdir, nullptr, nullptr, me->me_type,\n<line7>me->me_dummy, me->me_remote, nullptr, true);\n<line8>}
----------------------------------------
Function: add_fs_type
Content: <line0>static void\n<line1>add_fs_type (char const *fstype)\n<line2>{\n<line3>struct fs_type_list *fsp;\n<line4>fsp = xmalloc (sizeof *fsp);\n<line5>fsp->fs_name = (char *) fstype;\n<line6>fsp->fs_next = fs_select_list;\n<line7>fs_select_list = fsp;\n<line8>}
----------------------------------------
Function: add_excluded_fs_type
Content: <line0>static void\n<line1>add_excluded_fs_type (char const *fstype)\n<line2>{\n<line3>struct fs_type_list *fsp;\n<line4>fsp = xmalloc (sizeof *fsp);\n<line5>fsp->fs_name = (char *) fstype;\n<line6>fsp->fs_next = fs_exclude_list;\n<line7>fs_exclude_list = fsp;\n<line8>}
----------------------------------------
Function: usage
Content: <line0>void\n<line1>usage (int status)\n<line2>{\n<line3>if (status != EXIT_SUCCESS)\n<line4>emit_try_help ();\n<line5>else\n<line6>{\n<line7>printf (_("Usage: %s [OPTION]... [FILE]...\n"), program_name);\n<line8>fputs (_("\\n<line9>Show information about the file system on which each FILE resides,\n\\n<line10>or all file systems by default.\n\\n<line11>"), stdout);\n<line12>emit_mandatory_arg_note ();\n<line13>/* TRANSLATORS: The thousands and decimal separators are best\n<line14>adjusted to an appropriate default for your locale.  */\n<line15>fputs (_("\\n<line16>-a, --all             include pseudo, duplicate, inaccessible file systems\n\\n<line17>-B, --block-size=SIZE  scale sizes by SIZE before printing them; e.g.,\n\\n<line18>'-BM' prints sizes in units of 1,048,576 bytes;\n\\n<line19>see SIZE format below\n\\n<line20>-h, --human-readable  print sizes in powers of 1024 (e.g., 1023M)\n\\n<line21>-H, --si              print sizes in powers of 1000 (e.g., 1.1G)\n\\n<line22>"), stdout);\n<line23>fputs (_("\\n<line24>-i, --inodes          list inode information instead of block usage\n\\n<line25>-k                    like --block-size=1K\n\\n<line26>-l, --local           limit listing to local file systems\n\\n<line27>--no-sync         do not invoke sync before getting usage info (default)\\n<line28>\n\\n<line29>"), stdout);\n<line30>fputs (_("\\n<line31>--output[=FIELD_LIST]  use the output format defined by FIELD_LIST,\n\\n<line32>or print all fields if FIELD_LIST is omitted.\n\\n<line33>-P, --portability     use the POSIX output format\n\\n<line34>--sync            invoke sync before getting usage info\n\\n<line35>"), stdout);\n<line36>fputs (_("\\n<line37>--total           elide all entries insignificant to available space,\n\\n<line38>and produce a grand total\n\\n<line39>"), stdout);\n<line40>fputs (_("\\n<line41>-t, --type=TYPE       limit listing to file systems of type TYPE\n\\n<line42>-T, --print-type      print file system type\n\\n<line43>-x, --exclude-type=TYPE   limit listing to file systems not of type TYPE\n\\n<line44>-v                    (ignored)\n\\n<line45>"), stdout);\n<line46>fputs (HELP_OPTION_DESCRIPTION, stdout);\n<line47>fputs (VERSION_OPTION_DESCRIPTION, stdout);\n<line48>emit_blocksize_note ("DF");\n<line49>emit_size_note ();\n<line50>fputs (_("\n\\n<line51>FIELD_LIST is a comma-separated list of columns to be included.  Valid\n\\n<line52>field names are: 'source', 'fstype', 'itotal', 'iused', 'iavail', 'ipcent',\n\\n<line53>'size', 'used', 'avail', 'pcent', 'file' and 'target' (see info page).\n\\n<line54>"), stdout);\n<line55>emit_ancillary_info (PROGRAM_NAME);\n<line56>}\n<line57>exit (status);\n<line58>}
----------------------------------------
Function: main
Content: <line0>int\n<line1>main (int argc, char **argv)\n<line2>{\n<line3>struct stat *stats = nullptr;\n<line4>initialize_main (&argc, &argv);\n<line5>set_program_name (argv[0]);\n<line6>setlocale (LC_ALL, "");\n<line7>bindtextdomain (PACKAGE, LOCALEDIR);\n<line8>textdomain (PACKAGE);\n<line9>atexit (close_stdout);\n<line10>fs_select_list = nullptr;\n<line11>fs_exclude_list = nullptr;\n<line12>show_all_fs = false;\n<line13>show_listed_fs = false;\n<line14>human_output_opts = -1;\n<line15>print_type = false;\n<line16>file_systems_processed = false;\n<line17>exit_status = EXIT_SUCCESS;\n<line18>print_grand_total = false;\n<line19>grand_fsu.fsu_blocksize = 1;\n<line20>/* If true, use the POSIX output format.  */\n<line21>bool posix_format = false;\n<line22>char const *msg_mut_excl = _("options %s and %s are mutually exclusive");\n<line23>while (true)\n<line24>{\n<line25>int oi = -1;\n<line26>int c = getopt_long (argc, argv, "aB:iF:hHklmPTt:vx:", long_options,\n<line27>&oi);\n<line28>if (c == -1)\n<line29>break;\n<line30>switch (c)\n<line31>{\n<line32>case 'a':\n<line33>show_all_fs = true;\n<line34>break;\n<line35>case 'B':\n<line36>{\n<line37>enum strtol_error e = human_options (optarg, &human_output_opts,\n<line38>&output_block_size);\n<line39>if (e != LONGINT_OK)\n<line40>xstrtol_fatal (e, oi, c, long_options, optarg);\n<line41>}\n<line42>break;\n<line43>case 'i':\n<line44>if (header_mode == OUTPUT_MODE)\n<line45>{\n<line46>error (0, 0, msg_mut_excl, "-i", "--output");\n<line47>usage (EXIT_FAILURE);\n<line48>}\n<line49>header_mode = INODES_MODE;\n<line50>break;\n<line51>case 'h':\n<line52>human_output_opts = human_autoscale | human_SI | human_base_1024;\n<line53>output_block_size = 1;\n<line54>break;\n<line55>case 'H':\n<line56>human_output_opts = human_autoscale | human_SI;\n<line57>output_block_size = 1;\n<line58>break;\n<line59>case 'k':\n<line60>human_output_opts = 0;\n<line61>output_block_size = 1024;\n<line62>break;\n<line63>case 'l':\n<line64>show_local_fs = true;\n<line65>break;\n<line66>case 'm': /* obsolescent, exists for BSD compatibility */\n<line67>human_output_opts = 0;\n<line68>output_block_size = 1024 * 1024;\n<line69>break;\n<line70>case 'T':\n<line71>if (header_mode == OUTPUT_MODE)\n<line72>{\n<line73>error (0, 0, msg_mut_excl, "-T", "--output");\n<line74>usage (EXIT_FAILURE);\n<line75>}\n<line76>print_type = true;\n<line77>break;\n<line78>case 'P':\n<line79>if (header_mode == OUTPUT_MODE)\n<line80>{\n<line81>error (0, 0, msg_mut_excl, "-P", "--output");\n<line82>usage (EXIT_FAILURE);\n<line83>}\n<line84>posix_format = true;\n<line85>break;\n<line86>case SYNC_OPTION:\n<line87>require_sync = true;\n<line88>break;\n<line89>case NO_SYNC_OPTION:\n<line90>require_sync = false;\n<line91>break;\n<line92>case 'F':\n<line93>/* Accept -F as a synonym for -t for compatibility with Solaris.  */\n<line94>case 't':\n<line95>add_fs_type (optarg);\n<line96>break;\n<line97>case 'v':		/* For SysV compatibility.  */\n<line98>/* ignore */\n<line99>break;\n<line100>case 'x':\n<line101>add_excluded_fs_type (optarg);\n<line102>break;\n<line103>case OUTPUT_OPTION:\n<line104>if (header_mode == INODES_MODE)\n<line105>{\n<line106>error (0, 0, msg_mut_excl, "-i", "--output");\n<line107>usage (EXIT_FAILURE);\n<line108>}\n<line109>if (posix_format && header_mode == DEFAULT_MODE)\n<line110>{\n<line111>error (0, 0, msg_mut_excl, "-P", "--output");\n<line112>usage (EXIT_FAILURE);\n<line113>}\n<line114>if (print_type)\n<line115>{\n<line116>error (0, 0, msg_mut_excl, "-T", "--output");\n<line117>usage (EXIT_FAILURE);\n<line118>}\n<line119>header_mode = OUTPUT_MODE;\n<line120>if (optarg)\n<line121>decode_output_arg (optarg);\n<line122>break;\n<line123>case TOTAL_OPTION:\n<line124>print_grand_total = true;\n<line125>break;\n<line126>case_GETOPT_HELP_CHAR;\n<line127>case_GETOPT_VERSION_CHAR (PROGRAM_NAME, AUTHORS);\n<line128>default:\n<line129>usage (EXIT_FAILURE);\n<line130>}\n<line131>}\n<line132>if (human_output_opts == -1)\n<line133>{\n<line134>if (posix_format)\n<line135>{\n<line136>human_output_opts = 0;\n<line137>output_block_size = (getenv ("POSIXLY_CORRECT") ? 512 : 1024);\n<line138>}\n<line139>else\n<line140>human_options (getenv ("DF_BLOCK_SIZE"),\n<line141>&human_output_opts, &output_block_size);\n<line142>}\n<line143>if (header_mode == INODES_MODE || header_mode == OUTPUT_MODE)\n<line144>;\n<line145>else if (human_output_opts & human_autoscale)\n<line146>header_mode = HUMAN_MODE;\n<line147>else if (posix_format)\n<line148>header_mode = POSIX_MODE;\n<line149>/* Fail if the same file system type was both selected and excluded.  */\n<line150>{\n<line151>bool match = false;\n<line152>struct fs_type_list *fs_incl;\n<line153>for (fs_incl = fs_select_list; fs_incl; fs_incl = fs_incl->fs_next)\n<line154>{\n<line155>struct fs_type_list *fs_excl;\n<line156>for (fs_excl = fs_exclude_list; fs_excl; fs_excl = fs_excl->fs_next)\n<line157>{\n<line158>if (STREQ (fs_incl->fs_name, fs_excl->fs_name))\n<line159>{\n<line160>error (0, 0,\n<line161>_("file system type %s both selected and excluded"),\n<line162>quote (fs_incl->fs_name));\n<line163>match = true;\n<line164>break;\n<line165>}\n<line166>}\n<line167>}\n<line168>if (match)\n<line169>return EXIT_FAILURE;\n<line170>}\n<line171>if (optind < argc)\n<line172>{\n<line173>/* stat each of the given entries to make sure any corresponding\n<line174>partition is automounted.  This must be done before reading the\n<line175>file system table.  */\n<line176>stats = xnmalloc (argc - optind, sizeof *stats);\n<line177>for (int i = optind; i < argc; ++i)\n<line178>{\n<line179>int err = automount_stat_err (argv[i], &stats[i - optind]);\n<line180>if (err != 0)\n<line181>{\n<line182>error (0, err, "%s", quotef (argv[i]));\n<line183>exit_status = EXIT_FAILURE;\n<line184>argv[i] = nullptr;\n<line185>}\n<line186>}\n<line187>}\n<line188>mount_list =\n<line189>read_file_system_list ((fs_select_list != nullptr\n<line190>|| fs_exclude_list != nullptr\n<line191>|| print_type\n<line192>|| field_data[FSTYPE_FIELD].used\n<line193>|| show_local_fs));\n<line194>if (mount_list == nullptr)\n<line195>{\n<line196>/* Couldn't read the table of mounted file systems.\n<line197>Fail if df was invoked with no file name arguments,\n<line198>or when either of -a, -l, -t or -x is used with file name\n<line199>arguments.  Otherwise, merely give a warning and proceed.  */\n<line200>int status = 0;\n<line201>if ( ! (optind < argc)\n<line202>|| (show_all_fs\n<line203>|| show_local_fs\n<line204>|| fs_select_list != nullptr\n<line205>|| fs_exclude_list != nullptr))\n<line206>{\n<line207>status = EXIT_FAILURE;\n<line208>}\n<line209>char const *warning = (status == 0 ? _("Warning: ") : "");\n<line210>error (status, errno, "%s%s", warning,\n<line211>_("cannot read table of mounted file systems"));\n<line212>}\n<line213>if (require_sync)\n<line214>sync ();\n<line215>get_field_list ();\n<line216>get_header ();\n<line217>if (stats)\n<line218>{\n<line219>/* Display explicitly requested empty file systems.  */\n<line220>show_listed_fs = true;\n<line221>for (int i = optind; i < argc; ++i)\n<line222>if (argv[i])\n<line223>get_entry (argv[i], &stats[i - optind]);\n<line224>}\n<line225>else\n<line226>get_all_entries ();\n<line227>if (file_systems_processed)\n<line228>{\n<line229>if (print_grand_total)\n<line230>get_dev ("total",\n<line231>(field_data[SOURCE_FIELD].used ? "-" : "total"),\n<line232>nullptr, nullptr, nullptr, false, false, &grand_fsu, false);\n<line233>print_table ();\n<line234>}\n<line235>else\n<line236>{\n<line237>/* Print the "no FS processed" diagnostic only if there was no preceding\n<line238>diagnostic, e.g., if all have been excluded.  */\n<line239>if (exit_status == EXIT_SUCCESS)\n<line240>error (EXIT_FAILURE, 0, _("no file systems processed"));\n<line241>}\n<line242>main_exit (exit_status);\n<line243>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/src/find-mount-point.c
========================================
Function: find_mount_point
Content: <line0>extern char *\n<line1>find_mount_point (char const *file, struct stat const *file_stat)\n<line2>{\n<line3>struct saved_cwd cwd;\n<line4>struct stat last_stat;\n<line5>char *mp = nullptr;		/* The malloc'd mount point.  */\n<line6>if (save_cwd (&cwd) != 0)\n<line7>{\n<line8>error (0, errno, _("cannot get current directory"));\n<line9>return nullptr;\n<line10>}\n<line11>if (S_ISDIR (file_stat->st_mode))\n<line12>/* FILE is a directory, so just chdir there directly.  */\n<line13>{\n<line14>last_stat = *file_stat;\n<line15>if (chdir (file) < 0)\n<line16>{\n<line17>error (0, errno, _("cannot change to directory %s"), quoteaf (file));\n<line18>return nullptr;\n<line19>}\n<line20>}\n<line21>else\n<line22>/* FILE is some other kind of file; use its directory.  */\n<line23>{\n<line24>char *xdir = dir_name (file);\n<line25>char *dir;\n<line26>ASSIGN_STRDUPA (dir, xdir);\n<line27>free (xdir);\n<line28>if (chdir (dir) < 0)\n<line29>{\n<line30>error (0, errno, _("cannot change to directory %s"), quoteaf (dir));\n<line31>return nullptr;\n<line32>}\n<line33>if (stat (".", &last_stat) < 0)\n<line34>{\n<line35>error (0, errno, _("cannot stat current directory (now %s)"),\n<line36>quoteaf (dir));\n<line37>goto done;\n<line38>}\n<line39>}\n<line40>/* Now walk up FILE's parents until we find another file system or /,\n<line41>chdiring as we go.  LAST_STAT holds stat information for the last place\n<line42>we visited.  */\n<line43>while (true)\n<line44>{\n<line45>struct stat st;\n<line46>if (stat ("..", &st) < 0)\n<line47>{\n<line48>error (0, errno, _("cannot stat %s"), quoteaf (".."));\n<line49>goto done;\n<line50>}\n<line51>if (st.st_dev != last_stat.st_dev || st.st_ino == last_stat.st_ino)\n<line52>/* cwd is the mount point.  */\n<line53>break;\n<line54>if (chdir ("..") < 0)\n<line55>{\n<line56>error (0, errno, _("cannot change to directory %s"), quoteaf (".."));\n<line57>goto done;\n<line58>}\n<line59>last_stat = st;\n<line60>}\n<line61>/* Finally reached a mount point, see what it's called.  */\n<line62>mp = xgetcwd ();\n<line63>done:\n<line64>/* Restore the original cwd.  */\n<line65>{\n<line66>int save_errno = errno;\n<line67>if (restore_cwd (&cwd) != 0)\n<line68>error (EXIT_FAILURE, errno,\n<line69>_("failed to return to initial working directory"));\n<line70>free_cwd (&cwd);\n<line71>errno = save_errno;\n<line72>}\n<line73>return mp;\n<line74>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/src/stdbuf.c
========================================
Function: parse_size
Content: <line0>static int\n<line1>parse_size (char const *str, size_t *size)\n<line2>{\n<line3>uintmax_t tmp_size;\n<line4>enum strtol_error e = xstrtoumax (str, nullptr, 10,\n<line5>&tmp_size, "EGkKMPQRTYZ0");\n<line6>if (e == LONGINT_OK && SIZE_MAX < tmp_size)\n<line7>e = LONGINT_OVERFLOW;\n<line8>if (e == LONGINT_OK)\n<line9>{\n<line10>errno = 0;\n<line11>*size = tmp_size;\n<line12>return 0;\n<line13>}\n<line14>errno = (e == LONGINT_OVERFLOW ? EOVERFLOW : errno);\n<line15>return -1;\n<line16>}
----------------------------------------
Function: usage
Content: <line0>void\n<line1>usage (int status)\n<line2>{\n<line3>if (status != EXIT_SUCCESS)\n<line4>emit_try_help ();\n<line5>else\n<line6>{\n<line7>printf (_("Usage: %s OPTION... COMMAND\n"), program_name);\n<line8>fputs (_("\\n<line9>Run COMMAND, with modified buffering operations for its standard streams.\n\\n<line10>"), stdout);\n<line11>emit_mandatory_arg_note ();\n<line12>fputs (_("\\n<line13>-i, --input=MODE   adjust standard input stream buffering\n\\n<line14>-o, --output=MODE  adjust standard output stream buffering\n\\n<line15>-e, --error=MODE   adjust standard error stream buffering\n\\n<line16>"), stdout);\n<line17>fputs (HELP_OPTION_DESCRIPTION, stdout);\n<line18>fputs (VERSION_OPTION_DESCRIPTION, stdout);\n<line19>fputs (_("\n\\n<line20>If MODE is 'L' the corresponding stream will be line buffered.\n\\n<line21>This option is invalid with standard input.\n"), stdout);\n<line22>fputs (_("\n\\n<line23>If MODE is '0' the corresponding stream will be unbuffered.\n\\n<line24>"), stdout);\n<line25>fputs (_("\n\\n<line26>Otherwise MODE is a number which may be followed by one of the following:\n\\n<line27>KB 1000, K 1024, MB 1000*1000, M 1024*1024, and so on for G,T,P,E,Z,Y,R,Q.\n\\n<line28>Binary prefixes can be used, too: KiB=K, MiB=M, and so on.\n\\n<line29>In this case the corresponding stream will be fully buffered with the buffer\n\\n<line30>size set to MODE bytes.\n\\n<line31>"), stdout);\n<line32>fputs (_("\n\\n<line33>NOTE: If COMMAND adjusts the buffering of its standard streams ('tee' does\n\\n<line34>for example) then that will override corresponding changes by 'stdbuf'.\n\\n<line35>Also some filters (like 'dd' and 'cat' etc.) don't use streams for I/O,\n\\n<line36>and are thus unaffected by 'stdbuf' settings.\n\\n<line37>"), stdout);\n<line38>emit_exec_status (PROGRAM_NAME);\n<line39>emit_ancillary_info (PROGRAM_NAME);\n<line40>}\n<line41>exit (status);\n<line42>}
----------------------------------------
Function: set_program_path
Content: <line0>static void\n<line1>set_program_path (char const *arg)\n<line2>{\n<line3>if (strchr (arg, '/'))        /* Use absolute or relative paths directly.  */\n<line4>{\n<line5>program_path = dir_name (arg);\n<line6>}\n<line7>else\n<line8>{\n<line9>char *path = xreadlink ("/proc/self/exe");\n<line10>if (path)\n<line11>program_path = dir_name (path);\n<line12>else if ((path = getenv ("PATH")))\n<line13>{\n<line14>char *dir;\n<line15>path = xstrdup (path);\n<line16>for (dir = strtok (path, ":"); dir != nullptr;\n<line17>dir = strtok (nullptr, ":"))\n<line18>{\n<line19>char *candidate = file_name_concat (dir, arg, nullptr);\n<line20>if (access (candidate, X_OK) == 0)\n<line21>{\n<line22>program_path = dir_name (candidate);\n<line23>free (candidate);\n<line24>break;\n<line25>}\n<line26>free (candidate);\n<line27>}\n<line28>}\n<line29>free (path);\n<line30>}\n<line31>}
----------------------------------------
Function: optc_to_fileno
Content: <line0>static int\n<line1>optc_to_fileno (int c)\n<line2>{\n<line3>int ret = -1;\n<line4>switch (c)\n<line5>{\n<line6>case 'e':\n<line7>ret = STDERR_FILENO;\n<line8>break;\n<line9>case 'i':\n<line10>ret = STDIN_FILENO;\n<line11>break;\n<line12>case 'o':\n<line13>ret = STDOUT_FILENO;\n<line14>break;\n<line15>}\n<line16>return ret;\n<line17>}
----------------------------------------
Function: set_LD_PRELOAD
Content: <line0>static void\n<line1>set_LD_PRELOAD (void)\n<line2>{\n<line3>int ret;\n<line4>#ifdef __APPLE__\n<line5>char const *preload_env = "DYLD_INSERT_LIBRARIES";\n<line6>#else\n<line7>char const *preload_env = "LD_PRELOAD";\n<line8>#endif\n<line9>char *old_libs = getenv (preload_env);\n<line10>char *LD_PRELOAD;\n<line11>/* Note this would auto add the appropriate search path for "libstdbuf.so":\n<line12>gcc stdbuf.c -Wl,-rpath,'$ORIGIN' -Wl,-rpath,$PKGLIBEXECDIR\n<line13>However we want the lookup done for the exec'd command not stdbuf.\n<line14>Since we don't link against libstdbuf.so add it to PKGLIBEXECDIR\n<line15>rather than to LIBDIR.\n<line16>Note we could add "" as the penultimate item in the following list\n<line17>to enable searching for libstdbuf.so in the default system lib paths.\n<line18>However that would not indicate an error if libstdbuf.so was not found.\n<line19>Also while this could support auto selecting the right arch in a multilib\n<line20>environment, what we really want is to auto select based on the arch of the\n<line21>command being run, rather than that of stdbuf itself.  This is currently\n<line22>not supported due to the unusual need for controlling the stdio buffering\n<line23>of programs that are a different architecture to the default on the\n<line24>system (and that of stdbuf itself).  */\n<line25>char const *const search_path[] = {\n<line26>program_path,\n<line27>PKGLIBEXECDIR,\n<line28>nullptr\n<line29>};\n<line30>char const *const *path = search_path;\n<line31>char *libstdbuf;\n<line32>while (true)\n<line33>{\n<line34>struct stat sb;\n<line35>if (!**path)              /* system default  */\n<line36>{\n<line37>libstdbuf = xstrdup (LIB_NAME);\n<line38>break;\n<line39>}\n<line40>ret = asprintf (&libstdbuf, "%s/%s", *path, LIB_NAME);\n<line41>if (ret < 0)\n<line42>xalloc_die ();\n<line43>if (stat (libstdbuf, &sb) == 0)   /* file_exists  */\n<line44>break;\n<line45>free (libstdbuf);\n<line46>++path;\n<line47>if ( ! *path)\n<line48>error (EXIT_CANCELED, 0, _("failed to find %s"), quote (LIB_NAME));\n<line49>}\n<line50>/* FIXME: Do we need to support libstdbuf.dll, c:, '\' separators etc?  */\n<line51>if (old_libs)\n<line52>ret = asprintf (&LD_PRELOAD, "%s=%s:%s", preload_env, old_libs, libstdbuf);\n<line53>else\n<line54>ret = asprintf (&LD_PRELOAD, "%s=%s", preload_env, libstdbuf);\n<line55>if (ret < 0)\n<line56>xalloc_die ();\n<line57>free (libstdbuf);\n<line58>ret = putenv (LD_PRELOAD);\n<line59>#ifdef __APPLE__\n<line60>if (ret == 0)\n<line61>ret = setenv ("DYLD_FORCE_FLAT_NAMESPACE", "y", 1);\n<line62>#endif\n<line63>if (ret != 0)\n<line64>error (EXIT_CANCELED, errno,\n<line65>_("failed to update the environment with %s"),\n<line66>quote (LD_PRELOAD));\n<line67>}
----------------------------------------
Function: set_libstdbuf_options
Content: <line0>static bool\n<line1>set_libstdbuf_options (void)\n<line2>{\n<line3>bool env_set = false;\n<line4>for (size_t i = 0; i < ARRAY_CARDINALITY (stdbuf); i++)\n<line5>{\n<line6>if (stdbuf[i].optarg)\n<line7>{\n<line8>char *var;\n<line9>int ret;\n<line10>if (*stdbuf[i].optarg == 'L')\n<line11>ret = asprintf (&var, "%s%c=L", "_STDBUF_",\n<line12>toupper (stdbuf[i].optc));\n<line13>else\n<line14>ret = asprintf (&var, "%s%c=%" PRIuMAX, "_STDBUF_",\n<line15>toupper (stdbuf[i].optc),\n<line16>(uintmax_t) stdbuf[i].size);\n<line17>if (ret < 0)\n<line18>xalloc_die ();\n<line19>if (putenv (var) != 0)\n<line20>error (EXIT_CANCELED, errno,\n<line21>_("failed to update the environment with %s"),\n<line22>quote (var));\n<line23>env_set = true;\n<line24>}\n<line25>}\n<line26>return env_set;\n<line27>}
----------------------------------------
Function: main
Content: <line0>int\n<line1>main (int argc, char **argv)\n<line2>{\n<line3>int c;\n<line4>initialize_main (&argc, &argv);\n<line5>set_program_name (argv[0]);\n<line6>setlocale (LC_ALL, "");\n<line7>bindtextdomain (PACKAGE, LOCALEDIR);\n<line8>textdomain (PACKAGE);\n<line9>initialize_exit_failure (EXIT_CANCELED);\n<line10>atexit (close_stdout);\n<line11>while ((c = getopt_long (argc, argv, "+i:o:e:", longopts, nullptr)) != -1)\n<line12>{\n<line13>int opt_fileno;\n<line14>switch (c)\n<line15>{\n<line16>/* Old McDonald had a farm ei...  */\n<line17>case 'e':\n<line18>case 'i':\n<line19>case 'o':\n<line20>opt_fileno = optc_to_fileno (c);\n<line21>affirm (0 <= opt_fileno && opt_fileno < ARRAY_CARDINALITY (stdbuf));\n<line22>stdbuf[opt_fileno].optc = c;\n<line23>while (c_isspace (*optarg))\n<line24>optarg++;\n<line25>stdbuf[opt_fileno].optarg = optarg;\n<line26>if (c == 'i' && *optarg == 'L')\n<line27>{\n<line28>/* -oL will be by far the most common use of this utility,\n<line29>but one could easily think -iL might have the same affect,\n<line30>so disallow it as it could be confusing.  */\n<line31>error (0, 0, _("line buffering stdin is meaningless"));\n<line32>usage (EXIT_CANCELED);\n<line33>}\n<line34>if (!STREQ (optarg, "L")\n<line35>&& parse_size (optarg, &stdbuf[opt_fileno].size) == -1)\n<line36>error (EXIT_CANCELED, errno, _("invalid mode %s"), quote (optarg));\n<line37>break;\n<line38>case_GETOPT_HELP_CHAR;\n<line39>case_GETOPT_VERSION_CHAR (PROGRAM_NAME, AUTHORS);\n<line40>default:\n<line41>usage (EXIT_CANCELED);\n<line42>}\n<line43>}\n<line44>argv += optind;\n<line45>argc -= optind;\n<line46>/* must specify at least 1 command.  */\n<line47>if (argc < 1)\n<line48>{\n<line49>error (0, 0, _("missing operand"));\n<line50>usage (EXIT_CANCELED);\n<line51>}\n<line52>if (! set_libstdbuf_options ())\n<line53>{\n<line54>error (0, 0, _("you must specify a buffering mode option"));\n<line55>usage (EXIT_CANCELED);\n<line56>}\n<line57>/* Try to preload libstdbuf first from the same path as\n<line58>stdbuf is running from.  */\n<line59>set_program_path (program_name);\n<line60>if (!program_path)\n<line61>program_path = xstrdup (PKGLIBDIR);  /* Need to init to non-null.  */\n<line62>set_LD_PRELOAD ();\n<line63>free (program_path);\n<line64>execvp (*argv, argv);\n<line65>int exit_status = errno == ENOENT ? EXIT_ENOENT : EXIT_CANNOT_INVOKE;\n<line66>error (0, errno, _("failed to run command %s"), quote (argv[0]));\n<line67>return exit_status;\n<line68>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/src/lbracket.c
========================================
========================================
/home/huihui/Downloads/coreutils-9.4/src/digest.c
========================================
Function: usage
Content: <line0>void\n<line1>usage (int status)\n<line2>{\n<line3>if (status != EXIT_SUCCESS)\n<line4>emit_try_help ();\n<line5>else\n<line6>{\n<line7>printf (_("\\n<line8>Usage: %s [OPTION]... [FILE]...\n\\n<line9>"), program_name);\n<line10>#if HASH_ALGO_CKSUM\n<line11>fputs (_("\\n<line12>Print or verify checksums.\n\\n<line13>By default use the 32 bit CRC algorithm.\n\\n<line14>"), stdout);\n<line15>#else\n<line16>printf (_("\\n<line17>Print or check %s (%d-bit) checksums.\n\\n<line18>"),\n<line19>DIGEST_TYPE_STRING,\n<line20>DIGEST_BITS);\n<line21>#endif\n<line22>emit_stdin_note ();\n<line23>#if HASH_ALGO_SUM\n<line24>fputs (_("\\n<line25>\n\\n<line26>-r              use BSD sum algorithm (the default), use 1K blocks\n\\n<line27>-s, --sysv      use System V sum algorithm, use 512 bytes blocks\n\\n<line28>"), stdout);\n<line29>#endif\n<line30>#if HASH_ALGO_BLAKE2 || HASH_ALGO_CKSUM\n<line31>emit_mandatory_arg_note ();\n<line32>#endif\n<line33>#if HASH_ALGO_CKSUM\n<line34>fputs (_("\\n<line35>-a, --algorithm=TYPE  select the digest type to use.  See DIGEST below.\\n<line36>\n\\n<line37>"), stdout);\n<line38>fputs (_("\\n<line39>--base64          emit base64-encoded digests, not hexadecimal\\n<line40>\n\\n<line41>"), stdout);\n<line42>#endif\n<line43>#if !HASH_ALGO_SUM\n<line44># if !HASH_ALGO_CKSUM\n<line45>if (O_BINARY)\n<line46>fputs (_("\\n<line47>-b, --binary          read in binary mode (default unless reading tty stdin)\\n<line48>\n\\n<line49>"), stdout);\n<line50>else\n<line51>fputs (_("\\n<line52>-b, --binary          read in binary mode\n\\n<line53>"), stdout);\n<line54># endif\n<line55>fputs (_("\\n<line56>-c, --check           read checksums from the FILEs and check them\n\\n<line57>"), stdout);\n<line58># if HASH_ALGO_BLAKE2 || HASH_ALGO_CKSUM\n<line59>fputs (_("\\n<line60>-l, --length=BITS     digest length in bits; must not exceed the max for\n\\n<line61>the blake2 algorithm and must be a multiple of 8\n\\n<line62>"), stdout);\n<line63># endif\n<line64># if HASH_ALGO_CKSUM\n<line65>fputs (_("\\n<line66>--raw             emit a raw binary digest, not hexadecimal\\n<line67>\n\\n<line68>"), stdout);\n<line69>fputs (_("\\n<line70>--tag             create a BSD-style checksum (the default)\n\\n<line71>"), stdout);\n<line72>fputs (_("\\n<line73>--untagged        create a reversed style checksum, without digest type\n\\n<line74>"), stdout);\n<line75># else\n<line76>fputs (_("\\n<line77>--tag             create a BSD-style checksum\n\\n<line78>"), stdout);\n<line79># endif\n<line80># if !HASH_ALGO_CKSUM\n<line81>if (O_BINARY)\n<line82>fputs (_("\\n<line83>-t, --text            read in text mode (default if reading tty stdin)\n\\n<line84>"), stdout);\n<line85>else\n<line86>fputs (_("\\n<line87>-t, --text            read in text mode (default)\n\\n<line88>"), stdout);\n<line89># endif\n<line90>fputs (_("\\n<line91>-z, --zero            end each output line with NUL, not newline,\n\\n<line92>and disable file name escaping\n\\n<line93>"), stdout);\n<line94>fputs (_("\\n<line95>\n\\n<line96>The following five options are useful only when verifying checksums:\n\\n<line97>--ignore-missing  don't fail or report status for missing files\n\\n<line98>--quiet           don't print OK for each successfully verified file\n\\n<line99>--status          don't output anything, status code shows success\n\\n<line100>--strict          exit non-zero for improperly formatted checksum lines\n\\n<line101>-w, --warn            warn about improperly formatted checksum lines\n\\n<line102>\n\\n<line103>"), stdout);\n<line104>#endif\n<line105>#if HASH_ALGO_CKSUM\n<line106>fputs (_("\\n<line107>--debug           indicate which implementation used\n\\n<line108>"), stdout);\n<line109>#endif\n<line110>fputs (HELP_OPTION_DESCRIPTION, stdout);\n<line111>fputs (VERSION_OPTION_DESCRIPTION, stdout);\n<line112>#if HASH_ALGO_CKSUM\n<line113>fputs (_("\\n<line114>\n\\n<line115>DIGEST determines the digest algorithm and default output format:\n\\n<line116>sysv      (equivalent to sum -s)\n\\n<line117>bsd       (equivalent to sum -r)\n\\n<line118>crc       (equivalent to cksum)\n\\n<line119>md5       (equivalent to md5sum)\n\\n<line120>sha1      (equivalent to sha1sum)\n\\n<line121>sha224    (equivalent to sha224sum)\n\\n<line122>sha256    (equivalent to sha256sum)\n\\n<line123>sha384    (equivalent to sha384sum)\n\\n<line124>sha512    (equivalent to sha512sum)\n\\n<line125>blake2b   (equivalent to b2sum)\n\\n<line126>sm3       (only available through cksum)\n\\n<line127>\n"), stdout);\n<line128>#endif\n<line129>#if !HASH_ALGO_SUM && !HASH_ALGO_CKSUM\n<line130>printf (_("\\n<line131>\n\\n<line132>The sums are computed as described in %s.\n"), DIGEST_REFERENCE);\n<line133>fputs (_("\\n<line134>When checking, the input should be a former output of this program.\n\\n<line135>The default mode is to print a line with: checksum, a space,\n\\n<line136>a character indicating input mode ('*' for binary, ' ' for text\n\\n<line137>or where binary is insignificant), and name for each FILE.\n\\n<line138>\n\\n<line139>Note: There is no difference between binary mode and text mode on GNU systems.\\n<line140>\n"), stdout);\n<line141>#endif\n<line142>#if HASH_ALGO_CKSUM\n<line143>fputs (_("\\n<line144>When checking, the input should be a former output of this program,\n\\n<line145>or equivalent standalone program.\\n<line146>\n"), stdout);\n<line147>#endif\n<line148>emit_ancillary_info (PROGRAM_NAME);\n<line149>}\n<line150>exit (status);\n<line151>}
----------------------------------------
Function: filename_unescape
Content: <line0>static char *\n<line1>filename_unescape (char *s, size_t s_len)\n<line2>{\n<line3>char *dst = s;\n<line4>for (size_t i = 0; i < s_len; i++)\n<line5>{\n<line6>switch (s[i])\n<line7>{\n<line8>case '\\':\n<line9>if (i == s_len - 1)\n<line10>{\n<line11>/* File name ends with an unescaped backslash: invalid.  */\n<line12>return nullptr;\n<line13>}\n<line14>++i;\n<line15>switch (s[i])\n<line16>{\n<line17>case 'n':\n<line18>*dst++ = '\n';\n<line19>break;\n<line20>case 'r':\n<line21>*dst++ = '\r';\n<line22>break;\n<line23>case '\\':\n<line24>*dst++ = '\\';\n<line25>break;\n<line26>default:\n<line27>/* Only '\', 'n' or 'r' may follow a backslash.  */\n<line28>return nullptr;\n<line29>}\n<line30>break;\n<line31>case '\0':\n<line32>/* The file name may not contain a NUL.  */\n<line33>return nullptr;\n<line34>default:\n<line35>*dst++ = s[i];\n<line36>break;\n<line37>}\n<line38>}\n<line39>if (dst < s + s_len)\n<line40>*dst = '\0';\n<line41>return s;\n<line42>}
----------------------------------------
Function: bsd_split_3
Content: <line0>static bool\n<line1>bsd_split_3 (char *s, size_t s_len,\n<line2>unsigned char **digest, size_t *d_len,\n<line3>char **file_name, bool escaped_filename)\n<line4>{\n<line5>if (s_len == 0)\n<line6>return false;\n<line7>/* Find end of filename.  */\n<line8>size_t i = s_len - 1;\n<line9>while (i && s[i] != ')')\n<line10>i--;\n<line11>if (s[i] != ')')\n<line12>return false;\n<line13>*file_name = s;\n<line14>if (escaped_filename && filename_unescape (s, i) == nullptr)\n<line15>return false;\n<line16>s[i++] = '\0';\n<line17>while (ISWHITE (s[i]))\n<line18>i++;\n<line19>if (s[i] != '=')\n<line20>return false;\n<line21>i++;\n<line22>while (ISWHITE (s[i]))\n<line23>i++;\n<line24>*digest = (unsigned char *) &s[i];\n<line25>*d_len = s_len - i;\n<line26>return valid_digits (*digest, *d_len);\n<line27>}
----------------------------------------
Function: split_3
Content: <line0>static bool\n<line1>split_3 (char *s, size_t s_len,\n<line2>unsigned char **digest, size_t *d_len, int *binary, char **file_name)\n<line3>{\n<line4>bool escaped_filename = false;\n<line5>size_t algo_name_len;\n<line6>size_t i = 0;\n<line7>while (ISWHITE (s[i]))\n<line8>++i;\n<line9>if (s[i] == '\\')\n<line10>{\n<line11>++i;\n<line12>escaped_filename = true;\n<line13>}\n<line14>/* Check for BSD-style checksum line. */\n<line15>#if HASH_ALGO_CKSUM\n<line16>if (! algorithm_specified)\n<line17>{\n<line18>ptrdiff_t algo_tag = algorithm_from_tag (s + i);\n<line19>if (algo_tag >= 0)\n<line20>{\n<line21>if (algo_tag <= crc)\n<line22>return false;  /* We don't support checking these older formats.  */\n<line23>cksum_algorithm = algo_tag;\n<line24>}\n<line25>else\n<line26>return false;  /* We only support tagged format without -a.  */\n<line27>}\n<line28>#endif\n<line29>algo_name_len = strlen (DIGEST_TYPE_STRING);\n<line30>if (STREQ_LEN (s + i, DIGEST_TYPE_STRING, algo_name_len))\n<line31>{\n<line32>i += algo_name_len;\n<line33>#if HASH_ALGO_BLAKE2 || HASH_ALGO_CKSUM\n<line34>/* Terminate and match algorithm name.  */\n<line35>char const *algo_name = &s[i - algo_name_len];\n<line36>bool length_specified = s[i] == '-';\n<line37>bool openssl_format = s[i] == '('; /* and no length_specified */\n<line38>s[i++] = '\0';\n<line39>if (!STREQ (algo_name, DIGEST_TYPE_STRING))\n<line40>return false;\n<line41>if (openssl_format)\n<line42>s[--i] = '(';\n<line43># if HASH_ALGO_BLAKE2\n<line44>digest_length = BLAKE2B_MAX_LEN * 8;\n<line45># else\n<line46>digest_length = algorithm_bits[cksum_algorithm];\n<line47># endif\n<line48>if (length_specified)\n<line49>{\n<line50>uintmax_t length;\n<line51>char *siend;\n<line52>if (! (xstrtoumax (s + i, &siend, 0, &length, nullptr) == LONGINT_OK\n<line53>&& 0 < length && length <= digest_length\n<line54>&& length % 8 == 0))\n<line55>return false;\n<line56>i = siend - s;\n<line57>digest_length = length;\n<line58>}\n<line59>digest_hex_bytes = digest_length / 4;\n<line60>#endif\n<line61>if (s[i] == ' ')\n<line62>++i;\n<line63>if (s[i] == '(')\n<line64>{\n<line65>++i;\n<line66>*binary = 0;\n<line67>return bsd_split_3 (s + i, s_len - i,\n<line68>digest, d_len, file_name, escaped_filename);\n<line69>}\n<line70>return false;\n<line71>}\n<line72>/* Ignore this line if it is too short.\n<line73>Each line must have at least 'min_digest_line_length - 1' (or one more, if\n<line74>the first is a backslash) more characters to contain correct message digest\n<line75>information.  */\n<line76>if (s_len - i < min_digest_line_length + (s[i] == '\\'))\n<line77>return false;\n<line78>*digest = (unsigned char *) &s[i];\n<line79>#if HASH_ALGO_BLAKE2 || HASH_ALGO_CKSUM\n<line80>/* Auto determine length.  */\n<line81># if HASH_ALGO_CKSUM\n<line82>if (cksum_algorithm == blake2b) {\n<line83># endif\n<line84>unsigned char const *hp = *digest;\n<line85>digest_hex_bytes = 0;\n<line86>while (isxdigit (*hp++))\n<line87>digest_hex_bytes++;\n<line88>if (digest_hex_bytes < 2 || digest_hex_bytes % 2\n<line89>|| BLAKE2B_MAX_LEN * 2 < digest_hex_bytes)\n<line90>return false;\n<line91>digest_length = digest_hex_bytes * 4;\n<line92># if HASH_ALGO_CKSUM\n<line93>}\n<line94># endif\n<line95>#endif\n<line96>/* This field must be the hexadecimal or base64 representation\n<line97>of the message digest.  */\n<line98>while (s[i] && !ISWHITE (s[i]))\n<line99>i++;\n<line100>/* The digest must be followed by at least one whitespace character.  */\n<line101>if (i == s_len)\n<line102>return false;\n<line103>*d_len = &s[i] - (char *) *digest;\n<line104>s[i++] = '\0';\n<line105>if (! valid_digits (*digest, *d_len))\n<line106>return false;\n<line107>/* If "bsd reversed" format detected.  */\n<line108>if ((s_len - i == 1) || (s[i] != ' ' && s[i] != '*'))\n<line109>{\n<line110>/* Don't allow mixing bsd and standard formats,\n<line111>to minimize security issues with attackers\n<line112>renaming files with leading spaces.\n<line113>This assumes that with bsd format checksums\n<line114>that the first file name does not have\n<line115>a leading ' ' or '*'.  */\n<line116>if (bsd_reversed == 0)\n<line117>return false;\n<line118>bsd_reversed = 1;\n<line119>}\n<line120>else if (bsd_reversed != 1)\n<line121>{\n<line122>bsd_reversed = 0;\n<line123>*binary = (s[i++] == '*');\n<line124>}\n<line125>/* All characters between the type indicator and end of line are\n<line126>significant -- that includes leading and trailing white space.  */\n<line127>*file_name = &s[i];\n<line128>if (escaped_filename)\n<line129>return filename_unescape (&s[i], s_len - i) != nullptr;\n<line130>return true;\n<line131>}
----------------------------------------
Function: print_filename
Content: <line0>static void\n<line1>print_filename (char const *file, bool escape)\n<line2>{\n<line3>if (! escape)\n<line4>{\n<line5>fputs (file, stdout);\n<line6>return;\n<line7>}\n<line8>while (*file)\n<line9>{\n<line10>switch (*file)\n<line11>{\n<line12>case '\n':\n<line13>fputs ("\\n", stdout);\n<line14>break;\n<line15>case '\r':\n<line16>fputs ("\\r", stdout);\n<line17>break;\n<line18>case '\\':\n<line19>fputs ("\\\\", stdout);\n<line20>break;\n<line21>default:\n<line22>putchar (*file);\n<line23>break;\n<line24>}\n<line25>file++;\n<line26>}\n<line27>}
----------------------------------------
Function: digest_file
Content: <line0>static bool\n<line1>digest_file (char const *filename, int *binary, unsigned char *bin_result,\n<line2>bool *missing, MAYBE_UNUSED uintmax_t *length)\n<line3>{\n<line4>FILE *fp;\n<line5>int err;\n<line6>bool is_stdin = STREQ (filename, "-");\n<line7>*missing = false;\n<line8>if (is_stdin)\n<line9>{\n<line10>have_read_stdin = true;\n<line11>fp = stdin;\n<line12>if (O_BINARY && *binary)\n<line13>{\n<line14>if (*binary < 0)\n<line15>*binary = ! isatty (STDIN_FILENO);\n<line16>if (*binary)\n<line17>xset_binary_mode (STDIN_FILENO, O_BINARY);\n<line18>}\n<line19>}\n<line20>else\n<line21>{\n<line22>fp = fopen (filename, (O_BINARY && *binary ? "rb" : "r"));\n<line23>if (fp == nullptr)\n<line24>{\n<line25>if (ignore_missing && errno == ENOENT)\n<line26>{\n<line27>*missing = true;\n<line28>return true;\n<line29>}\n<line30>error (0, errno, "%s", quotef (filename));\n<line31>return false;\n<line32>}\n<line33>}\n<line34>fadvise (fp, FADVISE_SEQUENTIAL);\n<line35>#if HASH_ALGO_CKSUM\n<line36>if (cksum_algorithm == blake2b)\n<line37>*length = digest_length / 8;\n<line38>err = DIGEST_STREAM (fp, bin_result, length);\n<line39>#elif HASH_ALGO_SUM\n<line40>err = DIGEST_STREAM (fp, bin_result, length);\n<line41>#elif HASH_ALGO_BLAKE2\n<line42>err = DIGEST_STREAM (fp, bin_result, digest_length / 8);\n<line43>#else\n<line44>err = DIGEST_STREAM (fp, bin_result);\n<line45>#endif\n<line46>err = err ? errno : 0;\n<line47>if (is_stdin)\n<line48>clearerr (fp);\n<line49>else if (fclose (fp) != 0 && !err)\n<line50>err = errno;\n<line51>if (err)\n<line52>{\n<line53>error (0, err, "%s", quotef (filename));\n<line54>return false;\n<line55>}\n<line56>return true;\n<line57>}
----------------------------------------
Function: output_file
Content: <line0>static void\n<line1>output_file (char const *file, int binary_file, void const *digest,\n<line2>bool raw, bool tagged, unsigned char delim, MAYBE_UNUSED bool args,\n<line3>MAYBE_UNUSED uintmax_t length)\n<line4>{\n<line5># if HASH_ALGO_CKSUM\n<line6>if (raw)\n<line7>{\n<line8>fwrite (digest, 1, digest_length / 8, stdout);\n<line9>return;\n<line10>}\n<line11># endif\n<line12>unsigned char const *bin_buffer = digest;\n<line13>/* Output a leading backslash if the file name contains problematic chars.  */\n<line14>bool needs_escape = delim == '\n' && problematic_chars (file);\n<line15>if (needs_escape)\n<line16>putchar ('\\');\n<line17>if (tagged)\n<line18>{\n<line19>fputs (DIGEST_TYPE_STRING, stdout);\n<line20># if HASH_ALGO_BLAKE2\n<line21>if (digest_length < BLAKE2B_MAX_LEN * 8)\n<line22>printf ("-%"PRIuMAX, digest_length);\n<line23># elif HASH_ALGO_CKSUM\n<line24>if (cksum_algorithm == blake2b)\n<line25>{\n<line26>if (digest_length < BLAKE2B_MAX_LEN * 8)\n<line27>printf ("-%"PRIuMAX, digest_length);\n<line28>}\n<line29># endif\n<line30>fputs (" (", stdout);\n<line31>print_filename (file, needs_escape);\n<line32>fputs (") = ", stdout);\n<line33>}\n<line34># if HASH_ALGO_CKSUM\n<line35>if (base64_digest)\n<line36>{\n<line37>char b64[BASE64_LENGTH (DIGEST_BIN_BYTES) + 1];\n<line38>base64_encode ((char const *) bin_buffer, digest_length / 8,\n<line39>b64, sizeof b64);\n<line40>fputs (b64, stdout);\n<line41>}\n<line42>else\n<line43># endif\n<line44>{\n<line45>for (size_t i = 0; i < (digest_hex_bytes / 2); ++i)\n<line46>printf ("%02x", bin_buffer[i]);\n<line47>}\n<line48>if (!tagged)\n<line49>{\n<line50>putchar (' ');\n<line51>putchar (binary_file ? '*' : ' ');\n<line52>print_filename (file, needs_escape);\n<line53>}\n<line54>putchar (delim);\n<line55>}
----------------------------------------
Function: hex_equal
Content: <line0>static bool\n<line1>hex_equal (unsigned char const *hex_digest, unsigned char const *bin_buffer)\n<line2>{\n<line3>static const char bin2hex[] = { '0', '1', '2', '3',\n<line4>'4', '5', '6', '7',\n<line5>'8', '9', 'a', 'b',\n<line6>'c', 'd', 'e', 'f' };\n<line7>size_t digest_bin_bytes = digest_hex_bytes / 2;\n<line8>/* Compare generated binary number with text representation\n<line9>in check file.  Ignore case of hex digits.  */\n<line10>size_t cnt;\n<line11>for (cnt = 0; cnt < digest_bin_bytes; ++cnt)\n<line12>{\n<line13>if (tolower (hex_digest[2 * cnt])\n<line14>!= bin2hex[bin_buffer[cnt] >> 4]\n<line15>|| (tolower (hex_digest[2 * cnt + 1])\n<line16>!= (bin2hex[bin_buffer[cnt] & 0xf])))\n<line17>break;\n<line18>}\n<line19>return cnt == digest_bin_bytes;\n<line20>}
----------------------------------------
Function: digest_check
Content: <line0>static bool\n<line1>digest_check (char const *checkfile_name)\n<line2>{\n<line3>FILE *checkfile_stream;\n<line4>uintmax_t n_misformatted_lines = 0;\n<line5>uintmax_t n_mismatched_checksums = 0;\n<line6>uintmax_t n_open_or_read_failures = 0;\n<line7>bool properly_formatted_lines = false;\n<line8>bool matched_checksums = false;\n<line9>unsigned char bin_buffer_unaligned[DIGEST_BIN_BYTES + DIGEST_ALIGN];\n<line10>/* Make sure bin_buffer is properly aligned. */\n<line11>unsigned char *bin_buffer = ptr_align (bin_buffer_unaligned, DIGEST_ALIGN);\n<line12>uintmax_t line_number;\n<line13>char *line;\n<line14>size_t line_chars_allocated;\n<line15>bool is_stdin = STREQ (checkfile_name, "-");\n<line16>if (is_stdin)\n<line17>{\n<line18>have_read_stdin = true;\n<line19>checkfile_name = _("standard input");\n<line20>checkfile_stream = stdin;\n<line21>}\n<line22>else\n<line23>{\n<line24>checkfile_stream = fopen (checkfile_name, "r");\n<line25>if (checkfile_stream == nullptr)\n<line26>{\n<line27>error (0, errno, "%s", quotef (checkfile_name));\n<line28>return false;\n<line29>}\n<line30>}\n<line31>line_number = 0;\n<line32>line = nullptr;\n<line33>line_chars_allocated = 0;\n<line34>do\n<line35>{\n<line36>char *filename;\n<line37>int binary;\n<line38>unsigned char *digest;\n<line39>ssize_t line_length;\n<line40>++line_number;\n<line41>if (line_number == 0)\n<line42>error (EXIT_FAILURE, 0, _("%s: too many checksum lines"),\n<line43>quotef (checkfile_name));\n<line44>line_length = getline (&line, &line_chars_allocated, checkfile_stream);\n<line45>if (line_length <= 0)\n<line46>break;\n<line47>/* Ignore comment lines, which begin with a '#' character.  */\n<line48>if (line[0] == '#')\n<line49>continue;\n<line50>/* Remove any trailing newline.  */\n<line51>line_length -= line[line_length - 1] == '\n';\n<line52>/* Remove any trailing carriage return.  */\n<line53>line_length -= line[line_length - (0 < line_length)] == '\r';\n<line54>/* Ignore empty lines.  */\n<line55>if (line_length == 0)\n<line56>continue;\n<line57>line[line_length] = '\0';\n<line58>size_t d_len;\n<line59>if (! (split_3 (line, line_length, &digest, &d_len, &binary, &filename)\n<line60>&& ! (is_stdin && STREQ (filename, "-"))))\n<line61>{\n<line62>++n_misformatted_lines;\n<line63>if (warn)\n<line64>{\n<line65>error (0, 0,\n<line66>_("%s: %" PRIuMAX\n<line67>": improperly formatted %s checksum line"),\n<line68>quotef (checkfile_name), line_number,\n<line69>DIGEST_TYPE_STRING);\n<line70>}\n<line71>}\n<line72>else\n<line73>{\n<line74>bool ok;\n<line75>bool missing;\n<line76>bool needs_escape = ! status_only && problematic_chars (filename);\n<line77>properly_formatted_lines = true;\n<line78>uintmax_t length;\n<line79>ok = digest_file (filename, &binary, bin_buffer, &missing, &length);\n<line80>if (!ok)\n<line81>{\n<line82>++n_open_or_read_failures;\n<line83>if (!status_only)\n<line84>{\n<line85>if (needs_escape)\n<line86>putchar ('\\');\n<line87>print_filename (filename, needs_escape);\n<line88>printf (": %s\n", _("FAILED open or read"));\n<line89>}\n<line90>}\n<line91>else if (ignore_missing && missing)\n<line92>{\n<line93>/* Ignore missing files with --ignore-missing.  */\n<line94>;\n<line95>}\n<line96>else\n<line97>{\n<line98>bool match = false;\n<line99>#if HASH_ALGO_CKSUM\n<line100>if (d_len < digest_hex_bytes)\n<line101>match = b64_equal (digest, bin_buffer);\n<line102>else\n<line103>#endif\n<line104>if (d_len == digest_hex_bytes)\n<line105>match = hex_equal (digest, bin_buffer);\n<line106>if (match)\n<line107>matched_checksums = true;\n<line108>else\n<line109>++n_mismatched_checksums;\n<line110>if (!status_only)\n<line111>{\n<line112>if (! match || ! quiet)\n<line113>{\n<line114>if (needs_escape)\n<line115>putchar ('\\');\n<line116>print_filename (filename, needs_escape);\n<line117>}\n<line118>if (! match)\n<line119>printf (": %s\n", _("FAILED"));\n<line120>else if (!quiet)\n<line121>printf (": %s\n", _("OK"));\n<line122>}\n<line123>}\n<line124>}\n<line125>}\n<line126>while (!feof (checkfile_stream) && !ferror (checkfile_stream));\n<line127>free (line);\n<line128>int err = ferror (checkfile_stream) ? 0 : -1;\n<line129>if (is_stdin)\n<line130>clearerr (checkfile_stream);\n<line131>else if (fclose (checkfile_stream) != 0 && err < 0)\n<line132>err = errno;\n<line133>if (0 <= err)\n<line134>{\n<line135>error (0, err, err ? "%s" : _("%s: read error"),\n<line136>quotef (checkfile_name));\n<line137>return false;\n<line138>}\n<line139>if (! properly_formatted_lines)\n<line140>{\n<line141>/* Warn if no tests are found.  */\n<line142>error (0, 0, _("%s: no properly formatted checksum lines found"),\n<line143>quotef (checkfile_name));\n<line144>}\n<line145>else\n<line146>{\n<line147>if (!status_only)\n<line148>{\n<line149>if (n_misformatted_lines != 0)\n<line150>error (0, 0,\n<line151>(ngettext\n<line152>("WARNING: %" PRIuMAX " line is improperly formatted",\n<line153>"WARNING: %" PRIuMAX " lines are improperly formatted",\n<line154>select_plural (n_misformatted_lines))),\n<line155>n_misformatted_lines);\n<line156>if (n_open_or_read_failures != 0)\n<line157>error (0, 0,\n<line158>(ngettext\n<line159>("WARNING: %" PRIuMAX " listed file could not be read",\n<line160>"WARNING: %" PRIuMAX " listed files could not be read",\n<line161>select_plural (n_open_or_read_failures))),\n<line162>n_open_or_read_failures);\n<line163>if (n_mismatched_checksums != 0)\n<line164>error (0, 0,\n<line165>(ngettext\n<line166>("WARNING: %" PRIuMAX " computed checksum did NOT match",\n<line167>"WARNING: %" PRIuMAX " computed checksums did NOT match",\n<line168>select_plural (n_mismatched_checksums))),\n<line169>n_mismatched_checksums);\n<line170>if (ignore_missing && ! matched_checksums)\n<line171>error (0, 0, _("%s: no file was verified"),\n<line172>quotef (checkfile_name));\n<line173>}\n<line174>}\n<line175>return (properly_formatted_lines\n<line176>&& matched_checksums\n<line177>&& n_mismatched_checksums == 0\n<line178>&& n_open_or_read_failures == 0\n<line179>&& (!strict || n_misformatted_lines == 0));\n<line180>}
----------------------------------------
Function: main
Content: <line0>int\n<line1>main (int argc, char **argv)\n<line2>{\n<line3>unsigned char bin_buffer_unaligned[DIGEST_BIN_BYTES + DIGEST_ALIGN];\n<line4>/* Make sure bin_buffer is properly aligned. */\n<line5>unsigned char *bin_buffer = ptr_align (bin_buffer_unaligned, DIGEST_ALIGN);\n<line6>bool do_check = false;\n<line7>int opt;\n<line8>bool ok = true;\n<line9>int binary = -1;\n<line10>#if HASH_ALGO_CKSUM\n<line11>bool prefix_tag = true;\n<line12>#else\n<line13>bool prefix_tag = false;\n<line14>#endif\n<line15>/* Setting values of global variables.  */\n<line16>initialize_main (&argc, &argv);\n<line17>set_program_name (argv[0]);\n<line18>setlocale (LC_ALL, "");\n<line19>bindtextdomain (PACKAGE, LOCALEDIR);\n<line20>textdomain (PACKAGE);\n<line21>atexit (close_stdout);\n<line22>/* Line buffer stdout to ensure lines are written atomically and immediately\n<line23>so that processes running in parallel do not intersperse their output.  */\n<line24>setvbuf (stdout, nullptr, _IOLBF, 0);\n<line25>#if HASH_ALGO_SUM\n<line26>char const *short_opts = "rs";\n<line27>#elif HASH_ALGO_CKSUM\n<line28>char const *short_opts = "a:l:bctwz";\n<line29>char const *digest_length_str = "";\n<line30>#elif HASH_ALGO_BLAKE2\n<line31>char const *short_opts = "l:bctwz";\n<line32>char const *digest_length_str = "";\n<line33>#else\n<line34>char const *short_opts = "bctwz";\n<line35>#endif\n<line36>while ((opt = getopt_long (argc, argv, short_opts, long_options, nullptr))\n<line37>!= -1)\n<line38>switch (opt)\n<line39>{\n<line40>#if HASH_ALGO_CKSUM\n<line41>case 'a':\n<line42>cksum_algorithm = XARGMATCH_EXACT ("--algorithm", optarg,\n<line43>algorithm_args, algorithm_types);\n<line44>algorithm_specified = true;\n<line45>break;\n<line46>case DEBUG_PROGRAM_OPTION:\n<line47>cksum_debug = true;\n<line48>break;\n<line49>#endif\n<line50>#if HASH_ALGO_BLAKE2 || HASH_ALGO_CKSUM\n<line51>case 'l':\n<line52>digest_length = xdectoumax (optarg, 0, UINTMAX_MAX, "",\n<line53>_("invalid length"), 0);\n<line54>digest_length_str = optarg;\n<line55>if (digest_length % 8 != 0)\n<line56>{\n<line57>error (0, 0, _("invalid length: %s"), quote (digest_length_str));\n<line58>error (EXIT_FAILURE, 0, _("length is not a multiple of 8"));\n<line59>}\n<line60>break;\n<line61>#endif\n<line62>#if !HASH_ALGO_SUM\n<line63>case 'c':\n<line64>do_check = true;\n<line65>break;\n<line66>case STATUS_OPTION:\n<line67>status_only = true;\n<line68>warn = false;\n<line69>quiet = false;\n<line70>break;\n<line71>case 'b':\n<line72>binary = 1;\n<line73>break;\n<line74>case 't':\n<line75>binary = 0;\n<line76>break;\n<line77>case 'w':\n<line78>status_only = false;\n<line79>warn = true;\n<line80>quiet = false;\n<line81>break;\n<line82>case IGNORE_MISSING_OPTION:\n<line83>ignore_missing = true;\n<line84>break;\n<line85>case QUIET_OPTION:\n<line86>status_only = false;\n<line87>warn = false;\n<line88>quiet = true;\n<line89>break;\n<line90>case STRICT_OPTION:\n<line91>strict = true;\n<line92>break;\n<line93># if HASH_ALGO_CKSUM\n<line94>case BASE64_OPTION:\n<line95>base64_digest = true;\n<line96>break;\n<line97>case RAW_OPTION:\n<line98>raw_digest = true;\n<line99>break;\n<line100>case UNTAG_OPTION:\n<line101>prefix_tag = false;\n<line102>break;\n<line103># endif\n<line104>case TAG_OPTION:\n<line105>prefix_tag = true;\n<line106>binary = 1;\n<line107>break;\n<line108>case 'z':\n<line109>digest_delim = '\0';\n<line110>break;\n<line111>#endif\n<line112>#if HASH_ALGO_SUM\n<line113>case 'r':		/* For SysV compatibility. */\n<line114>sum_algorithm = bsd;\n<line115>break;\n<line116>case 's':\n<line117>sum_algorithm = sysv;\n<line118>break;\n<line119>#endif\n<line120>case_GETOPT_HELP_CHAR;\n<line121>case_GETOPT_VERSION_CHAR (PROGRAM_NAME, AUTHORS);\n<line122>default:\n<line123>usage (EXIT_FAILURE);\n<line124>}\n<line125>min_digest_line_length = MIN_DIGEST_LINE_LENGTH;\n<line126>#if HASH_ALGO_BLAKE2 || HASH_ALGO_CKSUM\n<line127># if HASH_ALGO_CKSUM\n<line128>if (digest_length && cksum_algorithm != blake2b)\n<line129>error (EXIT_FAILURE, 0,\n<line130>_("--length is only supported with --algorithm=blake2b"));\n<line131># endif\n<line132>if (digest_length > BLAKE2B_MAX_LEN * 8)\n<line133>{\n<line134>error (0, 0, _("invalid length: %s"), quote (digest_length_str));\n<line135>error (EXIT_FAILURE, 0,\n<line136>_("maximum digest length for %s is %d bits"),\n<line137>quote (DIGEST_TYPE_STRING),\n<line138>BLAKE2B_MAX_LEN * 8);\n<line139>}\n<line140>if (digest_length == 0)\n<line141>{\n<line142># if HASH_ALGO_BLAKE2\n<line143>digest_length = BLAKE2B_MAX_LEN * 8;\n<line144># else\n<line145>digest_length = algorithm_bits[cksum_algorithm];\n<line146># endif\n<line147>}\n<line148>digest_hex_bytes = digest_length / 4;\n<line149>#else\n<line150>digest_hex_bytes = DIGEST_HEX_BYTES;\n<line151>#endif\n<line152>#if HASH_ALGO_CKSUM\n<line153>switch (cksum_algorithm)\n<line154>{\n<line155>case bsd:\n<line156>case sysv:\n<line157>case crc:\n<line158>if (do_check && algorithm_specified)\n<line159>error (EXIT_FAILURE, 0,\n<line160>_("--check is not supported with --algorithm={bsd,sysv,crc}"));\n<line161>break;\n<line162>default:\n<line163>break;\n<line164>}\n<line165>if (base64_digest && raw_digest)\n<line166>{\n<line167>error (0, 0, _("--base64 and --raw are mutually exclusive"));\n<line168>usage (EXIT_FAILURE);\n<line169>}\n<line170>#endif\n<line171>if (prefix_tag && !binary)\n<line172>{\n<line173>/* This could be supported in a backwards compatible way\n<line174>by prefixing the output line with a space in text mode.\n<line175>However that's invasive enough that it was agreed to\n<line176>not support this mode with --tag, as --text use cases\n<line177>are adequately supported by the default output format.  */\n<line178>#if !HASH_ALGO_CKSUM\n<line179>error (0, 0, _("--tag does not support --text mode"));\n<line180>#else\n<line181>error (0, 0, _("--text mode is only supported with --untagged"));\n<line182>#endif\n<line183>usage (EXIT_FAILURE);\n<line184>}\n<line185>if (digest_delim != '\n' && do_check)\n<line186>{\n<line187>error (0, 0, _("the --zero option is not supported when "\n<line188>"verifying checksums"));\n<line189>usage (EXIT_FAILURE);\n<line190>}\n<line191>#if !HASH_ALGO_CKSUM\n<line192>if (prefix_tag && do_check)\n<line193>{\n<line194>error (0, 0, _("the --tag option is meaningless when "\n<line195>"verifying checksums"));\n<line196>usage (EXIT_FAILURE);\n<line197>}\n<line198>#endif\n<line199>if (0 <= binary && do_check)\n<line200>{\n<line201>error (0, 0, _("the --binary and --text options are meaningless when "\n<line202>"verifying checksums"));\n<line203>usage (EXIT_FAILURE);\n<line204>}\n<line205>if (ignore_missing && !do_check)\n<line206>{\n<line207>error (0, 0,\n<line208>_("the --ignore-missing option is meaningful only when "\n<line209>"verifying checksums"));\n<line210>usage (EXIT_FAILURE);\n<line211>}\n<line212>if (status_only && !do_check)\n<line213>{\n<line214>error (0, 0,\n<line215>_("the --status option is meaningful only when verifying checksums"));\n<line216>usage (EXIT_FAILURE);\n<line217>}\n<line218>if (warn && !do_check)\n<line219>{\n<line220>error (0, 0,\n<line221>_("the --warn option is meaningful only when verifying checksums"));\n<line222>usage (EXIT_FAILURE);\n<line223>}\n<line224>if (quiet && !do_check)\n<line225>{\n<line226>error (0, 0,\n<line227>_("the --quiet option is meaningful only when verifying checksums"));\n<line228>usage (EXIT_FAILURE);\n<line229>}\n<line230>if (strict & !do_check)\n<line231>{\n<line232>error (0, 0,\n<line233>_("the --strict option is meaningful only when verifying checksums"));\n<line234>usage (EXIT_FAILURE);\n<line235>}\n<line236>if (!O_BINARY && binary < 0)\n<line237>binary = 0;\n<line238>char **operand_lim = argv + argc;\n<line239>if (optind == argc)\n<line240>*operand_lim++ = bad_cast ("-");\n<line241>else if (1 < argc - optind && raw_digest)\n<line242>error (EXIT_FAILURE, 0,\n<line243>_("the --raw option is not supported with multiple files"));\n<line244>for (char **operandp = argv + optind; operandp < operand_lim; operandp++)\n<line245>{\n<line246>char *file = *operandp;\n<line247>if (do_check)\n<line248>ok &= digest_check (file);\n<line249>else\n<line250>{\n<line251>int binary_file = binary;\n<line252>bool missing;\n<line253>uintmax_t length;\n<line254>if (! digest_file (file, &binary_file, bin_buffer, &missing, &length))\n<line255>ok = false;\n<line256>else\n<line257>{\n<line258>DIGEST_OUT (file, binary_file, bin_buffer, raw_digest, prefix_tag,\n<line259>digest_delim, optind != argc, length);\n<line260>}\n<line261>}\n<line262>}\n<line263>if (have_read_stdin && fclose (stdin) == EOF)\n<line264>error (EXIT_FAILURE, errno, _("standard input"));\n<line265>return ok ? EXIT_SUCCESS : EXIT_FAILURE;\n<line266>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/src/blake2/blake2b-ref.c
========================================
Function: blake2b_set_lastnode
Content: <line0>static void blake2b_set_lastnode( blake2b_state *S )\n<line1>{\n<line2>S->f[1] = (uint64_t)-1;\n<line3>}
----------------------------------------
Function: blake2b_is_lastblock
Content: <line0>static int blake2b_is_lastblock( const blake2b_state *S )\n<line1>{\n<line2>return S->f[0] != 0;\n<line3>}
----------------------------------------
Function: blake2b_set_lastblock
Content: <line0>static void blake2b_set_lastblock( blake2b_state *S )\n<line1>{\n<line2>if( S->last_node ) blake2b_set_lastnode( S );\n<line3>S->f[0] = (uint64_t)-1;\n<line4>}
----------------------------------------
Function: blake2b_increment_counter
Content: <line0>static void blake2b_increment_counter( blake2b_state *S, const uint64_t inc )\n<line1>{\n<line2>S->t[0] += inc;\n<line3>S->t[1] += ( S->t[0] < inc );\n<line4>}
----------------------------------------
Function: blake2b_init0
Content: <line0>static void blake2b_init0( blake2b_state *S )\n<line1>{\n<line2>size_t i;\n<line3>memset( S, 0, sizeof( blake2b_state ) );\n<line4>for( i = 0; i < 8; ++i ) S->h[i] = blake2b_IV[i];\n<line5>}
----------------------------------------
Function: blake2b_init_param
Content: <line0>int blake2b_init_param( blake2b_state *S, const blake2b_param *P )\n<line1>{\n<line2>const uint8_t *p = ( const uint8_t * )( P );\n<line3>size_t i;\n<line4>blake2b_init0( S );\n<line5>/* IV XOR ParamBlock */\n<line6>for( i = 0; i < 8; ++i )\n<line7>S->h[i] ^= load64( p + sizeof( S->h[i] ) * i );\n<line8>S->outlen = P->digest_length;\n<line9>return 0;\n<line10>}
----------------------------------------
Function: blake2b_init
Content: <line0>int blake2b_init( blake2b_state *S, size_t outlen )\n<line1>{\n<line2>blake2b_param P[1];\n<line3>if ( ( !outlen ) || ( outlen > BLAKE2B_OUTBYTES ) ) return -1;\n<line4>P->digest_length = (uint8_t)outlen;\n<line5>P->key_length    = 0;\n<line6>P->fanout        = 1;\n<line7>P->depth         = 1;\n<line8>store32( &P->leaf_length, 0 );\n<line9>store32( &P->node_offset, 0 );\n<line10>store32( &P->xof_length, 0 );\n<line11>P->node_depth    = 0;\n<line12>P->inner_length  = 0;\n<line13>memset( P->reserved, 0, sizeof( P->reserved ) );\n<line14>memset( P->salt,     0, sizeof( P->salt ) );\n<line15>memset( P->personal, 0, sizeof( P->personal ) );\n<line16>return blake2b_init_param( S, P );\n<line17>}
----------------------------------------
Function: blake2b_init_key
Content: <line0>int blake2b_init_key( blake2b_state *S, size_t outlen, const void *key, size_t keylen )\n<line1>{\n<line2>blake2b_param P[1];\n<line3>if ( ( !outlen ) || ( outlen > BLAKE2B_OUTBYTES ) ) return -1;\n<line4>if ( !key || !keylen || keylen > BLAKE2B_KEYBYTES ) return -1;\n<line5>P->digest_length = (uint8_t)outlen;\n<line6>P->key_length    = (uint8_t)keylen;\n<line7>P->fanout        = 1;\n<line8>P->depth         = 1;\n<line9>store32( &P->leaf_length, 0 );\n<line10>store32( &P->node_offset, 0 );\n<line11>store32( &P->xof_length, 0 );\n<line12>P->node_depth    = 0;\n<line13>P->inner_length  = 0;\n<line14>memset( P->reserved, 0, sizeof( P->reserved ) );\n<line15>memset( P->salt,     0, sizeof( P->salt ) );\n<line16>memset( P->personal, 0, sizeof( P->personal ) );\n<line17>if( blake2b_init_param( S, P ) < 0 ) return -1;\n<line18>{\n<line19>uint8_t block[BLAKE2B_BLOCKBYTES];\n<line20>memset( block, 0, BLAKE2B_BLOCKBYTES );\n<line21>memcpy( block, key, keylen );\n<line22>blake2b_update( S, block, BLAKE2B_BLOCKBYTES );\n<line23>secure_zero_memory( block, BLAKE2B_BLOCKBYTES ); /* Burn the key from stack */\n<line24>}\n<line25>return 0;\n<line26>}
----------------------------------------
Function: blake2b_compress
Content: <line0>static void blake2b_compress( blake2b_state *S, const uint8_t block[BLAKE2B_BLOCKBYTES] )\n<line1>{\n<line2>uint64_t m[16];\n<line3>uint64_t v[16];\n<line4>size_t i;\n<line5>for( i = 0; i < 16; ++i ) {\n<line6>m[i] = load64( block + i * sizeof( m[i] ) );\n<line7>}\n<line8>for( i = 0; i < 8; ++i ) {\n<line9>v[i] = S->h[i];\n<line10>}\n<line11>v[ 8] = blake2b_IV[0];\n<line12>v[ 9] = blake2b_IV[1];\n<line13>v[10] = blake2b_IV[2];\n<line14>v[11] = blake2b_IV[3];\n<line15>v[12] = blake2b_IV[4] ^ S->t[0];\n<line16>v[13] = blake2b_IV[5] ^ S->t[1];\n<line17>v[14] = blake2b_IV[6] ^ S->f[0];\n<line18>v[15] = blake2b_IV[7] ^ S->f[1];\n<line19>ROUND( 0 );\n<line20>ROUND( 1 );\n<line21>ROUND( 2 );\n<line22>ROUND( 3 );\n<line23>ROUND( 4 );\n<line24>ROUND( 5 );\n<line25>ROUND( 6 );\n<line26>ROUND( 7 );\n<line27>ROUND( 8 );\n<line28>ROUND( 9 );\n<line29>ROUND( 10 );\n<line30>ROUND( 11 );\n<line31>for( i = 0; i < 8; ++i ) {\n<line32>S->h[i] = S->h[i] ^ v[i] ^ v[i + 8];\n<line33>}\n<line34>}
----------------------------------------
Function: blake2b_update
Content: <line0>int blake2b_update( blake2b_state *S, const void *pin, size_t inlen )\n<line1>{\n<line2>const unsigned char * in = (const unsigned char *)pin;\n<line3>if( inlen > 0 )\n<line4>{\n<line5>size_t left = S->buflen;\n<line6>size_t fill = BLAKE2B_BLOCKBYTES - left;\n<line7>if( inlen > fill )\n<line8>{\n<line9>S->buflen = 0;\n<line10>memcpy( S->buf + left, in, fill ); /* Fill buffer */\n<line11>blake2b_increment_counter( S, BLAKE2B_BLOCKBYTES );\n<line12>blake2b_compress( S, S->buf ); /* Compress */\n<line13>in += fill; inlen -= fill;\n<line14>while(inlen > BLAKE2B_BLOCKBYTES) {\n<line15>blake2b_increment_counter(S, BLAKE2B_BLOCKBYTES);\n<line16>blake2b_compress( S, in );\n<line17>in += BLAKE2B_BLOCKBYTES;\n<line18>inlen -= BLAKE2B_BLOCKBYTES;\n<line19>}\n<line20>}\n<line21>memcpy( S->buf + S->buflen, in, inlen );\n<line22>S->buflen += inlen;\n<line23>}\n<line24>return 0;\n<line25>}
----------------------------------------
Function: blake2b_final
Content: <line0>int blake2b_final( blake2b_state *S, void *out, size_t outlen )\n<line1>{\n<line2>uint8_t buffer[BLAKE2B_OUTBYTES] = {0};\n<line3>size_t i;\n<line4>if( out == NULL || outlen < S->outlen )\n<line5>return -1;\n<line6>if( blake2b_is_lastblock( S ) )\n<line7>return -1;\n<line8>blake2b_increment_counter( S, S->buflen );\n<line9>blake2b_set_lastblock( S );\n<line10>memset( S->buf + S->buflen, 0, BLAKE2B_BLOCKBYTES - S->buflen ); /* Padding */\n<line11>blake2b_compress( S, S->buf );\n<line12>for( i = 0; i < 8; ++i ) /* Output full hash to temp buffer */\n<line13>store64( buffer + sizeof( S->h[i] ) * i, S->h[i] );\n<line14>memcpy( out, buffer, S->outlen );\n<line15>secure_zero_memory(buffer, sizeof(buffer));\n<line16>return 0;\n<line17>}
----------------------------------------
Function: blake2b
Content: <line0>int blake2b( void *out, size_t outlen, const void *in, size_t inlen, const void *key, size_t keylen )\n<line1>{\n<line2>blake2b_state S[1];\n<line3>/* Verify parameters */\n<line4>if ( NULL == in && inlen > 0 ) return -1;\n<line5>if ( NULL == out ) return -1;\n<line6>if( NULL == key && keylen > 0 ) return -1;\n<line7>if( !outlen || outlen > BLAKE2B_OUTBYTES ) return -1;\n<line8>if( keylen > BLAKE2B_KEYBYTES ) return -1;\n<line9>if( keylen > 0 )\n<line10>{\n<line11>if( blake2b_init_key( S, outlen, key, keylen ) < 0 ) return -1;\n<line12>}\n<line13>else\n<line14>{\n<line15>if( blake2b_init( S, outlen ) < 0 ) return -1;\n<line16>}\n<line17>blake2b_update( S, ( const uint8_t * )in, inlen );\n<line18>blake2b_final( S, out, outlen );\n<line19>return 0;\n<line20>}
----------------------------------------
Function: blake2
Content: <line0>int blake2( void *out, size_t outlen, const void *in, size_t inlen, const void *key, size_t keylen ) {\n<line1>return blake2b(out, outlen, in, inlen, key, keylen);\n<line2>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/src/blake2/b2sum.c
========================================
Function: blake2b_stream
Content: <line0>int blake2b_stream( FILE *stream, void *resstream, size_t outbytes )\n<line1>{\n<line2>int ret = -1;\n<line3>size_t sum, n;\n<line4>blake2b_state S[1];\n<line5>static const size_t buffer_length = 32768;\n<line6>uint8_t *buffer = ( uint8_t * )malloc( buffer_length );\n<line7>if( !buffer ) return -1;\n<line8>blake2b_init( S, outbytes );\n<line9>while( 1 )\n<line10>{\n<line11>sum = 0;\n<line12>while( 1 )\n<line13>{\n<line14>n = fread( buffer + sum, 1, buffer_length - sum, stream );\n<line15>sum += n;\n<line16>if( buffer_length == sum )\n<line17>break;\n<line18>if( 0 == n )\n<line19>{\n<line20>if( ferror( stream ) )\n<line21>goto cleanup_buffer;\n<line22>goto final_process;\n<line23>}\n<line24>if( feof( stream ) )\n<line25>goto final_process;\n<line26>}\n<line27>blake2b_update( S, buffer, buffer_length );\n<line28>}\n<line29>final_process:;\n<line30>if( sum > 0 ) blake2b_update( S, buffer, sum );\n<line31>blake2b_final( S, resstream, outbytes );\n<line32>ret = 0;\n<line33>cleanup_buffer:\n<line34>free( buffer );\n<line35>return ret;\n<line36>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/src/basenc.c
========================================
/home/huihui/Downloads/coreutils-9.4/src/basenc.c:199:39: warning: '_Static_assert' with no message is a C2x extension [-Wc2x-extensions]
static_assert (ENC_BLOCKSIZE % 12 == 0); /* Padding chars only on last block. */
                                      ^
                                      , ""
/home/huihui/Downloads/coreutils-9.4/src/basenc.c:200:39: warning: '_Static_assert' with no message is a C2x extension [-Wc2x-extensions]
static_assert (DEC_BLOCKSIZE % 12 == 0); /* Complete encoded blocks are used. */
                                      ^
                                      , ""
2 warnings generated.
Function: usage
Content: <line0>void\n<line1>usage (int status)\n<line2>{\n<line3>if (status != EXIT_SUCCESS)\n<line4>emit_try_help ();\n<line5>else\n<line6>{\n<line7>printf (_("\\n<line8>Usage: %s [OPTION]... [FILE]\n\\n<line9>"), program_name);\n<line10>#if BASE_TYPE == 42\n<line11>fputs (_("\\n<line12>basenc encode or decode FILE, or standard input, to standard output.\n\\n<line13>"), stdout);\n<line14>#else\n<line15>printf (_("\\n<line16>Base%d encode or decode FILE, or standard input, to standard output.\n\\n<line17>"), BASE_TYPE);\n<line18>#endif\n<line19>emit_stdin_note ();\n<line20>emit_mandatory_arg_note ();\n<line21>#if BASE_TYPE == 42\n<line22>fputs (_("\\n<line23>--base64          same as 'base64' program (RFC4648 section 4)\n\\n<line24>"), stdout);\n<line25>fputs (_("\\n<line26>--base64url       file- and url-safe base64 (RFC4648 section 5)\n\\n<line27>"), stdout);\n<line28>fputs (_("\\n<line29>--base32          same as 'base32' program (RFC4648 section 6)\n\\n<line30>"), stdout);\n<line31>fputs (_("\\n<line32>--base32hex       extended hex alphabet base32 (RFC4648 section 7)\n\\n<line33>"), stdout);\n<line34>fputs (_("\\n<line35>--base16          hex encoding (RFC4648 section 8)\n\\n<line36>"), stdout);\n<line37>fputs (_("\\n<line38>--base2msbf       bit string with most significant bit (msb) first\n\\n<line39>"), stdout);\n<line40>fputs (_("\\n<line41>--base2lsbf       bit string with least significant bit (lsb) first\n\\n<line42>"), stdout);\n<line43>#endif\n<line44>fputs (_("\\n<line45>-d, --decode          decode data\n\\n<line46>-i, --ignore-garbage  when decoding, ignore non-alphabet characters\n\\n<line47>-w, --wrap=COLS       wrap encoded lines after COLS character (default 76).\n\\n<line48>Use 0 to disable line wrapping\n\\n<line49>"), stdout);\n<line50>#if BASE_TYPE == 42\n<line51>fputs (_("\\n<line52>--z85             ascii85-like encoding (ZeroMQ spec:32/Z85);\n\\n<line53>when encoding, input length must be a multiple of 4;\n\\n<line54>when decoding, input length must be a multiple of 5\n\\n<line55>"), stdout);\n<line56>#endif\n<line57>fputs (HELP_OPTION_DESCRIPTION, stdout);\n<line58>fputs (VERSION_OPTION_DESCRIPTION, stdout);\n<line59>#if BASE_TYPE == 42\n<line60>fputs (_("\\n<line61>\n\\n<line62>When decoding, the input may contain newlines in addition to the bytes of\n\\n<line63>the formal alphabet.  Use --ignore-garbage to attempt to recover\n\\n<line64>from any other non-alphabet bytes in the encoded stream.\n\\n<line65>"), stdout);\n<line66>#else\n<line67>printf (_("\\n<line68>\n\\n<line69>The data are encoded as described for the %s alphabet in RFC 4648.\n\\n<line70>When decoding, the input may contain newlines in addition to the bytes of\n\\n<line71>the formal %s alphabet.  Use --ignore-garbage to attempt to recover\n\\n<line72>from any other non-alphabet bytes in the encoded stream.\n"),\n<line73>PROGRAM_NAME, PROGRAM_NAME);\n<line74>#endif\n<line75>emit_ancillary_info (PROGRAM_NAME);\n<line76>}\n<line77>exit (status);\n<line78>}
----------------------------------------
Function: wrap_write
Content: <line0>static void\n<line1>wrap_write (char const *buffer, idx_t len,\n<line2>idx_t wrap_column, idx_t *current_column, FILE *out)\n<line3>{\n<line4>if (wrap_column == 0)\n<line5>{\n<line6>/* Simple write. */\n<line7>if (fwrite (buffer, 1, len, stdout) < len)\n<line8>write_error ();\n<line9>}\n<line10>else\n<line11>for (idx_t written = 0; written < len; )\n<line12>{\n<line13>idx_t to_write = MIN (wrap_column - *current_column, len - written);\n<line14>if (to_write == 0)\n<line15>{\n<line16>if (fputc ('\n', out) == EOF)\n<line17>write_error ();\n<line18>*current_column = 0;\n<line19>}\n<line20>else\n<line21>{\n<line22>if (fwrite (buffer + written, 1, to_write, stdout) < to_write)\n<line23>write_error ();\n<line24>*current_column += to_write;\n<line25>written += to_write;\n<line26>}\n<line27>}\n<line28>}
----------------------------------------
Function: finish_and_exit
Content: <line0>static _Noreturn void\n<line1>finish_and_exit (FILE *in, char const *infile)\n<line2>{\n<line3>if (fclose (in) != 0)\n<line4>{\n<line5>if (STREQ (infile, "-"))\n<line6>error (EXIT_FAILURE, errno, _("closing standard input"));\n<line7>else\n<line8>error (EXIT_FAILURE, errno, "%s", quotef (infile));\n<line9>}\n<line10>exit (EXIT_SUCCESS);\n<line11>}
----------------------------------------
Function: do_encode
Content: <line0>static _Noreturn void\n<line1>do_encode (FILE *in, char const *infile, FILE *out, idx_t wrap_column)\n<line2>{\n<line3>idx_t current_column = 0;\n<line4>char *inbuf, *outbuf;\n<line5>idx_t sum;\n<line6>inbuf = xmalloc (ENC_BLOCKSIZE);\n<line7>outbuf = xmalloc (BASE_LENGTH (ENC_BLOCKSIZE));\n<line8>do\n<line9>{\n<line10>idx_t n;\n<line11>sum = 0;\n<line12>do\n<line13>{\n<line14>n = fread (inbuf + sum, 1, ENC_BLOCKSIZE - sum, in);\n<line15>sum += n;\n<line16>}\n<line17>while (!feof (in) && !ferror (in) && sum < ENC_BLOCKSIZE);\n<line18>if (sum > 0)\n<line19>{\n<line20>/* Process input one block at a time.  Note that ENC_BLOCKSIZE\n<line21>is sized so that no pad chars will appear in output. */\n<line22>base_encode (inbuf, sum, outbuf, BASE_LENGTH (sum));\n<line23>wrap_write (outbuf, BASE_LENGTH (sum), wrap_column,\n<line24>&current_column, out);\n<line25>}\n<line26>}\n<line27>while (!feof (in) && !ferror (in) && sum == ENC_BLOCKSIZE);\n<line28>/* When wrapping, terminate last line. */\n<line29>if (wrap_column && current_column > 0 && fputc ('\n', out) == EOF)\n<line30>write_error ();\n<line31>if (ferror (in))\n<line32>error (EXIT_FAILURE, errno, _("read error"));\n<line33>finish_and_exit (in, infile);\n<line34>}
----------------------------------------
Function: do_decode
Content: <line0>static _Noreturn void\n<line1>do_decode (FILE *in, char const *infile, FILE *out, bool ignore_garbage)\n<line2>{\n<line3>char *inbuf, *outbuf;\n<line4>idx_t sum;\n<line5>struct base_decode_context ctx;\n<line6>inbuf = xmalloc (BASE_LENGTH (DEC_BLOCKSIZE));\n<line7>outbuf = xmalloc (DEC_BLOCKSIZE);\n<line8>#if BASE_TYPE == 42\n<line9>ctx.inbuf = nullptr;\n<line10>#endif\n<line11>base_decode_ctx_init (&ctx);\n<line12>do\n<line13>{\n<line14>bool ok;\n<line15>sum = 0;\n<line16>do\n<line17>{\n<line18>idx_t n = fread (inbuf + sum,\n<line19>1, BASE_LENGTH (DEC_BLOCKSIZE) - sum, in);\n<line20>if (ignore_garbage)\n<line21>{\n<line22>for (idx_t i = 0; n > 0 && i < n;)\n<line23>{\n<line24>if (isbase (inbuf[sum + i]) || inbuf[sum + i] == '=')\n<line25>i++;\n<line26>else\n<line27>memmove (inbuf + sum + i, inbuf + sum + i + 1, --n - i);\n<line28>}\n<line29>}\n<line30>sum += n;\n<line31>if (ferror (in))\n<line32>error (EXIT_FAILURE, errno, _("read error"));\n<line33>}\n<line34>while (sum < BASE_LENGTH (DEC_BLOCKSIZE) && !feof (in));\n<line35>/* The following "loop" is usually iterated just once.\n<line36>However, when it processes the final input buffer, we want\n<line37>to iterate it one additional time, but with an indicator\n<line38>telling it to flush what is in CTX.  */\n<line39>for (int k = 0; k < 1 + !!feof (in); k++)\n<line40>{\n<line41>if (k == 1 && ctx.i == 0)\n<line42>break;\n<line43>idx_t n = DEC_BLOCKSIZE;\n<line44>ok = base_decode_ctx (&ctx, inbuf, (k == 0 ? sum : 0), outbuf, &n);\n<line45>if (fwrite (outbuf, 1, n, out) < n)\n<line46>write_error ();\n<line47>if (!ok)\n<line48>error (EXIT_FAILURE, 0, _("invalid input"));\n<line49>}\n<line50>}\n<line51>while (!feof (in));\n<line52>finish_and_exit (in, infile);\n<line53>}
----------------------------------------
Function: main
Content: <line0>int\n<line1>main (int argc, char **argv)\n<line2>{\n<line3>int opt;\n<line4>FILE *input_fh;\n<line5>char const *infile;\n<line6>/* True if --decode has been given and we should decode data. */\n<line7>bool decode = false;\n<line8>/* True if we should ignore non-base-alphabetic characters. */\n<line9>bool ignore_garbage = false;\n<line10>/* Wrap encoded data around the 76th column, by default. */\n<line11>idx_t wrap_column = 76;\n<line12>#if BASE_TYPE == 42\n<line13>int base_type = 0;\n<line14>#endif\n<line15>initialize_main (&argc, &argv);\n<line16>set_program_name (argv[0]);\n<line17>setlocale (LC_ALL, "");\n<line18>bindtextdomain (PACKAGE, LOCALEDIR);\n<line19>textdomain (PACKAGE);\n<line20>atexit (close_stdout);\n<line21>while ((opt = getopt_long (argc, argv, "diw:", long_options, nullptr)) != -1)\n<line22>switch (opt)\n<line23>{\n<line24>case 'd':\n<line25>decode = true;\n<line26>break;\n<line27>case 'w':\n<line28>{\n<line29>intmax_t w;\n<line30>strtol_error s_err = xstrtoimax (optarg, nullptr, 10, &w, "");\n<line31>if (LONGINT_OVERFLOW < s_err || w < 0)\n<line32>error (EXIT_FAILURE, 0, "%s: %s",\n<line33>_("invalid wrap size"), quote (optarg));\n<line34>wrap_column = s_err == LONGINT_OVERFLOW || IDX_MAX < w ? 0 : w;\n<line35>}\n<line36>break;\n<line37>case 'i':\n<line38>ignore_garbage = true;\n<line39>break;\n<line40>#if BASE_TYPE == 42\n<line41>case BASE64_OPTION:\n<line42>case BASE64URL_OPTION:\n<line43>case BASE32_OPTION:\n<line44>case BASE32HEX_OPTION:\n<line45>case BASE16_OPTION:\n<line46>case BASE2MSBF_OPTION:\n<line47>case BASE2LSBF_OPTION:\n<line48>case Z85_OPTION:\n<line49>base_type = opt;\n<line50>break;\n<line51>#endif\n<line52>case_GETOPT_HELP_CHAR;\n<line53>case_GETOPT_VERSION_CHAR (PROGRAM_NAME, AUTHORS);\n<line54>default:\n<line55>usage (EXIT_FAILURE);\n<line56>break;\n<line57>}\n<line58>#if BASE_TYPE == 42\n<line59>switch (base_type)\n<line60>{\n<line61>case BASE64_OPTION:\n<line62>base_length = base64_length_wrapper;\n<line63>isbase = isbase64;\n<line64>base_encode = base64_encode;\n<line65>base_decode_ctx_init = base64_decode_ctx_init_wrapper;\n<line66>base_decode_ctx = base64_decode_ctx_wrapper;\n<line67>break;\n<line68>case BASE64URL_OPTION:\n<line69>base_length = base64_length_wrapper;\n<line70>isbase = isbase64url;\n<line71>base_encode = base64url_encode;\n<line72>base_decode_ctx_init = base64url_decode_ctx_init_wrapper;\n<line73>base_decode_ctx = base64url_decode_ctx_wrapper;\n<line74>break;\n<line75>case BASE32_OPTION:\n<line76>base_length = base32_length_wrapper;\n<line77>isbase = isbase32;\n<line78>base_encode = base32_encode;\n<line79>base_decode_ctx_init = base32_decode_ctx_init_wrapper;\n<line80>base_decode_ctx = base32_decode_ctx_wrapper;\n<line81>break;\n<line82>case BASE32HEX_OPTION:\n<line83>base_length = base32_length_wrapper;\n<line84>isbase = isbase32hex;\n<line85>base_encode = base32hex_encode;\n<line86>base_decode_ctx_init = base32hex_decode_ctx_init_wrapper;\n<line87>base_decode_ctx = base32hex_decode_ctx_wrapper;\n<line88>break;\n<line89>case BASE16_OPTION:\n<line90>base_length = base16_length;\n<line91>isbase = isbase16;\n<line92>base_encode = base16_encode;\n<line93>base_decode_ctx_init = base16_decode_ctx_init;\n<line94>base_decode_ctx = base16_decode_ctx;\n<line95>break;\n<line96>case BASE2MSBF_OPTION:\n<line97>base_length = base2_length;\n<line98>isbase = isbase2;\n<line99>base_encode = base2msbf_encode;\n<line100>base_decode_ctx_init = base2_decode_ctx_init;\n<line101>base_decode_ctx = base2msbf_decode_ctx;\n<line102>break;\n<line103>case BASE2LSBF_OPTION:\n<line104>base_length = base2_length;\n<line105>isbase = isbase2;\n<line106>base_encode = base2lsbf_encode;\n<line107>base_decode_ctx_init = base2_decode_ctx_init;\n<line108>base_decode_ctx = base2lsbf_decode_ctx;\n<line109>break;\n<line110>case Z85_OPTION:\n<line111>base_length = z85_length;\n<line112>isbase = isz85;\n<line113>base_encode = z85_encode;\n<line114>base_decode_ctx_init = z85_decode_ctx_init;\n<line115>base_decode_ctx = z85_decode_ctx;\n<line116>break;\n<line117>default:\n<line118>error (0, 0, _("missing encoding type"));\n<line119>usage (EXIT_FAILURE);\n<line120>}\n<line121>#endif\n<line122>if (argc - optind > 1)\n<line123>{\n<line124>error (0, 0, _("extra operand %s"), quote (argv[optind + 1]));\n<line125>usage (EXIT_FAILURE);\n<line126>}\n<line127>if (optind < argc)\n<line128>infile = argv[optind];\n<line129>else\n<line130>infile = "-";\n<line131>if (STREQ (infile, "-"))\n<line132>{\n<line133>xset_binary_mode (STDIN_FILENO, O_BINARY);\n<line134>input_fh = stdin;\n<line135>}\n<line136>else\n<line137>{\n<line138>input_fh = fopen (infile, "rb");\n<line139>if (input_fh == nullptr)\n<line140>error (EXIT_FAILURE, errno, "%s", quotef (infile));\n<line141>}\n<line142>fadvise (input_fh, FADVISE_SEQUENTIAL);\n<line143>if (decode)\n<line144>do_decode (input_fh, infile, stdout, ignore_garbage);\n<line145>else\n<line146>do_encode (input_fh, infile, stdout, wrap_column);\n<line147>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/src/basenc.c
========================================
/home/huihui/Downloads/coreutils-9.4/src/basenc.c:184:39: warning: '_Static_assert' with no message is a C2x extension [-Wc2x-extensions]
static_assert (ENC_BLOCKSIZE % 40 == 0); /* Padding chars only on last block. */
                                      ^
                                      , ""
/home/huihui/Downloads/coreutils-9.4/src/basenc.c:185:39: warning: '_Static_assert' with no message is a C2x extension [-Wc2x-extensions]
static_assert (DEC_BLOCKSIZE % 40 == 0); /* Complete encoded blocks are used. */
                                      ^
                                      , ""
2 warnings generated.
Function: usage
Content: <line0>void\n<line1>usage (int status)\n<line2>{\n<line3>if (status != EXIT_SUCCESS)\n<line4>emit_try_help ();\n<line5>else\n<line6>{\n<line7>printf (_("\\n<line8>Usage: %s [OPTION]... [FILE]\n\\n<line9>"), program_name);\n<line10>#if BASE_TYPE == 42\n<line11>fputs (_("\\n<line12>basenc encode or decode FILE, or standard input, to standard output.\n\\n<line13>"), stdout);\n<line14>#else\n<line15>printf (_("\\n<line16>Base%d encode or decode FILE, or standard input, to standard output.\n\\n<line17>"), BASE_TYPE);\n<line18>#endif\n<line19>emit_stdin_note ();\n<line20>emit_mandatory_arg_note ();\n<line21>#if BASE_TYPE == 42\n<line22>fputs (_("\\n<line23>--base64          same as 'base64' program (RFC4648 section 4)\n\\n<line24>"), stdout);\n<line25>fputs (_("\\n<line26>--base64url       file- and url-safe base64 (RFC4648 section 5)\n\\n<line27>"), stdout);\n<line28>fputs (_("\\n<line29>--base32          same as 'base32' program (RFC4648 section 6)\n\\n<line30>"), stdout);\n<line31>fputs (_("\\n<line32>--base32hex       extended hex alphabet base32 (RFC4648 section 7)\n\\n<line33>"), stdout);\n<line34>fputs (_("\\n<line35>--base16          hex encoding (RFC4648 section 8)\n\\n<line36>"), stdout);\n<line37>fputs (_("\\n<line38>--base2msbf       bit string with most significant bit (msb) first\n\\n<line39>"), stdout);\n<line40>fputs (_("\\n<line41>--base2lsbf       bit string with least significant bit (lsb) first\n\\n<line42>"), stdout);\n<line43>#endif\n<line44>fputs (_("\\n<line45>-d, --decode          decode data\n\\n<line46>-i, --ignore-garbage  when decoding, ignore non-alphabet characters\n\\n<line47>-w, --wrap=COLS       wrap encoded lines after COLS character (default 76).\n\\n<line48>Use 0 to disable line wrapping\n\\n<line49>"), stdout);\n<line50>#if BASE_TYPE == 42\n<line51>fputs (_("\\n<line52>--z85             ascii85-like encoding (ZeroMQ spec:32/Z85);\n\\n<line53>when encoding, input length must be a multiple of 4;\n\\n<line54>when decoding, input length must be a multiple of 5\n\\n<line55>"), stdout);\n<line56>#endif\n<line57>fputs (HELP_OPTION_DESCRIPTION, stdout);\n<line58>fputs (VERSION_OPTION_DESCRIPTION, stdout);\n<line59>#if BASE_TYPE == 42\n<line60>fputs (_("\\n<line61>\n\\n<line62>When decoding, the input may contain newlines in addition to the bytes of\n\\n<line63>the formal alphabet.  Use --ignore-garbage to attempt to recover\n\\n<line64>from any other non-alphabet bytes in the encoded stream.\n\\n<line65>"), stdout);\n<line66>#else\n<line67>printf (_("\\n<line68>\n\\n<line69>The data are encoded as described for the %s alphabet in RFC 4648.\n\\n<line70>When decoding, the input may contain newlines in addition to the bytes of\n\\n<line71>the formal %s alphabet.  Use --ignore-garbage to attempt to recover\n\\n<line72>from any other non-alphabet bytes in the encoded stream.\n"),\n<line73>PROGRAM_NAME, PROGRAM_NAME);\n<line74>#endif\n<line75>emit_ancillary_info (PROGRAM_NAME);\n<line76>}\n<line77>exit (status);\n<line78>}
----------------------------------------
Function: wrap_write
Content: <line0>static void\n<line1>wrap_write (char const *buffer, idx_t len,\n<line2>idx_t wrap_column, idx_t *current_column, FILE *out)\n<line3>{\n<line4>if (wrap_column == 0)\n<line5>{\n<line6>/* Simple write. */\n<line7>if (fwrite (buffer, 1, len, stdout) < len)\n<line8>write_error ();\n<line9>}\n<line10>else\n<line11>for (idx_t written = 0; written < len; )\n<line12>{\n<line13>idx_t to_write = MIN (wrap_column - *current_column, len - written);\n<line14>if (to_write == 0)\n<line15>{\n<line16>if (fputc ('\n', out) == EOF)\n<line17>write_error ();\n<line18>*current_column = 0;\n<line19>}\n<line20>else\n<line21>{\n<line22>if (fwrite (buffer + written, 1, to_write, stdout) < to_write)\n<line23>write_error ();\n<line24>*current_column += to_write;\n<line25>written += to_write;\n<line26>}\n<line27>}\n<line28>}
----------------------------------------
Function: finish_and_exit
Content: <line0>static _Noreturn void\n<line1>finish_and_exit (FILE *in, char const *infile)\n<line2>{\n<line3>if (fclose (in) != 0)\n<line4>{\n<line5>if (STREQ (infile, "-"))\n<line6>error (EXIT_FAILURE, errno, _("closing standard input"));\n<line7>else\n<line8>error (EXIT_FAILURE, errno, "%s", quotef (infile));\n<line9>}\n<line10>exit (EXIT_SUCCESS);\n<line11>}
----------------------------------------
Function: do_encode
Content: <line0>static _Noreturn void\n<line1>do_encode (FILE *in, char const *infile, FILE *out, idx_t wrap_column)\n<line2>{\n<line3>idx_t current_column = 0;\n<line4>char *inbuf, *outbuf;\n<line5>idx_t sum;\n<line6>inbuf = xmalloc (ENC_BLOCKSIZE);\n<line7>outbuf = xmalloc (BASE_LENGTH (ENC_BLOCKSIZE));\n<line8>do\n<line9>{\n<line10>idx_t n;\n<line11>sum = 0;\n<line12>do\n<line13>{\n<line14>n = fread (inbuf + sum, 1, ENC_BLOCKSIZE - sum, in);\n<line15>sum += n;\n<line16>}\n<line17>while (!feof (in) && !ferror (in) && sum < ENC_BLOCKSIZE);\n<line18>if (sum > 0)\n<line19>{\n<line20>/* Process input one block at a time.  Note that ENC_BLOCKSIZE\n<line21>is sized so that no pad chars will appear in output. */\n<line22>base_encode (inbuf, sum, outbuf, BASE_LENGTH (sum));\n<line23>wrap_write (outbuf, BASE_LENGTH (sum), wrap_column,\n<line24>&current_column, out);\n<line25>}\n<line26>}\n<line27>while (!feof (in) && !ferror (in) && sum == ENC_BLOCKSIZE);\n<line28>/* When wrapping, terminate last line. */\n<line29>if (wrap_column && current_column > 0 && fputc ('\n', out) == EOF)\n<line30>write_error ();\n<line31>if (ferror (in))\n<line32>error (EXIT_FAILURE, errno, _("read error"));\n<line33>finish_and_exit (in, infile);\n<line34>}
----------------------------------------
Function: do_decode
Content: <line0>static _Noreturn void\n<line1>do_decode (FILE *in, char const *infile, FILE *out, bool ignore_garbage)\n<line2>{\n<line3>char *inbuf, *outbuf;\n<line4>idx_t sum;\n<line5>struct base_decode_context ctx;\n<line6>inbuf = xmalloc (BASE_LENGTH (DEC_BLOCKSIZE));\n<line7>outbuf = xmalloc (DEC_BLOCKSIZE);\n<line8>#if BASE_TYPE == 42\n<line9>ctx.inbuf = nullptr;\n<line10>#endif\n<line11>base_decode_ctx_init (&ctx);\n<line12>do\n<line13>{\n<line14>bool ok;\n<line15>sum = 0;\n<line16>do\n<line17>{\n<line18>idx_t n = fread (inbuf + sum,\n<line19>1, BASE_LENGTH (DEC_BLOCKSIZE) - sum, in);\n<line20>if (ignore_garbage)\n<line21>{\n<line22>for (idx_t i = 0; n > 0 && i < n;)\n<line23>{\n<line24>if (isbase (inbuf[sum + i]) || inbuf[sum + i] == '=')\n<line25>i++;\n<line26>else\n<line27>memmove (inbuf + sum + i, inbuf + sum + i + 1, --n - i);\n<line28>}\n<line29>}\n<line30>sum += n;\n<line31>if (ferror (in))\n<line32>error (EXIT_FAILURE, errno, _("read error"));\n<line33>}\n<line34>while (sum < BASE_LENGTH (DEC_BLOCKSIZE) && !feof (in));\n<line35>/* The following "loop" is usually iterated just once.\n<line36>However, when it processes the final input buffer, we want\n<line37>to iterate it one additional time, but with an indicator\n<line38>telling it to flush what is in CTX.  */\n<line39>for (int k = 0; k < 1 + !!feof (in); k++)\n<line40>{\n<line41>if (k == 1 && ctx.i == 0)\n<line42>break;\n<line43>idx_t n = DEC_BLOCKSIZE;\n<line44>ok = base_decode_ctx (&ctx, inbuf, (k == 0 ? sum : 0), outbuf, &n);\n<line45>if (fwrite (outbuf, 1, n, out) < n)\n<line46>write_error ();\n<line47>if (!ok)\n<line48>error (EXIT_FAILURE, 0, _("invalid input"));\n<line49>}\n<line50>}\n<line51>while (!feof (in));\n<line52>finish_and_exit (in, infile);\n<line53>}
----------------------------------------
Function: main
Content: <line0>int\n<line1>main (int argc, char **argv)\n<line2>{\n<line3>int opt;\n<line4>FILE *input_fh;\n<line5>char const *infile;\n<line6>/* True if --decode has been given and we should decode data. */\n<line7>bool decode = false;\n<line8>/* True if we should ignore non-base-alphabetic characters. */\n<line9>bool ignore_garbage = false;\n<line10>/* Wrap encoded data around the 76th column, by default. */\n<line11>idx_t wrap_column = 76;\n<line12>#if BASE_TYPE == 42\n<line13>int base_type = 0;\n<line14>#endif\n<line15>initialize_main (&argc, &argv);\n<line16>set_program_name (argv[0]);\n<line17>setlocale (LC_ALL, "");\n<line18>bindtextdomain (PACKAGE, LOCALEDIR);\n<line19>textdomain (PACKAGE);\n<line20>atexit (close_stdout);\n<line21>while ((opt = getopt_long (argc, argv, "diw:", long_options, nullptr)) != -1)\n<line22>switch (opt)\n<line23>{\n<line24>case 'd':\n<line25>decode = true;\n<line26>break;\n<line27>case 'w':\n<line28>{\n<line29>intmax_t w;\n<line30>strtol_error s_err = xstrtoimax (optarg, nullptr, 10, &w, "");\n<line31>if (LONGINT_OVERFLOW < s_err || w < 0)\n<line32>error (EXIT_FAILURE, 0, "%s: %s",\n<line33>_("invalid wrap size"), quote (optarg));\n<line34>wrap_column = s_err == LONGINT_OVERFLOW || IDX_MAX < w ? 0 : w;\n<line35>}\n<line36>break;\n<line37>case 'i':\n<line38>ignore_garbage = true;\n<line39>break;\n<line40>#if BASE_TYPE == 42\n<line41>case BASE64_OPTION:\n<line42>case BASE64URL_OPTION:\n<line43>case BASE32_OPTION:\n<line44>case BASE32HEX_OPTION:\n<line45>case BASE16_OPTION:\n<line46>case BASE2MSBF_OPTION:\n<line47>case BASE2LSBF_OPTION:\n<line48>case Z85_OPTION:\n<line49>base_type = opt;\n<line50>break;\n<line51>#endif\n<line52>case_GETOPT_HELP_CHAR;\n<line53>case_GETOPT_VERSION_CHAR (PROGRAM_NAME, AUTHORS);\n<line54>default:\n<line55>usage (EXIT_FAILURE);\n<line56>break;\n<line57>}\n<line58>#if BASE_TYPE == 42\n<line59>switch (base_type)\n<line60>{\n<line61>case BASE64_OPTION:\n<line62>base_length = base64_length_wrapper;\n<line63>isbase = isbase64;\n<line64>base_encode = base64_encode;\n<line65>base_decode_ctx_init = base64_decode_ctx_init_wrapper;\n<line66>base_decode_ctx = base64_decode_ctx_wrapper;\n<line67>break;\n<line68>case BASE64URL_OPTION:\n<line69>base_length = base64_length_wrapper;\n<line70>isbase = isbase64url;\n<line71>base_encode = base64url_encode;\n<line72>base_decode_ctx_init = base64url_decode_ctx_init_wrapper;\n<line73>base_decode_ctx = base64url_decode_ctx_wrapper;\n<line74>break;\n<line75>case BASE32_OPTION:\n<line76>base_length = base32_length_wrapper;\n<line77>isbase = isbase32;\n<line78>base_encode = base32_encode;\n<line79>base_decode_ctx_init = base32_decode_ctx_init_wrapper;\n<line80>base_decode_ctx = base32_decode_ctx_wrapper;\n<line81>break;\n<line82>case BASE32HEX_OPTION:\n<line83>base_length = base32_length_wrapper;\n<line84>isbase = isbase32hex;\n<line85>base_encode = base32hex_encode;\n<line86>base_decode_ctx_init = base32hex_decode_ctx_init_wrapper;\n<line87>base_decode_ctx = base32hex_decode_ctx_wrapper;\n<line88>break;\n<line89>case BASE16_OPTION:\n<line90>base_length = base16_length;\n<line91>isbase = isbase16;\n<line92>base_encode = base16_encode;\n<line93>base_decode_ctx_init = base16_decode_ctx_init;\n<line94>base_decode_ctx = base16_decode_ctx;\n<line95>break;\n<line96>case BASE2MSBF_OPTION:\n<line97>base_length = base2_length;\n<line98>isbase = isbase2;\n<line99>base_encode = base2msbf_encode;\n<line100>base_decode_ctx_init = base2_decode_ctx_init;\n<line101>base_decode_ctx = base2msbf_decode_ctx;\n<line102>break;\n<line103>case BASE2LSBF_OPTION:\n<line104>base_length = base2_length;\n<line105>isbase = isbase2;\n<line106>base_encode = base2lsbf_encode;\n<line107>base_decode_ctx_init = base2_decode_ctx_init;\n<line108>base_decode_ctx = base2lsbf_decode_ctx;\n<line109>break;\n<line110>case Z85_OPTION:\n<line111>base_length = z85_length;\n<line112>isbase = isz85;\n<line113>base_encode = z85_encode;\n<line114>base_decode_ctx_init = z85_decode_ctx_init;\n<line115>base_decode_ctx = z85_decode_ctx;\n<line116>break;\n<line117>default:\n<line118>error (0, 0, _("missing encoding type"));\n<line119>usage (EXIT_FAILURE);\n<line120>}\n<line121>#endif\n<line122>if (argc - optind > 1)\n<line123>{\n<line124>error (0, 0, _("extra operand %s"), quote (argv[optind + 1]));\n<line125>usage (EXIT_FAILURE);\n<line126>}\n<line127>if (optind < argc)\n<line128>infile = argv[optind];\n<line129>else\n<line130>infile = "-";\n<line131>if (STREQ (infile, "-"))\n<line132>{\n<line133>xset_binary_mode (STDIN_FILENO, O_BINARY);\n<line134>input_fh = stdin;\n<line135>}\n<line136>else\n<line137>{\n<line138>input_fh = fopen (infile, "rb");\n<line139>if (input_fh == nullptr)\n<line140>error (EXIT_FAILURE, errno, "%s", quotef (infile));\n<line141>}\n<line142>fadvise (input_fh, FADVISE_SEQUENTIAL);\n<line143>if (decode)\n<line144>do_decode (input_fh, infile, stdout, ignore_garbage);\n<line145>else\n<line146>do_encode (input_fh, infile, stdout, wrap_column);\n<line147>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/src/basenc.c
========================================
/home/huihui/Downloads/coreutils-9.4/src/basenc.c:215:39: warning: '_Static_assert' with no message is a C2x extension [-Wc2x-extensions]
static_assert (DEC_BLOCKSIZE % 40 == 0); /* complete encoded blocks for base32*/
                                      ^
                                      , ""
/home/huihui/Downloads/coreutils-9.4/src/basenc.c:216:39: warning: '_Static_assert' with no message is a C2x extension [-Wc2x-extensions]
static_assert (DEC_BLOCKSIZE % 12 == 0); /* complete encoded blocks for base64*/
                                      ^
                                      , ""
2 warnings generated.
Function: usage
Content: <line0>void\n<line1>usage (int status)\n<line2>{\n<line3>if (status != EXIT_SUCCESS)\n<line4>emit_try_help ();\n<line5>else\n<line6>{\n<line7>printf (_("\\n<line8>Usage: %s [OPTION]... [FILE]\n\\n<line9>"), program_name);\n<line10>#if BASE_TYPE == 42\n<line11>fputs (_("\\n<line12>basenc encode or decode FILE, or standard input, to standard output.\n\\n<line13>"), stdout);\n<line14>#else\n<line15>printf (_("\\n<line16>Base%d encode or decode FILE, or standard input, to standard output.\n\\n<line17>"), BASE_TYPE);\n<line18>#endif\n<line19>emit_stdin_note ();\n<line20>emit_mandatory_arg_note ();\n<line21>#if BASE_TYPE == 42\n<line22>fputs (_("\\n<line23>--base64          same as 'base64' program (RFC4648 section 4)\n\\n<line24>"), stdout);\n<line25>fputs (_("\\n<line26>--base64url       file- and url-safe base64 (RFC4648 section 5)\n\\n<line27>"), stdout);\n<line28>fputs (_("\\n<line29>--base32          same as 'base32' program (RFC4648 section 6)\n\\n<line30>"), stdout);\n<line31>fputs (_("\\n<line32>--base32hex       extended hex alphabet base32 (RFC4648 section 7)\n\\n<line33>"), stdout);\n<line34>fputs (_("\\n<line35>--base16          hex encoding (RFC4648 section 8)\n\\n<line36>"), stdout);\n<line37>fputs (_("\\n<line38>--base2msbf       bit string with most significant bit (msb) first\n\\n<line39>"), stdout);\n<line40>fputs (_("\\n<line41>--base2lsbf       bit string with least significant bit (lsb) first\n\\n<line42>"), stdout);\n<line43>#endif\n<line44>fputs (_("\\n<line45>-d, --decode          decode data\n\\n<line46>-i, --ignore-garbage  when decoding, ignore non-alphabet characters\n\\n<line47>-w, --wrap=COLS       wrap encoded lines after COLS character (default 76).\n\\n<line48>Use 0 to disable line wrapping\n\\n<line49>"), stdout);\n<line50>#if BASE_TYPE == 42\n<line51>fputs (_("\\n<line52>--z85             ascii85-like encoding (ZeroMQ spec:32/Z85);\n\\n<line53>when encoding, input length must be a multiple of 4;\n\\n<line54>when decoding, input length must be a multiple of 5\n\\n<line55>"), stdout);\n<line56>#endif\n<line57>fputs (HELP_OPTION_DESCRIPTION, stdout);\n<line58>fputs (VERSION_OPTION_DESCRIPTION, stdout);\n<line59>#if BASE_TYPE == 42\n<line60>fputs (_("\\n<line61>\n\\n<line62>When decoding, the input may contain newlines in addition to the bytes of\n\\n<line63>the formal alphabet.  Use --ignore-garbage to attempt to recover\n\\n<line64>from any other non-alphabet bytes in the encoded stream.\n\\n<line65>"), stdout);\n<line66>#else\n<line67>printf (_("\\n<line68>\n\\n<line69>The data are encoded as described for the %s alphabet in RFC 4648.\n\\n<line70>When decoding, the input may contain newlines in addition to the bytes of\n\\n<line71>the formal %s alphabet.  Use --ignore-garbage to attempt to recover\n\\n<line72>from any other non-alphabet bytes in the encoded stream.\n"),\n<line73>PROGRAM_NAME, PROGRAM_NAME);\n<line74>#endif\n<line75>emit_ancillary_info (PROGRAM_NAME);\n<line76>}\n<line77>exit (status);\n<line78>}
----------------------------------------
Function: base64_length_wrapper
Content: <line0>static int\n<line1>base64_length_wrapper (int len)\n<line2>{\n<line3>return BASE64_LENGTH (len);\n<line4>}
----------------------------------------
Function: base64_decode_ctx_init_wrapper
Content: <line0>static void\n<line1>base64_decode_ctx_init_wrapper (struct base_decode_context *ctx)\n<line2>{\n<line3>base64_decode_ctx_init (&ctx->ctx.base64);\n<line4>}
----------------------------------------
Function: base64_decode_ctx_wrapper
Content: <line0>static bool\n<line1>base64_decode_ctx_wrapper (struct base_decode_context *ctx,\n<line2>char const *restrict in, idx_t inlen,\n<line3>char *restrict out, idx_t *outlen)\n<line4>{\n<line5>bool b = base64_decode_ctx (&ctx->ctx.base64, in, inlen, out, outlen);\n<line6>ctx->i = ctx->ctx.base64.i;\n<line7>return b;\n<line8>}
----------------------------------------
Function: init_inbuf
Content: <line0>static void\n<line1>init_inbuf (struct base_decode_context *ctx)\n<line2>{\n<line3>ctx->bufsize = DEC_BLOCKSIZE;\n<line4>ctx->inbuf = xcharalloc (ctx->bufsize);\n<line5>}
----------------------------------------
Function: prepare_inbuf
Content: <line0>static void\n<line1>prepare_inbuf (struct base_decode_context *ctx, idx_t inlen)\n<line2>{\n<line3>if (ctx->bufsize < inlen)\n<line4>{\n<line5>ctx->bufsize = inlen * 2;\n<line6>ctx->inbuf = xnrealloc (ctx->inbuf, ctx->bufsize, sizeof (char));\n<line7>}\n<line8>}
----------------------------------------
Function: base64url_encode
Content: <line0>static void\n<line1>base64url_encode (char const *restrict in, idx_t inlen,\n<line2>char *restrict out, idx_t outlen)\n<line3>{\n<line4>base64_encode (in, inlen, out, outlen);\n<line5>/* translate 62nd and 63rd characters */\n<line6>char *p = out;\n<line7>while (outlen--)\n<line8>{\n<line9>if (*p == '+')\n<line10>*p = '-';\n<line11>else if (*p == '/')\n<line12>*p = '_';\n<line13>++p;\n<line14>}\n<line15>}
----------------------------------------
Function: isbase64url
Content: <line0>static bool\n<line1>isbase64url (char ch)\n<line2>{\n<line3>return (ch == '-' || ch == '_'\n<line4>|| (ch != '+' && ch != '/' && isbase64 (ch)));\n<line5>}
----------------------------------------
Function: base64url_decode_ctx_init_wrapper
Content: <line0>static void\n<line1>base64url_decode_ctx_init_wrapper (struct base_decode_context *ctx)\n<line2>{\n<line3>base64_decode_ctx_init (&ctx->ctx.base64);\n<line4>init_inbuf (ctx);\n<line5>}
----------------------------------------
Function: base64url_decode_ctx_wrapper
Content: <line0>static bool\n<line1>base64url_decode_ctx_wrapper (struct base_decode_context *ctx,\n<line2>char const *restrict in, idx_t inlen,\n<line3>char *restrict out, idx_t *outlen)\n<line4>{\n<line5>prepare_inbuf (ctx, inlen);\n<line6>memcpy (ctx->inbuf, in, inlen);\n<line7>/* translate 62nd and 63rd characters */\n<line8>idx_t i = inlen;\n<line9>char *p = ctx->inbuf;\n<line10>while (i--)\n<line11>{\n<line12>if (*p == '+' || *p == '/')\n<line13>{\n<line14>*outlen = 0;\n<line15>return false; /* reject base64 input */\n<line16>}\n<line17>else if (*p == '-')\n<line18>*p = '+';\n<line19>else if (*p == '_')\n<line20>*p = '/';\n<line21>++p;\n<line22>}\n<line23>bool b = base64_decode_ctx (&ctx->ctx.base64, ctx->inbuf, inlen,\n<line24>out, outlen);\n<line25>ctx->i = ctx->ctx.base64.i;\n<line26>return b;\n<line27>}
----------------------------------------
Function: base32_length_wrapper
Content: <line0>static int\n<line1>base32_length_wrapper (int len)\n<line2>{\n<line3>return BASE32_LENGTH (len);\n<line4>}
----------------------------------------
Function: base32_decode_ctx_init_wrapper
Content: <line0>static void\n<line1>base32_decode_ctx_init_wrapper (struct base_decode_context *ctx)\n<line2>{\n<line3>base32_decode_ctx_init (&ctx->ctx.base32);\n<line4>}
----------------------------------------
Function: base32_decode_ctx_wrapper
Content: <line0>static bool\n<line1>base32_decode_ctx_wrapper (struct base_decode_context *ctx,\n<line2>char const *restrict in, idx_t inlen,\n<line3>char *restrict out, idx_t *outlen)\n<line4>{\n<line5>bool b = base32_decode_ctx (&ctx->ctx.base32, in, inlen, out, outlen);\n<line6>ctx->i = ctx->ctx.base32.i;\n<line7>return b;\n<line8>}
----------------------------------------
Function: isbase32hex
Content: <line0>inline static bool\n<line1>isbase32hex (char ch)\n<line2>{\n<line3>return ('0' <= ch && ch <= '9') || ('A' <= ch && ch <= 'V');\n<line4>}
----------------------------------------
Function: base32hex_encode
Content: <line0>static void\n<line1>base32hex_encode (char const *restrict in, idx_t inlen,\n<line2>char *restrict out, idx_t outlen)\n<line3>{\n<line4>base32_encode (in, inlen, out, outlen);\n<line5>for (char *p = out; outlen--; p++)\n<line6>{\n<line7>affirm (0x32 <= *p && *p <= 0x5a);          /* LCOV_EXCL_LINE */\n<line8>*p = base32_norm_to_hex[*p - 0x32];\n<line9>}\n<line10>}
----------------------------------------
Function: base32hex_decode_ctx_init_wrapper
Content: <line0>static void\n<line1>base32hex_decode_ctx_init_wrapper (struct base_decode_context *ctx)\n<line2>{\n<line3>base32_decode_ctx_init (&ctx->ctx.base32);\n<line4>init_inbuf (ctx);\n<line5>}
----------------------------------------
Function: base32hex_decode_ctx_wrapper
Content: <line0>static bool\n<line1>base32hex_decode_ctx_wrapper (struct base_decode_context *ctx,\n<line2>char const *restrict in, idx_t inlen,\n<line3>char *restrict out, idx_t *outlen)\n<line4>{\n<line5>prepare_inbuf (ctx, inlen);\n<line6>idx_t i = inlen;\n<line7>char *p = ctx->inbuf;\n<line8>while (i--)\n<line9>{\n<line10>if (isbase32hex (*in))\n<line11>*p = base32_hex_to_norm[ (int)*in - 0x30];\n<line12>else\n<line13>*p = *in;\n<line14>++p;\n<line15>++in;\n<line16>}\n<line17>bool b = base32_decode_ctx (&ctx->ctx.base32, ctx->inbuf, inlen,\n<line18>out, outlen);\n<line19>ctx->i = ctx->ctx.base32.i;\n<line20>return b;\n<line21>}
----------------------------------------
Function: isbase16
Content: <line0>static bool\n<line1>isbase16 (char ch)\n<line2>{\n<line3>return ('0' <= ch && ch <= '9') || ('A' <= ch && ch <= 'F');\n<line4>}
----------------------------------------
Function: base16_length
Content: <line0>static int\n<line1>base16_length (int len)\n<line2>{\n<line3>return len * 2;\n<line4>}
----------------------------------------
Function: base16_encode
Content: <line0>static void\n<line1>base16_encode (char const *restrict in, idx_t inlen,\n<line2>char *restrict out, idx_t outlen)\n<line3>{\n<line4>while (inlen--)\n<line5>{\n<line6>unsigned char c = *in;\n<line7>*out++ = base16[c >> 4];\n<line8>*out++ = base16[c & 0x0F];\n<line9>++in;\n<line10>}\n<line11>}
----------------------------------------
Function: base16_decode_ctx_init
Content: <line0>static void\n<line1>base16_decode_ctx_init (struct base_decode_context *ctx)\n<line2>{\n<line3>init_inbuf (ctx);\n<line4>ctx->ctx.base16.have_nibble = false;\n<line5>ctx->i = 1;\n<line6>}
----------------------------------------
Function: base16_decode_ctx
Content: <line0>static bool\n<line1>base16_decode_ctx (struct base_decode_context *ctx,\n<line2>char const *restrict in, idx_t inlen,\n<line3>char *restrict out, idx_t *outlen)\n<line4>{\n<line5>bool ignore_lines = true;  /* for now, always ignore them */\n<line6>*outlen = 0;\n<line7>/* inlen==0 is request to flush output.\n<line8>if there is a dangling high nibble - we are missing the low nibble,\n<line9>so return false - indicating an invalid input.  */\n<line10>if (inlen == 0)\n<line11>return !ctx->ctx.base16.have_nibble;\n<line12>while (inlen--)\n<line13>{\n<line14>if (ignore_lines && *in == '\n')\n<line15>{\n<line16>++in;\n<line17>continue;\n<line18>}\n<line19>int nib = *in++;\n<line20>if ('0' <= nib && nib <= '9')\n<line21>nib -= '0';\n<line22>else if ('A' <= nib && nib <= 'F')\n<line23>nib -= 'A' - 10;\n<line24>else\n<line25>return false; /* garbage - return false */\n<line26>if (ctx->ctx.base16.have_nibble)\n<line27>{\n<line28>/* have both nibbles, write octet */\n<line29>*out++ = (ctx->ctx.base16.nibble << 4) + nib;\n<line30>++(*outlen);\n<line31>}\n<line32>else\n<line33>{\n<line34>/* Store higher nibble until next one arrives */\n<line35>ctx->ctx.base16.nibble = nib;\n<line36>}\n<line37>ctx->ctx.base16.have_nibble = !ctx->ctx.base16.have_nibble;\n<line38>}\n<line39>return true;\n<line40>}
----------------------------------------
Function: z85_length
Content: <line0>static int\n<line1>z85_length (int len)\n<line2>{\n<line3>/* Z85 does not allow padding, so no need to round to highest integer.  */\n<line4>int outlen = (len * 5) / 4;\n<line5>return outlen;\n<line6>}
----------------------------------------
Function: isz85
Content: <line0>static bool\n<line1>isz85 (char ch)\n<line2>{\n<line3>return c_isalnum (ch) || strchr (".-:+=^!/*?&<>()[]{}@%$#", ch) != nullptr;\n<line4>}
----------------------------------------
Function: z85_encode
Content: <line0>static void\n<line1>z85_encode (char const *restrict in, idx_t inlen,\n<line2>char *restrict out, idx_t outlen)\n<line3>{\n<line4>int i = 0;\n<line5>unsigned char quad[4];\n<line6>idx_t outidx = 0;\n<line7>while (true)\n<line8>{\n<line9>if (inlen == 0)\n<line10>{\n<line11>/* no more input, exactly on 4 octet boundary. */\n<line12>if (i == 0)\n<line13>return;\n<line14>/* currently, there's no way to return an error in encoding.  */\n<line15>error (EXIT_FAILURE, 0,\n<line16>_("invalid input (length must be multiple of 4 characters)"));\n<line17>}\n<line18>else\n<line19>{\n<line20>quad[i++] = *in++;\n<line21>--inlen;\n<line22>}\n<line23>/* Got a quad, encode it */\n<line24>if (i == 4)\n<line25>{\n<line26>int_fast64_t val = quad[0];\n<line27>val = (val << 24) + (quad[1] << 16) + (quad[2] << 8) + quad[3];\n<line28>for (int j = 4; j >= 0; --j)\n<line29>{\n<line30>int c = val % 85;\n<line31>val /= 85;\n<line32>/* NOTE: if there is padding (which is trimmed by z85\n<line33>before outputting the result), the output buffer 'out'\n<line34>might not include enough allocated bytes for the padding,\n<line35>so don't store them. */\n<line36>if (outidx + j < outlen)\n<line37>out[j] = z85_encoding[c];\n<line38>}\n<line39>out += 5;\n<line40>outidx += 5;\n<line41>i = 0;\n<line42>}\n<line43>}\n<line44>}
----------------------------------------
Function: z85_decode_ctx_init
Content: <line0>static void\n<line1>z85_decode_ctx_init (struct base_decode_context *ctx)\n<line2>{\n<line3>init_inbuf (ctx);\n<line4>ctx->ctx.z85.i = 0;\n<line5>ctx->i = 1;\n<line6>}
----------------------------------------
Function: z85_decode_ctx
Content: <line0>static bool\n<line1>z85_decode_ctx (struct base_decode_context *ctx,\n<line2>char const *restrict in, idx_t inlen,\n<line3>char *restrict out, idx_t *outlen)\n<line4>{\n<line5>bool ignore_lines = true;  /* for now, always ignore them */\n<line6>*outlen = 0;\n<line7>/* inlen==0 is request to flush output.\n<line8>if there are dangling values - we are missing entries,\n<line9>so return false - indicating an invalid input.  */\n<line10>if (inlen == 0)\n<line11>{\n<line12>if (ctx->ctx.z85.i > 0)\n<line13>{\n<line14>/* Z85 variant does not allow padding - input must\n<line15>be a multiple of 5 - so return error.  */\n<line16>return false;\n<line17>}\n<line18>return true;\n<line19>}\n<line20>while (inlen--)\n<line21>{\n<line22>if (ignore_lines && *in == '\n')\n<line23>{\n<line24>++in;\n<line25>continue;\n<line26>}\n<line27>/* z85 decoding */\n<line28>unsigned char c = *in;\n<line29>if (c >= 33 && c <= 125)\n<line30>{\n<line31>signed char ch = z85_decoding[c - 33];\n<line32>if (ch < 0)\n<line33>return false; /* garbage - return false */\n<line34>c = ch;\n<line35>}\n<line36>else\n<line37>return false; /* garbage - return false */\n<line38>++in;\n<line39>ctx->ctx.z85.octets[ctx->ctx.z85.i++] = c;\n<line40>if (ctx->ctx.z85.i == 5)\n<line41>{\n<line42>/* decode the lowest 4 octets, then check for overflows.  */\n<line43>int_fast64_t val = Z85_LO_CTX_TO_32BIT_VAL (ctx);\n<line44>/* The Z85 spec and the reference implementation say nothing\n<line45>about overflows. To be on the safe side, reject them.  */\n<line46>val += Z85_HI_CTX_TO_32BIT_VAL (ctx);\n<line47>if ((val >> 24) & ~0xFF)\n<line48>return false;\n<line49>*out++ = val >> 24;\n<line50>*out++ = (val >> 16) & 0xFF;\n<line51>*out++ = (val >> 8) & 0xFF;\n<line52>*out++ = val & 0xFF;\n<line53>*outlen += 4;\n<line54>ctx->ctx.z85.i = 0;\n<line55>}\n<line56>}\n<line57>ctx->i = ctx->ctx.z85.i;\n<line58>return true;\n<line59>}
----------------------------------------
Function: isbase2
Content: <line0>inline static bool\n<line1>isbase2 (char ch)\n<line2>{\n<line3>return ch == '0' || ch == '1';\n<line4>}
----------------------------------------
Function: base2_length
Content: <line0>static int\n<line1>base2_length (int len)\n<line2>{\n<line3>return len * 8;\n<line4>}
----------------------------------------
Function: base2msbf_encode
Content: <line0>inline static void\n<line1>base2msbf_encode (char const *restrict in, idx_t inlen,\n<line2>char *restrict out, idx_t outlen)\n<line3>{\n<line4>while (inlen--)\n<line5>{\n<line6>unsigned char c = *in;\n<line7>for (int i = 0; i < 8; i++)\n<line8>{\n<line9>*out++ = c & 0x80 ? '1' : '0';\n<line10>c <<= 1;\n<line11>}\n<line12>outlen -= 8;\n<line13>++in;\n<line14>}\n<line15>}
----------------------------------------
Function: base2lsbf_encode
Content: <line0>inline static void\n<line1>base2lsbf_encode (char const *restrict in, idx_t inlen,\n<line2>char *restrict out, idx_t outlen)\n<line3>{\n<line4>while (inlen--)\n<line5>{\n<line6>unsigned char c = *in;\n<line7>for (int i = 0; i < 8; i++)\n<line8>{\n<line9>*out++ = c & 0x01 ? '1' : '0';\n<line10>c >>= 1;\n<line11>}\n<line12>outlen -= 8;\n<line13>++in;\n<line14>}\n<line15>}
----------------------------------------
Function: base2_decode_ctx_init
Content: <line0>static void\n<line1>base2_decode_ctx_init (struct base_decode_context *ctx)\n<line2>{\n<line3>init_inbuf (ctx);\n<line4>ctx->ctx.base2.octet = 0;\n<line5>ctx->i = 0;\n<line6>}
----------------------------------------
Function: base2lsbf_decode_ctx
Content: <line0>static bool\n<line1>base2lsbf_decode_ctx (struct base_decode_context *ctx,\n<line2>char const *restrict in, idx_t inlen,\n<line3>char *restrict out, idx_t *outlen)\n<line4>{\n<line5>bool ignore_lines = true;  /* for now, always ignore them */\n<line6>*outlen = 0;\n<line7>/* inlen==0 is request to flush output.\n<line8>if there is a dangling bit - we are missing some bits,\n<line9>so return false - indicating an invalid input.  */\n<line10>if (inlen == 0)\n<line11>return ctx->i == 0;\n<line12>while (inlen--)\n<line13>{\n<line14>if (ignore_lines && *in == '\n')\n<line15>{\n<line16>++in;\n<line17>continue;\n<line18>}\n<line19>if (!isbase2 (*in))\n<line20>return false;\n<line21>bool bit = (*in == '1');\n<line22>ctx->ctx.base2.octet |= bit << ctx->i;\n<line23>++ctx->i;\n<line24>if (ctx->i == 8)\n<line25>{\n<line26>*out++ = ctx->ctx.base2.octet;\n<line27>ctx->ctx.base2.octet = 0;\n<line28>++*outlen;\n<line29>ctx->i = 0;\n<line30>}\n<line31>++in;\n<line32>}\n<line33>return true;\n<line34>}
----------------------------------------
Function: base2msbf_decode_ctx
Content: <line0>static bool\n<line1>base2msbf_decode_ctx (struct base_decode_context *ctx,\n<line2>char const *restrict in, idx_t inlen,\n<line3>char *restrict out, idx_t *outlen)\n<line4>{\n<line5>bool ignore_lines = true;  /* for now, always ignore them */\n<line6>*outlen = 0;\n<line7>/* inlen==0 is request to flush output.\n<line8>if there is a dangling bit - we are missing some bits,\n<line9>so return false - indicating an invalid input.  */\n<line10>if (inlen == 0)\n<line11>return ctx->i == 0;\n<line12>while (inlen--)\n<line13>{\n<line14>if (ignore_lines && *in == '\n')\n<line15>{\n<line16>++in;\n<line17>continue;\n<line18>}\n<line19>if (!isbase2 (*in))\n<line20>return false;\n<line21>bool bit = (*in == '1');\n<line22>if (ctx->i == 0)\n<line23>ctx->i = 8;\n<line24>--ctx->i;\n<line25>ctx->ctx.base2.octet |= bit << ctx->i;\n<line26>if (ctx->i == 0)\n<line27>{\n<line28>*out++ = ctx->ctx.base2.octet;\n<line29>ctx->ctx.base2.octet = 0;\n<line30>++*outlen;\n<line31>ctx->i = 0;\n<line32>}\n<line33>++in;\n<line34>}\n<line35>return true;\n<line36>}
----------------------------------------
Function: wrap_write
Content: <line0>static void\n<line1>wrap_write (char const *buffer, idx_t len,\n<line2>idx_t wrap_column, idx_t *current_column, FILE *out)\n<line3>{\n<line4>if (wrap_column == 0)\n<line5>{\n<line6>/* Simple write. */\n<line7>if (fwrite (buffer, 1, len, stdout) < len)\n<line8>write_error ();\n<line9>}\n<line10>else\n<line11>for (idx_t written = 0; written < len; )\n<line12>{\n<line13>idx_t to_write = MIN (wrap_column - *current_column, len - written);\n<line14>if (to_write == 0)\n<line15>{\n<line16>if (fputc ('\n', out) == EOF)\n<line17>write_error ();\n<line18>*current_column = 0;\n<line19>}\n<line20>else\n<line21>{\n<line22>if (fwrite (buffer + written, 1, to_write, stdout) < to_write)\n<line23>write_error ();\n<line24>*current_column += to_write;\n<line25>written += to_write;\n<line26>}\n<line27>}\n<line28>}
----------------------------------------
Function: finish_and_exit
Content: <line0>static _Noreturn void\n<line1>finish_and_exit (FILE *in, char const *infile)\n<line2>{\n<line3>if (fclose (in) != 0)\n<line4>{\n<line5>if (STREQ (infile, "-"))\n<line6>error (EXIT_FAILURE, errno, _("closing standard input"));\n<line7>else\n<line8>error (EXIT_FAILURE, errno, "%s", quotef (infile));\n<line9>}\n<line10>exit (EXIT_SUCCESS);\n<line11>}
----------------------------------------
Function: do_encode
Content: <line0>static _Noreturn void\n<line1>do_encode (FILE *in, char const *infile, FILE *out, idx_t wrap_column)\n<line2>{\n<line3>idx_t current_column = 0;\n<line4>char *inbuf, *outbuf;\n<line5>idx_t sum;\n<line6>inbuf = xmalloc (ENC_BLOCKSIZE);\n<line7>outbuf = xmalloc (BASE_LENGTH (ENC_BLOCKSIZE));\n<line8>do\n<line9>{\n<line10>idx_t n;\n<line11>sum = 0;\n<line12>do\n<line13>{\n<line14>n = fread (inbuf + sum, 1, ENC_BLOCKSIZE - sum, in);\n<line15>sum += n;\n<line16>}\n<line17>while (!feof (in) && !ferror (in) && sum < ENC_BLOCKSIZE);\n<line18>if (sum > 0)\n<line19>{\n<line20>/* Process input one block at a time.  Note that ENC_BLOCKSIZE\n<line21>is sized so that no pad chars will appear in output. */\n<line22>base_encode (inbuf, sum, outbuf, BASE_LENGTH (sum));\n<line23>wrap_write (outbuf, BASE_LENGTH (sum), wrap_column,\n<line24>&current_column, out);\n<line25>}\n<line26>}\n<line27>while (!feof (in) && !ferror (in) && sum == ENC_BLOCKSIZE);\n<line28>/* When wrapping, terminate last line. */\n<line29>if (wrap_column && current_column > 0 && fputc ('\n', out) == EOF)\n<line30>write_error ();\n<line31>if (ferror (in))\n<line32>error (EXIT_FAILURE, errno, _("read error"));\n<line33>finish_and_exit (in, infile);\n<line34>}
----------------------------------------
Function: do_decode
Content: <line0>static _Noreturn void\n<line1>do_decode (FILE *in, char const *infile, FILE *out, bool ignore_garbage)\n<line2>{\n<line3>char *inbuf, *outbuf;\n<line4>idx_t sum;\n<line5>struct base_decode_context ctx;\n<line6>inbuf = xmalloc (BASE_LENGTH (DEC_BLOCKSIZE));\n<line7>outbuf = xmalloc (DEC_BLOCKSIZE);\n<line8>#if BASE_TYPE == 42\n<line9>ctx.inbuf = nullptr;\n<line10>#endif\n<line11>base_decode_ctx_init (&ctx);\n<line12>do\n<line13>{\n<line14>bool ok;\n<line15>sum = 0;\n<line16>do\n<line17>{\n<line18>idx_t n = fread (inbuf + sum,\n<line19>1, BASE_LENGTH (DEC_BLOCKSIZE) - sum, in);\n<line20>if (ignore_garbage)\n<line21>{\n<line22>for (idx_t i = 0; n > 0 && i < n;)\n<line23>{\n<line24>if (isbase (inbuf[sum + i]) || inbuf[sum + i] == '=')\n<line25>i++;\n<line26>else\n<line27>memmove (inbuf + sum + i, inbuf + sum + i + 1, --n - i);\n<line28>}\n<line29>}\n<line30>sum += n;\n<line31>if (ferror (in))\n<line32>error (EXIT_FAILURE, errno, _("read error"));\n<line33>}\n<line34>while (sum < BASE_LENGTH (DEC_BLOCKSIZE) && !feof (in));\n<line35>/* The following "loop" is usually iterated just once.\n<line36>However, when it processes the final input buffer, we want\n<line37>to iterate it one additional time, but with an indicator\n<line38>telling it to flush what is in CTX.  */\n<line39>for (int k = 0; k < 1 + !!feof (in); k++)\n<line40>{\n<line41>if (k == 1 && ctx.i == 0)\n<line42>break;\n<line43>idx_t n = DEC_BLOCKSIZE;\n<line44>ok = base_decode_ctx (&ctx, inbuf, (k == 0 ? sum : 0), outbuf, &n);\n<line45>if (fwrite (outbuf, 1, n, out) < n)\n<line46>write_error ();\n<line47>if (!ok)\n<line48>error (EXIT_FAILURE, 0, _("invalid input"));\n<line49>}\n<line50>}\n<line51>while (!feof (in));\n<line52>finish_and_exit (in, infile);\n<line53>}
----------------------------------------
Function: main
Content: <line0>int\n<line1>main (int argc, char **argv)\n<line2>{\n<line3>int opt;\n<line4>FILE *input_fh;\n<line5>char const *infile;\n<line6>/* True if --decode has been given and we should decode data. */\n<line7>bool decode = false;\n<line8>/* True if we should ignore non-base-alphabetic characters. */\n<line9>bool ignore_garbage = false;\n<line10>/* Wrap encoded data around the 76th column, by default. */\n<line11>idx_t wrap_column = 76;\n<line12>#if BASE_TYPE == 42\n<line13>int base_type = 0;\n<line14>#endif\n<line15>initialize_main (&argc, &argv);\n<line16>set_program_name (argv[0]);\n<line17>setlocale (LC_ALL, "");\n<line18>bindtextdomain (PACKAGE, LOCALEDIR);\n<line19>textdomain (PACKAGE);\n<line20>atexit (close_stdout);\n<line21>while ((opt = getopt_long (argc, argv, "diw:", long_options, nullptr)) != -1)\n<line22>switch (opt)\n<line23>{\n<line24>case 'd':\n<line25>decode = true;\n<line26>break;\n<line27>case 'w':\n<line28>{\n<line29>intmax_t w;\n<line30>strtol_error s_err = xstrtoimax (optarg, nullptr, 10, &w, "");\n<line31>if (LONGINT_OVERFLOW < s_err || w < 0)\n<line32>error (EXIT_FAILURE, 0, "%s: %s",\n<line33>_("invalid wrap size"), quote (optarg));\n<line34>wrap_column = s_err == LONGINT_OVERFLOW || IDX_MAX < w ? 0 : w;\n<line35>}\n<line36>break;\n<line37>case 'i':\n<line38>ignore_garbage = true;\n<line39>break;\n<line40>#if BASE_TYPE == 42\n<line41>case BASE64_OPTION:\n<line42>case BASE64URL_OPTION:\n<line43>case BASE32_OPTION:\n<line44>case BASE32HEX_OPTION:\n<line45>case BASE16_OPTION:\n<line46>case BASE2MSBF_OPTION:\n<line47>case BASE2LSBF_OPTION:\n<line48>case Z85_OPTION:\n<line49>base_type = opt;\n<line50>break;\n<line51>#endif\n<line52>case_GETOPT_HELP_CHAR;\n<line53>case_GETOPT_VERSION_CHAR (PROGRAM_NAME, AUTHORS);\n<line54>default:\n<line55>usage (EXIT_FAILURE);\n<line56>break;\n<line57>}\n<line58>#if BASE_TYPE == 42\n<line59>switch (base_type)\n<line60>{\n<line61>case BASE64_OPTION:\n<line62>base_length = base64_length_wrapper;\n<line63>isbase = isbase64;\n<line64>base_encode = base64_encode;\n<line65>base_decode_ctx_init = base64_decode_ctx_init_wrapper;\n<line66>base_decode_ctx = base64_decode_ctx_wrapper;\n<line67>break;\n<line68>case BASE64URL_OPTION:\n<line69>base_length = base64_length_wrapper;\n<line70>isbase = isbase64url;\n<line71>base_encode = base64url_encode;\n<line72>base_decode_ctx_init = base64url_decode_ctx_init_wrapper;\n<line73>base_decode_ctx = base64url_decode_ctx_wrapper;\n<line74>break;\n<line75>case BASE32_OPTION:\n<line76>base_length = base32_length_wrapper;\n<line77>isbase = isbase32;\n<line78>base_encode = base32_encode;\n<line79>base_decode_ctx_init = base32_decode_ctx_init_wrapper;\n<line80>base_decode_ctx = base32_decode_ctx_wrapper;\n<line81>break;\n<line82>case BASE32HEX_OPTION:\n<line83>base_length = base32_length_wrapper;\n<line84>isbase = isbase32hex;\n<line85>base_encode = base32hex_encode;\n<line86>base_decode_ctx_init = base32hex_decode_ctx_init_wrapper;\n<line87>base_decode_ctx = base32hex_decode_ctx_wrapper;\n<line88>break;\n<line89>case BASE16_OPTION:\n<line90>base_length = base16_length;\n<line91>isbase = isbase16;\n<line92>base_encode = base16_encode;\n<line93>base_decode_ctx_init = base16_decode_ctx_init;\n<line94>base_decode_ctx = base16_decode_ctx;\n<line95>break;\n<line96>case BASE2MSBF_OPTION:\n<line97>base_length = base2_length;\n<line98>isbase = isbase2;\n<line99>base_encode = base2msbf_encode;\n<line100>base_decode_ctx_init = base2_decode_ctx_init;\n<line101>base_decode_ctx = base2msbf_decode_ctx;\n<line102>break;\n<line103>case BASE2LSBF_OPTION:\n<line104>base_length = base2_length;\n<line105>isbase = isbase2;\n<line106>base_encode = base2lsbf_encode;\n<line107>base_decode_ctx_init = base2_decode_ctx_init;\n<line108>base_decode_ctx = base2lsbf_decode_ctx;\n<line109>break;\n<line110>case Z85_OPTION:\n<line111>base_length = z85_length;\n<line112>isbase = isz85;\n<line113>base_encode = z85_encode;\n<line114>base_decode_ctx_init = z85_decode_ctx_init;\n<line115>base_decode_ctx = z85_decode_ctx;\n<line116>break;\n<line117>default:\n<line118>error (0, 0, _("missing encoding type"));\n<line119>usage (EXIT_FAILURE);\n<line120>}\n<line121>#endif\n<line122>if (argc - optind > 1)\n<line123>{\n<line124>error (0, 0, _("extra operand %s"), quote (argv[optind + 1]));\n<line125>usage (EXIT_FAILURE);\n<line126>}\n<line127>if (optind < argc)\n<line128>infile = argv[optind];\n<line129>else\n<line130>infile = "-";\n<line131>if (STREQ (infile, "-"))\n<line132>{\n<line133>xset_binary_mode (STDIN_FILENO, O_BINARY);\n<line134>input_fh = stdin;\n<line135>}\n<line136>else\n<line137>{\n<line138>input_fh = fopen (infile, "rb");\n<line139>if (input_fh == nullptr)\n<line140>error (EXIT_FAILURE, errno, "%s", quotef (infile));\n<line141>}\n<line142>fadvise (input_fh, FADVISE_SEQUENTIAL);\n<line143>if (decode)\n<line144>do_decode (input_fh, infile, stdout, ignore_garbage);\n<line145>else\n<line146>do_encode (input_fh, infile, stdout, wrap_column);\n<line147>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/src/basename.c
========================================
Function: usage
Content: <line0>void\n<line1>usage (int status)\n<line2>{\n<line3>if (status != EXIT_SUCCESS)\n<line4>emit_try_help ();\n<line5>else\n<line6>{\n<line7>printf (_("\\n<line8>Usage: %s NAME [SUFFIX]\n\\n<line9>or:  %s OPTION... NAME...\n\\n<line10>"),\n<line11>program_name, program_name);\n<line12>fputs (_("\\n<line13>Print NAME with any leading directory components removed.\n\\n<line14>If specified, also remove a trailing SUFFIX.\n\\n<line15>"), stdout);\n<line16>emit_mandatory_arg_note ();\n<line17>fputs (_("\\n<line18>-a, --multiple       support multiple arguments and treat each as a NAME\n\\n<line19>-s, --suffix=SUFFIX  remove a trailing SUFFIX; implies -a\n\\n<line20>-z, --zero           end each output line with NUL, not newline\n\\n<line21>"), stdout);\n<line22>fputs (HELP_OPTION_DESCRIPTION, stdout);\n<line23>fputs (VERSION_OPTION_DESCRIPTION, stdout);\n<line24>printf (_("\\n<line25>\n\\n<line26>Examples:\n\\n<line27>%s /usr/bin/sort          -> \"sort\"\n\\n<line28>%s include/stdio.h .h     -> \"stdio\"\n\\n<line29>%s -s .h include/stdio.h  -> \"stdio\"\n\\n<line30>%s -a any/str1 any/str2   -> \"str1\" followed by \"str2\"\n\\n<line31>"),\n<line32>program_name, program_name, program_name, program_name);\n<line33>emit_ancillary_info (PROGRAM_NAME);\n<line34>}\n<line35>exit (status);\n<line36>}
----------------------------------------
Function: remove_suffix
Content: <line0>static void\n<line1>remove_suffix (char *name, char const *suffix)\n<line2>{\n<line3>char *np;\n<line4>char const *sp;\n<line5>np = name + strlen (name);\n<line6>sp = suffix + strlen (suffix);\n<line7>while (np > name && sp > suffix)\n<line8>if (*--np != *--sp)\n<line9>return;\n<line10>if (np > name)\n<line11>*np = '\0';\n<line12>}
----------------------------------------
Function: perform_basename
Content: <line0>static void\n<line1>perform_basename (char const *string, char const *suffix, bool use_nuls)\n<line2>{\n<line3>char *name = base_name (string);\n<line4>strip_trailing_slashes (name);\n<line5>/* Per POSIX, 'basename // /' must return '//' on platforms with\n<line6>distinct //.  On platforms with drive letters, this generalizes\n<line7>to making 'basename c: :' return 'c:'.  This rule is captured by\n<line8>skipping suffix stripping if base_name returned an absolute path\n<line9>or a drive letter (only possible if name is a file-system\n<line10>root).  */\n<line11>if (suffix && IS_RELATIVE_FILE_NAME (name) && ! FILE_SYSTEM_PREFIX_LEN (name))\n<line12>remove_suffix (name, suffix);\n<line13>fputs (name, stdout);\n<line14>putchar (use_nuls ? '\0' : '\n');\n<line15>free (name);\n<line16>}
----------------------------------------
Function: main
Content: <line0>int\n<line1>main (int argc, char **argv)\n<line2>{\n<line3>bool multiple_names = false;\n<line4>bool use_nuls = false;\n<line5>char const *suffix = nullptr;\n<line6>initialize_main (&argc, &argv);\n<line7>set_program_name (argv[0]);\n<line8>setlocale (LC_ALL, "");\n<line9>bindtextdomain (PACKAGE, LOCALEDIR);\n<line10>textdomain (PACKAGE);\n<line11>atexit (close_stdout);\n<line12>while (true)\n<line13>{\n<line14>int c = getopt_long (argc, argv, "+as:z", longopts, nullptr);\n<line15>if (c == -1)\n<line16>break;\n<line17>switch (c)\n<line18>{\n<line19>case 's':\n<line20>suffix = optarg;\n<line21>/* -s implies -a, so...  */\n<line22>FALLTHROUGH;\n<line23>case 'a':\n<line24>multiple_names = true;\n<line25>break;\n<line26>case 'z':\n<line27>use_nuls = true;\n<line28>break;\n<line29>case_GETOPT_HELP_CHAR;\n<line30>case_GETOPT_VERSION_CHAR (PROGRAM_NAME, AUTHORS);\n<line31>default:\n<line32>usage (EXIT_FAILURE);\n<line33>}\n<line34>}\n<line35>if (argc < optind + 1)\n<line36>{\n<line37>error (0, 0, _("missing operand"));\n<line38>usage (EXIT_FAILURE);\n<line39>}\n<line40>if (!multiple_names && optind + 2 < argc)\n<line41>{\n<line42>error (0, 0, _("extra operand %s"), quote (argv[optind + 2]));\n<line43>usage (EXIT_FAILURE);\n<line44>}\n<line45>if (multiple_names)\n<line46>{\n<line47>for (; optind < argc; optind++)\n<line48>perform_basename (argv[optind], suffix, use_nuls);\n<line49>}\n<line50>else\n<line51>perform_basename (argv[optind],\n<line52>optind + 2 == argc ? argv[optind + 1] : nullptr,\n<line53>use_nuls);\n<line54>return EXIT_SUCCESS;\n<line55>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/src/cat.c
========================================
Function: usage
Content: <line0>void\n<line1>usage (int status)\n<line2>{\n<line3>if (status != EXIT_SUCCESS)\n<line4>emit_try_help ();\n<line5>else\n<line6>{\n<line7>printf (_("\\n<line8>Usage: %s [OPTION]... [FILE]...\n\\n<line9>"),\n<line10>program_name);\n<line11>fputs (_("\\n<line12>Concatenate FILE(s) to standard output.\n\\n<line13>"), stdout);\n<line14>emit_stdin_note ();\n<line15>fputs (_("\\n<line16>\n\\n<line17>-A, --show-all           equivalent to -vET\n\\n<line18>-b, --number-nonblank    number nonempty output lines, overrides -n\n\\n<line19>-e                       equivalent to -vE\n\\n<line20>-E, --show-ends          display $ at end of each line\n\\n<line21>-n, --number             number all output lines\n\\n<line22>-s, --squeeze-blank      suppress repeated empty output lines\n\\n<line23>"), stdout);\n<line24>fputs (_("\\n<line25>-t                       equivalent to -vT\n\\n<line26>-T, --show-tabs          display TAB characters as ^I\n\\n<line27>-u                       (ignored)\n\\n<line28>-v, --show-nonprinting   use ^ and M- notation, except for LFD and TAB\n\\n<line29>"), stdout);\n<line30>fputs (HELP_OPTION_DESCRIPTION, stdout);\n<line31>fputs (VERSION_OPTION_DESCRIPTION, stdout);\n<line32>printf (_("\\n<line33>\n\\n<line34>Examples:\n\\n<line35>%s f - g  Output f's contents, then standard input, then g's contents.\n\\n<line36>%s        Copy standard input to standard output.\n\\n<line37>"),\n<line38>program_name, program_name);\n<line39>emit_ancillary_info (PROGRAM_NAME);\n<line40>}\n<line41>exit (status);\n<line42>}
----------------------------------------
Function: next_line_num
Content: <line0>static void\n<line1>next_line_num (void)\n<line2>{\n<line3>char *endp = line_num_end;\n<line4>do\n<line5>{\n<line6>if ((*endp)++ < '9')\n<line7>return;\n<line8>*endp-- = '0';\n<line9>}\n<line10>while (endp >= line_num_start);\n<line11>if (line_num_start > line_buf)\n<line12>*--line_num_start = '1';\n<line13>else\n<line14>*line_buf = '>';\n<line15>if (line_num_start < line_num_print)\n<line16>line_num_print--;\n<line17>}
----------------------------------------
Function: simple_cat
Content: <line0>static bool\n<line1>simple_cat (char *buf, idx_t bufsize)\n<line2>{\n<line3>/* Loop until the end of the file.  */\n<line4>while (true)\n<line5>{\n<line6>/* Read a block of input.  */\n<line7>size_t n_read = safe_read (input_desc, buf, bufsize);\n<line8>if (n_read == SAFE_READ_ERROR)\n<line9>{\n<line10>error (0, errno, "%s", quotef (infile));\n<line11>return false;\n<line12>}\n<line13>/* End of this file?  */\n<line14>if (n_read == 0)\n<line15>return true;\n<line16>/* Write this block out.  */\n<line17>if (full_write (STDOUT_FILENO, buf, n_read) != n_read)\n<line18>write_error ();\n<line19>}\n<line20>}
----------------------------------------
Function: write_pending
Content: <line0>static inline void\n<line1>write_pending (char *outbuf, char **bpout)\n<line2>{\n<line3>idx_t n_write = *bpout - outbuf;\n<line4>if (0 < n_write)\n<line5>{\n<line6>if (full_write (STDOUT_FILENO, outbuf, n_write) != n_write)\n<line7>write_error ();\n<line8>*bpout = outbuf;\n<line9>}\n<line10>}
----------------------------------------
Function: cat
Content: <line0>static bool\n<line1>cat (char *inbuf, idx_t insize, char *outbuf, idx_t outsize,\n<line2>bool show_nonprinting, bool show_tabs, bool number, bool number_nonblank,\n<line3>bool show_ends, bool squeeze_blank)\n<line4>{\n<line5>/* Last character read from the input buffer.  */\n<line6>unsigned char ch;\n<line7>/* Determines how many consecutive newlines there have been in the\n<line8>input.  0 newlines makes NEWLINES -1, 1 newline makes NEWLINES 1,\n<line9>etc.  Initially 0 to indicate that we are at the beginning of a\n<line10>new line.  The "state" of the procedure is determined by\n<line11>NEWLINES.  */\n<line12>int newlines = newlines2;\n<line13>#ifdef FIONREAD\n<line14>/* If nonzero, use the FIONREAD ioctl, as an optimization.\n<line15>(On Ultrix, it is not supported on NFS file systems.)  */\n<line16>bool use_fionread = true;\n<line17>#endif\n<line18>/* The inbuf pointers are initialized so that BPIN > EOB, and thereby input\n<line19>is read immediately.  */\n<line20>/* Pointer to the first non-valid byte in the input buffer, i.e., the\n<line21>current end of the buffer.  */\n<line22>char *eob = inbuf;\n<line23>/* Pointer to the next character in the input buffer.  */\n<line24>char *bpin = eob + 1;\n<line25>/* Pointer to the position where the next character shall be written.  */\n<line26>char *bpout = outbuf;\n<line27>while (true)\n<line28>{\n<line29>do\n<line30>{\n<line31>/* Write if there are at least OUTSIZE bytes in OUTBUF.  */\n<line32>if (outbuf + outsize <= bpout)\n<line33>{\n<line34>char *wp = outbuf;\n<line35>idx_t remaining_bytes;\n<line36>do\n<line37>{\n<line38>if (full_write (STDOUT_FILENO, wp, outsize) != outsize)\n<line39>write_error ();\n<line40>wp += outsize;\n<line41>remaining_bytes = bpout - wp;\n<line42>}\n<line43>while (outsize <= remaining_bytes);\n<line44>/* Move the remaining bytes to the beginning of the\n<line45>buffer.  */\n<line46>memmove (outbuf, wp, remaining_bytes);\n<line47>bpout = outbuf + remaining_bytes;\n<line48>}\n<line49>/* Is INBUF empty?  */\n<line50>if (bpin > eob)\n<line51>{\n<line52>bool input_pending = false;\n<line53>#ifdef FIONREAD\n<line54>int n_to_read = 0;\n<line55>/* Is there any input to read immediately?\n<line56>If not, we are about to wait,\n<line57>so write all buffered output before waiting.  */\n<line58>if (use_fionread\n<line59>&& ioctl (input_desc, FIONREAD, &n_to_read) < 0)\n<line60>{\n<line61>/* Ultrix returns EOPNOTSUPP on NFS;\n<line62>HP-UX returns ENOTTY on pipes.\n<line63>SunOS returns EINVAL and\n<line64>More/BSD returns ENODEV on special files\n<line65>like /dev/null.\n<line66>Irix-5 returns ENOSYS on pipes.  */\n<line67>if (errno == EOPNOTSUPP || errno == ENOTTY\n<line68>|| errno == EINVAL || errno == ENODEV\n<line69>|| errno == ENOSYS)\n<line70>use_fionread = false;\n<line71>else\n<line72>{\n<line73>error (0, errno, _("cannot do ioctl on %s"),\n<line74>quoteaf (infile));\n<line75>newlines2 = newlines;\n<line76>return false;\n<line77>}\n<line78>}\n<line79>if (n_to_read != 0)\n<line80>input_pending = true;\n<line81>#endif\n<line82>if (!input_pending)\n<line83>write_pending (outbuf, &bpout);\n<line84>/* Read more input into INBUF.  */\n<line85>size_t n_read = safe_read (input_desc, inbuf, insize);\n<line86>if (n_read == SAFE_READ_ERROR)\n<line87>{\n<line88>error (0, errno, "%s", quotef (infile));\n<line89>write_pending (outbuf, &bpout);\n<line90>newlines2 = newlines;\n<line91>return false;\n<line92>}\n<line93>if (n_read == 0)\n<line94>{\n<line95>write_pending (outbuf, &bpout);\n<line96>newlines2 = newlines;\n<line97>return true;\n<line98>}\n<line99>/* Update the pointers and insert a sentinel at the buffer\n<line100>end.  */\n<line101>bpin = inbuf;\n<line102>eob = bpin + n_read;\n<line103>*eob = '\n';\n<line104>}\n<line105>else\n<line106>{\n<line107>/* It was a real (not a sentinel) newline.  */\n<line108>/* Was the last line empty?\n<line109>(i.e., have two or more consecutive newlines been read?)  */\n<line110>if (++newlines > 0)\n<line111>{\n<line112>if (newlines >= 2)\n<line113>{\n<line114>/* Limit this to 2 here.  Otherwise, with lots of\n<line115>consecutive newlines, the counter could wrap\n<line116>around at INT_MAX.  */\n<line117>newlines = 2;\n<line118>/* Are multiple adjacent empty lines to be substituted\n<line119>by single ditto (-s), and this was the second empty\n<line120>line?  */\n<line121>if (squeeze_blank)\n<line122>{\n<line123>ch = *bpin++;\n<line124>continue;\n<line125>}\n<line126>}\n<line127>/* Are line numbers to be written at empty lines (-n)?  */\n<line128>if (number && !number_nonblank)\n<line129>{\n<line130>next_line_num ();\n<line131>bpout = stpcpy (bpout, line_num_print);\n<line132>}\n<line133>}\n<line134>/* Output a currency symbol if requested (-e).  */\n<line135>if (show_ends)\n<line136>{\n<line137>if (pending_cr)\n<line138>{\n<line139>*bpout++ = '^';\n<line140>*bpout++ = 'M';\n<line141>pending_cr = false;\n<line142>}\n<line143>*bpout++ = '$';\n<line144>}\n<line145>/* Output the newline.  */\n<line146>*bpout++ = '\n';\n<line147>}\n<line148>ch = *bpin++;\n<line149>}\n<line150>while (ch == '\n');\n<line151>/* Here CH cannot contain a newline character.  */\n<line152>if (pending_cr)\n<line153>{\n<line154>*bpout++ = '\r';\n<line155>pending_cr = false;\n<line156>}\n<line157>/* Are we at the beginning of a line, and line numbers are requested?  */\n<line158>if (newlines >= 0 && number)\n<line159>{\n<line160>next_line_num ();\n<line161>bpout = stpcpy (bpout, line_num_print);\n<line162>}\n<line163>/* The loops below continue until a newline character is found,\n<line164>which means that the buffer is empty or that a proper newline\n<line165>has been found.  */\n<line166>/* If quoting, i.e., at least one of -v, -e, or -t specified,\n<line167>scan for chars that need conversion.  */\n<line168>if (show_nonprinting)\n<line169>{\n<line170>while (true)\n<line171>{\n<line172>if (ch >= 32)\n<line173>{\n<line174>if (ch < 127)\n<line175>*bpout++ = ch;\n<line176>else if (ch == 127)\n<line177>{\n<line178>*bpout++ = '^';\n<line179>*bpout++ = '?';\n<line180>}\n<line181>else\n<line182>{\n<line183>*bpout++ = 'M';\n<line184>*bpout++ = '-';\n<line185>if (ch >= 128 + 32)\n<line186>{\n<line187>if (ch < 128 + 127)\n<line188>*bpout++ = ch - 128;\n<line189>else\n<line190>{\n<line191>*bpout++ = '^';\n<line192>*bpout++ = '?';\n<line193>}\n<line194>}\n<line195>else\n<line196>{\n<line197>*bpout++ = '^';\n<line198>*bpout++ = ch - 128 + 64;\n<line199>}\n<line200>}\n<line201>}\n<line202>else if (ch == '\t' && !show_tabs)\n<line203>*bpout++ = '\t';\n<line204>else if (ch == '\n')\n<line205>{\n<line206>newlines = -1;\n<line207>break;\n<line208>}\n<line209>else\n<line210>{\n<line211>*bpout++ = '^';\n<line212>*bpout++ = ch + 64;\n<line213>}\n<line214>ch = *bpin++;\n<line215>}\n<line216>}\n<line217>else\n<line218>{\n<line219>/* Not quoting, neither of -v, -e, or -t specified.  */\n<line220>while (true)\n<line221>{\n<line222>if (ch == '\t' && show_tabs)\n<line223>{\n<line224>*bpout++ = '^';\n<line225>*bpout++ = ch + 64;\n<line226>}\n<line227>else if (ch != '\n')\n<line228>{\n<line229>if (ch == '\r' && *bpin == '\n' && show_ends)\n<line230>{\n<line231>if (bpin == eob)\n<line232>pending_cr = true;\n<line233>else\n<line234>{\n<line235>*bpout++ = '^';\n<line236>*bpout++ = 'M';\n<line237>}\n<line238>}\n<line239>else\n<line240>*bpout++ = ch;\n<line241>}\n<line242>else\n<line243>{\n<line244>newlines = -1;\n<line245>break;\n<line246>}\n<line247>ch = *bpin++;\n<line248>}\n<line249>}\n<line250>}\n<line251>}
----------------------------------------
Function: copy_cat
Content: <line0>static int\n<line1>copy_cat (void)\n<line2>{\n<line3>/* Copy at most COPY_MAX bytes at a time; this is min\n<line4>(SSIZE_MAX, SIZE_MAX) truncated to a value that is\n<line5>surely aligned well.  */\n<line6>ssize_t copy_max = MIN (SSIZE_MAX, SIZE_MAX) >> 30 << 30;\n<line7>/* copy_file_range does not support some cases, and it\n<line8>incorrectly returns 0 when reading from the proc file\n<line9>system on the Linux kernel through at least 5.6.19 (2020),\n<line10>so fall back on read+write if the copy_file_range is\n<line11>unsupported or the input file seems empty.  */\n<line12>for (bool some_copied = false; ; some_copied = true)\n<line13>switch (copy_file_range (input_desc, nullptr, STDOUT_FILENO, nullptr,\n<line14>copy_max, 0))\n<line15>{\n<line16>case 0:\n<line17>return some_copied;\n<line18>case -1:\n<line19>if (errno == ENOSYS || is_ENOTSUP (errno) || errno == EINVAL\n<line20>|| errno == EBADF || errno == EXDEV || errno == ETXTBSY\n<line21>|| errno == EPERM)\n<line22>return 0;\n<line23>error (0, errno, "%s", quotef (infile));\n<line24>return -1;\n<line25>}\n<line26>}
----------------------------------------
Function: main
Content: <line0>int\n<line1>main (int argc, char **argv)\n<line2>{\n<line3>/* Nonzero if we have ever read standard input.  */\n<line4>bool have_read_stdin = false;\n<line5>struct stat stat_buf;\n<line6>/* Variables that are set according to the specified options.  */\n<line7>bool number = false;\n<line8>bool number_nonblank = false;\n<line9>bool squeeze_blank = false;\n<line10>bool show_ends = false;\n<line11>bool show_nonprinting = false;\n<line12>bool show_tabs = false;\n<line13>int file_open_mode = O_RDONLY;\n<line14>static struct option const long_options[] =\n<line15>{\n<line16>{"number-nonblank", no_argument, nullptr, 'b'},\n<line17>{"number", no_argument, nullptr, 'n'},\n<line18>{"squeeze-blank", no_argument, nullptr, 's'},\n<line19>{"show-nonprinting", no_argument, nullptr, 'v'},\n<line20>{"show-ends", no_argument, nullptr, 'E'},\n<line21>{"show-tabs", no_argument, nullptr, 'T'},\n<line22>{"show-all", no_argument, nullptr, 'A'},\n<line23>{GETOPT_HELP_OPTION_DECL},\n<line24>{GETOPT_VERSION_OPTION_DECL},\n<line25>{nullptr, 0, nullptr, 0}\n<line26>};\n<line27>initialize_main (&argc, &argv);\n<line28>set_program_name (argv[0]);\n<line29>setlocale (LC_ALL, "");\n<line30>bindtextdomain (PACKAGE, LOCALEDIR);\n<line31>textdomain (PACKAGE);\n<line32>/* Arrange to close stdout if we exit via the\n<line33>case_GETOPT_HELP_CHAR or case_GETOPT_VERSION_CHAR code.\n<line34>Normally STDOUT_FILENO is used rather than stdout, so\n<line35>close_stdout does nothing.  */\n<line36>atexit (close_stdout);\n<line37>/* Parse command line options.  */\n<line38>int c;\n<line39>while ((c = getopt_long (argc, argv, "benstuvAET", long_options, nullptr))\n<line40>!= -1)\n<line41>{\n<line42>switch (c)\n<line43>{\n<line44>case 'b':\n<line45>number = true;\n<line46>number_nonblank = true;\n<line47>break;\n<line48>case 'e':\n<line49>show_ends = true;\n<line50>show_nonprinting = true;\n<line51>break;\n<line52>case 'n':\n<line53>number = true;\n<line54>break;\n<line55>case 's':\n<line56>squeeze_blank = true;\n<line57>break;\n<line58>case 't':\n<line59>show_tabs = true;\n<line60>show_nonprinting = true;\n<line61>break;\n<line62>case 'u':\n<line63>/* We provide the -u feature unconditionally.  */\n<line64>break;\n<line65>case 'v':\n<line66>show_nonprinting = true;\n<line67>break;\n<line68>case 'A':\n<line69>show_nonprinting = true;\n<line70>show_ends = true;\n<line71>show_tabs = true;\n<line72>break;\n<line73>case 'E':\n<line74>show_ends = true;\n<line75>break;\n<line76>case 'T':\n<line77>show_tabs = true;\n<line78>break;\n<line79>case_GETOPT_HELP_CHAR;\n<line80>case_GETOPT_VERSION_CHAR (PROGRAM_NAME, AUTHORS);\n<line81>default:\n<line82>usage (EXIT_FAILURE);\n<line83>}\n<line84>}\n<line85>/* Get device, i-node number, and optimal blocksize of output.  */\n<line86>if (fstat (STDOUT_FILENO, &stat_buf) < 0)\n<line87>error (EXIT_FAILURE, errno, _("standard output"));\n<line88>/* Optimal size of i/o operations of output.  */\n<line89>idx_t outsize = io_blksize (stat_buf);\n<line90>/* Device and I-node number of the output.  */\n<line91>dev_t out_dev = stat_buf.st_dev;\n<line92>ino_t out_ino = stat_buf.st_ino;\n<line93>/* True if the output is a regular file.  */\n<line94>bool out_isreg = S_ISREG (stat_buf.st_mode) != 0;\n<line95>if (! (number || show_ends || squeeze_blank))\n<line96>{\n<line97>file_open_mode |= O_BINARY;\n<line98>xset_binary_mode (STDOUT_FILENO, O_BINARY);\n<line99>}\n<line100>/* Main loop.  */\n<line101>infile = "-";\n<line102>int argind = optind;\n<line103>bool ok = true;\n<line104>idx_t page_size = getpagesize ();\n<line105>do\n<line106>{\n<line107>if (argind < argc)\n<line108>infile = argv[argind];\n<line109>bool reading_stdin = STREQ (infile, "-");\n<line110>if (reading_stdin)\n<line111>{\n<line112>have_read_stdin = true;\n<line113>input_desc = STDIN_FILENO;\n<line114>if (file_open_mode & O_BINARY)\n<line115>xset_binary_mode (STDIN_FILENO, O_BINARY);\n<line116>}\n<line117>else\n<line118>{\n<line119>input_desc = open (infile, file_open_mode);\n<line120>if (input_desc < 0)\n<line121>{\n<line122>error (0, errno, "%s", quotef (infile));\n<line123>ok = false;\n<line124>continue;\n<line125>}\n<line126>}\n<line127>if (fstat (input_desc, &stat_buf) < 0)\n<line128>{\n<line129>error (0, errno, "%s", quotef (infile));\n<line130>ok = false;\n<line131>goto contin;\n<line132>}\n<line133>/* Optimal size of i/o operations of input.  */\n<line134>idx_t insize = io_blksize (stat_buf);\n<line135>fdadvise (input_desc, 0, 0, FADVISE_SEQUENTIAL);\n<line136>/* Don't copy a nonempty regular file to itself, as that would\n<line137>merely exhaust the output device.  It's better to catch this\n<line138>error earlier rather than later.  */\n<line139>if (out_isreg\n<line140>&& stat_buf.st_dev == out_dev && stat_buf.st_ino == out_ino\n<line141>&& lseek (input_desc, 0, SEEK_CUR) < stat_buf.st_size)\n<line142>{\n<line143>error (0, 0, _("%s: input file is output file"), quotef (infile));\n<line144>ok = false;\n<line145>goto contin;\n<line146>}\n<line147>/* Pointer to the input buffer.  */\n<line148>char *inbuf;\n<line149>/* Select which version of 'cat' to use.  If any format-oriented\n<line150>options were given use 'cat'; if not, use 'copy_cat' if it\n<line151>works, 'simple_cat' otherwise.  */\n<line152>if (! (number || show_ends || show_nonprinting\n<line153>|| show_tabs || squeeze_blank))\n<line154>{\n<line155>int copy_cat_status =\n<line156>out_isreg && S_ISREG (stat_buf.st_mode) ? copy_cat () : 0;\n<line157>if (copy_cat_status != 0)\n<line158>{\n<line159>inbuf = nullptr;\n<line160>ok &= 0 < copy_cat_status;\n<line161>}\n<line162>else\n<line163>{\n<line164>insize = MAX (insize, outsize);\n<line165>inbuf = xalignalloc (page_size, insize);\n<line166>ok &= simple_cat (inbuf, insize);\n<line167>}\n<line168>}\n<line169>else\n<line170>{\n<line171>/* Allocate, with an extra byte for a newline sentinel.  */\n<line172>inbuf = xalignalloc (page_size, insize + 1);\n<line173>/* Why are\n<line174>(OUTSIZE - 1 + INSIZE * 4 + LINE_COUNTER_BUF_LEN)\n<line175>bytes allocated for the output buffer?\n<line176>A test whether output needs to be written is done when the input\n<line177>buffer empties or when a newline appears in the input.  After\n<line178>output is written, at most (OUTSIZE - 1) bytes will remain in the\n<line179>buffer.  Now INSIZE bytes of input is read.  Each input character\n<line180>may grow by a factor of 4 (by the prepending of M-^).  If all\n<line181>characters do, and no newlines appear in this block of input, we\n<line182>will have at most (OUTSIZE - 1 + INSIZE * 4) bytes in the buffer.\n<line183>If the last character in the preceding block of input was a\n<line184>newline, a line number may be written (according to the given\n<line185>options) as the first thing in the output buffer. (Done after the\n<line186>new input is read, but before processing of the input begins.)\n<line187>A line number requires seldom more than LINE_COUNTER_BUF_LEN\n<line188>positions.\n<line189>Align the output buffer to a page size boundary, for efficiency\n<line190>on some paging implementations.  */\n<line191>idx_t bufsize;\n<line192>if (ckd_mul (&bufsize, insize, 4)\n<line193>|| ckd_add (&bufsize, bufsize, outsize)\n<line194>|| ckd_add (&bufsize, bufsize, LINE_COUNTER_BUF_LEN - 1))\n<line195>xalloc_die ();\n<line196>char *outbuf = xalignalloc (page_size, bufsize);\n<line197>ok &= cat (inbuf, insize, outbuf, outsize, show_nonprinting,\n<line198>show_tabs, number, number_nonblank, show_ends,\n<line199>squeeze_blank);\n<line200>alignfree (outbuf);\n<line201>}\n<line202>alignfree (inbuf);\n<line203>contin:\n<line204>if (!reading_stdin && close (input_desc) < 0)\n<line205>{\n<line206>error (0, errno, "%s", quotef (infile));\n<line207>ok = false;\n<line208>}\n<line209>}\n<line210>while (++argind < argc);\n<line211>if (pending_cr)\n<line212>{\n<line213>if (full_write (STDOUT_FILENO, "\r", 1) != 1)\n<line214>write_error ();\n<line215>}\n<line216>if (have_read_stdin && close (STDIN_FILENO) < 0)\n<line217>error (EXIT_FAILURE, errno, _("closing standard input"));\n<line218>return ok ? EXIT_SUCCESS : EXIT_FAILURE;\n<line219>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/src/chcon.c
========================================
In file included from /home/huihui/Downloads/coreutils-9.4/src/chcon.c:29:
In file included from ./lib/xfts.h:1:
In file included from ./lib/fts_.h:83:
./lib/i-ring.h:24:32: warning: '_Static_assert' with no message is a C2x extension [-Wc2x-extensions]
static_assert (1 <= I_RING_SIZE);
                               ^
                               , ""
1 warning generated.
Function: compute_context_from_mask
Content: <line0>static int\n<line1>compute_context_from_mask (char const *context, context_t *ret)\n<line2>{\n<line3>bool ok = true;\n<line4>context_t new_context = context_new (context);\n<line5>if (!new_context)\n<line6>{\n<line7>error (0, errno, _("failed to create security context: %s"),\n<line8>quote (context));\n<line9>return 1;\n<line10>}\n<line11>#define SET_COMPONENT(C, comp)						\\n<line12>do									\\n<line13>{									\\n<line14>if (specified_ ## comp						\\n<line15>&& context_ ## comp ## _set ((C), specified_ ## comp))	\\n<line16>{								\\n<line17>error (0, errno,						\\n<line18>_("failed to set %s security context component to %s"), \\n<line19>#comp, quote (specified_ ## comp));			\\n<line20>ok = false;							\\n<line21>}								\\n<line22>}									\\n<line23>while (0)\n<line24>SET_COMPONENT (new_context, user);\n<line25>SET_COMPONENT (new_context, range);\n<line26>SET_COMPONENT (new_context, role);\n<line27>SET_COMPONENT (new_context, type);\n<line28>if (!ok)\n<line29>{\n<line30>int saved_errno = errno;\n<line31>context_free (new_context);\n<line32>errno = saved_errno;\n<line33>return 1;\n<line34>}\n<line35>*ret = new_context;\n<line36>return 0;\n<line37>}
----------------------------------------
Function: change_file_context
Content: <line0>static int\n<line1>change_file_context (int fd, char const *file)\n<line2>{\n<line3>char *file_context = nullptr;\n<line4>context_t context IF_LINT (= 0);\n<line5>char const * context_string;\n<line6>int errors = 0;\n<line7>if (specified_context == nullptr)\n<line8>{\n<line9>int status = (affect_symlink_referent\n<line10>? getfileconat (fd, file, &file_context)\n<line11>: lgetfileconat (fd, file, &file_context));\n<line12>if (status < 0 && errno != ENODATA)\n<line13>{\n<line14>error (0, errno, _("failed to get security context of %s"),\n<line15>quoteaf (file));\n<line16>return 1;\n<line17>}\n<line18>/* If the file doesn't have a context, and we're not setting all of\n<line19>the context components, there isn't really an obvious default.\n<line20>Thus, we just give up. */\n<line21>if (file_context == nullptr)\n<line22>{\n<line23>error (0, 0, _("can't apply partial context to unlabeled file %s"),\n<line24>quoteaf (file));\n<line25>return 1;\n<line26>}\n<line27>if (compute_context_from_mask (file_context, &context))\n<line28>return 1;\n<line29>context_string = context_str (context);\n<line30>}\n<line31>else\n<line32>{\n<line33>context_string = specified_context;\n<line34>}\n<line35>if (file_context == nullptr || ! STREQ (context_string, file_context))\n<line36>{\n<line37>int fail = (affect_symlink_referent\n<line38>?  setfileconat (fd, file, context_string)\n<line39>: lsetfileconat (fd, file, context_string));\n<line40>if (fail)\n<line41>{\n<line42>errors = 1;\n<line43>error (0, errno, _("failed to change context of %s to %s"),\n<line44>quoteaf_n (0, file), quote_n (1, context_string));\n<line45>}\n<line46>}\n<line47>if (specified_context == nullptr)\n<line48>{\n<line49>context_free (context);\n<line50>freecon (file_context);\n<line51>}\n<line52>return errors;\n<line53>}
----------------------------------------
Function: process_file
Content: <line0>static bool\n<line1>process_file (FTS *fts, FTSENT *ent)\n<line2>{\n<line3>char const *file_full_name = ent->fts_path;\n<line4>char const *file = ent->fts_accpath;\n<line5>const struct stat *file_stats = ent->fts_statp;\n<line6>bool ok = true;\n<line7>switch (ent->fts_info)\n<line8>{\n<line9>case FTS_D:\n<line10>if (recurse)\n<line11>{\n<line12>if (ROOT_DEV_INO_CHECK (root_dev_ino, ent->fts_statp))\n<line13>{\n<line14>/* This happens e.g., with "chcon -R --preserve-root ... /"\n<line15>and with "chcon -RH --preserve-root ... symlink-to-root".  */\n<line16>ROOT_DEV_INO_WARN (file_full_name);\n<line17>/* Tell fts not to traverse into this hierarchy.  */\n<line18>fts_set (fts, ent, FTS_SKIP);\n<line19>/* Ensure that we do not process "/" on the second visit.  */\n<line20>ignore_value (fts_read (fts));\n<line21>return false;\n<line22>}\n<line23>return true;\n<line24>}\n<line25>break;\n<line26>case FTS_DP:\n<line27>if (! recurse)\n<line28>return true;\n<line29>break;\n<line30>case FTS_NS:\n<line31>/* For a top-level file or directory, this FTS_NS (stat failed)\n<line32>indicator is determined at the time of the initial fts_open call.\n<line33>With programs like chmod, chown, and chgrp, that modify\n<line34>permissions, it is possible that the file in question is\n<line35>accessible when control reaches this point.  So, if this is\n<line36>the first time we've seen the FTS_NS for this file, tell\n<line37>fts_read to stat it "again".  */\n<line38>if (ent->fts_level == 0 && ent->fts_number == 0)\n<line39>{\n<line40>ent->fts_number = 1;\n<line41>fts_set (fts, ent, FTS_AGAIN);\n<line42>return true;\n<line43>}\n<line44>error (0, ent->fts_errno, _("cannot access %s"),\n<line45>quoteaf (file_full_name));\n<line46>ok = false;\n<line47>break;\n<line48>case FTS_ERR:\n<line49>error (0, ent->fts_errno, "%s", quotef (file_full_name));\n<line50>ok = false;\n<line51>break;\n<line52>case FTS_DNR:\n<line53>error (0, ent->fts_errno, _("cannot read directory %s"),\n<line54>quoteaf (file_full_name));\n<line55>ok = false;\n<line56>break;\n<line57>case FTS_DC:		/* directory that causes cycles */\n<line58>if (cycle_warning_required (fts, ent))\n<line59>{\n<line60>emit_cycle_warning (file_full_name);\n<line61>return false;\n<line62>}\n<line63>break;\n<line64>default:\n<line65>break;\n<line66>}\n<line67>if (ent->fts_info == FTS_DP\n<line68>&& ok && ROOT_DEV_INO_CHECK (root_dev_ino, file_stats))\n<line69>{\n<line70>ROOT_DEV_INO_WARN (file_full_name);\n<line71>ok = false;\n<line72>}\n<line73>if (ok)\n<line74>{\n<line75>if (verbose)\n<line76>printf (_("changing security context of %s\n"),\n<line77>quoteaf (file_full_name));\n<line78>if (change_file_context (fts->fts_cwd_fd, file) != 0)\n<line79>ok = false;\n<line80>}\n<line81>if ( ! recurse)\n<line82>fts_set (fts, ent, FTS_SKIP);\n<line83>return ok;\n<line84>}
----------------------------------------
Function: process_files
Content: <line0>static bool\n<line1>process_files (char **files, int bit_flags)\n<line2>{\n<line3>bool ok = true;\n<line4>FTS *fts = xfts_open (files, bit_flags, nullptr);\n<line5>while (true)\n<line6>{\n<line7>FTSENT *ent;\n<line8>ent = fts_read (fts);\n<line9>if (ent == nullptr)\n<line10>{\n<line11>if (errno != 0)\n<line12>{\n<line13>/* FIXME: try to give a better message  */\n<line14>error (0, errno, _("fts_read failed"));\n<line15>ok = false;\n<line16>}\n<line17>break;\n<line18>}\n<line19>ok &= process_file (fts, ent);\n<line20>}\n<line21>if (fts_close (fts) != 0)\n<line22>{\n<line23>error (0, errno, _("fts_close failed"));\n<line24>ok = false;\n<line25>}\n<line26>return ok;\n<line27>}
----------------------------------------
Function: usage
Content: <line0>void\n<line1>usage (int status)\n<line2>{\n<line3>if (status != EXIT_SUCCESS)\n<line4>emit_try_help ();\n<line5>else\n<line6>{\n<line7>printf (_("\\n<line8>Usage: %s [OPTION]... CONTEXT FILE...\n\\n<line9>or:  %s [OPTION]... [-u USER] [-r ROLE] [-l RANGE] [-t TYPE] FILE...\n\\n<line10>or:  %s [OPTION]... --reference=RFILE FILE...\n\\n<line11>"),\n<line12>program_name, program_name, program_name);\n<line13>fputs (_("\\n<line14>Change the SELinux security context of each FILE to CONTEXT.\n\\n<line15>With --reference, change the security context of each FILE to that of RFILE.\n\\n<line16>"), stdout);\n<line17>emit_mandatory_arg_note ();\n<line18>fputs (_("\\n<line19>--dereference      affect the referent of each symbolic link (this is\n\\n<line20>the default), rather than the symbolic link itself\n\\n<line21>-h, --no-dereference   affect symbolic links instead of any referenced file\n\\n<line22>"), stdout);\n<line23>fputs (_("\\n<line24>-u, --user=USER        set user USER in the target security context\n\\n<line25>-r, --role=ROLE        set role ROLE in the target security context\n\\n<line26>-t, --type=TYPE        set type TYPE in the target security context\n\\n<line27>-l, --range=RANGE      set range RANGE in the target security context\n\\n<line28>"), stdout);\n<line29>fputs (_("\\n<line30>--no-preserve-root  do not treat '/' specially (the default)\n\\n<line31>--preserve-root    fail to operate recursively on '/'\n\\n<line32>"), stdout);\n<line33>fputs (_("\\n<line34>--reference=RFILE  use RFILE's security context rather than specifying\n\\n<line35>a CONTEXT value\n\\n<line36>"), stdout);\n<line37>fputs (_("\\n<line38>-R, --recursive        operate on files and directories recursively\n\\n<line39>"), stdout);\n<line40>fputs (_("\\n<line41>-v, --verbose          output a diagnostic for every file processed\n\\n<line42>"), stdout);\n<line43>fputs (_("\\n<line44>\n\\n<line45>The following options modify how a hierarchy is traversed when the -R\n\\n<line46>option is also specified.  If more than one is specified, only the final\n\\n<line47>one takes effect.\n\\n<line48>\n\\n<line49>-H                     if a command line argument is a symbolic link\n\\n<line50>to a directory, traverse it\n\\n<line51>-L                     traverse every symbolic link to a directory\n\\n<line52>encountered\n\\n<line53>-P                     do not traverse any symbolic links (default)\n\\n<line54>\n\\n<line55>"), stdout);\n<line56>fputs (HELP_OPTION_DESCRIPTION, stdout);\n<line57>fputs (VERSION_OPTION_DESCRIPTION, stdout);\n<line58>emit_ancillary_info (PROGRAM_NAME);\n<line59>}\n<line60>exit (status);\n<line61>}
----------------------------------------
Function: main
Content: <line0>int\n<line1>main (int argc, char **argv)\n<line2>{\n<line3>/* Bit flags that control how fts works.  */\n<line4>int bit_flags = FTS_PHYSICAL;\n<line5>/* 1 if --dereference, 0 if --no-dereference, -1 if neither has been\n<line6>specified.  */\n<line7>int dereference = -1;\n<line8>bool ok;\n<line9>bool preserve_root = false;\n<line10>bool component_specified = false;\n<line11>char *reference_file = nullptr;\n<line12>int optc;\n<line13>initialize_main (&argc, &argv);\n<line14>set_program_name (argv[0]);\n<line15>setlocale (LC_ALL, "");\n<line16>bindtextdomain (PACKAGE, LOCALEDIR);\n<line17>textdomain (PACKAGE);\n<line18>atexit (close_stdout);\n<line19>while ((optc = getopt_long (argc, argv, "HLPRhvu:r:t:l:",\n<line20>long_options, nullptr))\n<line21>!= -1)\n<line22>{\n<line23>switch (optc)\n<line24>{\n<line25>case 'H': /* Traverse command-line symlinks-to-directories.  */\n<line26>bit_flags = FTS_COMFOLLOW | FTS_PHYSICAL;\n<line27>break;\n<line28>case 'L': /* Traverse all symlinks-to-directories.  */\n<line29>bit_flags = FTS_LOGICAL;\n<line30>break;\n<line31>case 'P': /* Traverse no symlinks-to-directories.  */\n<line32>bit_flags = FTS_PHYSICAL;\n<line33>break;\n<line34>case 'h': /* --no-dereference: affect symlinks */\n<line35>dereference = 0;\n<line36>break;\n<line37>case DEREFERENCE_OPTION: /* --dereference: affect the referent\n<line38>of each symlink */\n<line39>dereference = 1;\n<line40>break;\n<line41>case NO_PRESERVE_ROOT:\n<line42>preserve_root = false;\n<line43>break;\n<line44>case PRESERVE_ROOT:\n<line45>preserve_root = true;\n<line46>break;\n<line47>case REFERENCE_FILE_OPTION:\n<line48>reference_file = optarg;\n<line49>break;\n<line50>case 'R':\n<line51>recurse = true;\n<line52>break;\n<line53>case 'f':\n<line54>/* ignore */\n<line55>break;\n<line56>case 'v':\n<line57>verbose = true;\n<line58>break;\n<line59>case 'u':\n<line60>specified_user = optarg;\n<line61>component_specified = true;\n<line62>break;\n<line63>case 'r':\n<line64>specified_role = optarg;\n<line65>component_specified = true;\n<line66>break;\n<line67>case 't':\n<line68>specified_type = optarg;\n<line69>component_specified = true;\n<line70>break;\n<line71>case 'l':\n<line72>specified_range = optarg;\n<line73>component_specified = true;\n<line74>break;\n<line75>case_GETOPT_HELP_CHAR;\n<line76>case_GETOPT_VERSION_CHAR (PROGRAM_NAME, AUTHORS);\n<line77>default:\n<line78>usage (EXIT_FAILURE);\n<line79>}\n<line80>}\n<line81>if (recurse)\n<line82>{\n<line83>if (bit_flags == FTS_PHYSICAL)\n<line84>{\n<line85>if (dereference == 1)\n<line86>error (EXIT_FAILURE, 0,\n<line87>_("-R --dereference requires either -H or -L"));\n<line88>affect_symlink_referent = false;\n<line89>}\n<line90>else\n<line91>{\n<line92>if (dereference == 0)\n<line93>error (EXIT_FAILURE, 0, _("-R -h requires -P"));\n<line94>affect_symlink_referent = true;\n<line95>}\n<line96>}\n<line97>else\n<line98>{\n<line99>bit_flags = FTS_PHYSICAL;\n<line100>affect_symlink_referent = (dereference != 0);\n<line101>}\n<line102>if (argc - optind < (reference_file || component_specified ? 1 : 2))\n<line103>{\n<line104>if (argc <= optind)\n<line105>error (0, 0, _("missing operand"));\n<line106>else\n<line107>error (0, 0, _("missing operand after %s"), quote (argv[argc - 1]));\n<line108>usage (EXIT_FAILURE);\n<line109>}\n<line110>if (reference_file)\n<line111>{\n<line112>char *ref_context = nullptr;\n<line113>if (getfilecon (reference_file, &ref_context) < 0)\n<line114>error (EXIT_FAILURE, errno, _("failed to get security context of %s"),\n<line115>quoteaf (reference_file));\n<line116>specified_context = ref_context;\n<line117>}\n<line118>else if (component_specified)\n<line119>{\n<line120>/* FIXME: it's already null, so this is a no-op. */\n<line121>specified_context = nullptr;\n<line122>}\n<line123>else\n<line124>{\n<line125>specified_context = argv[optind++];\n<line126>if (0 < is_selinux_enabled ()\n<line127>&& security_check_context (specified_context) < 0)\n<line128>error (EXIT_FAILURE, errno, _("invalid context: %s"),\n<line129>quote (specified_context));\n<line130>}\n<line131>if (reference_file && component_specified)\n<line132>{\n<line133>error (0, 0, _("conflicting security context specifiers given"));\n<line134>usage (EXIT_FAILURE);\n<line135>}\n<line136>if (recurse && preserve_root)\n<line137>{\n<line138>static struct dev_ino dev_ino_buf;\n<line139>root_dev_ino = get_root_dev_ino (&dev_ino_buf);\n<line140>if (root_dev_ino == nullptr)\n<line141>error (EXIT_FAILURE, errno, _("failed to get attributes of %s"),\n<line142>quoteaf ("/"));\n<line143>}\n<line144>else\n<line145>{\n<line146>root_dev_ino = nullptr;\n<line147>}\n<line148>ok = process_files (argv + optind, bit_flags | FTS_NOSTAT);\n<line149>return ok ? EXIT_SUCCESS : EXIT_FAILURE;\n<line150>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/src/chgrp.c
========================================
In file included from /home/huihui/Downloads/coreutils-9.4/src/chgrp.c:27:
In file included from ./lib/fts_.h:83:
./lib/i-ring.h:24:32: warning: '_Static_assert' with no message is a C2x extension [-Wc2x-extensions]
static_assert (1 <= I_RING_SIZE);
                               ^
                               , ""
1 warning generated.
Function: parse_group
Content: <line0>static gid_t\n<line1>parse_group (char const *name)\n<line2>{\n<line3>gid_t gid = -1;\n<line4>if (*name)\n<line5>{\n<line6>struct group *grp = getgrnam (name);\n<line7>if (grp)\n<line8>gid = grp->gr_gid;\n<line9>else\n<line10>{\n<line11>uintmax_t tmp;\n<line12>if (! (xstrtoumax (name, nullptr, 10, &tmp, "") == LONGINT_OK\n<line13>&& tmp <= GID_T_MAX))\n<line14>error (EXIT_FAILURE, 0, _("invalid group: %s"),\n<line15>quote (name));\n<line16>gid = tmp;\n<line17>}\n<line18>endgrent ();		/* Save a file descriptor. */\n<line19>}\n<line20>return gid;\n<line21>}
----------------------------------------
Function: usage
Content: <line0>void\n<line1>usage (int status)\n<line2>{\n<line3>if (status != EXIT_SUCCESS)\n<line4>emit_try_help ();\n<line5>else\n<line6>{\n<line7>printf (_("\\n<line8>Usage: %s [OPTION]... GROUP FILE...\n\\n<line9>or:  %s [OPTION]... --reference=RFILE FILE...\n\\n<line10>"),\n<line11>program_name, program_name);\n<line12>fputs (_("\\n<line13>Change the group of each FILE to GROUP.\n\\n<line14>With --reference, change the group of each FILE to that of RFILE.\n\\n<line15>\n\\n<line16>"), stdout);\n<line17>fputs (_("\\n<line18>-c, --changes          like verbose but report only when a change is made\n\\n<line19>-f, --silent, --quiet  suppress most error messages\n\\n<line20>-v, --verbose          output a diagnostic for every file processed\n\\n<line21>"), stdout);\n<line22>fputs (_("\\n<line23>--dereference      affect the referent of each symbolic link (this is\n\\n<line24>the default), rather than the symbolic link itself\n\\n<line25>-h, --no-dereference   affect symbolic links instead of any referenced file\n\\n<line26>"), stdout);\n<line27>fputs (_("\\n<line28>(useful only on systems that can change the\n\\n<line29>ownership of a symlink)\n\\n<line30>"), stdout);\n<line31>fputs (_("\\n<line32>--no-preserve-root  do not treat '/' specially (the default)\n\\n<line33>--preserve-root    fail to operate recursively on '/'\n\\n<line34>"), stdout);\n<line35>fputs (_("\\n<line36>--reference=RFILE  use RFILE's group rather than specifying a GROUP.\n\\n<line37>RFILE is always dereferenced if a symbolic link.\n\\n<line38>"), stdout);\n<line39>fputs (_("\\n<line40>-R, --recursive        operate on files and directories recursively\n\\n<line41>"), stdout);\n<line42>fputs (_("\\n<line43>\n\\n<line44>The following options modify how a hierarchy is traversed when the -R\n\\n<line45>option is also specified.  If more than one is specified, only the final\n\\n<line46>one takes effect.\n\\n<line47>\n\\n<line48>-H                     if a command line argument is a symbolic link\n\\n<line49>to a directory, traverse it\n\\n<line50>-L                     traverse every symbolic link to a directory\n\\n<line51>encountered\n\\n<line52>-P                     do not traverse any symbolic links (default)\n\\n<line53>\n\\n<line54>"), stdout);\n<line55>fputs (HELP_OPTION_DESCRIPTION, stdout);\n<line56>fputs (VERSION_OPTION_DESCRIPTION, stdout);\n<line57>printf (_("\\n<line58>\n\\n<line59>Examples:\n\\n<line60>%s staff /u      Change the group of /u to \"staff\".\n\\n<line61>%s -hR staff /u  Change the group of /u and subfiles to \"staff\".\n\\n<line62>"),\n<line63>program_name, program_name);\n<line64>emit_ancillary_info (PROGRAM_NAME);\n<line65>}\n<line66>exit (status);\n<line67>}
----------------------------------------
Function: main
Content: <line0>int\n<line1>main (int argc, char **argv)\n<line2>{\n<line3>bool preserve_root = false;\n<line4>gid_t gid;\n<line5>/* Bit flags that control how fts works.  */\n<line6>int bit_flags = FTS_PHYSICAL;\n<line7>/* 1 if --dereference, 0 if --no-dereference, -1 if neither has been\n<line8>specified.  */\n<line9>int dereference = -1;\n<line10>struct Chown_option chopt;\n<line11>bool ok;\n<line12>int optc;\n<line13>initialize_main (&argc, &argv);\n<line14>set_program_name (argv[0]);\n<line15>setlocale (LC_ALL, "");\n<line16>bindtextdomain (PACKAGE, LOCALEDIR);\n<line17>textdomain (PACKAGE);\n<line18>atexit (close_stdout);\n<line19>chopt_init (&chopt);\n<line20>while ((optc = getopt_long (argc, argv, "HLPRcfhv", long_options, nullptr))\n<line21>!= -1)\n<line22>{\n<line23>switch (optc)\n<line24>{\n<line25>case 'H': /* Traverse command-line symlinks-to-directories.  */\n<line26>bit_flags = FTS_COMFOLLOW | FTS_PHYSICAL;\n<line27>break;\n<line28>case 'L': /* Traverse all symlinks-to-directories.  */\n<line29>bit_flags = FTS_LOGICAL;\n<line30>break;\n<line31>case 'P': /* Traverse no symlinks-to-directories.  */\n<line32>bit_flags = FTS_PHYSICAL;\n<line33>break;\n<line34>case 'h': /* --no-dereference: affect symlinks */\n<line35>dereference = 0;\n<line36>break;\n<line37>case DEREFERENCE_OPTION: /* --dereference: affect the referent\n<line38>of each symlink */\n<line39>dereference = 1;\n<line40>break;\n<line41>case NO_PRESERVE_ROOT:\n<line42>preserve_root = false;\n<line43>break;\n<line44>case PRESERVE_ROOT:\n<line45>preserve_root = true;\n<line46>break;\n<line47>case REFERENCE_FILE_OPTION:\n<line48>reference_file = optarg;\n<line49>break;\n<line50>case 'R':\n<line51>chopt.recurse = true;\n<line52>break;\n<line53>case 'c':\n<line54>chopt.verbosity = V_changes_only;\n<line55>break;\n<line56>case 'f':\n<line57>chopt.force_silent = true;\n<line58>break;\n<line59>case 'v':\n<line60>chopt.verbosity = V_high;\n<line61>break;\n<line62>case_GETOPT_HELP_CHAR;\n<line63>case_GETOPT_VERSION_CHAR (PROGRAM_NAME, AUTHORS);\n<line64>default:\n<line65>usage (EXIT_FAILURE);\n<line66>}\n<line67>}\n<line68>if (chopt.recurse)\n<line69>{\n<line70>if (bit_flags == FTS_PHYSICAL)\n<line71>{\n<line72>if (dereference == 1)\n<line73>error (EXIT_FAILURE, 0,\n<line74>_("-R --dereference requires either -H or -L"));\n<line75>dereference = 0;\n<line76>}\n<line77>}\n<line78>else\n<line79>{\n<line80>bit_flags = FTS_PHYSICAL;\n<line81>}\n<line82>chopt.affect_symlink_referent = (dereference != 0);\n<line83>if (argc - optind < (reference_file ? 1 : 2))\n<line84>{\n<line85>if (argc <= optind)\n<line86>error (0, 0, _("missing operand"));\n<line87>else\n<line88>error (0, 0, _("missing operand after %s"), quote (argv[argc - 1]));\n<line89>usage (EXIT_FAILURE);\n<line90>}\n<line91>if (reference_file)\n<line92>{\n<line93>struct stat ref_stats;\n<line94>if (stat (reference_file, &ref_stats))\n<line95>error (EXIT_FAILURE, errno, _("failed to get attributes of %s"),\n<line96>quoteaf (reference_file));\n<line97>gid = ref_stats.st_gid;\n<line98>chopt.group_name = gid_to_name (ref_stats.st_gid);\n<line99>}\n<line100>else\n<line101>{\n<line102>char *group_name = argv[optind++];\n<line103>chopt.group_name = (*group_name ? xstrdup (group_name) : nullptr);\n<line104>gid = parse_group (group_name);\n<line105>}\n<line106>if (chopt.recurse && preserve_root)\n<line107>{\n<line108>static struct dev_ino dev_ino_buf;\n<line109>chopt.root_dev_ino = get_root_dev_ino (&dev_ino_buf);\n<line110>if (chopt.root_dev_ino == nullptr)\n<line111>error (EXIT_FAILURE, errno, _("failed to get attributes of %s"),\n<line112>quoteaf ("/"));\n<line113>}\n<line114>bit_flags |= FTS_DEFER_STAT;\n<line115>ok = chown_files (argv + optind, bit_flags,\n<line116>(uid_t) -1, gid,\n<line117>(uid_t) -1, (gid_t) -1, &chopt);\n<line118>main_exit (ok ? EXIT_SUCCESS : EXIT_FAILURE);\n<line119>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/src/chown-core.c
========================================
In file included from /home/huihui/Downloads/coreutils-9.4/src/chown-core.c:30:
In file included from ./lib/xfts.h:1:
In file included from ./lib/fts_.h:83:
./lib/i-ring.h:24:32: warning: '_Static_assert' with no message is a C2x extension [-Wc2x-extensions]
static_assert (1 <= I_RING_SIZE);
                               ^
                               , ""
1 warning generated.
Function: chopt_init
Content: <line0>extern void\n<line1>chopt_init (struct Chown_option *chopt)\n<line2>{\n<line3>chopt->verbosity = V_off;\n<line4>chopt->root_dev_ino = nullptr;\n<line5>chopt->affect_symlink_referent = true;\n<line6>chopt->recurse = false;\n<line7>chopt->force_silent = false;\n<line8>chopt->user_name = nullptr;\n<line9>chopt->group_name = nullptr;\n<line10>}
----------------------------------------
Function: chopt_free
Content: <line0>extern void\n<line1>chopt_free (struct Chown_option *chopt)\n<line2>{\n<line3>free (chopt->user_name);\n<line4>free (chopt->group_name);\n<line5>}
----------------------------------------
Function: uid_to_str
Content: <line0>static char *\n<line1>uid_to_str (uid_t uid)\n<line2>{\n<line3>char buf[INT_BUFSIZE_BOUND (intmax_t)];\n<line4>return xstrdup (TYPE_SIGNED (uid_t) ? imaxtostr (uid, buf)\n<line5>: umaxtostr (uid, buf));\n<line6>}
----------------------------------------
Function: gid_to_str
Content: <line0>static char *\n<line1>gid_to_str (gid_t gid)\n<line2>{\n<line3>char buf[INT_BUFSIZE_BOUND (intmax_t)];\n<line4>return xstrdup (TYPE_SIGNED (gid_t) ? imaxtostr (gid, buf)\n<line5>: umaxtostr (gid, buf));\n<line6>}
----------------------------------------
Function: gid_to_name
Content: <line0>extern char *\n<line1>gid_to_name (gid_t gid)\n<line2>{\n<line3>struct group *grp = getgrgid (gid);\n<line4>return grp ? xstrdup (grp->gr_name) : gid_to_str (gid);\n<line5>}
----------------------------------------
Function: uid_to_name
Content: <line0>extern char *\n<line1>uid_to_name (uid_t uid)\n<line2>{\n<line3>struct passwd *pwd = getpwuid (uid);\n<line4>return pwd ? xstrdup (pwd->pw_name) : uid_to_str (uid);\n<line5>}
----------------------------------------
Function: user_group_str
Content: <line0>static char *\n<line1>user_group_str (char const *user, char const *group)\n<line2>{\n<line3>char *spec = nullptr;\n<line4>if (user)\n<line5>{\n<line6>if (group)\n<line7>{\n<line8>spec = xmalloc (strlen (user) + 1 + strlen (group) + 1);\n<line9>stpcpy (stpcpy (stpcpy (spec, user), ":"), group);\n<line10>}\n<line11>else\n<line12>{\n<line13>spec = xstrdup (user);\n<line14>}\n<line15>}\n<line16>else if (group)\n<line17>{\n<line18>spec = xstrdup (group);\n<line19>}\n<line20>return spec;\n<line21>}
----------------------------------------
Function: describe_change
Content: <line0>static void\n<line1>describe_change (char const *file, enum Change_status changed,\n<line2>char const *old_user, char const *old_group,\n<line3>char const *user, char const *group)\n<line4>{\n<line5>char const *fmt;\n<line6>char *old_spec;\n<line7>char *spec;\n<line8>if (changed == CH_NOT_APPLIED)\n<line9>{\n<line10>printf (_("neither symbolic link %s nor referent has been changed\n"),\n<line11>quoteaf (file));\n<line12>return;\n<line13>}\n<line14>spec = user_group_str (user, group);\n<line15>old_spec = user_group_str (user ? old_user : nullptr,\n<line16>group ? old_group : nullptr);\n<line17>switch (changed)\n<line18>{\n<line19>case CH_SUCCEEDED:\n<line20>fmt = (user ? _("changed ownership of %s from %s to %s\n")\n<line21>: group ? _("changed group of %s from %s to %s\n")\n<line22>: _("no change to ownership of %s\n"));\n<line23>break;\n<line24>case CH_FAILED:\n<line25>if (old_spec)\n<line26>{\n<line27>fmt = (user ? _("failed to change ownership of %s from %s to %s\n")\n<line28>: group ? _("failed to change group of %s from %s to %s\n")\n<line29>: _("failed to change ownership of %s\n"));\n<line30>}\n<line31>else\n<line32>{\n<line33>fmt = (user ? _("failed to change ownership of %s to %s\n")\n<line34>: group ? _("failed to change group of %s to %s\n")\n<line35>: _("failed to change ownership of %s\n"));\n<line36>free (old_spec);\n<line37>old_spec = spec;\n<line38>spec = nullptr;\n<line39>}\n<line40>break;\n<line41>case CH_NO_CHANGE_REQUESTED:\n<line42>fmt = (user ? _("ownership of %s retained as %s\n")\n<line43>: group ? _("group of %s retained as %s\n")\n<line44>: _("ownership of %s retained\n"));\n<line45>break;\n<line46>default:\n<line47>affirm (false);\n<line48>}\n<line49>printf (fmt, quoteaf (file), old_spec, spec);\n<line50>free (old_spec);\n<line51>free (spec);\n<line52>}
----------------------------------------
Function: restricted_chown
Content: <line0>static enum RCH_status\n<line1>restricted_chown (int cwd_fd, char const *file,\n<line2>struct stat const *orig_st,\n<line3>uid_t uid, gid_t gid,\n<line4>uid_t required_uid, gid_t required_gid)\n<line5>{\n<line6>enum RCH_status status = RC_ok;\n<line7>struct stat st;\n<line8>int open_flags = O_NONBLOCK | O_NOCTTY;\n<line9>int fd;\n<line10>if (required_uid == (uid_t) -1 && required_gid == (gid_t) -1)\n<line11>return RC_do_ordinary_chown;\n<line12>if (! S_ISREG (orig_st->st_mode))\n<line13>{\n<line14>if (S_ISDIR (orig_st->st_mode))\n<line15>open_flags |= O_DIRECTORY;\n<line16>else\n<line17>return RC_do_ordinary_chown;\n<line18>}\n<line19>fd = openat (cwd_fd, file, O_RDONLY | open_flags);\n<line20>if (! (0 <= fd\n<line21>|| (errno == EACCES && S_ISREG (orig_st->st_mode)\n<line22>&& 0 <= (fd = openat (cwd_fd, file, O_WRONLY | open_flags)))))\n<line23>return (errno == EACCES ? RC_do_ordinary_chown : RC_error);\n<line24>if (fstat (fd, &st) != 0)\n<line25>status = RC_error;\n<line26>else if (! SAME_INODE (*orig_st, st))\n<line27>status = RC_inode_changed;\n<line28>else if ((required_uid == (uid_t) -1 || required_uid == st.st_uid)\n<line29>&& (required_gid == (gid_t) -1 || required_gid == st.st_gid))\n<line30>{\n<line31>if (fchown (fd, uid, gid) == 0)\n<line32>{\n<line33>status = (close (fd) == 0\n<line34>? RC_ok : RC_error);\n<line35>return status;\n<line36>}\n<line37>else\n<line38>{\n<line39>status = RC_error;\n<line40>}\n<line41>}\n<line42>int saved_errno = errno;\n<line43>close (fd);\n<line44>errno = saved_errno;\n<line45>return status;\n<line46>}
----------------------------------------
Function: change_file_owner
Content: <line0>static bool\n<line1>change_file_owner (FTS *fts, FTSENT *ent,\n<line2>uid_t uid, gid_t gid,\n<line3>uid_t required_uid, gid_t required_gid,\n<line4>struct Chown_option const *chopt)\n<line5>{\n<line6>char const *file_full_name = ent->fts_path;\n<line7>char const *file = ent->fts_accpath;\n<line8>struct stat const *file_stats;\n<line9>struct stat stat_buf;\n<line10>bool ok = true;\n<line11>bool do_chown;\n<line12>bool symlink_changed = true;\n<line13>switch (ent->fts_info)\n<line14>{\n<line15>case FTS_D:\n<line16>if (chopt->recurse)\n<line17>{\n<line18>if (ROOT_DEV_INO_CHECK (chopt->root_dev_ino, ent->fts_statp))\n<line19>{\n<line20>/* This happens e.g., with "chown -R --preserve-root 0 /"\n<line21>and with "chown -RH --preserve-root 0 symlink-to-root".  */\n<line22>ROOT_DEV_INO_WARN (file_full_name);\n<line23>/* Tell fts not to traverse into this hierarchy.  */\n<line24>fts_set (fts, ent, FTS_SKIP);\n<line25>/* Ensure that we do not process "/" on the second visit.  */\n<line26>ignore_value (fts_read (fts));\n<line27>return false;\n<line28>}\n<line29>return true;\n<line30>}\n<line31>break;\n<line32>case FTS_DP:\n<line33>if (! chopt->recurse)\n<line34>return true;\n<line35>break;\n<line36>case FTS_NS:\n<line37>/* For a top-level file or directory, this FTS_NS (stat failed)\n<line38>indicator is determined at the time of the initial fts_open call.\n<line39>With programs like chmod, chown, and chgrp, that modify\n<line40>permissions, it is possible that the file in question is\n<line41>accessible when control reaches this point.  So, if this is\n<line42>the first time we've seen the FTS_NS for this file, tell\n<line43>fts_read to stat it "again".  */\n<line44>if (ent->fts_level == 0 && ent->fts_number == 0)\n<line45>{\n<line46>ent->fts_number = 1;\n<line47>fts_set (fts, ent, FTS_AGAIN);\n<line48>return true;\n<line49>}\n<line50>if (! chopt->force_silent)\n<line51>error (0, ent->fts_errno, _("cannot access %s"),\n<line52>quoteaf (file_full_name));\n<line53>ok = false;\n<line54>break;\n<line55>case FTS_ERR:\n<line56>if (! chopt->force_silent)\n<line57>error (0, ent->fts_errno, "%s", quotef (file_full_name));\n<line58>ok = false;\n<line59>break;\n<line60>case FTS_DNR:\n<line61>if (! chopt->force_silent)\n<line62>error (0, ent->fts_errno, _("cannot read directory %s"),\n<line63>quoteaf (file_full_name));\n<line64>ok = false;\n<line65>break;\n<line66>case FTS_DC:		/* directory that causes cycles */\n<line67>if (cycle_warning_required (fts, ent))\n<line68>{\n<line69>emit_cycle_warning (file_full_name);\n<line70>return false;\n<line71>}\n<line72>break;\n<line73>default:\n<line74>break;\n<line75>}\n<line76>if (!ok)\n<line77>{\n<line78>do_chown = false;\n<line79>file_stats = nullptr;\n<line80>}\n<line81>else if (required_uid == (uid_t) -1 && required_gid == (gid_t) -1\n<line82>&& chopt->verbosity == V_off\n<line83>&& ! chopt->root_dev_ino\n<line84>&& ! chopt->affect_symlink_referent)\n<line85>{\n<line86>do_chown = true;\n<line87>file_stats = ent->fts_statp;\n<line88>}\n<line89>else\n<line90>{\n<line91>file_stats = ent->fts_statp;\n<line92>/* If this is a symlink and we're dereferencing them,\n<line93>stat it to get info on the referent.  */\n<line94>if (chopt->affect_symlink_referent && S_ISLNK (file_stats->st_mode))\n<line95>{\n<line96>if (fstatat (fts->fts_cwd_fd, file, &stat_buf, 0) != 0)\n<line97>{\n<line98>if (! chopt->force_silent)\n<line99>error (0, errno, _("cannot dereference %s"),\n<line100>quoteaf (file_full_name));\n<line101>ok = false;\n<line102>}\n<line103>file_stats = &stat_buf;\n<line104>}\n<line105>do_chown = (ok\n<line106>&& (required_uid == (uid_t) -1\n<line107>|| required_uid == file_stats->st_uid)\n<line108>&& (required_gid == (gid_t) -1\n<line109>|| required_gid == file_stats->st_gid));\n<line110>}\n<line111>/* This happens when chown -LR --preserve-root encounters a symlink-to-/.  */\n<line112>if (ok\n<line113>&& FTSENT_IS_DIRECTORY (ent)\n<line114>&& ROOT_DEV_INO_CHECK (chopt->root_dev_ino, file_stats))\n<line115>{\n<line116>ROOT_DEV_INO_WARN (file_full_name);\n<line117>return false;\n<line118>}\n<line119>if (do_chown)\n<line120>{\n<line121>if ( ! chopt->affect_symlink_referent)\n<line122>{\n<line123>ok = (lchownat (fts->fts_cwd_fd, file, uid, gid) == 0);\n<line124>/* Ignore any error due to lack of support; POSIX requires\n<line125>this behavior for top-level symbolic links with -h, and\n<line126>implies that it's required for all symbolic links.  */\n<line127>if (!ok && errno == EOPNOTSUPP)\n<line128>{\n<line129>ok = true;\n<line130>symlink_changed = false;\n<line131>}\n<line132>}\n<line133>else\n<line134>{\n<line135>/* If possible, avoid a race condition with --from=O:G and without the\n<line136>(-h) --no-dereference option.  If fts's stat call determined\n<line137>that the uid/gid of FILE matched the --from=O:G-selected\n<line138>owner and group IDs, blindly using chown(2) here could lead\n<line139>chown(1) or chgrp(1) mistakenly to dereference a *symlink*\n<line140>to an arbitrary file that an attacker had moved into the\n<line141>place of FILE during the window between the stat and\n<line142>chown(2) calls.  If FILE is a regular file or a directory\n<line143>that can be opened, this race condition can be avoided safely.  */\n<line144>enum RCH_status err\n<line145>= restricted_chown (fts->fts_cwd_fd, file, file_stats, uid, gid,\n<line146>required_uid, required_gid);\n<line147>switch (err)\n<line148>{\n<line149>case RC_ok:\n<line150>break;\n<line151>case RC_do_ordinary_chown:\n<line152>ok = (chownat (fts->fts_cwd_fd, file, uid, gid) == 0);\n<line153>break;\n<line154>case RC_error:\n<line155>ok = false;\n<line156>break;\n<line157>case RC_inode_changed:\n<line158>/* FIXME: give a diagnostic in this case?  */\n<line159>case RC_excluded:\n<line160>do_chown = false;\n<line161>ok = false;\n<line162>break;\n<line163>default:\n<line164>unreachable ();\n<line165>}\n<line166>}\n<line167>/* On some systems (e.g., GNU/Linux 2.4.x),\n<line168>the chown function resets the 'special' permission bits.\n<line169>Do *not* restore those bits;  doing so would open a window in\n<line170>which a malicious user, M, could subvert a chown command run\n<line171>by some other user and operating on files in a directory\n<line172>where M has write access.  */\n<line173>if (do_chown && !ok && ! chopt->force_silent)\n<line174>error (0, errno, (uid != (uid_t) -1\n<line175>? _("changing ownership of %s")\n<line176>: _("changing group of %s")),\n<line177>quoteaf (file_full_name));\n<line178>}\n<line179>if (chopt->verbosity != V_off)\n<line180>{\n<line181>bool changed =\n<line182>((do_chown && ok && symlink_changed)\n<line183>&& ! ((uid == (uid_t) -1 || uid == file_stats->st_uid)\n<line184>&& (gid == (gid_t) -1 || gid == file_stats->st_gid)));\n<line185>if (changed || chopt->verbosity == V_high)\n<line186>{\n<line187>enum Change_status ch_status =\n<line188>(!ok ? CH_FAILED\n<line189>: !symlink_changed ? CH_NOT_APPLIED\n<line190>: !changed ? CH_NO_CHANGE_REQUESTED\n<line191>: CH_SUCCEEDED);\n<line192>char *old_usr = (file_stats\n<line193>? uid_to_name (file_stats->st_uid) : nullptr);\n<line194>char *old_grp = (file_stats\n<line195>? gid_to_name (file_stats->st_gid) : nullptr);\n<line196>char *new_usr = chopt->user_name\n<line197>? chopt->user_name : uid != -1\n<line198>? uid_to_str (uid) : nullptr;\n<line199>char *new_grp = chopt->group_name\n<line200>? chopt->group_name : gid != -1\n<line201>? gid_to_str (gid) : nullptr;\n<line202>describe_change (file_full_name, ch_status,\n<line203>old_usr, old_grp,\n<line204>new_usr, new_grp);\n<line205>free (old_usr);\n<line206>free (old_grp);\n<line207>if (new_usr != chopt->user_name)\n<line208>free (new_usr);\n<line209>if (new_grp != chopt->group_name)\n<line210>free (new_grp);\n<line211>}\n<line212>}\n<line213>if ( ! chopt->recurse)\n<line214>fts_set (fts, ent, FTS_SKIP);\n<line215>return ok;\n<line216>}
----------------------------------------
Function: chown_files
Content: <line0>extern bool\n<line1>chown_files (char **files, int bit_flags,\n<line2>uid_t uid, gid_t gid,\n<line3>uid_t required_uid, gid_t required_gid,\n<line4>struct Chown_option const *chopt)\n<line5>{\n<line6>bool ok = true;\n<line7>/* Use lstat and stat only if they're needed.  */\n<line8>int stat_flags = ((required_uid != (uid_t) -1 || required_gid != (gid_t) -1\n<line9>|| chopt->affect_symlink_referent\n<line10>|| chopt->verbosity != V_off)\n<line11>? 0\n<line12>: FTS_NOSTAT);\n<line13>FTS *fts = xfts_open (files, bit_flags | stat_flags, nullptr);\n<line14>while (true)\n<line15>{\n<line16>FTSENT *ent;\n<line17>ent = fts_read (fts);\n<line18>if (ent == nullptr)\n<line19>{\n<line20>if (errno != 0)\n<line21>{\n<line22>/* FIXME: try to give a better message  */\n<line23>if (! chopt->force_silent)\n<line24>error (0, errno, _("fts_read failed"));\n<line25>ok = false;\n<line26>}\n<line27>break;\n<line28>}\n<line29>ok &= change_file_owner (fts, ent, uid, gid,\n<line30>required_uid, required_gid, chopt);\n<line31>}\n<line32>if (fts_close (fts) != 0)\n<line33>{\n<line34>error (0, errno, _("fts_close failed"));\n<line35>ok = false;\n<line36>}\n<line37>return ok;\n<line38>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/src/chmod.c
========================================
In file included from /home/huihui/Downloads/coreutils-9.4/src/chmod.c:32:
In file included from ./lib/xfts.h:1:
In file included from ./lib/fts_.h:83:
./lib/i-ring.h:24:32: warning: '_Static_assert' with no message is a C2x extension [-Wc2x-extensions]
static_assert (1 <= I_RING_SIZE);
                               ^
                               , ""
1 warning generated.
Function: mode_changed
Content: <line0>static bool\n<line1>mode_changed (int dir_fd, char const *file, char const *file_full_name,\n<line2>mode_t old_mode, mode_t new_mode)\n<line3>{\n<line4>if (new_mode & (S_ISUID | S_ISGID | S_ISVTX))\n<line5>{\n<line6>/* The new mode contains unusual bits that the call to chmod may\n<line7>have silently cleared.  Check whether they actually changed.  */\n<line8>struct stat new_stats;\n<line9>if (fstatat (dir_fd, file, &new_stats, 0) != 0)\n<line10>{\n<line11>if (! force_silent)\n<line12>error (0, errno, _("getting new attributes of %s"),\n<line13>quoteaf (file_full_name));\n<line14>return false;\n<line15>}\n<line16>new_mode = new_stats.st_mode;\n<line17>}\n<line18>return ((old_mode ^ new_mode) & CHMOD_MODE_BITS) != 0;\n<line19>}
----------------------------------------
Function: describe_change
Content: <line0>static void\n<line1>describe_change (char const *file, struct change_status const *ch)\n<line2>{\n<line3>char perms[12];		/* "-rwxrwxrwx" ls-style modes. */\n<line4>char old_perms[12];\n<line5>char const *fmt;\n<line6>char const *quoted_file = quoteaf (file);\n<line7>switch (ch->status)\n<line8>{\n<line9>case CH_NOT_APPLIED:\n<line10>printf (_("neither symbolic link %s nor referent has been changed\n"),\n<line11>quoted_file);\n<line12>return;\n<line13>case CH_NO_STAT:\n<line14>printf (_("%s could not be accessed\n"), quoted_file);\n<line15>return;\n<line16>default:\n<line17>break;\n<line18>}\n<line19>unsigned long int\n<line20>old_m = ch->old_mode & CHMOD_MODE_BITS,\n<line21>m = ch->new_mode & CHMOD_MODE_BITS;\n<line22>strmode (ch->new_mode, perms);\n<line23>perms[10] = '\0';		/* Remove trailing space.  */\n<line24>strmode (ch->old_mode, old_perms);\n<line25>old_perms[10] = '\0';		/* Remove trailing space.  */\n<line26>switch (ch->status)\n<line27>{\n<line28>case CH_SUCCEEDED:\n<line29>fmt = _("mode of %s changed from %04lo (%s) to %04lo (%s)\n");\n<line30>break;\n<line31>case CH_FAILED:\n<line32>fmt = _("failed to change mode of %s from %04lo (%s) to %04lo (%s)\n");\n<line33>break;\n<line34>case CH_NO_CHANGE_REQUESTED:\n<line35>fmt = _("mode of %s retained as %04lo (%s)\n");\n<line36>printf (fmt, quoted_file, m, &perms[1]);\n<line37>return;\n<line38>default:\n<line39>affirm (false);\n<line40>}\n<line41>printf (fmt, quoted_file, old_m, &old_perms[1], m, &perms[1]);\n<line42>}
----------------------------------------
Function: process_file
Content: <line0>static bool\n<line1>process_file (FTS *fts, FTSENT *ent)\n<line2>{\n<line3>char const *file_full_name = ent->fts_path;\n<line4>char const *file = ent->fts_accpath;\n<line5>const struct stat *file_stats = ent->fts_statp;\n<line6>struct change_status ch = { 0, };\n<line7>ch.status = CH_NO_STAT;\n<line8>switch (ent->fts_info)\n<line9>{\n<line10>case FTS_DP:\n<line11>return true;\n<line12>case FTS_NS:\n<line13>/* For a top-level file or directory, this FTS_NS (stat failed)\n<line14>indicator is determined at the time of the initial fts_open call.\n<line15>With programs like chmod, chown, and chgrp, that modify\n<line16>permissions, it is possible that the file in question is\n<line17>accessible when control reaches this point.  So, if this is\n<line18>the first time we've seen the FTS_NS for this file, tell\n<line19>fts_read to stat it "again".  */\n<line20>if (ent->fts_level == 0 && ent->fts_number == 0)\n<line21>{\n<line22>ent->fts_number = 1;\n<line23>fts_set (fts, ent, FTS_AGAIN);\n<line24>return true;\n<line25>}\n<line26>if (! force_silent)\n<line27>error (0, ent->fts_errno, _("cannot access %s"),\n<line28>quoteaf (file_full_name));\n<line29>break;\n<line30>case FTS_ERR:\n<line31>if (! force_silent)\n<line32>error (0, ent->fts_errno, "%s", quotef (file_full_name));\n<line33>break;\n<line34>case FTS_DNR:\n<line35>if (! force_silent)\n<line36>error (0, ent->fts_errno, _("cannot read directory %s"),\n<line37>quoteaf (file_full_name));\n<line38>break;\n<line39>case FTS_SLNONE:\n<line40>if (! force_silent)\n<line41>error (0, 0, _("cannot operate on dangling symlink %s"),\n<line42>quoteaf (file_full_name));\n<line43>break;\n<line44>case FTS_DC:		/* directory that causes cycles */\n<line45>if (cycle_warning_required (fts, ent))\n<line46>{\n<line47>emit_cycle_warning (file_full_name);\n<line48>return false;\n<line49>}\n<line50>FALLTHROUGH;\n<line51>default:\n<line52>ch.status = CH_NOT_APPLIED;\n<line53>break;\n<line54>}\n<line55>if (ch.status == CH_NOT_APPLIED\n<line56>&& ROOT_DEV_INO_CHECK (root_dev_ino, file_stats))\n<line57>{\n<line58>ROOT_DEV_INO_WARN (file_full_name);\n<line59>/* Tell fts not to traverse into this hierarchy.  */\n<line60>fts_set (fts, ent, FTS_SKIP);\n<line61>/* Ensure that we do not process "/" on the second visit.  */\n<line62>ignore_value (fts_read (fts));\n<line63>return false;\n<line64>}\n<line65>if (ch.status == CH_NOT_APPLIED && ! S_ISLNK (file_stats->st_mode))\n<line66>{\n<line67>ch.old_mode = file_stats->st_mode;\n<line68>ch.new_mode = mode_adjust (ch.old_mode, S_ISDIR (ch.old_mode) != 0,\n<line69>umask_value, change, nullptr);\n<line70>if (chmodat (fts->fts_cwd_fd, file, ch.new_mode) == 0)\n<line71>ch.status = CH_SUCCEEDED;\n<line72>else\n<line73>{\n<line74>if (! force_silent)\n<line75>error (0, errno, _("changing permissions of %s"),\n<line76>quoteaf (file_full_name));\n<line77>ch.status = CH_FAILED;\n<line78>}\n<line79>}\n<line80>if (verbosity != V_off)\n<line81>{\n<line82>if (ch.status == CH_SUCCEEDED\n<line83>&& !mode_changed (fts->fts_cwd_fd, file, file_full_name,\n<line84>ch.old_mode, ch.new_mode))\n<line85>ch.status = CH_NO_CHANGE_REQUESTED;\n<line86>if (ch.status == CH_SUCCEEDED || verbosity == V_high)\n<line87>describe_change (file_full_name, &ch);\n<line88>}\n<line89>if (CH_NO_CHANGE_REQUESTED <= ch.status && diagnose_surprises)\n<line90>{\n<line91>mode_t naively_expected_mode =\n<line92>mode_adjust (ch.old_mode, S_ISDIR (ch.old_mode) != 0,\n<line93>0, change, nullptr);\n<line94>if (ch.new_mode & ~naively_expected_mode)\n<line95>{\n<line96>char new_perms[12];\n<line97>char naively_expected_perms[12];\n<line98>strmode (ch.new_mode, new_perms);\n<line99>strmode (naively_expected_mode, naively_expected_perms);\n<line100>new_perms[10] = naively_expected_perms[10] = '\0';\n<line101>error (0, 0,\n<line102>_("%s: new permissions are %s, not %s"),\n<line103>quotef (file_full_name),\n<line104>new_perms + 1, naively_expected_perms + 1);\n<line105>ch.status = CH_FAILED;\n<line106>}\n<line107>}\n<line108>if ( ! recurse)\n<line109>fts_set (fts, ent, FTS_SKIP);\n<line110>return CH_NOT_APPLIED <= ch.status;\n<line111>}
----------------------------------------
Function: process_files
Content: <line0>static bool\n<line1>process_files (char **files, int bit_flags)\n<line2>{\n<line3>bool ok = true;\n<line4>FTS *fts = xfts_open (files, bit_flags, nullptr);\n<line5>while (true)\n<line6>{\n<line7>FTSENT *ent;\n<line8>ent = fts_read (fts);\n<line9>if (ent == nullptr)\n<line10>{\n<line11>if (errno != 0)\n<line12>{\n<line13>/* FIXME: try to give a better message  */\n<line14>if (! force_silent)\n<line15>error (0, errno, _("fts_read failed"));\n<line16>ok = false;\n<line17>}\n<line18>break;\n<line19>}\n<line20>ok &= process_file (fts, ent);\n<line21>}\n<line22>if (fts_close (fts) != 0)\n<line23>{\n<line24>error (0, errno, _("fts_close failed"));\n<line25>ok = false;\n<line26>}\n<line27>return ok;\n<line28>}
----------------------------------------
Function: usage
Content: <line0>void\n<line1>usage (int status)\n<line2>{\n<line3>if (status != EXIT_SUCCESS)\n<line4>emit_try_help ();\n<line5>else\n<line6>{\n<line7>printf (_("\\n<line8>Usage: %s [OPTION]... MODE[,MODE]... FILE...\n\\n<line9>or:  %s [OPTION]... OCTAL-MODE FILE...\n\\n<line10>or:  %s [OPTION]... --reference=RFILE FILE...\n\\n<line11>"),\n<line12>program_name, program_name, program_name);\n<line13>fputs (_("\\n<line14>Change the mode of each FILE to MODE.\n\\n<line15>With --reference, change the mode of each FILE to that of RFILE.\n\\n<line16>\n\\n<line17>"), stdout);\n<line18>fputs (_("\\n<line19>-c, --changes          like verbose but report only when a change is made\n\\n<line20>-f, --silent, --quiet  suppress most error messages\n\\n<line21>-v, --verbose          output a diagnostic for every file processed\n\\n<line22>"), stdout);\n<line23>fputs (_("\\n<line24>--no-preserve-root  do not treat '/' specially (the default)\n\\n<line25>--preserve-root    fail to operate recursively on '/'\n\\n<line26>"), stdout);\n<line27>fputs (_("\\n<line28>--reference=RFILE  use RFILE's mode instead of specifying MODE values.\n\\n<line29>RFILE is always dereferenced if a symbolic link.\n\\n<line30>"), stdout);\n<line31>fputs (_("\\n<line32>-R, --recursive        change files and directories recursively\n\\n<line33>"), stdout);\n<line34>fputs (HELP_OPTION_DESCRIPTION, stdout);\n<line35>fputs (VERSION_OPTION_DESCRIPTION, stdout);\n<line36>fputs (_("\\n<line37>\n\\n<line38>Each MODE is of the form '[ugoa]*([-+=]([rwxXst]*|[ugo]))+|[-+=][0-7]+'.\n\\n<line39>"), stdout);\n<line40>emit_ancillary_info (PROGRAM_NAME);\n<line41>}\n<line42>exit (status);\n<line43>}
----------------------------------------
Function: main
Content: <line0>int\n<line1>main (int argc, char **argv)\n<line2>{\n<line3>char *mode = nullptr;\n<line4>idx_t mode_len = 0;\n<line5>idx_t mode_alloc = 0;\n<line6>bool ok;\n<line7>bool preserve_root = false;\n<line8>char const *reference_file = nullptr;\n<line9>int c;\n<line10>initialize_main (&argc, &argv);\n<line11>set_program_name (argv[0]);\n<line12>setlocale (LC_ALL, "");\n<line13>bindtextdomain (PACKAGE, LOCALEDIR);\n<line14>textdomain (PACKAGE);\n<line15>atexit (close_stdout);\n<line16>recurse = force_silent = diagnose_surprises = false;\n<line17>while ((c = getopt_long (argc, argv,\n<line18>("Rcfvr::w::x::X::s::t::u::g::o::a::,::+::=::"\n<line19>"0::1::2::3::4::5::6::7::"),\n<line20>long_options, nullptr))\n<line21>!= -1)\n<line22>{\n<line23>switch (c)\n<line24>{\n<line25>case 'r':\n<line26>case 'w':\n<line27>case 'x':\n<line28>case 'X':\n<line29>case 's':\n<line30>case 't':\n<line31>case 'u':\n<line32>case 'g':\n<line33>case 'o':\n<line34>case 'a':\n<line35>case ',':\n<line36>case '+':\n<line37>case '=':\n<line38>case '0': case '1': case '2': case '3':\n<line39>case '4': case '5': case '6': case '7':\n<line40>/* Support non-portable uses like "chmod -w", but diagnose\n<line41>surprises due to umask confusion.  Even though "--", "--r",\n<line42>etc., are valid modes, there is no "case '-'" here since\n<line43>getopt_long reserves leading "--" for long options.  */\n<line44>{\n<line45>/* Allocate a mode string (e.g., "-rwx") by concatenating\n<line46>the argument containing this option.  If a previous mode\n<line47>string was given, concatenate the previous string, a\n<line48>comma, and the new string (e.g., "-s,-rwx").  */\n<line49>char const *arg = argv[optind - 1];\n<line50>idx_t arg_len = strlen (arg);\n<line51>idx_t mode_comma_len = mode_len + !!mode_len;\n<line52>idx_t new_mode_len = mode_comma_len + arg_len;\n<line53>assume (0 <= new_mode_len);  /* Pacify GCC bug #109613.  */\n<line54>if (mode_alloc <= new_mode_len)\n<line55>mode = xpalloc (mode, &mode_alloc,\n<line56>new_mode_len + 1 - mode_alloc, -1, 1);\n<line57>mode[mode_len] = ',';\n<line58>memcpy (mode + mode_comma_len, arg, arg_len + 1);\n<line59>mode_len = new_mode_len;\n<line60>diagnose_surprises = true;\n<line61>}\n<line62>break;\n<line63>case NO_PRESERVE_ROOT:\n<line64>preserve_root = false;\n<line65>break;\n<line66>case PRESERVE_ROOT:\n<line67>preserve_root = true;\n<line68>break;\n<line69>case REFERENCE_FILE_OPTION:\n<line70>reference_file = optarg;\n<line71>break;\n<line72>case 'R':\n<line73>recurse = true;\n<line74>break;\n<line75>case 'c':\n<line76>verbosity = V_changes_only;\n<line77>break;\n<line78>case 'f':\n<line79>force_silent = true;\n<line80>break;\n<line81>case 'v':\n<line82>verbosity = V_high;\n<line83>break;\n<line84>case_GETOPT_HELP_CHAR;\n<line85>case_GETOPT_VERSION_CHAR (PROGRAM_NAME, AUTHORS);\n<line86>default:\n<line87>usage (EXIT_FAILURE);\n<line88>}\n<line89>}\n<line90>if (reference_file)\n<line91>{\n<line92>if (mode)\n<line93>{\n<line94>error (0, 0, _("cannot combine mode and --reference options"));\n<line95>usage (EXIT_FAILURE);\n<line96>}\n<line97>}\n<line98>else\n<line99>{\n<line100>if (!mode)\n<line101>mode = argv[optind++];\n<line102>}\n<line103>if (optind >= argc)\n<line104>{\n<line105>if (!mode || mode != argv[optind - 1])\n<line106>error (0, 0, _("missing operand"));\n<line107>else\n<line108>error (0, 0, _("missing operand after %s"), quote (argv[argc - 1]));\n<line109>usage (EXIT_FAILURE);\n<line110>}\n<line111>if (reference_file)\n<line112>{\n<line113>change = mode_create_from_ref (reference_file);\n<line114>if (!change)\n<line115>error (EXIT_FAILURE, errno, _("failed to get attributes of %s"),\n<line116>quoteaf (reference_file));\n<line117>}\n<line118>else\n<line119>{\n<line120>change = mode_compile (mode);\n<line121>if (!change)\n<line122>{\n<line123>error (0, 0, _("invalid mode: %s"), quote (mode));\n<line124>usage (EXIT_FAILURE);\n<line125>}\n<line126>umask_value = umask (0);\n<line127>}\n<line128>if (recurse && preserve_root)\n<line129>{\n<line130>static struct dev_ino dev_ino_buf;\n<line131>root_dev_ino = get_root_dev_ino (&dev_ino_buf);\n<line132>if (root_dev_ino == nullptr)\n<line133>error (EXIT_FAILURE, errno, _("failed to get attributes of %s"),\n<line134>quoteaf ("/"));\n<line135>}\n<line136>else\n<line137>{\n<line138>root_dev_ino = nullptr;\n<line139>}\n<line140>ok = process_files (argv + optind,\n<line141>FTS_COMFOLLOW | FTS_PHYSICAL | FTS_DEFER_STAT);\n<line142>main_exit (ok ? EXIT_SUCCESS : EXIT_FAILURE);\n<line143>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/src/chown.c
========================================
In file included from /home/huihui/Downloads/coreutils-9.4/src/chown.c:26:
In file included from ./lib/fts_.h:83:
./lib/i-ring.h:24:32: warning: '_Static_assert' with no message is a C2x extension [-Wc2x-extensions]
static_assert (1 <= I_RING_SIZE);
                               ^
                               , ""
1 warning generated.
Function: usage
Content: <line0>void\n<line1>usage (int status)\n<line2>{\n<line3>if (status != EXIT_SUCCESS)\n<line4>emit_try_help ();\n<line5>else\n<line6>{\n<line7>printf (_("\\n<line8>Usage: %s [OPTION]... [OWNER][:[GROUP]] FILE...\n\\n<line9>or:  %s [OPTION]... --reference=RFILE FILE...\n\\n<line10>"),\n<line11>program_name, program_name);\n<line12>fputs (_("\\n<line13>Change the owner and/or group of each FILE to OWNER and/or GROUP.\n\\n<line14>With --reference, change the owner and group of each FILE to those of RFILE.\n\\n<line15>\n\\n<line16>"), stdout);\n<line17>fputs (_("\\n<line18>-c, --changes          like verbose but report only when a change is made\n\\n<line19>-f, --silent, --quiet  suppress most error messages\n\\n<line20>-v, --verbose          output a diagnostic for every file processed\n\\n<line21>"), stdout);\n<line22>fputs (_("\\n<line23>--dereference      affect the referent of each symbolic link (this is\n\\n<line24>the default), rather than the symbolic link itself\n\\n<line25>-h, --no-dereference   affect symbolic links instead of any referenced file\n\\n<line26>"), stdout);\n<line27>fputs (_("\\n<line28>(useful only on systems that can change the\n\\n<line29>ownership of a symlink)\n\\n<line30>"), stdout);\n<line31>fputs (_("\\n<line32>--from=CURRENT_OWNER:CURRENT_GROUP\n\\n<line33>change the owner and/or group of each file only if\n\\n<line34>its current owner and/or group match those specified\n\\n<line35>here.  Either may be omitted, in which case a match\n\\n<line36>is not required for the omitted attribute\n\\n<line37>"), stdout);\n<line38>fputs (_("\\n<line39>--no-preserve-root  do not treat '/' specially (the default)\n\\n<line40>--preserve-root    fail to operate recursively on '/'\n\\n<line41>"), stdout);\n<line42>fputs (_("\\n<line43>--reference=RFILE  use RFILE's owner and group rather than specifying\n\\n<line44>OWNER:GROUP values.  RFILE is always dereferenced.\n\\n<line45>"), stdout);\n<line46>fputs (_("\\n<line47>-R, --recursive        operate on files and directories recursively\n\\n<line48>"), stdout);\n<line49>fputs (_("\\n<line50>\n\\n<line51>The following options modify how a hierarchy is traversed when the -R\n\\n<line52>option is also specified.  If more than one is specified, only the final\n\\n<line53>one takes effect.\n\\n<line54>\n\\n<line55>-H                     if a command line argument is a symbolic link\n\\n<line56>to a directory, traverse it\n\\n<line57>-L                     traverse every symbolic link to a directory\n\\n<line58>encountered\n\\n<line59>-P                     do not traverse any symbolic links (default)\n\\n<line60>\n\\n<line61>"), stdout);\n<line62>fputs (HELP_OPTION_DESCRIPTION, stdout);\n<line63>fputs (VERSION_OPTION_DESCRIPTION, stdout);\n<line64>fputs (_("\\n<line65>\n\\n<line66>Owner is unchanged if missing.  Group is unchanged if missing, but changed\n\\n<line67>to login group if implied by a ':' following a symbolic OWNER.\n\\n<line68>OWNER and GROUP may be numeric as well as symbolic.\n\\n<line69>"), stdout);\n<line70>printf (_("\\n<line71>\n\\n<line72>Examples:\n\\n<line73>%s root /u        Change the owner of /u to \"root\".\n\\n<line74>%s root:staff /u  Likewise, but also change its group to \"staff\".\n\\n<line75>%s -hR root /u    Change the owner of /u and subfiles to \"root\".\n\\n<line76>"),\n<line77>program_name, program_name, program_name);\n<line78>emit_ancillary_info (PROGRAM_NAME);\n<line79>}\n<line80>exit (status);\n<line81>}
----------------------------------------
Function: main
Content: <line0>int\n<line1>main (int argc, char **argv)\n<line2>{\n<line3>bool preserve_root = false;\n<line4>uid_t uid = -1;	/* Specified uid; -1 if not to be changed. */\n<line5>gid_t gid = -1;	/* Specified gid; -1 if not to be changed. */\n<line6>/* Change the owner (group) of a file only if it has this uid (gid).\n<line7>-1 means there's no restriction.  */\n<line8>uid_t required_uid = -1;\n<line9>gid_t required_gid = -1;\n<line10>/* Bit flags that control how fts works.  */\n<line11>int bit_flags = FTS_PHYSICAL;\n<line12>/* 1 if --dereference, 0 if --no-dereference, -1 if neither has been\n<line13>specified.  */\n<line14>int dereference = -1;\n<line15>struct Chown_option chopt;\n<line16>bool ok;\n<line17>int optc;\n<line18>initialize_main (&argc, &argv);\n<line19>set_program_name (argv[0]);\n<line20>setlocale (LC_ALL, "");\n<line21>bindtextdomain (PACKAGE, LOCALEDIR);\n<line22>textdomain (PACKAGE);\n<line23>atexit (close_stdout);\n<line24>chopt_init (&chopt);\n<line25>while ((optc = getopt_long (argc, argv, "HLPRcfhv", long_options, nullptr))\n<line26>!= -1)\n<line27>{\n<line28>switch (optc)\n<line29>{\n<line30>case 'H': /* Traverse command-line symlinks-to-directories.  */\n<line31>bit_flags = FTS_COMFOLLOW | FTS_PHYSICAL;\n<line32>break;\n<line33>case 'L': /* Traverse all symlinks-to-directories.  */\n<line34>bit_flags = FTS_LOGICAL;\n<line35>break;\n<line36>case 'P': /* Traverse no symlinks-to-directories.  */\n<line37>bit_flags = FTS_PHYSICAL;\n<line38>break;\n<line39>case 'h': /* --no-dereference: affect symlinks */\n<line40>dereference = 0;\n<line41>break;\n<line42>case DEREFERENCE_OPTION: /* --dereference: affect the referent\n<line43>of each symlink */\n<line44>dereference = 1;\n<line45>break;\n<line46>case NO_PRESERVE_ROOT:\n<line47>preserve_root = false;\n<line48>break;\n<line49>case PRESERVE_ROOT:\n<line50>preserve_root = true;\n<line51>break;\n<line52>case REFERENCE_FILE_OPTION:\n<line53>reference_file = optarg;\n<line54>break;\n<line55>case FROM_OPTION:\n<line56>{\n<line57>bool warn;\n<line58>char const *e = parse_user_spec_warn (optarg,\n<line59>&required_uid, &required_gid,\n<line60>nullptr, nullptr, &warn);\n<line61>if (e)\n<line62>error (warn ? 0 : EXIT_FAILURE, 0, "%s: %s", e, quote (optarg));\n<line63>break;\n<line64>}\n<line65>case 'R':\n<line66>chopt.recurse = true;\n<line67>break;\n<line68>case 'c':\n<line69>chopt.verbosity = V_changes_only;\n<line70>break;\n<line71>case 'f':\n<line72>chopt.force_silent = true;\n<line73>break;\n<line74>case 'v':\n<line75>chopt.verbosity = V_high;\n<line76>break;\n<line77>case_GETOPT_HELP_CHAR;\n<line78>case_GETOPT_VERSION_CHAR (PROGRAM_NAME, AUTHORS);\n<line79>default:\n<line80>usage (EXIT_FAILURE);\n<line81>}\n<line82>}\n<line83>if (chopt.recurse)\n<line84>{\n<line85>if (bit_flags == FTS_PHYSICAL)\n<line86>{\n<line87>if (dereference == 1)\n<line88>error (EXIT_FAILURE, 0,\n<line89>_("-R --dereference requires either -H or -L"));\n<line90>dereference = 0;\n<line91>}\n<line92>}\n<line93>else\n<line94>{\n<line95>bit_flags = FTS_PHYSICAL;\n<line96>}\n<line97>chopt.affect_symlink_referent = (dereference != 0);\n<line98>if (argc - optind < (reference_file ? 1 : 2))\n<line99>{\n<line100>if (argc <= optind)\n<line101>error (0, 0, _("missing operand"));\n<line102>else\n<line103>error (0, 0, _("missing operand after %s"), quote (argv[argc - 1]));\n<line104>usage (EXIT_FAILURE);\n<line105>}\n<line106>if (reference_file)\n<line107>{\n<line108>struct stat ref_stats;\n<line109>if (stat (reference_file, &ref_stats))\n<line110>error (EXIT_FAILURE, errno, _("failed to get attributes of %s"),\n<line111>quoteaf (reference_file));\n<line112>uid = ref_stats.st_uid;\n<line113>gid = ref_stats.st_gid;\n<line114>chopt.user_name = uid_to_name (ref_stats.st_uid);\n<line115>chopt.group_name = gid_to_name (ref_stats.st_gid);\n<line116>}\n<line117>else\n<line118>{\n<line119>bool warn;\n<line120>char const *e = parse_user_spec_warn (argv[optind], &uid, &gid,\n<line121>&chopt.user_name,\n<line122>&chopt.group_name, &warn);\n<line123>if (e)\n<line124>error (warn ? 0 : EXIT_FAILURE, 0, "%s: %s", e, quote (argv[optind]));\n<line125>/* If a group is specified but no user, set the user name to the\n<line126>empty string so that diagnostics say "ownership :GROUP"\n<line127>rather than "group GROUP".  */\n<line128>if (!chopt.user_name && chopt.group_name)\n<line129>chopt.user_name = xstrdup ("");\n<line130>optind++;\n<line131>}\n<line132>if (chopt.recurse && preserve_root)\n<line133>{\n<line134>static struct dev_ino dev_ino_buf;\n<line135>chopt.root_dev_ino = get_root_dev_ino (&dev_ino_buf);\n<line136>if (chopt.root_dev_ino == nullptr)\n<line137>error (EXIT_FAILURE, errno, _("failed to get attributes of %s"),\n<line138>quoteaf ("/"));\n<line139>}\n<line140>bit_flags |= FTS_DEFER_STAT;\n<line141>ok = chown_files (argv + optind, bit_flags,\n<line142>uid, gid,\n<line143>required_uid, required_gid, &chopt);\n<line144>main_exit (ok ? EXIT_SUCCESS : EXIT_FAILURE);\n<line145>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/src/digest.c
========================================
/home/huihui/Downloads/coreutils-9.4/src/digest.c:308:1: warning: '_Static_assert' with no message is a C2x extension [-Wc2x-extensions]
ARGMATCH_VERIFY (algorithm_args, algorithm_types);
^
./lib/argmatch.h:49:54: note: expanded from macro 'ARGMATCH_VERIFY'
                   == ARRAY_CARDINALITY (Vallist) + 1)
                                                     ^
/home/huihui/Downloads/coreutils-9.4/src/digest.c:322:53: warning: '_Static_assert' with no message is a C2x extension [-Wc2x-extensions]
               == ARRAY_CARDINALITY (algorithm_args));
                                                    ^
                                                    , ""
2 warnings generated.
Function: md5_sum_stream
Content: <line0>static int\n<line1>md5_sum_stream (FILE *stream, void *resstream, uintmax_t *length)\n<line2>{\n<line3>return md5_stream (stream, resstream);\n<line4>}
----------------------------------------
Function: sha1_sum_stream
Content: <line0>static int\n<line1>sha1_sum_stream (FILE *stream, void *resstream, uintmax_t *length)\n<line2>{\n<line3>return sha1_stream (stream, resstream);\n<line4>}
----------------------------------------
Function: sha224_sum_stream
Content: <line0>static int\n<line1>sha224_sum_stream (FILE *stream, void *resstream, uintmax_t *length)\n<line2>{\n<line3>return sha224_stream (stream, resstream);\n<line4>}
----------------------------------------
Function: sha256_sum_stream
Content: <line0>static int\n<line1>sha256_sum_stream (FILE *stream, void *resstream, uintmax_t *length)\n<line2>{\n<line3>return sha256_stream (stream, resstream);\n<line4>}
----------------------------------------
Function: sha384_sum_stream
Content: <line0>static int\n<line1>sha384_sum_stream (FILE *stream, void *resstream, uintmax_t *length)\n<line2>{\n<line3>return sha384_stream (stream, resstream);\n<line4>}
----------------------------------------
Function: sha512_sum_stream
Content: <line0>static int\n<line1>sha512_sum_stream (FILE *stream, void *resstream, uintmax_t *length)\n<line2>{\n<line3>return sha512_stream (stream, resstream);\n<line4>}
----------------------------------------
Function: blake2b_sum_stream
Content: <line0>static int\n<line1>blake2b_sum_stream (FILE *stream, void *resstream, uintmax_t *length)\n<line2>{\n<line3>return blake2b_stream (stream, resstream, *length);\n<line4>}
----------------------------------------
Function: sm3_sum_stream
Content: <line0>static int\n<line1>sm3_sum_stream (FILE *stream, void *resstream, uintmax_t *length)\n<line2>{\n<line3>return sm3_stream (stream, resstream);\n<line4>}
----------------------------------------
Function: usage
Content: <line0>void\n<line1>usage (int status)\n<line2>{\n<line3>if (status != EXIT_SUCCESS)\n<line4>emit_try_help ();\n<line5>else\n<line6>{\n<line7>printf (_("\\n<line8>Usage: %s [OPTION]... [FILE]...\n\\n<line9>"), program_name);\n<line10>#if HASH_ALGO_CKSUM\n<line11>fputs (_("\\n<line12>Print or verify checksums.\n\\n<line13>By default use the 32 bit CRC algorithm.\n\\n<line14>"), stdout);\n<line15>#else\n<line16>printf (_("\\n<line17>Print or check %s (%d-bit) checksums.\n\\n<line18>"),\n<line19>DIGEST_TYPE_STRING,\n<line20>DIGEST_BITS);\n<line21>#endif\n<line22>emit_stdin_note ();\n<line23>#if HASH_ALGO_SUM\n<line24>fputs (_("\\n<line25>\n\\n<line26>-r              use BSD sum algorithm (the default), use 1K blocks\n\\n<line27>-s, --sysv      use System V sum algorithm, use 512 bytes blocks\n\\n<line28>"), stdout);\n<line29>#endif\n<line30>#if HASH_ALGO_BLAKE2 || HASH_ALGO_CKSUM\n<line31>emit_mandatory_arg_note ();\n<line32>#endif\n<line33>#if HASH_ALGO_CKSUM\n<line34>fputs (_("\\n<line35>-a, --algorithm=TYPE  select the digest type to use.  See DIGEST below.\\n<line36>\n\\n<line37>"), stdout);\n<line38>fputs (_("\\n<line39>--base64          emit base64-encoded digests, not hexadecimal\\n<line40>\n\\n<line41>"), stdout);\n<line42>#endif\n<line43>#if !HASH_ALGO_SUM\n<line44># if !HASH_ALGO_CKSUM\n<line45>if (O_BINARY)\n<line46>fputs (_("\\n<line47>-b, --binary          read in binary mode (default unless reading tty stdin)\\n<line48>\n\\n<line49>"), stdout);\n<line50>else\n<line51>fputs (_("\\n<line52>-b, --binary          read in binary mode\n\\n<line53>"), stdout);\n<line54># endif\n<line55>fputs (_("\\n<line56>-c, --check           read checksums from the FILEs and check them\n\\n<line57>"), stdout);\n<line58># if HASH_ALGO_BLAKE2 || HASH_ALGO_CKSUM\n<line59>fputs (_("\\n<line60>-l, --length=BITS     digest length in bits; must not exceed the max for\n\\n<line61>the blake2 algorithm and must be a multiple of 8\n\\n<line62>"), stdout);\n<line63># endif\n<line64># if HASH_ALGO_CKSUM\n<line65>fputs (_("\\n<line66>--raw             emit a raw binary digest, not hexadecimal\\n<line67>\n\\n<line68>"), stdout);\n<line69>fputs (_("\\n<line70>--tag             create a BSD-style checksum (the default)\n\\n<line71>"), stdout);\n<line72>fputs (_("\\n<line73>--untagged        create a reversed style checksum, without digest type\n\\n<line74>"), stdout);\n<line75># else\n<line76>fputs (_("\\n<line77>--tag             create a BSD-style checksum\n\\n<line78>"), stdout);\n<line79># endif\n<line80># if !HASH_ALGO_CKSUM\n<line81>if (O_BINARY)\n<line82>fputs (_("\\n<line83>-t, --text            read in text mode (default if reading tty stdin)\n\\n<line84>"), stdout);\n<line85>else\n<line86>fputs (_("\\n<line87>-t, --text            read in text mode (default)\n\\n<line88>"), stdout);\n<line89># endif\n<line90>fputs (_("\\n<line91>-z, --zero            end each output line with NUL, not newline,\n\\n<line92>and disable file name escaping\n\\n<line93>"), stdout);\n<line94>fputs (_("\\n<line95>\n\\n<line96>The following five options are useful only when verifying checksums:\n\\n<line97>--ignore-missing  don't fail or report status for missing files\n\\n<line98>--quiet           don't print OK for each successfully verified file\n\\n<line99>--status          don't output anything, status code shows success\n\\n<line100>--strict          exit non-zero for improperly formatted checksum lines\n\\n<line101>-w, --warn            warn about improperly formatted checksum lines\n\\n<line102>\n\\n<line103>"), stdout);\n<line104>#endif\n<line105>#if HASH_ALGO_CKSUM\n<line106>fputs (_("\\n<line107>--debug           indicate which implementation used\n\\n<line108>"), stdout);\n<line109>#endif\n<line110>fputs (HELP_OPTION_DESCRIPTION, stdout);\n<line111>fputs (VERSION_OPTION_DESCRIPTION, stdout);\n<line112>#if HASH_ALGO_CKSUM\n<line113>fputs (_("\\n<line114>\n\\n<line115>DIGEST determines the digest algorithm and default output format:\n\\n<line116>sysv      (equivalent to sum -s)\n\\n<line117>bsd       (equivalent to sum -r)\n\\n<line118>crc       (equivalent to cksum)\n\\n<line119>md5       (equivalent to md5sum)\n\\n<line120>sha1      (equivalent to sha1sum)\n\\n<line121>sha224    (equivalent to sha224sum)\n\\n<line122>sha256    (equivalent to sha256sum)\n\\n<line123>sha384    (equivalent to sha384sum)\n\\n<line124>sha512    (equivalent to sha512sum)\n\\n<line125>blake2b   (equivalent to b2sum)\n\\n<line126>sm3       (only available through cksum)\n\\n<line127>\n"), stdout);\n<line128>#endif\n<line129>#if !HASH_ALGO_SUM && !HASH_ALGO_CKSUM\n<line130>printf (_("\\n<line131>\n\\n<line132>The sums are computed as described in %s.\n"), DIGEST_REFERENCE);\n<line133>fputs (_("\\n<line134>When checking, the input should be a former output of this program.\n\\n<line135>The default mode is to print a line with: checksum, a space,\n\\n<line136>a character indicating input mode ('*' for binary, ' ' for text\n\\n<line137>or where binary is insignificant), and name for each FILE.\n\\n<line138>\n\\n<line139>Note: There is no difference between binary mode and text mode on GNU systems.\\n<line140>\n"), stdout);\n<line141>#endif\n<line142>#if HASH_ALGO_CKSUM\n<line143>fputs (_("\\n<line144>When checking, the input should be a former output of this program,\n\\n<line145>or equivalent standalone program.\\n<line146>\n"), stdout);\n<line147>#endif\n<line148>emit_ancillary_info (PROGRAM_NAME);\n<line149>}\n<line150>exit (status);\n<line151>}
----------------------------------------
Function: filename_unescape
Content: <line0>static char *\n<line1>filename_unescape (char *s, size_t s_len)\n<line2>{\n<line3>char *dst = s;\n<line4>for (size_t i = 0; i < s_len; i++)\n<line5>{\n<line6>switch (s[i])\n<line7>{\n<line8>case '\\':\n<line9>if (i == s_len - 1)\n<line10>{\n<line11>/* File name ends with an unescaped backslash: invalid.  */\n<line12>return nullptr;\n<line13>}\n<line14>++i;\n<line15>switch (s[i])\n<line16>{\n<line17>case 'n':\n<line18>*dst++ = '\n';\n<line19>break;\n<line20>case 'r':\n<line21>*dst++ = '\r';\n<line22>break;\n<line23>case '\\':\n<line24>*dst++ = '\\';\n<line25>break;\n<line26>default:\n<line27>/* Only '\', 'n' or 'r' may follow a backslash.  */\n<line28>return nullptr;\n<line29>}\n<line30>break;\n<line31>case '\0':\n<line32>/* The file name may not contain a NUL.  */\n<line33>return nullptr;\n<line34>default:\n<line35>*dst++ = s[i];\n<line36>break;\n<line37>}\n<line38>}\n<line39>if (dst < s + s_len)\n<line40>*dst = '\0';\n<line41>return s;\n<line42>}
----------------------------------------
Function: bsd_split_3
Content: <line0>static bool\n<line1>bsd_split_3 (char *s, size_t s_len,\n<line2>unsigned char **digest, size_t *d_len,\n<line3>char **file_name, bool escaped_filename)\n<line4>{\n<line5>if (s_len == 0)\n<line6>return false;\n<line7>/* Find end of filename.  */\n<line8>size_t i = s_len - 1;\n<line9>while (i && s[i] != ')')\n<line10>i--;\n<line11>if (s[i] != ')')\n<line12>return false;\n<line13>*file_name = s;\n<line14>if (escaped_filename && filename_unescape (s, i) == nullptr)\n<line15>return false;\n<line16>s[i++] = '\0';\n<line17>while (ISWHITE (s[i]))\n<line18>i++;\n<line19>if (s[i] != '=')\n<line20>return false;\n<line21>i++;\n<line22>while (ISWHITE (s[i]))\n<line23>i++;\n<line24>*digest = (unsigned char *) &s[i];\n<line25>*d_len = s_len - i;\n<line26>return valid_digits (*digest, *d_len);\n<line27>}
----------------------------------------
Function: algorithm_from_tag
Content: <line0>static ptrdiff_t\n<line1>algorithm_from_tag (char *s)\n<line2>{\n<line3>/* Limit check size to this length for perf reasons.  */\n<line4>static size_t max_tag_len;\n<line5>if (! max_tag_len)\n<line6>{\n<line7>char const * const * tag = algorithm_tags;\n<line8>while (*tag)\n<line9>{\n<line10>size_t tag_len = strlen (*tag++);\n<line11>max_tag_len = MAX (tag_len, max_tag_len);\n<line12>}\n<line13>}\n<line14>size_t i = 0;\n<line15>/* Find end of tag */\n<line16>while (i <= max_tag_len && s[i] && ! ISWHITE (s[i])\n<line17>&& s[i] != '-' && s[i] != '(')\n<line18>++i;\n<line19>if (i > max_tag_len)\n<line20>return -1;\n<line21>/* Terminate tag, and lookup.  */\n<line22>char sep = s[i];\n<line23>s[i] = '\0';\n<line24>ptrdiff_t algo = argmatch_exact (s, algorithm_tags);\n<line25>s[i] = sep;\n<line26>return algo;\n<line27>}
----------------------------------------
Function: split_3
Content: <line0>static bool\n<line1>split_3 (char *s, size_t s_len,\n<line2>unsigned char **digest, size_t *d_len, int *binary, char **file_name)\n<line3>{\n<line4>bool escaped_filename = false;\n<line5>size_t algo_name_len;\n<line6>size_t i = 0;\n<line7>while (ISWHITE (s[i]))\n<line8>++i;\n<line9>if (s[i] == '\\')\n<line10>{\n<line11>++i;\n<line12>escaped_filename = true;\n<line13>}\n<line14>/* Check for BSD-style checksum line. */\n<line15>#if HASH_ALGO_CKSUM\n<line16>if (! algorithm_specified)\n<line17>{\n<line18>ptrdiff_t algo_tag = algorithm_from_tag (s + i);\n<line19>if (algo_tag >= 0)\n<line20>{\n<line21>if (algo_tag <= crc)\n<line22>return false;  /* We don't support checking these older formats.  */\n<line23>cksum_algorithm = algo_tag;\n<line24>}\n<line25>else\n<line26>return false;  /* We only support tagged format without -a.  */\n<line27>}\n<line28>#endif\n<line29>algo_name_len = strlen (DIGEST_TYPE_STRING);\n<line30>if (STREQ_LEN (s + i, DIGEST_TYPE_STRING, algo_name_len))\n<line31>{\n<line32>i += algo_name_len;\n<line33>#if HASH_ALGO_BLAKE2 || HASH_ALGO_CKSUM\n<line34>/* Terminate and match algorithm name.  */\n<line35>char const *algo_name = &s[i - algo_name_len];\n<line36>bool length_specified = s[i] == '-';\n<line37>bool openssl_format = s[i] == '('; /* and no length_specified */\n<line38>s[i++] = '\0';\n<line39>if (!STREQ (algo_name, DIGEST_TYPE_STRING))\n<line40>return false;\n<line41>if (openssl_format)\n<line42>s[--i] = '(';\n<line43># if HASH_ALGO_BLAKE2\n<line44>digest_length = BLAKE2B_MAX_LEN * 8;\n<line45># else\n<line46>digest_length = algorithm_bits[cksum_algorithm];\n<line47># endif\n<line48>if (length_specified)\n<line49>{\n<line50>uintmax_t length;\n<line51>char *siend;\n<line52>if (! (xstrtoumax (s + i, &siend, 0, &length, nullptr) == LONGINT_OK\n<line53>&& 0 < length && length <= digest_length\n<line54>&& length % 8 == 0))\n<line55>return false;\n<line56>i = siend - s;\n<line57>digest_length = length;\n<line58>}\n<line59>digest_hex_bytes = digest_length / 4;\n<line60>#endif\n<line61>if (s[i] == ' ')\n<line62>++i;\n<line63>if (s[i] == '(')\n<line64>{\n<line65>++i;\n<line66>*binary = 0;\n<line67>return bsd_split_3 (s + i, s_len - i,\n<line68>digest, d_len, file_name, escaped_filename);\n<line69>}\n<line70>return false;\n<line71>}\n<line72>/* Ignore this line if it is too short.\n<line73>Each line must have at least 'min_digest_line_length - 1' (or one more, if\n<line74>the first is a backslash) more characters to contain correct message digest\n<line75>information.  */\n<line76>if (s_len - i < min_digest_line_length + (s[i] == '\\'))\n<line77>return false;\n<line78>*digest = (unsigned char *) &s[i];\n<line79>#if HASH_ALGO_BLAKE2 || HASH_ALGO_CKSUM\n<line80>/* Auto determine length.  */\n<line81># if HASH_ALGO_CKSUM\n<line82>if (cksum_algorithm == blake2b) {\n<line83># endif\n<line84>unsigned char const *hp = *digest;\n<line85>digest_hex_bytes = 0;\n<line86>while (isxdigit (*hp++))\n<line87>digest_hex_bytes++;\n<line88>if (digest_hex_bytes < 2 || digest_hex_bytes % 2\n<line89>|| BLAKE2B_MAX_LEN * 2 < digest_hex_bytes)\n<line90>return false;\n<line91>digest_length = digest_hex_bytes * 4;\n<line92># if HASH_ALGO_CKSUM\n<line93>}\n<line94># endif\n<line95>#endif\n<line96>/* This field must be the hexadecimal or base64 representation\n<line97>of the message digest.  */\n<line98>while (s[i] && !ISWHITE (s[i]))\n<line99>i++;\n<line100>/* The digest must be followed by at least one whitespace character.  */\n<line101>if (i == s_len)\n<line102>return false;\n<line103>*d_len = &s[i] - (char *) *digest;\n<line104>s[i++] = '\0';\n<line105>if (! valid_digits (*digest, *d_len))\n<line106>return false;\n<line107>/* If "bsd reversed" format detected.  */\n<line108>if ((s_len - i == 1) || (s[i] != ' ' && s[i] != '*'))\n<line109>{\n<line110>/* Don't allow mixing bsd and standard formats,\n<line111>to minimize security issues with attackers\n<line112>renaming files with leading spaces.\n<line113>This assumes that with bsd format checksums\n<line114>that the first file name does not have\n<line115>a leading ' ' or '*'.  */\n<line116>if (bsd_reversed == 0)\n<line117>return false;\n<line118>bsd_reversed = 1;\n<line119>}\n<line120>else if (bsd_reversed != 1)\n<line121>{\n<line122>bsd_reversed = 0;\n<line123>*binary = (s[i++] == '*');\n<line124>}\n<line125>/* All characters between the type indicator and end of line are\n<line126>significant -- that includes leading and trailing white space.  */\n<line127>*file_name = &s[i];\n<line128>if (escaped_filename)\n<line129>return filename_unescape (&s[i], s_len - i) != nullptr;\n<line130>return true;\n<line131>}
----------------------------------------
Function: print_filename
Content: <line0>static void\n<line1>print_filename (char const *file, bool escape)\n<line2>{\n<line3>if (! escape)\n<line4>{\n<line5>fputs (file, stdout);\n<line6>return;\n<line7>}\n<line8>while (*file)\n<line9>{\n<line10>switch (*file)\n<line11>{\n<line12>case '\n':\n<line13>fputs ("\\n", stdout);\n<line14>break;\n<line15>case '\r':\n<line16>fputs ("\\r", stdout);\n<line17>break;\n<line18>case '\\':\n<line19>fputs ("\\\\", stdout);\n<line20>break;\n<line21>default:\n<line22>putchar (*file);\n<line23>break;\n<line24>}\n<line25>file++;\n<line26>}\n<line27>}
----------------------------------------
Function: digest_file
Content: <line0>static bool\n<line1>digest_file (char const *filename, int *binary, unsigned char *bin_result,\n<line2>bool *missing, MAYBE_UNUSED uintmax_t *length)\n<line3>{\n<line4>FILE *fp;\n<line5>int err;\n<line6>bool is_stdin = STREQ (filename, "-");\n<line7>*missing = false;\n<line8>if (is_stdin)\n<line9>{\n<line10>have_read_stdin = true;\n<line11>fp = stdin;\n<line12>if (O_BINARY && *binary)\n<line13>{\n<line14>if (*binary < 0)\n<line15>*binary = ! isatty (STDIN_FILENO);\n<line16>if (*binary)\n<line17>xset_binary_mode (STDIN_FILENO, O_BINARY);\n<line18>}\n<line19>}\n<line20>else\n<line21>{\n<line22>fp = fopen (filename, (O_BINARY && *binary ? "rb" : "r"));\n<line23>if (fp == nullptr)\n<line24>{\n<line25>if (ignore_missing && errno == ENOENT)\n<line26>{\n<line27>*missing = true;\n<line28>return true;\n<line29>}\n<line30>error (0, errno, "%s", quotef (filename));\n<line31>return false;\n<line32>}\n<line33>}\n<line34>fadvise (fp, FADVISE_SEQUENTIAL);\n<line35>#if HASH_ALGO_CKSUM\n<line36>if (cksum_algorithm == blake2b)\n<line37>*length = digest_length / 8;\n<line38>err = DIGEST_STREAM (fp, bin_result, length);\n<line39>#elif HASH_ALGO_SUM\n<line40>err = DIGEST_STREAM (fp, bin_result, length);\n<line41>#elif HASH_ALGO_BLAKE2\n<line42>err = DIGEST_STREAM (fp, bin_result, digest_length / 8);\n<line43>#else\n<line44>err = DIGEST_STREAM (fp, bin_result);\n<line45>#endif\n<line46>err = err ? errno : 0;\n<line47>if (is_stdin)\n<line48>clearerr (fp);\n<line49>else if (fclose (fp) != 0 && !err)\n<line50>err = errno;\n<line51>if (err)\n<line52>{\n<line53>error (0, err, "%s", quotef (filename));\n<line54>return false;\n<line55>}\n<line56>return true;\n<line57>}
----------------------------------------
Function: output_file
Content: <line0>static void\n<line1>output_file (char const *file, int binary_file, void const *digest,\n<line2>bool raw, bool tagged, unsigned char delim, MAYBE_UNUSED bool args,\n<line3>MAYBE_UNUSED uintmax_t length)\n<line4>{\n<line5># if HASH_ALGO_CKSUM\n<line6>if (raw)\n<line7>{\n<line8>fwrite (digest, 1, digest_length / 8, stdout);\n<line9>return;\n<line10>}\n<line11># endif\n<line12>unsigned char const *bin_buffer = digest;\n<line13>/* Output a leading backslash if the file name contains problematic chars.  */\n<line14>bool needs_escape = delim == '\n' && problematic_chars (file);\n<line15>if (needs_escape)\n<line16>putchar ('\\');\n<line17>if (tagged)\n<line18>{\n<line19>fputs (DIGEST_TYPE_STRING, stdout);\n<line20># if HASH_ALGO_BLAKE2\n<line21>if (digest_length < BLAKE2B_MAX_LEN * 8)\n<line22>printf ("-%"PRIuMAX, digest_length);\n<line23># elif HASH_ALGO_CKSUM\n<line24>if (cksum_algorithm == blake2b)\n<line25>{\n<line26>if (digest_length < BLAKE2B_MAX_LEN * 8)\n<line27>printf ("-%"PRIuMAX, digest_length);\n<line28>}\n<line29># endif\n<line30>fputs (" (", stdout);\n<line31>print_filename (file, needs_escape);\n<line32>fputs (") = ", stdout);\n<line33>}\n<line34># if HASH_ALGO_CKSUM\n<line35>if (base64_digest)\n<line36>{\n<line37>char b64[BASE64_LENGTH (DIGEST_BIN_BYTES) + 1];\n<line38>base64_encode ((char const *) bin_buffer, digest_length / 8,\n<line39>b64, sizeof b64);\n<line40>fputs (b64, stdout);\n<line41>}\n<line42>else\n<line43># endif\n<line44>{\n<line45>for (size_t i = 0; i < (digest_hex_bytes / 2); ++i)\n<line46>printf ("%02x", bin_buffer[i]);\n<line47>}\n<line48>if (!tagged)\n<line49>{\n<line50>putchar (' ');\n<line51>putchar (binary_file ? '*' : ' ');\n<line52>print_filename (file, needs_escape);\n<line53>}\n<line54>putchar (delim);\n<line55>}
----------------------------------------
Function: b64_equal
Content: <line0>static bool\n<line1>b64_equal (unsigned char const *b64_digest, unsigned char const *bin_buffer)\n<line2>{\n<line3>size_t b64_n_bytes = BASE64_LENGTH (digest_length / 8);\n<line4>char b64[BASE64_LENGTH (DIGEST_BIN_BYTES) + 1];\n<line5>base64_encode ((char const *) bin_buffer, digest_length / 8, b64, sizeof b64);\n<line6>return memcmp (b64_digest, b64, b64_n_bytes + 1) == 0;\n<line7>}
----------------------------------------
Function: hex_equal
Content: <line0>static bool\n<line1>hex_equal (unsigned char const *hex_digest, unsigned char const *bin_buffer)\n<line2>{\n<line3>static const char bin2hex[] = { '0', '1', '2', '3',\n<line4>'4', '5', '6', '7',\n<line5>'8', '9', 'a', 'b',\n<line6>'c', 'd', 'e', 'f' };\n<line7>size_t digest_bin_bytes = digest_hex_bytes / 2;\n<line8>/* Compare generated binary number with text representation\n<line9>in check file.  Ignore case of hex digits.  */\n<line10>size_t cnt;\n<line11>for (cnt = 0; cnt < digest_bin_bytes; ++cnt)\n<line12>{\n<line13>if (tolower (hex_digest[2 * cnt])\n<line14>!= bin2hex[bin_buffer[cnt] >> 4]\n<line15>|| (tolower (hex_digest[2 * cnt + 1])\n<line16>!= (bin2hex[bin_buffer[cnt] & 0xf])))\n<line17>break;\n<line18>}\n<line19>return cnt == digest_bin_bytes;\n<line20>}
----------------------------------------
Function: digest_check
Content: <line0>static bool\n<line1>digest_check (char const *checkfile_name)\n<line2>{\n<line3>FILE *checkfile_stream;\n<line4>uintmax_t n_misformatted_lines = 0;\n<line5>uintmax_t n_mismatched_checksums = 0;\n<line6>uintmax_t n_open_or_read_failures = 0;\n<line7>bool properly_formatted_lines = false;\n<line8>bool matched_checksums = false;\n<line9>unsigned char bin_buffer_unaligned[DIGEST_BIN_BYTES + DIGEST_ALIGN];\n<line10>/* Make sure bin_buffer is properly aligned. */\n<line11>unsigned char *bin_buffer = ptr_align (bin_buffer_unaligned, DIGEST_ALIGN);\n<line12>uintmax_t line_number;\n<line13>char *line;\n<line14>size_t line_chars_allocated;\n<line15>bool is_stdin = STREQ (checkfile_name, "-");\n<line16>if (is_stdin)\n<line17>{\n<line18>have_read_stdin = true;\n<line19>checkfile_name = _("standard input");\n<line20>checkfile_stream = stdin;\n<line21>}\n<line22>else\n<line23>{\n<line24>checkfile_stream = fopen (checkfile_name, "r");\n<line25>if (checkfile_stream == nullptr)\n<line26>{\n<line27>error (0, errno, "%s", quotef (checkfile_name));\n<line28>return false;\n<line29>}\n<line30>}\n<line31>line_number = 0;\n<line32>line = nullptr;\n<line33>line_chars_allocated = 0;\n<line34>do\n<line35>{\n<line36>char *filename;\n<line37>int binary;\n<line38>unsigned char *digest;\n<line39>ssize_t line_length;\n<line40>++line_number;\n<line41>if (line_number == 0)\n<line42>error (EXIT_FAILURE, 0, _("%s: too many checksum lines"),\n<line43>quotef (checkfile_name));\n<line44>line_length = getline (&line, &line_chars_allocated, checkfile_stream);\n<line45>if (line_length <= 0)\n<line46>break;\n<line47>/* Ignore comment lines, which begin with a '#' character.  */\n<line48>if (line[0] == '#')\n<line49>continue;\n<line50>/* Remove any trailing newline.  */\n<line51>line_length -= line[line_length - 1] == '\n';\n<line52>/* Remove any trailing carriage return.  */\n<line53>line_length -= line[line_length - (0 < line_length)] == '\r';\n<line54>/* Ignore empty lines.  */\n<line55>if (line_length == 0)\n<line56>continue;\n<line57>line[line_length] = '\0';\n<line58>size_t d_len;\n<line59>if (! (split_3 (line, line_length, &digest, &d_len, &binary, &filename)\n<line60>&& ! (is_stdin && STREQ (filename, "-"))))\n<line61>{\n<line62>++n_misformatted_lines;\n<line63>if (warn)\n<line64>{\n<line65>error (0, 0,\n<line66>_("%s: %" PRIuMAX\n<line67>": improperly formatted %s checksum line"),\n<line68>quotef (checkfile_name), line_number,\n<line69>DIGEST_TYPE_STRING);\n<line70>}\n<line71>}\n<line72>else\n<line73>{\n<line74>bool ok;\n<line75>bool missing;\n<line76>bool needs_escape = ! status_only && problematic_chars (filename);\n<line77>properly_formatted_lines = true;\n<line78>uintmax_t length;\n<line79>ok = digest_file (filename, &binary, bin_buffer, &missing, &length);\n<line80>if (!ok)\n<line81>{\n<line82>++n_open_or_read_failures;\n<line83>if (!status_only)\n<line84>{\n<line85>if (needs_escape)\n<line86>putchar ('\\');\n<line87>print_filename (filename, needs_escape);\n<line88>printf (": %s\n", _("FAILED open or read"));\n<line89>}\n<line90>}\n<line91>else if (ignore_missing && missing)\n<line92>{\n<line93>/* Ignore missing files with --ignore-missing.  */\n<line94>;\n<line95>}\n<line96>else\n<line97>{\n<line98>bool match = false;\n<line99>#if HASH_ALGO_CKSUM\n<line100>if (d_len < digest_hex_bytes)\n<line101>match = b64_equal (digest, bin_buffer);\n<line102>else\n<line103>#endif\n<line104>if (d_len == digest_hex_bytes)\n<line105>match = hex_equal (digest, bin_buffer);\n<line106>if (match)\n<line107>matched_checksums = true;\n<line108>else\n<line109>++n_mismatched_checksums;\n<line110>if (!status_only)\n<line111>{\n<line112>if (! match || ! quiet)\n<line113>{\n<line114>if (needs_escape)\n<line115>putchar ('\\');\n<line116>print_filename (filename, needs_escape);\n<line117>}\n<line118>if (! match)\n<line119>printf (": %s\n", _("FAILED"));\n<line120>else if (!quiet)\n<line121>printf (": %s\n", _("OK"));\n<line122>}\n<line123>}\n<line124>}\n<line125>}\n<line126>while (!feof (checkfile_stream) && !ferror (checkfile_stream));\n<line127>free (line);\n<line128>int err = ferror (checkfile_stream) ? 0 : -1;\n<line129>if (is_stdin)\n<line130>clearerr (checkfile_stream);\n<line131>else if (fclose (checkfile_stream) != 0 && err < 0)\n<line132>err = errno;\n<line133>if (0 <= err)\n<line134>{\n<line135>error (0, err, err ? "%s" : _("%s: read error"),\n<line136>quotef (checkfile_name));\n<line137>return false;\n<line138>}\n<line139>if (! properly_formatted_lines)\n<line140>{\n<line141>/* Warn if no tests are found.  */\n<line142>error (0, 0, _("%s: no properly formatted checksum lines found"),\n<line143>quotef (checkfile_name));\n<line144>}\n<line145>else\n<line146>{\n<line147>if (!status_only)\n<line148>{\n<line149>if (n_misformatted_lines != 0)\n<line150>error (0, 0,\n<line151>(ngettext\n<line152>("WARNING: %" PRIuMAX " line is improperly formatted",\n<line153>"WARNING: %" PRIuMAX " lines are improperly formatted",\n<line154>select_plural (n_misformatted_lines))),\n<line155>n_misformatted_lines);\n<line156>if (n_open_or_read_failures != 0)\n<line157>error (0, 0,\n<line158>(ngettext\n<line159>("WARNING: %" PRIuMAX " listed file could not be read",\n<line160>"WARNING: %" PRIuMAX " listed files could not be read",\n<line161>select_plural (n_open_or_read_failures))),\n<line162>n_open_or_read_failures);\n<line163>if (n_mismatched_checksums != 0)\n<line164>error (0, 0,\n<line165>(ngettext\n<line166>("WARNING: %" PRIuMAX " computed checksum did NOT match",\n<line167>"WARNING: %" PRIuMAX " computed checksums did NOT match",\n<line168>select_plural (n_mismatched_checksums))),\n<line169>n_mismatched_checksums);\n<line170>if (ignore_missing && ! matched_checksums)\n<line171>error (0, 0, _("%s: no file was verified"),\n<line172>quotef (checkfile_name));\n<line173>}\n<line174>}\n<line175>return (properly_formatted_lines\n<line176>&& matched_checksums\n<line177>&& n_mismatched_checksums == 0\n<line178>&& n_open_or_read_failures == 0\n<line179>&& (!strict || n_misformatted_lines == 0));\n<line180>}
----------------------------------------
Function: main
Content: <line0>int\n<line1>main (int argc, char **argv)\n<line2>{\n<line3>unsigned char bin_buffer_unaligned[DIGEST_BIN_BYTES + DIGEST_ALIGN];\n<line4>/* Make sure bin_buffer is properly aligned. */\n<line5>unsigned char *bin_buffer = ptr_align (bin_buffer_unaligned, DIGEST_ALIGN);\n<line6>bool do_check = false;\n<line7>int opt;\n<line8>bool ok = true;\n<line9>int binary = -1;\n<line10>#if HASH_ALGO_CKSUM\n<line11>bool prefix_tag = true;\n<line12>#else\n<line13>bool prefix_tag = false;\n<line14>#endif\n<line15>/* Setting values of global variables.  */\n<line16>initialize_main (&argc, &argv);\n<line17>set_program_name (argv[0]);\n<line18>setlocale (LC_ALL, "");\n<line19>bindtextdomain (PACKAGE, LOCALEDIR);\n<line20>textdomain (PACKAGE);\n<line21>atexit (close_stdout);\n<line22>/* Line buffer stdout to ensure lines are written atomically and immediately\n<line23>so that processes running in parallel do not intersperse their output.  */\n<line24>setvbuf (stdout, nullptr, _IOLBF, 0);\n<line25>#if HASH_ALGO_SUM\n<line26>char const *short_opts = "rs";\n<line27>#elif HASH_ALGO_CKSUM\n<line28>char const *short_opts = "a:l:bctwz";\n<line29>char const *digest_length_str = "";\n<line30>#elif HASH_ALGO_BLAKE2\n<line31>char const *short_opts = "l:bctwz";\n<line32>char const *digest_length_str = "";\n<line33>#else\n<line34>char const *short_opts = "bctwz";\n<line35>#endif\n<line36>while ((opt = getopt_long (argc, argv, short_opts, long_options, nullptr))\n<line37>!= -1)\n<line38>switch (opt)\n<line39>{\n<line40>#if HASH_ALGO_CKSUM\n<line41>case 'a':\n<line42>cksum_algorithm = XARGMATCH_EXACT ("--algorithm", optarg,\n<line43>algorithm_args, algorithm_types);\n<line44>algorithm_specified = true;\n<line45>break;\n<line46>case DEBUG_PROGRAM_OPTION:\n<line47>cksum_debug = true;\n<line48>break;\n<line49>#endif\n<line50>#if HASH_ALGO_BLAKE2 || HASH_ALGO_CKSUM\n<line51>case 'l':\n<line52>digest_length = xdectoumax (optarg, 0, UINTMAX_MAX, "",\n<line53>_("invalid length"), 0);\n<line54>digest_length_str = optarg;\n<line55>if (digest_length % 8 != 0)\n<line56>{\n<line57>error (0, 0, _("invalid length: %s"), quote (digest_length_str));\n<line58>error (EXIT_FAILURE, 0, _("length is not a multiple of 8"));\n<line59>}\n<line60>break;\n<line61>#endif\n<line62>#if !HASH_ALGO_SUM\n<line63>case 'c':\n<line64>do_check = true;\n<line65>break;\n<line66>case STATUS_OPTION:\n<line67>status_only = true;\n<line68>warn = false;\n<line69>quiet = false;\n<line70>break;\n<line71>case 'b':\n<line72>binary = 1;\n<line73>break;\n<line74>case 't':\n<line75>binary = 0;\n<line76>break;\n<line77>case 'w':\n<line78>status_only = false;\n<line79>warn = true;\n<line80>quiet = false;\n<line81>break;\n<line82>case IGNORE_MISSING_OPTION:\n<line83>ignore_missing = true;\n<line84>break;\n<line85>case QUIET_OPTION:\n<line86>status_only = false;\n<line87>warn = false;\n<line88>quiet = true;\n<line89>break;\n<line90>case STRICT_OPTION:\n<line91>strict = true;\n<line92>break;\n<line93># if HASH_ALGO_CKSUM\n<line94>case BASE64_OPTION:\n<line95>base64_digest = true;\n<line96>break;\n<line97>case RAW_OPTION:\n<line98>raw_digest = true;\n<line99>break;\n<line100>case UNTAG_OPTION:\n<line101>prefix_tag = false;\n<line102>break;\n<line103># endif\n<line104>case TAG_OPTION:\n<line105>prefix_tag = true;\n<line106>binary = 1;\n<line107>break;\n<line108>case 'z':\n<line109>digest_delim = '\0';\n<line110>break;\n<line111>#endif\n<line112>#if HASH_ALGO_SUM\n<line113>case 'r':		/* For SysV compatibility. */\n<line114>sum_algorithm = bsd;\n<line115>break;\n<line116>case 's':\n<line117>sum_algorithm = sysv;\n<line118>break;\n<line119>#endif\n<line120>case_GETOPT_HELP_CHAR;\n<line121>case_GETOPT_VERSION_CHAR (PROGRAM_NAME, AUTHORS);\n<line122>default:\n<line123>usage (EXIT_FAILURE);\n<line124>}\n<line125>min_digest_line_length = MIN_DIGEST_LINE_LENGTH;\n<line126>#if HASH_ALGO_BLAKE2 || HASH_ALGO_CKSUM\n<line127># if HASH_ALGO_CKSUM\n<line128>if (digest_length && cksum_algorithm != blake2b)\n<line129>error (EXIT_FAILURE, 0,\n<line130>_("--length is only supported with --algorithm=blake2b"));\n<line131># endif\n<line132>if (digest_length > BLAKE2B_MAX_LEN * 8)\n<line133>{\n<line134>error (0, 0, _("invalid length: %s"), quote (digest_length_str));\n<line135>error (EXIT_FAILURE, 0,\n<line136>_("maximum digest length for %s is %d bits"),\n<line137>quote (DIGEST_TYPE_STRING),\n<line138>BLAKE2B_MAX_LEN * 8);\n<line139>}\n<line140>if (digest_length == 0)\n<line141>{\n<line142># if HASH_ALGO_BLAKE2\n<line143>digest_length = BLAKE2B_MAX_LEN * 8;\n<line144># else\n<line145>digest_length = algorithm_bits[cksum_algorithm];\n<line146># endif\n<line147>}\n<line148>digest_hex_bytes = digest_length / 4;\n<line149>#else\n<line150>digest_hex_bytes = DIGEST_HEX_BYTES;\n<line151>#endif\n<line152>#if HASH_ALGO_CKSUM\n<line153>switch (cksum_algorithm)\n<line154>{\n<line155>case bsd:\n<line156>case sysv:\n<line157>case crc:\n<line158>if (do_check && algorithm_specified)\n<line159>error (EXIT_FAILURE, 0,\n<line160>_("--check is not supported with --algorithm={bsd,sysv,crc}"));\n<line161>break;\n<line162>default:\n<line163>break;\n<line164>}\n<line165>if (base64_digest && raw_digest)\n<line166>{\n<line167>error (0, 0, _("--base64 and --raw are mutually exclusive"));\n<line168>usage (EXIT_FAILURE);\n<line169>}\n<line170>#endif\n<line171>if (prefix_tag && !binary)\n<line172>{\n<line173>/* This could be supported in a backwards compatible way\n<line174>by prefixing the output line with a space in text mode.\n<line175>However that's invasive enough that it was agreed to\n<line176>not support this mode with --tag, as --text use cases\n<line177>are adequately supported by the default output format.  */\n<line178>#if !HASH_ALGO_CKSUM\n<line179>error (0, 0, _("--tag does not support --text mode"));\n<line180>#else\n<line181>error (0, 0, _("--text mode is only supported with --untagged"));\n<line182>#endif\n<line183>usage (EXIT_FAILURE);\n<line184>}\n<line185>if (digest_delim != '\n' && do_check)\n<line186>{\n<line187>error (0, 0, _("the --zero option is not supported when "\n<line188>"verifying checksums"));\n<line189>usage (EXIT_FAILURE);\n<line190>}\n<line191>#if !HASH_ALGO_CKSUM\n<line192>if (prefix_tag && do_check)\n<line193>{\n<line194>error (0, 0, _("the --tag option is meaningless when "\n<line195>"verifying checksums"));\n<line196>usage (EXIT_FAILURE);\n<line197>}\n<line198>#endif\n<line199>if (0 <= binary && do_check)\n<line200>{\n<line201>error (0, 0, _("the --binary and --text options are meaningless when "\n<line202>"verifying checksums"));\n<line203>usage (EXIT_FAILURE);\n<line204>}\n<line205>if (ignore_missing && !do_check)\n<line206>{\n<line207>error (0, 0,\n<line208>_("the --ignore-missing option is meaningful only when "\n<line209>"verifying checksums"));\n<line210>usage (EXIT_FAILURE);\n<line211>}\n<line212>if (status_only && !do_check)\n<line213>{\n<line214>error (0, 0,\n<line215>_("the --status option is meaningful only when verifying checksums"));\n<line216>usage (EXIT_FAILURE);\n<line217>}\n<line218>if (warn && !do_check)\n<line219>{\n<line220>error (0, 0,\n<line221>_("the --warn option is meaningful only when verifying checksums"));\n<line222>usage (EXIT_FAILURE);\n<line223>}\n<line224>if (quiet && !do_check)\n<line225>{\n<line226>error (0, 0,\n<line227>_("the --quiet option is meaningful only when verifying checksums"));\n<line228>usage (EXIT_FAILURE);\n<line229>}\n<line230>if (strict & !do_check)\n<line231>{\n<line232>error (0, 0,\n<line233>_("the --strict option is meaningful only when verifying checksums"));\n<line234>usage (EXIT_FAILURE);\n<line235>}\n<line236>if (!O_BINARY && binary < 0)\n<line237>binary = 0;\n<line238>char **operand_lim = argv + argc;\n<line239>if (optind == argc)\n<line240>*operand_lim++ = bad_cast ("-");\n<line241>else if (1 < argc - optind && raw_digest)\n<line242>error (EXIT_FAILURE, 0,\n<line243>_("the --raw option is not supported with multiple files"));\n<line244>for (char **operandp = argv + optind; operandp < operand_lim; operandp++)\n<line245>{\n<line246>char *file = *operandp;\n<line247>if (do_check)\n<line248>ok &= digest_check (file);\n<line249>else\n<line250>{\n<line251>int binary_file = binary;\n<line252>bool missing;\n<line253>uintmax_t length;\n<line254>if (! digest_file (file, &binary_file, bin_buffer, &missing, &length))\n<line255>ok = false;\n<line256>else\n<line257>{\n<line258>DIGEST_OUT (file, binary_file, bin_buffer, raw_digest, prefix_tag,\n<line259>digest_delim, optind != argc, length);\n<line260>}\n<line261>}\n<line262>}\n<line263>if (have_read_stdin && fclose (stdin) == EOF)\n<line264>error (EXIT_FAILURE, errno, _("standard input"));\n<line265>return ok ? EXIT_SUCCESS : EXIT_FAILURE;\n<line266>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/src/blake2/blake2b-ref.c
========================================
Function: blake2b_set_lastnode
Content: <line0>static void blake2b_set_lastnode( blake2b_state *S )\n<line1>{\n<line2>S->f[1] = (uint64_t)-1;\n<line3>}
----------------------------------------
Function: blake2b_is_lastblock
Content: <line0>static int blake2b_is_lastblock( const blake2b_state *S )\n<line1>{\n<line2>return S->f[0] != 0;\n<line3>}
----------------------------------------
Function: blake2b_set_lastblock
Content: <line0>static void blake2b_set_lastblock( blake2b_state *S )\n<line1>{\n<line2>if( S->last_node ) blake2b_set_lastnode( S );\n<line3>S->f[0] = (uint64_t)-1;\n<line4>}
----------------------------------------
Function: blake2b_increment_counter
Content: <line0>static void blake2b_increment_counter( blake2b_state *S, const uint64_t inc )\n<line1>{\n<line2>S->t[0] += inc;\n<line3>S->t[1] += ( S->t[0] < inc );\n<line4>}
----------------------------------------
Function: blake2b_init0
Content: <line0>static void blake2b_init0( blake2b_state *S )\n<line1>{\n<line2>size_t i;\n<line3>memset( S, 0, sizeof( blake2b_state ) );\n<line4>for( i = 0; i < 8; ++i ) S->h[i] = blake2b_IV[i];\n<line5>}
----------------------------------------
Function: blake2b_init_param
Content: <line0>int blake2b_init_param( blake2b_state *S, const blake2b_param *P )\n<line1>{\n<line2>const uint8_t *p = ( const uint8_t * )( P );\n<line3>size_t i;\n<line4>blake2b_init0( S );\n<line5>/* IV XOR ParamBlock */\n<line6>for( i = 0; i < 8; ++i )\n<line7>S->h[i] ^= load64( p + sizeof( S->h[i] ) * i );\n<line8>S->outlen = P->digest_length;\n<line9>return 0;\n<line10>}
----------------------------------------
Function: blake2b_init
Content: <line0>int blake2b_init( blake2b_state *S, size_t outlen )\n<line1>{\n<line2>blake2b_param P[1];\n<line3>if ( ( !outlen ) || ( outlen > BLAKE2B_OUTBYTES ) ) return -1;\n<line4>P->digest_length = (uint8_t)outlen;\n<line5>P->key_length    = 0;\n<line6>P->fanout        = 1;\n<line7>P->depth         = 1;\n<line8>store32( &P->leaf_length, 0 );\n<line9>store32( &P->node_offset, 0 );\n<line10>store32( &P->xof_length, 0 );\n<line11>P->node_depth    = 0;\n<line12>P->inner_length  = 0;\n<line13>memset( P->reserved, 0, sizeof( P->reserved ) );\n<line14>memset( P->salt,     0, sizeof( P->salt ) );\n<line15>memset( P->personal, 0, sizeof( P->personal ) );\n<line16>return blake2b_init_param( S, P );\n<line17>}
----------------------------------------
Function: blake2b_init_key
Content: <line0>int blake2b_init_key( blake2b_state *S, size_t outlen, const void *key, size_t keylen )\n<line1>{\n<line2>blake2b_param P[1];\n<line3>if ( ( !outlen ) || ( outlen > BLAKE2B_OUTBYTES ) ) return -1;\n<line4>if ( !key || !keylen || keylen > BLAKE2B_KEYBYTES ) return -1;\n<line5>P->digest_length = (uint8_t)outlen;\n<line6>P->key_length    = (uint8_t)keylen;\n<line7>P->fanout        = 1;\n<line8>P->depth         = 1;\n<line9>store32( &P->leaf_length, 0 );\n<line10>store32( &P->node_offset, 0 );\n<line11>store32( &P->xof_length, 0 );\n<line12>P->node_depth    = 0;\n<line13>P->inner_length  = 0;\n<line14>memset( P->reserved, 0, sizeof( P->reserved ) );\n<line15>memset( P->salt,     0, sizeof( P->salt ) );\n<line16>memset( P->personal, 0, sizeof( P->personal ) );\n<line17>if( blake2b_init_param( S, P ) < 0 ) return -1;\n<line18>{\n<line19>uint8_t block[BLAKE2B_BLOCKBYTES];\n<line20>memset( block, 0, BLAKE2B_BLOCKBYTES );\n<line21>memcpy( block, key, keylen );\n<line22>blake2b_update( S, block, BLAKE2B_BLOCKBYTES );\n<line23>secure_zero_memory( block, BLAKE2B_BLOCKBYTES ); /* Burn the key from stack */\n<line24>}\n<line25>return 0;\n<line26>}
----------------------------------------
Function: blake2b_compress
Content: <line0>static void blake2b_compress( blake2b_state *S, const uint8_t block[BLAKE2B_BLOCKBYTES] )\n<line1>{\n<line2>uint64_t m[16];\n<line3>uint64_t v[16];\n<line4>size_t i;\n<line5>for( i = 0; i < 16; ++i ) {\n<line6>m[i] = load64( block + i * sizeof( m[i] ) );\n<line7>}\n<line8>for( i = 0; i < 8; ++i ) {\n<line9>v[i] = S->h[i];\n<line10>}\n<line11>v[ 8] = blake2b_IV[0];\n<line12>v[ 9] = blake2b_IV[1];\n<line13>v[10] = blake2b_IV[2];\n<line14>v[11] = blake2b_IV[3];\n<line15>v[12] = blake2b_IV[4] ^ S->t[0];\n<line16>v[13] = blake2b_IV[5] ^ S->t[1];\n<line17>v[14] = blake2b_IV[6] ^ S->f[0];\n<line18>v[15] = blake2b_IV[7] ^ S->f[1];\n<line19>ROUND( 0 );\n<line20>ROUND( 1 );\n<line21>ROUND( 2 );\n<line22>ROUND( 3 );\n<line23>ROUND( 4 );\n<line24>ROUND( 5 );\n<line25>ROUND( 6 );\n<line26>ROUND( 7 );\n<line27>ROUND( 8 );\n<line28>ROUND( 9 );\n<line29>ROUND( 10 );\n<line30>ROUND( 11 );\n<line31>for( i = 0; i < 8; ++i ) {\n<line32>S->h[i] = S->h[i] ^ v[i] ^ v[i + 8];\n<line33>}\n<line34>}
----------------------------------------
Function: blake2b_update
Content: <line0>int blake2b_update( blake2b_state *S, const void *pin, size_t inlen )\n<line1>{\n<line2>const unsigned char * in = (const unsigned char *)pin;\n<line3>if( inlen > 0 )\n<line4>{\n<line5>size_t left = S->buflen;\n<line6>size_t fill = BLAKE2B_BLOCKBYTES - left;\n<line7>if( inlen > fill )\n<line8>{\n<line9>S->buflen = 0;\n<line10>memcpy( S->buf + left, in, fill ); /* Fill buffer */\n<line11>blake2b_increment_counter( S, BLAKE2B_BLOCKBYTES );\n<line12>blake2b_compress( S, S->buf ); /* Compress */\n<line13>in += fill; inlen -= fill;\n<line14>while(inlen > BLAKE2B_BLOCKBYTES) {\n<line15>blake2b_increment_counter(S, BLAKE2B_BLOCKBYTES);\n<line16>blake2b_compress( S, in );\n<line17>in += BLAKE2B_BLOCKBYTES;\n<line18>inlen -= BLAKE2B_BLOCKBYTES;\n<line19>}\n<line20>}\n<line21>memcpy( S->buf + S->buflen, in, inlen );\n<line22>S->buflen += inlen;\n<line23>}\n<line24>return 0;\n<line25>}
----------------------------------------
Function: blake2b_final
Content: <line0>int blake2b_final( blake2b_state *S, void *out, size_t outlen )\n<line1>{\n<line2>uint8_t buffer[BLAKE2B_OUTBYTES] = {0};\n<line3>size_t i;\n<line4>if( out == NULL || outlen < S->outlen )\n<line5>return -1;\n<line6>if( blake2b_is_lastblock( S ) )\n<line7>return -1;\n<line8>blake2b_increment_counter( S, S->buflen );\n<line9>blake2b_set_lastblock( S );\n<line10>memset( S->buf + S->buflen, 0, BLAKE2B_BLOCKBYTES - S->buflen ); /* Padding */\n<line11>blake2b_compress( S, S->buf );\n<line12>for( i = 0; i < 8; ++i ) /* Output full hash to temp buffer */\n<line13>store64( buffer + sizeof( S->h[i] ) * i, S->h[i] );\n<line14>memcpy( out, buffer, S->outlen );\n<line15>secure_zero_memory(buffer, sizeof(buffer));\n<line16>return 0;\n<line17>}
----------------------------------------
Function: blake2b
Content: <line0>int blake2b( void *out, size_t outlen, const void *in, size_t inlen, const void *key, size_t keylen )\n<line1>{\n<line2>blake2b_state S[1];\n<line3>/* Verify parameters */\n<line4>if ( NULL == in && inlen > 0 ) return -1;\n<line5>if ( NULL == out ) return -1;\n<line6>if( NULL == key && keylen > 0 ) return -1;\n<line7>if( !outlen || outlen > BLAKE2B_OUTBYTES ) return -1;\n<line8>if( keylen > BLAKE2B_KEYBYTES ) return -1;\n<line9>if( keylen > 0 )\n<line10>{\n<line11>if( blake2b_init_key( S, outlen, key, keylen ) < 0 ) return -1;\n<line12>}\n<line13>else\n<line14>{\n<line15>if( blake2b_init( S, outlen ) < 0 ) return -1;\n<line16>}\n<line17>blake2b_update( S, ( const uint8_t * )in, inlen );\n<line18>blake2b_final( S, out, outlen );\n<line19>return 0;\n<line20>}
----------------------------------------
Function: blake2
Content: <line0>int blake2( void *out, size_t outlen, const void *in, size_t inlen, const void *key, size_t keylen ) {\n<line1>return blake2b(out, outlen, in, inlen, key, keylen);\n<line2>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/src/blake2/b2sum.c
========================================
Function: blake2b_stream
Content: <line0>int blake2b_stream( FILE *stream, void *resstream, size_t outbytes )\n<line1>{\n<line2>int ret = -1;\n<line3>size_t sum, n;\n<line4>blake2b_state S[1];\n<line5>static const size_t buffer_length = 32768;\n<line6>uint8_t *buffer = ( uint8_t * )malloc( buffer_length );\n<line7>if( !buffer ) return -1;\n<line8>blake2b_init( S, outbytes );\n<line9>while( 1 )\n<line10>{\n<line11>sum = 0;\n<line12>while( 1 )\n<line13>{\n<line14>n = fread( buffer + sum, 1, buffer_length - sum, stream );\n<line15>sum += n;\n<line16>if( buffer_length == sum )\n<line17>break;\n<line18>if( 0 == n )\n<line19>{\n<line20>if( ferror( stream ) )\n<line21>goto cleanup_buffer;\n<line22>goto final_process;\n<line23>}\n<line24>if( feof( stream ) )\n<line25>goto final_process;\n<line26>}\n<line27>blake2b_update( S, buffer, buffer_length );\n<line28>}\n<line29>final_process:;\n<line30>if( sum > 0 ) blake2b_update( S, buffer, sum );\n<line31>blake2b_final( S, resstream, outbytes );\n<line32>ret = 0;\n<line33>cleanup_buffer:\n<line34>free( buffer );\n<line35>return ret;\n<line36>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/src/sum.c
========================================
Function: bsd_sum_stream
Content: <line0>int\n<line1>bsd_sum_stream (FILE *stream, void *resstream, uintmax_t *length)\n<line2>{\n<line3>int ret = -1;\n<line4>size_t sum, n;\n<line5>int checksum = 0;	/* The checksum mod 2^16. */\n<line6>uintmax_t total_bytes = 0;	/* The number of bytes. */\n<line7>static const size_t buffer_length = 32768;\n<line8>uint8_t *buffer = malloc (buffer_length);\n<line9>if (! buffer)\n<line10>return -1;\n<line11>/* Process file */\n<line12>while (true)\n<line13>{\n<line14>sum = 0;\n<line15>/* Read block */\n<line16>while (true)\n<line17>{\n<line18>n = fread (buffer + sum, 1, buffer_length - sum, stream);\n<line19>sum += n;\n<line20>if (buffer_length == sum)\n<line21>break;\n<line22>if (n == 0)\n<line23>{\n<line24>if (ferror (stream))\n<line25>goto cleanup_buffer;\n<line26>goto final_process;\n<line27>}\n<line28>if (feof (stream))\n<line29>goto final_process;\n<line30>}\n<line31>for (size_t i = 0; i < sum; i++)\n<line32>{\n<line33>checksum = (checksum >> 1) + ((checksum & 1) << 15);\n<line34>checksum += buffer[i];\n<line35>checksum &= 0xffff;	/* Keep it within bounds. */\n<line36>}\n<line37>if (total_bytes + sum < total_bytes)\n<line38>{\n<line39>errno = EOVERFLOW;\n<line40>goto cleanup_buffer;\n<line41>}\n<line42>total_bytes += sum;\n<line43>}\n<line44>final_process:;\n<line45>for (size_t i = 0; i < sum; i++)\n<line46>{\n<line47>checksum = (checksum >> 1) + ((checksum & 1) << 15);\n<line48>checksum += buffer[i];\n<line49>checksum &= 0xffff;	/* Keep it within bounds. */\n<line50>}\n<line51>if (total_bytes + sum < total_bytes)\n<line52>{\n<line53>errno = EOVERFLOW;\n<line54>goto cleanup_buffer;\n<line55>}\n<line56>total_bytes += sum;\n<line57>memcpy (resstream, &checksum, sizeof checksum);\n<line58>*length = total_bytes;\n<line59>ret = 0;\n<line60>cleanup_buffer:\n<line61>free (buffer);\n<line62>return ret;\n<line63>}
----------------------------------------
Function: sysv_sum_stream
Content: <line0>int\n<line1>sysv_sum_stream (FILE *stream, void *resstream, uintmax_t *length)\n<line2>{\n<line3>int ret = -1;\n<line4>size_t sum, n;\n<line5>uintmax_t total_bytes = 0;\n<line6>static const size_t buffer_length = 32768;\n<line7>uint8_t *buffer = malloc (buffer_length);\n<line8>if (! buffer)\n<line9>return -1;\n<line10>/* The sum of all the input bytes, modulo (UINT_MAX + 1).  */\n<line11>unsigned int s = 0;\n<line12>/* Process file */\n<line13>while (true)\n<line14>{\n<line15>sum = 0;\n<line16>/* Read block */\n<line17>while (true)\n<line18>{\n<line19>n = fread (buffer + sum, 1, buffer_length - sum, stream);\n<line20>sum += n;\n<line21>if (buffer_length == sum)\n<line22>break;\n<line23>if (n == 0)\n<line24>{\n<line25>if (ferror (stream))\n<line26>goto cleanup_buffer;\n<line27>goto final_process;\n<line28>}\n<line29>if (feof (stream))\n<line30>goto final_process;\n<line31>}\n<line32>for (size_t i = 0; i < sum; i++)\n<line33>s += buffer[i];\n<line34>if (total_bytes + sum < total_bytes)\n<line35>{\n<line36>errno = EOVERFLOW;\n<line37>goto cleanup_buffer;\n<line38>}\n<line39>total_bytes += sum;\n<line40>}\n<line41>final_process:;\n<line42>for (size_t i = 0; i < sum; i++)\n<line43>s += buffer[i];\n<line44>if (total_bytes + sum < total_bytes)\n<line45>{\n<line46>errno = EOVERFLOW;\n<line47>goto cleanup_buffer;\n<line48>}\n<line49>total_bytes += sum;\n<line50>int r = (s & 0xffff) + ((s & 0xffffffff) >> 16);\n<line51>int checksum = (r & 0xffff) + (r >> 16);\n<line52>memcpy (resstream, &checksum, sizeof checksum);\n<line53>*length = total_bytes;\n<line54>ret = 0;\n<line55>cleanup_buffer:\n<line56>free (buffer);\n<line57>return ret;\n<line58>}
----------------------------------------
Function: output_bsd
Content: <line0>void\n<line1>output_bsd (char const *file, int binary_file, void const *digest,\n<line2>bool raw, bool tagged, unsigned char delim, bool args,\n<line3>uintmax_t length)\n<line4>{\n<line5>if (raw)\n<line6>{\n<line7>/* Output in network byte order (big endian).  */\n<line8>uint16_t out_int = *(int *)digest;\n<line9>out_int = SWAP (out_int);\n<line10>fwrite (&out_int, 1, 16/8, stdout);\n<line11>return;\n<line12>}\n<line13>char hbuf[LONGEST_HUMAN_READABLE + 1];\n<line14>printf ("%05d %5s", *(int *)digest,\n<line15>human_readable (length, hbuf, human_ceiling, 1, 1024));\n<line16>if (args)\n<line17>printf (" %s", file);\n<line18>putchar (delim);\n<line19>}
----------------------------------------
Function: output_sysv
Content: <line0>void\n<line1>output_sysv (char const *file, int binary_file, void const *digest,\n<line2>bool raw, bool tagged, unsigned char delim, bool args,\n<line3>uintmax_t length)\n<line4>{\n<line5>if (raw)\n<line6>{\n<line7>/* Output in network byte order (big endian).  */\n<line8>uint16_t out_int = *(int *)digest;\n<line9>out_int = SWAP (out_int);\n<line10>fwrite (&out_int, 1, 16/8, stdout);\n<line11>return;\n<line12>}\n<line13>char hbuf[LONGEST_HUMAN_READABLE + 1];\n<line14>printf ("%d %s", *(int *)digest,\n<line15>human_readable (length, hbuf, human_ceiling, 1, 512));\n<line16>if (args)\n<line17>printf (" %s", file);\n<line18>putchar (delim);\n<line19>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/src/cksum.c
========================================
Function: pclmul_supported
Content: <line0>static bool\n<line1>pclmul_supported (void)\n<line2>{\n<line3>bool pclmul_enabled = (0 < __builtin_cpu_supports ("pclmul")\n<line4>&& 0 < __builtin_cpu_supports ("avx"));\n<line5>if (cksum_debug)\n<line6>error (0, 0, "%s",\n<line7>(pclmul_enabled\n<line8>? _("using pclmul hardware support")\n<line9>: _("pclmul support not detected")));\n<line10>return pclmul_enabled;\n<line11>}
----------------------------------------
Function: cksum_slice8
Content: <line0>static bool\n<line1>cksum_slice8 (FILE *fp, uint_fast32_t *crc_out, uintmax_t *length_out)\n<line2>{\n<line3>uint32_t buf[BUFLEN / sizeof (uint32_t)];\n<line4>uint_fast32_t crc = 0;\n<line5>uintmax_t length = 0;\n<line6>size_t bytes_read;\n<line7>if (!fp || !crc_out || !length_out)\n<line8>return false;\n<line9>while ((bytes_read = fread (buf, 1, BUFLEN, fp)) > 0)\n<line10>{\n<line11>uint32_t *datap;\n<line12>if (length + bytes_read < length)\n<line13>{\n<line14>errno = EOVERFLOW;\n<line15>return false;\n<line16>}\n<line17>length += bytes_read;\n<line18>/* Process multiples of 8 bytes */\n<line19>datap = (uint32_t *)buf;\n<line20>while (bytes_read >= 8)\n<line21>{\n<line22>uint32_t first = *datap++, second = *datap++;\n<line23>crc ^= SWAP (first);\n<line24>second = SWAP (second);\n<line25>crc = (crctab[7][(crc >> 24) & 0xFF]\n<line26>^ crctab[6][(crc >> 16) & 0xFF]\n<line27>^ crctab[5][(crc >> 8) & 0xFF]\n<line28>^ crctab[4][(crc) & 0xFF]\n<line29>^ crctab[3][(second >> 24) & 0xFF]\n<line30>^ crctab[2][(second >> 16) & 0xFF]\n<line31>^ crctab[1][(second >> 8) & 0xFF]\n<line32>^ crctab[0][(second) & 0xFF]);\n<line33>bytes_read -= 8;\n<line34>}\n<line35>/* And finish up last 0-7 bytes in a byte by byte fashion */\n<line36>unsigned char *cp = (unsigned char *)datap;\n<line37>while (bytes_read--)\n<line38>crc = (crc << 8) ^ crctab[0][((crc >> 24) ^ *cp++) & 0xFF];\n<line39>if (feof (fp))\n<line40>break;\n<line41>}\n<line42>*crc_out = crc;\n<line43>*length_out = length;\n<line44>return !ferror (fp);\n<line45>}
----------------------------------------
Function: crc_sum_stream
Content: <line0>int\n<line1>crc_sum_stream (FILE *stream, void *resstream, uintmax_t *length)\n<line2>{\n<line3>uintmax_t total_bytes = 0;\n<line4>uint_fast32_t crc = 0;\n<line5># if USE_PCLMUL_CRC32\n<line6>static bool (*cksum_fp) (FILE *, uint_fast32_t *, uintmax_t *);\n<line7>if (! cksum_fp)\n<line8>cksum_fp = pclmul_supported () ? cksum_pclmul : cksum_slice8;\n<line9># else\n<line10>bool (*cksum_fp) (FILE *, uint_fast32_t *, uintmax_t *) = cksum_slice8;\n<line11># endif\n<line12>if (! cksum_fp (stream, &crc, &total_bytes))\n<line13>return -1;\n<line14>*length = total_bytes;\n<line15>for (; total_bytes; total_bytes >>= 8)\n<line16>crc = (crc << 8) ^ crctab[0][((crc >> 24) ^ total_bytes) & 0xFF];\n<line17>crc = ~crc & 0xFFFFFFFF;\n<line18>unsigned int crc_out = crc;\n<line19>memcpy (resstream, &crc_out, sizeof crc_out);\n<line20>return 0;\n<line21>}
----------------------------------------
Function: output_crc
Content: <line0>void\n<line1>output_crc (char const *file, int binary_file, void const *digest, bool raw,\n<line2>bool tagged, unsigned char delim, bool args, uintmax_t length)\n<line3>{\n<line4>if (raw)\n<line5>{\n<line6>/* Output in network byte order (big endian).  */\n<line7>uint32_t out_int = SWAP (*(uint32_t *)digest);\n<line8>fwrite (&out_int, 1, 32/8, stdout);\n<line9>return;\n<line10>}\n<line11>char length_buf[INT_BUFSIZE_BOUND (uintmax_t)];\n<line12>printf ("%u %s", *(unsigned int *)digest, umaxtostr (length, length_buf));\n<line13>if (args)\n<line14>printf (" %s", file);\n<line15>putchar (delim);\n<line16>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/src/crctab.c
========================================
========================================
/home/huihui/Downloads/coreutils-9.4/src/cksum_pclmul.c
========================================
========================================
/home/huihui/Downloads/coreutils-9.4/src/comm.c
========================================
Function: usage
Content: <line0>void\n<line1>usage (int status)\n<line2>{\n<line3>if (status != EXIT_SUCCESS)\n<line4>emit_try_help ();\n<line5>else\n<line6>{\n<line7>printf (_("\\n<line8>Usage: %s [OPTION]... FILE1 FILE2\n\\n<line9>"),\n<line10>program_name);\n<line11>fputs (_("\\n<line12>Compare sorted files FILE1 and FILE2 line by line.\n\\n<line13>"), stdout);\n<line14>fputs (_("\\n<line15>\n\\n<line16>When FILE1 or FILE2 (not both) is -, read standard input.\n\\n<line17>"), stdout);\n<line18>fputs (_("\\n<line19>\n\\n<line20>With no options, produce three-column output.  Column one contains\n\\n<line21>lines unique to FILE1, column two contains lines unique to FILE2,\n\\n<line22>and column three contains lines common to both files.\n\\n<line23>"), stdout);\n<line24>fputs (_("\\n<line25>\n\\n<line26>-1                      suppress column 1 (lines unique to FILE1)\n\\n<line27>-2                      suppress column 2 (lines unique to FILE2)\n\\n<line28>-3                      suppress column 3 (lines that appear in both files)\n\\n<line29>"), stdout);\n<line30>fputs (_("\\n<line31>\n\\n<line32>--check-order       check that the input is correctly sorted, even\n\\n<line33>if all input lines are pairable\n\\n<line34>--nocheck-order     do not check that the input is correctly sorted\n\\n<line35>"), stdout);\n<line36>fputs (_("\\n<line37>--output-delimiter=STR  separate columns with STR\n\\n<line38>"), stdout);\n<line39>fputs (_("\\n<line40>--total             output a summary\n\\n<line41>"), stdout);\n<line42>fputs (_("\\n<line43>-z, --zero-terminated   line delimiter is NUL, not newline\n\\n<line44>"), stdout);\n<line45>fputs (HELP_OPTION_DESCRIPTION, stdout);\n<line46>fputs (VERSION_OPTION_DESCRIPTION, stdout);\n<line47>fputs (_("\\n<line48>\n\\n<line49>Note, comparisons honor the rules specified by 'LC_COLLATE'.\n\\n<line50>"), stdout);\n<line51>printf (_("\\n<line52>\n\\n<line53>Examples:\n\\n<line54>%s -12 file1 file2  Print only lines present in both file1 and file2.\n\\n<line55>%s -3 file1 file2  Print lines in file1 not in file2, and vice versa.\n\\n<line56>"),\n<line57>program_name, program_name);\n<line58>emit_ancillary_info (PROGRAM_NAME);\n<line59>}\n<line60>exit (status);\n<line61>}
----------------------------------------
Function: writeline
Content: <line0>static void\n<line1>writeline (struct linebuffer const *line, int class)\n<line2>{\n<line3>switch (class)\n<line4>{\n<line5>case 1:\n<line6>if (!only_file_1)\n<line7>return;\n<line8>break;\n<line9>case 2:\n<line10>if (!only_file_2)\n<line11>return;\n<line12>if (only_file_1)\n<line13>fwrite (col_sep, 1, col_sep_len, stdout);\n<line14>break;\n<line15>case 3:\n<line16>if (!both)\n<line17>return;\n<line18>if (only_file_1)\n<line19>fwrite (col_sep, 1, col_sep_len, stdout);\n<line20>if (only_file_2)\n<line21>fwrite (col_sep, 1, col_sep_len, stdout);\n<line22>break;\n<line23>}\n<line24>fwrite (line->buffer, sizeof (char), line->length, stdout);\n<line25>if (ferror (stdout))\n<line26>write_error ();\n<line27>}
----------------------------------------
Function: check_order
Content: <line0>static void\n<line1>check_order (struct linebuffer const *prev,\n<line2>struct linebuffer const *current,\n<line3>int whatfile)\n<line4>{\n<line5>if (check_input_order != CHECK_ORDER_DISABLED\n<line6>&& ((check_input_order == CHECK_ORDER_ENABLED) || seen_unpairable))\n<line7>{\n<line8>if (!issued_disorder_warning[whatfile - 1])\n<line9>{\n<line10>int order;\n<line11>if (hard_LC_COLLATE)\n<line12>order = xmemcoll (prev->buffer, prev->length - 1,\n<line13>current->buffer, current->length - 1);\n<line14>else\n<line15>order = memcmp2 (prev->buffer, prev->length - 1,\n<line16>current->buffer, current->length - 1);\n<line17>if (0 < order)\n<line18>{\n<line19>error ((check_input_order == CHECK_ORDER_ENABLED\n<line20>? EXIT_FAILURE : 0),\n<line21>0, _("file %d is not in sorted order"), whatfile);\n<line22>/* If we get to here, the message was just a warning, but we\n<line23>want only to issue it once. */\n<line24>issued_disorder_warning[whatfile - 1] = true;\n<line25>}\n<line26>}\n<line27>}\n<line28>}
----------------------------------------
Function: compare_files
Content: <line0>static _Noreturn void\n<line1>compare_files (char **infiles)\n<line2>{\n<line3>/* For each file, we have four linebuffers in lba. */\n<line4>struct linebuffer lba[2][4];\n<line5>/* thisline[i] points to the linebuffer holding the next available line\n<line6>in file i, or is null if there are no lines left in that file.  */\n<line7>struct linebuffer *thisline[2];\n<line8>/* all_line[i][alt[i][0]] also points to the linebuffer holding the\n<line9>current line in file i. We keep two buffers of history around so we\n<line10>can look two lines back when we get to the end of a file. */\n<line11>struct linebuffer *all_line[2][4];\n<line12>/* This is used to rotate through the buffers for each input file. */\n<line13>int alt[2][3];\n<line14>/* streams[i] holds the input stream for file i.  */\n<line15>FILE *streams[2];\n<line16>/* Counters for the summary.  */\n<line17>uintmax_t total[] = {0, 0, 0};\n<line18>int i, j;\n<line19>/* Initialize the storage. */\n<line20>for (i = 0; i < 2; i++)\n<line21>{\n<line22>for (j = 0; j < 4; j++)\n<line23>{\n<line24>initbuffer (&lba[i][j]);\n<line25>all_line[i][j] = &lba[i][j];\n<line26>}\n<line27>alt[i][0] = 0;\n<line28>alt[i][1] = 0;\n<line29>alt[i][2] = 0;\n<line30>streams[i] = (STREQ (infiles[i], "-") ? stdin : fopen (infiles[i], "r"));\n<line31>if (!streams[i])\n<line32>error (EXIT_FAILURE, errno, "%s", quotef (infiles[i]));\n<line33>fadvise (streams[i], FADVISE_SEQUENTIAL);\n<line34>thisline[i] = readlinebuffer_delim (all_line[i][alt[i][0]], streams[i],\n<line35>delim);\n<line36>if (ferror (streams[i]))\n<line37>error (EXIT_FAILURE, errno, "%s", quotef (infiles[i]));\n<line38>}\n<line39>while (thisline[0] || thisline[1])\n<line40>{\n<line41>int order;\n<line42>bool fill_up[2] = { false, false };\n<line43>/* Compare the next available lines of the two files.  */\n<line44>if (!thisline[0])\n<line45>order = 1;\n<line46>else if (!thisline[1])\n<line47>order = -1;\n<line48>else\n<line49>{\n<line50>if (hard_LC_COLLATE)\n<line51>order = xmemcoll (thisline[0]->buffer, thisline[0]->length - 1,\n<line52>thisline[1]->buffer, thisline[1]->length - 1);\n<line53>else\n<line54>{\n<line55>size_t len = min (thisline[0]->length, thisline[1]->length) - 1;\n<line56>order = memcmp (thisline[0]->buffer, thisline[1]->buffer, len);\n<line57>if (order == 0)\n<line58>order = ((thisline[0]->length > thisline[1]->length)\n<line59>- (thisline[0]->length < thisline[1]->length));\n<line60>}\n<line61>}\n<line62>/* Output the line that is lesser. */\n<line63>if (order == 0)\n<line64>{\n<line65>/* Line is seen in both files.  */\n<line66>total[2]++;\n<line67>writeline (thisline[1], 3);\n<line68>}\n<line69>else\n<line70>{\n<line71>seen_unpairable = true;\n<line72>if (order <= 0)\n<line73>{\n<line74>/* Line is seen in file 1 only.  */\n<line75>total[0]++;\n<line76>writeline (thisline[0], 1);\n<line77>}\n<line78>else\n<line79>{\n<line80>/* Line is seen in file 2 only.  */\n<line81>total[1]++;\n<line82>writeline (thisline[1], 2);\n<line83>}\n<line84>}\n<line85>/* Step the file the line came from.\n<line86>If the files match, step both files.  */\n<line87>if (0 <= order)\n<line88>fill_up[1] = true;\n<line89>if (order <= 0)\n<line90>fill_up[0] = true;\n<line91>for (i = 0; i < 2; i++)\n<line92>if (fill_up[i])\n<line93>{\n<line94>/* Rotate the buffers for this file. */\n<line95>alt[i][2] = alt[i][1];\n<line96>alt[i][1] = alt[i][0];\n<line97>alt[i][0] = (alt[i][0] + 1) & 0x03;\n<line98>thisline[i] = readlinebuffer_delim (all_line[i][alt[i][0]],\n<line99>streams[i], delim);\n<line100>if (thisline[i])\n<line101>check_order (all_line[i][alt[i][1]], thisline[i], i + 1);\n<line102>/* If this is the end of the file we may need to re-check\n<line103>the order of the previous two lines, since we might have\n<line104>discovered an unpairable match since we checked before. */\n<line105>else if (all_line[i][alt[i][2]]->buffer)\n<line106>check_order (all_line[i][alt[i][2]],\n<line107>all_line[i][alt[i][1]], i + 1);\n<line108>if (ferror (streams[i]))\n<line109>error (EXIT_FAILURE, errno, "%s", quotef (infiles[i]));\n<line110>fill_up[i] = false;\n<line111>}\n<line112>}\n<line113>for (i = 0; i < 2; i++)\n<line114>if (fclose (streams[i]) != 0)\n<line115>error (EXIT_FAILURE, errno, "%s", quotef (infiles[i]));\n<line116>if (total_option)\n<line117>{\n<line118>/* Print the summary, minding the column and line delimiters.  */\n<line119>char buf1[INT_BUFSIZE_BOUND (uintmax_t)];\n<line120>char buf2[INT_BUFSIZE_BOUND (uintmax_t)];\n<line121>char buf3[INT_BUFSIZE_BOUND (uintmax_t)];\n<line122>if (col_sep_len == 1)\n<line123>{ /* Separate to handle NUL char.  */\n<line124>printf ("%s%c%s%c%s%c%s%c",\n<line125>umaxtostr (total[0], buf1), *col_sep,\n<line126>umaxtostr (total[1], buf2), *col_sep,\n<line127>umaxtostr (total[2], buf3), *col_sep,\n<line128>_("total"), delim);\n<line129>}\n<line130>else\n<line131>{\n<line132>printf ("%s%s%s%s%s%s%s%c",\n<line133>umaxtostr (total[0], buf1), col_sep,\n<line134>umaxtostr (total[1], buf2), col_sep,\n<line135>umaxtostr (total[2], buf3), col_sep,\n<line136>_("total"), delim);\n<line137>}\n<line138>}\n<line139>if (issued_disorder_warning[0] || issued_disorder_warning[1])\n<line140>error (EXIT_FAILURE, 0, _("input is not in sorted order"));\n<line141>/* Exit here to pacify gcc -fsanitizer=leak.  */\n<line142>exit (EXIT_SUCCESS);\n<line143>}
----------------------------------------
Function: main
Content: <line0>int\n<line1>main (int argc, char **argv)\n<line2>{\n<line3>int c;\n<line4>initialize_main (&argc, &argv);\n<line5>set_program_name (argv[0]);\n<line6>setlocale (LC_ALL, "");\n<line7>bindtextdomain (PACKAGE, LOCALEDIR);\n<line8>textdomain (PACKAGE);\n<line9>hard_LC_COLLATE = hard_locale (LC_COLLATE);\n<line10>atexit (close_stdout);\n<line11>only_file_1 = true;\n<line12>only_file_2 = true;\n<line13>both = true;\n<line14>seen_unpairable = false;\n<line15>issued_disorder_warning[0] = issued_disorder_warning[1] = false;\n<line16>check_input_order = CHECK_ORDER_DEFAULT;\n<line17>total_option = false;\n<line18>while ((c = getopt_long (argc, argv, "123z", long_options, nullptr)) != -1)\n<line19>switch (c)\n<line20>{\n<line21>case '1':\n<line22>only_file_1 = false;\n<line23>break;\n<line24>case '2':\n<line25>only_file_2 = false;\n<line26>break;\n<line27>case '3':\n<line28>both = false;\n<line29>break;\n<line30>case 'z':\n<line31>delim = '\0';\n<line32>break;\n<line33>case NOCHECK_ORDER_OPTION:\n<line34>check_input_order = CHECK_ORDER_DISABLED;\n<line35>break;\n<line36>case CHECK_ORDER_OPTION:\n<line37>check_input_order = CHECK_ORDER_ENABLED;\n<line38>break;\n<line39>case OUTPUT_DELIMITER_OPTION:\n<line40>if (col_sep_len && !STREQ (col_sep, optarg))\n<line41>error (EXIT_FAILURE, 0, _("multiple output delimiters specified"));\n<line42>col_sep = optarg;\n<line43>col_sep_len = *optarg ? strlen (optarg) : 1;\n<line44>break;\n<line45>case TOTAL_OPTION:\n<line46>total_option = true;\n<line47>break;\n<line48>case_GETOPT_HELP_CHAR;\n<line49>case_GETOPT_VERSION_CHAR (PROGRAM_NAME, AUTHORS);\n<line50>default:\n<line51>usage (EXIT_FAILURE);\n<line52>}\n<line53>if (! col_sep_len)\n<line54>col_sep_len = 1;\n<line55>if (argc - optind < 2)\n<line56>{\n<line57>if (argc <= optind)\n<line58>error (0, 0, _("missing operand"));\n<line59>else\n<line60>error (0, 0, _("missing operand after %s"), quote (argv[argc - 1]));\n<line61>usage (EXIT_FAILURE);\n<line62>}\n<line63>if (2 < argc - optind)\n<line64>{\n<line65>error (0, 0, _("extra operand %s"), quote (argv[optind + 2]));\n<line66>usage (EXIT_FAILURE);\n<line67>}\n<line68>compare_files (argv + optind);\n<line69>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/src/cp.c
========================================
/home/huihui/Downloads/coreutils-9.4/src/cp.c:92:1: warning: '_Static_assert' with no message is a C2x extension [-Wc2x-extensions]
ARGMATCH_VERIFY (sparse_type_string, sparse_type);
^
./lib/argmatch.h:49:54: note: expanded from macro 'ARGMATCH_VERIFY'
                   == ARRAY_CARDINALITY (Vallist) + 1)
                                                     ^
/home/huihui/Downloads/coreutils-9.4/src/cp.c:102:1: warning: '_Static_assert' with no message is a C2x extension [-Wc2x-extensions]
ARGMATCH_VERIFY (reflink_type_string, reflink_type);
^
./lib/argmatch.h:49:54: note: expanded from macro 'ARGMATCH_VERIFY'
                   == ARRAY_CARDINALITY (Vallist) + 1)
                                                     ^
/home/huihui/Downloads/coreutils-9.4/src/cp.c:112:1: warning: '_Static_assert' with no message is a C2x extension [-Wc2x-extensions]
ARGMATCH_VERIFY (update_type_string, update_type);
^
./lib/argmatch.h:49:54: note: expanded from macro 'ARGMATCH_VERIFY'
                   == ARRAY_CARDINALITY (Vallist) + 1)
                                                     ^
/home/huihui/Downloads/coreutils-9.4/src/cp.c:900:3: warning: '_Static_assert' with no message is a C2x extension [-Wc2x-extensions]
  ARGMATCH_VERIFY (preserve_args, preserve_vals);
  ^
./lib/argmatch.h:49:54: note: expanded from macro 'ARGMATCH_VERIFY'
                   == ARRAY_CARDINALITY (Vallist) + 1)
                                                     ^
4 warnings generated.
Function: usage
Content: <line0>void\n<line1>usage (int status)\n<line2>{\n<line3>if (status != EXIT_SUCCESS)\n<line4>emit_try_help ();\n<line5>else\n<line6>{\n<line7>printf (_("\\n<line8>Usage: %s [OPTION]... [-T] SOURCE DEST\n\\n<line9>or:  %s [OPTION]... SOURCE... DIRECTORY\n\\n<line10>or:  %s [OPTION]... -t DIRECTORY SOURCE...\n\\n<line11>"),\n<line12>program_name, program_name, program_name);\n<line13>fputs (_("\\n<line14>Copy SOURCE to DEST, or multiple SOURCE(s) to DIRECTORY.\n\\n<line15>"), stdout);\n<line16>emit_mandatory_arg_note ();\n<line17>fputs (_("\\n<line18>-a, --archive                same as -dR --preserve=all\n\\n<line19>--attributes-only        don't copy the file data, just the attributes\n\\n<line20>--backup[=CONTROL]       make a backup of each existing destination file\\n<line21>\n\\n<line22>-b                           like --backup but does not accept an argument\n\\n<line23>--copy-contents          copy contents of special files when recursive\n\\n<line24>-d                           same as --no-dereference --preserve=links\n\\n<line25>"), stdout);\n<line26>fputs (_("\\n<line27>--debug                  explain how a file is copied.  Implies -v\n\\n<line28>"), stdout);\n<line29>fputs (_("\\n<line30>-f, --force                  if an existing destination file cannot be\n\\n<line31>opened, remove it and try again (this option\n\\n<line32>is ignored when the -n option is also used)\n\\n<line33>-i, --interactive            prompt before overwrite (overrides a previous -n\\n<line34>\n\\n<line35>option)\n\\n<line36>-H                           follow command-line symbolic links in SOURCE\n\\n<line37>"), stdout);\n<line38>fputs (_("\\n<line39>-l, --link                   hard link files instead of copying\n\\n<line40>-L, --dereference            always follow symbolic links in SOURCE\n\\n<line41>"), stdout);\n<line42>fputs (_("\\n<line43>-n, --no-clobber             do not overwrite an existing file (overrides a\n\\n<line44>-u or previous -i option). See also --update\n\\n<line45>"), stdout);\n<line46>fputs (_("\\n<line47>-P, --no-dereference         never follow symbolic links in SOURCE\n\\n<line48>"), stdout);\n<line49>fputs (_("\\n<line50>-p                           same as --preserve=mode,ownership,timestamps\n\\n<line51>--preserve[=ATTR_LIST]   preserve the specified attributes\n\\n<line52>"), stdout);\n<line53>fputs (_("\\n<line54>--no-preserve=ATTR_LIST  don't preserve the specified attributes\n\\n<line55>--parents                use full source file name under DIRECTORY\n\\n<line56>"), stdout);\n<line57>fputs (_("\\n<line58>-R, -r, --recursive          copy directories recursively\n\\n<line59>--reflink[=WHEN]         control clone/CoW copies. See below\n\\n<line60>--remove-destination     remove each existing destination file before\n\\n<line61>attempting to open it (contrast with --force)\\n<line62>\n"), stdout);\n<line63>fputs (_("\\n<line64>--sparse=WHEN            control creation of sparse files. See below\n\\n<line65>--strip-trailing-slashes  remove any trailing slashes from each SOURCE\n\\n<line66>argument\n\\n<line67>"), stdout);\n<line68>fputs (_("\\n<line69>-s, --symbolic-link          make symbolic links instead of copying\n\\n<line70>-S, --suffix=SUFFIX          override the usual backup suffix\n\\n<line71>-t, --target-directory=DIRECTORY  copy all SOURCE arguments into DIRECTORY\n\\n<line72>-T, --no-target-directory    treat DEST as a normal file\n\\n<line73>"), stdout);\n<line74>fputs (_("\\n<line75>--update[=UPDATE]            control which existing files are updated;\n\\n<line76>UPDATE={all,none,older(default)}.  See below\n\\n<line77>-u                           equivalent to --update[=older]\n\\n<line78>"), stdout);\n<line79>fputs (_("\\n<line80>-v, --verbose                explain what is being done\n\\n<line81>"), stdout);\n<line82>fputs (_("\\n<line83>-x, --one-file-system        stay on this file system\n\\n<line84>"), stdout);\n<line85>fputs (_("\\n<line86>-Z                           set SELinux security context of destination\n\\n<line87>file to default type\n\\n<line88>--context[=CTX]          like -Z, or if CTX is specified then set the\n\\n<line89>SELinux or SMACK security context to CTX\n\\n<line90>"), stdout);\n<line91>fputs (HELP_OPTION_DESCRIPTION, stdout);\n<line92>fputs (VERSION_OPTION_DESCRIPTION, stdout);\n<line93>fputs (_("\\n<line94>\n\\n<line95>ATTR_LIST is a comma-separated list of attributes. Attributes are 'mode' for\n\\n<line96>permissions (including any ACL and xattr permissions), 'ownership' for user\n\\n<line97>and group, 'timestamps' for file timestamps, 'links' for hard links, 'context'\\n<line98>\nfor security context, 'xattr' for extended attributes, and 'all' for all\n\\n<line99>attributes.\n\\n<line100>"), stdout);\n<line101>fputs (_("\\n<line102>\n\\n<line103>By default, sparse SOURCE files are detected by a crude heuristic and the\n\\n<line104>corresponding DEST file is made sparse as well.  That is the behavior\n\\n<line105>selected by --sparse=auto.  Specify --sparse=always to create a sparse DEST\n\\n<line106>file whenever the SOURCE file contains a long enough sequence of zero bytes.\n\\n<line107>Use --sparse=never to inhibit creation of sparse files.\n\\n<line108>"), stdout);\n<line109>emit_update_parameters_note ();\n<line110>fputs (_("\\n<line111>\n\\n<line112>When --reflink[=always] is specified, perform a lightweight copy, where the\n\\n<line113>data blocks are copied only when modified.  If this is not possible the copy\n\\n<line114>fails, or if --reflink=auto is specified, fall back to a standard copy.\n\\n<line115>Use --reflink=never to ensure a standard copy is performed.\n\\n<line116>"), stdout);\n<line117>emit_backup_suffix_note ();\n<line118>fputs (_("\\n<line119>\n\\n<line120>As a special case, cp makes a backup of SOURCE when the force and backup\n\\n<line121>options are given and SOURCE and DEST are the same name for an existing,\n\\n<line122>regular file.\n\\n<line123>"), stdout);\n<line124>emit_ancillary_info (PROGRAM_NAME);\n<line125>}\n<line126>exit (status);\n<line127>}
----------------------------------------
Function: re_protect
Content: <line0>static bool\n<line1>re_protect (char const *const_dst_name, char const *dst_src_name,\n<line2>int dst_dirfd, char const *dst_relname,\n<line3>struct dir_attr *attr_list, const struct cp_options *x)\n<line4>{\n<line5>struct dir_attr *p;\n<line6>char *dst_name;		/* A copy of CONST_DST_NAME we can change. */\n<line7>ASSIGN_STRDUPA (dst_name, const_dst_name);\n<line8>/* The suffix of DST_NAME that is a copy of the source file name,\n<line9>possibly truncated to name a parent directory.  */\n<line10>char const *src_name = dst_name + (dst_src_name - const_dst_name);\n<line11>/* Likewise, but with any leading '/'s skipped.  */\n<line12>char const *relname = dst_name + (dst_relname - const_dst_name);\n<line13>for (p = attr_list; p; p = p->next)\n<line14>{\n<line15>dst_name[p->slash_offset] = '\0';\n<line16>/* Adjust the times (and if possible, ownership) for the copy.\n<line17>chown turns off set[ug]id bits for non-root,\n<line18>so do the chmod last.  */\n<line19>if (x->preserve_timestamps)\n<line20>{\n<line21>struct timespec timespec[2];\n<line22>timespec[0] = get_stat_atime (&p->st);\n<line23>timespec[1] = get_stat_mtime (&p->st);\n<line24>if (utimensat (dst_dirfd, relname, timespec, 0))\n<line25>{\n<line26>error (0, errno, _("failed to preserve times for %s"),\n<line27>quoteaf (dst_name));\n<line28>return false;\n<line29>}\n<line30>}\n<line31>if (x->preserve_ownership)\n<line32>{\n<line33>if (lchownat (dst_dirfd, relname, p->st.st_uid, p->st.st_gid)\n<line34>!= 0)\n<line35>{\n<line36>if (! chown_failure_ok (x))\n<line37>{\n<line38>error (0, errno, _("failed to preserve ownership for %s"),\n<line39>quoteaf (dst_name));\n<line40>return false;\n<line41>}\n<line42>/* Failing to preserve ownership is OK. Still, try to preserve\n<line43>the group, but ignore the possible error. */\n<line44>ignore_value (lchownat (dst_dirfd, relname, -1, p->st.st_gid));\n<line45>}\n<line46>}\n<line47>if (x->preserve_mode)\n<line48>{\n<line49>if (copy_acl (src_name, -1, dst_name, -1, p->st.st_mode) != 0)\n<line50>return false;\n<line51>}\n<line52>else if (p->restore_mode)\n<line53>{\n<line54>if (lchmodat (dst_dirfd, relname, p->st.st_mode) != 0)\n<line55>{\n<line56>error (0, errno, _("failed to preserve permissions for %s"),\n<line57>quoteaf (dst_name));\n<line58>return false;\n<line59>}\n<line60>}\n<line61>dst_name[p->slash_offset] = '/';\n<line62>}\n<line63>return true;\n<line64>}
----------------------------------------
Function: make_dir_parents_private
Content: <line0>static bool\n<line1>make_dir_parents_private (char const *const_dir, size_t src_offset,\n<line2>int dst_dirfd,\n<line3>char const *verbose_fmt_string,\n<line4>struct dir_attr **attr_list, bool *new_dst,\n<line5>const struct cp_options *x)\n<line6>{\n<line7>struct stat stats;\n<line8>char *dir;		/* A copy of CONST_DIR we can change.  */\n<line9>char *src;		/* Source name in DIR.  */\n<line10>char *dst_dir;	/* Leading directory of DIR.  */\n<line11>idx_t dirlen = dir_len (const_dir);\n<line12>*attr_list = nullptr;\n<line13>/* Succeed immediately if the parent of CONST_DIR must already exist,\n<line14>as the target directory has already been checked.  */\n<line15>if (dirlen <= src_offset)\n<line16>return true;\n<line17>ASSIGN_STRDUPA (dir, const_dir);\n<line18>src = dir + src_offset;\n<line19>dst_dir = alloca (dirlen + 1);\n<line20>memcpy (dst_dir, dir, dirlen);\n<line21>dst_dir[dirlen] = '\0';\n<line22>char const *dst_reldir = dst_dir + src_offset;\n<line23>while (*dst_reldir == '/')\n<line24>dst_reldir++;\n<line25>/* XXX: If all dirs are present at the destination,\n<line26>no permissions or security contexts will be updated.  */\n<line27>if (fstatat (dst_dirfd, dst_reldir, &stats, 0) != 0)\n<line28>{\n<line29>/* A parent of CONST_DIR does not exist.\n<line30>Make all missing intermediate directories. */\n<line31>char *slash;\n<line32>slash = src;\n<line33>while (*slash == '/')\n<line34>slash++;\n<line35>dst_reldir = slash;\n<line36>while ((slash = strchr (slash, '/')))\n<line37>{\n<line38>struct dir_attr *new;\n<line39>bool missing_dir;\n<line40>*slash = '\0';\n<line41>missing_dir = fstatat (dst_dirfd, dst_reldir, &stats, 0) != 0;\n<line42>if (missing_dir || x->preserve_ownership || x->preserve_mode\n<line43>|| x->preserve_timestamps)\n<line44>{\n<line45>/* Add this directory to the list of directories whose\n<line46>modes might need fixing later. */\n<line47>struct stat src_st;\n<line48>int src_errno = (stat (src, &src_st) != 0\n<line49>? errno\n<line50>: S_ISDIR (src_st.st_mode)\n<line51>? 0\n<line52>: ENOTDIR);\n<line53>if (src_errno)\n<line54>{\n<line55>error (0, src_errno, _("failed to get attributes of %s"),\n<line56>quoteaf (src));\n<line57>return false;\n<line58>}\n<line59>new = xmalloc (sizeof *new);\n<line60>new->st = src_st;\n<line61>new->slash_offset = slash - dir;\n<line62>new->restore_mode = false;\n<line63>new->next = *attr_list;\n<line64>*attr_list = new;\n<line65>}\n<line66>/* If required set the default context for created dirs.  */\n<line67>if (! set_process_security_ctx (src, dir,\n<line68>missing_dir ? new->st.st_mode : 0,\n<line69>missing_dir, x))\n<line70>return false;\n<line71>if (missing_dir)\n<line72>{\n<line73>mode_t src_mode;\n<line74>mode_t omitted_permissions;\n<line75>mode_t mkdir_mode;\n<line76>/* This component does not exist.  We must set\n<line77>*new_dst and new->st.st_mode inside this loop because,\n<line78>for example, in the command 'cp --parents ../a/../b/c e_dir',\n<line79>make_dir_parents_private creates only e_dir/../a if\n<line80>./b already exists. */\n<line81>*new_dst = true;\n<line82>src_mode = new->st.st_mode;\n<line83>/* If the ownership or special mode bits might change,\n<line84>omit some permissions at first, so unauthorized users\n<line85>cannot nip in before the file is ready.  */\n<line86>omitted_permissions = (src_mode\n<line87>& (x->preserve_ownership\n<line88>? S_IRWXG | S_IRWXO\n<line89>: x->preserve_mode\n<line90>? S_IWGRP | S_IWOTH\n<line91>: 0));\n<line92>/* POSIX says mkdir's behavior is implementation-defined when\n<line93>(src_mode & ~S_IRWXUGO) != 0.  However, common practice is\n<line94>to ask mkdir to copy all the CHMOD_MODE_BITS, letting mkdir\n<line95>decide what to do with S_ISUID | S_ISGID | S_ISVTX.  */\n<line96>mkdir_mode = x->explicit_no_preserve_mode ? S_IRWXUGO : src_mode;\n<line97>mkdir_mode &= CHMOD_MODE_BITS & ~omitted_permissions;\n<line98>if (mkdirat (dst_dirfd, dst_reldir, mkdir_mode) != 0)\n<line99>{\n<line100>error (0, errno, _("cannot make directory %s"),\n<line101>quoteaf (dir));\n<line102>return false;\n<line103>}\n<line104>else\n<line105>{\n<line106>if (verbose_fmt_string != nullptr)\n<line107>printf (verbose_fmt_string, src, dir);\n<line108>}\n<line109>/* We need search and write permissions to the new directory\n<line110>for writing the directory's contents. Check if these\n<line111>permissions are there.  */\n<line112>if (fstatat (dst_dirfd, dst_reldir, &stats, AT_SYMLINK_NOFOLLOW))\n<line113>{\n<line114>error (0, errno, _("failed to get attributes of %s"),\n<line115>quoteaf (dir));\n<line116>return false;\n<line117>}\n<line118>if (! x->preserve_mode)\n<line119>{\n<line120>if (omitted_permissions & ~stats.st_mode)\n<line121>omitted_permissions &= ~ cached_umask ();\n<line122>if (omitted_permissions & ~stats.st_mode\n<line123>|| (stats.st_mode & S_IRWXU) != S_IRWXU)\n<line124>{\n<line125>new->st.st_mode = stats.st_mode | omitted_permissions;\n<line126>new->restore_mode = true;\n<line127>}\n<line128>}\n<line129>mode_t accessible = stats.st_mode | S_IRWXU;\n<line130>if (stats.st_mode != accessible)\n<line131>{\n<line132>/* Make the new directory searchable and writable.\n<line133>The original permissions will be restored later.  */\n<line134>if (lchmodat (dst_dirfd, dst_reldir, accessible) != 0)\n<line135>{\n<line136>error (0, errno, _("setting permissions for %s"),\n<line137>quoteaf (dir));\n<line138>return false;\n<line139>}\n<line140>}\n<line141>}\n<line142>else if (!S_ISDIR (stats.st_mode))\n<line143>{\n<line144>error (0, 0, _("%s exists but is not a directory"),\n<line145>quoteaf (dir));\n<line146>return false;\n<line147>}\n<line148>else\n<line149>*new_dst = false;\n<line150>/* For existing dirs, set the security context as per that already\n<line151>set for the process global context.  */\n<line152>if (! *new_dst\n<line153>&& (x->set_security_context || x->preserve_security_context))\n<line154>{\n<line155>if (! set_file_security_ctx (dir, false, x)\n<line156>&& x->require_preserve_context)\n<line157>return false;\n<line158>}\n<line159>*slash++ = '/';\n<line160>/* Avoid unnecessary calls to 'stat' when given\n<line161>file names containing multiple adjacent slashes.  */\n<line162>while (*slash == '/')\n<line163>slash++;\n<line164>}\n<line165>}\n<line166>/* We get here if the parent of DIR already exists.  */\n<line167>else if (!S_ISDIR (stats.st_mode))\n<line168>{\n<line169>error (0, 0, _("%s exists but is not a directory"), quoteaf (dst_dir));\n<line170>return false;\n<line171>}\n<line172>else\n<line173>{\n<line174>*new_dst = false;\n<line175>}\n<line176>return true;\n<line177>}
----------------------------------------
Function: do_copy
Content: <line0>static bool\n<line1>do_copy (int n_files, char **file, char const *target_directory,\n<line2>bool no_target_directory, struct cp_options *x)\n<line3>{\n<line4>struct stat sb;\n<line5>bool new_dst = false;\n<line6>bool ok = true;\n<line7>if (n_files <= !target_directory)\n<line8>{\n<line9>if (n_files <= 0)\n<line10>error (0, 0, _("missing file operand"));\n<line11>else\n<line12>error (0, 0, _("missing destination file operand after %s"),\n<line13>quoteaf (file[0]));\n<line14>usage (EXIT_FAILURE);\n<line15>}\n<line16>sb.st_mode = 0;\n<line17>int target_dirfd = AT_FDCWD;\n<line18>if (no_target_directory)\n<line19>{\n<line20>if (target_directory)\n<line21>error (EXIT_FAILURE, 0,\n<line22>_("cannot combine --target-directory (-t) "\n<line23>"and --no-target-directory (-T)"));\n<line24>if (2 < n_files)\n<line25>{\n<line26>error (0, 0, _("extra operand %s"), quoteaf (file[2]));\n<line27>usage (EXIT_FAILURE);\n<line28>}\n<line29>}\n<line30>else if (target_directory)\n<line31>{\n<line32>target_dirfd = target_directory_operand (target_directory, &sb);\n<line33>if (! target_dirfd_valid (target_dirfd))\n<line34>error (EXIT_FAILURE, errno, _("target directory %s"),\n<line35>quoteaf (target_directory));\n<line36>}\n<line37>else\n<line38>{\n<line39>char const *lastfile = file[n_files - 1];\n<line40>int fd = target_directory_operand (lastfile, &sb);\n<line41>if (target_dirfd_valid (fd))\n<line42>{\n<line43>target_dirfd = fd;\n<line44>target_directory = lastfile;\n<line45>n_files--;\n<line46>}\n<line47>else\n<line48>{\n<line49>int err = errno;\n<line50>if (err == ENOENT)\n<line51>new_dst = true;\n<line52>/* The last operand LASTFILE cannot be opened as a directory.\n<line53>If there are more than two operands, report an error.\n<line54>Also, report an error if LASTFILE is known to be a directory\n<line55>even though it could not be opened, which can happen if\n<line56>opening failed with EACCES on a platform lacking O_PATH.\n<line57>In this case use stat to test whether LASTFILE is a\n<line58>directory, in case opening a non-directory with (O_SEARCH\n<line59>| O_DIRECTORY) failed with EACCES not ENOTDIR.  */\n<line60>if (2 < n_files\n<line61>|| (O_PATHSEARCH == O_SEARCH && err == EACCES\n<line62>&& (sb.st_mode || stat (lastfile, &sb) == 0)\n<line63>&& S_ISDIR (sb.st_mode)))\n<line64>error (EXIT_FAILURE, err, _("target %s"), quoteaf (lastfile));\n<line65>}\n<line66>}\n<line67>if (target_directory)\n<line68>{\n<line69>/* cp file1...filen edir\n<line70>Copy the files 'file1' through 'filen'\n<line71>to the existing directory 'edir'. */\n<line72>/* Initialize these hash tables only if we'll need them.\n<line73>The problems they're used to detect can arise only if\n<line74>there are two or more files to copy.  */\n<line75>if (2 <= n_files)\n<line76>{\n<line77>dest_info_init (x);\n<line78>src_info_init (x);\n<line79>}\n<line80>for (int i = 0; i < n_files; i++)\n<line81>{\n<line82>char *dst_name;\n<line83>bool parent_exists = true;  /* True if dir_name (dst_name) exists. */\n<line84>struct dir_attr *attr_list;\n<line85>char *arg_in_concat;\n<line86>char *arg = file[i];\n<line87>/* Trailing slashes are meaningful (i.e., maybe worth preserving)\n<line88>only in the source file names.  */\n<line89>if (remove_trailing_slashes)\n<line90>strip_trailing_slashes (arg);\n<line91>if (parents_option)\n<line92>{\n<line93>char *arg_no_trailing_slash;\n<line94>/* Use 'arg' without trailing slashes in constructing destination\n<line95>file names.  Otherwise, we can end up trying to create a\n<line96>directory using a name with trailing slash, which fails on\n<line97>NetBSD 1.[34] systems.  */\n<line98>ASSIGN_STRDUPA (arg_no_trailing_slash, arg);\n<line99>strip_trailing_slashes (arg_no_trailing_slash);\n<line100>/* Append all of 'arg' (minus any trailing slash) to 'dest'.  */\n<line101>dst_name = file_name_concat (target_directory,\n<line102>arg_no_trailing_slash,\n<line103>&arg_in_concat);\n<line104>/* For --parents, we have to make sure that the directory\n<line105>dir_name (dst_name) exists.  We may have to create a few\n<line106>leading directories. */\n<line107>parent_exists =\n<line108>(make_dir_parents_private\n<line109>(dst_name, arg_in_concat - dst_name, target_dirfd,\n<line110>(x->verbose ? "%s -> %s\n" : nullptr),\n<line111>&attr_list, &new_dst, x));\n<line112>}\n<line113>else\n<line114>{\n<line115>char *arg_base;\n<line116>/* Append the last component of 'arg' to 'target_directory'.  */\n<line117>ASSIGN_STRDUPA (arg_base, last_component (arg));\n<line118>strip_trailing_slashes (arg_base);\n<line119>/* For 'cp -R source/.. dest', don't copy into 'dest/..'. */\n<line120>arg_base += STREQ (arg_base, "..");\n<line121>dst_name = file_name_concat (target_directory, arg_base,\n<line122>&arg_in_concat);\n<line123>}\n<line124>if (!parent_exists)\n<line125>{\n<line126>/* make_dir_parents_private failed, so don't even\n<line127>attempt the copy.  */\n<line128>ok = false;\n<line129>}\n<line130>else\n<line131>{\n<line132>char const *dst_relname = arg_in_concat;\n<line133>while (*dst_relname == '/')\n<line134>dst_relname++;\n<line135>bool copy_into_self;\n<line136>ok &= copy (arg, dst_name, target_dirfd, dst_relname,\n<line137>new_dst, x, &copy_into_self, nullptr);\n<line138>if (parents_option)\n<line139>ok &= re_protect (dst_name, arg_in_concat, target_dirfd,\n<line140>dst_relname, attr_list, x);\n<line141>}\n<line142>if (parents_option)\n<line143>{\n<line144>while (attr_list)\n<line145>{\n<line146>struct dir_attr *p = attr_list;\n<line147>attr_list = attr_list->next;\n<line148>free (p);\n<line149>}\n<line150>}\n<line151>free (dst_name);\n<line152>}\n<line153>}\n<line154>else /* !target_directory */\n<line155>{\n<line156>char const *source = file[0];\n<line157>char const *dest = file[1];\n<line158>bool unused;\n<line159>if (parents_option)\n<line160>{\n<line161>error (0, 0,\n<line162>_("with --parents, the destination must be a directory"));\n<line163>usage (EXIT_FAILURE);\n<line164>}\n<line165>/* When the force and backup options have been specified and\n<line166>the source and destination are the same name for an existing\n<line167>regular file, convert the user's command, e.g.,\n<line168>'cp --force --backup foo foo' to 'cp --force foo fooSUFFIX'\n<line169>where SUFFIX is determined by any version control options used.  */\n<line170>if (x->unlink_dest_after_failed_open\n<line171>&& x->backup_type != no_backups\n<line172>&& STREQ (source, dest)\n<line173>&& !new_dst\n<line174>&& (sb.st_mode != 0 || stat (dest, &sb) == 0) && S_ISREG (sb.st_mode))\n<line175>{\n<line176>static struct cp_options x_tmp;\n<line177>dest = find_backup_file_name (AT_FDCWD, dest, x->backup_type);\n<line178>/* Set x->backup_type to 'no_backups' so that the normal backup\n<line179>mechanism is not used when performing the actual copy.\n<line180>backup_type must be set to 'no_backups' only *after* the above\n<line181>call to find_backup_file_name -- that function uses\n<line182>backup_type to determine the suffix it applies.  */\n<line183>x_tmp = *x;\n<line184>x_tmp.backup_type = no_backups;\n<line185>x = &x_tmp;\n<line186>}\n<line187>ok = copy (source, dest, AT_FDCWD, dest, -new_dst, x, &unused, nullptr);\n<line188>}\n<line189>return ok;\n<line190>}
----------------------------------------
Function: cp_option_init
Content: <line0>static void\n<line1>cp_option_init (struct cp_options *x)\n<line2>{\n<line3>cp_options_default (x);\n<line4>x->copy_as_regular = true;\n<line5>x->dereference = DEREF_UNDEFINED;\n<line6>x->unlink_dest_before_opening = false;\n<line7>x->unlink_dest_after_failed_open = false;\n<line8>x->hard_link = false;\n<line9>x->interactive = I_UNSPECIFIED;\n<line10>x->move_mode = false;\n<line11>x->install_mode = false;\n<line12>x->one_file_system = false;\n<line13>x->reflink_mode = REFLINK_AUTO;\n<line14>x->preserve_ownership = false;\n<line15>x->preserve_links = false;\n<line16>x->preserve_mode = false;\n<line17>x->preserve_timestamps = false;\n<line18>x->explicit_no_preserve_mode = false;\n<line19>x->preserve_security_context = false; /* -a or --preserve=context.  */\n<line20>x->require_preserve_context = false;  /* --preserve=context.  */\n<line21>x->set_security_context = nullptr;       /* -Z, set sys default context. */\n<line22>x->preserve_xattr = false;\n<line23>x->reduce_diagnostics = false;\n<line24>x->require_preserve_xattr = false;\n<line25>x->data_copy_required = true;\n<line26>x->require_preserve = false;\n<line27>x->recursive = false;\n<line28>x->sparse_mode = SPARSE_AUTO;\n<line29>x->symbolic_link = false;\n<line30>x->set_mode = false;\n<line31>x->mode = 0;\n<line32>/* Not used.  */\n<line33>x->stdin_tty = false;\n<line34>x->update = false;\n<line35>x->verbose = false;\n<line36>/* By default, refuse to open a dangling destination symlink, because\n<line37>in general one cannot do that safely, give the current semantics of\n<line38>open's O_EXCL flag, (which POSIX doesn't even allow cp to use, btw).\n<line39>But POSIX requires it.  */\n<line40>x->open_dangling_dest_symlink = getenv ("POSIXLY_CORRECT") != nullptr;\n<line41>x->dest_info = nullptr;\n<line42>x->src_info = nullptr;\n<line43>}
----------------------------------------
Function: decode_preserve_arg
Content: <line0>static void\n<line1>decode_preserve_arg (char const *arg, struct cp_options *x, bool on_off)\n<line2>{\n<line3>enum File_attribute\n<line4>{\n<line5>PRESERVE_MODE,\n<line6>PRESERVE_TIMESTAMPS,\n<line7>PRESERVE_OWNERSHIP,\n<line8>PRESERVE_LINK,\n<line9>PRESERVE_CONTEXT,\n<line10>PRESERVE_XATTR,\n<line11>PRESERVE_ALL\n<line12>};\n<line13>static enum File_attribute const preserve_vals[] =\n<line14>{\n<line15>PRESERVE_MODE, PRESERVE_TIMESTAMPS,\n<line16>PRESERVE_OWNERSHIP, PRESERVE_LINK, PRESERVE_CONTEXT, PRESERVE_XATTR,\n<line17>PRESERVE_ALL\n<line18>};\n<line19>/* Valid arguments to the '--preserve' option. */\n<line20>static char const *const preserve_args[] =\n<line21>{\n<line22>"mode", "timestamps",\n<line23>"ownership", "links", "context", "xattr", "all", nullptr\n<line24>};\n<line25>ARGMATCH_VERIFY (preserve_args, preserve_vals);\n<line26>char *arg_writable = xstrdup (arg);\n<line27>char *s = arg_writable;\n<line28>do\n<line29>{\n<line30>/* find next comma */\n<line31>char *comma = strchr (s, ',');\n<line32>enum File_attribute val;\n<line33>/* If we found a comma, put a NUL in its place and advance.  */\n<line34>if (comma)\n<line35>*comma++ = 0;\n<line36>/* process S.  */\n<line37>val = XARGMATCH (on_off ? "--preserve" : "--no-preserve",\n<line38>s, preserve_args, preserve_vals);\n<line39>switch (val)\n<line40>{\n<line41>case PRESERVE_MODE:\n<line42>x->preserve_mode = on_off;\n<line43>x->explicit_no_preserve_mode = !on_off;\n<line44>break;\n<line45>case PRESERVE_TIMESTAMPS:\n<line46>x->preserve_timestamps = on_off;\n<line47>break;\n<line48>case PRESERVE_OWNERSHIP:\n<line49>x->preserve_ownership = on_off;\n<line50>break;\n<line51>case PRESERVE_LINK:\n<line52>x->preserve_links = on_off;\n<line53>break;\n<line54>case PRESERVE_CONTEXT:\n<line55>x->require_preserve_context = on_off;\n<line56>x->preserve_security_context = on_off;\n<line57>break;\n<line58>case PRESERVE_XATTR:\n<line59>x->preserve_xattr = on_off;\n<line60>x->require_preserve_xattr = on_off;\n<line61>break;\n<line62>case PRESERVE_ALL:\n<line63>x->preserve_mode = on_off;\n<line64>x->preserve_timestamps = on_off;\n<line65>x->preserve_ownership = on_off;\n<line66>x->preserve_links = on_off;\n<line67>x->explicit_no_preserve_mode = !on_off;\n<line68>if (selinux_enabled)\n<line69>x->preserve_security_context = on_off;\n<line70>x->preserve_xattr = on_off;\n<line71>break;\n<line72>default:\n<line73>affirm (false);\n<line74>}\n<line75>s = comma;\n<line76>}\n<line77>while (s);\n<line78>free (arg_writable);\n<line79>}
----------------------------------------
Function: main
Content: <line0>int\n<line1>main (int argc, char **argv)\n<line2>{\n<line3>int c;\n<line4>bool ok;\n<line5>bool make_backups = false;\n<line6>char const *backup_suffix = nullptr;\n<line7>char *version_control_string = nullptr;\n<line8>struct cp_options x;\n<line9>bool copy_contents = false;\n<line10>char *target_directory = nullptr;\n<line11>bool no_target_directory = false;\n<line12>char const *scontext = nullptr;\n<line13>initialize_main (&argc, &argv);\n<line14>set_program_name (argv[0]);\n<line15>setlocale (LC_ALL, "");\n<line16>bindtextdomain (PACKAGE, LOCALEDIR);\n<line17>textdomain (PACKAGE);\n<line18>atexit (close_stdin);\n<line19>selinux_enabled = (0 < is_selinux_enabled ());\n<line20>cp_option_init (&x);\n<line21>while ((c = getopt_long (argc, argv, "abdfHilLnprst:uvxPRS:TZ",\n<line22>long_opts, nullptr))\n<line23>!= -1)\n<line24>{\n<line25>switch (c)\n<line26>{\n<line27>case SPARSE_OPTION:\n<line28>x.sparse_mode = XARGMATCH ("--sparse", optarg,\n<line29>sparse_type_string, sparse_type);\n<line30>break;\n<line31>case REFLINK_OPTION:\n<line32>if (optarg == nullptr)\n<line33>x.reflink_mode = REFLINK_ALWAYS;\n<line34>else\n<line35>x.reflink_mode = XARGMATCH ("--reflink", optarg,\n<line36>reflink_type_string, reflink_type);\n<line37>break;\n<line38>case 'a':\n<line39>/* Like -dR --preserve=all with reduced failure diagnostics.  */\n<line40>x.dereference = DEREF_NEVER;\n<line41>x.preserve_links = true;\n<line42>x.preserve_ownership = true;\n<line43>x.preserve_mode = true;\n<line44>x.preserve_timestamps = true;\n<line45>x.require_preserve = true;\n<line46>if (selinux_enabled)\n<line47>x.preserve_security_context = true;\n<line48>x.preserve_xattr = true;\n<line49>x.reduce_diagnostics = true;\n<line50>x.recursive = true;\n<line51>break;\n<line52>case 'b':\n<line53>make_backups = true;\n<line54>if (optarg)\n<line55>version_control_string = optarg;\n<line56>break;\n<line57>case ATTRIBUTES_ONLY_OPTION:\n<line58>x.data_copy_required = false;\n<line59>break;\n<line60>case DEBUG_OPTION:\n<line61>x.debug = x.verbose = true;\n<line62>break;\n<line63>case COPY_CONTENTS_OPTION:\n<line64>copy_contents = true;\n<line65>break;\n<line66>case 'd':\n<line67>x.preserve_links = true;\n<line68>x.dereference = DEREF_NEVER;\n<line69>break;\n<line70>case 'f':\n<line71>x.unlink_dest_after_failed_open = true;\n<line72>break;\n<line73>case 'H':\n<line74>x.dereference = DEREF_COMMAND_LINE_ARGUMENTS;\n<line75>break;\n<line76>case 'i':\n<line77>x.interactive = I_ASK_USER;\n<line78>break;\n<line79>case 'l':\n<line80>x.hard_link = true;\n<line81>break;\n<line82>case 'L':\n<line83>x.dereference = DEREF_ALWAYS;\n<line84>break;\n<line85>case 'n':\n<line86>x.interactive = I_ALWAYS_NO;\n<line87>break;\n<line88>case 'P':\n<line89>x.dereference = DEREF_NEVER;\n<line90>break;\n<line91>case NO_PRESERVE_ATTRIBUTES_OPTION:\n<line92>decode_preserve_arg (optarg, &x, false);\n<line93>break;\n<line94>case PRESERVE_ATTRIBUTES_OPTION:\n<line95>if (optarg == nullptr)\n<line96>{\n<line97>/* Fall through to the case for 'p' below.  */\n<line98>}\n<line99>else\n<line100>{\n<line101>decode_preserve_arg (optarg, &x, true);\n<line102>x.require_preserve = true;\n<line103>break;\n<line104>}\n<line105>FALLTHROUGH;\n<line106>case 'p':\n<line107>x.preserve_ownership = true;\n<line108>x.preserve_mode = true;\n<line109>x.preserve_timestamps = true;\n<line110>x.require_preserve = true;\n<line111>break;\n<line112>case PARENTS_OPTION:\n<line113>parents_option = true;\n<line114>break;\n<line115>case 'r':\n<line116>case 'R':\n<line117>x.recursive = true;\n<line118>break;\n<line119>case UNLINK_DEST_BEFORE_OPENING:\n<line120>x.unlink_dest_before_opening = true;\n<line121>break;\n<line122>case STRIP_TRAILING_SLASHES_OPTION:\n<line123>remove_trailing_slashes = true;\n<line124>break;\n<line125>case 's':\n<line126>x.symbolic_link = true;\n<line127>break;\n<line128>case 't':\n<line129>if (target_directory)\n<line130>error (EXIT_FAILURE, 0,\n<line131>_("multiple target directories specified"));\n<line132>target_directory = optarg;\n<line133>break;\n<line134>case 'T':\n<line135>no_target_directory = true;\n<line136>break;\n<line137>case 'u':\n<line138>if (optarg == nullptr)\n<line139>x.update = true;\n<line140>else if (x.interactive != I_ALWAYS_NO)  /* -n takes precedence.  */\n<line141>{\n<line142>enum Update_type update_opt;\n<line143>update_opt = XARGMATCH ("--update", optarg,\n<line144>update_type_string, update_type);\n<line145>if (update_opt == UPDATE_ALL)\n<line146>{\n<line147>/* Default cp operation.  */\n<line148>x.update = false;\n<line149>x.interactive = I_UNSPECIFIED;\n<line150>}\n<line151>else if (update_opt == UPDATE_NONE)\n<line152>{\n<line153>x.update = false;\n<line154>x.interactive = I_ALWAYS_SKIP;\n<line155>}\n<line156>else if (update_opt == UPDATE_OLDER)\n<line157>{\n<line158>x.update = true;\n<line159>x.interactive = I_UNSPECIFIED;\n<line160>}\n<line161>}\n<line162>break;\n<line163>case 'v':\n<line164>x.verbose = true;\n<line165>break;\n<line166>case 'x':\n<line167>x.one_file_system = true;\n<line168>break;\n<line169>case 'Z':\n<line170>/* politely decline if we're not on a selinux-enabled kernel.  */\n<line171>if (selinux_enabled)\n<line172>{\n<line173>if (optarg)\n<line174>scontext = optarg;\n<line175>else\n<line176>{\n<line177>x.set_security_context = selabel_open (SELABEL_CTX_FILE,\n<line178>nullptr, 0);\n<line179>if (! x.set_security_context)\n<line180>error (0, errno, _("warning: ignoring --context"));\n<line181>}\n<line182>}\n<line183>else if (optarg)\n<line184>{\n<line185>error (0, 0,\n<line186>_("warning: ignoring --context; "\n<line187>"it requires an SELinux-enabled kernel"));\n<line188>}\n<line189>break;\n<line190>case 'S':\n<line191>make_backups = true;\n<line192>backup_suffix = optarg;\n<line193>break;\n<line194>case_GETOPT_HELP_CHAR;\n<line195>case_GETOPT_VERSION_CHAR (PROGRAM_NAME, AUTHORS);\n<line196>default:\n<line197>usage (EXIT_FAILURE);\n<line198>}\n<line199>}\n<line200>/* With --sparse=never, disable reflinking so we create a non sparse copy.\n<line201>This will also have the effect of disabling copy offload as that may\n<line202>propagate holes.  For e.g. FreeBSD documents that copy_file_range()\n<line203>will try to propagate holes.  */\n<line204>if (x.reflink_mode == REFLINK_AUTO && x.sparse_mode == SPARSE_NEVER)\n<line205>x.reflink_mode = REFLINK_NEVER;\n<line206>if (x.hard_link && x.symbolic_link)\n<line207>{\n<line208>error (0, 0, _("cannot make both hard and symbolic links"));\n<line209>usage (EXIT_FAILURE);\n<line210>}\n<line211>if (x.interactive == I_ALWAYS_NO)\n<line212>x.update = false;\n<line213>if (make_backups && x.interactive == I_ALWAYS_NO)\n<line214>{\n<line215>error (0, 0,\n<line216>_("options --backup and --no-clobber are mutually exclusive"));\n<line217>usage (EXIT_FAILURE);\n<line218>}\n<line219>if (x.reflink_mode == REFLINK_ALWAYS && x.sparse_mode != SPARSE_AUTO)\n<line220>{\n<line221>error (0, 0, _("--reflink can be used only with --sparse=auto"));\n<line222>usage (EXIT_FAILURE);\n<line223>}\n<line224>x.backup_type = (make_backups\n<line225>? xget_version (_("backup type"),\n<line226>version_control_string)\n<line227>: no_backups);\n<line228>set_simple_backup_suffix (backup_suffix);\n<line229>if (x.dereference == DEREF_UNDEFINED)\n<line230>{\n<line231>if (x.recursive && ! x.hard_link)\n<line232>/* This is compatible with FreeBSD.  */\n<line233>x.dereference = DEREF_NEVER;\n<line234>else\n<line235>x.dereference = DEREF_ALWAYS;\n<line236>}\n<line237>if (x.recursive)\n<line238>x.copy_as_regular = copy_contents;\n<line239>/* Ensure -Z overrides -a.  */\n<line240>if ((x.set_security_context || scontext)\n<line241>&& ! x.require_preserve_context)\n<line242>x.preserve_security_context = false;\n<line243>if (x.preserve_security_context && (x.set_security_context || scontext))\n<line244>error (EXIT_FAILURE, 0,\n<line245>_("cannot set target context and preserve it"));\n<line246>if (x.require_preserve_context && ! selinux_enabled)\n<line247>error (EXIT_FAILURE, 0,\n<line248>_("cannot preserve security context "\n<line249>"without an SELinux-enabled kernel"));\n<line250>/* FIXME: This handles new files.  But what about existing files?\n<line251>I.e., if updating a tree, new files would have the specified context,\n<line252>but shouldn't existing files be updated for consistency like this?\n<line253>if (scontext && !restorecon (nullptr, dst_path, 0))\n<line254>error (...);\n<line255>*/\n<line256>if (scontext && setfscreatecon (scontext) < 0)\n<line257>error (EXIT_FAILURE, errno,\n<line258>_("failed to set default file creation context to %s"),\n<line259>quote (scontext));\n<line260>#if !USE_XATTR\n<line261>if (x.require_preserve_xattr)\n<line262>error (EXIT_FAILURE, 0, _("cannot preserve extended attributes, cp is "\n<line263>"built without xattr support"));\n<line264>#endif\n<line265>/* Allocate space for remembering copied and created files.  */\n<line266>hash_init ();\n<line267>ok = do_copy (argc - optind, argv + optind,\n<line268>target_directory, no_target_directory, &x);\n<line269>main_exit (ok ? EXIT_SUCCESS : EXIT_FAILURE);\n<line270>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/src/copy.c
========================================
Function: copy_debug_string
Content: <line0>static const char*\n<line1>copy_debug_string (enum copy_debug_val debug_val)\n<line2>{\n<line3>switch (debug_val)\n<line4>{\n<line5>case COPY_DEBUG_NO: return "no";\n<line6>case COPY_DEBUG_YES: return "yes";\n<line7>case COPY_DEBUG_AVOIDED: return "avoided";\n<line8>case COPY_DEBUG_UNSUPPORTED: return "unsupported";\n<line9>default: return "unknown";\n<line10>}\n<line11>}
----------------------------------------
Function: copy_debug_sparse_string
Content: <line0>static const char*\n<line1>copy_debug_sparse_string (enum copy_debug_val debug_val)\n<line2>{\n<line3>switch (debug_val)\n<line4>{\n<line5>case COPY_DEBUG_NO: return "no";\n<line6>case COPY_DEBUG_YES: return "zeros";\n<line7>case COPY_DEBUG_EXTERNAL: return "SEEK_HOLE";\n<line8>case COPY_DEBUG_EXTERNAL_INTERNAL: return "SEEK_HOLE + zeros";\n<line9>default: return "unknown";\n<line10>}\n<line11>}
----------------------------------------
Function: emit_debug
Content: <line0>static void\n<line1>emit_debug (const struct cp_options *x)\n<line2>{\n<line3>if (! x->hard_link && ! x->symbolic_link && x->data_copy_required)\n<line4>printf ("copy offload: %s, reflink: %s, sparse detection: %s\n",\n<line5>copy_debug_string (copy_debug.offload),\n<line6>copy_debug_string (copy_debug.reflink),\n<line7>copy_debug_sparse_string (copy_debug.sparse_detection));\n<line8>}
----------------------------------------
Function: follow_fstatat
Content: <line0>static int\n<line1>follow_fstatat (int dirfd, char const *filename, struct stat *st, int flags)\n<line2>{\n<line3>int result = fstatat (dirfd, filename, st, flags);\n<line4>if (DEV_FD_MIGHT_BE_CHR && result == 0 && !(flags & AT_SYMLINK_NOFOLLOW)\n<line5>&& S_ISCHR (st->st_mode))\n<line6>{\n<line7>static dev_t stdin_rdev;\n<line8>static signed char stdin_rdev_status;\n<line9>if (stdin_rdev_status == 0)\n<line10>{\n<line11>struct stat stdin_st;\n<line12>if (stat ("/dev/stdin", &stdin_st) == 0 && S_ISCHR (stdin_st.st_mode)\n<line13>&& minor (stdin_st.st_rdev) == STDIN_FILENO)\n<line14>{\n<line15>stdin_rdev = stdin_st.st_rdev;\n<line16>stdin_rdev_status = 1;\n<line17>}\n<line18>else\n<line19>stdin_rdev_status = -1;\n<line20>}\n<line21>if (0 < stdin_rdev_status && major (stdin_rdev) == major (st->st_rdev))\n<line22>result = fstat (minor (st->st_rdev), st);\n<line23>}\n<line24>return result;\n<line25>}
----------------------------------------
Function: punch_hole
Content: <line0>static int\n<line1>punch_hole (int fd, off_t offset, off_t length)\n<line2>{\n<line3>int ret = 0;\n<line4>/* +0 is to work around older <linux/fs.h> defining HAVE_FALLOCATE to empty.  */\n<line5>#if HAVE_FALLOCATE + 0\n<line6># if defined FALLOC_FL_PUNCH_HOLE && defined FALLOC_FL_KEEP_SIZE\n<line7>ret = fallocate (fd, FALLOC_FL_PUNCH_HOLE | FALLOC_FL_KEEP_SIZE,\n<line8>offset, length);\n<line9>if (ret < 0 && (is_ENOTSUP (errno) || errno == ENOSYS))\n<line10>ret = 0;\n<line11># endif\n<line12>#endif\n<line13>return ret;\n<line14>}
----------------------------------------
Function: create_hole
Content: <line0>static bool\n<line1>create_hole (int fd, char const *name, bool punch_holes, off_t size)\n<line2>{\n<line3>off_t file_end = lseek (fd, size, SEEK_CUR);\n<line4>if (file_end < 0)\n<line5>{\n<line6>error (0, errno, _("cannot lseek %s"), quoteaf (name));\n<line7>return false;\n<line8>}\n<line9>/* Some file systems (like XFS) preallocate when write extending a file.\n<line10>I.e., a previous write() may have preallocated extra space\n<line11>that the seek above will not discard.  A subsequent write() could\n<line12>then make this allocation permanent.  */\n<line13>if (punch_holes && punch_hole (fd, file_end - size, size) < 0)\n<line14>{\n<line15>error (0, errno, _("error deallocating %s"), quoteaf (name));\n<line16>return false;\n<line17>}\n<line18>return true;\n<line19>}
----------------------------------------
Function: is_terminal_error
Content: <line0>static bool\n<line1>is_terminal_error (int err)\n<line2>{\n<line3>return err == EIO || err == ENOMEM || err == ENOSPC || err == EDQUOT;\n<line4>}
----------------------------------------
Function: is_CLONENOTSUP
Content: <line0>static bool\n<line1>is_CLONENOTSUP (int err)\n<line2>{\n<line3>return err == ENOSYS || err == ENOTTY || is_ENOTSUP (err)\n<line4>|| err == EINVAL || err == EBADF\n<line5>|| err == EXDEV || err == ETXTBSY\n<line6>|| err == EPERM || err == EACCES;\n<line7>}
----------------------------------------
Function: sparse_copy
Content: <line0>static bool\n<line1>sparse_copy (int src_fd, int dest_fd, char **abuf, size_t buf_size,\n<line2>size_t hole_size, bool punch_holes, bool allow_reflink,\n<line3>char const *src_name, char const *dst_name,\n<line4>uintmax_t max_n_read, off_t *total_n_read,\n<line5>bool *last_write_made_hole)\n<line6>{\n<line7>*last_write_made_hole = false;\n<line8>*total_n_read = 0;\n<line9>if (copy_debug.sparse_detection == COPY_DEBUG_UNKNOWN)\n<line10>copy_debug.sparse_detection = hole_size ? COPY_DEBUG_YES : COPY_DEBUG_NO;\n<line11>else if (hole_size && copy_debug.sparse_detection == COPY_DEBUG_EXTERNAL)\n<line12>copy_debug.sparse_detection = COPY_DEBUG_EXTERNAL_INTERNAL;\n<line13>/* If not looking for holes, use copy_file_range if functional,\n<line14>but don't use if reflink disallowed as that may be implicit.  */\n<line15>if (!hole_size && allow_reflink)\n<line16>while (max_n_read)\n<line17>{\n<line18>/* Copy at most COPY_MAX bytes at a time; this is min\n<line19>(SSIZE_MAX, SIZE_MAX) truncated to a value that is\n<line20>surely aligned well.  */\n<line21>ssize_t copy_max = MIN (SSIZE_MAX, SIZE_MAX) >> 30 << 30;\n<line22>ssize_t n_copied = copy_file_range (src_fd, nullptr, dest_fd, nullptr,\n<line23>MIN (max_n_read, copy_max), 0);\n<line24>if (n_copied == 0)\n<line25>{\n<line26>/* copy_file_range incorrectly returns 0 when reading from\n<line27>the proc file system on the Linux kernel through at\n<line28>least 5.6.19 (2020), so fall back on 'read' if the\n<line29>input file seems empty.  */\n<line30>if (*total_n_read == 0)\n<line31>break;\n<line32>copy_debug.offload = COPY_DEBUG_YES;\n<line33>return true;\n<line34>}\n<line35>if (n_copied < 0)\n<line36>{\n<line37>copy_debug.offload = COPY_DEBUG_UNSUPPORTED;\n<line38>/* Consider operation unsupported only if no data copied.\n<line39>For example, EPERM could occur if copy_file_range not enabled\n<line40>in seccomp filters, so retry with a standard copy.  EPERM can\n<line41>also occur for immutable files, but that would only be in the\n<line42>edge case where the file is made immutable after creating,\n<line43>in which case the (more accurate) error is still shown.  */\n<line44>if (*total_n_read == 0 && is_CLONENOTSUP (errno))\n<line45>break;\n<line46>/* ENOENT was seen sometimes across CIFS shares, resulting in\n<line47>no data being copied, but subsequent standard copies succeed.  */\n<line48>if (*total_n_read == 0 && errno == ENOENT)\n<line49>break;\n<line50>if (errno == EINTR)\n<line51>n_copied = 0;\n<line52>else\n<line53>{\n<line54>error (0, errno, _("error copying %s to %s"),\n<line55>quoteaf_n (0, src_name), quoteaf_n (1, dst_name));\n<line56>return false;\n<line57>}\n<line58>}\n<line59>copy_debug.offload = COPY_DEBUG_YES;\n<line60>max_n_read -= n_copied;\n<line61>*total_n_read += n_copied;\n<line62>}\n<line63>else\n<line64>copy_debug.offload = COPY_DEBUG_AVOIDED;\n<line65>bool make_hole = false;\n<line66>off_t psize = 0;\n<line67>while (max_n_read)\n<line68>{\n<line69>if (!*abuf)\n<line70>*abuf = xalignalloc (getpagesize (), buf_size);\n<line71>char *buf = *abuf;\n<line72>ssize_t n_read = read (src_fd, buf, MIN (max_n_read, buf_size));\n<line73>if (n_read < 0)\n<line74>{\n<line75>if (errno == EINTR)\n<line76>continue;\n<line77>error (0, errno, _("error reading %s"), quoteaf (src_name));\n<line78>return false;\n<line79>}\n<line80>if (n_read == 0)\n<line81>break;\n<line82>max_n_read -= n_read;\n<line83>*total_n_read += n_read;\n<line84>/* Loop over the input buffer in chunks of hole_size.  */\n<line85>size_t csize = hole_size ? hole_size : buf_size;\n<line86>char *cbuf = buf;\n<line87>char *pbuf = buf;\n<line88>while (n_read)\n<line89>{\n<line90>bool prev_hole = make_hole;\n<line91>csize = MIN (csize, n_read);\n<line92>if (hole_size && csize)\n<line93>make_hole = is_nul (cbuf, csize);\n<line94>bool transition = (make_hole != prev_hole) && psize;\n<line95>bool last_chunk = (n_read == csize && ! make_hole) || ! csize;\n<line96>if (transition || last_chunk)\n<line97>{\n<line98>if (! transition)\n<line99>psize += csize;\n<line100>if (! prev_hole)\n<line101>{\n<line102>if (full_write (dest_fd, pbuf, psize) != psize)\n<line103>{\n<line104>error (0, errno, _("error writing %s"),\n<line105>quoteaf (dst_name));\n<line106>return false;\n<line107>}\n<line108>}\n<line109>else\n<line110>{\n<line111>if (! create_hole (dest_fd, dst_name, punch_holes, psize))\n<line112>return false;\n<line113>}\n<line114>pbuf = cbuf;\n<line115>psize = csize;\n<line116>if (last_chunk)\n<line117>{\n<line118>if (! csize)\n<line119>n_read = 0; /* Finished processing buffer.  */\n<line120>if (transition)\n<line121>csize = 0;  /* Loop again to deal with last chunk.  */\n<line122>else\n<line123>psize = 0;  /* Reset for next read loop.  */\n<line124>}\n<line125>}\n<line126>else  /* Coalesce writes/seeks.  */\n<line127>{\n<line128>if (ckd_add (&psize, psize, csize))\n<line129>{\n<line130>error (0, 0, _("overflow reading %s"), quoteaf (src_name));\n<line131>return false;\n<line132>}\n<line133>}\n<line134>n_read -= csize;\n<line135>cbuf += csize;\n<line136>}\n<line137>*last_write_made_hole = make_hole;\n<line138>/* It's tempting to break early here upon a short read from\n<line139>a regular file.  That would save the final read syscall\n<line140>for each file.  Unfortunately that doesn't work for\n<line141>certain files in /proc or /sys with linux kernels.  */\n<line142>}\n<line143>/* Ensure a trailing hole is created, so that subsequent\n<line144>calls of sparse_copy() start at the correct offset.  */\n<line145>if (make_hole && ! create_hole (dest_fd, dst_name, punch_holes, psize))\n<line146>return false;\n<line147>else\n<line148>return true;\n<line149>}
----------------------------------------
Function: clone_file
Content: <line0>static inline int\n<line1>clone_file (int dest_fd, int src_fd)\n<line2>{\n<line3>#ifdef FICLONE\n<line4>return ioctl (dest_fd, FICLONE, src_fd);\n<line5>#else\n<line6>(void) dest_fd;\n<line7>(void) src_fd;\n<line8>errno = ENOTSUP;\n<line9>return -1;\n<line10>#endif\n<line11>}
----------------------------------------
Function: write_zeros
Content: <line0>static bool\n<line1>write_zeros (int fd, off_t n_bytes)\n<line2>{\n<line3>static char *zeros;\n<line4>static size_t nz = IO_BUFSIZE;\n<line5>/* Attempt to use a relatively large calloc'd source buffer for\n<line6>efficiency, but if that allocation fails, resort to a smaller\n<line7>statically allocated one.  */\n<line8>if (zeros == nullptr)\n<line9>{\n<line10>static char fallback[1024];\n<line11>zeros = calloc (nz, 1);\n<line12>if (zeros == nullptr)\n<line13>{\n<line14>zeros = fallback;\n<line15>nz = sizeof fallback;\n<line16>}\n<line17>}\n<line18>while (n_bytes)\n<line19>{\n<line20>size_t n = MIN (nz, n_bytes);\n<line21>if ((full_write (fd, zeros, n)) != n)\n<line22>return false;\n<line23>n_bytes -= n;\n<line24>}\n<line25>return true;\n<line26>}
----------------------------------------
Function: lseek_copy
Content: <line0>static bool\n<line1>lseek_copy (int src_fd, int dest_fd, char **abuf, size_t buf_size,\n<line2>size_t hole_size, off_t ext_start, off_t src_total_size,\n<line3>enum Sparse_type sparse_mode,\n<line4>bool allow_reflink,\n<line5>char const *src_name, char const *dst_name)\n<line6>{\n<line7>off_t last_ext_start = 0;\n<line8>off_t last_ext_len = 0;\n<line9>off_t dest_pos = 0;\n<line10>bool wrote_hole_at_eof = true;\n<line11>copy_debug.sparse_detection = COPY_DEBUG_EXTERNAL;\n<line12>while (0 <= ext_start)\n<line13>{\n<line14>off_t ext_end = lseek (src_fd, ext_start, SEEK_HOLE);\n<line15>if (ext_end < 0)\n<line16>{\n<line17>if (errno != ENXIO)\n<line18>goto cannot_lseek;\n<line19>ext_end = src_total_size;\n<line20>if (ext_end <= ext_start)\n<line21>{\n<line22>/* The input file grew; get its current size.  */\n<line23>src_total_size = lseek (src_fd, 0, SEEK_END);\n<line24>if (src_total_size < 0)\n<line25>goto cannot_lseek;\n<line26>/* If the input file shrank after growing, stop copying.  */\n<line27>if (src_total_size <= ext_start)\n<line28>break;\n<line29>ext_end = src_total_size;\n<line30>}\n<line31>}\n<line32>/* If the input file must have grown, increase its measured size.  */\n<line33>if (src_total_size < ext_end)\n<line34>src_total_size = ext_end;\n<line35>if (lseek (src_fd, ext_start, SEEK_SET) < 0)\n<line36>goto cannot_lseek;\n<line37>wrote_hole_at_eof = false;\n<line38>off_t ext_hole_size = ext_start - last_ext_start - last_ext_len;\n<line39>if (ext_hole_size)\n<line40>{\n<line41>if (sparse_mode != SPARSE_NEVER)\n<line42>{\n<line43>if (! create_hole (dest_fd, dst_name,\n<line44>sparse_mode == SPARSE_ALWAYS,\n<line45>ext_hole_size))\n<line46>return false;\n<line47>wrote_hole_at_eof = true;\n<line48>}\n<line49>else\n<line50>{\n<line51>/* When not inducing holes and when there is a hole between\n<line52>the end of the previous extent and the beginning of the\n<line53>current one, write zeros to the destination file.  */\n<line54>if (! write_zeros (dest_fd, ext_hole_size))\n<line55>{\n<line56>error (0, errno, _("%s: write failed"),\n<line57>quotef (dst_name));\n<line58>return false;\n<line59>}\n<line60>}\n<line61>}\n<line62>off_t ext_len = ext_end - ext_start;\n<line63>last_ext_start = ext_start;\n<line64>last_ext_len = ext_len;\n<line65>/* Copy this extent, looking for further opportunities to not\n<line66>bother to write zeros if --sparse=always, since SEEK_HOLE\n<line67>is conservative and may miss some holes.  */\n<line68>off_t n_read;\n<line69>bool read_hole;\n<line70>if ( ! sparse_copy (src_fd, dest_fd, abuf, buf_size,\n<line71>sparse_mode != SPARSE_ALWAYS ? 0 : hole_size,\n<line72>true, allow_reflink, src_name, dst_name,\n<line73>ext_len, &n_read, &read_hole))\n<line74>return false;\n<line75>dest_pos = ext_start + n_read;\n<line76>if (n_read)\n<line77>wrote_hole_at_eof = read_hole;\n<line78>if (n_read < ext_len)\n<line79>{\n<line80>/* The input file shrank.  */\n<line81>src_total_size = dest_pos;\n<line82>break;\n<line83>}\n<line84>ext_start = lseek (src_fd, dest_pos, SEEK_DATA);\n<line85>if (ext_start < 0 && errno != ENXIO)\n<line86>goto cannot_lseek;\n<line87>}\n<line88>/* When the source file ends with a hole, we have to do a little more work,\n<line89>since the above copied only up to and including the final extent.\n<line90>In order to complete the copy, we may have to insert a hole or write\n<line91>zeros in the destination corresponding to the source file's hole-at-EOF.\n<line92>In addition, if the final extent was a block of zeros at EOF and we've\n<line93>just converted them to a hole in the destination, we must call ftruncate\n<line94>here in order to record the proper length in the destination.  */\n<line95>if ((dest_pos < src_total_size || wrote_hole_at_eof)\n<line96>&& ! (sparse_mode == SPARSE_NEVER\n<line97>? write_zeros (dest_fd, src_total_size - dest_pos)\n<line98>: ftruncate (dest_fd, src_total_size) == 0))\n<line99>{\n<line100>error (0, errno, _("failed to extend %s"), quoteaf (dst_name));\n<line101>return false;\n<line102>}\n<line103>if (sparse_mode == SPARSE_ALWAYS && dest_pos < src_total_size\n<line104>&& punch_hole (dest_fd, dest_pos, src_total_size - dest_pos) < 0)\n<line105>{\n<line106>error (0, errno, _("error deallocating %s"), quoteaf (dst_name));\n<line107>return false;\n<line108>}\n<line109>return true;\n<line110>cannot_lseek:\n<line111>error (0, errno, _("cannot lseek %s"), quoteaf (src_name));\n<line112>return false;\n<line113>}
----------------------------------------
Function: errno_unsupported
Content: <line0>static bool\n<line1>errno_unsupported (int err)\n<line2>{\n<line3>return err == ENOTSUP || err == ENODATA;\n<line4>}
----------------------------------------
Function: copy_attr
Content: <line0>static bool\n<line1>copy_attr (MAYBE_UNUSED char const *src_path,\n<line2>MAYBE_UNUSED int src_fd,\n<line3>MAYBE_UNUSED char const *dst_path,\n<line4>MAYBE_UNUSED int dst_fd,\n<line5>MAYBE_UNUSED struct cp_options const *x)\n<line6>{\n<line7>return true;\n<line8>}
----------------------------------------
Function: copy_dir
Content: <line0>static bool\n<line1>copy_dir (char const *src_name_in, char const *dst_name_in,\n<line2>int dst_dirfd, char const *dst_relname_in, bool new_dst,\n<line3>const struct stat *src_sb, struct dir_list *ancestors,\n<line4>const struct cp_options *x,\n<line5>bool *first_dir_created_per_command_line_arg,\n<line6>bool *copy_into_self)\n<line7>{\n<line8>char *name_space;\n<line9>char *namep;\n<line10>struct cp_options non_command_line_options = *x;\n<line11>bool ok = true;\n<line12>name_space = savedir (src_name_in, SAVEDIR_SORT_FASTREAD);\n<line13>if (name_space == nullptr)\n<line14>{\n<line15>/* This diagnostic is a bit vague because savedir can fail in\n<line16>several different ways.  */\n<line17>error (0, errno, _("cannot access %s"), quoteaf (src_name_in));\n<line18>return false;\n<line19>}\n<line20>/* For cp's -H option, dereference command line arguments, but do not\n<line21>dereference symlinks that are found via recursive traversal.  */\n<line22>if (x->dereference == DEREF_COMMAND_LINE_ARGUMENTS)\n<line23>non_command_line_options.dereference = DEREF_NEVER;\n<line24>bool new_first_dir_created = false;\n<line25>namep = name_space;\n<line26>while (*namep != '\0')\n<line27>{\n<line28>bool local_copy_into_self;\n<line29>char *src_name = file_name_concat (src_name_in, namep, nullptr);\n<line30>char *dst_name = file_name_concat (dst_name_in, namep, nullptr);\n<line31>bool first_dir_created = *first_dir_created_per_command_line_arg;\n<line32>bool rename_succeeded;\n<line33>ok &= copy_internal (src_name, dst_name, dst_dirfd,\n<line34>dst_name + (dst_relname_in - dst_name_in),\n<line35>new_dst, src_sb,\n<line36>ancestors, &non_command_line_options, false,\n<line37>&first_dir_created,\n<line38>&local_copy_into_self, &rename_succeeded);\n<line39>*copy_into_self |= local_copy_into_self;\n<line40>free (dst_name);\n<line41>free (src_name);\n<line42>/* If we're copying into self, there's no point in continuing,\n<line43>and in fact, that would even infloop, now that we record only\n<line44>the first created directory per command line argument.  */\n<line45>if (local_copy_into_self)\n<line46>break;\n<line47>new_first_dir_created |= first_dir_created;\n<line48>namep += strlen (namep) + 1;\n<line49>}\n<line50>free (name_space);\n<line51>*first_dir_created_per_command_line_arg = new_first_dir_created;\n<line52>return ok;\n<line53>}
----------------------------------------
Function: set_owner
Content: <line0>static int\n<line1>set_owner (const struct cp_options *x, char const *dst_name,\n<line2>int dst_dirfd, char const *dst_relname, int dest_desc,\n<line3>struct stat const *src_sb, bool new_dst,\n<line4>struct stat const *dst_sb)\n<line5>{\n<line6>uid_t uid = src_sb->st_uid;\n<line7>gid_t gid = src_sb->st_gid;\n<line8>/* Naively changing the ownership of an already-existing file before\n<line9>changing its permissions would create a window of vulnerability if\n<line10>the file's old permissions are too generous for the new owner and\n<line11>group.  Avoid the window by first changing to a restrictive\n<line12>temporary mode if necessary.  */\n<line13>if (!new_dst && (x->preserve_mode || x->move_mode || x->set_mode))\n<line14>{\n<line15>mode_t old_mode = dst_sb->st_mode;\n<line16>mode_t new_mode =\n<line17>(x->preserve_mode || x->move_mode ? src_sb->st_mode : x->mode);\n<line18>mode_t restrictive_temp_mode = old_mode & new_mode & S_IRWXU;\n<line19>if ((USE_ACL\n<line20>|| (old_mode & CHMOD_MODE_BITS\n<line21>& (~new_mode | S_ISUID | S_ISGID | S_ISVTX)))\n<line22>&& qset_acl (dst_name, dest_desc, restrictive_temp_mode) != 0)\n<line23>{\n<line24>if (! owner_failure_ok (x))\n<line25>error (0, errno, _("clearing permissions for %s"),\n<line26>quoteaf (dst_name));\n<line27>return -x->require_preserve;\n<line28>}\n<line29>}\n<line30>if (HAVE_FCHOWN && dest_desc != -1)\n<line31>{\n<line32>if (fchown (dest_desc, uid, gid) == 0)\n<line33>return 1;\n<line34>if (errno == EPERM || errno == EINVAL)\n<line35>{\n<line36>/* We've failed to set *both*.  Now, try to set just the group\n<line37>ID, but ignore any failure here, and don't change errno.  */\n<line38>int saved_errno = errno;\n<line39>ignore_value (fchown (dest_desc, -1, gid));\n<line40>errno = saved_errno;\n<line41>}\n<line42>}\n<line43>else\n<line44>{\n<line45>if (lchownat (dst_dirfd, dst_relname, uid, gid) == 0)\n<line46>return 1;\n<line47>if (errno == EPERM || errno == EINVAL)\n<line48>{\n<line49>/* We've failed to set *both*.  Now, try to set just the group\n<line50>ID, but ignore any failure here, and don't change errno.  */\n<line51>int saved_errno = errno;\n<line52>ignore_value (lchownat (dst_dirfd, dst_relname, -1, gid));\n<line53>errno = saved_errno;\n<line54>}\n<line55>}\n<line56>if (! chown_failure_ok (x))\n<line57>{\n<line58>error (0, errno, _("failed to preserve ownership for %s"),\n<line59>quoteaf (dst_name));\n<line60>if (x->require_preserve)\n<line61>return -1;\n<line62>}\n<line63>return 0;\n<line64>}
----------------------------------------
Function: set_author
Content: <line0>static void\n<line1>set_author (char const *dst_name, int dest_desc, const struct stat *src_sb)\n<line2>{\n<line3>#if HAVE_STRUCT_STAT_ST_AUTHOR\n<line4>/* FIXME: Modify the following code so that it does not\n<line5>follow symbolic links.  */\n<line6>/* Preserve the st_author field.  */\n<line7>file_t file = (dest_desc < 0\n<line8>? file_name_lookup (dst_name, 0, 0)\n<line9>: getdport (dest_desc));\n<line10>if (file == MACH_PORT_NULL)\n<line11>error (0, errno, _("failed to lookup file %s"), quoteaf (dst_name));\n<line12>else\n<line13>{\n<line14>error_t err = file_chauthor (file, src_sb->st_author);\n<line15>if (err)\n<line16>error (0, err, _("failed to preserve authorship for %s"),\n<line17>quoteaf (dst_name));\n<line18>mach_port_deallocate (mach_task_self (), file);\n<line19>}\n<line20>#else\n<line21>(void) dst_name;\n<line22>(void) dest_desc;\n<line23>(void) src_sb;\n<line24>#endif\n<line25>}
----------------------------------------
Function: fchmod_or_lchmod
Content: <line0>static int\n<line1>fchmod_or_lchmod (int desc, int dirfd, char const *name, mode_t mode)\n<line2>{\n<line3>#if HAVE_FCHMOD\n<line4>if (0 <= desc)\n<line5>return fchmod (desc, mode);\n<line6>#endif\n<line7>return lchmodat (dirfd, name, mode);\n<line8>}
----------------------------------------
Function: infer_scantype
Content: <line0>static enum scantype\n<line1>infer_scantype (int fd, struct stat const *sb,\n<line2>union scan_inference *scan_inference)\n<line3>{\n<line4>scan_inference->ext_start = -1;  /* avoid -Wmaybe-uninitialized */\n<line5>/* Only attempt SEEK_HOLE if this heuristic\n<line6>suggests the file is sparse.  */\n<line7>if (! (HAVE_STRUCT_STAT_ST_BLOCKS\n<line8>&& S_ISREG (sb->st_mode)\n<line9>&& ST_NBLOCKS (*sb) < sb->st_size / ST_NBLOCKSIZE))\n<line10>return PLAIN_SCANTYPE;\n<line11>#ifdef SEEK_HOLE\n<line12>off_t ext_start = lseek (fd, 0, SEEK_DATA);\n<line13>if (0 <= ext_start || errno == ENXIO)\n<line14>{\n<line15>scan_inference->ext_start = ext_start;\n<line16>return LSEEK_SCANTYPE;\n<line17>}\n<line18>else if (errno != EINVAL && !is_ENOTSUP (errno))\n<line19>return ERROR_SCANTYPE;\n<line20>#endif\n<line21>return ZERO_SCANTYPE;\n<line22>}
----------------------------------------
Function: handle_clone_fail
Content: <line0>static bool\n<line1>handle_clone_fail (int dst_dirfd, char const *dst_relname,\n<line2>char const *src_name, char const *dst_name,\n<line3>int dest_desc, bool new_dst, enum Reflink_type reflink_mode)\n<line4>{\n<line5>/* When the clone operation fails, report failure only with errno values\n<line6>known to mean trouble when the clone is supported and called properly.\n<line7>Do not report failure merely because !is_CLONENOTSUP (errno),\n<line8>as systems may yield oddball errno values here with FICLONE,\n<line9>and is_CLONENOTSUP is not appropriate for fclonefileat.  */\n<line10>bool report_failure = is_terminal_error (errno);\n<line11>if (reflink_mode == REFLINK_ALWAYS || report_failure)\n<line12>error (0, errno, _("failed to clone %s from %s"),\n<line13>quoteaf_n (0, dst_name), quoteaf_n (1, src_name));\n<line14>/* Remove the destination if cp --reflink=always created it\n<line15>but cloned no data.  */\n<line16>if (new_dst /* currently not for fclonefileat().  */\n<line17>&& reflink_mode == REFLINK_ALWAYS\n<line18>&& ((! report_failure) || lseek (dest_desc, 0, SEEK_END) == 0)\n<line19>&& unlinkat (dst_dirfd, dst_relname, 0) != 0 && errno != ENOENT)\n<line20>error (0, errno, _("cannot remove %s"), quoteaf (dst_name));\n<line21>if (! report_failure)\n<line22>copy_debug.reflink = COPY_DEBUG_UNSUPPORTED;\n<line23>if (reflink_mode == REFLINK_ALWAYS || report_failure)\n<line24>return false;\n<line25>return true;\n<line26>}
----------------------------------------
Function: copy_reg
Content: <line0>static bool\n<line1>copy_reg (char const *src_name, char const *dst_name,\n<line2>int dst_dirfd, char const *dst_relname,\n<line3>const struct cp_options *x,\n<line4>mode_t dst_mode, mode_t omitted_permissions, bool *new_dst,\n<line5>struct stat const *src_sb)\n<line6>{\n<line7>char *buf = nullptr;\n<line8>int dest_desc;\n<line9>int dest_errno;\n<line10>int source_desc;\n<line11>mode_t src_mode = src_sb->st_mode;\n<line12>mode_t extra_permissions;\n<line13>struct stat sb;\n<line14>struct stat src_open_sb;\n<line15>union scan_inference scan_inference;\n<line16>bool return_val = true;\n<line17>bool data_copy_required = x->data_copy_required;\n<line18>bool preserve_xattr = USE_XATTR & x->preserve_xattr;\n<line19>copy_debug.offload = COPY_DEBUG_UNKNOWN;\n<line20>copy_debug.reflink = x->reflink_mode ? COPY_DEBUG_UNKNOWN : COPY_DEBUG_NO;\n<line21>copy_debug.sparse_detection = COPY_DEBUG_UNKNOWN;\n<line22>source_desc = open (src_name,\n<line23>(O_RDONLY | O_BINARY\n<line24>| (x->dereference == DEREF_NEVER ? O_NOFOLLOW : 0)));\n<line25>if (source_desc < 0)\n<line26>{\n<line27>error (0, errno, _("cannot open %s for reading"), quoteaf (src_name));\n<line28>return false;\n<line29>}\n<line30>if (fstat (source_desc, &src_open_sb) != 0)\n<line31>{\n<line32>error (0, errno, _("cannot fstat %s"), quoteaf (src_name));\n<line33>return_val = false;\n<line34>goto close_src_desc;\n<line35>}\n<line36>/* Compare the source dev/ino from the open file to the incoming,\n<line37>saved ones obtained via a previous call to stat.  */\n<line38>if (! SAME_INODE (*src_sb, src_open_sb))\n<line39>{\n<line40>error (0, 0,\n<line41>_("skipping file %s, as it was replaced while being copied"),\n<line42>quoteaf (src_name));\n<line43>return_val = false;\n<line44>goto close_src_desc;\n<line45>}\n<line46>/* The semantics of the following open calls are mandated\n<line47>by the specs for both cp and mv.  */\n<line48>if (! *new_dst)\n<line49>{\n<line50>int open_flags =\n<line51>O_WRONLY | O_BINARY | (data_copy_required ? O_TRUNC : 0);\n<line52>dest_desc = openat (dst_dirfd, dst_relname, open_flags);\n<line53>dest_errno = errno;\n<line54>/* When using cp --preserve=context to copy to an existing destination,\n<line55>reset the context as per the default context, which has already been\n<line56>set according to the src.\n<line57>When using the mutually exclusive -Z option, then adjust the type of\n<line58>the existing context according to the system default for the dest.\n<line59>Note we set the context here, _after_ the file is opened, lest the\n<line60>new context disallow that.  */\n<line61>if (0 <= dest_desc\n<line62>&& (x->set_security_context || x->preserve_security_context))\n<line63>{\n<line64>if (! set_file_security_ctx (dst_name, false, x))\n<line65>{\n<line66>if (x->require_preserve_context)\n<line67>{\n<line68>return_val = false;\n<line69>goto close_src_and_dst_desc;\n<line70>}\n<line71>}\n<line72>}\n<line73>if (dest_desc < 0 && dest_errno != ENOENT\n<line74>&& x->unlink_dest_after_failed_open)\n<line75>{\n<line76>if (unlinkat (dst_dirfd, dst_relname, 0) == 0)\n<line77>{\n<line78>if (x->verbose)\n<line79>printf (_("removed %s\n"), quoteaf (dst_name));\n<line80>}\n<line81>else if (errno != ENOENT)\n<line82>{\n<line83>error (0, errno, _("cannot remove %s"), quoteaf (dst_name));\n<line84>return_val = false;\n<line85>goto close_src_desc;\n<line86>}\n<line87>dest_errno = ENOENT;\n<line88>}\n<line89>if (dest_desc < 0 && dest_errno == ENOENT)\n<line90>{\n<line91>/* Ensure there is no race where a file may be left without\n<line92>an appropriate security context.  */\n<line93>if (x->set_security_context)\n<line94>{\n<line95>if (! set_process_security_ctx (src_name, dst_name, dst_mode,\n<line96>true, x))\n<line97>{\n<line98>return_val = false;\n<line99>goto close_src_desc;\n<line100>}\n<line101>}\n<line102>/* Tell caller that the destination file is created.  */\n<line103>*new_dst = true;\n<line104>}\n<line105>}\n<line106>if (*new_dst)\n<line107>{\n<line108>#if HAVE_FCLONEFILEAT && !USE_XATTR\n<line109># ifndef CLONE_ACL\n<line110>#  define CLONE_ACL 0 /* Added in macOS 12.6.  */\n<line111># endif\n<line112># ifndef CLONE_NOOWNERCOPY\n<line113>#  define CLONE_NOOWNERCOPY 0 /* Added in macOS 10.13.  */\n<line114># endif\n<line115>/* Try fclonefileat if copying data in reflink mode.\n<line116>Use CLONE_NOFOLLOW to avoid security issues that could occur\n<line117>if writing through dangling symlinks.  Although the circa\n<line118>2023 macOS documentation doesn't say so, CLONE_NOFOLLOW\n<line119>affects the destination file too.  */\n<line120>if (data_copy_required && x->reflink_mode\n<line121>&& (CLONE_NOOWNERCOPY || x->preserve_ownership))\n<line122>{\n<line123>/* Try fclonefileat so long as it won't create the\n<line124>destination with unwanted permissions, which could lead\n<line125>to a security race.  */\n<line126>mode_t cloned_mode_bits = S_ISVTX | S_IRWXUGO;\n<line127>mode_t cloned_mode = src_mode & cloned_mode_bits;\n<line128>mode_t desired_mode\n<line129>= (x->preserve_mode ? src_mode & CHMOD_MODE_BITS\n<line130>: x->set_mode ? x->mode\n<line131>: ((x->explicit_no_preserve_mode ? MODE_RW_UGO : dst_mode)\n<line132>& ~ cached_umask ()));\n<line133>if (! (cloned_mode & ~desired_mode))\n<line134>{\n<line135>int fc_flags\n<line136>= (CLONE_NOFOLLOW\n<line137>| (x->preserve_mode ? CLONE_ACL : 0)\n<line138>| (x->preserve_ownership ? 0 : CLONE_NOOWNERCOPY));\n<line139>int s = fclonefileat (source_desc, dst_dirfd, dst_relname,\n<line140>fc_flags);\n<line141>if (s != 0 && (fc_flags & CLONE_ACL) && errno == EINVAL)\n<line142>{\n<line143>fc_flags &= ~CLONE_ACL;\n<line144>s = fclonefileat (source_desc, dst_dirfd, dst_relname,\n<line145>fc_flags);\n<line146>}\n<line147>if (s == 0)\n<line148>{\n<line149>copy_debug.reflink = COPY_DEBUG_YES;\n<line150>/* Update the clone's timestamps and permissions\n<line151>as needed.  */\n<line152>if (!x->preserve_timestamps)\n<line153>{\n<line154>struct timespec timespec[2];\n<line155>timespec[0].tv_nsec = timespec[1].tv_nsec = UTIME_NOW;\n<line156>if (utimensat (dst_dirfd, dst_relname, timespec,\n<line157>AT_SYMLINK_NOFOLLOW)\n<line158>!= 0)\n<line159>{\n<line160>error (0, errno, _("updating times for %s"),\n<line161>quoteaf (dst_name));\n<line162>return_val = false;\n<line163>goto close_src_desc;\n<line164>}\n<line165>}\n<line166>extra_permissions = desired_mode & ~cloned_mode;\n<line167>if (!extra_permissions\n<line168>&& (!x->preserve_mode || (fc_flags & CLONE_ACL)\n<line169>|| !fd_has_acl (source_desc)))\n<line170>{\n<line171>goto close_src_desc;\n<line172>}\n<line173>/* Either some desired permissions were not cloned,\n<line174>or ACLs were not cloned despite that being requested.  */\n<line175>omitted_permissions = 0;\n<line176>dest_desc = -1;\n<line177>goto set_dest_mode;\n<line178>}\n<line179>if (! handle_clone_fail (dst_dirfd, dst_relname, src_name,\n<line180>dst_name,\n<line181>-1, false /* We didn't create dst  */,\n<line182>x->reflink_mode))\n<line183>{\n<line184>return_val = false;\n<line185>goto close_src_desc;\n<line186>}\n<line187>}\n<line188>else\n<line189>copy_debug.reflink = COPY_DEBUG_AVOIDED;\n<line190>}\n<line191>else if (data_copy_required && x->reflink_mode)\n<line192>{\n<line193>if (! CLONE_NOOWNERCOPY)\n<line194>copy_debug.reflink = COPY_DEBUG_AVOIDED;\n<line195>}\n<line196>#endif\n<line197>/* To allow copying xattrs on read-only files, create with u+w.\n<line198>This satisfies an inode permission check done by\n<line199>xattr_permission in fs/xattr.c of the GNU/Linux kernel.  */\n<line200>mode_t open_mode =\n<line201>((dst_mode & ~omitted_permissions)\n<line202>| (preserve_xattr && !x->owner_privileges ? S_IWUSR : 0));\n<line203>extra_permissions = open_mode & ~dst_mode; /* either 0 or S_IWUSR */\n<line204>int open_flags = O_WRONLY | O_CREAT | O_BINARY;\n<line205>dest_desc = openat (dst_dirfd, dst_relname, open_flags | O_EXCL,\n<line206>open_mode);\n<line207>dest_errno = errno;\n<line208>/* When trying to copy through a dangling destination symlink,\n<line209>the above open fails with EEXIST.  If that happens, and\n<line210>readlinkat shows that it is a symlink, then we\n<line211>have a problem: trying to resolve this dangling symlink to\n<line212>a directory/destination-entry pair is fundamentally racy,\n<line213>so punt.  If x->open_dangling_dest_symlink is set (cp sets\n<line214>that when POSIXLY_CORRECT is set in the environment), simply\n<line215>call open again, but without O_EXCL (potentially dangerous).\n<line216>If not, fail with a diagnostic.  These shenanigans are necessary\n<line217>only when copying, i.e., not in move_mode.  */\n<line218>if (dest_desc < 0 && dest_errno == EEXIST && ! x->move_mode)\n<line219>{\n<line220>char dummy[1];\n<line221>if (0 <= readlinkat (dst_dirfd, dst_relname, dummy, sizeof dummy))\n<line222>{\n<line223>if (x->open_dangling_dest_symlink)\n<line224>{\n<line225>dest_desc = openat (dst_dirfd, dst_relname,\n<line226>open_flags, open_mode);\n<line227>dest_errno = errno;\n<line228>}\n<line229>else\n<line230>{\n<line231>error (0, 0, _("not writing through dangling symlink %s"),\n<line232>quoteaf (dst_name));\n<line233>return_val = false;\n<line234>goto close_src_desc;\n<line235>}\n<line236>}\n<line237>}\n<line238>/* Improve quality of diagnostic when a nonexistent dst_name\n<line239>ends in a slash and open fails with errno == EISDIR.  */\n<line240>if (dest_desc < 0 && dest_errno == EISDIR\n<line241>&& *dst_name && dst_name[strlen (dst_name) - 1] == '/')\n<line242>dest_errno = ENOTDIR;\n<line243>}\n<line244>else\n<line245>{\n<line246>omitted_permissions = extra_permissions = 0;\n<line247>}\n<line248>if (dest_desc < 0)\n<line249>{\n<line250>error (0, dest_errno, _("cannot create regular file %s"),\n<line251>quoteaf (dst_name));\n<line252>return_val = false;\n<line253>goto close_src_desc;\n<line254>}\n<line255>/* --attributes-only overrides --reflink.  */\n<line256>if (data_copy_required && x->reflink_mode)\n<line257>{\n<line258>if (clone_file (dest_desc, source_desc) == 0)\n<line259>{\n<line260>data_copy_required = false;\n<line261>copy_debug.reflink = COPY_DEBUG_YES;\n<line262>}\n<line263>else\n<line264>{\n<line265>if (! handle_clone_fail (dst_dirfd, dst_relname, src_name, dst_name,\n<line266>dest_desc, *new_dst, x->reflink_mode))\n<line267>{\n<line268>return_val = false;\n<line269>goto close_src_and_dst_desc;\n<line270>}\n<line271>}\n<line272>}\n<line273>if (! (data_copy_required | x->preserve_ownership | extra_permissions))\n<line274>sb.st_mode = 0;\n<line275>else if (fstat (dest_desc, &sb) != 0)\n<line276>{\n<line277>error (0, errno, _("cannot fstat %s"), quoteaf (dst_name));\n<line278>return_val = false;\n<line279>goto close_src_and_dst_desc;\n<line280>}\n<line281>/* If extra permissions needed for copy_xattr didn't happen (e.g.,\n<line282>due to umask) chmod to add them temporarily; if that fails give\n<line283>up with extra permissions, letting copy_attr fail later.  */\n<line284>mode_t temporary_mode = sb.st_mode | extra_permissions;\n<line285>if (temporary_mode != sb.st_mode\n<line286>&& (fchmod_or_lchmod (dest_desc, dst_dirfd, dst_relname, temporary_mode)\n<line287>!= 0))\n<line288>extra_permissions = 0;\n<line289>if (data_copy_required)\n<line290>{\n<line291>/* Choose a suitable buffer size; it may be adjusted later.  */\n<line292>size_t buf_size = io_blksize (sb);\n<line293>size_t hole_size = ST_BLKSIZE (sb);\n<line294>/* Deal with sparse files.  */\n<line295>enum scantype scantype = infer_scantype (source_desc, &src_open_sb,\n<line296>&scan_inference);\n<line297>if (scantype == ERROR_SCANTYPE)\n<line298>{\n<line299>error (0, errno, _("cannot lseek %s"), quoteaf (src_name));\n<line300>return_val = false;\n<line301>goto close_src_and_dst_desc;\n<line302>}\n<line303>bool make_holes\n<line304>= (S_ISREG (sb.st_mode)\n<line305>&& (x->sparse_mode == SPARSE_ALWAYS\n<line306>|| (x->sparse_mode == SPARSE_AUTO\n<line307>&& scantype != PLAIN_SCANTYPE)));\n<line308>fdadvise (source_desc, 0, 0, FADVISE_SEQUENTIAL);\n<line309>/* If not making a sparse file, try to use a more-efficient\n<line310>buffer size.  */\n<line311>if (! make_holes)\n<line312>{\n<line313>/* Compute the least common multiple of the input and output\n<line314>buffer sizes, adjusting for outlandish values.\n<line315>Note we read in multiples of the reported block size\n<line316>to support (unusual) devices that have this constraint.  */\n<line317>size_t blcm_max = MIN (SIZE_MAX, SSIZE_MAX);\n<line318>size_t blcm = buffer_lcm (io_blksize (src_open_sb), buf_size,\n<line319>blcm_max);\n<line320>/* Do not bother with a buffer larger than the input file, plus one\n<line321>byte to make sure the file has not grown while reading it.  */\n<line322>if (S_ISREG (src_open_sb.st_mode) && src_open_sb.st_size < buf_size)\n<line323>buf_size = src_open_sb.st_size + 1;\n<line324>/* However, stick with a block size that is a positive multiple of\n<line325>blcm, overriding the above adjustments.  Watch out for\n<line326>overflow.  */\n<line327>buf_size += blcm - 1;\n<line328>buf_size -= buf_size % blcm;\n<line329>if (buf_size == 0 || blcm_max < buf_size)\n<line330>buf_size = blcm;\n<line331>}\n<line332>off_t n_read;\n<line333>bool wrote_hole_at_eof = false;\n<line334>if (! (\n<line335>#ifdef SEEK_HOLE\n<line336>scantype == LSEEK_SCANTYPE\n<line337>? lseek_copy (source_desc, dest_desc, &buf, buf_size, hole_size,\n<line338>scan_inference.ext_start, src_open_sb.st_size,\n<line339>make_holes ? x->sparse_mode : SPARSE_NEVER,\n<line340>x->reflink_mode != REFLINK_NEVER,\n<line341>src_name, dst_name)\n<line342>:\n<line343>#endif\n<line344>sparse_copy (source_desc, dest_desc, &buf, buf_size,\n<line345>make_holes ? hole_size : 0,\n<line346>x->sparse_mode == SPARSE_ALWAYS,\n<line347>x->reflink_mode != REFLINK_NEVER,\n<line348>src_name, dst_name, UINTMAX_MAX, &n_read,\n<line349>&wrote_hole_at_eof)))\n<line350>{\n<line351>return_val = false;\n<line352>goto close_src_and_dst_desc;\n<line353>}\n<line354>else if (wrote_hole_at_eof && ftruncate (dest_desc, n_read) < 0)\n<line355>{\n<line356>error (0, errno, _("failed to extend %s"), quoteaf (dst_name));\n<line357>return_val = false;\n<line358>goto close_src_and_dst_desc;\n<line359>}\n<line360>}\n<line361>if (x->preserve_timestamps)\n<line362>{\n<line363>struct timespec timespec[2];\n<line364>timespec[0] = get_stat_atime (src_sb);\n<line365>timespec[1] = get_stat_mtime (src_sb);\n<line366>if (fdutimensat (dest_desc, dst_dirfd, dst_relname, timespec, 0) != 0)\n<line367>{\n<line368>error (0, errno, _("preserving times for %s"), quoteaf (dst_name));\n<line369>if (x->require_preserve)\n<line370>{\n<line371>return_val = false;\n<line372>goto close_src_and_dst_desc;\n<line373>}\n<line374>}\n<line375>}\n<line376>/* Set ownership before xattrs as changing owners will\n<line377>clear capabilities.  */\n<line378>if (x->preserve_ownership && ! SAME_OWNER_AND_GROUP (*src_sb, sb))\n<line379>{\n<line380>switch (set_owner (x, dst_name, dst_dirfd, dst_relname, dest_desc,\n<line381>src_sb, *new_dst, &sb))\n<line382>{\n<line383>case -1:\n<line384>return_val = false;\n<line385>goto close_src_and_dst_desc;\n<line386>case 0:\n<line387>src_mode &= ~ (S_ISUID | S_ISGID | S_ISVTX);\n<line388>break;\n<line389>}\n<line390>}\n<line391>if (preserve_xattr)\n<line392>{\n<line393>if (!copy_attr (src_name, source_desc, dst_name, dest_desc, x)\n<line394>&& x->require_preserve_xattr)\n<line395>return_val = false;\n<line396>}\n<line397>set_author (dst_name, dest_desc, src_sb);\n<line398>#if HAVE_FCLONEFILEAT && !USE_XATTR\n<line399>set_dest_mode:\n<line400>#endif\n<line401>if (x->preserve_mode || x->move_mode)\n<line402>{\n<line403>if (copy_acl (src_name, source_desc, dst_name, dest_desc, src_mode) != 0\n<line404>&& x->require_preserve)\n<line405>return_val = false;\n<line406>}\n<line407>else if (x->set_mode)\n<line408>{\n<line409>if (set_acl (dst_name, dest_desc, x->mode) != 0)\n<line410>return_val = false;\n<line411>}\n<line412>else if (x->explicit_no_preserve_mode && *new_dst)\n<line413>{\n<line414>if (set_acl (dst_name, dest_desc, MODE_RW_UGO & ~cached_umask ()) != 0)\n<line415>return_val = false;\n<line416>}\n<line417>else if (omitted_permissions | extra_permissions)\n<line418>{\n<line419>omitted_permissions &= ~ cached_umask ();\n<line420>if ((omitted_permissions | extra_permissions)\n<line421>&& (fchmod_or_lchmod (dest_desc, dst_dirfd, dst_relname,\n<line422>dst_mode & ~ cached_umask ())\n<line423>!= 0))\n<line424>{\n<line425>error (0, errno, _("preserving permissions for %s"),\n<line426>quoteaf (dst_name));\n<line427>if (x->require_preserve)\n<line428>return_val = false;\n<line429>}\n<line430>}\n<line431>if (dest_desc < 0)\n<line432>goto close_src_desc;\n<line433>close_src_and_dst_desc:\n<line434>if (close (dest_desc) < 0)\n<line435>{\n<line436>error (0, errno, _("failed to close %s"), quoteaf (dst_name));\n<line437>return_val = false;\n<line438>}\n<line439>close_src_desc:\n<line440>if (close (source_desc) < 0)\n<line441>{\n<line442>error (0, errno, _("failed to close %s"), quoteaf (src_name));\n<line443>return_val = false;\n<line444>}\n<line445>/* Output debug info for data copying operations.  */\n<line446>if (x->debug)\n<line447>emit_debug (x);\n<line448>alignfree (buf);\n<line449>return return_val;\n<line450>}
----------------------------------------
Function: same_file_ok
Content: <line0>static bool\n<line1>same_file_ok (char const *src_name, struct stat const *src_sb,\n<line2>int dst_dirfd, char const *dst_relname, struct stat const *dst_sb,\n<line3>const struct cp_options *x, bool *return_now)\n<line4>{\n<line5>const struct stat *src_sb_link;\n<line6>const struct stat *dst_sb_link;\n<line7>struct stat tmp_dst_sb;\n<line8>struct stat tmp_src_sb;\n<line9>bool same_link;\n<line10>bool same = SAME_INODE (*src_sb, *dst_sb);\n<line11>*return_now = false;\n<line12>/* FIXME: this should (at the very least) be moved into the following\n<line13>if-block.  More likely, it should be removed, because it inhibits\n<line14>making backups.  But removing it will result in a change in behavior\n<line15>that will probably have to be documented -- and tests will have to\n<line16>be updated.  */\n<line17>if (same && x->hard_link)\n<line18>{\n<line19>*return_now = true;\n<line20>return true;\n<line21>}\n<line22>if (x->dereference == DEREF_NEVER)\n<line23>{\n<line24>same_link = same;\n<line25>/* If both the source and destination files are symlinks (and we'll\n<line26>know this here IFF preserving symlinks), then it's usually ok\n<line27>when they are distinct.  */\n<line28>if (S_ISLNK (src_sb->st_mode) && S_ISLNK (dst_sb->st_mode))\n<line29>{\n<line30>bool sn = same_nameat (AT_FDCWD, src_name, dst_dirfd, dst_relname);\n<line31>if ( ! sn)\n<line32>{\n<line33>/* It's fine when we're making any type of backup.  */\n<line34>if (x->backup_type != no_backups)\n<line35>return true;\n<line36>/* Here we have two symlinks that are hard-linked together,\n<line37>and we're not making backups.  In this unusual case, simply\n<line38>returning true would lead to mv calling "rename(A,B)",\n<line39>which would do nothing and return 0.  */\n<line40>if (same_link)\n<line41>{\n<line42>*return_now = true;\n<line43>return ! x->move_mode;\n<line44>}\n<line45>}\n<line46>return ! sn;\n<line47>}\n<line48>src_sb_link = src_sb;\n<line49>dst_sb_link = dst_sb;\n<line50>}\n<line51>else\n<line52>{\n<line53>if (!same)\n<line54>return true;\n<line55>if (fstatat (dst_dirfd, dst_relname, &tmp_dst_sb,\n<line56>AT_SYMLINK_NOFOLLOW) != 0\n<line57>|| lstat (src_name, &tmp_src_sb) != 0)\n<line58>return true;\n<line59>src_sb_link = &tmp_src_sb;\n<line60>dst_sb_link = &tmp_dst_sb;\n<line61>same_link = SAME_INODE (*src_sb_link, *dst_sb_link);\n<line62>/* If both are symlinks, then it's ok, but only if the destination\n<line63>will be unlinked before being opened.  This is like the test\n<line64>above, but with the addition of the unlink_dest_before_opening\n<line65>conjunct because otherwise, with two symlinks to the same target,\n<line66>we'd end up truncating the source file.  */\n<line67>if (S_ISLNK (src_sb_link->st_mode) && S_ISLNK (dst_sb_link->st_mode)\n<line68>&& x->unlink_dest_before_opening)\n<line69>return true;\n<line70>}\n<line71>/* The backup code ensures there's a copy, so it's usually ok to\n<line72>remove any destination file.  One exception is when both\n<line73>source and destination are the same directory entry.  In that\n<line74>case, moving the destination file aside (in making the backup)\n<line75>would also rename the source file and result in an error.  */\n<line76>if (x->backup_type != no_backups)\n<line77>{\n<line78>if (!same_link)\n<line79>{\n<line80>/* In copy mode when dereferencing symlinks, if the source is a\n<line81>symlink and the dest is not, then backing up the destination\n<line82>(moving it aside) would make it a dangling symlink, and the\n<line83>subsequent attempt to open it in copy_reg would fail with\n<line84>a misleading diagnostic.  Avoid that by returning zero in\n<line85>that case so the caller can make cp (or mv when it has to\n<line86>resort to reading the source file) fail now.  */\n<line87>/* FIXME-note: even with the following kludge, we can still provoke\n<line88>the offending diagnostic.  It's just a little harder to do :-)\n<line89>$ rm -f a b c; touch c; ln -s c b; ln -s b a; cp -b a b\n<line90>cp: cannot open 'a' for reading: No such file or directory\n<line91>That's misleading, since a subsequent 'ls' shows that 'a'\n<line92>is still there.\n<line93>One solution would be to open the source file *before* moving\n<line94>aside the destination, but that'd involve a big rewrite. */\n<line95>if ( ! x->move_mode\n<line96>&& x->dereference != DEREF_NEVER\n<line97>&& S_ISLNK (src_sb_link->st_mode)\n<line98>&& ! S_ISLNK (dst_sb_link->st_mode))\n<line99>return false;\n<line100>return true;\n<line101>}\n<line102>/* FIXME: What about case insensitive file systems ?  */\n<line103>return ! same_nameat (AT_FDCWD, src_name, dst_dirfd, dst_relname);\n<line104>}\n<line105>#if 0\n<line106>/* FIXME: use or remove */\n<line107>/* If we're making a backup, we'll detect the problem case in\n<line108>copy_reg because SRC_NAME will no longer exist.  Allowing\n<line109>the test to be deferred lets cp do some useful things.\n<line110>But when creating hardlinks and SRC_NAME is a symlink\n<line111>but DST_RELNAME is not we must test anyway.  */\n<line112>if (x->hard_link\n<line113>|| !S_ISLNK (src_sb_link->st_mode)\n<line114>|| S_ISLNK (dst_sb_link->st_mode))\n<line115>return true;\n<line116>if (x->dereference != DEREF_NEVER)\n<line117>return true;\n<line118>#endif\n<line119>if (x->move_mode || x->unlink_dest_before_opening)\n<line120>{\n<line121>/* They may refer to the same file if we're in move mode and the\n<line122>target is a symlink.  That is ok, since we remove any existing\n<line123>destination file before opening it -- via 'rename' if they're on\n<line124>the same file system, via unlinkat otherwise.  */\n<line125>if (S_ISLNK (dst_sb_link->st_mode))\n<line126>return true;\n<line127>/* It's not ok if they're distinct hard links to the same file as\n<line128>this causes a race condition and we may lose data in this case.  */\n<line129>if (same_link\n<line130>&& 1 < dst_sb_link->st_nlink\n<line131>&& ! same_nameat (AT_FDCWD, src_name, dst_dirfd, dst_relname))\n<line132>return ! x->move_mode;\n<line133>}\n<line134>/* If neither is a symlink, then it's ok as long as they aren't\n<line135>hard links to the same file.  */\n<line136>if (!S_ISLNK (src_sb_link->st_mode) && !S_ISLNK (dst_sb_link->st_mode))\n<line137>{\n<line138>if (!SAME_INODE (*src_sb_link, *dst_sb_link))\n<line139>return true;\n<line140>/* If they are the same file, it's ok if we're making hard links.  */\n<line141>if (x->hard_link)\n<line142>{\n<line143>*return_now = true;\n<line144>return true;\n<line145>}\n<line146>}\n<line147>/* At this point, it is normally an error (data loss) to move a symlink\n<line148>onto its referent, but in at least one narrow case, it is not:\n<line149>In move mode, when\n<line150>1) src is a symlink,\n<line151>2) dest has a link count of 2 or more and\n<line152>3) dest and the referent of src are not the same directory entry,\n<line153>then it's ok, since while we'll lose one of those hard links,\n<line154>src will still point to a remaining link.\n<line155>Note that technically, condition #3 obviates condition #2, but we\n<line156>retain the 1 < st_nlink condition because that means fewer invocations\n<line157>of the more expensive #3.\n<line158>Given this,\n<line159>$ touch f && ln f l && ln -s f s\n<line160>$ ls -og f l s\n<line161>-rw-------. 2  0 Jan  4 22:46 f\n<line162>-rw-------. 2  0 Jan  4 22:46 l\n<line163>lrwxrwxrwx. 1  1 Jan  4 22:46 s -> f\n<line164>this must fail: mv s f\n<line165>this must succeed: mv s l */\n<line166>if (x->move_mode\n<line167>&& S_ISLNK (src_sb->st_mode)\n<line168>&& 1 < dst_sb_link->st_nlink)\n<line169>{\n<line170>char *abs_src = canonicalize_file_name (src_name);\n<line171>if (abs_src)\n<line172>{\n<line173>bool result = ! same_nameat (AT_FDCWD, abs_src,\n<line174>dst_dirfd, dst_relname);\n<line175>free (abs_src);\n<line176>return result;\n<line177>}\n<line178>}\n<line179>/* It's ok to recreate a destination symlink. */\n<line180>if (x->symbolic_link && S_ISLNK (dst_sb_link->st_mode))\n<line181>return true;\n<line182>if (x->dereference == DEREF_NEVER)\n<line183>{\n<line184>if ( ! S_ISLNK (src_sb_link->st_mode))\n<line185>tmp_src_sb = *src_sb_link;\n<line186>else if (stat (src_name, &tmp_src_sb) != 0)\n<line187>return true;\n<line188>if ( ! S_ISLNK (dst_sb_link->st_mode))\n<line189>tmp_dst_sb = *dst_sb_link;\n<line190>else if (fstatat (dst_dirfd, dst_relname, &tmp_dst_sb, 0) != 0)\n<line191>return true;\n<line192>if ( ! SAME_INODE (tmp_src_sb, tmp_dst_sb))\n<line193>return true;\n<line194>if (x->hard_link)\n<line195>{\n<line196>/* It's ok to attempt to hardlink the same file,\n<line197>and return early if not replacing a symlink.\n<line198>Note we need to return early to avoid a later\n<line199>unlink() of DST (when SRC is a symlink).  */\n<line200>*return_now = ! S_ISLNK (dst_sb_link->st_mode);\n<line201>return true;\n<line202>}\n<line203>}\n<line204>return false;\n<line205>}
----------------------------------------
Function: writable_destination
Content: <line0>static bool\n<line1>writable_destination (int dst_dirfd, char const *dst_relname, mode_t mode)\n<line2>{\n<line3>return (S_ISLNK (mode)\n<line4>|| can_write_any_file ()\n<line5>|| faccessat (dst_dirfd, dst_relname, W_OK, AT_EACCESS) == 0);\n<line6>}
----------------------------------------
Function: overwrite_ok
Content: <line0>static bool\n<line1>overwrite_ok (struct cp_options const *x, char const *dst_name,\n<line2>int dst_dirfd, char const *dst_relname,\n<line3>struct stat const *dst_sb)\n<line4>{\n<line5>if (! writable_destination (dst_dirfd, dst_relname, dst_sb->st_mode))\n<line6>{\n<line7>char perms[12];		/* "-rwxrwxrwx " ls-style modes. */\n<line8>strmode (dst_sb->st_mode, perms);\n<line9>perms[10] = '\0';\n<line10>fprintf (stderr,\n<line11>(x->move_mode || x->unlink_dest_before_opening\n<line12>|| x->unlink_dest_after_failed_open)\n<line13>? _("%s: replace %s, overriding mode %04lo (%s)? ")\n<line14>: _("%s: unwritable %s (mode %04lo, %s); try anyway? "),\n<line15>program_name, quoteaf (dst_name),\n<line16>(unsigned long int) (dst_sb->st_mode & CHMOD_MODE_BITS),\n<line17>&perms[1]);\n<line18>}\n<line19>else\n<line20>{\n<line21>fprintf (stderr, _("%s: overwrite %s? "),\n<line22>program_name, quoteaf (dst_name));\n<line23>}\n<line24>return yesno ();\n<line25>}
----------------------------------------
Function: dest_info_init
Content: <line0>extern void\n<line1>dest_info_init (struct cp_options *x)\n<line2>{\n<line3>x->dest_info\n<line4>= hash_initialize (DEST_INFO_INITIAL_CAPACITY,\n<line5>nullptr,\n<line6>triple_hash,\n<line7>triple_compare,\n<line8>triple_free);\n<line9>if (! x->dest_info)\n<line10>xalloc_die ();\n<line11>}
----------------------------------------
Function: src_info_init
Content: <line0>extern void\n<line1>src_info_init (struct cp_options *x)\n<line2>{\n<line3>/* Note that we use triple_hash_no_name here.\n<line4>Contrast with the use of triple_hash above.\n<line5>That is necessary because a source file may be specified\n<line6>in many different ways.  We want to warn about this\n<line7>cp a a d/\n<line8>as well as this:\n<line9>cp a ./a d/\n<line10>*/\n<line11>x->src_info\n<line12>= hash_initialize (DEST_INFO_INITIAL_CAPACITY,\n<line13>nullptr,\n<line14>triple_hash_no_name,\n<line15>triple_compare,\n<line16>triple_free);\n<line17>if (! x->src_info)\n<line18>xalloc_die ();\n<line19>}
----------------------------------------
Function: abandon_move
Content: <line0>static bool\n<line1>abandon_move (const struct cp_options *x,\n<line2>char const *dst_name,\n<line3>int dst_dirfd, char const *dst_relname,\n<line4>struct stat const *dst_sb)\n<line5>{\n<line6>affirm (x->move_mode);\n<line7>return (x->interactive == I_ALWAYS_NO\n<line8>|| x->interactive == I_ALWAYS_SKIP\n<line9>|| ((x->interactive == I_ASK_USER\n<line10>|| (x->interactive == I_UNSPECIFIED\n<line11>&& x->stdin_tty\n<line12>&& ! writable_destination (dst_dirfd, dst_relname,\n<line13>dst_sb->st_mode)))\n<line14>&& ! overwrite_ok (x, dst_name, dst_dirfd, dst_relname, dst_sb)));\n<line15>}
----------------------------------------
Function: emit_verbose
Content: <line0>static void\n<line1>emit_verbose (char const *src, char const *dst, char const *backup_dst_name)\n<line2>{\n<line3>printf ("%s -> %s", quoteaf_n (0, src), quoteaf_n (1, dst));\n<line4>if (backup_dst_name)\n<line5>printf (_(" (backup: %s)"), quoteaf (backup_dst_name));\n<line6>putchar ('\n');\n<line7>}
----------------------------------------
Function: restore_default_fscreatecon_or_die
Content: <line0>static void\n<line1>restore_default_fscreatecon_or_die (void)\n<line2>{\n<line3>if (setfscreatecon (nullptr) != 0)\n<line4>error (EXIT_FAILURE, errno,\n<line5>_("failed to restore the default file creation context"));\n<line6>}
----------------------------------------
Function: subst_suffix
Content: <line0>static char *\n<line1>subst_suffix (char const *str, char const *suffix, char const *newsuffix)\n<line2>{\n<line3>idx_t prefixlen = suffix - str;\n<line4>idx_t newsuffixsize = strlen (newsuffix) + 1;\n<line5>char *r = ximalloc (prefixlen + newsuffixsize);\n<line6>memcpy (r + prefixlen, newsuffix, newsuffixsize);\n<line7>return memcpy (r, str, prefixlen);\n<line8>}
----------------------------------------
Function: create_hard_link
Content: <line0>static bool\n<line1>create_hard_link (char const *src_name, int src_dirfd, char const *src_relname,\n<line2>char const *dst_name, int dst_dirfd, char const *dst_relname,\n<line3>bool replace, bool verbose, bool dereference)\n<line4>{\n<line5>int err = force_linkat (src_dirfd, src_relname, dst_dirfd, dst_relname,\n<line6>dereference ? AT_SYMLINK_FOLLOW : 0,\n<line7>replace, -1);\n<line8>if (0 < err)\n<line9>{\n<line10>char *a_src_name = nullptr;\n<line11>if (!src_name)\n<line12>src_name = a_src_name = subst_suffix (dst_name, dst_relname,\n<line13>src_relname);\n<line14>error (0, err, _("cannot create hard link %s to %s"),\n<line15>quoteaf_n (0, dst_name), quoteaf_n (1, src_name));\n<line16>free (a_src_name);\n<line17>return false;\n<line18>}\n<line19>if (err < 0 && verbose)\n<line20>printf (_("removed %s\n"), quoteaf (dst_name));\n<line21>return true;\n<line22>}
----------------------------------------
Function: source_is_dst_backup
Content: <line0>static bool\n<line1>source_is_dst_backup (char const *srcbase, struct stat const *src_st,\n<line2>int dst_dirfd, char const *dst_relname)\n<line3>{\n<line4>size_t srcbaselen = strlen (srcbase);\n<line5>char const *dstbase = last_component (dst_relname);\n<line6>size_t dstbaselen = strlen (dstbase);\n<line7>size_t suffixlen = strlen (simple_backup_suffix);\n<line8>if (! (srcbaselen == dstbaselen + suffixlen\n<line9>&& memcmp (srcbase, dstbase, dstbaselen) == 0\n<line10>&& STREQ (srcbase + dstbaselen, simple_backup_suffix)))\n<line11>return false;\n<line12>char *dst_back = subst_suffix (dst_relname,\n<line13>dst_relname + strlen (dst_relname),\n<line14>simple_backup_suffix);\n<line15>struct stat dst_back_sb;\n<line16>int dst_back_status = fstatat (dst_dirfd, dst_back, &dst_back_sb, 0);\n<line17>free (dst_back);\n<line18>return dst_back_status == 0 && SAME_INODE (*src_st, dst_back_sb);\n<line19>}
----------------------------------------
Function: copy_internal
Content: <line0>static bool\n<line1>copy_internal (char const *src_name, char const *dst_name,\n<line2>int dst_dirfd, char const *dst_relname,\n<line3>int nonexistent_dst,\n<line4>struct stat const *parent,\n<line5>struct dir_list *ancestors,\n<line6>const struct cp_options *x,\n<line7>bool command_line_arg,\n<line8>bool *first_dir_created_per_command_line_arg,\n<line9>bool *copy_into_self,\n<line10>bool *rename_succeeded)\n<line11>{\n<line12>struct stat src_sb;\n<line13>struct stat dst_sb;\n<line14>mode_t src_mode IF_LINT ( = 0);\n<line15>mode_t dst_mode IF_LINT ( = 0);\n<line16>mode_t dst_mode_bits;\n<line17>mode_t omitted_permissions;\n<line18>bool restore_dst_mode = false;\n<line19>char *earlier_file = nullptr;\n<line20>char *dst_backup = nullptr;\n<line21>char const *drelname = *dst_relname ? dst_relname : ".";\n<line22>bool delayed_ok;\n<line23>bool copied_as_regular = false;\n<line24>bool dest_is_symlink = false;\n<line25>bool have_dst_lstat = false;\n<line26>/* Whether the destination is (or was) known to be new, updated as\n<line27>more info comes in.  This may become true if the destination is a\n<line28>dangling symlink, in contexts where dangling symlinks should be\n<line29>treated the same as nonexistent files.  */\n<line30>bool new_dst = 0 < nonexistent_dst;\n<line31>*copy_into_self = false;\n<line32>int rename_errno = x->rename_errno;\n<line33>if (x->move_mode)\n<line34>{\n<line35>if (rename_errno < 0)\n<line36>rename_errno = (renameatu (AT_FDCWD, src_name, dst_dirfd, drelname,\n<line37>RENAME_NOREPLACE)\n<line38>? errno : 0);\n<line39>nonexistent_dst = *rename_succeeded = new_dst = rename_errno == 0;\n<line40>}\n<line41>if (rename_errno == 0\n<line42>? !x->last_file\n<line43>: rename_errno != EEXIST\n<line44>|| (x->interactive != I_ALWAYS_NO && x->interactive != I_ALWAYS_SKIP))\n<line45>{\n<line46>char const *name = rename_errno == 0 ? dst_name : src_name;\n<line47>int dirfd = rename_errno == 0 ? dst_dirfd : AT_FDCWD;\n<line48>char const *relname = rename_errno == 0 ? drelname : src_name;\n<line49>int fstatat_flags\n<line50>= x->dereference == DEREF_NEVER ? AT_SYMLINK_NOFOLLOW : 0;\n<line51>if (follow_fstatat (dirfd, relname, &src_sb, fstatat_flags) != 0)\n<line52>{\n<line53>error (0, errno, _("cannot stat %s"), quoteaf (name));\n<line54>return false;\n<line55>}\n<line56>src_mode = src_sb.st_mode;\n<line57>if (S_ISDIR (src_mode) && !x->recursive)\n<line58>{\n<line59>error (0, 0, ! x->install_mode /* cp */\n<line60>? _("-r not specified; omitting directory %s")\n<line61>: _("omitting directory %s"),\n<line62>quoteaf (src_name));\n<line63>return false;\n<line64>}\n<line65>}\n<line66>else\n<line67>{\n<line68>#if defined lint && (defined __clang__ || defined __COVERITY__)\n<line69>affirm (x->move_mode);\n<line70>memset (&src_sb, 0, sizeof src_sb);\n<line71>#endif\n<line72>}\n<line73>/* Detect the case in which the same source file appears more than\n<line74>once on the command line and no backup option has been selected.\n<line75>If so, simply warn and don't copy it the second time.\n<line76>This check is enabled only if x->src_info is non-null.  */\n<line77>if (command_line_arg && x->src_info)\n<line78>{\n<line79>if ( ! S_ISDIR (src_mode)\n<line80>&& x->backup_type == no_backups\n<line81>&& seen_file (x->src_info, src_name, &src_sb))\n<line82>{\n<line83>error (0, 0, _("warning: source file %s specified more than once"),\n<line84>quoteaf (src_name));\n<line85>return true;\n<line86>}\n<line87>record_file (x->src_info, src_name, &src_sb);\n<line88>}\n<line89>bool dereference = should_dereference (x, command_line_arg);\n<line90>if (nonexistent_dst <= 0)\n<line91>{\n<line92>if (! (rename_errno == EEXIST\n<line93>&& (x->interactive == I_ALWAYS_NO\n<line94>|| x->interactive == I_ALWAYS_SKIP)))\n<line95>{\n<line96>/* Regular files can be created by writing through symbolic\n<line97>links, but other files cannot.  So use stat on the\n<line98>destination when copying a regular file, and lstat otherwise.\n<line99>However, if we intend to unlink or remove the destination\n<line100>first, use lstat, since a copy won't actually be made to the\n<line101>destination in that case.  */\n<line102>bool use_lstat\n<line103>= ((! S_ISREG (src_mode)\n<line104>&& (! x->copy_as_regular\n<line105>|| S_ISDIR (src_mode) || S_ISLNK (src_mode)))\n<line106>|| x->move_mode || x->symbolic_link || x->hard_link\n<line107>|| x->backup_type != no_backups\n<line108>|| x->unlink_dest_before_opening);\n<line109>int fstatat_flags = use_lstat ? AT_SYMLINK_NOFOLLOW : 0;\n<line110>if (!use_lstat && nonexistent_dst < 0)\n<line111>new_dst = true;\n<line112>else if (follow_fstatat (dst_dirfd, drelname, &dst_sb, fstatat_flags)\n<line113>== 0)\n<line114>{\n<line115>have_dst_lstat = use_lstat;\n<line116>rename_errno = EEXIST;\n<line117>}\n<line118>else\n<line119>{\n<line120>if (errno == ELOOP && x->unlink_dest_after_failed_open)\n<line121>/* leave new_dst=false so we unlink later.  */;\n<line122>else if (errno != ENOENT)\n<line123>{\n<line124>error (0, errno, _("cannot stat %s"), quoteaf (dst_name));\n<line125>return false;\n<line126>}\n<line127>else\n<line128>new_dst = true;\n<line129>}\n<line130>}\n<line131>if (rename_errno == EEXIST)\n<line132>{\n<line133>bool return_now = false;\n<line134>bool return_val = true;\n<line135>bool skipped = false;\n<line136>if ((x->interactive != I_ALWAYS_NO && x->interactive != I_ALWAYS_SKIP)\n<line137>&& ! same_file_ok (src_name, &src_sb, dst_dirfd, drelname,\n<line138>&dst_sb, x, &return_now))\n<line139>{\n<line140>error (0, 0, _("%s and %s are the same file"),\n<line141>quoteaf_n (0, src_name), quoteaf_n (1, dst_name));\n<line142>return false;\n<line143>}\n<line144>if (x->update && !S_ISDIR (src_mode))\n<line145>{\n<line146>/* When preserving timestamps (but not moving within a file\n<line147>system), don't worry if the destination timestamp is\n<line148>less than the source merely because of timestamp\n<line149>truncation.  */\n<line150>int options = ((x->preserve_timestamps\n<line151>&& ! (x->move_mode\n<line152>&& dst_sb.st_dev == src_sb.st_dev))\n<line153>? UTIMECMP_TRUNCATE_SOURCE\n<line154>: 0);\n<line155>if (0 <= utimecmpat (dst_dirfd, dst_relname, &dst_sb,\n<line156>&src_sb, options))\n<line157>{\n<line158>/* We're using --update and the destination is not older\n<line159>than the source, so do not copy or move.  Pretend the\n<line160>rename succeeded, so the caller (if it's mv) doesn't\n<line161>end up removing the source file.  */\n<line162>if (rename_succeeded)\n<line163>*rename_succeeded = true;\n<line164>/* However, we still must record that we've processed\n<line165>this src/dest pair, in case this source file is\n<line166>hard-linked to another one.  In that case, we'll use\n<line167>the mapping information to link the corresponding\n<line168>destination names.  */\n<line169>earlier_file = remember_copied (dst_relname, src_sb.st_ino,\n<line170>src_sb.st_dev);\n<line171>if (earlier_file)\n<line172>{\n<line173>/* Note we currently replace DST_NAME unconditionally,\n<line174>even if it was a newer separate file.  */\n<line175>if (! create_hard_link (nullptr, dst_dirfd, earlier_file,\n<line176>dst_name, dst_dirfd, dst_relname,\n<line177>true,\n<line178>x->verbose, dereference))\n<line179>{\n<line180>goto un_backup;\n<line181>}\n<line182>}\n<line183>skipped = true;\n<line184>goto skip;\n<line185>}\n<line186>}\n<line187>/* When there is an existing destination file, we may end up\n<line188>returning early, and hence not copying/moving the file.\n<line189>This may be due to an interactive 'negative' reply to the\n<line190>prompt about the existing file.  It may also be due to the\n<line191>use of the --no-clobber option.\n<line192>cp and mv treat -i and -f differently.  */\n<line193>if (x->move_mode)\n<line194>{\n<line195>if (abandon_move (x, dst_name, dst_dirfd, drelname, &dst_sb))\n<line196>{\n<line197>/* Pretend the rename succeeded, so the caller (mv)\n<line198>doesn't end up removing the source file.  */\n<line199>if (rename_succeeded)\n<line200>*rename_succeeded = true;\n<line201>skipped = true;\n<line202>return_val = x->interactive == I_ALWAYS_SKIP;\n<line203>}\n<line204>}\n<line205>else\n<line206>{\n<line207>if (! S_ISDIR (src_mode)\n<line208>&& (x->interactive == I_ALWAYS_NO\n<line209>|| x->interactive == I_ALWAYS_SKIP\n<line210>|| (x->interactive == I_ASK_USER\n<line211>&& ! overwrite_ok (x, dst_name, dst_dirfd,\n<line212>dst_relname, &dst_sb))))\n<line213>{\n<line214>skipped = true;\n<line215>return_val = x->interactive == I_ALWAYS_SKIP;\n<line216>}\n<line217>}\n<line218>skip:\n<line219>if (skipped)\n<line220>{\n<line221>if (x->interactive == I_ALWAYS_NO)\n<line222>error (0, 0, _("not replacing %s"), quoteaf (dst_name));\n<line223>else if (x->debug)\n<line224>printf (_("skipped %s\n"), quoteaf (dst_name));\n<line225>return_now = true;\n<line226>}\n<line227>if (return_now)\n<line228>return return_val;\n<line229>if (!S_ISDIR (dst_sb.st_mode))\n<line230>{\n<line231>if (S_ISDIR (src_mode))\n<line232>{\n<line233>if (x->move_mode && x->backup_type != no_backups)\n<line234>{\n<line235>/* Moving a directory onto an existing\n<line236>non-directory is ok only with --backup.  */\n<line237>}\n<line238>else\n<line239>{\n<line240>error (0, 0,\n<line241>_("cannot overwrite non-directory %s with directory %s"),\n<line242>quoteaf_n (0, dst_name), quoteaf_n (1, src_name));\n<line243>return false;\n<line244>}\n<line245>}\n<line246>/* Don't let the user destroy their data, even if they try hard:\n<line247>This mv command must fail (likewise for cp):\n<line248>rm -rf a b c; mkdir a b c; touch a/f b/f; mv a/f b/f c\n<line249>Otherwise, the contents of b/f would be lost.\n<line250>In the case of 'cp', b/f would be lost if the user simulated\n<line251>a move using cp and rm.\n<line252>Note that it works fine if you use --backup=numbered.  */\n<line253>if (command_line_arg\n<line254>&& x->backup_type != numbered_backups\n<line255>&& seen_file (x->dest_info, dst_relname, &dst_sb))\n<line256>{\n<line257>error (0, 0,\n<line258>_("will not overwrite just-created %s with %s"),\n<line259>quoteaf_n (0, dst_name), quoteaf_n (1, src_name));\n<line260>return false;\n<line261>}\n<line262>}\n<line263>if (!S_ISDIR (src_mode))\n<line264>{\n<line265>if (S_ISDIR (dst_sb.st_mode))\n<line266>{\n<line267>if (x->move_mode && x->backup_type != no_backups)\n<line268>{\n<line269>/* Moving a non-directory onto an existing\n<line270>directory is ok only with --backup.  */\n<line271>}\n<line272>else\n<line273>{\n<line274>error (0, 0,\n<line275>_("cannot overwrite directory %s with non-directory"),\n<line276>quoteaf (dst_name));\n<line277>return false;\n<line278>}\n<line279>}\n<line280>}\n<line281>if (x->move_mode)\n<line282>{\n<line283>/* Don't allow user to move a directory onto a non-directory.  */\n<line284>if (S_ISDIR (src_sb.st_mode) && !S_ISDIR (dst_sb.st_mode)\n<line285>&& x->backup_type == no_backups)\n<line286>{\n<line287>error (0, 0,\n<line288>_("cannot move directory onto non-directory: %s -> %s"),\n<line289>quotef_n (0, src_name), quotef_n (0, dst_name));\n<line290>return false;\n<line291>}\n<line292>}\n<line293>char const *srcbase;\n<line294>if (x->backup_type != no_backups\n<line295>/* Don't try to back up a destination if the last\n<line296>component of src_name is "." or "..".  */\n<line297>&& ! dot_or_dotdot (srcbase = last_component (src_name))\n<line298>/* Create a backup of each destination directory in move mode,\n<line299>but not in copy mode.  FIXME: it might make sense to add an\n<line300>option to suppress backup creation also for move mode.\n<line301>That would let one use mv to merge new content into an\n<line302>existing hierarchy.  */\n<line303>&& (x->move_mode || ! S_ISDIR (dst_sb.st_mode)))\n<line304>{\n<line305>/* Fail if creating the backup file would likely destroy\n<line306>the source file.  Otherwise, the commands:\n<line307>cd /tmp; rm -f a a~; : > a; echo A > a~; cp --b=simple a~ a\n<line308>would leave two zero-length files: a and a~.  */\n<line309>if (x->backup_type != numbered_backups\n<line310>&& source_is_dst_backup (srcbase, &src_sb,\n<line311>dst_dirfd, dst_relname))\n<line312>{\n<line313>char const *fmt;\n<line314>fmt = (x->move_mode\n<line315>? _("backing up %s might destroy source;  %s not moved")\n<line316>: _("backing up %s might destroy source;  %s not copied"));\n<line317>error (0, 0, fmt,\n<line318>quoteaf_n (0, dst_name),\n<line319>quoteaf_n (1, src_name));\n<line320>return false;\n<line321>}\n<line322>char *tmp_backup = backup_file_rename (dst_dirfd, dst_relname,\n<line323>x->backup_type);\n<line324>/* FIXME: use fts:\n<line325>Using alloca for a file name that may be arbitrarily\n<line326>long is not recommended.  In fact, even forming such a name\n<line327>should be discouraged.  Eventually, this code will be rewritten\n<line328>to use fts, so using alloca here will be less of a problem.  */\n<line329>if (tmp_backup)\n<line330>{\n<line331>idx_t dirlen = dst_relname - dst_name;\n<line332>idx_t backupsize = strlen (tmp_backup) + 1;\n<line333>dst_backup = alloca (dirlen + backupsize);\n<line334>memcpy (mempcpy (dst_backup, dst_name, dirlen),\n<line335>tmp_backup, backupsize);\n<line336>free (tmp_backup);\n<line337>}\n<line338>else if (errno != ENOENT)\n<line339>{\n<line340>error (0, errno, _("cannot backup %s"), quoteaf (dst_name));\n<line341>return false;\n<line342>}\n<line343>new_dst = true;\n<line344>}\n<line345>else if (! S_ISDIR (dst_sb.st_mode)\n<line346>/* Never unlink dst_name when in move mode.  */\n<line347>&& ! x->move_mode\n<line348>&& (x->unlink_dest_before_opening\n<line349>|| (x->data_copy_required\n<line350>&& ((x->preserve_links && 1 < dst_sb.st_nlink)\n<line351>|| (x->dereference == DEREF_NEVER\n<line352>&& ! S_ISREG (src_sb.st_mode))))\n<line353>))\n<line354>{\n<line355>if (unlinkat (dst_dirfd, dst_relname, 0) != 0 && errno != ENOENT)\n<line356>{\n<line357>error (0, errno, _("cannot remove %s"), quoteaf (dst_name));\n<line358>return false;\n<line359>}\n<line360>new_dst = true;\n<line361>if (x->verbose)\n<line362>printf (_("removed %s\n"), quoteaf (dst_name));\n<line363>}\n<line364>}\n<line365>}\n<line366>/* Ensure we don't try to copy through a symlink that was\n<line367>created by a prior call to this function.  */\n<line368>if (command_line_arg\n<line369>&& x->dest_info\n<line370>&& ! x->move_mode\n<line371>&& x->backup_type == no_backups)\n<line372>{\n<line373>bool lstat_ok = true;\n<line374>struct stat tmp_buf;\n<line375>struct stat *dst_lstat_sb;\n<line376>/* If we did not follow symlinks above, good: use that data.\n<line377>Otherwise, use AT_SYMLINK_NOFOLLOW, in case dst_name is a symlink.  */\n<line378>if (have_dst_lstat)\n<line379>dst_lstat_sb = &dst_sb;\n<line380>else if (fstatat (dst_dirfd, drelname, &tmp_buf, AT_SYMLINK_NOFOLLOW)\n<line381>== 0)\n<line382>dst_lstat_sb = &tmp_buf;\n<line383>else\n<line384>lstat_ok = false;\n<line385>/* Never copy through a symlink we've just created.  */\n<line386>if (lstat_ok\n<line387>&& S_ISLNK (dst_lstat_sb->st_mode)\n<line388>&& seen_file (x->dest_info, dst_relname, dst_lstat_sb))\n<line389>{\n<line390>error (0, 0,\n<line391>_("will not copy %s through just-created symlink %s"),\n<line392>quoteaf_n (0, src_name), quoteaf_n (1, dst_name));\n<line393>return false;\n<line394>}\n<line395>}\n<line396>/* If the source is a directory, we don't always create the destination\n<line397>directory.  So --verbose should not announce anything until we're\n<line398>sure we'll create a directory.  Also don't announce yet when moving\n<line399>so we can distinguish renames versus copies.  */\n<line400>if (x->verbose && !x->move_mode && !S_ISDIR (src_mode))\n<line401>emit_verbose (src_name, dst_name, dst_backup);\n<line402>/* Associate the destination file name with the source device and inode\n<line403>so that if we encounter a matching dev/ino pair in the source tree\n<line404>we can arrange to create a hard link between the corresponding names\n<line405>in the destination tree.\n<line406>When using the --link (-l) option, there is no need to take special\n<line407>measures, because (barring race conditions) files that are hard-linked\n<line408>in the source tree will also be hard-linked in the destination tree.\n<line409>Sometimes, when preserving links, we have to record dev/ino even\n<line410>though st_nlink == 1:\n<line411>- when in move_mode, since we may be moving a group of N hard-linked\n<line412>files (via two or more command line arguments) to a different\n<line413>partition; the links may be distributed among the command line\n<line414>arguments (possibly hierarchies) so that the link count of\n<line415>the final, once-linked source file is reduced to 1 when it is\n<line416>considered below.  But in this case (for mv) we don't need to\n<line417>incur the expense of recording the dev/ino => name mapping; all we\n<line418>really need is a lookup, to see if the dev/ino pair has already\n<line419>been copied.\n<line420>- when using -H and processing a command line argument;\n<line421>that command line argument could be a symlink pointing to another\n<line422>command line argument.  With 'cp -H --preserve=link', we hard-link\n<line423>those two destination files.\n<line424>- likewise for -L except that it applies to all files, not just\n<line425>command line arguments.\n<line426>Also, with --recursive, record dev/ino of each command-line directory.\n<line427>We'll use that info to detect this problem: cp -R dir dir.  */\n<line428>if (rename_errno == 0)\n<line429>earlier_file = nullptr;\n<line430>else if (x->recursive && S_ISDIR (src_mode))\n<line431>{\n<line432>if (command_line_arg)\n<line433>earlier_file = remember_copied (dst_relname,\n<line434>src_sb.st_ino, src_sb.st_dev);\n<line435>else\n<line436>earlier_file = src_to_dest_lookup (src_sb.st_ino, src_sb.st_dev);\n<line437>}\n<line438>else if (x->move_mode && src_sb.st_nlink == 1)\n<line439>{\n<line440>earlier_file = src_to_dest_lookup (src_sb.st_ino, src_sb.st_dev);\n<line441>}\n<line442>else if (x->preserve_links\n<line443>&& !x->hard_link\n<line444>&& (1 < src_sb.st_nlink\n<line445>|| (command_line_arg\n<line446>&& x->dereference == DEREF_COMMAND_LINE_ARGUMENTS)\n<line447>|| x->dereference == DEREF_ALWAYS))\n<line448>{\n<line449>earlier_file = remember_copied (dst_relname,\n<line450>src_sb.st_ino, src_sb.st_dev);\n<line451>}\n<line452>/* Did we copy this inode somewhere else (in this command line argument)\n<line453>and therefore this is a second hard link to the inode?  */\n<line454>if (earlier_file)\n<line455>{\n<line456>/* Avoid damaging the destination file system by refusing to preserve\n<line457>hard-linked directories (which are found at least in Netapp snapshot\n<line458>directories).  */\n<line459>if (S_ISDIR (src_mode))\n<line460>{\n<line461>/* If src_name and earlier_file refer to the same directory entry,\n<line462>then warn about copying a directory into itself.  */\n<line463>if (same_nameat (AT_FDCWD, src_name, dst_dirfd, earlier_file))\n<line464>{\n<line465>error (0, 0, _("cannot copy a directory, %s, into itself, %s"),\n<line466>quoteaf_n (0, top_level_src_name),\n<line467>quoteaf_n (1, top_level_dst_name));\n<line468>*copy_into_self = true;\n<line469>goto un_backup;\n<line470>}\n<line471>else if (same_nameat (dst_dirfd, dst_relname,\n<line472>dst_dirfd, earlier_file))\n<line473>{\n<line474>error (0, 0, _("warning: source directory %s "\n<line475>"specified more than once"),\n<line476>quoteaf (top_level_src_name));\n<line477>/* In move mode, if a previous rename succeeded, then\n<line478>we won't be in this path as the source is missing.  If the\n<line479>rename previously failed, then that has been handled, so\n<line480>pretend this attempt succeeded so the source isn't removed.  */\n<line481>if (x->move_mode && rename_succeeded)\n<line482>*rename_succeeded = true;\n<line483>/* We only do backups in move mode, and for non directories.\n<line484>So just ignore this repeated entry.  */\n<line485>return true;\n<line486>}\n<line487>else if (x->dereference == DEREF_ALWAYS\n<line488>|| (command_line_arg\n<line489>&& x->dereference == DEREF_COMMAND_LINE_ARGUMENTS))\n<line490>{\n<line491>/* This happens when e.g., encountering a directory for the\n<line492>second or subsequent time via symlinks when cp is invoked\n<line493>with -R and -L.  E.g.,\n<line494>rm -rf a b c d; mkdir a b c d; ln -s ../c a; ln -s ../c b;\n<line495>cp -RL a b d\n<line496>*/\n<line497>}\n<line498>else\n<line499>{\n<line500>char *earlier = subst_suffix (dst_name, dst_relname,\n<line501>earlier_file);\n<line502>error (0, 0, _("will not create hard link %s to directory %s"),\n<line503>quoteaf_n (0, dst_name), quoteaf_n (1, earlier));\n<line504>free (earlier);\n<line505>goto un_backup;\n<line506>}\n<line507>}\n<line508>else\n<line509>{\n<line510>if (! create_hard_link (nullptr, dst_dirfd, earlier_file,\n<line511>dst_name, dst_dirfd, dst_relname,\n<line512>true, x->verbose, dereference))\n<line513>goto un_backup;\n<line514>return true;\n<line515>}\n<line516>}\n<line517>if (x->move_mode)\n<line518>{\n<line519>if (rename_errno == EEXIST)\n<line520>rename_errno = (renameat (AT_FDCWD, src_name, dst_dirfd, drelname) == 0\n<line521>? 0 : errno);\n<line522>if (rename_errno == 0)\n<line523>{\n<line524>if (x->verbose)\n<line525>{\n<line526>printf (_("renamed "));\n<line527>emit_verbose (src_name, dst_name, dst_backup);\n<line528>}\n<line529>if (x->set_security_context)\n<line530>{\n<line531>/* -Z failures are only warnings currently.  */\n<line532>(void) set_file_security_ctx (dst_name, true, x);\n<line533>}\n<line534>if (rename_succeeded)\n<line535>*rename_succeeded = true;\n<line536>if (command_line_arg && !x->last_file)\n<line537>{\n<line538>/* Record destination dev/ino/name, so that if we are asked\n<line539>to overwrite that file again, we can detect it and fail.  */\n<line540>/* It's fine to use the _source_ stat buffer (src_sb) to get the\n<line541>_destination_ dev/ino, since the rename above can't have\n<line542>changed those, and 'mv' always uses lstat.\n<line543>We could limit it further by operating\n<line544>only on non-directories.  */\n<line545>record_file (x->dest_info, dst_relname, &src_sb);\n<line546>}\n<line547>return true;\n<line548>}\n<line549>/* FIXME: someday, consider what to do when moving a directory into\n<line550>itself but when source and destination are on different devices.  */\n<line551>/* This happens when attempting to rename a directory to a\n<line552>subdirectory of itself.  */\n<line553>if (rename_errno == EINVAL)\n<line554>{\n<line555>/* FIXME: this is a little fragile in that it relies on rename(2)\n<line556>failing with a specific errno value.  Expect problems on\n<line557>non-POSIX systems.  */\n<line558>error (0, 0, _("cannot move %s to a subdirectory of itself, %s"),\n<line559>quoteaf_n (0, top_level_src_name),\n<line560>quoteaf_n (1, top_level_dst_name));\n<line561>/* Note that there is no need to call forget_created here,\n<line562>(compare with the other calls in this file) since the\n<line563>destination directory didn't exist before.  */\n<line564>*copy_into_self = true;\n<line565>/* FIXME-cleanup: Don't return true here; adjust mv.c accordingly.\n<line566>The only caller that uses this code (mv.c) ends up setting its\n<line567>exit status to nonzero when copy_into_self is nonzero.  */\n<line568>return true;\n<line569>}\n<line570>/* WARNING: there probably exist systems for which an inter-device\n<line571>rename fails with a value of errno not handled here.\n<line572>If/as those are reported, add them to the condition below.\n<line573>If this happens to you, please do the following and send the output\n<line574>to the bug-reporting address (e.g., in the output of cp --help):\n<line575>touch k; perl -e 'rename "k","/tmp/k" or print "$!(",$!+0,")\n"'\n<line576>where your current directory is on one partition and /tmp is the other.\n<line577>Also, please try to find the E* errno macro name corresponding to\n<line578>the diagnostic and parenthesized integer, and include that in your\n<line579>e-mail.  One way to do that is to run a command like this\n<line580>find /usr/include/. -type f \\n<line581>| xargs grep 'define.*\<E[A-Z]*\>.*\<18\>' /dev/null\n<line582>where you'd replace '18' with the integer in parentheses that\n<line583>was output from the perl one-liner above.\n<line584>If necessary, of course, change '/tmp' to some other directory.  */\n<line585>if (rename_errno != EXDEV || x->no_copy)\n<line586>{\n<line587>/* There are many ways this can happen due to a race condition.\n<line588>When something happens between the initial follow_fstatat and the\n<line589>subsequent rename, we can get many different types of errors.\n<line590>For example, if the destination is initially a non-directory\n<line591>or non-existent, but it is created as a directory, the rename\n<line592>fails.  If two 'mv' commands try to rename the same file at\n<line593>about the same time, one will succeed and the other will fail.\n<line594>If the permissions on the directory containing the source or\n<line595>destination file are made too restrictive, the rename will\n<line596>fail.  Etc.  */\n<line597>char const *quoted_dst_name = quoteaf_n (1, dst_name);\n<line598>switch (rename_errno)\n<line599>{\n<line600>case EDQUOT: case EEXIST: case EISDIR: case EMLINK:\n<line601>case ENOSPC: case ETXTBSY:\n<line602>#if ENOTEMPTY != EEXIST\n<line603>case ENOTEMPTY:\n<line604>#endif\n<line605>/* The destination must be the problem.  Don't mention\n<line606>the source as that is more likely to confuse the user\n<line607>than be helpful.  */\n<line608>error (0, rename_errno, _("cannot overwrite %s"),\n<line609>quoted_dst_name);\n<line610>break;\n<line611>default:\n<line612>error (0, rename_errno, _("cannot move %s to %s"),\n<line613>quoteaf_n (0, src_name), quoted_dst_name);\n<line614>break;\n<line615>}\n<line616>forget_created (src_sb.st_ino, src_sb.st_dev);\n<line617>return false;\n<line618>}\n<line619>/* The rename attempt has failed.  Remove any existing destination\n<line620>file so that a cross-device 'mv' acts as if it were really using\n<line621>the rename syscall.  Note both src and dst must both be directories\n<line622>or not, and this is enforced above.  Therefore we check the src_mode\n<line623>and operate on dst_name here as a tighter constraint and also because\n<line624>src_mode is readily available here.  */\n<line625>if ((unlinkat (dst_dirfd, drelname,\n<line626>S_ISDIR (src_mode) ? AT_REMOVEDIR : 0)\n<line627>!= 0)\n<line628>&& errno != ENOENT)\n<line629>{\n<line630>error (0, errno,\n<line631>_("inter-device move failed: %s to %s; unable to remove target"),\n<line632>quoteaf_n (0, src_name), quoteaf_n (1, dst_name));\n<line633>forget_created (src_sb.st_ino, src_sb.st_dev);\n<line634>return false;\n<line635>}\n<line636>if (x->verbose && !S_ISDIR (src_mode))\n<line637>{\n<line638>printf (_("copied "));\n<line639>emit_verbose (src_name, dst_name, dst_backup);\n<line640>}\n<line641>new_dst = true;\n<line642>}\n<line643>/* If the ownership might change, or if it is a directory (whose\n<line644>special mode bits may change after the directory is created),\n<line645>omit some permissions at first, so unauthorized users cannot nip\n<line646>in before the file is ready.  */\n<line647>dst_mode_bits = (x->set_mode ? x->mode : src_mode) & CHMOD_MODE_BITS;\n<line648>omitted_permissions =\n<line649>(dst_mode_bits\n<line650>& (x->preserve_ownership ? S_IRWXG | S_IRWXO\n<line651>: S_ISDIR (src_mode) ? S_IWGRP | S_IWOTH\n<line652>: 0));\n<line653>delayed_ok = true;\n<line654>/* If required, set the default security context for new files.\n<line655>Also for existing files this is used as a reference\n<line656>when copying the context with --preserve=context.\n<line657>FIXME: Do we need to consider dst_mode_bits here?  */\n<line658>if (! set_process_security_ctx (src_name, dst_name, src_mode, new_dst, x))\n<line659>return false;\n<line660>if (S_ISDIR (src_mode))\n<line661>{\n<line662>struct dir_list *dir;\n<line663>/* If this directory has been copied before during the\n<line664>recursion, there is a symbolic link to an ancestor\n<line665>directory of the symbolic link.  It is impossible to\n<line666>continue to copy this, unless we've got an infinite file system.  */\n<line667>if (is_ancestor (&src_sb, ancestors))\n<line668>{\n<line669>error (0, 0, _("cannot copy cyclic symbolic link %s"),\n<line670>quoteaf (src_name));\n<line671>goto un_backup;\n<line672>}\n<line673>/* Insert the current directory in the list of parents.  */\n<line674>dir = alloca (sizeof *dir);\n<line675>dir->parent = ancestors;\n<line676>dir->ino = src_sb.st_ino;\n<line677>dir->dev = src_sb.st_dev;\n<line678>if (new_dst || !S_ISDIR (dst_sb.st_mode))\n<line679>{\n<line680>/* POSIX says mkdir's behavior is implementation-defined when\n<line681>(src_mode & ~S_IRWXUGO) != 0.  However, common practice is\n<line682>to ask mkdir to copy all the CHMOD_MODE_BITS, letting mkdir\n<line683>decide what to do with S_ISUID | S_ISGID | S_ISVTX.  */\n<line684>mode_t mode = dst_mode_bits & ~omitted_permissions;\n<line685>if (mkdirat (dst_dirfd, drelname, mode) != 0)\n<line686>{\n<line687>error (0, errno, _("cannot create directory %s"),\n<line688>quoteaf (dst_name));\n<line689>goto un_backup;\n<line690>}\n<line691>/* We need search and write permissions to the new directory\n<line692>for writing the directory's contents. Check if these\n<line693>permissions are there.  */\n<line694>if (fstatat (dst_dirfd, drelname, &dst_sb, AT_SYMLINK_NOFOLLOW) != 0)\n<line695>{\n<line696>error (0, errno, _("cannot stat %s"), quoteaf (dst_name));\n<line697>goto un_backup;\n<line698>}\n<line699>else if ((dst_sb.st_mode & S_IRWXU) != S_IRWXU)\n<line700>{\n<line701>/* Make the new directory searchable and writable.  */\n<line702>dst_mode = dst_sb.st_mode;\n<line703>restore_dst_mode = true;\n<line704>if (lchmodat (dst_dirfd, drelname, dst_mode | S_IRWXU) != 0)\n<line705>{\n<line706>error (0, errno, _("setting permissions for %s"),\n<line707>quoteaf (dst_name));\n<line708>goto un_backup;\n<line709>}\n<line710>}\n<line711>/* Record the created directory's inode and device numbers into\n<line712>the search structure, so that we can avoid copying it again.\n<line713>Do this only for the first directory that is created for each\n<line714>source command line argument.  */\n<line715>if (!*first_dir_created_per_command_line_arg)\n<line716>{\n<line717>remember_copied (dst_relname, dst_sb.st_ino, dst_sb.st_dev);\n<line718>*first_dir_created_per_command_line_arg = true;\n<line719>}\n<line720>if (x->verbose)\n<line721>{\n<line722>if (x->move_mode)\n<line723>printf (_("created directory %s\n"), quoteaf (dst_name));\n<line724>else\n<line725>emit_verbose (src_name, dst_name, nullptr);\n<line726>}\n<line727>}\n<line728>else\n<line729>{\n<line730>omitted_permissions = 0;\n<line731>/* For directories, the process global context could be reset for\n<line732>descendants, so use it to set the context for existing dirs here.\n<line733>This will also give earlier indication of failure to set ctx.  */\n<line734>if (x->set_security_context || x->preserve_security_context)\n<line735>if (! set_file_security_ctx (dst_name, false, x))\n<line736>{\n<line737>if (x->require_preserve_context)\n<line738>goto un_backup;\n<line739>}\n<line740>}\n<line741>/* Decide whether to copy the contents of the directory.  */\n<line742>if (x->one_file_system && parent && parent->st_dev != src_sb.st_dev)\n<line743>{\n<line744>/* Here, we are crossing a file system boundary and cp's -x option\n<line745>is in effect: so don't copy the contents of this directory. */\n<line746>}\n<line747>else\n<line748>{\n<line749>/* Copy the contents of the directory.  Don't just return if\n<line750>this fails -- otherwise, the failure to read a single file\n<line751>in a source directory would cause the containing destination\n<line752>directory not to have owner/perms set properly.  */\n<line753>delayed_ok = copy_dir (src_name, dst_name, dst_dirfd, dst_relname,\n<line754>new_dst, &src_sb, dir, x,\n<line755>first_dir_created_per_command_line_arg,\n<line756>copy_into_self);\n<line757>}\n<line758>}\n<line759>else if (x->symbolic_link)\n<line760>{\n<line761>dest_is_symlink = true;\n<line762>if (*src_name != '/')\n<line763>{\n<line764>/* Check that DST_NAME denotes a file in the current directory.  */\n<line765>struct stat dot_sb;\n<line766>struct stat dst_parent_sb;\n<line767>char *dst_parent;\n<line768>bool in_current_dir;\n<line769>dst_parent = dir_name (dst_relname);\n<line770>in_current_dir = ((dst_dirfd == AT_FDCWD && STREQ (".", dst_parent))\n<line771>/* If either stat call fails, it's ok not to report\n<line772>the failure and say dst_name is in the current\n<line773>directory.  Other things will fail later.  */\n<line774>|| stat (".", &dot_sb) != 0\n<line775>|| (fstatat (dst_dirfd, dst_parent, &dst_parent_sb,\n<line776>0) != 0)\n<line777>|| SAME_INODE (dot_sb, dst_parent_sb));\n<line778>free (dst_parent);\n<line779>if (! in_current_dir)\n<line780>{\n<line781>error (0, 0,\n<line782>_("%s: can make relative symbolic links only in current directory"),\n<line783>quotef (dst_name));\n<line784>goto un_backup;\n<line785>}\n<line786>}\n<line787>int err = force_symlinkat (src_name, dst_dirfd, dst_relname,\n<line788>x->unlink_dest_after_failed_open, -1);\n<line789>if (0 < err)\n<line790>{\n<line791>error (0, err, _("cannot create symbolic link %s to %s"),\n<line792>quoteaf_n (0, dst_name), quoteaf_n (1, src_name));\n<line793>goto un_backup;\n<line794>}\n<line795>}\n<line796>/* POSIX 2008 states that it is implementation-defined whether\n<line797>link() on a symlink creates a hard-link to the symlink, or only\n<line798>to the referent (effectively dereferencing the symlink) (POSIX\n<line799>2001 required the latter behavior, although many systems provided\n<line800>the former).  Yet cp, invoked with '--link --no-dereference',\n<line801>should not follow the link.  We can approximate the desired\n<line802>behavior by skipping this hard-link creating block and instead\n<line803>copying the symlink, via the 'S_ISLNK'- copying code below.\n<line804>Note gnulib's linkat module, guarantees that the symlink is not\n<line805>dereferenced.  However its emulation currently doesn't maintain\n<line806>timestamps or ownership so we only call it when we know the\n<line807>emulation will not be needed.  */\n<line808>else if (x->hard_link\n<line809>&& !(! CAN_HARDLINK_SYMLINKS && S_ISLNK (src_mode)\n<line810>&& x->dereference == DEREF_NEVER))\n<line811>{\n<line812>bool replace = (x->unlink_dest_after_failed_open\n<line813>|| x->interactive == I_ASK_USER);\n<line814>if (! create_hard_link (src_name, AT_FDCWD, src_name,\n<line815>dst_name, dst_dirfd, dst_relname,\n<line816>replace, false, dereference))\n<line817>goto un_backup;\n<line818>}\n<line819>else if (S_ISREG (src_mode)\n<line820>|| (x->copy_as_regular && !S_ISLNK (src_mode)))\n<line821>{\n<line822>copied_as_regular = true;\n<line823>/* POSIX says the permission bits of the source file must be\n<line824>used as the 3rd argument in the open call.  Historical\n<line825>practice passed all the source mode bits to 'open', but the extra\n<line826>bits were ignored, so it should be the same either way.\n<line827>This call uses DST_MODE_BITS, not SRC_MODE.  These are\n<line828>normally the same, and the exception (where x->set_mode) is\n<line829>used only by 'install', which POSIX does not specify and\n<line830>where DST_MODE_BITS is what's wanted.  */\n<line831>if (! copy_reg (src_name, dst_name, dst_dirfd, dst_relname,\n<line832>x, dst_mode_bits & S_IRWXUGO,\n<line833>omitted_permissions, &new_dst, &src_sb))\n<line834>goto un_backup;\n<line835>}\n<line836>else if (S_ISFIFO (src_mode))\n<line837>{\n<line838>/* Use mknodat, rather than mkfifoat, because the former preserves\n<line839>the special mode bits of a fifo on Solaris 10, while mkfifoat\n<line840>does not.  But fall back on mkfifoat, because on some BSD systems,\n<line841>mknodat always fails when asked to create a FIFO.  */\n<line842>mode_t mode = src_mode & ~omitted_permissions;\n<line843>if (mknodat (dst_dirfd, dst_relname, mode, 0) != 0)\n<line844>if (mkfifoat (dst_dirfd, dst_relname, mode & ~S_IFIFO) != 0)\n<line845>{\n<line846>error (0, errno, _("cannot create fifo %s"), quoteaf (dst_name));\n<line847>goto un_backup;\n<line848>}\n<line849>}\n<line850>else if (S_ISBLK (src_mode) || S_ISCHR (src_mode) || S_ISSOCK (src_mode))\n<line851>{\n<line852>mode_t mode = src_mode & ~omitted_permissions;\n<line853>if (mknodat (dst_dirfd, dst_relname, mode, src_sb.st_rdev) != 0)\n<line854>{\n<line855>error (0, errno, _("cannot create special file %s"),\n<line856>quoteaf (dst_name));\n<line857>goto un_backup;\n<line858>}\n<line859>}\n<line860>else if (S_ISLNK (src_mode))\n<line861>{\n<line862>char *src_link_val = areadlink_with_size (src_name, src_sb.st_size);\n<line863>dest_is_symlink = true;\n<line864>if (src_link_val == nullptr)\n<line865>{\n<line866>error (0, errno, _("cannot read symbolic link %s"),\n<line867>quoteaf (src_name));\n<line868>goto un_backup;\n<line869>}\n<line870>int symlink_err = force_symlinkat (src_link_val, dst_dirfd, dst_relname,\n<line871>x->unlink_dest_after_failed_open, -1);\n<line872>if (0 < symlink_err && x->update && !new_dst && S_ISLNK (dst_sb.st_mode)\n<line873>&& dst_sb.st_size == strlen (src_link_val))\n<line874>{\n<line875>/* See if the destination is already the desired symlink.\n<line876>FIXME: This behavior isn't documented, and seems wrong\n<line877>in some cases, e.g., if the destination symlink has the\n<line878>wrong ownership, permissions, or timestamps.  */\n<line879>char *dest_link_val =\n<line880>areadlinkat_with_size (dst_dirfd, dst_relname, dst_sb.st_size);\n<line881>if (dest_link_val)\n<line882>{\n<line883>if (STREQ (dest_link_val, src_link_val))\n<line884>symlink_err = 0;\n<line885>free (dest_link_val);\n<line886>}\n<line887>}\n<line888>free (src_link_val);\n<line889>if (0 < symlink_err)\n<line890>{\n<line891>error (0, symlink_err, _("cannot create symbolic link %s"),\n<line892>quoteaf (dst_name));\n<line893>goto un_backup;\n<line894>}\n<line895>if (x->preserve_security_context)\n<line896>restore_default_fscreatecon_or_die ();\n<line897>if (x->preserve_ownership)\n<line898>{\n<line899>/* Preserve the owner and group of the just-'copied'\n<line900>symbolic link, if possible.  */\n<line901>if (HAVE_LCHOWN\n<line902>&& (lchownat (dst_dirfd, dst_relname,\n<line903>src_sb.st_uid, src_sb.st_gid)\n<line904>!= 0)\n<line905>&& ! chown_failure_ok (x))\n<line906>{\n<line907>error (0, errno, _("failed to preserve ownership for %s"),\n<line908>dst_name);\n<line909>if (x->require_preserve)\n<line910>goto un_backup;\n<line911>}\n<line912>else\n<line913>{\n<line914>/* Can't preserve ownership of symlinks.\n<line915>FIXME: maybe give a warning or even error for symlinks\n<line916>in directories with the sticky bit set -- there, not\n<line917>preserving owner/group is a potential security problem.  */\n<line918>}\n<line919>}\n<line920>}\n<line921>else\n<line922>{\n<line923>error (0, 0, _("%s has unknown file type"), quoteaf (src_name));\n<line924>goto un_backup;\n<line925>}\n<line926>/* With -Z or --preserve=context, set the context for existing files.\n<line927>Note this is done already for copy_reg() for reasons described therein.  */\n<line928>if (!new_dst && !x->copy_as_regular && !S_ISDIR (src_mode)\n<line929>&& (x->set_security_context || x->preserve_security_context))\n<line930>{\n<line931>if (! set_file_security_ctx (dst_name, false, x))\n<line932>{\n<line933>if (x->require_preserve_context)\n<line934>goto un_backup;\n<line935>}\n<line936>}\n<line937>if (command_line_arg && x->dest_info)\n<line938>{\n<line939>/* Now that the destination file is very likely to exist,\n<line940>add its info to the set.  */\n<line941>struct stat sb;\n<line942>if (fstatat (dst_dirfd, drelname, &sb, AT_SYMLINK_NOFOLLOW) == 0)\n<line943>record_file (x->dest_info, dst_relname, &sb);\n<line944>}\n<line945>/* If we've just created a hard-link due to cp's --link option,\n<line946>we're done.  */\n<line947>if (x->hard_link && ! S_ISDIR (src_mode)\n<line948>&& !(! CAN_HARDLINK_SYMLINKS && S_ISLNK (src_mode)\n<line949>&& x->dereference == DEREF_NEVER))\n<line950>return delayed_ok;\n<line951>if (copied_as_regular)\n<line952>return delayed_ok;\n<line953>/* POSIX says that 'cp -p' must restore the following:\n<line954>- permission bits\n<line955>- setuid, setgid bits\n<line956>- owner and group\n<line957>If it fails to restore any of those, we may give a warning but\n<line958>the destination must not be removed.\n<line959>FIXME: implement the above. */\n<line960>/* Adjust the times (and if possible, ownership) for the copy.\n<line961>chown turns off set[ug]id bits for non-root,\n<line962>so do the chmod last.  */\n<line963>if (x->preserve_timestamps)\n<line964>{\n<line965>struct timespec timespec[2];\n<line966>timespec[0] = get_stat_atime (&src_sb);\n<line967>timespec[1] = get_stat_mtime (&src_sb);\n<line968>int utimensat_flags = dest_is_symlink ? AT_SYMLINK_NOFOLLOW : 0;\n<line969>if (utimensat (dst_dirfd, drelname, timespec, utimensat_flags) != 0)\n<line970>{\n<line971>error (0, errno, _("preserving times for %s"), quoteaf (dst_name));\n<line972>if (x->require_preserve)\n<line973>return false;\n<line974>}\n<line975>}\n<line976>/* Avoid calling chown if we know it's not necessary.  */\n<line977>if (!dest_is_symlink && x->preserve_ownership\n<line978>&& (new_dst || !SAME_OWNER_AND_GROUP (src_sb, dst_sb)))\n<line979>{\n<line980>switch (set_owner (x, dst_name, dst_dirfd, drelname, -1,\n<line981>&src_sb, new_dst, &dst_sb))\n<line982>{\n<line983>case -1:\n<line984>return false;\n<line985>case 0:\n<line986>src_mode &= ~ (S_ISUID | S_ISGID | S_ISVTX);\n<line987>break;\n<line988>}\n<line989>}\n<line990>/* Set xattrs after ownership as changing owners will clear capabilities.  */\n<line991>if (x->preserve_xattr && ! copy_attr (src_name, -1, dst_name, -1, x)\n<line992>&& x->require_preserve_xattr)\n<line993>return false;\n<line994>/* The operations beyond this point may dereference a symlink.  */\n<line995>if (dest_is_symlink)\n<line996>return delayed_ok;\n<line997>set_author (dst_name, -1, &src_sb);\n<line998>if (x->preserve_mode || x->move_mode)\n<line999>{\n<line1000>if (copy_acl (src_name, -1, dst_name, -1, src_mode) != 0\n<line1001>&& x->require_preserve)\n<line1002>return false;\n<line1003>}\n<line1004>else if (x->set_mode)\n<line1005>{\n<line1006>if (set_acl (dst_name, -1, x->mode) != 0)\n<line1007>return false;\n<line1008>}\n<line1009>else if (x->explicit_no_preserve_mode && new_dst)\n<line1010>{\n<line1011>int default_permissions = S_ISDIR (src_mode) || S_ISSOCK (src_mode)\n<line1012>? S_IRWXUGO : MODE_RW_UGO;\n<line1013>if (set_acl (dst_name, -1, default_permissions & ~cached_umask ()) != 0)\n<line1014>return false;\n<line1015>}\n<line1016>else\n<line1017>{\n<line1018>if (omitted_permissions)\n<line1019>{\n<line1020>omitted_permissions &= ~ cached_umask ();\n<line1021>if (omitted_permissions && !restore_dst_mode)\n<line1022>{\n<line1023>/* Permissions were deliberately omitted when the file\n<line1024>was created due to security concerns.  See whether\n<line1025>they need to be re-added now.  It'd be faster to omit\n<line1026>the lstat, but deducing the current destination mode\n<line1027>is tricky in the presence of implementation-defined\n<line1028>rules for special mode bits.  */\n<line1029>if (new_dst && (fstatat (dst_dirfd, drelname, &dst_sb,\n<line1030>AT_SYMLINK_NOFOLLOW)\n<line1031>!= 0))\n<line1032>{\n<line1033>error (0, errno, _("cannot stat %s"), quoteaf (dst_name));\n<line1034>return false;\n<line1035>}\n<line1036>dst_mode = dst_sb.st_mode;\n<line1037>if (omitted_permissions & ~dst_mode)\n<line1038>restore_dst_mode = true;\n<line1039>}\n<line1040>}\n<line1041>if (restore_dst_mode)\n<line1042>{\n<line1043>if (lchmodat (dst_dirfd, drelname, dst_mode | omitted_permissions)\n<line1044>!= 0)\n<line1045>{\n<line1046>error (0, errno, _("preserving permissions for %s"),\n<line1047>quoteaf (dst_name));\n<line1048>if (x->require_preserve)\n<line1049>return false;\n<line1050>}\n<line1051>}\n<line1052>}\n<line1053>return delayed_ok;\n<line1054>un_backup:\n<line1055>if (x->preserve_security_context)\n<line1056>restore_default_fscreatecon_or_die ();\n<line1057>/* We have failed to create the destination file.\n<line1058>If we've just added a dev/ino entry via the remember_copied\n<line1059>call above (i.e., unless we've just failed to create a hard link),\n<line1060>remove the entry associating the source dev/ino with the\n<line1061>destination file name, so we don't try to 'preserve' a link\n<line1062>to a file we didn't create.  */\n<line1063>if (earlier_file == nullptr)\n<line1064>forget_created (src_sb.st_ino, src_sb.st_dev);\n<line1065>if (dst_backup)\n<line1066>{\n<line1067>char const *dst_relbackup = &dst_backup[dst_relname - dst_name];\n<line1068>if (renameat (dst_dirfd, dst_relbackup, dst_dirfd, drelname) != 0)\n<line1069>error (0, errno, _("cannot un-backup %s"), quoteaf (dst_name));\n<line1070>else\n<line1071>{\n<line1072>if (x->verbose)\n<line1073>printf (_("%s -> %s (unbackup)\n"),\n<line1074>quoteaf_n (0, dst_backup), quoteaf_n (1, dst_name));\n<line1075>}\n<line1076>}\n<line1077>return false;\n<line1078>}
----------------------------------------
Function: valid_options
Content: <line0>static void\n<line1>valid_options (const struct cp_options *co)\n<line2>{\n<line3>affirm (VALID_BACKUP_TYPE (co->backup_type));\n<line4>affirm (VALID_SPARSE_MODE (co->sparse_mode));\n<line5>affirm (VALID_REFLINK_MODE (co->reflink_mode));\n<line6>affirm (!(co->hard_link && co->symbolic_link));\n<line7>affirm (!\n<line8>(co->reflink_mode == REFLINK_ALWAYS\n<line9>&& co->sparse_mode != SPARSE_AUTO));\n<line10>}
----------------------------------------
Function: copy
Content: <line0>extern bool\n<line1>copy (char const *src_name, char const *dst_name,\n<line2>int dst_dirfd, char const *dst_relname,\n<line3>int nonexistent_dst, const struct cp_options *options,\n<line4>bool *copy_into_self, bool *rename_succeeded)\n<line5>{\n<line6>valid_options (options);\n<line7>/* Record the file names: they're used in case of error, when copying\n<line8>a directory into itself.  I don't like to make these tools do *any*\n<line9>extra work in the common case when that work is solely to handle\n<line10>exceptional cases, but in this case, I don't see a way to derive the\n<line11>top level source and destination directory names where they're used.\n<line12>An alternative is to use COPY_INTO_SELF and print the diagnostic\n<line13>from every caller -- but I don't want to do that.  */\n<line14>top_level_src_name = src_name;\n<line15>top_level_dst_name = dst_name;\n<line16>bool first_dir_created_per_command_line_arg = false;\n<line17>return copy_internal (src_name, dst_name, dst_dirfd, dst_relname,\n<line18>nonexistent_dst, nullptr, nullptr,\n<line19>options, true,\n<line20>&first_dir_created_per_command_line_arg,\n<line21>copy_into_self, rename_succeeded);\n<line22>}
----------------------------------------
Function: cp_options_default
Content: <line0>extern void\n<line1>cp_options_default (struct cp_options *x)\n<line2>{\n<line3>memset (x, 0, sizeof *x);\n<line4>#ifdef PRIV_FILE_CHOWN\n<line5>{\n<line6>priv_set_t *pset = priv_allocset ();\n<line7>if (!pset)\n<line8>xalloc_die ();\n<line9>if (getppriv (PRIV_EFFECTIVE, pset) == 0)\n<line10>{\n<line11>x->chown_privileges = priv_ismember (pset, PRIV_FILE_CHOWN);\n<line12>x->owner_privileges = priv_ismember (pset, PRIV_FILE_OWNER);\n<line13>}\n<line14>priv_freeset (pset);\n<line15>}\n<line16>#else\n<line17>x->chown_privileges = x->owner_privileges = (geteuid () == ROOT_UID);\n<line18>#endif\n<line19>x->rename_errno = -1;\n<line20>}
----------------------------------------
Function: chown_failure_ok
Content: <line0>extern bool\n<line1>chown_failure_ok (struct cp_options const *x)\n<line2>{\n<line3>/* If non-root uses -p, it's ok if we can't preserve ownership.\n<line4>But root probably wants to know, e.g. if NFS disallows it,\n<line5>or if the target system doesn't support file ownership.  */\n<line6>return ((errno == EPERM || errno == EINVAL) && !x->chown_privileges);\n<line7>}
----------------------------------------
Function: owner_failure_ok
Content: <line0>static bool\n<line1>owner_failure_ok (struct cp_options const *x)\n<line2>{\n<line3>return ((errno == EPERM || errno == EINVAL) && !x->owner_privileges);\n<line4>}
----------------------------------------
Function: cached_umask
Content: <line0>extern mode_t\n<line1>cached_umask (void)\n<line2>{\n<line3>static mode_t mask = (mode_t) -1;\n<line4>if (mask == (mode_t) -1)\n<line5>{\n<line6>mask = umask (0);\n<line7>umask (mask);\n<line8>}\n<line9>return mask;\n<line10>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/src/cp-hash.c
========================================
Function: src_to_dest_hash
Content: <line0>static size_t\n<line1>src_to_dest_hash (void const *x, size_t table_size)\n<line2>{\n<line3>struct Src_to_dest const *p = x;\n<line4>/* Ignoring the device number here should be fine.  */\n<line5>/* The cast to uintmax_t prevents negative remainders\n<line6>if st_ino is negative.  */\n<line7>return (uintmax_t) p->st_ino % table_size;\n<line8>}
----------------------------------------
Function: src_to_dest_compare
Content: <line0>static bool\n<line1>src_to_dest_compare (void const *x, void const *y)\n<line2>{\n<line3>struct Src_to_dest const *a = x;\n<line4>struct Src_to_dest const *b = y;\n<line5>return SAME_INODE (*a, *b) ? true : false;\n<line6>}
----------------------------------------
Function: src_to_dest_free
Content: <line0>static void\n<line1>src_to_dest_free (void *x)\n<line2>{\n<line3>struct Src_to_dest *a = x;\n<line4>free (a->name);\n<line5>free (x);\n<line6>}
----------------------------------------
Function: forget_created
Content: <line0>extern void\n<line1>forget_created (ino_t ino, dev_t dev)\n<line2>{\n<line3>struct Src_to_dest probe;\n<line4>struct Src_to_dest *ent;\n<line5>probe.st_ino = ino;\n<line6>probe.st_dev = dev;\n<line7>probe.name = nullptr;\n<line8>ent = hash_remove (src_to_dest, &probe);\n<line9>if (ent)\n<line10>src_to_dest_free (ent);\n<line11>}
----------------------------------------
Function: src_to_dest_lookup
Content: <line0>extern char *\n<line1>src_to_dest_lookup (ino_t ino, dev_t dev)\n<line2>{\n<line3>struct Src_to_dest ent;\n<line4>struct Src_to_dest const *e;\n<line5>ent.st_ino = ino;\n<line6>ent.st_dev = dev;\n<line7>e = hash_lookup (src_to_dest, &ent);\n<line8>return e ? e->name : nullptr;\n<line9>}
----------------------------------------
Function: remember_copied
Content: <line0>extern char *\n<line1>remember_copied (char const *name, ino_t ino, dev_t dev)\n<line2>{\n<line3>struct Src_to_dest *ent;\n<line4>struct Src_to_dest *ent_from_table;\n<line5>ent = xmalloc (sizeof *ent);\n<line6>ent->name = xstrdup (name);\n<line7>ent->st_ino = ino;\n<line8>ent->st_dev = dev;\n<line9>ent_from_table = hash_insert (src_to_dest, ent);\n<line10>if (ent_from_table == nullptr)\n<line11>{\n<line12>/* Insertion failed due to lack of memory.  */\n<line13>xalloc_die ();\n<line14>}\n<line15>/* Determine whether there was already an entry in the table\n<line16>with a matching key.  If so, free ENT (it wasn't inserted) and\n<line17>return the 'name' from the table entry.  */\n<line18>if (ent_from_table != ent)\n<line19>{\n<line20>src_to_dest_free (ent);\n<line21>return (char *) ent_from_table->name;\n<line22>}\n<line23>/* New key;  insertion succeeded.  */\n<line24>return nullptr;\n<line25>}
----------------------------------------
Function: hash_init
Content: <line0>extern void\n<line1>hash_init (void)\n<line2>{\n<line3>src_to_dest = hash_initialize (INITIAL_TABLE_SIZE, nullptr,\n<line4>src_to_dest_hash,\n<line5>src_to_dest_compare,\n<line6>src_to_dest_free);\n<line7>if (src_to_dest == nullptr)\n<line8>xalloc_die ();\n<line9>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/src/force-link.c
========================================
Function: samedir_template
Content: <line0>static char *\n<line1>samedir_template (char const *dstname, char buf[smallsize])\n<line2>{\n<line3>ptrdiff_t dstdirlen = last_component (dstname) - dstname;\n<line4>size_t dsttmpsize = dstdirlen + sizeof simple_pattern;\n<line5>char *dsttmp;\n<line6>if (dsttmpsize <= smallsize)\n<line7>dsttmp = buf;\n<line8>else\n<line9>{\n<line10>dsttmp = malloc (dsttmpsize);\n<line11>if (!dsttmp)\n<line12>return dsttmp;\n<line13>}\n<line14>strcpy (mempcpy (dsttmp, dstname, dstdirlen), simple_pattern);\n<line15>return dsttmp;\n<line16>}
----------------------------------------
Function: try_link
Content: <line0>static int\n<line1>try_link (char *dest, void *arg)\n<line2>{\n<line3>struct link_arg *a = arg;\n<line4>return linkat (a->srcdir, a->srcname, a->dstdir, dest, a->flags);\n<line5>}
----------------------------------------
Function: force_linkat
Content: <line0>extern int\n<line1>force_linkat (int srcdir, char const *srcname,\n<line2>int dstdir, char const *dstname, int flags, bool force,\n<line3>int linkat_errno)\n<line4>{\n<line5>if (linkat_errno < 0)\n<line6>linkat_errno = (linkat (srcdir, srcname, dstdir, dstname, flags) == 0\n<line7>? 0 : errno);\n<line8>if (!force || linkat_errno != EEXIST)\n<line9>return linkat_errno;\n<line10>char buf[smallsize];\n<line11>char *dsttmp = samedir_template (dstname, buf);\n<line12>if (! dsttmp)\n<line13>return errno;\n<line14>struct link_arg arg = { srcdir, srcname, dstdir, flags };\n<line15>int err;\n<line16>if (try_tempname_len (dsttmp, 0, &arg, try_link, x_suffix_len) != 0)\n<line17>err = errno;\n<line18>else\n<line19>{\n<line20>err = renameat (dstdir, dsttmp, dstdir, dstname) == 0 ? -1 : errno;\n<line21>/* Unlink DSTTMP even if renameat succeeded, in case DSTTMP\n<line22>and DSTNAME were already the same hard link and renameat\n<line23>was a no-op.  */\n<line24>unlinkat (dstdir, dsttmp, 0);\n<line25>}\n<line26>if (dsttmp != buf)\n<line27>free (dsttmp);\n<line28>return err;\n<line29>}
----------------------------------------
Function: try_symlink
Content: <line0>static int\n<line1>try_symlink (char *dest, void *arg)\n<line2>{\n<line3>struct symlink_arg *a = arg;\n<line4>return symlinkat (a->srcname, a->dstdir, dest);\n<line5>}
----------------------------------------
Function: force_symlinkat
Content: <line0>extern int\n<line1>force_symlinkat (char const *srcname, int dstdir, char const *dstname,\n<line2>bool force, int symlinkat_errno)\n<line3>{\n<line4>if (symlinkat_errno < 0)\n<line5>symlinkat_errno = symlinkat (srcname, dstdir, dstname) == 0 ? 0 : errno;\n<line6>if (!force || symlinkat_errno != EEXIST)\n<line7>return symlinkat_errno;\n<line8>char buf[smallsize];\n<line9>char *dsttmp = samedir_template (dstname, buf);\n<line10>if (!dsttmp)\n<line11>return errno;\n<line12>struct symlink_arg arg = { srcname, dstdir };\n<line13>int err;\n<line14>if (try_tempname_len (dsttmp, 0, &arg, try_symlink, x_suffix_len) != 0)\n<line15>err = errno;\n<line16>else if (renameat (dstdir, dsttmp, dstdir, dstname) != 0)\n<line17>{\n<line18>err = errno;\n<line19>unlinkat (dstdir, dsttmp, 0);\n<line20>}\n<line21>else\n<line22>{\n<line23>/* Don't worry about renameat being a no-op, since DSTTMP is\n<line24>newly created.  */\n<line25>err = -1;\n<line26>}\n<line27>if (dsttmp != buf)\n<line28>free (dsttmp);\n<line29>return err;\n<line30>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/src/selinux.c
========================================
In file included from /home/huihui/Downloads/coreutils-9.4/src/selinux.c:26:
In file included from ./lib/xfts.h:1:
In file included from ./lib/fts_.h:83:
./lib/i-ring.h:24:32: warning: '_Static_assert' with no message is a C2x extension [-Wc2x-extensions]
static_assert (1 <= I_RING_SIZE);
                               ^
                               , ""
1 warning generated.
========================================
/home/huihui/Downloads/coreutils-9.4/src/csplit.c
========================================
Function: cleanup
Content: <line0>static void\n<line1>cleanup (void)\n<line2>{\n<line3>sigset_t oldset;\n<line4>close_output_file ();\n<line5>sigprocmask (SIG_BLOCK, &caught_signals, &oldset);\n<line6>delete_all_files (false);\n<line7>sigprocmask (SIG_SETMASK, &oldset, nullptr);\n<line8>}
----------------------------------------
Function: cleanup_fatal
Content: <line0>static _Noreturn void\n<line1>cleanup_fatal (void)\n<line2>{\n<line3>cleanup ();\n<line4>exit (EXIT_FAILURE);\n<line5>}
----------------------------------------
Function: xalloc_die
Content: <line0>extern void\n<line1>xalloc_die (void)\n<line2>{\n<line3>error (0, 0, "%s", _("memory exhausted"));\n<line4>cleanup_fatal ();\n<line5>}
----------------------------------------
Function: interrupt_handler
Content: <line0>static void\n<line1>interrupt_handler (int sig)\n<line2>{\n<line3>delete_all_files (true);\n<line4>signal (sig, SIG_DFL);\n<line5>/* The signal has been reset to SIG_DFL, but blocked during this\n<line6>handler.  Force the default action of this signal once the\n<line7>handler returns and the block is removed.  */\n<line8>raise (sig);\n<line9>}
----------------------------------------
Function: save_to_hold_area
Content: <line0>static void\n<line1>save_to_hold_area (char *start, idx_t num)\n<line2>{\n<line3>free (hold_area);\n<line4>hold_area = start;\n<line5>hold_count = num;\n<line6>}
----------------------------------------
Function: read_input
Content: <line0>static idx_t\n<line1>read_input (char *dest, idx_t max_n_bytes)\n<line2>{\n<line3>idx_t bytes_read;\n<line4>if (max_n_bytes == 0)\n<line5>return 0;\n<line6>bytes_read = safe_read (STDIN_FILENO, dest, max_n_bytes);\n<line7>if (bytes_read == 0)\n<line8>have_read_eof = true;\n<line9>if (bytes_read == SAFE_READ_ERROR)\n<line10>{\n<line11>error (0, errno, _("read error"));\n<line12>cleanup_fatal ();\n<line13>}\n<line14>return bytes_read;\n<line15>}
----------------------------------------
Function: clear_line_control
Content: <line0>static void\n<line1>clear_line_control (struct line *p)\n<line2>{\n<line3>p->used = 0;\n<line4>p->insert_index = 0;\n<line5>p->retrieve_index = 0;\n<line6>}
----------------------------------------
Function: new_line_control
Content: <line0>static struct line *\n<line1>new_line_control (void)\n<line2>{\n<line3>struct line *p = xmalloc (sizeof *p);\n<line4>p->next = nullptr;\n<line5>clear_line_control (p);\n<line6>return p;\n<line7>}
----------------------------------------
Function: keep_new_line
Content: <line0>static void\n<line1>keep_new_line (struct buffer_record *b, char *line_start, idx_t line_len)\n<line2>{\n<line3>struct line *l;\n<line4>/* If there is no existing area to keep line info, get some. */\n<line5>if (b->line_start == nullptr)\n<line6>b->line_start = b->curr_line = new_line_control ();\n<line7>/* If existing area for lines is full, get more. */\n<line8>if (b->curr_line->used == CTRL_SIZE)\n<line9>{\n<line10>b->curr_line->next = new_line_control ();\n<line11>b->curr_line = b->curr_line->next;\n<line12>}\n<line13>l = b->curr_line;\n<line14>/* Record the start of the line, and update counters. */\n<line15>l->starts[l->insert_index].str = line_start;\n<line16>l->starts[l->insert_index].len = line_len;\n<line17>l->used++;\n<line18>l->insert_index++;\n<line19>}
----------------------------------------
Function: record_line_starts
Content: <line0>static idx_t\n<line1>record_line_starts (struct buffer_record *b)\n<line2>{\n<line3>char *line_start;		/* Start of current line. */\n<line4>idx_t lines;			/* Number of lines found. */\n<line5>idx_t line_length;		/* Length of each line found. */\n<line6>if (b->bytes_used == 0)\n<line7>return 0;\n<line8>lines = 0;\n<line9>line_start = b->buffer;\n<line10>char *buffer_end = line_start + b->bytes_used;\n<line11>*buffer_end = '\n';\n<line12>while (true)\n<line13>{\n<line14>char *line_end = rawmemchr (line_start, '\n');\n<line15>if (line_end == buffer_end)\n<line16>break;\n<line17>line_length = line_end - line_start + 1;\n<line18>keep_new_line (b, line_start, line_length);\n<line19>line_start = line_end + 1;\n<line20>lines++;\n<line21>}\n<line22>/* Check for an incomplete last line. */\n<line23>idx_t bytes_left = buffer_end - line_start;\n<line24>if (bytes_left)\n<line25>{\n<line26>if (have_read_eof)\n<line27>{\n<line28>keep_new_line (b, line_start, bytes_left);\n<line29>lines++;\n<line30>}\n<line31>else\n<line32>save_to_hold_area (ximemdup (line_start, bytes_left), bytes_left);\n<line33>}\n<line34>b->num_lines = lines;\n<line35>b->first_available = b->start_line = last_line_number + 1;\n<line36>last_line_number += lines;\n<line37>return lines;\n<line38>}
----------------------------------------
Function: free_buffer
Content: <line0>static void\n<line1>free_buffer (struct buffer_record *buf)\n<line2>{\n<line3>for (struct line *l = buf->line_start; l;)\n<line4>{\n<line5>struct line *n = l->next;\n<line6>free (l);\n<line7>l = n;\n<line8>}\n<line9>free (buf->buffer);\n<line10>free (buf);\n<line11>}
----------------------------------------
Function: get_new_buffer
Content: <line0>static ATTRIBUTE_DEALLOC (free_buffer, 1)\n<line1>struct buffer_record *\n<line2>get_new_buffer (idx_t min_size)\n<line3>{\n<line4>struct buffer_record *new_buffer = xmalloc (sizeof *new_buffer);\n<line5>new_buffer->bytes_alloc = 0;\n<line6>new_buffer->buffer = xpalloc (nullptr, &new_buffer->bytes_alloc, min_size,\n<line7>-1, 1);\n<line8>new_buffer->bytes_used = 0;\n<line9>new_buffer->start_line = new_buffer->first_available = last_line_number + 1;\n<line10>new_buffer->num_lines = 0;\n<line11>new_buffer->line_start = new_buffer->curr_line = nullptr;\n<line12>new_buffer->next = nullptr;\n<line13>return new_buffer;\n<line14>}
----------------------------------------
Function: save_buffer
Content: <line0>static void\n<line1>save_buffer (struct buffer_record *buf)\n<line2>{\n<line3>struct buffer_record *p;\n<line4>buf->next = nullptr;\n<line5>buf->curr_line = buf->line_start;\n<line6>if (head == nullptr)\n<line7>head = buf;\n<line8>else\n<line9>{\n<line10>for (p = head; p->next; p = p->next)\n<line11>/* Do nothing. */ ;\n<line12>p->next = buf;\n<line13>}\n<line14>}
----------------------------------------
Function: load_buffer
Content: <line0>static bool\n<line1>load_buffer (void)\n<line2>{\n<line3>if (have_read_eof)\n<line4>return false;\n<line5>/* We must make the buffer at least as large as the amount of data\n<line6>in the partial line left over from the last call,\n<line7>plus room for a sentinel '\n'. */\n<line8>idx_t bytes_wanted = MAX (START_SIZE, hold_count + 1);\n<line9>while (true)\n<line10>{\n<line11>struct buffer_record *b = get_new_buffer (bytes_wanted);\n<line12>idx_t bytes_alloc = b->bytes_alloc;\n<line13>idx_t bytes_avail = bytes_alloc;\n<line14>char *p = b->buffer;\n<line15>/* First check the 'holding' area for a partial line. */\n<line16>if (hold_count)\n<line17>{\n<line18>p = mempcpy (p, hold_area, hold_count);\n<line19>b->bytes_used += hold_count;\n<line20>bytes_avail -= hold_count;\n<line21>hold_count = 0;\n<line22>}\n<line23>b->bytes_used += read_input (p, bytes_avail - 1);\n<line24>if (record_line_starts (b) != 0)\n<line25>{\n<line26>save_buffer (b);\n<line27>return true;\n<line28>}\n<line29>free_buffer (b);\n<line30>if (have_read_eof)\n<line31>return false;\n<line32>if (ckd_add (&bytes_wanted, bytes_alloc, bytes_alloc >> 1))\n<line33>xalloc_die ();\n<line34>}\n<line35>}
----------------------------------------
Function: get_first_line_in_buffer
Content: <line0>static intmax_t\n<line1>get_first_line_in_buffer (void)\n<line2>{\n<line3>if (head == nullptr && !load_buffer ())\n<line4>error (EXIT_FAILURE, errno, _("input disappeared"));\n<line5>return head->first_available;\n<line6>}
----------------------------------------
Function: remove_line
Content: <line0>static struct cstring *\n<line1>remove_line (void)\n<line2>{\n<line3>/* If non-null, this is the buffer for which the previous call\n<line4>returned the final line.  So now, presuming that line has been\n<line5>processed, we can free the buffer and reset this pointer.  */\n<line6>static struct buffer_record *prev_buf = nullptr;\n<line7>struct cstring *line;		/* Return value. */\n<line8>struct line *l;		/* For convenience. */\n<line9>if (prev_buf)\n<line10>{\n<line11>free_buffer (prev_buf);\n<line12>prev_buf = nullptr;\n<line13>}\n<line14>if (head == nullptr && !load_buffer ())\n<line15>return nullptr;\n<line16>if (current_line < head->first_available)\n<line17>current_line = head->first_available;\n<line18>++(head->first_available);\n<line19>l = head->curr_line;\n<line20>line = &l->starts[l->retrieve_index];\n<line21>/* Advance index to next line. */\n<line22>if (++l->retrieve_index == l->used)\n<line23>{\n<line24>/* Go on to the next line record. */\n<line25>head->curr_line = l->next;\n<line26>if (head->curr_line == nullptr || head->curr_line->used == 0)\n<line27>{\n<line28>/* Go on to the next data block.\n<line29>but first record the current one so we can free it\n<line30>once the line we're returning has been processed.  */\n<line31>prev_buf = head;\n<line32>head = head->next;\n<line33>}\n<line34>}\n<line35>return line;\n<line36>}
----------------------------------------
Function: find_line
Content: <line0>static struct cstring *\n<line1>find_line (intmax_t linenum)\n<line2>{\n<line3>struct buffer_record *b;\n<line4>if (head == nullptr && !load_buffer ())\n<line5>return nullptr;\n<line6>if (linenum < head->start_line)\n<line7>return nullptr;\n<line8>for (b = head;;)\n<line9>{\n<line10>if (linenum < b->start_line + b->num_lines)\n<line11>{\n<line12>/* The line is in this buffer. */\n<line13>struct line *l;\n<line14>idx_t offset;	/* How far into the buffer the line is. */\n<line15>l = b->line_start;\n<line16>offset = linenum - b->start_line;\n<line17>/* Find the control record. */\n<line18>while (offset >= CTRL_SIZE)\n<line19>{\n<line20>l = l->next;\n<line21>offset -= CTRL_SIZE;\n<line22>}\n<line23>return &l->starts[offset];\n<line24>}\n<line25>if (b->next == nullptr && !load_buffer ())\n<line26>return nullptr;\n<line27>b = b->next;		/* Try the next data block. */\n<line28>}\n<line29>}
----------------------------------------
Function: no_more_lines
Content: <line0>static bool\n<line1>no_more_lines (void)\n<line2>{\n<line3>return find_line (current_line + 1) == nullptr;\n<line4>}
----------------------------------------
Function: set_input_file
Content: <line0>static void\n<line1>set_input_file (char const *name)\n<line2>{\n<line3>if (! STREQ (name, "-") && fd_reopen (STDIN_FILENO, name, O_RDONLY, 0) < 0)\n<line4>error (EXIT_FAILURE, errno, _("cannot open %s for reading"),\n<line5>quoteaf (name));\n<line6>}
----------------------------------------
Function: write_to_file
Content: <line0>static void\n<line1>write_to_file (intmax_t last_line, bool ignore, int argnum)\n<line2>{\n<line3>struct cstring *line;\n<line4>intmax_t first_line;		/* First available input line. */\n<line5>intmax_t lines;		/* Number of lines to output. */\n<line6>intmax_t i;\n<line7>first_line = get_first_line_in_buffer ();\n<line8>if (first_line > last_line)\n<line9>{\n<line10>error (0, 0, _("%s: line number out of range"),\n<line11>quote (global_argv[argnum]));\n<line12>cleanup_fatal ();\n<line13>}\n<line14>lines = last_line - first_line;\n<line15>for (i = 0; i < lines; i++)\n<line16>{\n<line17>line = remove_line ();\n<line18>if (line == nullptr)\n<line19>{\n<line20>error (0, 0, _("%s: line number out of range"),\n<line21>quote (global_argv[argnum]));\n<line22>cleanup_fatal ();\n<line23>}\n<line24>if (!ignore)\n<line25>save_line_to_file (line);\n<line26>}\n<line27>}
----------------------------------------
Function: dump_rest_of_file
Content: <line0>static void\n<line1>dump_rest_of_file (void)\n<line2>{\n<line3>struct cstring *line;\n<line4>while ((line = remove_line ()) != nullptr)\n<line5>save_line_to_file (line);\n<line6>}
----------------------------------------
Function: handle_line_error
Content: <line0>static void\n<line1>handle_line_error (const struct control *p, intmax_t repetition)\n<line2>{\n<line3>char buf[INT_BUFSIZE_BOUND (intmax_t)];\n<line4>fprintf (stderr, _("%s: %s: line number out of range"),\n<line5>program_name, quote (imaxtostr (p->lines_required, buf)));\n<line6>if (repetition)\n<line7>fprintf (stderr, _(" on repetition %s\n"), imaxtostr (repetition, buf));\n<line8>else\n<line9>fprintf (stderr, "\n");\n<line10>cleanup_fatal ();\n<line11>}
----------------------------------------
Function: process_line_count
Content: <line0>static void\n<line1>process_line_count (const struct control *p, intmax_t repetition)\n<line2>{\n<line3>intmax_t linenum;\n<line4>intmax_t last_line_to_save = p->lines_required * (repetition + 1);\n<line5>create_output_file ();\n<line6>/* Ensure that the line number specified is not 1 greater than\n<line7>the number of lines in the file.\n<line8>When suppressing matched lines, check before the loop. */\n<line9>if (no_more_lines () && suppress_matched)\n<line10>handle_line_error (p, repetition);\n<line11>linenum = get_first_line_in_buffer ();\n<line12>while (linenum++ < last_line_to_save)\n<line13>{\n<line14>struct cstring *line = remove_line ();\n<line15>if (line == nullptr)\n<line16>handle_line_error (p, repetition);\n<line17>save_line_to_file (line);\n<line18>}\n<line19>close_output_file ();\n<line20>if (suppress_matched)\n<line21>remove_line ();\n<line22>/* Ensure that the line number specified is not 1 greater than\n<line23>the number of lines in the file. */\n<line24>if (no_more_lines () && !suppress_matched)\n<line25>handle_line_error (p, repetition);\n<line26>}
----------------------------------------
Function: regexp_error
Content: <line0>static void\n<line1>regexp_error (struct control *p, intmax_t repetition, bool ignore)\n<line2>{\n<line3>fprintf (stderr, _("%s: %s: match not found"),\n<line4>program_name, quote (global_argv[p->argnum]));\n<line5>if (repetition)\n<line6>{\n<line7>char buf[INT_BUFSIZE_BOUND (intmax_t)];\n<line8>fprintf (stderr, _(" on repetition %s\n"), imaxtostr (repetition, buf));\n<line9>}\n<line10>else\n<line11>fprintf (stderr, "\n");\n<line12>if (!ignore)\n<line13>{\n<line14>dump_rest_of_file ();\n<line15>close_output_file ();\n<line16>}\n<line17>cleanup_fatal ();\n<line18>}
----------------------------------------
Function: process_regexp
Content: <line0>static void\n<line1>process_regexp (struct control *p, intmax_t repetition)\n<line2>{\n<line3>struct cstring *line;		/* From input file. */\n<line4>idx_t line_len;		/* To make "$" in regexps work. */\n<line5>intmax_t break_line;		/* First line number of next file. */\n<line6>bool ignore = p->ignore;	/* If true, skip this section. */\n<line7>regoff_t ret;\n<line8>if (!ignore)\n<line9>create_output_file ();\n<line10>/* If there is no offset for the regular expression, or\n<line11>it is positive, then it is not necessary to buffer the lines. */\n<line12>if (p->offset >= 0)\n<line13>{\n<line14>while (true)\n<line15>{\n<line16>line = find_line (++current_line);\n<line17>if (line == nullptr)\n<line18>{\n<line19>if (p->repeat_forever)\n<line20>{\n<line21>if (!ignore)\n<line22>{\n<line23>dump_rest_of_file ();\n<line24>close_output_file ();\n<line25>}\n<line26>exit (EXIT_SUCCESS);\n<line27>}\n<line28>else\n<line29>regexp_error (p, repetition, ignore);\n<line30>}\n<line31>line_len = line->len;\n<line32>if (line->str[line_len - 1] == '\n')\n<line33>line_len--;\n<line34>ret = re_search (&p->re_compiled, line->str, line_len,\n<line35>0, line_len, nullptr);\n<line36>if (ret == -2)\n<line37>{\n<line38>error (0, 0, _("error in regular expression search"));\n<line39>cleanup_fatal ();\n<line40>}\n<line41>if (ret == -1)\n<line42>{\n<line43>line = remove_line ();\n<line44>if (!ignore)\n<line45>save_line_to_file (line);\n<line46>}\n<line47>else\n<line48>break;\n<line49>}\n<line50>}\n<line51>else\n<line52>{\n<line53>/* Buffer the lines. */\n<line54>while (true)\n<line55>{\n<line56>line = find_line (++current_line);\n<line57>if (line == nullptr)\n<line58>{\n<line59>if (p->repeat_forever)\n<line60>{\n<line61>if (!ignore)\n<line62>{\n<line63>dump_rest_of_file ();\n<line64>close_output_file ();\n<line65>}\n<line66>exit (EXIT_SUCCESS);\n<line67>}\n<line68>else\n<line69>regexp_error (p, repetition, ignore);\n<line70>}\n<line71>line_len = line->len;\n<line72>if (line->str[line_len - 1] == '\n')\n<line73>line_len--;\n<line74>ret = re_search (&p->re_compiled, line->str, line_len,\n<line75>0, line_len, nullptr);\n<line76>if (ret == -2)\n<line77>{\n<line78>error (0, 0, _("error in regular expression search"));\n<line79>cleanup_fatal ();\n<line80>}\n<line81>if (ret != -1)\n<line82>break;\n<line83>}\n<line84>}\n<line85>/* Account for any offset from this regexp. */\n<line86>break_line = current_line + p->offset;\n<line87>write_to_file (break_line, ignore, p->argnum);\n<line88>if (!ignore)\n<line89>close_output_file ();\n<line90>if (p->offset > 0)\n<line91>current_line = break_line;\n<line92>if (suppress_matched)\n<line93>remove_line ();\n<line94>}
----------------------------------------
Function: split_file
Content: <line0>static void\n<line1>split_file (void)\n<line2>{\n<line3>for (idx_t i = 0; i < control_used; i++)\n<line4>{\n<line5>intmax_t j;\n<line6>if (controls[i].regexpr)\n<line7>{\n<line8>for (j = 0; (controls[i].repeat_forever\n<line9>|| j <= controls[i].repeat); j++)\n<line10>process_regexp (&controls[i], j);\n<line11>}\n<line12>else\n<line13>{\n<line14>for (j = 0; (controls[i].repeat_forever\n<line15>|| j <= controls[i].repeat); j++)\n<line16>process_line_count (&controls[i], j);\n<line17>}\n<line18>}\n<line19>create_output_file ();\n<line20>dump_rest_of_file ();\n<line21>close_output_file ();\n<line22>}
----------------------------------------
Function: make_filename
Content: <line0>static char *\n<line1>make_filename (int num)\n<line2>{\n<line3>strcpy (filename_space, prefix);\n<line4>if (suffix)\n<line5>sprintf (filename_space + strlen (prefix), suffix, num);\n<line6>else\n<line7>sprintf (filename_space + strlen (prefix), "%0*d", digits, num);\n<line8>return filename_space;\n<line9>}
----------------------------------------
Function: create_output_file
Content: <line0>static void\n<line1>create_output_file (void)\n<line2>{\n<line3>int nfiles = files_created;\n<line4>bool fopen_ok;\n<line5>int fopen_errno;\n<line6>output_filename = make_filename (nfiles);\n<line7>if (nfiles == INT_MAX)\n<line8>{\n<line9>fopen_ok = false;\n<line10>fopen_errno = EOVERFLOW;\n<line11>}\n<line12>else\n<line13>{\n<line14>/* Create the output file in a critical section, to avoid races.  */\n<line15>sigset_t oldset;\n<line16>sigprocmask (SIG_BLOCK, &caught_signals, &oldset);\n<line17>output_stream = fopen (output_filename, "w");\n<line18>fopen_ok = (output_stream != nullptr);\n<line19>fopen_errno = errno;\n<line20>files_created = nfiles + fopen_ok;\n<line21>sigprocmask (SIG_SETMASK, &oldset, nullptr);\n<line22>}\n<line23>if (! fopen_ok)\n<line24>{\n<line25>error (0, fopen_errno, "%s", quotef (output_filename));\n<line26>cleanup_fatal ();\n<line27>}\n<line28>bytes_written = 0;\n<line29>}
----------------------------------------
Function: delete_all_files
Content: <line0>static void\n<line1>delete_all_files (bool in_signal_handler)\n<line2>{\n<line3>if (! remove_files)\n<line4>return;\n<line5>for (int i = files_created; 0 <= --i; )\n<line6>{\n<line7>char const *name = make_filename (i);\n<line8>if (unlink (name) != 0 && errno != ENOENT && !in_signal_handler)\n<line9>error (0, errno, "%s", quotef (name));\n<line10>}\n<line11>files_created = 0;\n<line12>}
----------------------------------------
Function: close_output_file
Content: <line0>static void\n<line1>close_output_file (void)\n<line2>{\n<line3>if (output_stream)\n<line4>{\n<line5>if (ferror (output_stream))\n<line6>{\n<line7>error (0, 0, _("write error for %s"), quoteaf (output_filename));\n<line8>output_stream = nullptr;\n<line9>cleanup_fatal ();\n<line10>}\n<line11>if (fclose (output_stream) != 0)\n<line12>{\n<line13>error (0, errno, "%s", quotef (output_filename));\n<line14>output_stream = nullptr;\n<line15>cleanup_fatal ();\n<line16>}\n<line17>if (bytes_written == 0 && elide_empty_files)\n<line18>{\n<line19>sigset_t oldset;\n<line20>bool unlink_ok;\n<line21>int unlink_errno;\n<line22>/* Remove the output file in a critical section, to avoid races.  */\n<line23>sigprocmask (SIG_BLOCK, &caught_signals, &oldset);\n<line24>unlink_ok = (unlink (output_filename) == 0);\n<line25>unlink_errno = errno;\n<line26>files_created--;\n<line27>sigprocmask (SIG_SETMASK, &oldset, nullptr);\n<line28>if (! unlink_ok && unlink_errno != ENOENT)\n<line29>error (0, unlink_errno, "%s", quotef (output_filename));\n<line30>}\n<line31>else\n<line32>{\n<line33>if (!suppress_count)\n<line34>{\n<line35>char buf[INT_BUFSIZE_BOUND (intmax_t)];\n<line36>fprintf (stdout, "%s\n", imaxtostr (bytes_written, buf));\n<line37>}\n<line38>}\n<line39>output_stream = nullptr;\n<line40>}\n<line41>}
----------------------------------------
Function: save_line_to_file
Content: <line0>static void\n<line1>save_line_to_file (const struct cstring *line)\n<line2>{\n<line3>idx_t l = fwrite (line->str, sizeof (char), line->len, output_stream);\n<line4>if (l != line->len)\n<line5>{\n<line6>error (0, errno, _("write error for %s"), quoteaf (output_filename));\n<line7>output_stream = nullptr;\n<line8>cleanup_fatal ();\n<line9>}\n<line10>bytes_written += line->len;\n<line11>}
----------------------------------------
Function: new_control_record
Content: <line0>static struct control *\n<line1>new_control_record (void)\n<line2>{\n<line3>static idx_t control_allocated = 0; /* Total space allocated. */\n<line4>struct control *p;\n<line5>if (control_used == control_allocated)\n<line6>controls = xpalloc (controls, &control_allocated, 1, -1, sizeof *controls);\n<line7>p = &controls[control_used++];\n<line8>p->regexpr = false;\n<line9>p->repeat = 0;\n<line10>p->repeat_forever = false;\n<line11>p->lines_required = 0;\n<line12>p->offset = 0;\n<line13>return p;\n<line14>}
----------------------------------------
Function: check_for_offset
Content: <line0>static void\n<line1>check_for_offset (struct control *p, char const *str, char const *num)\n<line2>{\n<line3>if (xstrtoimax (num, nullptr, 10, &p->offset, "") != LONGINT_OK)\n<line4>error (EXIT_FAILURE, 0, _("%s: integer expected after delimiter"),\n<line5>quote (str));\n<line6>}
----------------------------------------
Function: parse_repeat_count
Content: <line0>static void\n<line1>parse_repeat_count (int argnum, struct control *p, char *str)\n<line2>{\n<line3>char *end;\n<line4>end = str + strlen (str) - 1;\n<line5>if (*end != '}')\n<line6>error (EXIT_FAILURE, 0, _("%s: '}' is required in repeat count"),\n<line7>quote (str));\n<line8>*end = '\0';\n<line9>if (str + 1 == end - 1 && *(str + 1) == '*')\n<line10>p->repeat_forever = true;\n<line11>else\n<line12>{\n<line13>uintmax_t val;\n<line14>if (xstrtoumax (str + 1, nullptr, 10, &val, "") != LONGINT_OK\n<line15>|| INTMAX_MAX < val)\n<line16>{\n<line17>error (EXIT_FAILURE, 0,\n<line18>_("%s}: integer required between '{' and '}'"),\n<line19>quote (global_argv[argnum]));\n<line20>}\n<line21>p->repeat = val;\n<line22>}\n<line23>*end = '}';\n<line24>}
----------------------------------------
Function: extract_regexp
Content: <line0>static struct control *\n<line1>extract_regexp (int argnum, bool ignore, char const *str)\n<line2>{\n<line3>idx_t len;			/* Number of bytes in this regexp. */\n<line4>char delim = *str;\n<line5>char const *closing_delim;\n<line6>struct control *p;\n<line7>char const *err;\n<line8>closing_delim = strrchr (str + 1, delim);\n<line9>if (closing_delim == nullptr)\n<line10>error (EXIT_FAILURE, 0,\n<line11>_("%s: closing delimiter '%c' missing"), str, delim);\n<line12>len = closing_delim - str - 1;\n<line13>p = new_control_record ();\n<line14>p->argnum = argnum;\n<line15>p->ignore = ignore;\n<line16>p->regexpr = true;\n<line17>p->re_compiled.buffer = nullptr;\n<line18>p->re_compiled.allocated = 0;\n<line19>p->re_compiled.fastmap = xmalloc (UCHAR_MAX + 1);\n<line20>p->re_compiled.translate = nullptr;\n<line21>re_syntax_options =\n<line22>RE_SYNTAX_POSIX_BASIC & ~RE_CONTEXT_INVALID_DUP & ~RE_NO_EMPTY_RANGES;\n<line23>err = re_compile_pattern (str + 1, len, &p->re_compiled);\n<line24>if (err)\n<line25>{\n<line26>error (0, 0, _("%s: invalid regular expression: %s"), quote (str), err);\n<line27>cleanup_fatal ();\n<line28>}\n<line29>if (closing_delim[1])\n<line30>check_for_offset (p, str, closing_delim + 1);\n<line31>return p;\n<line32>}
----------------------------------------
Function: parse_patterns
Content: <line0>static void\n<line1>parse_patterns (int argc, int start, char **argv)\n<line2>{\n<line3>struct control *p;		/* New control record created. */\n<line4>static intmax_t last_val = 0;\n<line5>for (int i = start; i < argc; i++)\n<line6>{\n<line7>if (*argv[i] == '/' || *argv[i] == '%')\n<line8>{\n<line9>p = extract_regexp (i, *argv[i] == '%', argv[i]);\n<line10>}\n<line11>else\n<line12>{\n<line13>p = new_control_record ();\n<line14>p->argnum = i;\n<line15>uintmax_t val;\n<line16>if (xstrtoumax (argv[i], nullptr, 10, &val, "") != LONGINT_OK\n<line17>|| INTMAX_MAX < val)\n<line18>error (EXIT_FAILURE, 0, _("%s: invalid pattern"), quote (argv[i]));\n<line19>if (val == 0)\n<line20>error (EXIT_FAILURE, 0,\n<line21>_("%s: line number must be greater than zero"), argv[i]);\n<line22>if (val < last_val)\n<line23>{\n<line24>char buf[INT_BUFSIZE_BOUND (intmax_t)];\n<line25>error (EXIT_FAILURE, 0,\n<line26>_("line number %s is smaller than preceding line number,"\n<line27>" %s"),\n<line28>quote (argv[i]), imaxtostr (last_val, buf));\n<line29>}\n<line30>if (val == last_val)\n<line31>error (0, 0,\n<line32>_("warning: line number %s is the same as preceding line number"),\n<line33>quote (argv[i]));\n<line34>last_val = val;\n<line35>p->lines_required = val;\n<line36>}\n<line37>if (i + 1 < argc && *argv[i + 1] == '{')\n<line38>{\n<line39>/* We have a repeat count. */\n<line40>i++;\n<line41>parse_repeat_count (i, p, argv[i]);\n<line42>}\n<line43>}\n<line44>}
----------------------------------------
Function: get_format_flags
Content: <line0>static idx_t\n<line1>get_format_flags (char const *format, int *flags_ptr)\n<line2>{\n<line3>int flags = 0;\n<line4>for (idx_t count = 0; ; count++)\n<line5>{\n<line6>switch (format[count])\n<line7>{\n<line8>case '-':\n<line9>case '0':\n<line10>break;\n<line11>case '\'':\n<line12>flags |= FLAG_THOUSANDS;\n<line13>break;\n<line14>case '#':\n<line15>flags |= FLAG_ALTERNATIVE;\n<line16>break;\n<line17>default:\n<line18>*flags_ptr = flags;\n<line19>return count;\n<line20>}\n<line21>}\n<line22>}
----------------------------------------
Function: check_format_conv_type
Content: <line0>static void\n<line1>check_format_conv_type (char *format, int flags)\n<line2>{\n<line3>unsigned char ch = *format;\n<line4>int compatible_flags = FLAG_THOUSANDS;\n<line5>switch (ch)\n<line6>{\n<line7>case 'd':\n<line8>case 'i':\n<line9>break;\n<line10>case 'u':\n<line11>*format = 'd';\n<line12>break;\n<line13>case 'o':\n<line14>case 'x':\n<line15>case 'X':\n<line16>compatible_flags = FLAG_ALTERNATIVE;\n<line17>break;\n<line18>case 0:\n<line19>error (EXIT_FAILURE, 0, _("missing conversion specifier in suffix"));\n<line20>default:\n<line21>if (isprint (ch))\n<line22>error (EXIT_FAILURE, 0,\n<line23>_("invalid conversion specifier in suffix: %c"), ch);\n<line24>else\n<line25>error (EXIT_FAILURE, 0,\n<line26>_("invalid conversion specifier in suffix: \\%.3o"), ch);\n<line27>}\n<line28>if (flags & ~ compatible_flags)\n<line29>error (EXIT_FAILURE, 0,\n<line30>_("invalid flags in conversion specification: %%%c%c"),\n<line31>(flags & ~ compatible_flags & FLAG_ALTERNATIVE ? '#' : '\''), ch);\n<line32>}
----------------------------------------
Function: max_out
Content: <line0>static idx_t\n<line1>max_out (char *format)\n<line2>{\n<line3>bool percent = false;\n<line4>for (char *f = format; *f; f++)\n<line5>if (*f == '%' && *++f != '%')\n<line6>{\n<line7>if (percent)\n<line8>error (EXIT_FAILURE, 0,\n<line9>_("too many %% conversion specifications in suffix"));\n<line10>percent = true;\n<line11>int flags;\n<line12>f += get_format_flags (f, &flags);\n<line13>while (ISDIGIT (*f))\n<line14>f++;\n<line15>if (*f == '.')\n<line16>while (ISDIGIT (*++f))\n<line17>continue;\n<line18>check_format_conv_type (f, flags);\n<line19>}\n<line20>if (! percent)\n<line21>error (EXIT_FAILURE, 0,\n<line22>_("missing %% conversion specification in suffix"));\n<line23>int maxlen = snprintf (nullptr, 0, format, INT_MAX);\n<line24>if (maxlen < 0)\n<line25>xalloc_die ();\n<line26>return maxlen;\n<line27>}
----------------------------------------
Function: main
Content: <line0>int\n<line1>main (int argc, char **argv)\n<line2>{\n<line3>int optc;\n<line4>initialize_main (&argc, &argv);\n<line5>set_program_name (argv[0]);\n<line6>setlocale (LC_ALL, "");\n<line7>bindtextdomain (PACKAGE, LOCALEDIR);\n<line8>textdomain (PACKAGE);\n<line9>atexit (close_stdout);\n<line10>global_argv = argv;\n<line11>controls = nullptr;\n<line12>control_used = 0;\n<line13>suppress_count = false;\n<line14>remove_files = true;\n<line15>suppress_matched = false;\n<line16>prefix = DEFAULT_PREFIX;\n<line17>while ((optc = getopt_long (argc, argv, "f:b:kn:sqz", longopts, nullptr))\n<line18>!= -1)\n<line19>switch (optc)\n<line20>{\n<line21>case 'f':\n<line22>prefix = optarg;\n<line23>break;\n<line24>case 'b':\n<line25>suffix = optarg;\n<line26>break;\n<line27>case 'k':\n<line28>remove_files = false;\n<line29>break;\n<line30>case 'n':\n<line31>digits = xdectoimax (optarg, 0, MIN (INT_MAX, IDX_MAX), "",\n<line32>_("invalid number"), 0);\n<line33>break;\n<line34>case 's':\n<line35>case 'q':\n<line36>suppress_count = true;\n<line37>break;\n<line38>case 'z':\n<line39>elide_empty_files = true;\n<line40>break;\n<line41>case SUPPRESS_MATCHED_OPTION:\n<line42>suppress_matched = true;\n<line43>break;\n<line44>case_GETOPT_HELP_CHAR;\n<line45>case_GETOPT_VERSION_CHAR (PROGRAM_NAME, AUTHORS);\n<line46>default:\n<line47>usage (EXIT_FAILURE);\n<line48>}\n<line49>if (argc - optind < 2)\n<line50>{\n<line51>if (argc <= optind)\n<line52>error (0, 0, _("missing operand"));\n<line53>else\n<line54>error (0, 0, _("missing operand after %s"), quote (argv[argc - 1]));\n<line55>usage (EXIT_FAILURE);\n<line56>}\n<line57>idx_t prefix_len = strlen (prefix);\n<line58>idx_t max_digit_string_len\n<line59>= (suffix\n<line60>? max_out (suffix)\n<line61>: MAX (INT_STRLEN_BOUND (int), digits));\n<line62>idx_t filename_size;\n<line63>if (ckd_add (&filename_size, prefix_len, max_digit_string_len + 1))\n<line64>xalloc_die ();\n<line65>filename_space = ximalloc (filename_size);\n<line66>set_input_file (argv[optind++]);\n<line67>parse_patterns (argc, optind, argv);\n<line68>{\n<line69>int i;\n<line70>static int const sig[] =\n<line71>{\n<line72>/* The usual suspects.  */\n<line73>SIGALRM, SIGHUP, SIGINT, SIGPIPE, SIGQUIT, SIGTERM,\n<line74>#ifdef SIGPOLL\n<line75>SIGPOLL,\n<line76>#endif\n<line77>#ifdef SIGPROF\n<line78>SIGPROF,\n<line79>#endif\n<line80>#ifdef SIGVTALRM\n<line81>SIGVTALRM,\n<line82>#endif\n<line83>#ifdef SIGXCPU\n<line84>SIGXCPU,\n<line85>#endif\n<line86>#ifdef SIGXFSZ\n<line87>SIGXFSZ,\n<line88>#endif\n<line89>};\n<line90>enum { nsigs = ARRAY_CARDINALITY (sig) };\n<line91>struct sigaction act;\n<line92>sigemptyset (&caught_signals);\n<line93>for (i = 0; i < nsigs; i++)\n<line94>{\n<line95>sigaction (sig[i], nullptr, &act);\n<line96>if (act.sa_handler != SIG_IGN)\n<line97>sigaddset (&caught_signals, sig[i]);\n<line98>}\n<line99>act.sa_handler = interrupt_handler;\n<line100>act.sa_mask = caught_signals;\n<line101>act.sa_flags = 0;\n<line102>for (i = 0; i < nsigs; i++)\n<line103>if (sigismember (&caught_signals, sig[i]))\n<line104>sigaction (sig[i], &act, nullptr);\n<line105>}\n<line106>split_file ();\n<line107>if (close (STDIN_FILENO) != 0)\n<line108>{\n<line109>error (0, errno, _("read error"));\n<line110>cleanup_fatal ();\n<line111>}\n<line112>return EXIT_SUCCESS;\n<line113>}
----------------------------------------
Function: usage
Content: <line0>void\n<line1>usage (int status)\n<line2>{\n<line3>if (status != EXIT_SUCCESS)\n<line4>emit_try_help ();\n<line5>else\n<line6>{\n<line7>printf (_("\\n<line8>Usage: %s [OPTION]... FILE PATTERN...\n\\n<line9>"),\n<line10>program_name);\n<line11>fputs (_("\\n<line12>Output pieces of FILE separated by PATTERN(s) to files 'xx00', 'xx01', ...,\n\\n<line13>and output byte counts of each piece to standard output.\n\\n<line14>"), stdout);\n<line15>fputs (_("\\n<line16>\n\\n<line17>Read standard input if FILE is -\n\\n<line18>"), stdout);\n<line19>emit_mandatory_arg_note ();\n<line20>fputs (_("\\n<line21>-b, --suffix-format=FORMAT  use sprintf FORMAT instead of %02d\n\\n<line22>-f, --prefix=PREFIX        use PREFIX instead of 'xx'\n\\n<line23>-k, --keep-files           do not remove output files on errors\n\\n<line24>"), stdout);\n<line25>fputs (_("\\n<line26>--suppress-matched     suppress the lines matching PATTERN\n\\n<line27>"), stdout);\n<line28>fputs (_("\\n<line29>-n, --digits=DIGITS        use specified number of digits instead of 2\n\\n<line30>-s, --quiet, --silent      do not print counts of output file sizes\n\\n<line31>-z, --elide-empty-files    suppress empty output files\n\\n<line32>"), stdout);\n<line33>fputs (HELP_OPTION_DESCRIPTION, stdout);\n<line34>fputs (VERSION_OPTION_DESCRIPTION, stdout);\n<line35>fputs (_("\\n<line36>\n\\n<line37>Each PATTERN may be:\n\\n<line38>INTEGER            copy up to but not including specified line number\n\\n<line39>/REGEXP/[OFFSET]   copy up to but not including a matching line\n\\n<line40>%REGEXP%[OFFSET]   skip to, but not including a matching line\n\\n<line41>{INTEGER}          repeat the previous pattern specified number of times\n\\n<line42>{*}                repeat the previous pattern as many times as possible\n\\n<line43>\n\\n<line44>A line OFFSET is an integer optionally preceded by '+' or '-'\n\\n<line45>"), stdout);\n<line46>emit_ancillary_info (PROGRAM_NAME);\n<line47>}\n<line48>exit (status);\n<line49>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/src/cut.c
========================================
Function: usage
Content: <line0>void\n<line1>usage (int status)\n<line2>{\n<line3>if (status != EXIT_SUCCESS)\n<line4>emit_try_help ();\n<line5>else\n<line6>{\n<line7>printf (_("\\n<line8>Usage: %s OPTION... [FILE]...\n\\n<line9>"),\n<line10>program_name);\n<line11>fputs (_("\\n<line12>Print selected parts of lines from each FILE to standard output.\n\\n<line13>"), stdout);\n<line14>emit_stdin_note ();\n<line15>emit_mandatory_arg_note ();\n<line16>fputs (_("\\n<line17>-b, --bytes=LIST        select only these bytes\n\\n<line18>-c, --characters=LIST   select only these characters\n\\n<line19>-d, --delimiter=DELIM   use DELIM instead of TAB for field delimiter\n\\n<line20>"), stdout);\n<line21>fputs (_("\\n<line22>-f, --fields=LIST       select only these fields;  also print any line\n\\n<line23>that contains no delimiter character, unless\n\\n<line24>the -s option is specified\n\\n<line25>-n                      (ignored)\n\\n<line26>"), stdout);\n<line27>fputs (_("\\n<line28>--complement        complement the set of selected bytes, characters\n\\n<line29>or fields\n\\n<line30>"), stdout);\n<line31>fputs (_("\\n<line32>-s, --only-delimited    do not print lines not containing delimiters\n\\n<line33>--output-delimiter=STRING  use STRING as the output delimiter\n\\n<line34>the default is to use the input delimiter\n\\n<line35>"), stdout);\n<line36>fputs (_("\\n<line37>-z, --zero-terminated   line delimiter is NUL, not newline\n\\n<line38>"), stdout);\n<line39>fputs (HELP_OPTION_DESCRIPTION, stdout);\n<line40>fputs (VERSION_OPTION_DESCRIPTION, stdout);\n<line41>fputs (_("\\n<line42>\n\\n<line43>Use one, and only one of -b, -c or -f.  Each LIST is made up of one\n\\n<line44>range, or many ranges separated by commas.  Selected input is written\n\\n<line45>in the same order that it is read, and is written exactly once.\n\\n<line46>"), stdout);\n<line47>fputs (_("\\n<line48>Each range is one of:\n\\n<line49>\n\\n<line50>N     N'th byte, character or field, counted from 1\n\\n<line51>N-    from N'th byte, character or field, to end of line\n\\n<line52>N-M   from N'th to M'th (included) byte, character or field\n\\n<line53>-M    from first to M'th (included) byte, character or field\n\\n<line54>"), stdout);\n<line55>emit_ancillary_info (PROGRAM_NAME);\n<line56>}\n<line57>exit (status);\n<line58>}
----------------------------------------
Function: next_item
Content: <line0>static inline void\n<line1>next_item (uintmax_t *item_idx)\n<line2>{\n<line3>(*item_idx)++;\n<line4>if ((*item_idx) > current_rp->hi)\n<line5>current_rp++;\n<line6>}
----------------------------------------
Function: print_kth
Content: <line0>static inline bool\n<line1>print_kth (uintmax_t k)\n<line2>{\n<line3>return current_rp->lo <= k;\n<line4>}
----------------------------------------
Function: is_range_start_index
Content: <line0>static inline bool\n<line1>is_range_start_index (uintmax_t k)\n<line2>{\n<line3>return k == current_rp->lo;\n<line4>}
----------------------------------------
Function: cut_bytes
Content: <line0>static void\n<line1>cut_bytes (FILE *stream)\n<line2>{\n<line3>uintmax_t byte_idx;	/* Number of bytes in the line so far.  */\n<line4>/* Whether to begin printing delimiters between ranges for the current line.\n<line5>Set after we've begun printing data corresponding to the first range.  */\n<line6>bool print_delimiter;\n<line7>byte_idx = 0;\n<line8>print_delimiter = false;\n<line9>current_rp = frp;\n<line10>while (true)\n<line11>{\n<line12>int c;		/* Each character from the file.  */\n<line13>c = getc (stream);\n<line14>if (c == line_delim)\n<line15>{\n<line16>if (putchar (c) < 0)\n<line17>write_error ();\n<line18>byte_idx = 0;\n<line19>print_delimiter = false;\n<line20>current_rp = frp;\n<line21>}\n<line22>else if (c == EOF)\n<line23>{\n<line24>if (byte_idx > 0)\n<line25>{\n<line26>if (putchar (line_delim) < 0)\n<line27>write_error ();\n<line28>}\n<line29>break;\n<line30>}\n<line31>else\n<line32>{\n<line33>next_item (&byte_idx);\n<line34>if (print_kth (byte_idx))\n<line35>{\n<line36>if (output_delimiter_string != output_delimiter_default)\n<line37>{\n<line38>if (print_delimiter && is_range_start_index (byte_idx))\n<line39>{\n<line40>if (fwrite (output_delimiter_string, sizeof (char),\n<line41>output_delimiter_length, stdout)\n<line42>!= output_delimiter_length)\n<line43>write_error ();\n<line44>}\n<line45>print_delimiter = true;\n<line46>}\n<line47>if (putchar (c) < 0)\n<line48>write_error ();\n<line49>}\n<line50>}\n<line51>}\n<line52>}
----------------------------------------
Function: cut_fields
Content: <line0>static void\n<line1>cut_fields (FILE *stream)\n<line2>{\n<line3>int c;	/* Each character from the file.  */\n<line4>uintmax_t field_idx = 1;\n<line5>bool found_any_selected_field = false;\n<line6>bool buffer_first_field;\n<line7>current_rp = frp;\n<line8>c = getc (stream);\n<line9>if (c == EOF)\n<line10>return;\n<line11>ungetc (c, stream);\n<line12>c = 0;\n<line13>/* To support the semantics of the -s flag, we may have to buffer\n<line14>all of the first field to determine whether it is 'delimited.'\n<line15>But that is unnecessary if all non-delimited lines must be printed\n<line16>and the first field has been selected, or if non-delimited lines\n<line17>must be suppressed and the first field has *not* been selected.\n<line18>That is because a non-delimited line has exactly one field.  */\n<line19>buffer_first_field = (suppress_non_delimited ^ !print_kth (1));\n<line20>while (true)\n<line21>{\n<line22>if (field_idx == 1 && buffer_first_field)\n<line23>{\n<line24>ssize_t len;\n<line25>size_t n_bytes;\n<line26>len = getndelim2 (&field_1_buffer, &field_1_bufsize, 0,\n<line27>GETNLINE_NO_LIMIT, delim, line_delim, stream);\n<line28>if (len < 0)\n<line29>{\n<line30>free (field_1_buffer);\n<line31>field_1_buffer = nullptr;\n<line32>if (ferror (stream) || feof (stream))\n<line33>break;\n<line34>xalloc_die ();\n<line35>}\n<line36>n_bytes = len;\n<line37>affirm (n_bytes != 0);\n<line38>c = 0;\n<line39>/* If the first field extends to the end of line (it is not\n<line40>delimited) and we are printing all non-delimited lines,\n<line41>print this one.  */\n<line42>if (to_uchar (field_1_buffer[n_bytes - 1]) != delim)\n<line43>{\n<line44>if (suppress_non_delimited)\n<line45>{\n<line46>/* Empty.  */\n<line47>}\n<line48>else\n<line49>{\n<line50>if (fwrite (field_1_buffer, sizeof (char), n_bytes, stdout)\n<line51>!= n_bytes)\n<line52>write_error ();\n<line53>/* Make sure the output line is newline terminated.  */\n<line54>if (field_1_buffer[n_bytes - 1] != line_delim)\n<line55>{\n<line56>if (putchar (line_delim) < 0)\n<line57>write_error ();\n<line58>}\n<line59>c = line_delim;\n<line60>}\n<line61>continue;\n<line62>}\n<line63>if (print_kth (1))\n<line64>{\n<line65>/* Print the field, but not the trailing delimiter.  */\n<line66>if (fwrite (field_1_buffer, sizeof (char), n_bytes - 1, stdout)\n<line67>!= n_bytes - 1)\n<line68>write_error ();\n<line69>/* With -d$'\n' don't treat the last '\n' as a delimiter.  */\n<line70>if (delim == line_delim)\n<line71>{\n<line72>int last_c = getc (stream);\n<line73>if (last_c != EOF)\n<line74>{\n<line75>ungetc (last_c, stream);\n<line76>found_any_selected_field = true;\n<line77>}\n<line78>}\n<line79>else\n<line80>{\n<line81>found_any_selected_field = true;\n<line82>}\n<line83>}\n<line84>next_item (&field_idx);\n<line85>}\n<line86>int prev_c = c;\n<line87>if (print_kth (field_idx))\n<line88>{\n<line89>if (found_any_selected_field)\n<line90>{\n<line91>if (fwrite (output_delimiter_string, sizeof (char),\n<line92>output_delimiter_length, stdout)\n<line93>!= output_delimiter_length)\n<line94>write_error ();\n<line95>}\n<line96>found_any_selected_field = true;\n<line97>while ((c = getc (stream)) != delim && c != line_delim && c != EOF)\n<line98>{\n<line99>if (putchar (c) < 0)\n<line100>write_error ();\n<line101>prev_c = c;\n<line102>}\n<line103>}\n<line104>else\n<line105>{\n<line106>while ((c = getc (stream)) != delim && c != line_delim && c != EOF)\n<line107>prev_c = c;\n<line108>}\n<line109>/* With -d$'\n' don't treat the last '\n' as a delimiter.  */\n<line110>if (delim == line_delim && c == delim)\n<line111>{\n<line112>int last_c = getc (stream);\n<line113>if (last_c != EOF)\n<line114>ungetc (last_c, stream);\n<line115>else\n<line116>c = last_c;\n<line117>}\n<line118>if (c == delim)\n<line119>next_item (&field_idx);\n<line120>else if (c == line_delim || c == EOF)\n<line121>{\n<line122>if (found_any_selected_field\n<line123>|| !(suppress_non_delimited && field_idx == 1))\n<line124>{\n<line125>/* Make sure the output line is newline terminated.  */\n<line126>if (c == line_delim || prev_c != line_delim\n<line127>|| delim == line_delim)\n<line128>{\n<line129>if (putchar (line_delim) < 0)\n<line130>write_error ();\n<line131>}\n<line132>}\n<line133>if (c == EOF)\n<line134>break;\n<line135>/* Start processing the next input line.  */\n<line136>field_idx = 1;\n<line137>current_rp = frp;\n<line138>found_any_selected_field = false;\n<line139>}\n<line140>}\n<line141>}
----------------------------------------
Function: cut_file
Content: <line0>static bool\n<line1>cut_file (char const *file, void (*cut_stream) (FILE *))\n<line2>{\n<line3>FILE *stream;\n<line4>if (STREQ (file, "-"))\n<line5>{\n<line6>have_read_stdin = true;\n<line7>stream = stdin;\n<line8>assume (stream);  /* Pacify GCC bug#109613.  */\n<line9>}\n<line10>else\n<line11>{\n<line12>stream = fopen (file, "r");\n<line13>if (stream == nullptr)\n<line14>{\n<line15>error (0, errno, "%s", quotef (file));\n<line16>return false;\n<line17>}\n<line18>}\n<line19>fadvise (stream, FADVISE_SEQUENTIAL);\n<line20>cut_stream (stream);\n<line21>int err = errno;\n<line22>if (!ferror (stream))\n<line23>err = 0;\n<line24>if (STREQ (file, "-"))\n<line25>clearerr (stream);		/* Also clear EOF.  */\n<line26>else if (fclose (stream) == EOF)\n<line27>err = errno;\n<line28>if (err)\n<line29>{\n<line30>error (0, err, "%s", quotef (file));\n<line31>return false;\n<line32>}\n<line33>return true;\n<line34>}
----------------------------------------
Function: main
Content: <line0>int\n<line1>main (int argc, char **argv)\n<line2>{\n<line3>int optc;\n<line4>bool ok;\n<line5>bool delim_specified = false;\n<line6>bool byte_mode = false;\n<line7>char *spec_list_string = nullptr;\n<line8>initialize_main (&argc, &argv);\n<line9>set_program_name (argv[0]);\n<line10>setlocale (LC_ALL, "");\n<line11>bindtextdomain (PACKAGE, LOCALEDIR);\n<line12>textdomain (PACKAGE);\n<line13>atexit (close_stdout);\n<line14>/* By default, all non-delimited lines are printed.  */\n<line15>suppress_non_delimited = false;\n<line16>delim = '\0';\n<line17>have_read_stdin = false;\n<line18>while ((optc = getopt_long (argc, argv, "b:c:d:f:nsz", longopts, nullptr))\n<line19>!= -1)\n<line20>{\n<line21>switch (optc)\n<line22>{\n<line23>case 'b':\n<line24>case 'c':\n<line25>/* Build the byte list.  */\n<line26>byte_mode = true;\n<line27>FALLTHROUGH;\n<line28>case 'f':\n<line29>/* Build the field list.  */\n<line30>if (spec_list_string)\n<line31>FATAL_ERROR (_("only one list may be specified"));\n<line32>spec_list_string = optarg;\n<line33>break;\n<line34>case 'd':\n<line35>/* New delimiter.  */\n<line36>/* Interpret -d '' to mean 'use the NUL byte as the delimiter.'  */\n<line37>if (optarg[0] != '\0' && optarg[1] != '\0')\n<line38>FATAL_ERROR (_("the delimiter must be a single character"));\n<line39>delim = optarg[0];\n<line40>delim_specified = true;\n<line41>break;\n<line42>case OUTPUT_DELIMITER_OPTION:\n<line43>/* Interpret --output-delimiter='' to mean\n<line44>'use the NUL byte as the delimiter.'  */\n<line45>output_delimiter_length = (optarg[0] == '\0'\n<line46>? 1 : strlen (optarg));\n<line47>output_delimiter_string = optarg;\n<line48>break;\n<line49>case 'n':\n<line50>break;\n<line51>case 's':\n<line52>suppress_non_delimited = true;\n<line53>break;\n<line54>case 'z':\n<line55>line_delim = '\0';\n<line56>break;\n<line57>case COMPLEMENT_OPTION:\n<line58>complement = true;\n<line59>break;\n<line60>case_GETOPT_HELP_CHAR;\n<line61>case_GETOPT_VERSION_CHAR (PROGRAM_NAME, AUTHORS);\n<line62>default:\n<line63>usage (EXIT_FAILURE);\n<line64>}\n<line65>}\n<line66>if (!spec_list_string)\n<line67>FATAL_ERROR (_("you must specify a list of bytes, characters, or fields"));\n<line68>if (byte_mode)\n<line69>{\n<line70>if (delim_specified)\n<line71>FATAL_ERROR (_("an input delimiter may be specified only\\n<line72>when operating on fields"));\n<line73>if (suppress_non_delimited)\n<line74>FATAL_ERROR (_("suppressing non-delimited lines makes sense\n\\n<line75>\tonly when operating on fields"));\n<line76>}\n<line77>set_fields (spec_list_string,\n<line78>((byte_mode ? SETFLD_ERRMSG_USE_POS : 0)\n<line79>| (complement ? SETFLD_COMPLEMENT : 0)));\n<line80>if (!delim_specified)\n<line81>delim = '\t';\n<line82>if (output_delimiter_string == nullptr)\n<line83>{\n<line84>output_delimiter_default[0] = delim;\n<line85>output_delimiter_string = output_delimiter_default;\n<line86>output_delimiter_length = 1;\n<line87>}\n<line88>void (*cut_stream) (FILE *) = byte_mode ? cut_bytes : cut_fields;\n<line89>if (optind == argc)\n<line90>ok = cut_file ("-", cut_stream);\n<line91>else\n<line92>for (ok = true; optind < argc; optind++)\n<line93>ok &= cut_file (argv[optind], cut_stream);\n<line94>if (have_read_stdin && fclose (stdin) == EOF)\n<line95>{\n<line96>error (0, errno, "-");\n<line97>ok = false;\n<line98>}\n<line99>return ok ? EXIT_SUCCESS : EXIT_FAILURE;\n<line100>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/src/set-fields.c
========================================
Function: add_range_pair
Content: <line0>static void\n<line1>add_range_pair (uintmax_t lo, uintmax_t hi)\n<line2>{\n<line3>if (n_frp == n_frp_allocated)\n<line4>frp = X2NREALLOC (frp, &n_frp_allocated);\n<line5>frp[n_frp].lo = lo;\n<line6>frp[n_frp].hi = hi;\n<line7>++n_frp;\n<line8>}
----------------------------------------
Function: compare_ranges
Content: <line0>static int\n<line1>compare_ranges (const void *a, const void *b)\n<line2>{\n<line3>struct field_range_pair const *ap = a, *bp = b;\n<line4>return (ap->lo > bp->lo) - (ap->lo < bp->lo);\n<line5>}
----------------------------------------
Function: complement_rp
Content: <line0>static void\n<line1>complement_rp (void)\n<line2>{\n<line3>struct field_range_pair *c = frp;\n<line4>size_t n = n_frp;\n<line5>frp = nullptr;\n<line6>n_frp = 0;\n<line7>n_frp_allocated = 0;\n<line8>if (c[0].lo > 1)\n<line9>add_range_pair (1, c[0].lo - 1);\n<line10>for (size_t i = 1; i < n; ++i)\n<line11>{\n<line12>if (c[i - 1].hi + 1 == c[i].lo)\n<line13>continue;\n<line14>add_range_pair (c[i - 1].hi + 1, c[i].lo - 1);\n<line15>}\n<line16>if (c[n - 1].hi < UINTMAX_MAX)\n<line17>add_range_pair (c[n - 1].hi + 1, UINTMAX_MAX);\n<line18>free (c);\n<line19>}
----------------------------------------
Function: set_fields
Content: <line0>void\n<line1>set_fields (char const *fieldstr, unsigned int options)\n<line2>{\n<line3>uintmax_t initial = 1;	/* Value of first number in a range.  */\n<line4>uintmax_t value = 0;		/* If nonzero, a number being accumulated.  */\n<line5>bool lhs_specified = false;\n<line6>bool rhs_specified = false;\n<line7>bool dash_found = false;	/* True if a '-' is found in this field.  */\n<line8>bool in_digits = false;\n<line9>/* Collect and store in RP the range end points. */\n<line10>/* Special case: '--field=-' means all fields, emulate '--field=1-' . */\n<line11>if ((options & SETFLD_ALLOW_DASH) && STREQ (fieldstr,"-"))\n<line12>{\n<line13>value = 1;\n<line14>lhs_specified = true;\n<line15>dash_found = true;\n<line16>fieldstr++;\n<line17>}\n<line18>while (true)\n<line19>{\n<line20>if (*fieldstr == '-')\n<line21>{\n<line22>in_digits = false;\n<line23>/* Starting a range. */\n<line24>if (dash_found)\n<line25>FATAL_ERROR ((options & SETFLD_ERRMSG_USE_POS)\n<line26>? _("invalid byte or character range")\n<line27>: _("invalid field range"));\n<line28>dash_found = true;\n<line29>fieldstr++;\n<line30>if (lhs_specified && !value)\n<line31>FATAL_ERROR ((options & SETFLD_ERRMSG_USE_POS)\n<line32>? _("byte/character positions are numbered from 1")\n<line33>: _("fields are numbered from 1"));\n<line34>initial = (lhs_specified ? value : 1);\n<line35>value = 0;\n<line36>}\n<line37>else if (*fieldstr == ','\n<line38>|| isblank (to_uchar (*fieldstr)) || *fieldstr == '\0')\n<line39>{\n<line40>in_digits = false;\n<line41>/* Ending the string, or this field/byte sublist. */\n<line42>if (dash_found)\n<line43>{\n<line44>dash_found = false;\n<line45>if (!lhs_specified && !rhs_specified)\n<line46>{\n<line47>/* if a lone dash is allowed, emulate '1-' for all fields */\n<line48>if (options & SETFLD_ALLOW_DASH)\n<line49>initial = 1;\n<line50>else\n<line51>FATAL_ERROR (_("invalid range with no endpoint: -"));\n<line52>}\n<line53>/* A range.  Possibilities: -n, m-n, n-.\n<line54>In any case, 'initial' contains the start of the range. */\n<line55>if (!rhs_specified)\n<line56>{\n<line57>/* 'n-'.  From 'initial' to end of line. */\n<line58>add_range_pair (initial, UINTMAX_MAX);\n<line59>}\n<line60>else\n<line61>{\n<line62>/* 'm-n' or '-n' (1-n). */\n<line63>if (value < initial)\n<line64>FATAL_ERROR (_("invalid decreasing range"));\n<line65>add_range_pair (initial, value);\n<line66>}\n<line67>value = 0;\n<line68>}\n<line69>else\n<line70>{\n<line71>/* A simple field number, not a range. */\n<line72>if (value == 0)\n<line73>FATAL_ERROR ((options & SETFLD_ERRMSG_USE_POS)\n<line74>? _("byte/character positions are numbered from 1")\n<line75>: _("fields are numbered from 1"));\n<line76>add_range_pair (value, value);\n<line77>value = 0;\n<line78>}\n<line79>if (*fieldstr == '\0')\n<line80>break;\n<line81>fieldstr++;\n<line82>lhs_specified = false;\n<line83>rhs_specified = false;\n<line84>}\n<line85>else if (ISDIGIT (*fieldstr))\n<line86>{\n<line87>/* Record beginning of digit string, in case we have to\n<line88>complain about it.  */\n<line89>static char const *num_start;\n<line90>if (!in_digits || !num_start)\n<line91>num_start = fieldstr;\n<line92>in_digits = true;\n<line93>if (dash_found)\n<line94>rhs_specified = 1;\n<line95>else\n<line96>lhs_specified = 1;\n<line97>/* Detect overflow.  */\n<line98>if (!DECIMAL_DIGIT_ACCUMULATE (value, *fieldstr - '0', uintmax_t)\n<line99>|| value == UINTMAX_MAX)\n<line100>{\n<line101>/* In case the user specified -c$(echo 2^64|bc),22,\n<line102>complain only about the first number.  */\n<line103>/* Determine the length of the offending number.  */\n<line104>size_t len = strspn (num_start, "0123456789");\n<line105>char *bad_num = ximemdup0 (num_start, len);\n<line106>error (0, 0, (options & SETFLD_ERRMSG_USE_POS)\n<line107>?_("byte/character offset %s is too large")\n<line108>:_("field number %s is too large"),\n<line109>quote (bad_num));\n<line110>free (bad_num);\n<line111>usage (EXIT_FAILURE);\n<line112>}\n<line113>fieldstr++;\n<line114>}\n<line115>else\n<line116>{\n<line117>error (0, 0, (options & SETFLD_ERRMSG_USE_POS)\n<line118>?_("invalid byte/character position %s")\n<line119>:_("invalid field value %s"),\n<line120>quote (fieldstr));\n<line121>usage (EXIT_FAILURE);\n<line122>}\n<line123>}\n<line124>if (!n_frp)\n<line125>FATAL_ERROR ((options&SETFLD_ERRMSG_USE_POS)\n<line126>? _("missing list of byte/character positions")\n<line127>: _("missing list of fields"));\n<line128>qsort (frp, n_frp, sizeof (frp[0]), compare_ranges);\n<line129>/* Merge range pairs (e.g. `2-5,3-4' becomes `2-5'). */\n<line130>for (size_t i = 0; i < n_frp; ++i)\n<line131>{\n<line132>for (size_t j = i + 1; j < n_frp; ++j)\n<line133>{\n<line134>if (frp[j].lo <= frp[i].hi)\n<line135>{\n<line136>frp[i].hi = MAX (frp[j].hi, frp[i].hi);\n<line137>memmove (frp + j, frp + j + 1, (n_frp - j - 1) * sizeof *frp);\n<line138>n_frp--;\n<line139>j--;\n<line140>}\n<line141>else\n<line142>break;\n<line143>}\n<line144>}\n<line145>if (options & SETFLD_COMPLEMENT)\n<line146>complement_rp ();\n<line147>/* After merging, reallocate RP so we release memory to the system.\n<line148>Also add a sentinel at the end of RP, to avoid out of bounds access\n<line149>and for performance reasons.  */\n<line150>++n_frp;\n<line151>frp = xrealloc (frp, n_frp * sizeof (struct field_range_pair));\n<line152>frp[n_frp - 1].lo = frp[n_frp - 1].hi = UINTMAX_MAX;\n<line153>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/src/date.c
========================================
/home/huihui/Downloads/coreutils-9.4/src/date.c:71:1: warning: '_Static_assert' with no message is a C2x extension [-Wc2x-extensions]
ARGMATCH_VERIFY (time_spec_string, time_spec);
^
./lib/argmatch.h:49:54: note: expanded from macro 'ARGMATCH_VERIFY'
                   == ARRAY_CARDINALITY (Vallist) + 1)
                                                     ^
1 warning generated.
Function: usage
Content: <line0>void\n<line1>usage (int status)\n<line2>{\n<line3>if (status != EXIT_SUCCESS)\n<line4>emit_try_help ();\n<line5>else\n<line6>{\n<line7>printf (_("\\n<line8>Usage: %s [OPTION]... [+FORMAT]\n\\n<line9>or:  %s [-u|--utc|--universal] [MMDDhhmm[[CC]YY][.ss]]\n\\n<line10>"),\n<line11>program_name, program_name);\n<line12>fputs (_("\\n<line13>Display date and time in the given FORMAT.\n\\n<line14>With -s, or with [MMDDhhmm[[CC]YY][.ss]], set the date and time.\n\\n<line15>"), stdout);\n<line16>emit_mandatory_arg_note ();\n<line17>fputs (_("\\n<line18>-d, --date=STRING          display time described by STRING, not 'now'\n\\n<line19>"), stdout);\n<line20>fputs (_("\\n<line21>--debug                annotate the parsed date,\n\\n<line22>and warn about questionable usage to stderr\n\\n<line23>"), stdout);\n<line24>fputs (_("\\n<line25>-f, --file=DATEFILE        like --date; once for each line of DATEFILE\n\\n<line26>"), stdout);\n<line27>fputs (_("\\n<line28>-I[FMT], --iso-8601[=FMT]  output date/time in ISO 8601 format.\n\\n<line29>FMT='date' for date only (the default),\n\\n<line30>'hours', 'minutes', 'seconds', or 'ns'\n\\n<line31>for date and time to the indicated precision.\n\\n<line32>Example: 2006-08-14T02:34:56-06:00\n\\n<line33>"), stdout);\n<line34>fputs (_("\\n<line35>--resolution               output the available resolution of timestamps\n\\n<line36>Example: 0.000000001\n\\n<line37>"), stdout);\n<line38>fputs (_("\\n<line39>-R, --rfc-email            output date and time in RFC 5322 format.\n\\n<line40>Example: Mon, 14 Aug 2006 02:34:56 -0600\n\\n<line41>"), stdout);\n<line42>fputs (_("\\n<line43>--rfc-3339=FMT         output date/time in RFC 3339 format.\n\\n<line44>FMT='date', 'seconds', or 'ns'\n\\n<line45>for date and time to the indicated precision.\n\\n<line46>Example: 2006-08-14 02:34:56-06:00\n\\n<line47>"), stdout);\n<line48>fputs (_("\\n<line49>-r, --reference=FILE       display the last modification time of FILE\n\\n<line50>"), stdout);\n<line51>fputs (_("\\n<line52>-s, --set=STRING           set time described by STRING\n\\n<line53>-u, --utc, --universal     print or set Coordinated Universal Time (UTC)\n\\n<line54>"), stdout);\n<line55>fputs (HELP_OPTION_DESCRIPTION, stdout);\n<line56>fputs (VERSION_OPTION_DESCRIPTION, stdout);\n<line57>fputs (_("\\n<line58>\n\\n<line59>All options that specify the date to display are mutually exclusive.\n\\n<line60>I.e.: --date, --file, --reference, --resolution.\n\\n<line61>"), stdout);\n<line62>fputs (_("\\n<line63>\n\\n<line64>FORMAT controls the output.  Interpreted sequences are:\n\\n<line65>\n\\n<line66>%%   a literal %\n\\n<line67>%a   locale's abbreviated weekday name (e.g., Sun)\n\\n<line68>"), stdout);\n<line69>fputs (_("\\n<line70>%A   locale's full weekday name (e.g., Sunday)\n\\n<line71>%b   locale's abbreviated month name (e.g., Jan)\n\\n<line72>%B   locale's full month name (e.g., January)\n\\n<line73>%c   locale's date and time (e.g., Thu Mar  3 23:05:25 2005)\n\\n<line74>"), stdout);\n<line75>fputs (_("\\n<line76>%C   century; like %Y, except omit last two digits (e.g., 20)\n\\n<line77>%d   day of month (e.g., 01)\n\\n<line78>%D   date; same as %m/%d/%y\n\\n<line79>%e   day of month, space padded; same as %_d\n\\n<line80>"), stdout);\n<line81>fputs (_("\\n<line82>%F   full date; like %+4Y-%m-%d\n\\n<line83>%g   last two digits of year of ISO week number (see %G)\n\\n<line84>%G   year of ISO week number (see %V); normally useful only with %V\n\\n<line85>"), stdout);\n<line86>fputs (_("\\n<line87>%h   same as %b\n\\n<line88>%H   hour (00..23)\n\\n<line89>%I   hour (01..12)\n\\n<line90>%j   day of year (001..366)\n\\n<line91>"), stdout);\n<line92>fputs (_("\\n<line93>%k   hour, space padded ( 0..23); same as %_H\n\\n<line94>%l   hour, space padded ( 1..12); same as %_I\n\\n<line95>%m   month (01..12)\n\\n<line96>%M   minute (00..59)\n\\n<line97>"), stdout);\n<line98>fputs (_("\\n<line99>%n   a newline\n\\n<line100>%N   nanoseconds (000000000..999999999)\n\\n<line101>%p   locale's equivalent of either AM or PM; blank if not known\n\\n<line102>%P   like %p, but lower case\n\\n<line103>%q   quarter of year (1..4)\n\\n<line104>%r   locale's 12-hour clock time (e.g., 11:11:04 PM)\n\\n<line105>%R   24-hour hour and minute; same as %H:%M\n\\n<line106>%s   seconds since the Epoch (1970-01-01 00:00 UTC)\n\\n<line107>"), stdout);\n<line108>fputs (_("\\n<line109>%S   second (00..60)\n\\n<line110>%t   a tab\n\\n<line111>%T   time; same as %H:%M:%S\n\\n<line112>%u   day of week (1..7); 1 is Monday\n\\n<line113>"), stdout);\n<line114>fputs (_("\\n<line115>%U   week number of year, with Sunday as first day of week (00..53)\n\\n<line116>%V   ISO week number, with Monday as first day of week (01..53)\n\\n<line117>%w   day of week (0..6); 0 is Sunday\n\\n<line118>%W   week number of year, with Monday as first day of week (00..53)\n\\n<line119>"), stdout);\n<line120>fputs (_("\\n<line121>%x   locale's date representation (e.g., 12/31/99)\n\\n<line122>%X   locale's time representation (e.g., 23:13:48)\n\\n<line123>%y   last two digits of year (00..99)\n\\n<line124>%Y   year\n\\n<line125>"), stdout);\n<line126>fputs (_("\\n<line127>%z   +hhmm numeric time zone (e.g., -0400)\n\\n<line128>%:z  +hh:mm numeric time zone (e.g., -04:00)\n\\n<line129>%::z  +hh:mm:ss numeric time zone (e.g., -04:00:00)\n\\n<line130>%:::z  numeric time zone with : to necessary precision (e.g., -04, +05:30)\n\\n<line131>%Z   alphabetic time zone abbreviation (e.g., EDT)\n\\n<line132>\n\\n<line133>By default, date pads numeric fields with zeroes.\n\\n<line134>"), stdout);\n<line135>fputs (_("\\n<line136>The following optional flags may follow '%':\n\\n<line137>\n\\n<line138>-  (hyphen) do not pad the field\n\\n<line139>_  (underscore) pad with spaces\n\\n<line140>0  (zero) pad with zeros\n\\n<line141>+  pad with zeros, and put '+' before future years with >4 digits\n\\n<line142>^  use upper case if possible\n\\n<line143>#  use opposite case if possible\n\\n<line144>"), stdout);\n<line145>fputs (_("\\n<line146>\n\\n<line147>After any flags comes an optional field width, as a decimal number;\n\\n<line148>then an optional modifier, which is either\n\\n<line149>E to use the locale's alternate representations if available, or\n\\n<line150>O to use the locale's alternate numeric symbols if available.\n\\n<line151>"), stdout);\n<line152>fputs (_("\\n<line153>\n\\n<line154>Examples:\n\\n<line155>Convert seconds since the Epoch (1970-01-01 UTC) to a date\n\\n<line156>$ date --date='@2147483647'\n\\n<line157>\n\\n<line158>Show the time on the west coast of the US (use tzselect(1) to find TZ)\n\\n<line159>$ TZ='America/Los_Angeles' date\n\\n<line160>\n\\n<line161>Show the local time for 9AM next Friday on the west coast of the US\n\\n<line162>$ date --date='TZ=\"America/Los_Angeles\" 09:00 next Fri'\n\\n<line163>"), stdout);\n<line164>emit_ancillary_info (PROGRAM_NAME);\n<line165>}\n<line166>exit (status);\n<line167>}
----------------------------------------
Function: res_width
Content: <line0>static int\n<line1>res_width (long int res)\n<line2>{\n<line3>int i = 9;\n<line4>for (long long int r = 1; (r *= 10) <= res; )\n<line5>i--;\n<line6>return i;\n<line7>}
----------------------------------------
Function: adjust_resolution
Content: <line0>static char *\n<line1>adjust_resolution (char const *format)\n<line2>{\n<line3>char *copy = nullptr;\n<line4>for (char const *f = format; *f; f++)\n<line5>if (f[0] == '%')\n<line6>{\n<line7>if (f[1] == '-' && f[2] == 'N')\n<line8>{\n<line9>if (!copy)\n<line10>copy = xstrdup (format);\n<line11>copy[f + 1 - format] = '0' + res_width (gettime_res ());\n<line12>f += 2;\n<line13>}\n<line14>else\n<line15>f += f[1] == '%';\n<line16>}\n<line17>return copy;\n<line18>}
----------------------------------------
Function: batch_convert
Content: <line0>static bool\n<line1>batch_convert (char const *input_filename, char const *format,\n<line2>timezone_t tz, char const *tzstring)\n<line3>{\n<line4>bool ok;\n<line5>FILE *in_stream;\n<line6>char *line;\n<line7>size_t buflen;\n<line8>struct timespec when;\n<line9>if (STREQ (input_filename, "-"))\n<line10>{\n<line11>input_filename = _("standard input");\n<line12>in_stream = stdin;\n<line13>}\n<line14>else\n<line15>{\n<line16>in_stream = fopen (input_filename, "r");\n<line17>if (in_stream == nullptr)\n<line18>error (EXIT_FAILURE, errno, "%s", quotef (input_filename));\n<line19>}\n<line20>line = nullptr;\n<line21>buflen = 0;\n<line22>ok = true;\n<line23>while (true)\n<line24>{\n<line25>ssize_t line_length = getline (&line, &buflen, in_stream);\n<line26>if (line_length < 0)\n<line27>{\n<line28>if (ferror (in_stream))\n<line29>error (EXIT_FAILURE, errno, _("%s: read error"),\n<line30>quotef (input_filename));\n<line31>break;\n<line32>}\n<line33>if (! parse_datetime2 (&when, line, nullptr,\n<line34>parse_datetime_flags, tz, tzstring))\n<line35>{\n<line36>if (line[line_length - 1] == '\n')\n<line37>line[line_length - 1] = '\0';\n<line38>error (0, 0, _("invalid date %s"), quote (line));\n<line39>ok = false;\n<line40>}\n<line41>else\n<line42>{\n<line43>ok &= show_date (format, when, tz);\n<line44>}\n<line45>}\n<line46>if (fclose (in_stream) == EOF)\n<line47>error (EXIT_FAILURE, errno, "%s", quotef (input_filename));\n<line48>free (line);\n<line49>return ok;\n<line50>}
----------------------------------------
Function: main
Content: <line0>int\n<line1>main (int argc, char **argv)\n<line2>{\n<line3>int optc;\n<line4>char const *datestr = nullptr;\n<line5>char const *set_datestr = nullptr;\n<line6>struct timespec when;\n<line7>bool set_date = false;\n<line8>char const *format = nullptr;\n<line9>bool get_resolution = false;\n<line10>char *batch_file = nullptr;\n<line11>char *reference = nullptr;\n<line12>struct stat refstats;\n<line13>bool ok;\n<line14>bool discarded_datestr = false;\n<line15>bool discarded_set_datestr = false;\n<line16>initialize_main (&argc, &argv);\n<line17>set_program_name (argv[0]);\n<line18>setlocale (LC_ALL, "");\n<line19>bindtextdomain (PACKAGE, LOCALEDIR);\n<line20>textdomain (PACKAGE);\n<line21>atexit (close_stdout);\n<line22>while ((optc = getopt_long (argc, argv, short_options, long_options, nullptr))\n<line23>!= -1)\n<line24>{\n<line25>char const *new_format = nullptr;\n<line26>switch (optc)\n<line27>{\n<line28>case 'd':\n<line29>if (datestr)\n<line30>discarded_datestr = true;\n<line31>datestr = optarg;\n<line32>break;\n<line33>case DEBUG_DATE_PARSING_OPTION:\n<line34>parse_datetime_flags |= PARSE_DATETIME_DEBUG;\n<line35>break;\n<line36>case 'f':\n<line37>batch_file = optarg;\n<line38>break;\n<line39>case RESOLUTION_OPTION:\n<line40>get_resolution = true;\n<line41>break;\n<line42>case RFC_3339_OPTION:\n<line43>{\n<line44>static char const rfc_3339_format[][32] =\n<line45>{\n<line46>"%Y-%m-%d",\n<line47>"%Y-%m-%d %H:%M:%S%:z",\n<line48>"%Y-%m-%d %H:%M:%S.%N%:z"\n<line49>};\n<line50>enum Time_spec i =\n<line51>XARGMATCH ("--rfc-3339", optarg,\n<line52>time_spec_string + 2, time_spec + 2);\n<line53>new_format = rfc_3339_format[i];\n<line54>break;\n<line55>}\n<line56>case 'I':\n<line57>{\n<line58>static char const iso_8601_format[][32] =\n<line59>{\n<line60>"%Y-%m-%d",\n<line61>"%Y-%m-%dT%H:%M:%S%:z",\n<line62>"%Y-%m-%dT%H:%M:%S,%N%:z",\n<line63>"%Y-%m-%dT%H%:z",\n<line64>"%Y-%m-%dT%H:%M%:z"\n<line65>};\n<line66>enum Time_spec i =\n<line67>(optarg\n<line68>? XARGMATCH ("--iso-8601", optarg, time_spec_string, time_spec)\n<line69>: TIME_SPEC_DATE);\n<line70>new_format = iso_8601_format[i];\n<line71>break;\n<line72>}\n<line73>case 'r':\n<line74>reference = optarg;\n<line75>break;\n<line76>case 'R':\n<line77>new_format = rfc_email_format;\n<line78>break;\n<line79>case 's':\n<line80>if (set_datestr)\n<line81>discarded_set_datestr = true;\n<line82>set_datestr = optarg;\n<line83>set_date = true;\n<line84>break;\n<line85>case 'u':\n<line86>/* POSIX says that 'date -u' is equivalent to setting the TZ\n<line87>environment variable, so this option should do nothing other\n<line88>than setting TZ.  */\n<line89>if (putenv (bad_cast ("TZ=UTC0")) != 0)\n<line90>xalloc_die ();\n<line91>TZSET;\n<line92>break;\n<line93>case_GETOPT_HELP_CHAR;\n<line94>case_GETOPT_VERSION_CHAR (PROGRAM_NAME, AUTHORS);\n<line95>default:\n<line96>usage (EXIT_FAILURE);\n<line97>}\n<line98>if (new_format)\n<line99>{\n<line100>if (format)\n<line101>error (EXIT_FAILURE, 0, _("multiple output formats specified"));\n<line102>format = new_format;\n<line103>}\n<line104>}\n<line105>int option_specified_date = (!!datestr + !!batch_file + !!reference\n<line106>+ get_resolution);\n<line107>if (option_specified_date > 1)\n<line108>{\n<line109>error (0, 0,\n<line110>_("the options to specify dates for printing are mutually exclusive"));\n<line111>usage (EXIT_FAILURE);\n<line112>}\n<line113>if (set_date && option_specified_date)\n<line114>{\n<line115>error (0, 0,\n<line116>_("the options to print and set the time may not be used together"));\n<line117>usage (EXIT_FAILURE);\n<line118>}\n<line119>if (discarded_datestr && (parse_datetime_flags & PARSE_DATETIME_DEBUG))\n<line120>error (0, 0, _("only using last of multiple -d options"));\n<line121>if (discarded_set_datestr && (parse_datetime_flags & PARSE_DATETIME_DEBUG))\n<line122>error (0, 0, _("only using last of multiple -s options"));\n<line123>if (optind < argc)\n<line124>{\n<line125>if (optind + 1 < argc)\n<line126>{\n<line127>error (0, 0, _("extra operand %s"), quote (argv[optind + 1]));\n<line128>usage (EXIT_FAILURE);\n<line129>}\n<line130>if (argv[optind][0] == '+')\n<line131>{\n<line132>if (format)\n<line133>error (EXIT_FAILURE, 0, _("multiple output formats specified"));\n<line134>format = argv[optind++] + 1;\n<line135>}\n<line136>else if (set_date || option_specified_date)\n<line137>{\n<line138>error (0, 0,\n<line139>_("the argument %s lacks a leading '+';\n"\n<line140>"when using an option to specify date(s), any non-option\n"\n<line141>"argument must be a format string beginning with '+'"),\n<line142>quote (argv[optind]));\n<line143>usage (EXIT_FAILURE);\n<line144>}\n<line145>}\n<line146>if (!format)\n<line147>{\n<line148>if (get_resolution)\n<line149>format = "%s.%N";\n<line150>else\n<line151>{\n<line152>format = DATE_FMT_LANGINFO ();\n<line153>/* Do not wrap the following literal format string with _(...).\n<line154>For example, suppose LC_ALL is unset, LC_TIME=POSIX,\n<line155>and LANG="ko_KR".  In that case, POSIX says that LC_TIME\n<line156>determines the format and contents of date and time strings\n<line157>written by date, which means "date" must generate output\n<line158>using the POSIX locale; but adding _() would cause "date"\n<line159>to use a Korean translation of the format.  */\n<line160>if (! *format)\n<line161>format = "%a %b %e %H:%M:%S %Z %Y";\n<line162>}\n<line163>}\n<line164>char *format_copy = adjust_resolution (format);\n<line165>char const *format_res = format_copy ? format_copy : format;\n<line166>char const *tzstring = getenv ("TZ");\n<line167>timezone_t tz = tzalloc (tzstring);\n<line168>if (batch_file != nullptr)\n<line169>ok = batch_convert (batch_file, format_res, tz, tzstring);\n<line170>else\n<line171>{\n<line172>bool valid_date = true;\n<line173>ok = true;\n<line174>if (!option_specified_date && !set_date)\n<line175>{\n<line176>if (optind < argc)\n<line177>{\n<line178>/* Prepare to set system clock to the specified date/time\n<line179>given in the POSIX-format.  */\n<line180>set_date = true;\n<line181>datestr = argv[optind];\n<line182>valid_date = posixtime (&when.tv_sec,\n<line183>datestr,\n<line184>(PDS_TRAILING_YEAR\n<line185>| PDS_CENTURY | PDS_SECONDS));\n<line186>when.tv_nsec = 0; /* FIXME: posixtime should set this.  */\n<line187>}\n<line188>else\n<line189>{\n<line190>/* Prepare to print the current date/time.  */\n<line191>gettime (&when);\n<line192>}\n<line193>}\n<line194>else\n<line195>{\n<line196>/* (option_specified_date || set_date) */\n<line197>if (reference != nullptr)\n<line198>{\n<line199>if (stat (reference, &refstats) != 0)\n<line200>error (EXIT_FAILURE, errno, "%s", quotef (reference));\n<line201>when = get_stat_mtime (&refstats);\n<line202>}\n<line203>else if (get_resolution)\n<line204>{\n<line205>long int res = gettime_res ();\n<line206>when.tv_sec = res / TIMESPEC_HZ;\n<line207>when.tv_nsec = res % TIMESPEC_HZ;\n<line208>}\n<line209>else\n<line210>{\n<line211>if (set_datestr)\n<line212>datestr = set_datestr;\n<line213>valid_date = parse_datetime2 (&when, datestr, nullptr,\n<line214>parse_datetime_flags,\n<line215>tz, tzstring);\n<line216>}\n<line217>}\n<line218>if (! valid_date)\n<line219>error (EXIT_FAILURE, 0, _("invalid date %s"), quote (datestr));\n<line220>if (set_date)\n<line221>{\n<line222>/* Set the system clock to the specified date, then regardless of\n<line223>the success of that operation, format and print that date.  */\n<line224>if (settime (&when) != 0)\n<line225>{\n<line226>error (0, errno, _("cannot set date"));\n<line227>ok = false;\n<line228>}\n<line229>}\n<line230>ok &= show_date (format_res, when, tz);\n<line231>}\n<line232>main_exit (ok ? EXIT_SUCCESS : EXIT_FAILURE);\n<line233>}
----------------------------------------
Function: show_date
Content: <line0>static bool\n<line1>show_date (char const *format, struct timespec when, timezone_t tz)\n<line2>{\n<line3>struct tm tm;\n<line4>if (parse_datetime_flags & PARSE_DATETIME_DEBUG)\n<line5>error (0, 0, _("output format: %s"), quote (format));\n<line6>if (localtime_rz (tz, &when.tv_sec, &tm))\n<line7>{\n<line8>if (format == rfc_email_format)\n<line9>setlocale (LC_TIME, "C");\n<line10>fprintftime (stdout, format, &tm, tz, when.tv_nsec);\n<line11>if (format == rfc_email_format)\n<line12>setlocale (LC_TIME, "");\n<line13>fputc ('\n', stdout);\n<line14>return true;\n<line15>}\n<line16>else\n<line17>{\n<line18>char buf[INT_BUFSIZE_BOUND (intmax_t)];\n<line19>error (0, 0, _("time %s is out of range"),\n<line20>quote (timetostr (when.tv_sec, buf)));\n<line21>return false;\n<line22>}\n<line23>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/src/dd.c
========================================
/home/huihui/Downloads/coreutils-9.4/src/dd.c:329:32: warning: '_Static_assert' with no message is a C2x extension [-Wc2x-extensions]
static_assert (O_FULLBLOCK != 0);
                               ^
                               , ""
/home/huihui/Downloads/coreutils-9.4/src/dd.c:330:30: warning: '_Static_assert' with no message is a C2x extension [-Wc2x-extensions]
static_assert (O_NOCACHE != 0);
                             ^
                             , ""
/home/huihui/Downloads/coreutils-9.4/src/dd.c:331:34: warning: '_Static_assert' with no message is a C2x extension [-Wc2x-extensions]
static_assert (O_COUNT_BYTES != 0);
                                 ^
                                 , ""
/home/huihui/Downloads/coreutils-9.4/src/dd.c:332:33: warning: '_Static_assert' with no message is a C2x extension [-Wc2x-extensions]
static_assert (O_SKIP_BYTES != 0);
                                ^
                                , ""
/home/huihui/Downloads/coreutils-9.4/src/dd.c:333:33: warning: '_Static_assert' with no message is a C2x extension [-Wc2x-extensions]
static_assert (O_SEEK_BYTES != 0);
                                ^
                                , ""
/home/huihui/Downloads/coreutils-9.4/src/dd.c:338:50: warning: '_Static_assert' with no message is a C2x extension [-Wc2x-extensions]
static_assert ( ! MULTIPLE_BITS_SET (O_FULLBLOCK));
                                                 ^
                                                 , ""
/home/huihui/Downloads/coreutils-9.4/src/dd.c:339:48: warning: '_Static_assert' with no message is a C2x extension [-Wc2x-extensions]
static_assert ( ! MULTIPLE_BITS_SET (O_NOCACHE));
                                               ^
                                               , ""
/home/huihui/Downloads/coreutils-9.4/src/dd.c:340:52: warning: '_Static_assert' with no message is a C2x extension [-Wc2x-extensions]
static_assert ( ! MULTIPLE_BITS_SET (O_COUNT_BYTES));
                                                   ^
                                                   , ""
/home/huihui/Downloads/coreutils-9.4/src/dd.c:341:51: warning: '_Static_assert' with no message is a C2x extension [-Wc2x-extensions]
static_assert ( ! MULTIPLE_BITS_SET (O_SKIP_BYTES));
                                                  ^
                                                  , ""
/home/huihui/Downloads/coreutils-9.4/src/dd.c:342:51: warning: '_Static_assert' with no message is a C2x extension [-Wc2x-extensions]
static_assert ( ! MULTIPLE_BITS_SET (O_SEEK_BYTES));
                                                  ^
                                                  , ""
10 warnings generated.
Function: maybe_close_stdout
Content: <line0>static void\n<line1>maybe_close_stdout (void)\n<line2>{\n<line3>if (close_stdout_required)\n<line4>close_stdout ();\n<line5>else if (close_stream (stderr) != 0)\n<line6>_exit (EXIT_FAILURE);\n<line7>}
----------------------------------------
Function: usage
Content: <line0>void\n<line1>usage (int status)\n<line2>{\n<line3>if (status != EXIT_SUCCESS)\n<line4>emit_try_help ();\n<line5>else\n<line6>{\n<line7>printf (_("\\n<line8>Usage: %s [OPERAND]...\n\\n<line9>or:  %s OPTION\n\\n<line10>"),\n<line11>program_name, program_name);\n<line12>fputs (_("\\n<line13>Copy a file, converting and formatting according to the operands.\n\\n<line14>\n\\n<line15>bs=BYTES        read and write up to BYTES bytes at a time (default: 512);\n\\n<line16>overrides ibs and obs\n\\n<line17>cbs=BYTES       convert BYTES bytes at a time\n\\n<line18>conv=CONVS      convert the file as per the comma separated symbol list\n\\n<line19>count=N         copy only N input blocks\n\\n<line20>ibs=BYTES       read up to BYTES bytes at a time (default: 512)\n\\n<line21>"), stdout);\n<line22>fputs (_("\\n<line23>if=FILE         read from FILE instead of stdin\n\\n<line24>iflag=FLAGS     read as per the comma separated symbol list\n\\n<line25>obs=BYTES       write BYTES bytes at a time (default: 512)\n\\n<line26>of=FILE         write to FILE instead of stdout\n\\n<line27>oflag=FLAGS     write as per the comma separated symbol list\n\\n<line28>seek=N          (or oseek=N) skip N obs-sized output blocks\n\\n<line29>skip=N          (or iseek=N) skip N ibs-sized input blocks\n\\n<line30>status=LEVEL    The LEVEL of information to print to stderr;\n\\n<line31>'none' suppresses everything but error messages,\n\\n<line32>'noxfer' suppresses the final transfer statistics,\n\\n<line33>'progress' shows periodic transfer statistics\n\\n<line34>"), stdout);\n<line35>fputs (_("\\n<line36>\n\\n<line37>N and BYTES may be followed by the following multiplicative suffixes:\n\\n<line38>c=1, w=2, b=512, kB=1000, K=1024, MB=1000*1000, M=1024*1024, xM=M,\n\\n<line39>GB=1000*1000*1000, G=1024*1024*1024, and so on for T, P, E, Z, Y, R, Q.\n\\n<line40>Binary prefixes can be used, too: KiB=K, MiB=M, and so on.\n\\n<line41>If N ends in 'B', it counts bytes not blocks.\n\\n<line42>\n\\n<line43>Each CONV symbol may be:\n\\n<line44>\n\\n<line45>"), stdout);\n<line46>fputs (_("\\n<line47>ascii     from EBCDIC to ASCII\n\\n<line48>ebcdic    from ASCII to EBCDIC\n\\n<line49>ibm       from ASCII to alternate EBCDIC\n\\n<line50>block     pad newline-terminated records with spaces to cbs-size\n\\n<line51>unblock   replace trailing spaces in cbs-size records with newline\n\\n<line52>lcase     change upper case to lower case\n\\n<line53>ucase     change lower case to upper case\n\\n<line54>sparse    try to seek rather than write all-NUL output blocks\n\\n<line55>swab      swap every pair of input bytes\n\\n<line56>sync      pad every input block with NULs to ibs-size; when used\n\\n<line57>with block or unblock, pad with spaces rather than NULs\n\\n<line58>"), stdout);\n<line59>fputs (_("\\n<line60>excl      fail if the output file already exists\n\\n<line61>nocreat   do not create the output file\n\\n<line62>notrunc   do not truncate the output file\n\\n<line63>noerror   continue after read errors\n\\n<line64>fdatasync  physically write output file data before finishing\n\\n<line65>fsync     likewise, but also write metadata\n\\n<line66>"), stdout);\n<line67>fputs (_("\\n<line68>\n\\n<line69>Each FLAG symbol may be:\n\\n<line70>\n\\n<line71>append    append mode (makes sense only for output; conv=notrunc suggested)\n\\n<line72>"), stdout);\n<line73>if (O_CIO)\n<line74>fputs (_("  cio       use concurrent I/O for data\n"), stdout);\n<line75>if (O_DIRECT)\n<line76>fputs (_("  direct    use direct I/O for data\n"), stdout);\n<line77>if (O_DIRECTORY)\n<line78>fputs (_("  directory  fail unless a directory\n"), stdout);\n<line79>if (O_DSYNC)\n<line80>fputs (_("  dsync     use synchronized I/O for data\n"), stdout);\n<line81>if (O_SYNC)\n<line82>fputs (_("  sync      likewise, but also for metadata\n"), stdout);\n<line83>fputs (_("  fullblock  accumulate full blocks of input (iflag only)\n"),\n<line84>stdout);\n<line85>if (O_NONBLOCK)\n<line86>fputs (_("  nonblock  use non-blocking I/O\n"), stdout);\n<line87>if (O_NOATIME)\n<line88>fputs (_("  noatime   do not update access time\n"), stdout);\n<line89>#if HAVE_POSIX_FADVISE\n<line90>if (O_NOCACHE)\n<line91>fputs (_("  nocache   Request to drop cache.  See also oflag=sync\n"),\n<line92>stdout);\n<line93>#endif\n<line94>if (O_NOCTTY)\n<line95>fputs (_("  noctty    do not assign controlling terminal from file\n"),\n<line96>stdout);\n<line97>if (HAVE_WORKING_O_NOFOLLOW)\n<line98>fputs (_("  nofollow  do not follow symlinks\n"), stdout);\n<line99>if (O_NOLINKS)\n<line100>fputs (_("  nolinks   fail if multiply-linked\n"), stdout);\n<line101>if (O_BINARY)\n<line102>fputs (_("  binary    use binary I/O for data\n"), stdout);\n<line103>if (O_TEXT)\n<line104>fputs (_("  text      use text I/O for data\n"), stdout);\n<line105>{\n<line106>printf (_("\\n<line107>\n\\n<line108>Sending a %s signal to a running 'dd' process makes it\n\\n<line109>print I/O statistics to standard error and then resume copying.\n\\n<line110>\n\\n<line111>Options are:\n\\n<line112>\n\\n<line113>"), SIGINFO == SIGUSR1 ? "USR1" : "INFO");\n<line114>}\n<line115>fputs (HELP_OPTION_DESCRIPTION, stdout);\n<line116>fputs (VERSION_OPTION_DESCRIPTION, stdout);\n<line117>emit_ancillary_info (PROGRAM_NAME);\n<line118>}\n<line119>exit (status);\n<line120>}
----------------------------------------
Function: alloc_ibuf
Content: <line0>static void\n<line1>alloc_ibuf (void)\n<line2>{\n<line3>if (ibuf)\n<line4>return;\n<line5>bool extra_byte_for_swab = !!(conversions_mask & C_SWAB);\n<line6>ibuf = alignalloc (page_size, input_blocksize + extra_byte_for_swab);\n<line7>if (!ibuf)\n<line8>{\n<line9>char hbuf[LONGEST_HUMAN_READABLE + 1];\n<line10>error (EXIT_FAILURE, 0,\n<line11>_("memory exhausted by input buffer of size %td bytes (%s)"),\n<line12>input_blocksize,\n<line13>human_readable (input_blocksize, hbuf,\n<line14>human_opts | human_base_1024, 1, 1));\n<line15>}\n<line16>}
----------------------------------------
Function: alloc_obuf
Content: <line0>static void\n<line1>alloc_obuf (void)\n<line2>{\n<line3>if (obuf)\n<line4>return;\n<line5>if (conversions_mask & C_TWOBUFS)\n<line6>{\n<line7>obuf = alignalloc (page_size, output_blocksize);\n<line8>if (!obuf)\n<line9>{\n<line10>char hbuf[LONGEST_HUMAN_READABLE + 1];\n<line11>error (EXIT_FAILURE, 0,\n<line12>_("memory exhausted by output buffer of size %td"\n<line13>" bytes (%s)"),\n<line14>output_blocksize,\n<line15>human_readable (output_blocksize, hbuf,\n<line16>human_opts | human_base_1024, 1, 1));\n<line17>}\n<line18>}\n<line19>else\n<line20>{\n<line21>alloc_ibuf ();\n<line22>obuf = ibuf;\n<line23>}\n<line24>}
----------------------------------------
Function: translate_charset
Content: <line0>static void\n<line1>translate_charset (char const *new_trans)\n<line2>{\n<line3>for (int i = 0; i < 256; i++)\n<line4>trans_table[i] = new_trans[trans_table[i]];\n<line5>translation_needed = true;\n<line6>}
----------------------------------------
Function: multiple_bits_set
Content: <line0>static inline bool\n<line1>multiple_bits_set (int i)\n<line2>{\n<line3>return MULTIPLE_BITS_SET (i);\n<line4>}
----------------------------------------
Function: abbreviation_lacks_prefix
Content: <line0>static bool\n<line1>abbreviation_lacks_prefix (char const *message)\n<line2>{\n<line3>return message[strlen (message) - 2] == ' ';\n<line4>}
----------------------------------------
Function: print_xfer_stats
Content: <line0>static void\n<line1>print_xfer_stats (xtime_t progress_time)\n<line2>{\n<line3>xtime_t now = progress_time ? progress_time : gethrxtime ();\n<line4>static char const slash_s[] = "/s";\n<line5>char hbuf[3][LONGEST_HUMAN_READABLE + sizeof slash_s];\n<line6>double delta_s;\n<line7>char const *bytes_per_second;\n<line8>char const *si = human_readable (w_bytes, hbuf[0], human_opts, 1, 1);\n<line9>char const *iec = human_readable (w_bytes, hbuf[1],\n<line10>human_opts | human_base_1024, 1, 1);\n<line11>/* Use integer arithmetic to compute the transfer rate,\n<line12>since that makes it easy to use SI abbreviations.  */\n<line13>char *bpsbuf = hbuf[2];\n<line14>int bpsbufsize = sizeof hbuf[2];\n<line15>if (start_time < now)\n<line16>{\n<line17>double XTIME_PRECISIONe0 = XTIME_PRECISION;\n<line18>xtime_t delta_xtime = now - start_time;\n<line19>delta_s = delta_xtime / XTIME_PRECISIONe0;\n<line20>bytes_per_second = human_readable (w_bytes, bpsbuf, human_opts,\n<line21>XTIME_PRECISION, delta_xtime);\n<line22>strcat (bytes_per_second - bpsbuf + bpsbuf, slash_s);\n<line23>}\n<line24>else\n<line25>{\n<line26>delta_s = 0;\n<line27>snprintf (bpsbuf, bpsbufsize, "%s B/s", _("Infinity"));\n<line28>bytes_per_second = bpsbuf;\n<line29>}\n<line30>if (progress_time)\n<line31>fputc ('\r', stderr);\n<line32>/* Use full seconds when printing progress, since the progress\n<line33>report is output once per second and there is little point\n<line34>displaying any subsecond jitter.  Use default precision with %g\n<line35>otherwise, as this provides more-useful output then.  With long\n<line36>transfers %g can generate a number with an exponent; that is OK.  */\n<line37>char delta_s_buf[24];\n<line38>snprintf (delta_s_buf, sizeof delta_s_buf,\n<line39>progress_time ? "%.0f s" : "%g s", delta_s);\n<line40>int stats_len\n<line41>= (abbreviation_lacks_prefix (si)\n<line42>? fprintf (stderr,\n<line43>ngettext ("%"PRIdMAX" byte copied, %s, %s",\n<line44>"%"PRIdMAX" bytes copied, %s, %s",\n<line45>select_plural (w_bytes)),\n<line46>w_bytes, delta_s_buf, bytes_per_second)\n<line47>: abbreviation_lacks_prefix (iec)\n<line48>? fprintf (stderr,\n<line49>_("%"PRIdMAX" bytes (%s) copied, %s, %s"),\n<line50>w_bytes, si, delta_s_buf, bytes_per_second)\n<line51>: fprintf (stderr,\n<line52>_("%"PRIdMAX" bytes (%s, %s) copied, %s, %s"),\n<line53>w_bytes, si, iec, delta_s_buf, bytes_per_second));\n<line54>if (progress_time)\n<line55>{\n<line56>/* Erase any trailing junk on the output line by outputting\n<line57>spaces.  In theory this could glitch the display because the\n<line58>formatted translation of a line describing a larger file\n<line59>could consume fewer screen columns than the strlen difference\n<line60>from the previously formatted translation.  In practice this\n<line61>does not seem to be a problem.  */\n<line62>if (0 <= stats_len && stats_len < progress_len)\n<line63>fprintf (stderr, "%*s", progress_len - stats_len, "");\n<line64>progress_len = stats_len;\n<line65>}\n<line66>else\n<line67>fputc ('\n', stderr);\n<line68>reported_w_bytes = w_bytes;\n<line69>}
----------------------------------------
Function: print_stats
Content: <line0>static void\n<line1>print_stats (void)\n<line2>{\n<line3>if (status_level == STATUS_NONE)\n<line4>return;\n<line5>if (0 < progress_len)\n<line6>{\n<line7>fputc ('\n', stderr);\n<line8>progress_len = 0;\n<line9>}\n<line10>fprintf (stderr,\n<line11>_("%"PRIdMAX"+%"PRIdMAX" records in\n"\n<line12>"%"PRIdMAX"+%"PRIdMAX" records out\n"),\n<line13>r_full, r_partial, w_full, w_partial);\n<line14>if (r_truncate != 0)\n<line15>fprintf (stderr,\n<line16>ngettext ("%"PRIdMAX" truncated record\n",\n<line17>"%"PRIdMAX" truncated records\n",\n<line18>select_plural (r_truncate)),\n<line19>r_truncate);\n<line20>if (status_level == STATUS_NOXFER)\n<line21>return;\n<line22>print_xfer_stats (0);\n<line23>}
----------------------------------------
Function: interrupt_handler
Content: <line0>static void\n<line1>interrupt_handler (int sig)\n<line2>{\n<line3>if (! SA_RESETHAND)\n<line4>signal (sig, SIG_DFL);\n<line5>interrupt_signal = sig;\n<line6>}
----------------------------------------
Function: siginfo_handler
Content: <line0>static void\n<line1>siginfo_handler (int sig)\n<line2>{\n<line3>if (! SA_NOCLDSTOP)\n<line4>signal (sig, siginfo_handler);\n<line5>info_signal_count++;\n<line6>}
----------------------------------------
Function: install_signal_handlers
Content: <line0>static void\n<line1>install_signal_handlers (void)\n<line2>{\n<line3>bool catch_siginfo = ! (SIGINFO == SIGUSR1 && getenv ("POSIXLY_CORRECT"));\n<line4>#if SA_NOCLDSTOP\n<line5>struct sigaction act;\n<line6>sigemptyset (&caught_signals);\n<line7>if (catch_siginfo)\n<line8>sigaddset (&caught_signals, SIGINFO);\n<line9>sigaction (SIGINT, nullptr, &act);\n<line10>if (act.sa_handler != SIG_IGN)\n<line11>sigaddset (&caught_signals, SIGINT);\n<line12>act.sa_mask = caught_signals;\n<line13>if (sigismember (&caught_signals, SIGINFO))\n<line14>{\n<line15>act.sa_handler = siginfo_handler;\n<line16>/* Note we don't use SA_RESTART here and instead\n<line17>handle EINTR explicitly in iftruncate etc.\n<line18>to avoid blocking on uncommitted read/write calls.  */\n<line19>act.sa_flags = 0;\n<line20>sigaction (SIGINFO, &act, nullptr);\n<line21>}\n<line22>if (sigismember (&caught_signals, SIGINT))\n<line23>{\n<line24>act.sa_handler = interrupt_handler;\n<line25>act.sa_flags = SA_NODEFER | SA_RESETHAND;\n<line26>sigaction (SIGINT, &act, nullptr);\n<line27>}\n<line28>#else\n<line29>if (catch_siginfo)\n<line30>{\n<line31>signal (SIGINFO, siginfo_handler);\n<line32>siginterrupt (SIGINFO, 1);\n<line33>}\n<line34>if (signal (SIGINT, SIG_IGN) != SIG_IGN)\n<line35>{\n<line36>signal (SIGINT, interrupt_handler);\n<line37>siginterrupt (SIGINT, 1);\n<line38>}\n<line39>#endif\n<line40>}
----------------------------------------
Function: iclose
Content: <line0>static int\n<line1>iclose (int fd)\n<line2>{\n<line3>if (close (fd) != 0)\n<line4>do\n<line5>if (errno != EINTR)\n<line6>return -1;\n<line7>while (close (fd) != 0 && errno != EBADF);\n<line8>return 0;\n<line9>}
----------------------------------------
Function: cleanup
Content: <line0>static void\n<line1>cleanup (void)\n<line2>{\n<line3>if (!interrupt_signal)\n<line4>{\n<line5>int sync_status = synchronize_output ();\n<line6>if (sync_status)\n<line7>exit (sync_status);\n<line8>}\n<line9>if (iclose (STDIN_FILENO) != 0)\n<line10>error (EXIT_FAILURE, errno, _("closing input file %s"),\n<line11>quoteaf (input_file));\n<line12>/* Don't remove this call to close, even though close_stdout\n<line13>closes standard output.  This close is necessary when cleanup\n<line14>is called as a consequence of signal handling.  */\n<line15>if (iclose (STDOUT_FILENO) != 0)\n<line16>error (EXIT_FAILURE, errno,\n<line17>_("closing output file %s"), quoteaf (output_file));\n<line18>}
----------------------------------------
Function: process_signals
Content: <line0>static void\n<line1>process_signals (void)\n<line2>{\n<line3>while (interrupt_signal || info_signal_count)\n<line4>{\n<line5>int interrupt;\n<line6>int infos;\n<line7>sigset_t oldset;\n<line8>sigprocmask (SIG_BLOCK, &caught_signals, &oldset);\n<line9>/* Reload interrupt_signal and info_signal_count, in case a new\n<line10>signal was handled before sigprocmask took effect.  */\n<line11>interrupt = interrupt_signal;\n<line12>infos = info_signal_count;\n<line13>if (infos)\n<line14>info_signal_count = infos - 1;\n<line15>sigprocmask (SIG_SETMASK, &oldset, nullptr);\n<line16>if (interrupt)\n<line17>cleanup ();\n<line18>print_stats ();\n<line19>if (interrupt)\n<line20>raise (interrupt);\n<line21>}\n<line22>}
----------------------------------------
Function: finish_up
Content: <line0>static void\n<line1>finish_up (void)\n<line2>{\n<line3>/* Process signals first, so that cleanup is called at most once.  */\n<line4>process_signals ();\n<line5>cleanup ();\n<line6>print_stats ();\n<line7>}
----------------------------------------
Function: quit
Content: <line0>static void\n<line1>quit (int code)\n<line2>{\n<line3>finish_up ();\n<line4>exit (code);\n<line5>}
----------------------------------------
Function: cache_round
Content: <line0>static off_t\n<line1>cache_round (int fd, off_t len)\n<line2>{\n<line3>static off_t i_pending, o_pending;\n<line4>off_t *pending = (fd == STDIN_FILENO ? &i_pending : &o_pending);\n<line5>if (len)\n<line6>{\n<line7>intmax_t c_pending;\n<line8>if (ckd_add (&c_pending, *pending, len))\n<line9>c_pending = INTMAX_MAX;\n<line10>*pending = c_pending % IO_BUFSIZE;\n<line11>if (c_pending > *pending)\n<line12>len = c_pending - *pending;\n<line13>else\n<line14>len = 0;\n<line15>}\n<line16>else\n<line17>len = *pending;\n<line18>return len;\n<line19>}
----------------------------------------
Function: invalidate_cache
Content: <line0>static bool\n<line1>invalidate_cache (int fd, off_t len)\n<line2>{\n<line3>int adv_ret = -1;\n<line4>off_t offset;\n<line5>bool nocache_eof = (fd == STDIN_FILENO ? i_nocache_eof : o_nocache_eof);\n<line6>/* Minimize syscalls.  */\n<line7>off_t clen = cache_round (fd, len);\n<line8>if (len && !clen)\n<line9>return true; /* Don't advise this time.  */\n<line10>else if (! len && ! clen && ! nocache_eof)\n<line11>return true;\n<line12>off_t pending = len ? cache_round (fd, 0) : 0;\n<line13>if (fd == STDIN_FILENO)\n<line14>{\n<line15>if (input_seekable)\n<line16>offset = input_offset;\n<line17>else\n<line18>{\n<line19>offset = -1;\n<line20>errno = ESPIPE;\n<line21>}\n<line22>}\n<line23>else\n<line24>{\n<line25>static off_t output_offset = -2;\n<line26>if (output_offset != -1)\n<line27>{\n<line28>if (output_offset < 0)\n<line29>output_offset = lseek (fd, 0, SEEK_CUR);\n<line30>else if (len)\n<line31>output_offset += clen + pending;\n<line32>}\n<line33>offset = output_offset;\n<line34>}\n<line35>if (0 <= offset)\n<line36>{\n<line37>if (! len && clen && nocache_eof)\n<line38>{\n<line39>pending = clen;\n<line40>clen = 0;\n<line41>}\n<line42>/* Note we're being careful here to only invalidate what\n<line43>we've read, so as not to dump any read ahead cache.\n<line44>Note also the kernel is conservative and only invalidates\n<line45>full pages in the specified range.  */\n<line46>#if HAVE_POSIX_FADVISE\n<line47>offset = offset - clen - pending;\n<line48>/* ensure full page specified when invalidating to eof.  */\n<line49>if (clen == 0)\n<line50>offset -= offset % page_size;\n<line51>adv_ret = posix_fadvise (fd, offset, clen, POSIX_FADV_DONTNEED);\n<line52>#else\n<line53>errno = ENOTSUP;\n<line54>#endif\n<line55>}\n<line56>return adv_ret != -1 ? true : false;\n<line57>}
----------------------------------------
Function: iread
Content: <line0>static ssize_t\n<line1>iread (int fd, char *buf, idx_t size)\n<line2>{\n<line3>ssize_t nread;\n<line4>static ssize_t prev_nread;\n<line5>do\n<line6>{\n<line7>process_signals ();\n<line8>nread = read (fd, buf, size);\n<line9>/* Ignore final read error with iflag=direct as that\n<line10>returns EINVAL due to the non aligned file offset.  */\n<line11>if (nread == -1 && errno == EINVAL\n<line12>&& 0 < prev_nread && prev_nread < size\n<line13>&& (input_flags & O_DIRECT))\n<line14>{\n<line15>errno = 0;\n<line16>nread = 0;\n<line17>}\n<line18>}\n<line19>while (nread < 0 && errno == EINTR);\n<line20>/* Short read may be due to received signal.  */\n<line21>if (0 < nread && nread < size)\n<line22>process_signals ();\n<line23>if (0 < nread && warn_partial_read)\n<line24>{\n<line25>if (0 < prev_nread && prev_nread < size)\n<line26>{\n<line27>idx_t prev = prev_nread;\n<line28>if (status_level != STATUS_NONE)\n<line29>diagnose (0, ngettext (("warning: partial read (%td byte); "\n<line30>"suggest iflag=fullblock"),\n<line31>("warning: partial read (%td bytes); "\n<line32>"suggest iflag=fullblock"),\n<line33>select_plural (prev)),\n<line34>prev);\n<line35>warn_partial_read = false;\n<line36>}\n<line37>}\n<line38>prev_nread = nread;\n<line39>return nread;\n<line40>}
----------------------------------------
Function: iread_fullblock
Content: <line0>static ssize_t\n<line1>iread_fullblock (int fd, char *buf, idx_t size)\n<line2>{\n<line3>ssize_t nread = 0;\n<line4>while (0 < size)\n<line5>{\n<line6>ssize_t ncurr = iread (fd, buf, size);\n<line7>if (ncurr < 0)\n<line8>return ncurr;\n<line9>if (ncurr == 0)\n<line10>break;\n<line11>nread += ncurr;\n<line12>buf   += ncurr;\n<line13>size  -= ncurr;\n<line14>}\n<line15>return nread;\n<line16>}
----------------------------------------
Function: iwrite
Content: <line0>static idx_t\n<line1>iwrite (int fd, char const *buf, idx_t size)\n<line2>{\n<line3>idx_t total_written = 0;\n<line4>if ((output_flags & O_DIRECT) && size < output_blocksize)\n<line5>{\n<line6>int old_flags = fcntl (STDOUT_FILENO, F_GETFL);\n<line7>if (fcntl (STDOUT_FILENO, F_SETFL, old_flags & ~O_DIRECT) != 0\n<line8>&& status_level != STATUS_NONE)\n<line9>diagnose (errno, _("failed to turn off O_DIRECT: %s"),\n<line10>quotef (output_file));\n<line11>/* Since we have just turned off O_DIRECT for the final write,\n<line12>we try to preserve some of its semantics.  */\n<line13>/* Call invalidate_cache to setup the appropriate offsets\n<line14>for subsequent calls.  */\n<line15>o_nocache_eof = true;\n<line16>invalidate_cache (STDOUT_FILENO, 0);\n<line17>/* Attempt to ensure that that final block is committed\n<line18>to stable storage as quickly as possible.  */\n<line19>conversions_mask |= C_FSYNC;\n<line20>/* After the subsequent fsync we'll call invalidate_cache\n<line21>to attempt to clear all data from the page cache.  */\n<line22>}\n<line23>while (total_written < size)\n<line24>{\n<line25>ssize_t nwritten = 0;\n<line26>process_signals ();\n<line27>/* Perform a seek for a NUL block if sparse output is enabled.  */\n<line28>final_op_was_seek = false;\n<line29>if ((conversions_mask & C_SPARSE) && is_nul (buf, size))\n<line30>{\n<line31>if (lseek (fd, size, SEEK_CUR) < 0)\n<line32>{\n<line33>conversions_mask &= ~C_SPARSE;\n<line34>/* Don't warn about the advisory sparse request.  */\n<line35>}\n<line36>else\n<line37>{\n<line38>final_op_was_seek = true;\n<line39>nwritten = size;\n<line40>}\n<line41>}\n<line42>if (!nwritten)\n<line43>nwritten = write (fd, buf + total_written, size - total_written);\n<line44>if (nwritten < 0)\n<line45>{\n<line46>if (errno != EINTR)\n<line47>break;\n<line48>}\n<line49>else if (nwritten == 0)\n<line50>{\n<line51>/* Some buggy drivers return 0 when one tries to write beyond\n<line52>a device's end.  (Example: Linux kernel 1.2.13 on /dev/fd0.)\n<line53>Set errno to ENOSPC so they get a sensible diagnostic.  */\n<line54>errno = ENOSPC;\n<line55>break;\n<line56>}\n<line57>else\n<line58>total_written += nwritten;\n<line59>}\n<line60>if (o_nocache && total_written)\n<line61>invalidate_cache (fd, total_written);\n<line62>return total_written;\n<line63>}
----------------------------------------
Function: write_output
Content: <line0>static void\n<line1>write_output (void)\n<line2>{\n<line3>idx_t nwritten = iwrite (STDOUT_FILENO, obuf, output_blocksize);\n<line4>w_bytes += nwritten;\n<line5>if (nwritten != output_blocksize)\n<line6>{\n<line7>diagnose (errno, _("writing to %s"), quoteaf (output_file));\n<line8>if (nwritten != 0)\n<line9>w_partial++;\n<line10>quit (EXIT_FAILURE);\n<line11>}\n<line12>else\n<line13>w_full++;\n<line14>oc = 0;\n<line15>}
----------------------------------------
Function: ifdatasync
Content: <line0>static int\n<line1>ifdatasync (int fd)\n<line2>{\n<line3>int ret;\n<line4>do\n<line5>{\n<line6>process_signals ();\n<line7>ret = fdatasync (fd);\n<line8>}\n<line9>while (ret < 0 && errno == EINTR);\n<line10>return ret;\n<line11>}
----------------------------------------
Function: ifd_reopen
Content: <line0>static int\n<line1>ifd_reopen (int desired_fd, char const *file, int flag, mode_t mode)\n<line2>{\n<line3>int ret;\n<line4>do\n<line5>{\n<line6>process_signals ();\n<line7>ret = fd_reopen (desired_fd, file, flag, mode);\n<line8>}\n<line9>while (ret < 0 && errno == EINTR);\n<line10>return ret;\n<line11>}
----------------------------------------
Function: ifstat
Content: <line0>static int\n<line1>ifstat (int fd, struct stat *st)\n<line2>{\n<line3>int ret;\n<line4>do\n<line5>{\n<line6>process_signals ();\n<line7>ret = fstat (fd, st);\n<line8>}\n<line9>while (ret < 0 && errno == EINTR);\n<line10>return ret;\n<line11>}
----------------------------------------
Function: ifsync
Content: <line0>static int\n<line1>ifsync (int fd)\n<line2>{\n<line3>int ret;\n<line4>do\n<line5>{\n<line6>process_signals ();\n<line7>ret = fsync (fd);\n<line8>}\n<line9>while (ret < 0 && errno == EINTR);\n<line10>return ret;\n<line11>}
----------------------------------------
Function: iftruncate
Content: <line0>static int\n<line1>iftruncate (int fd, off_t length)\n<line2>{\n<line3>int ret;\n<line4>do\n<line5>{\n<line6>process_signals ();\n<line7>ret = ftruncate (fd, length);\n<line8>}\n<line9>while (ret < 0 && errno == EINTR);\n<line10>return ret;\n<line11>}
----------------------------------------
Function: parse_symbols
Content: <line0>static int\n<line1>parse_symbols (char const *str, struct symbol_value const *table,\n<line2>bool exclusive, char const *error_msgid)\n<line3>{\n<line4>int value = 0;\n<line5>while (true)\n<line6>{\n<line7>char const *strcomma = strchr (str, ',');\n<line8>struct symbol_value const *entry;\n<line9>for (entry = table;\n<line10>! (operand_matches (str, entry->symbol, ',') && entry->value);\n<line11>entry++)\n<line12>{\n<line13>if (! entry->symbol[0])\n<line14>{\n<line15>idx_t slen = strcomma ? strcomma - str : strlen (str);\n<line16>diagnose (0, "%s: %s", _(error_msgid),\n<line17>quotearg_n_style_mem (0, locale_quoting_style,\n<line18>str, slen));\n<line19>usage (EXIT_FAILURE);\n<line20>}\n<line21>}\n<line22>if (exclusive)\n<line23>value = entry->value;\n<line24>else\n<line25>value |= entry->value;\n<line26>if (!strcomma)\n<line27>break;\n<line28>str = strcomma + 1;\n<line29>}\n<line30>return value;\n<line31>}
----------------------------------------
Function: parse_integer
Content: <line0>static intmax_t\n<line1>parse_integer (char const *str, strtol_error *invalid)\n<line2>{\n<line3>/* Call xstrtoumax, not xstrtoimax, since we don't want to\n<line4>allow strings like " -0".  Initialize N to an indeterminate value;\n<line5>calling code should not rely on this function returning 0\n<line6>when *INVALID represents a non-overflow error.  */\n<line7>int indeterminate = 0;\n<line8>uintmax_t n = indeterminate;\n<line9>char *suffix;\n<line10>static char const suffixes[] = "bcEGkKMPQRTwYZ0";\n<line11>strtol_error e = xstrtoumax (str, &suffix, 10, &n, suffixes);\n<line12>intmax_t result;\n<line13>if ((e & ~LONGINT_OVERFLOW) == LONGINT_INVALID_SUFFIX_CHAR\n<line14>&& *suffix == 'B' && str < suffix && suffix[-1] != 'B')\n<line15>{\n<line16>suffix++;\n<line17>if (!*suffix)\n<line18>e &= ~LONGINT_INVALID_SUFFIX_CHAR;\n<line19>}\n<line20>if ((e & ~LONGINT_OVERFLOW) == LONGINT_INVALID_SUFFIX_CHAR\n<line21>&& *suffix == 'x')\n<line22>{\n<line23>strtol_error f = LONGINT_OK;\n<line24>intmax_t o = parse_integer (suffix + 1, &f);\n<line25>if ((f & ~LONGINT_OVERFLOW) != LONGINT_OK)\n<line26>{\n<line27>e = f;\n<line28>result = indeterminate;\n<line29>}\n<line30>else if (ckd_mul (&result, n, o)\n<line31>|| (result != 0 && ((e | f) & LONGINT_OVERFLOW)))\n<line32>{\n<line33>e = LONGINT_OVERFLOW;\n<line34>result = INTMAX_MAX;\n<line35>}\n<line36>else\n<line37>{\n<line38>if (result == 0 && STRPREFIX (str, "0x"))\n<line39>diagnose (0, _("warning: %s is a zero multiplier; "\n<line40>"use %s if that is intended"),\n<line41>quote_n (0, "0x"), quote_n (1, "00x"));\n<line42>e = LONGINT_OK;\n<line43>}\n<line44>}\n<line45>else if (n <= INTMAX_MAX)\n<line46>result = n;\n<line47>else\n<line48>{\n<line49>e = LONGINT_OVERFLOW;\n<line50>result = INTMAX_MAX;\n<line51>}\n<line52>*invalid = e;\n<line53>return result;\n<line54>}
----------------------------------------
Function: scanargs
Content: <line0>static void\n<line1>scanargs (int argc, char *const *argv)\n<line2>{\n<line3>idx_t blocksize = 0;\n<line4>intmax_t count = INTMAX_MAX;\n<line5>intmax_t skip = 0;\n<line6>intmax_t seek = 0;\n<line7>bool count_B = false, skip_B = false, seek_B = false;\n<line8>for (int i = optind; i < argc; i++)\n<line9>{\n<line10>char const *name = argv[i];\n<line11>char const *val = strchr (name, '=');\n<line12>if (val == nullptr)\n<line13>{\n<line14>diagnose (0, _("unrecognized operand %s"), quoteaf (name));\n<line15>usage (EXIT_FAILURE);\n<line16>}\n<line17>val++;\n<line18>if (operand_is (name, "if"))\n<line19>input_file = val;\n<line20>else if (operand_is (name, "of"))\n<line21>output_file = val;\n<line22>else if (operand_is (name, "conv"))\n<line23>conversions_mask |= parse_symbols (val, conversions, false,\n<line24>N_("invalid conversion"));\n<line25>else if (operand_is (name, "iflag"))\n<line26>input_flags |= parse_symbols (val, flags, false,\n<line27>N_("invalid input flag"));\n<line28>else if (operand_is (name, "oflag"))\n<line29>output_flags |= parse_symbols (val, flags, false,\n<line30>N_("invalid output flag"));\n<line31>else if (operand_is (name, "status"))\n<line32>status_level = parse_symbols (val, statuses, true,\n<line33>N_("invalid status level"));\n<line34>else\n<line35>{\n<line36>strtol_error invalid = LONGINT_OK;\n<line37>intmax_t n = parse_integer (val, &invalid);\n<line38>bool has_B = !!strchr (val, 'B');\n<line39>intmax_t n_min = 0;\n<line40>intmax_t n_max = INTMAX_MAX;\n<line41>idx_t *converted_idx = nullptr;\n<line42>/* Maximum blocksize.  Keep it smaller than IDX_MAX, so that\n<line43>it fits into blocksize vars even if 1 is added for conv=swab.\n<line44>Do not exceed SSIZE_MAX, for the benefit of system calls\n<line45>like "read".  And do not exceed OFF_T_MAX, for the\n<line46>benefit of the large-offset seek code.  */\n<line47>idx_t max_blocksize = MIN (IDX_MAX - 1, MIN (SSIZE_MAX, OFF_T_MAX));\n<line48>if (operand_is (name, "ibs"))\n<line49>{\n<line50>n_min = 1;\n<line51>n_max = max_blocksize;\n<line52>converted_idx = &input_blocksize;\n<line53>}\n<line54>else if (operand_is (name, "obs"))\n<line55>{\n<line56>n_min = 1;\n<line57>n_max = max_blocksize;\n<line58>converted_idx = &output_blocksize;\n<line59>}\n<line60>else if (operand_is (name, "bs"))\n<line61>{\n<line62>n_min = 1;\n<line63>n_max = max_blocksize;\n<line64>converted_idx = &blocksize;\n<line65>}\n<line66>else if (operand_is (name, "cbs"))\n<line67>{\n<line68>n_min = 1;\n<line69>n_max = MIN (SIZE_MAX, IDX_MAX);\n<line70>converted_idx = &conversion_blocksize;\n<line71>}\n<line72>else if (operand_is (name, "skip") || operand_is (name, "iseek"))\n<line73>{\n<line74>skip = n;\n<line75>skip_B = has_B;\n<line76>}\n<line77>else if (operand_is (name + (*name == 'o'), "seek"))\n<line78>{\n<line79>seek = n;\n<line80>seek_B = has_B;\n<line81>}\n<line82>else if (operand_is (name, "count"))\n<line83>{\n<line84>count = n;\n<line85>count_B = has_B;\n<line86>}\n<line87>else\n<line88>{\n<line89>diagnose (0, _("unrecognized operand %s"), quoteaf (name));\n<line90>usage (EXIT_FAILURE);\n<line91>}\n<line92>if (n < n_min)\n<line93>invalid = LONGINT_INVALID;\n<line94>else if (n_max < n)\n<line95>invalid = LONGINT_OVERFLOW;\n<line96>if (invalid != LONGINT_OK)\n<line97>error (EXIT_FAILURE, invalid == LONGINT_OVERFLOW ? EOVERFLOW : 0,\n<line98>"%s: %s", _("invalid number"), quoteaf (val));\n<line99>else if (converted_idx)\n<line100>*converted_idx = n;\n<line101>}\n<line102>}\n<line103>if (blocksize)\n<line104>input_blocksize = output_blocksize = blocksize;\n<line105>else\n<line106>{\n<line107>/* POSIX says dd aggregates partial reads into\n<line108>output_blocksize if bs= is not specified.  */\n<line109>conversions_mask |= C_TWOBUFS;\n<line110>}\n<line111>if (input_blocksize == 0)\n<line112>input_blocksize = DEFAULT_BLOCKSIZE;\n<line113>if (output_blocksize == 0)\n<line114>output_blocksize = DEFAULT_BLOCKSIZE;\n<line115>if (conversion_blocksize == 0)\n<line116>conversions_mask &= ~(C_BLOCK | C_UNBLOCK);\n<line117>if (input_flags & (O_DSYNC | O_SYNC))\n<line118>input_flags |= O_RSYNC;\n<line119>if (output_flags & O_FULLBLOCK)\n<line120>{\n<line121>diagnose (0, "%s: %s", _("invalid output flag"), quote ("fullblock"));\n<line122>usage (EXIT_FAILURE);\n<line123>}\n<line124>if (skip_B)\n<line125>input_flags |= O_SKIP_BYTES;\n<line126>if (input_flags & O_SKIP_BYTES && skip != 0)\n<line127>{\n<line128>skip_records = skip / input_blocksize;\n<line129>skip_bytes = skip % input_blocksize;\n<line130>}\n<line131>else if (skip != 0)\n<line132>skip_records = skip;\n<line133>if (count_B)\n<line134>input_flags |= O_COUNT_BYTES;\n<line135>if (input_flags & O_COUNT_BYTES && count != INTMAX_MAX)\n<line136>{\n<line137>max_records = count / input_blocksize;\n<line138>max_bytes = count % input_blocksize;\n<line139>}\n<line140>else if (count != INTMAX_MAX)\n<line141>max_records = count;\n<line142>if (seek_B)\n<line143>output_flags |= O_SEEK_BYTES;\n<line144>if (output_flags & O_SEEK_BYTES && seek != 0)\n<line145>{\n<line146>seek_records = seek / output_blocksize;\n<line147>seek_bytes = seek % output_blocksize;\n<line148>}\n<line149>else if (seek != 0)\n<line150>seek_records = seek;\n<line151>/* Warn about partial reads if bs=SIZE is given and iflag=fullblock\n<line152>is not, and if counting or skipping bytes or using direct I/O.\n<line153>This helps to avoid confusion with miscounts, and to avoid issues\n<line154>with direct I/O on GNU/Linux.  */\n<line155>warn_partial_read =\n<line156>(! (conversions_mask & C_TWOBUFS) && ! (input_flags & O_FULLBLOCK)\n<line157>&& (skip_records\n<line158>|| (0 < max_records && max_records < INTMAX_MAX)\n<line159>|| (input_flags | output_flags) & O_DIRECT));\n<line160>iread_fnc = ((input_flags & O_FULLBLOCK)\n<line161>? iread_fullblock\n<line162>: iread);\n<line163>input_flags &= ~O_FULLBLOCK;\n<line164>if (multiple_bits_set (conversions_mask & (C_ASCII | C_EBCDIC | C_IBM)))\n<line165>error (EXIT_FAILURE, 0, _("cannot combine any two of {ascii,ebcdic,ibm}"));\n<line166>if (multiple_bits_set (conversions_mask & (C_BLOCK | C_UNBLOCK)))\n<line167>error (EXIT_FAILURE, 0, _("cannot combine block and unblock"));\n<line168>if (multiple_bits_set (conversions_mask & (C_LCASE | C_UCASE)))\n<line169>error (EXIT_FAILURE, 0, _("cannot combine lcase and ucase"));\n<line170>if (multiple_bits_set (conversions_mask & (C_EXCL | C_NOCREAT)))\n<line171>error (EXIT_FAILURE, 0, _("cannot combine excl and nocreat"));\n<line172>if (multiple_bits_set (input_flags & (O_DIRECT | O_NOCACHE))\n<line173>|| multiple_bits_set (output_flags & (O_DIRECT | O_NOCACHE)))\n<line174>error (EXIT_FAILURE, 0, _("cannot combine direct and nocache"));\n<line175>if (input_flags & O_NOCACHE)\n<line176>{\n<line177>i_nocache = true;\n<line178>i_nocache_eof = (max_records == 0 && max_bytes == 0);\n<line179>input_flags &= ~O_NOCACHE;\n<line180>}\n<line181>if (output_flags & O_NOCACHE)\n<line182>{\n<line183>o_nocache = true;\n<line184>o_nocache_eof = (max_records == 0 && max_bytes == 0);\n<line185>output_flags &= ~O_NOCACHE;\n<line186>}\n<line187>}
----------------------------------------
Function: apply_translations
Content: <line0>static void\n<line1>apply_translations (void)\n<line2>{\n<line3>int i;\n<line4>if (conversions_mask & C_ASCII)\n<line5>translate_charset (ebcdic_to_ascii);\n<line6>if (conversions_mask & C_UCASE)\n<line7>{\n<line8>for (i = 0; i < 256; i++)\n<line9>trans_table[i] = toupper (trans_table[i]);\n<line10>translation_needed = true;\n<line11>}\n<line12>else if (conversions_mask & C_LCASE)\n<line13>{\n<line14>for (i = 0; i < 256; i++)\n<line15>trans_table[i] = tolower (trans_table[i]);\n<line16>translation_needed = true;\n<line17>}\n<line18>if (conversions_mask & C_EBCDIC)\n<line19>{\n<line20>translate_charset (ascii_to_ebcdic);\n<line21>newline_character = ascii_to_ebcdic['\n'];\n<line22>space_character = ascii_to_ebcdic[' '];\n<line23>}\n<line24>else if (conversions_mask & C_IBM)\n<line25>{\n<line26>translate_charset (ascii_to_ibm);\n<line27>newline_character = ascii_to_ibm['\n'];\n<line28>space_character = ascii_to_ibm[' '];\n<line29>}\n<line30>}
----------------------------------------
Function: translate_buffer
Content: <line0>static void\n<line1>translate_buffer (char *buf, idx_t nread)\n<line2>{\n<line3>idx_t i;\n<line4>char *cp;\n<line5>for (i = nread, cp = buf; i; i--, cp++)\n<line6>*cp = trans_table[to_uchar (*cp)];\n<line7>}
----------------------------------------
Function: swab_buffer
Content: <line0>static char *\n<line1>swab_buffer (char *buf, idx_t *nread, int *saved_byte)\n<line2>{\n<line3>if (*nread == 0)\n<line4>return buf;\n<line5>/* Update *SAVED_BYTE, and set PREV_SAVED to its old value.  */\n<line6>int prev_saved = *saved_byte;\n<line7>if ((prev_saved < 0) == (*nread & 1))\n<line8>{\n<line9>unsigned char c = buf[--*nread];\n<line10>*saved_byte = c;\n<line11>}\n<line12>else\n<line13>*saved_byte = -1;\n<line14>/* Do the byte-swapping by moving every other byte two\n<line15>positions toward the end, working from the end of the buffer\n<line16>toward the beginning.  This way we move only half the data.  */\n<line17>for (idx_t i = *nread; 1 < i; i -= 2)\n<line18>buf[i] = buf[i - 2];\n<line19>if (prev_saved < 0)\n<line20>return buf + 1;\n<line21>buf[1] = prev_saved;\n<line22>++*nread;\n<line23>return buf;\n<line24>}
----------------------------------------
Function: advance_input_offset
Content: <line0>static void\n<line1>advance_input_offset (intmax_t offset)\n<line2>{\n<line3>if (0 <= input_offset && ckd_add (&input_offset, input_offset, offset))\n<line4>input_offset = -1;\n<line5>}
----------------------------------------
Function: skip
Content: <line0>static intmax_t\n<line1>skip (int fdesc, char const *file, intmax_t records, idx_t blocksize,\n<line2>idx_t *bytes)\n<line3>{\n<line4>/* Try lseek and if an error indicates it was an inappropriate operation --\n<line5>or if the file offset is not representable as an off_t --\n<line6>fall back on using read.  */\n<line7>errno = 0;\n<line8>off_t offset;\n<line9>if (! ckd_mul (&offset, records, blocksize)\n<line10>&& ! ckd_add (&offset, offset, *bytes)\n<line11>&& 0 <= lseek (fdesc, offset, SEEK_CUR))\n<line12>{\n<line13>if (fdesc == STDIN_FILENO)\n<line14>{\n<line15>struct stat st;\n<line16>if (ifstat (STDIN_FILENO, &st) != 0)\n<line17>error (EXIT_FAILURE, errno, _("cannot fstat %s"), quoteaf (file));\n<line18>if (usable_st_size (&st) && 0 <= input_offset\n<line19>&& st.st_size - input_offset < offset)\n<line20>{\n<line21>/* When skipping past EOF, return the number of _full_ blocks\n<line22>* that are not skipped, and set offset to EOF, so the caller\n<line23>* can determine the requested skip was not satisfied.  */\n<line24>records = ( offset - st.st_size ) / blocksize;\n<line25>offset = st.st_size - input_offset;\n<line26>}\n<line27>else\n<line28>records = 0;\n<line29>advance_input_offset (offset);\n<line30>}\n<line31>else\n<line32>{\n<line33>records = 0;\n<line34>*bytes = 0;\n<line35>}\n<line36>return records;\n<line37>}\n<line38>else\n<line39>{\n<line40>int lseek_errno = errno;\n<line41>/* The seek request may have failed above if it was too big\n<line42>(> device size, > max file size, etc.)\n<line43>Or it may not have been done at all (> OFF_T_MAX).\n<line44>Therefore try to seek to the end of the file,\n<line45>to avoid redundant reading.  */\n<line46>if (lseek (fdesc, 0, SEEK_END) >= 0)\n<line47>{\n<line48>/* File is seekable, and we're at the end of it, and\n<line49>size <= OFF_T_MAX. So there's no point using read to advance.  */\n<line50>if (!lseek_errno)\n<line51>{\n<line52>/* The original seek was not attempted as offset > OFF_T_MAX.\n<line53>We should error for write as can't get to the desired\n<line54>location, even if OFF_T_MAX < max file size.\n<line55>For read we're not going to read any data anyway,\n<line56>so we should error for consistency.\n<line57>It would be nice to not error for /dev/{zero,null}\n<line58>for any offset, but that's not a significant issue.  */\n<line59>lseek_errno = EOVERFLOW;\n<line60>}\n<line61>diagnose (lseek_errno,\n<line62>gettext (fdesc == STDIN_FILENO\n<line63>? N_("%s: cannot skip")\n<line64>: N_("%s: cannot seek")),\n<line65>quotef (file));\n<line66>/* If the file has a specific size and we've asked\n<line67>to skip/seek beyond the max allowable, then quit.  */\n<line68>quit (EXIT_FAILURE);\n<line69>}\n<line70>/* else file_size && offset > OFF_T_MAX or file ! seekable */\n<line71>char *buf;\n<line72>if (fdesc == STDIN_FILENO)\n<line73>{\n<line74>alloc_ibuf ();\n<line75>buf = ibuf;\n<line76>}\n<line77>else\n<line78>{\n<line79>alloc_obuf ();\n<line80>buf = obuf;\n<line81>}\n<line82>do\n<line83>{\n<line84>ssize_t nread = iread_fnc (fdesc, buf, records ? blocksize : *bytes);\n<line85>if (nread < 0)\n<line86>{\n<line87>if (fdesc == STDIN_FILENO)\n<line88>{\n<line89>diagnose (errno, _("error reading %s"), quoteaf (file));\n<line90>if (conversions_mask & C_NOERROR)\n<line91>print_stats ();\n<line92>}\n<line93>else\n<line94>diagnose (lseek_errno, _("%s: cannot seek"), quotef (file));\n<line95>quit (EXIT_FAILURE);\n<line96>}\n<line97>else if (nread == 0)\n<line98>break;\n<line99>else if (fdesc == STDIN_FILENO)\n<line100>advance_input_offset (nread);\n<line101>if (records != 0)\n<line102>records--;\n<line103>else\n<line104>*bytes = 0;\n<line105>}\n<line106>while (records || *bytes);\n<line107>return records;\n<line108>}\n<line109>}
----------------------------------------
Function: advance_input_after_read_error
Content: <line0>static bool\n<line1>advance_input_after_read_error (idx_t nbytes)\n<line2>{\n<line3>if (! input_seekable)\n<line4>{\n<line5>if (input_seek_errno == ESPIPE)\n<line6>return true;\n<line7>errno = input_seek_errno;\n<line8>}\n<line9>else\n<line10>{\n<line11>off_t offset;\n<line12>advance_input_offset (nbytes);\n<line13>if (input_offset < 0)\n<line14>{\n<line15>diagnose (0, _("offset overflow while reading file %s"),\n<line16>quoteaf (input_file));\n<line17>return false;\n<line18>}\n<line19>offset = lseek (STDIN_FILENO, 0, SEEK_CUR);\n<line20>if (0 <= offset)\n<line21>{\n<line22>off_t diff;\n<line23>if (offset == input_offset)\n<line24>return true;\n<line25>diff = input_offset - offset;\n<line26>if (! (0 <= diff && diff <= nbytes) && status_level != STATUS_NONE)\n<line27>diagnose (0, _("warning: invalid file offset after failed read"));\n<line28>if (0 <= lseek (STDIN_FILENO, diff, SEEK_CUR))\n<line29>return true;\n<line30>if (errno == 0)\n<line31>diagnose (0, _("cannot work around kernel bug after all"));\n<line32>}\n<line33>}\n<line34>diagnose (errno, _("%s: cannot seek"), quotef (input_file));\n<line35>return false;\n<line36>}
----------------------------------------
Function: copy_simple
Content: <line0>static void\n<line1>copy_simple (char const *buf, idx_t nread)\n<line2>{\n<line3>char const *start = buf;	/* First uncopied char in BUF.  */\n<line4>do\n<line5>{\n<line6>idx_t nfree = MIN (nread, output_blocksize - oc);\n<line7>memcpy (obuf + oc, start, nfree);\n<line8>nread -= nfree;		/* Update the number of bytes left to copy. */\n<line9>start += nfree;\n<line10>oc += nfree;\n<line11>if (oc >= output_blocksize)\n<line12>write_output ();\n<line13>}\n<line14>while (nread != 0);\n<line15>}
----------------------------------------
Function: copy_with_block
Content: <line0>static void\n<line1>copy_with_block (char const *buf, idx_t nread)\n<line2>{\n<line3>for (idx_t i = nread; i; i--, buf++)\n<line4>{\n<line5>if (*buf == newline_character)\n<line6>{\n<line7>if (col < conversion_blocksize)\n<line8>{\n<line9>idx_t j;\n<line10>for (j = col; j < conversion_blocksize; j++)\n<line11>output_char (space_character);\n<line12>}\n<line13>col = 0;\n<line14>}\n<line15>else\n<line16>{\n<line17>if (col == conversion_blocksize)\n<line18>r_truncate++;\n<line19>else if (col < conversion_blocksize)\n<line20>output_char (*buf);\n<line21>col++;\n<line22>}\n<line23>}\n<line24>}
----------------------------------------
Function: copy_with_unblock
Content: <line0>static void\n<line1>copy_with_unblock (char const *buf, idx_t nread)\n<line2>{\n<line3>static idx_t pending_spaces = 0;\n<line4>for (idx_t i = 0; i < nread; i++)\n<line5>{\n<line6>char c = buf[i];\n<line7>if (col++ >= conversion_blocksize)\n<line8>{\n<line9>col = pending_spaces = 0; /* Wipe out any pending spaces.  */\n<line10>i--;			/* Push the char back; get it later. */\n<line11>output_char (newline_character);\n<line12>}\n<line13>else if (c == space_character)\n<line14>pending_spaces++;\n<line15>else\n<line16>{\n<line17>/* 'c' is the character after a run of spaces that were not\n<line18>at the end of the conversion buffer.  Output them.  */\n<line19>while (pending_spaces)\n<line20>{\n<line21>output_char (space_character);\n<line22>--pending_spaces;\n<line23>}\n<line24>output_char (c);\n<line25>}\n<line26>}\n<line27>}
----------------------------------------
Function: set_fd_flags
Content: <line0>static void\n<line1>set_fd_flags (int fd, int add_flags, char const *name)\n<line2>{\n<line3>/* Ignore file creation flags that are no-ops on file descriptors.  */\n<line4>add_flags &= ~ (O_NOCTTY | O_NOFOLLOW);\n<line5>if (add_flags)\n<line6>{\n<line7>int old_flags = fcntl (fd, F_GETFL);\n<line8>int new_flags = old_flags | add_flags;\n<line9>bool ok = true;\n<line10>if (old_flags < 0)\n<line11>ok = false;\n<line12>else if (old_flags != new_flags)\n<line13>{\n<line14>if (new_flags & (O_DIRECTORY | O_NOLINKS))\n<line15>{\n<line16>/* NEW_FLAGS contains at least one file creation flag that\n<line17>requires some checking of the open file descriptor.  */\n<line18>struct stat st;\n<line19>if (ifstat (fd, &st) != 0)\n<line20>ok = false;\n<line21>else if ((new_flags & O_DIRECTORY) && ! S_ISDIR (st.st_mode))\n<line22>{\n<line23>errno = ENOTDIR;\n<line24>ok = false;\n<line25>}\n<line26>else if ((new_flags & O_NOLINKS) && 1 < st.st_nlink)\n<line27>{\n<line28>errno = EMLINK;\n<line29>ok = false;\n<line30>}\n<line31>new_flags &= ~ (O_DIRECTORY | O_NOLINKS);\n<line32>}\n<line33>if (ok && old_flags != new_flags\n<line34>&& fcntl (fd, F_SETFL, new_flags) == -1)\n<line35>ok = false;\n<line36>}\n<line37>if (!ok)\n<line38>error (EXIT_FAILURE, errno, _("setting flags for %s"), quoteaf (name));\n<line39>}\n<line40>}
----------------------------------------
Function: dd_copy
Content: <line0>static int\n<line1>dd_copy (void)\n<line2>{\n<line3>char *bufstart;		/* Input buffer. */\n<line4>ssize_t nread;		/* Bytes read in the current block.  */\n<line5>/* If nonzero, then the previously read block was partial and\n<line6>PARTREAD was its size.  */\n<line7>idx_t partread = 0;\n<line8>int exit_status = EXIT_SUCCESS;\n<line9>idx_t n_bytes_read;\n<line10>if (skip_records != 0 || skip_bytes != 0)\n<line11>{\n<line12>intmax_t us_bytes;\n<line13>bool us_bytes_overflow =\n<line14>(ckd_mul (&us_bytes, skip_records, input_blocksize)\n<line15>|| ckd_add (&us_bytes, skip_bytes, us_bytes));\n<line16>off_t input_offset0 = input_offset;\n<line17>intmax_t us_blocks = skip (STDIN_FILENO, input_file,\n<line18>skip_records, input_blocksize, &skip_bytes);\n<line19>/* POSIX doesn't say what to do when dd detects it has been\n<line20>asked to skip past EOF, so I assume it's non-fatal.\n<line21>There are 3 reasons why there might be unskipped blocks/bytes:\n<line22>1. file is too small\n<line23>2. pipe has not enough data\n<line24>3. partial reads  */\n<line25>if ((us_blocks\n<line26>|| (0 <= input_offset\n<line27>&& (us_bytes_overflow\n<line28>|| us_bytes != input_offset - input_offset0)))\n<line29>&& status_level != STATUS_NONE)\n<line30>{\n<line31>diagnose (0, _("%s: cannot skip to specified offset"),\n<line32>quotef (input_file));\n<line33>}\n<line34>}\n<line35>if (seek_records != 0 || seek_bytes != 0)\n<line36>{\n<line37>idx_t bytes = seek_bytes;\n<line38>intmax_t write_records = skip (STDOUT_FILENO, output_file,\n<line39>seek_records, output_blocksize, &bytes);\n<line40>if (write_records != 0 || bytes != 0)\n<line41>{\n<line42>memset (obuf, 0, write_records ? output_blocksize : bytes);\n<line43>do\n<line44>{\n<line45>idx_t size = write_records ? output_blocksize : bytes;\n<line46>if (iwrite (STDOUT_FILENO, obuf, size) != size)\n<line47>{\n<line48>diagnose (errno, _("writing to %s"), quoteaf (output_file));\n<line49>quit (EXIT_FAILURE);\n<line50>}\n<line51>if (write_records != 0)\n<line52>write_records--;\n<line53>else\n<line54>bytes = 0;\n<line55>}\n<line56>while (write_records || bytes);\n<line57>}\n<line58>}\n<line59>if (max_records == 0 && max_bytes == 0)\n<line60>return exit_status;\n<line61>alloc_ibuf ();\n<line62>alloc_obuf ();\n<line63>int saved_byte = -1;\n<line64>while (true)\n<line65>{\n<line66>if (status_level == STATUS_PROGRESS)\n<line67>{\n<line68>xtime_t progress_time = gethrxtime ();\n<line69>if (next_time <= progress_time)\n<line70>{\n<line71>print_xfer_stats (progress_time);\n<line72>next_time += XTIME_PRECISION;\n<line73>}\n<line74>}\n<line75>if (r_partial + r_full >= max_records + !!max_bytes)\n<line76>break;\n<line77>/* Zero the buffer before reading, so that if we get a read error,\n<line78>whatever data we are able to read is followed by zeros.\n<line79>This minimizes data loss. */\n<line80>if ((conversions_mask & C_SYNC) && (conversions_mask & C_NOERROR))\n<line81>memset (ibuf,\n<line82>(conversions_mask & (C_BLOCK | C_UNBLOCK)) ? ' ' : '\0',\n<line83>input_blocksize);\n<line84>if (r_partial + r_full >= max_records)\n<line85>nread = iread_fnc (STDIN_FILENO, ibuf, max_bytes);\n<line86>else\n<line87>nread = iread_fnc (STDIN_FILENO, ibuf, input_blocksize);\n<line88>if (nread > 0)\n<line89>{\n<line90>advance_input_offset (nread);\n<line91>if (i_nocache)\n<line92>invalidate_cache (STDIN_FILENO, nread);\n<line93>}\n<line94>else if (nread == 0)\n<line95>{\n<line96>i_nocache_eof |= i_nocache;\n<line97>o_nocache_eof |= o_nocache && ! (conversions_mask & C_NOTRUNC);\n<line98>break;			/* EOF.  */\n<line99>}\n<line100>else\n<line101>{\n<line102>if (!(conversions_mask & C_NOERROR) || status_level != STATUS_NONE)\n<line103>diagnose (errno, _("error reading %s"), quoteaf (input_file));\n<line104>if (conversions_mask & C_NOERROR)\n<line105>{\n<line106>print_stats ();\n<line107>idx_t bad_portion = input_blocksize - partread;\n<line108>/* We already know this data is not cached,\n<line109>but call this so that correct offsets are maintained.  */\n<line110>invalidate_cache (STDIN_FILENO, bad_portion);\n<line111>/* Seek past the bad block if possible. */\n<line112>if (!advance_input_after_read_error (bad_portion))\n<line113>{\n<line114>exit_status = EXIT_FAILURE;\n<line115>/* Suppress duplicate diagnostics.  */\n<line116>input_seekable = false;\n<line117>input_seek_errno = ESPIPE;\n<line118>}\n<line119>if ((conversions_mask & C_SYNC) && !partread)\n<line120>/* Replace the missing input with null bytes and\n<line121>proceed normally.  */\n<line122>nread = 0;\n<line123>else\n<line124>continue;\n<line125>}\n<line126>else\n<line127>{\n<line128>/* Write any partial block. */\n<line129>exit_status = EXIT_FAILURE;\n<line130>break;\n<line131>}\n<line132>}\n<line133>n_bytes_read = nread;\n<line134>if (n_bytes_read < input_blocksize)\n<line135>{\n<line136>r_partial++;\n<line137>partread = n_bytes_read;\n<line138>if (conversions_mask & C_SYNC)\n<line139>{\n<line140>if (!(conversions_mask & C_NOERROR))\n<line141>/* If C_NOERROR, we zeroed the block before reading. */\n<line142>memset (ibuf + n_bytes_read,\n<line143>(conversions_mask & (C_BLOCK | C_UNBLOCK)) ? ' ' : '\0',\n<line144>input_blocksize - n_bytes_read);\n<line145>n_bytes_read = input_blocksize;\n<line146>}\n<line147>}\n<line148>else\n<line149>{\n<line150>r_full++;\n<line151>partread = 0;\n<line152>}\n<line153>if (ibuf == obuf)		/* If not C_TWOBUFS. */\n<line154>{\n<line155>idx_t nwritten = iwrite (STDOUT_FILENO, obuf, n_bytes_read);\n<line156>w_bytes += nwritten;\n<line157>if (nwritten != n_bytes_read)\n<line158>{\n<line159>diagnose (errno, _("error writing %s"), quoteaf (output_file));\n<line160>return EXIT_FAILURE;\n<line161>}\n<line162>else if (n_bytes_read == input_blocksize)\n<line163>w_full++;\n<line164>else\n<line165>w_partial++;\n<line166>continue;\n<line167>}\n<line168>/* Do any translations on the whole buffer at once.  */\n<line169>if (translation_needed)\n<line170>translate_buffer (ibuf, n_bytes_read);\n<line171>if (conversions_mask & C_SWAB)\n<line172>bufstart = swab_buffer (ibuf, &n_bytes_read, &saved_byte);\n<line173>else\n<line174>bufstart = ibuf;\n<line175>if (conversions_mask & C_BLOCK)\n<line176>copy_with_block (bufstart, n_bytes_read);\n<line177>else if (conversions_mask & C_UNBLOCK)\n<line178>copy_with_unblock (bufstart, n_bytes_read);\n<line179>else\n<line180>copy_simple (bufstart, n_bytes_read);\n<line181>}\n<line182>/* If we have a char left as a result of conv=swab, output it.  */\n<line183>if (0 <= saved_byte)\n<line184>{\n<line185>char saved_char = saved_byte;\n<line186>if (conversions_mask & C_BLOCK)\n<line187>copy_with_block (&saved_char, 1);\n<line188>else if (conversions_mask & C_UNBLOCK)\n<line189>copy_with_unblock (&saved_char, 1);\n<line190>else\n<line191>output_char (saved_char);\n<line192>}\n<line193>if ((conversions_mask & C_BLOCK) && col > 0)\n<line194>{\n<line195>/* If the final input line didn't end with a '\n', pad\n<line196>the output block to 'conversion_blocksize' chars.  */\n<line197>for (idx_t i = col; i < conversion_blocksize; i++)\n<line198>output_char (space_character);\n<line199>}\n<line200>if (col && (conversions_mask & C_UNBLOCK))\n<line201>{\n<line202>/* If there was any output, add a final '\n'.  */\n<line203>output_char (newline_character);\n<line204>}\n<line205>/* Write out the last block. */\n<line206>if (oc != 0)\n<line207>{\n<line208>idx_t nwritten = iwrite (STDOUT_FILENO, obuf, oc);\n<line209>w_bytes += nwritten;\n<line210>if (nwritten != 0)\n<line211>w_partial++;\n<line212>if (nwritten != oc)\n<line213>{\n<line214>diagnose (errno, _("error writing %s"), quoteaf (output_file));\n<line215>return EXIT_FAILURE;\n<line216>}\n<line217>}\n<line218>/* If the last write was converted to a seek, then for a regular file\n<line219>or shared memory object, ftruncate to extend the size.  */\n<line220>if (final_op_was_seek)\n<line221>{\n<line222>struct stat stdout_stat;\n<line223>if (ifstat (STDOUT_FILENO, &stdout_stat) != 0)\n<line224>{\n<line225>diagnose (errno, _("cannot fstat %s"), quoteaf (output_file));\n<line226>return EXIT_FAILURE;\n<line227>}\n<line228>if (S_ISREG (stdout_stat.st_mode) || S_TYPEISSHM (&stdout_stat))\n<line229>{\n<line230>off_t output_offset = lseek (STDOUT_FILENO, 0, SEEK_CUR);\n<line231>if (0 <= output_offset && stdout_stat.st_size < output_offset)\n<line232>{\n<line233>if (iftruncate (STDOUT_FILENO, output_offset) != 0)\n<line234>{\n<line235>diagnose (errno, _("failed to truncate to %" PRIdMAX " bytes"\n<line236>" in output file %s"),\n<line237>(intmax_t) output_offset, quoteaf (output_file));\n<line238>return EXIT_FAILURE;\n<line239>}\n<line240>}\n<line241>}\n<line242>}\n<line243>/* fdatasync/fsync can take a long time, so issue a final progress\n<line244>indication now if progress has been made since the previous indication.  */\n<line245>if (conversions_mask & (C_FDATASYNC | C_FSYNC)\n<line246>&& status_level == STATUS_PROGRESS\n<line247>&& 0 <= reported_w_bytes && reported_w_bytes < w_bytes)\n<line248>print_xfer_stats (0);\n<line249>return exit_status;\n<line250>}
----------------------------------------
Function: synchronize_output
Content: <line0>static int\n<line1>synchronize_output (void)\n<line2>{\n<line3>int exit_status = 0;\n<line4>int mask = conversions_mask;\n<line5>conversions_mask &= ~ (C_FDATASYNC | C_FSYNC);\n<line6>if ((mask & C_FDATASYNC) && ifdatasync (STDOUT_FILENO) != 0)\n<line7>{\n<line8>if (errno != ENOSYS && errno != EINVAL)\n<line9>{\n<line10>diagnose (errno, _("fdatasync failed for %s"), quoteaf (output_file));\n<line11>exit_status = EXIT_FAILURE;\n<line12>}\n<line13>mask |= C_FSYNC;\n<line14>}\n<line15>if ((mask & C_FSYNC) && ifsync (STDOUT_FILENO) != 0)\n<line16>{\n<line17>diagnose (errno, _("fsync failed for %s"), quoteaf (output_file));\n<line18>return EXIT_FAILURE;\n<line19>}\n<line20>return exit_status;\n<line21>}
----------------------------------------
Function: main
Content: <line0>int\n<line1>main (int argc, char **argv)\n<line2>{\n<line3>int i;\n<line4>int exit_status;\n<line5>off_t offset;\n<line6>install_signal_handlers ();\n<line7>initialize_main (&argc, &argv);\n<line8>set_program_name (argv[0]);\n<line9>setlocale (LC_ALL, "");\n<line10>bindtextdomain (PACKAGE, LOCALEDIR);\n<line11>textdomain (PACKAGE);\n<line12>/* Arrange to close stdout if parse_long_options exits.  */\n<line13>atexit (maybe_close_stdout);\n<line14>page_size = getpagesize ();\n<line15>parse_gnu_standard_options_only (argc, argv, PROGRAM_NAME, PACKAGE, Version,\n<line16>true, usage, AUTHORS,\n<line17>(char const *) nullptr);\n<line18>close_stdout_required = false;\n<line19>/* Initialize translation table to identity translation. */\n<line20>for (i = 0; i < 256; i++)\n<line21>trans_table[i] = i;\n<line22>/* Decode arguments. */\n<line23>scanargs (argc, argv);\n<line24>apply_translations ();\n<line25>if (input_file == nullptr)\n<line26>{\n<line27>input_file = _("standard input");\n<line28>set_fd_flags (STDIN_FILENO, input_flags, input_file);\n<line29>}\n<line30>else\n<line31>{\n<line32>if (ifd_reopen (STDIN_FILENO, input_file, O_RDONLY | input_flags, 0) < 0)\n<line33>error (EXIT_FAILURE, errno, _("failed to open %s"),\n<line34>quoteaf (input_file));\n<line35>}\n<line36>offset = lseek (STDIN_FILENO, 0, SEEK_CUR);\n<line37>input_seekable = (0 <= offset);\n<line38>input_offset = MAX (0, offset);\n<line39>input_seek_errno = errno;\n<line40>if (output_file == nullptr)\n<line41>{\n<line42>output_file = _("standard output");\n<line43>set_fd_flags (STDOUT_FILENO, output_flags, output_file);\n<line44>}\n<line45>else\n<line46>{\n<line47>mode_t perms = MODE_RW_UGO;\n<line48>int opts\n<line49>= (output_flags\n<line50>| (conversions_mask & C_NOCREAT ? 0 : O_CREAT)\n<line51>| (conversions_mask & C_EXCL ? O_EXCL : 0)\n<line52>| (seek_records || (conversions_mask & C_NOTRUNC) ? 0 : O_TRUNC));\n<line53>off_t size;\n<line54>if ((ckd_mul (&size, seek_records, output_blocksize)\n<line55>|| ckd_add (&size, seek_bytes, size))\n<line56>&& !(conversions_mask & C_NOTRUNC))\n<line57>error (EXIT_FAILURE, 0,\n<line58>_("offset too large: "\n<line59>"cannot truncate to a length of seek=%"PRIdMAX""\n<line60>" (%td-byte) blocks"),\n<line61>seek_records, output_blocksize);\n<line62>/* Open the output file with *read* access only if we might\n<line63>need to read to satisfy a 'seek=' request.  If we can't read\n<line64>the file, go ahead with write-only access; it might work.  */\n<line65>if ((! seek_records\n<line66>|| ifd_reopen (STDOUT_FILENO, output_file, O_RDWR | opts, perms) < 0)\n<line67>&& (ifd_reopen (STDOUT_FILENO, output_file, O_WRONLY | opts, perms)\n<line68>< 0))\n<line69>error (EXIT_FAILURE, errno, _("failed to open %s"),\n<line70>quoteaf (output_file));\n<line71>if (seek_records != 0 && !(conversions_mask & C_NOTRUNC))\n<line72>{\n<line73>if (iftruncate (STDOUT_FILENO, size) != 0)\n<line74>{\n<line75>/* Complain only when ftruncate fails on a regular file, a\n<line76>directory, or a shared memory object, as POSIX 1003.1-2004\n<line77>specifies ftruncate's behavior only for these file types.\n<line78>For example, do not complain when Linux kernel 2.4 ftruncate\n<line79>fails on /dev/fd0.  */\n<line80>int ftruncate_errno = errno;\n<line81>struct stat stdout_stat;\n<line82>if (ifstat (STDOUT_FILENO, &stdout_stat) != 0)\n<line83>{\n<line84>diagnose (errno, _("cannot fstat %s"), quoteaf (output_file));\n<line85>exit_status = EXIT_FAILURE;\n<line86>}\n<line87>else if (S_ISREG (stdout_stat.st_mode)\n<line88>|| S_ISDIR (stdout_stat.st_mode)\n<line89>|| S_TYPEISSHM (&stdout_stat))\n<line90>{\n<line91>intmax_t isize = size;\n<line92>diagnose (ftruncate_errno,\n<line93>_("failed to truncate to %"PRIdMAX" bytes"\n<line94>" in output file %s"),\n<line95>isize, quoteaf (output_file));\n<line96>exit_status = EXIT_FAILURE;\n<line97>}\n<line98>}\n<line99>}\n<line100>}\n<line101>start_time = gethrxtime ();\n<line102>next_time = start_time + XTIME_PRECISION;\n<line103>exit_status = dd_copy ();\n<line104>int sync_status = synchronize_output ();\n<line105>if (sync_status)\n<line106>exit_status = sync_status;\n<line107>if (max_records == 0 && max_bytes == 0)\n<line108>{\n<line109>/* Special case to invalidate cache to end of file.  */\n<line110>if (i_nocache && !invalidate_cache (STDIN_FILENO, 0))\n<line111>{\n<line112>diagnose (errno, _("failed to discard cache for: %s"),\n<line113>quotef (input_file));\n<line114>exit_status = EXIT_FAILURE;\n<line115>}\n<line116>if (o_nocache && !invalidate_cache (STDOUT_FILENO, 0))\n<line117>{\n<line118>diagnose (errno, _("failed to discard cache for: %s"),\n<line119>quotef (output_file));\n<line120>exit_status = EXIT_FAILURE;\n<line121>}\n<line122>}\n<line123>else\n<line124>{\n<line125>/* Invalidate any pending region or to EOF if appropriate.  */\n<line126>if (i_nocache || i_nocache_eof)\n<line127>invalidate_cache (STDIN_FILENO, 0);\n<line128>if (o_nocache || o_nocache_eof)\n<line129>invalidate_cache (STDOUT_FILENO, 0);\n<line130>}\n<line131>finish_up ();\n<line132>main_exit (exit_status);\n<line133>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/src/ls.c
========================================
/home/huihui/Downloads/coreutils-9.4/src/ls.c:180:63: warning: '_Static_assert' with no message is a C2x extension [-Wc2x-extensions]
static_assert (sizeof filetype_letter - 1 == arg_directory + 1);
                                                              ^
                                                              , ""
/home/huihui/Downloads/coreutils-9.4/src/ls.c:455:1: warning: '_Static_assert' with no message is a C2x extension [-Wc2x-extensions]
ARGMATCH_VERIFY (time_style_args, time_style_types);
^
./lib/argmatch.h:49:54: note: expanded from macro 'ARGMATCH_VERIFY'
                   == ARRAY_CARDINALITY (Vallist) + 1)
                                                     ^
/home/huihui/Downloads/coreutils-9.4/src/ls.c:560:1: warning: '_Static_assert' with no message is a C2x extension [-Wc2x-extensions]
ARGMATCH_VERIFY (indicator_style_args, indicator_style_types);
^
./lib/argmatch.h:49:54: note: expanded from macro 'ARGMATCH_VERIFY'
                   == ARRAY_CARDINALITY (Vallist) + 1)
                                                     ^
/home/huihui/Downloads/coreutils-9.4/src/ls.c:909:1: warning: '_Static_assert' with no message is a C2x extension [-Wc2x-extensions]
ARGMATCH_VERIFY (format_args, format_types);
^
./lib/argmatch.h:49:54: note: expanded from macro 'ARGMATCH_VERIFY'
                   == ARRAY_CARDINALITY (Vallist) + 1)
                                                     ^
/home/huihui/Downloads/coreutils-9.4/src/ls.c:919:1: warning: '_Static_assert' with no message is a C2x extension [-Wc2x-extensions]
ARGMATCH_VERIFY (sort_args, sort_types);
^
./lib/argmatch.h:49:54: note: expanded from macro 'ARGMATCH_VERIFY'
                   == ARRAY_CARDINALITY (Vallist) + 1)
                                                     ^
/home/huihui/Downloads/coreutils-9.4/src/ls.c:936:1: warning: '_Static_assert' with no message is a C2x extension [-Wc2x-extensions]
ARGMATCH_VERIFY (time_args, time_types);
^
./lib/argmatch.h:49:54: note: expanded from macro 'ARGMATCH_VERIFY'
                   == ARRAY_CARDINALITY (Vallist) + 1)
                                                     ^
/home/huihui/Downloads/coreutils-9.4/src/ls.c:951:1: warning: '_Static_assert' with no message is a C2x extension [-Wc2x-extensions]
ARGMATCH_VERIFY (when_args, when_types);
^
./lib/argmatch.h:49:54: note: expanded from macro 'ARGMATCH_VERIFY'
                   == ARRAY_CARDINALITY (Vallist) + 1)
                                                     ^
/home/huihui/Downloads/coreutils-9.4/src/ls.c:1660:55: warning: '_Static_assert' with no message is a C2x extension [-Wc2x-extensions]
                 == ARRAY_CARDINALITY (indicator_name));
                                                      ^
                                                      , ""
/home/huihui/Downloads/coreutils-9.4/src/ls.c:2286:33: warning: result of comparison of constant 9223372036854775807 with expression of type 'unsigned short' is always true [-Wtautological-constant-out-of-range-compare]
            linelen = ws.ws_col <= MIN (PTRDIFF_MAX, SIZE_MAX) ? ws.ws_col : 0;
                      ~~~~~~~~~ ^  ~~~~~~~~~~~~~~~~~~~~~~~~~~~
/home/huihui/Downloads/coreutils-9.4/src/ls.c:4054:52: warning: '_Static_assert' with no message is a C2x extension [-Wc2x-extensions]
               == sort_numtypes - 2 + time_numtypes);
                                                   ^
                                                   , ""
10 warnings generated.
Function: file_or_link_mode
Content: <line0>static mode_t\n<line1>file_or_link_mode (struct fileinfo const *file)\n<line2>{\n<line3>return (color_symlink_as_referent && file->linkok\n<line4>? file->linkmode : file->stat.st_mode);\n<line5>}
----------------------------------------
Function: dired_outbyte
Content: <line0>static void\n<line1>dired_outbyte (char c)\n<line2>{\n<line3>dired_pos++;\n<line4>putchar (c);\n<line5>}
----------------------------------------
Function: dired_outbuf
Content: <line0>static void\n<line1>dired_outbuf (char const *s, size_t s_len)\n<line2>{\n<line3>dired_pos += s_len;\n<line4>fwrite (s, sizeof *s, s_len, stdout);\n<line5>}
----------------------------------------
Function: dired_outstring
Content: <line0>static void\n<line1>dired_outstring (char const *s)\n<line2>{\n<line3>dired_outbuf (s, strlen (s));\n<line4>}
----------------------------------------
Function: dired_indent
Content: <line0>static void\n<line1>dired_indent (void)\n<line2>{\n<line3>if (dired)\n<line4>dired_outstring ("  ");\n<line5>}
----------------------------------------
Function: push_current_dired_pos
Content: <line0>static void\n<line1>push_current_dired_pos (struct obstack *obs)\n<line2>{\n<line3>if (dired)\n<line4>obstack_grow (obs, &dired_pos, sizeof dired_pos);\n<line5>}
----------------------------------------
Function: dev_ino_push
Content: <line0>static void\n<line1>dev_ino_push (dev_t dev, ino_t ino)\n<line2>{\n<line3>void *vdi;\n<line4>struct dev_ino *di;\n<line5>int dev_ino_size = sizeof *di;\n<line6>obstack_blank (&dev_ino_obstack, dev_ino_size);\n<line7>vdi = obstack_next_free (&dev_ino_obstack);\n<line8>di = vdi;\n<line9>di--;\n<line10>di->st_dev = dev;\n<line11>di->st_ino = ino;\n<line12>}
----------------------------------------
Function: dev_ino_pop
Content: <line0>static struct dev_ino\n<line1>dev_ino_pop (void)\n<line2>{\n<line3>void *vdi;\n<line4>struct dev_ino *di;\n<line5>int dev_ino_size = sizeof *di;\n<line6>affirm (dev_ino_size <= obstack_object_size (&dev_ino_obstack));\n<line7>obstack_blank_fast (&dev_ino_obstack, -dev_ino_size);\n<line8>vdi = obstack_next_free (&dev_ino_obstack);\n<line9>di = vdi;\n<line10>return *di;\n<line11>}
----------------------------------------
Function: assert_matching_dev_ino
Content: <line0>static void\n<line1>assert_matching_dev_ino (char const *name, struct dev_ino di)\n<line2>{\n<line3>MAYBE_UNUSED struct stat sb;\n<line4>assure (0 <= stat (name, &sb));\n<line5>assure (sb.st_dev == di.st_dev);\n<line6>assure (sb.st_ino == di.st_ino);\n<line7>}
----------------------------------------
Function: dired_dump_obstack
Content: <line0>static void\n<line1>dired_dump_obstack (char const *prefix, struct obstack *os)\n<line2>{\n<line3>size_t n_pos;\n<line4>n_pos = obstack_object_size (os) / sizeof (dired_pos);\n<line5>if (n_pos > 0)\n<line6>{\n<line7>off_t *pos = obstack_finish (os);\n<line8>fputs (prefix, stdout);\n<line9>for (size_t i = 0; i < n_pos; i++)\n<line10>{\n<line11>intmax_t p = pos[i];\n<line12>printf (" %"PRIdMAX, p);\n<line13>}\n<line14>putchar ('\n');\n<line15>}\n<line16>}
----------------------------------------
Function: get_stat_btime
Content: <line0>static struct timespec\n<line1>get_stat_btime (struct stat const *st)\n<line2>{\n<line3>struct timespec btimespec;\n<line4>#if HAVE_STATX && defined STATX_INO\n<line5>btimespec = get_stat_mtime (st);\n<line6>#else\n<line7>btimespec = get_stat_birthtime (st);\n<line8>#endif\n<line9>return btimespec;\n<line10>}
----------------------------------------
Function: do_statx
Content: <line0>static int\n<line1>do_statx (int fd, char const *name, struct stat *st, int flags,\n<line2>unsigned int mask)\n<line3>{\n<line4>struct statx stx;\n<line5>bool want_btime = mask & STATX_BTIME;\n<line6>int ret = statx (fd, name, flags | AT_NO_AUTOMOUNT, mask, &stx);\n<line7>if (ret >= 0)\n<line8>{\n<line9>statx_to_stat (&stx, st);\n<line10>/* Since we only need one timestamp type,\n<line11>store birth time in st_mtim.  */\n<line12>if (want_btime)\n<line13>{\n<line14>if (stx.stx_mask & STATX_BTIME)\n<line15>st->st_mtim = statx_timestamp_to_timespec (stx.stx_btime);\n<line16>else\n<line17>st->st_mtim.tv_sec = st->st_mtim.tv_nsec = -1;\n<line18>}\n<line19>}\n<line20>return ret;\n<line21>}
----------------------------------------
Function: do_stat
Content: <line0>static int\n<line1>do_stat (char const *name, struct stat *st)\n<line2>{\n<line3>return do_statx (AT_FDCWD, name, st, 0, calc_req_mask ());\n<line4>}
----------------------------------------
Function: do_lstat
Content: <line0>static int\n<line1>do_lstat (char const *name, struct stat *st)\n<line2>{\n<line3>return do_statx (AT_FDCWD, name, st, AT_SYMLINK_NOFOLLOW, calc_req_mask ());\n<line4>}
----------------------------------------
Function: stat_for_mode
Content: <line0>static int\n<line1>stat_for_mode (char const *name, struct stat *st)\n<line2>{\n<line3>return do_statx (AT_FDCWD, name, st, 0, STATX_MODE);\n<line4>}
----------------------------------------
Function: stat_for_ino
Content: <line0>static int\n<line1>stat_for_ino (char const *name, struct stat *st)\n<line2>{\n<line3>return do_statx (AT_FDCWD, name, st, 0, STATX_INO);\n<line4>}
----------------------------------------
Function: fstat_for_ino
Content: <line0>static int\n<line1>fstat_for_ino (int fd, struct stat *st)\n<line2>{\n<line3>return do_statx (fd, "", st, AT_EMPTY_PATH, STATX_INO);\n<line4>}
----------------------------------------
Function: file_escape_init
Content: <line0>static void\n<line1>file_escape_init (void)\n<line2>{\n<line3>for (int i = 0; i < 256; i++)\n<line4>RFC3986[i] |= c_isalnum (i) || i == '~' || i == '-' || i == '.' || i == '_';\n<line5>}
----------------------------------------
Function: abmon_init
Content: <line0>static bool\n<line1>abmon_init (char abmon[12][ABFORMAT_SIZE])\n<line2>{\n<line3>#ifndef HAVE_NL_LANGINFO\n<line4>return false;\n<line5>#else\n<line6>size_t required_mon_width = MAX_MON_WIDTH;\n<line7>size_t curr_max_width;\n<line8>do\n<line9>{\n<line10>curr_max_width = required_mon_width;\n<line11>required_mon_width = 0;\n<line12>for (int i = 0; i < 12; i++)\n<line13>{\n<line14>size_t width = curr_max_width;\n<line15>char const *abbr = nl_langinfo (ABMON_1 + i);\n<line16>if (strchr (abbr, '%'))\n<line17>return false;\n<line18>mbs_align_t alignment = isdigit (to_uchar (*abbr))\n<line19>? MBS_ALIGN_RIGHT : MBS_ALIGN_LEFT;\n<line20>size_t req = mbsalign (abbr, abmon[i], ABFORMAT_SIZE,\n<line21>&width, alignment, 0);\n<line22>if (! (req < ABFORMAT_SIZE))\n<line23>return false;\n<line24>required_mon_width = MAX (required_mon_width, width);\n<line25>}\n<line26>}\n<line27>while (curr_max_width > required_mon_width);\n<line28>return true;\n<line29>#endif\n<line30>}
----------------------------------------
Function: abformat_init
Content: <line0>static void\n<line1>abformat_init (void)\n<line2>{\n<line3>char const *pb[2];\n<line4>for (int recent = 0; recent < 2; recent++)\n<line5>pb[recent] = first_percent_b (long_time_format[recent]);\n<line6>if (! (pb[0] || pb[1]))\n<line7>return;\n<line8>char abmon[12][ABFORMAT_SIZE];\n<line9>if (! abmon_init (abmon))\n<line10>return;\n<line11>for (int recent = 0; recent < 2; recent++)\n<line12>{\n<line13>char const *fmt = long_time_format[recent];\n<line14>for (int i = 0; i < 12; i++)\n<line15>{\n<line16>char *nfmt = abformat[recent][i];\n<line17>int nbytes;\n<line18>if (! pb[recent])\n<line19>nbytes = snprintf (nfmt, ABFORMAT_SIZE, "%s", fmt);\n<line20>else\n<line21>{\n<line22>if (! (pb[recent] - fmt <= MIN (ABFORMAT_SIZE, INT_MAX)))\n<line23>return;\n<line24>int prefix_len = pb[recent] - fmt;\n<line25>nbytes = snprintf (nfmt, ABFORMAT_SIZE, "%.*s%s%s",\n<line26>prefix_len, fmt, abmon[i], pb[recent] + 2);\n<line27>}\n<line28>if (! (0 <= nbytes && nbytes < ABFORMAT_SIZE))\n<line29>return;\n<line30>}\n<line31>}\n<line32>use_abformat = true;\n<line33>}
----------------------------------------
Function: dev_ino_hash
Content: <line0>static size_t\n<line1>dev_ino_hash (void const *x, size_t table_size)\n<line2>{\n<line3>struct dev_ino const *p = x;\n<line4>return (uintmax_t) p->st_ino % table_size;\n<line5>}
----------------------------------------
Function: dev_ino_compare
Content: <line0>static bool\n<line1>dev_ino_compare (void const *x, void const *y)\n<line2>{\n<line3>struct dev_ino const *a = x;\n<line4>struct dev_ino const *b = y;\n<line5>return SAME_INODE (*a, *b) ? true : false;\n<line6>}
----------------------------------------
Function: dev_ino_free
Content: <line0>static void\n<line1>dev_ino_free (void *x)\n<line2>{\n<line3>free (x);\n<line4>}
----------------------------------------
Function: visit_dir
Content: <line0>static bool\n<line1>visit_dir (dev_t dev, ino_t ino)\n<line2>{\n<line3>struct dev_ino *ent;\n<line4>struct dev_ino *ent_from_table;\n<line5>bool found_match;\n<line6>ent = xmalloc (sizeof *ent);\n<line7>ent->st_ino = ino;\n<line8>ent->st_dev = dev;\n<line9>/* Attempt to insert this entry into the table.  */\n<line10>ent_from_table = hash_insert (active_dir_set, ent);\n<line11>if (ent_from_table == nullptr)\n<line12>{\n<line13>/* Insertion failed due to lack of memory.  */\n<line14>xalloc_die ();\n<line15>}\n<line16>found_match = (ent_from_table != ent);\n<line17>if (found_match)\n<line18>{\n<line19>/* ent was not inserted, so free it.  */\n<line20>free (ent);\n<line21>}\n<line22>return found_match;\n<line23>}
----------------------------------------
Function: free_pending_ent
Content: <line0>static void\n<line1>free_pending_ent (struct pending *p)\n<line2>{\n<line3>free (p->name);\n<line4>free (p->realname);\n<line5>free (p);\n<line6>}
----------------------------------------
Function: is_colored
Content: <line0>static bool\n<line1>is_colored (enum indicator_no type)\n<line2>{\n<line3>size_t len = color_indicator[type].len;\n<line4>char const *s = color_indicator[type].string;\n<line5>return ! (len == 0\n<line6>|| (len == 1 && STRNCMP_LIT (s, "0") == 0)\n<line7>|| (len == 2 && STRNCMP_LIT (s, "00") == 0));\n<line8>}
----------------------------------------
Function: restore_default_color
Content: <line0>static void\n<line1>restore_default_color (void)\n<line2>{\n<line3>put_indicator (&color_indicator[C_LEFT]);\n<line4>put_indicator (&color_indicator[C_RIGHT]);\n<line5>}
----------------------------------------
Function: set_normal_color
Content: <line0>static void\n<line1>set_normal_color (void)\n<line2>{\n<line3>if (print_with_color && is_colored (C_NORM))\n<line4>{\n<line5>put_indicator (&color_indicator[C_LEFT]);\n<line6>put_indicator (&color_indicator[C_NORM]);\n<line7>put_indicator (&color_indicator[C_RIGHT]);\n<line8>}\n<line9>}
----------------------------------------
Function: sighandler
Content: <line0>static void\n<line1>sighandler (int sig)\n<line2>{\n<line3>if (! SA_NOCLDSTOP)\n<line4>signal (sig, SIG_IGN);\n<line5>if (! interrupt_signal)\n<line6>interrupt_signal = sig;\n<line7>}
----------------------------------------
Function: stophandler
Content: <line0>static void\n<line1>stophandler (int sig)\n<line2>{\n<line3>if (! SA_NOCLDSTOP)\n<line4>signal (sig, stophandler);\n<line5>if (! interrupt_signal)\n<line6>stop_signal_count++;\n<line7>}
----------------------------------------
Function: process_signals
Content: <line0>static void\n<line1>process_signals (void)\n<line2>{\n<line3>while (interrupt_signal || stop_signal_count)\n<line4>{\n<line5>int sig;\n<line6>int stops;\n<line7>sigset_t oldset;\n<line8>if (used_color)\n<line9>restore_default_color ();\n<line10>fflush (stdout);\n<line11>sigprocmask (SIG_BLOCK, &caught_signals, &oldset);\n<line12>/* Reload interrupt_signal and stop_signal_count, in case a new\n<line13>signal was handled before sigprocmask took effect.  */\n<line14>sig = interrupt_signal;\n<line15>stops = stop_signal_count;\n<line16>/* SIGTSTP is special, since the application can receive that signal\n<line17>more than once.  In this case, don't set the signal handler to the\n<line18>default.  Instead, just raise the uncatchable SIGSTOP.  */\n<line19>if (stops)\n<line20>{\n<line21>stop_signal_count = stops - 1;\n<line22>sig = SIGSTOP;\n<line23>}\n<line24>else\n<line25>signal (sig, SIG_DFL);\n<line26>/* Exit or suspend the program.  */\n<line27>raise (sig);\n<line28>sigprocmask (SIG_SETMASK, &oldset, nullptr);\n<line29>/* If execution reaches here, then the program has been\n<line30>continued (after being suspended).  */\n<line31>}\n<line32>}
----------------------------------------
Function: signal_setup
Content: <line0>static void\n<line1>signal_setup (bool init)\n<line2>{\n<line3>/* The signals that are trapped, and the number of such signals.  */\n<line4>static int const sig[] =\n<line5>{\n<line6>/* This one is handled specially.  */\n<line7>SIGTSTP,\n<line8>/* The usual suspects.  */\n<line9>SIGALRM, SIGHUP, SIGINT, SIGPIPE, SIGQUIT, SIGTERM,\n<line10>#ifdef SIGPOLL\n<line11>SIGPOLL,\n<line12>#endif\n<line13>#ifdef SIGPROF\n<line14>SIGPROF,\n<line15>#endif\n<line16>#ifdef SIGVTALRM\n<line17>SIGVTALRM,\n<line18>#endif\n<line19>#ifdef SIGXCPU\n<line20>SIGXCPU,\n<line21>#endif\n<line22>#ifdef SIGXFSZ\n<line23>SIGXFSZ,\n<line24>#endif\n<line25>};\n<line26>enum { nsigs = ARRAY_CARDINALITY (sig) };\n<line27>#if ! SA_NOCLDSTOP\n<line28>static bool caught_sig[nsigs];\n<line29>#endif\n<line30>int j;\n<line31>if (init)\n<line32>{\n<line33>#if SA_NOCLDSTOP\n<line34>struct sigaction act;\n<line35>sigemptyset (&caught_signals);\n<line36>for (j = 0; j < nsigs; j++)\n<line37>{\n<line38>sigaction (sig[j], nullptr, &act);\n<line39>if (act.sa_handler != SIG_IGN)\n<line40>sigaddset (&caught_signals, sig[j]);\n<line41>}\n<line42>act.sa_mask = caught_signals;\n<line43>act.sa_flags = SA_RESTART;\n<line44>for (j = 0; j < nsigs; j++)\n<line45>if (sigismember (&caught_signals, sig[j]))\n<line46>{\n<line47>act.sa_handler = sig[j] == SIGTSTP ? stophandler : sighandler;\n<line48>sigaction (sig[j], &act, nullptr);\n<line49>}\n<line50>#else\n<line51>for (j = 0; j < nsigs; j++)\n<line52>{\n<line53>caught_sig[j] = (signal (sig[j], SIG_IGN) != SIG_IGN);\n<line54>if (caught_sig[j])\n<line55>{\n<line56>signal (sig[j], sig[j] == SIGTSTP ? stophandler : sighandler);\n<line57>siginterrupt (sig[j], 0);\n<line58>}\n<line59>}\n<line60>#endif\n<line61>}\n<line62>else /* restore.  */\n<line63>{\n<line64>#if SA_NOCLDSTOP\n<line65>for (j = 0; j < nsigs; j++)\n<line66>if (sigismember (&caught_signals, sig[j]))\n<line67>signal (sig[j], SIG_DFL);\n<line68>#else\n<line69>for (j = 0; j < nsigs; j++)\n<line70>if (caught_sig[j])\n<line71>signal (sig[j], SIG_DFL);\n<line72>#endif\n<line73>}\n<line74>}
----------------------------------------
Function: signal_init
Content: <line0>static void\n<line1>signal_init (void)\n<line2>{\n<line3>signal_setup (true);\n<line4>}
----------------------------------------
Function: signal_restore
Content: <line0>static void\n<line1>signal_restore (void)\n<line2>{\n<line3>signal_setup (false);\n<line4>}
----------------------------------------
Function: main
Content: <line0>int\n<line1>main (int argc, char **argv)\n<line2>{\n<line3>int i;\n<line4>struct pending *thispend;\n<line5>int n_files;\n<line6>initialize_main (&argc, &argv);\n<line7>set_program_name (argv[0]);\n<line8>setlocale (LC_ALL, "");\n<line9>bindtextdomain (PACKAGE, LOCALEDIR);\n<line10>textdomain (PACKAGE);\n<line11>initialize_exit_failure (LS_FAILURE);\n<line12>atexit (close_stdout);\n<line13>static_assert (ARRAY_CARDINALITY (color_indicator) + 1\n<line14>== ARRAY_CARDINALITY (indicator_name));\n<line15>exit_status = EXIT_SUCCESS;\n<line16>print_dir_name = true;\n<line17>pending_dirs = nullptr;\n<line18>current_time.tv_sec = TYPE_MINIMUM (time_t);\n<line19>current_time.tv_nsec = -1;\n<line20>i = decode_switches (argc, argv);\n<line21>if (print_with_color)\n<line22>parse_ls_color ();\n<line23>/* Test print_with_color again, because the call to parse_ls_color\n<line24>may have just reset it -- e.g., if LS_COLORS is invalid.  */\n<line25>if (print_with_color)\n<line26>{\n<line27>/* Don't use TAB characters in output.  Some terminal\n<line28>emulators can't handle the combination of tabs and\n<line29>color codes on the same line.  */\n<line30>tabsize = 0;\n<line31>}\n<line32>if (directories_first)\n<line33>check_symlink_mode = true;\n<line34>else if (print_with_color)\n<line35>{\n<line36>/* Avoid following symbolic links when possible.  */\n<line37>if (is_colored (C_ORPHAN)\n<line38>|| (is_colored (C_EXEC) && color_symlink_as_referent)\n<line39>|| (is_colored (C_MISSING) && format == long_format))\n<line40>check_symlink_mode = true;\n<line41>}\n<line42>if (dereference == DEREF_UNDEFINED)\n<line43>dereference = ((immediate_dirs\n<line44>|| indicator_style == classify\n<line45>|| format == long_format)\n<line46>? DEREF_NEVER\n<line47>: DEREF_COMMAND_LINE_SYMLINK_TO_DIR);\n<line48>/* When using -R, initialize a data structure we'll use to\n<line49>detect any directory cycles.  */\n<line50>if (recursive)\n<line51>{\n<line52>active_dir_set = hash_initialize (INITIAL_TABLE_SIZE, nullptr,\n<line53>dev_ino_hash,\n<line54>dev_ino_compare,\n<line55>dev_ino_free);\n<line56>if (active_dir_set == nullptr)\n<line57>xalloc_die ();\n<line58>obstack_init (&dev_ino_obstack);\n<line59>}\n<line60>localtz = tzalloc (getenv ("TZ"));\n<line61>format_needs_stat = sort_type == sort_time || sort_type == sort_size\n<line62>|| format == long_format\n<line63>|| print_scontext\n<line64>|| print_block_size;\n<line65>format_needs_type = (! format_needs_stat\n<line66>&& (recursive\n<line67>|| print_with_color\n<line68>|| indicator_style != none\n<line69>|| directories_first));\n<line70>if (dired)\n<line71>{\n<line72>obstack_init (&dired_obstack);\n<line73>obstack_init (&subdired_obstack);\n<line74>}\n<line75>if (print_hyperlink)\n<line76>{\n<line77>file_escape_init ();\n<line78>hostname = xgethostname ();\n<line79>/* The hostname is generally ignored,\n<line80>so ignore failures obtaining it.  */\n<line81>if (! hostname)\n<line82>hostname = "";\n<line83>}\n<line84>cwd_n_alloc = 100;\n<line85>cwd_file = xnmalloc (cwd_n_alloc, sizeof *cwd_file);\n<line86>cwd_n_used = 0;\n<line87>clear_files ();\n<line88>n_files = argc - i;\n<line89>if (n_files <= 0)\n<line90>{\n<line91>if (immediate_dirs)\n<line92>gobble_file (".", directory, NOT_AN_INODE_NUMBER, true, "");\n<line93>else\n<line94>queue_directory (".", nullptr, true);\n<line95>}\n<line96>else\n<line97>do\n<line98>gobble_file (argv[i++], unknown, NOT_AN_INODE_NUMBER, true, "");\n<line99>while (i < argc);\n<line100>if (cwd_n_used)\n<line101>{\n<line102>sort_files ();\n<line103>if (!immediate_dirs)\n<line104>extract_dirs_from_files (nullptr, true);\n<line105>/* 'cwd_n_used' might be zero now.  */\n<line106>}\n<line107>/* In the following if/else blocks, it is sufficient to test 'pending_dirs'\n<line108>(and not pending_dirs->name) because there may be no markers in the queue\n<line109>at this point.  A marker may be enqueued when extract_dirs_from_files is\n<line110>called with a non-empty string or via print_dir.  */\n<line111>if (cwd_n_used)\n<line112>{\n<line113>print_current_files ();\n<line114>if (pending_dirs)\n<line115>dired_outbyte ('\n');\n<line116>}\n<line117>else if (n_files <= 1 && pending_dirs && pending_dirs->next == 0)\n<line118>print_dir_name = false;\n<line119>while (pending_dirs)\n<line120>{\n<line121>thispend = pending_dirs;\n<line122>pending_dirs = pending_dirs->next;\n<line123>if (LOOP_DETECT)\n<line124>{\n<line125>if (thispend->name == nullptr)\n<line126>{\n<line127>/* thispend->name == nullptr means this is a marker entry\n<line128>indicating we've finished processing the directory.\n<line129>Use its dev/ino numbers to remove the corresponding\n<line130>entry from the active_dir_set hash table.  */\n<line131>struct dev_ino di = dev_ino_pop ();\n<line132>struct dev_ino *found = hash_remove (active_dir_set, &di);\n<line133>if (false)\n<line134>assert_matching_dev_ino (thispend->realname, di);\n<line135>affirm (found);\n<line136>dev_ino_free (found);\n<line137>free_pending_ent (thispend);\n<line138>continue;\n<line139>}\n<line140>}\n<line141>print_dir (thispend->name, thispend->realname,\n<line142>thispend->command_line_arg);\n<line143>free_pending_ent (thispend);\n<line144>print_dir_name = true;\n<line145>}\n<line146>if (print_with_color && used_color)\n<line147>{\n<line148>int j;\n<line149>/* Skip the restore when it would be a no-op, i.e.,\n<line150>when left is "\033[" and right is "m".  */\n<line151>if (!(color_indicator[C_LEFT].len == 2\n<line152>&& memcmp (color_indicator[C_LEFT].string, "\033[", 2) == 0\n<line153>&& color_indicator[C_RIGHT].len == 1\n<line154>&& color_indicator[C_RIGHT].string[0] == 'm'))\n<line155>restore_default_color ();\n<line156>fflush (stdout);\n<line157>signal_restore ();\n<line158>/* Act on any signals that arrived before the default was restored.\n<line159>This can process signals out of order, but there doesn't seem to\n<line160>be an easy way to do them in order, and the order isn't that\n<line161>important anyway.  */\n<line162>for (j = stop_signal_count; j; j--)\n<line163>raise (SIGSTOP);\n<line164>j = interrupt_signal;\n<line165>if (j)\n<line166>raise (j);\n<line167>}\n<line168>if (dired)\n<line169>{\n<line170>/* No need to free these since we're about to exit.  */\n<line171>dired_dump_obstack ("//DIRED//", &dired_obstack);\n<line172>dired_dump_obstack ("//SUBDIRED//", &subdired_obstack);\n<line173>printf ("//DIRED-OPTIONS// --quoting-style=%s\n",\n<line174>quoting_style_args[get_quoting_style (filename_quoting_options)]);\n<line175>}\n<line176>if (LOOP_DETECT)\n<line177>{\n<line178>assure (hash_get_n_entries (active_dir_set) == 0);\n<line179>hash_free (active_dir_set);\n<line180>}\n<line181>return exit_status;\n<line182>}
----------------------------------------
Function: decode_line_length
Content: <line0>static ptrdiff_t\n<line1>decode_line_length (char const *spec)\n<line2>{\n<line3>uintmax_t val;\n<line4>/* Treat too-large values as if they were 0, which is\n<line5>effectively infinity.  */\n<line6>switch (xstrtoumax (spec, nullptr, 0, &val, ""))\n<line7>{\n<line8>case LONGINT_OK:\n<line9>return val <= MIN (PTRDIFF_MAX, SIZE_MAX) ? val : 0;\n<line10>case LONGINT_OVERFLOW:\n<line11>return 0;\n<line12>default:\n<line13>return -1;\n<line14>}\n<line15>}
----------------------------------------
Function: stdout_isatty
Content: <line0>static bool\n<line1>stdout_isatty (void)\n<line2>{\n<line3>static signed char out_tty = -1;\n<line4>if (out_tty < 0)\n<line5>out_tty = isatty (STDOUT_FILENO);\n<line6>assume (out_tty == 0 || out_tty == 1);\n<line7>return out_tty;\n<line8>}
----------------------------------------
Function: decode_switches
Content: <line0>static int\n<line1>decode_switches (int argc, char **argv)\n<line2>{\n<line3>char *time_style_option = nullptr;\n<line4>/* These variables are false or -1 unless a switch says otherwise.  */\n<line5>bool kibibytes_specified = false;\n<line6>int format_opt = -1;\n<line7>int hide_control_chars_opt = -1;\n<line8>int quoting_style_opt = -1;\n<line9>int sort_opt = -1;\n<line10>ptrdiff_t tabsize_opt = -1;\n<line11>ptrdiff_t width_opt = -1;\n<line12>while (true)\n<line13>{\n<line14>int oi = -1;\n<line15>int c = getopt_long (argc, argv,\n<line16>"abcdfghiklmnopqrstuvw:xABCDFGHI:LNQRST:UXZ1",\n<line17>long_options, &oi);\n<line18>if (c == -1)\n<line19>break;\n<line20>switch (c)\n<line21>{\n<line22>case 'a':\n<line23>ignore_mode = IGNORE_MINIMAL;\n<line24>break;\n<line25>case 'b':\n<line26>quoting_style_opt = escape_quoting_style;\n<line27>break;\n<line28>case 'c':\n<line29>time_type = time_ctime;\n<line30>break;\n<line31>case 'd':\n<line32>immediate_dirs = true;\n<line33>break;\n<line34>case 'f':\n<line35>/* Same as -a -U -1 --color=none --hyperlink=none,\n<line36>while disabling -s.  */\n<line37>ignore_mode = IGNORE_MINIMAL;\n<line38>sort_opt = sort_none;\n<line39>if (format_opt == long_format)\n<line40>format_opt = -1;\n<line41>print_with_color = false;\n<line42>print_hyperlink = false;\n<line43>print_block_size = false;\n<line44>break;\n<line45>case FILE_TYPE_INDICATOR_OPTION: /* --file-type */\n<line46>indicator_style = file_type;\n<line47>break;\n<line48>case 'g':\n<line49>format_opt = long_format;\n<line50>print_owner = false;\n<line51>break;\n<line52>case 'h':\n<line53>file_human_output_opts = human_output_opts =\n<line54>human_autoscale | human_SI | human_base_1024;\n<line55>file_output_block_size = output_block_size = 1;\n<line56>break;\n<line57>case 'i':\n<line58>print_inode = true;\n<line59>break;\n<line60>case 'k':\n<line61>kibibytes_specified = true;\n<line62>break;\n<line63>case 'l':\n<line64>format_opt = long_format;\n<line65>break;\n<line66>case 'm':\n<line67>format_opt = with_commas;\n<line68>break;\n<line69>case 'n':\n<line70>numeric_ids = true;\n<line71>format_opt = long_format;\n<line72>break;\n<line73>case 'o':  /* Just like -l, but don't display group info.  */\n<line74>format_opt = long_format;\n<line75>print_group = false;\n<line76>break;\n<line77>case 'p':\n<line78>indicator_style = slash;\n<line79>break;\n<line80>case 'q':\n<line81>hide_control_chars_opt = true;\n<line82>break;\n<line83>case 'r':\n<line84>sort_reverse = true;\n<line85>break;\n<line86>case 's':\n<line87>print_block_size = true;\n<line88>break;\n<line89>case 't':\n<line90>sort_opt = sort_time;\n<line91>break;\n<line92>case 'u':\n<line93>time_type = time_atime;\n<line94>break;\n<line95>case 'v':\n<line96>sort_opt = sort_version;\n<line97>break;\n<line98>case 'w':\n<line99>width_opt = decode_line_length (optarg);\n<line100>if (width_opt < 0)\n<line101>error (LS_FAILURE, 0, "%s: %s", _("invalid line width"),\n<line102>quote (optarg));\n<line103>break;\n<line104>case 'x':\n<line105>format_opt = horizontal;\n<line106>break;\n<line107>case 'A':\n<line108>ignore_mode = IGNORE_DOT_AND_DOTDOT;\n<line109>break;\n<line110>case 'B':\n<line111>add_ignore_pattern ("*~");\n<line112>add_ignore_pattern (".*~");\n<line113>break;\n<line114>case 'C':\n<line115>format_opt = many_per_line;\n<line116>break;\n<line117>case 'D':\n<line118>dired = true;\n<line119>break;\n<line120>case 'F':\n<line121>{\n<line122>int i;\n<line123>if (optarg)\n<line124>i = XARGMATCH ("--classify", optarg, when_args, when_types);\n<line125>else\n<line126>/* Using --classify with no argument is equivalent to using\n<line127>--classify=always.  */\n<line128>i = when_always;\n<line129>if (i == when_always || (i == when_if_tty && stdout_isatty ()))\n<line130>indicator_style = classify;\n<line131>break;\n<line132>}\n<line133>case 'G':		/* inhibit display of group info */\n<line134>print_group = false;\n<line135>break;\n<line136>case 'H':\n<line137>dereference = DEREF_COMMAND_LINE_ARGUMENTS;\n<line138>break;\n<line139>case DEREFERENCE_COMMAND_LINE_SYMLINK_TO_DIR_OPTION:\n<line140>dereference = DEREF_COMMAND_LINE_SYMLINK_TO_DIR;\n<line141>break;\n<line142>case 'I':\n<line143>add_ignore_pattern (optarg);\n<line144>break;\n<line145>case 'L':\n<line146>dereference = DEREF_ALWAYS;\n<line147>break;\n<line148>case 'N':\n<line149>quoting_style_opt = literal_quoting_style;\n<line150>break;\n<line151>case 'Q':\n<line152>quoting_style_opt = c_quoting_style;\n<line153>break;\n<line154>case 'R':\n<line155>recursive = true;\n<line156>break;\n<line157>case 'S':\n<line158>sort_opt = sort_size;\n<line159>break;\n<line160>case 'T':\n<line161>tabsize_opt = xnumtoumax (optarg, 0, 0, MIN (PTRDIFF_MAX, SIZE_MAX),\n<line162>"", _("invalid tab size"), LS_FAILURE);\n<line163>break;\n<line164>case 'U':\n<line165>sort_opt = sort_none;\n<line166>break;\n<line167>case 'X':\n<line168>sort_opt = sort_extension;\n<line169>break;\n<line170>case '1':\n<line171>/* -1 has no effect after -l.  */\n<line172>if (format_opt != long_format)\n<line173>format_opt = one_per_line;\n<line174>break;\n<line175>case AUTHOR_OPTION:\n<line176>print_author = true;\n<line177>break;\n<line178>case HIDE_OPTION:\n<line179>{\n<line180>struct ignore_pattern *hide = xmalloc (sizeof *hide);\n<line181>hide->pattern = optarg;\n<line182>hide->next = hide_patterns;\n<line183>hide_patterns = hide;\n<line184>}\n<line185>break;\n<line186>case SORT_OPTION:\n<line187>sort_opt = XARGMATCH ("--sort", optarg, sort_args, sort_types);\n<line188>break;\n<line189>case GROUP_DIRECTORIES_FIRST_OPTION:\n<line190>directories_first = true;\n<line191>break;\n<line192>case TIME_OPTION:\n<line193>time_type = XARGMATCH ("--time", optarg, time_args, time_types);\n<line194>break;\n<line195>case FORMAT_OPTION:\n<line196>format_opt = XARGMATCH ("--format", optarg, format_args,\n<line197>format_types);\n<line198>break;\n<line199>case FULL_TIME_OPTION:\n<line200>format_opt = long_format;\n<line201>time_style_option = bad_cast ("full-iso");\n<line202>break;\n<line203>case COLOR_OPTION:\n<line204>{\n<line205>int i;\n<line206>if (optarg)\n<line207>i = XARGMATCH ("--color", optarg, when_args, when_types);\n<line208>else\n<line209>/* Using --color with no argument is equivalent to using\n<line210>--color=always.  */\n<line211>i = when_always;\n<line212>print_with_color = (i == when_always\n<line213>|| (i == when_if_tty && stdout_isatty ()));\n<line214>break;\n<line215>}\n<line216>case HYPERLINK_OPTION:\n<line217>{\n<line218>int i;\n<line219>if (optarg)\n<line220>i = XARGMATCH ("--hyperlink", optarg, when_args, when_types);\n<line221>else\n<line222>/* Using --hyperlink with no argument is equivalent to using\n<line223>--hyperlink=always.  */\n<line224>i = when_always;\n<line225>print_hyperlink = (i == when_always\n<line226>|| (i == when_if_tty && stdout_isatty ()));\n<line227>break;\n<line228>}\n<line229>case INDICATOR_STYLE_OPTION:\n<line230>indicator_style = XARGMATCH ("--indicator-style", optarg,\n<line231>indicator_style_args,\n<line232>indicator_style_types);\n<line233>break;\n<line234>case QUOTING_STYLE_OPTION:\n<line235>quoting_style_opt = XARGMATCH ("--quoting-style", optarg,\n<line236>quoting_style_args,\n<line237>quoting_style_vals);\n<line238>break;\n<line239>case TIME_STYLE_OPTION:\n<line240>time_style_option = optarg;\n<line241>break;\n<line242>case SHOW_CONTROL_CHARS_OPTION:\n<line243>hide_control_chars_opt = false;\n<line244>break;\n<line245>case BLOCK_SIZE_OPTION:\n<line246>{\n<line247>enum strtol_error e = human_options (optarg, &human_output_opts,\n<line248>&output_block_size);\n<line249>if (e != LONGINT_OK)\n<line250>xstrtol_fatal (e, oi, 0, long_options, optarg);\n<line251>file_human_output_opts = human_output_opts;\n<line252>file_output_block_size = output_block_size;\n<line253>}\n<line254>break;\n<line255>case SI_OPTION:\n<line256>file_human_output_opts = human_output_opts =\n<line257>human_autoscale | human_SI;\n<line258>file_output_block_size = output_block_size = 1;\n<line259>break;\n<line260>case 'Z':\n<line261>print_scontext = true;\n<line262>break;\n<line263>case ZERO_OPTION:\n<line264>eolbyte = 0;\n<line265>hide_control_chars_opt = false;\n<line266>if (format_opt != long_format)\n<line267>format_opt = one_per_line;\n<line268>print_with_color = false;\n<line269>quoting_style_opt = literal_quoting_style;\n<line270>break;\n<line271>case_GETOPT_HELP_CHAR;\n<line272>case_GETOPT_VERSION_CHAR (PROGRAM_NAME, AUTHORS);\n<line273>default:\n<line274>usage (LS_FAILURE);\n<line275>}\n<line276>}\n<line277>if (! output_block_size)\n<line278>{\n<line279>char const *ls_block_size = getenv ("LS_BLOCK_SIZE");\n<line280>human_options (ls_block_size,\n<line281>&human_output_opts, &output_block_size);\n<line282>if (ls_block_size || getenv ("BLOCK_SIZE"))\n<line283>{\n<line284>file_human_output_opts = human_output_opts;\n<line285>file_output_block_size = output_block_size;\n<line286>}\n<line287>if (kibibytes_specified)\n<line288>{\n<line289>human_output_opts = 0;\n<line290>output_block_size = 1024;\n<line291>}\n<line292>}\n<line293>format = (0 <= format_opt ? format_opt\n<line294>: ls_mode == LS_LS ? (stdout_isatty ()\n<line295>? many_per_line : one_per_line)\n<line296>: ls_mode == LS_MULTI_COL ? many_per_line\n<line297>: /* ls_mode == LS_LONG_FORMAT */ long_format);\n<line298>/* If the line length was not set by a switch but is needed to determine\n<line299>output, go to the work of obtaining it from the environment.  */\n<line300>ptrdiff_t linelen = width_opt;\n<line301>if (format == many_per_line || format == horizontal || format == with_commas\n<line302>|| print_with_color)\n<line303>{\n<line304>#ifdef TIOCGWINSZ\n<line305>if (linelen < 0)\n<line306>{\n<line307>/* Suppress bogus warning re comparing ws.ws_col to big integer.  */\n<line308># if 4 < __GNUC__ + (6 <= __GNUC_MINOR__)\n<line309>#  pragma GCC diagnostic push\n<line310>#  pragma GCC diagnostic ignored "-Wtype-limits"\n<line311># endif\n<line312>struct winsize ws;\n<line313>if (stdout_isatty ()\n<line314>&& 0 <= ioctl (STDOUT_FILENO, TIOCGWINSZ, &ws)\n<line315>&& 0 < ws.ws_col)\n<line316>linelen = ws.ws_col <= MIN (PTRDIFF_MAX, SIZE_MAX) ? ws.ws_col : 0;\n<line317># if 4 < __GNUC__ + (6 <= __GNUC_MINOR__)\n<line318>#  pragma GCC diagnostic pop\n<line319># endif\n<line320>}\n<line321>#endif\n<line322>if (linelen < 0)\n<line323>{\n<line324>char const *p = getenv ("COLUMNS");\n<line325>if (p && *p)\n<line326>{\n<line327>linelen = decode_line_length (p);\n<line328>if (linelen < 0)\n<line329>error (0, 0,\n<line330>_("ignoring invalid width"\n<line331>" in environment variable COLUMNS: %s"),\n<line332>quote (p));\n<line333>}\n<line334>}\n<line335>}\n<line336>line_length = linelen < 0 ? 80 : linelen;\n<line337>/* Determine the max possible number of display columns.  */\n<line338>max_idx = line_length / MIN_COLUMN_WIDTH;\n<line339>/* Account for first display column not having a separator,\n<line340>or line_lengths shorter than MIN_COLUMN_WIDTH.  */\n<line341>max_idx += line_length % MIN_COLUMN_WIDTH != 0;\n<line342>if (format == many_per_line || format == horizontal || format == with_commas)\n<line343>{\n<line344>if (0 <= tabsize_opt)\n<line345>tabsize = tabsize_opt;\n<line346>else\n<line347>{\n<line348>tabsize = 8;\n<line349>char const *p = getenv ("TABSIZE");\n<line350>if (p)\n<line351>{\n<line352>uintmax_t tmp;\n<line353>if (xstrtoumax (p, nullptr, 0, &tmp, "") == LONGINT_OK\n<line354>&& tmp <= SIZE_MAX)\n<line355>tabsize = tmp;\n<line356>else\n<line357>error (0, 0,\n<line358>_("ignoring invalid tab size"\n<line359>" in environment variable TABSIZE: %s"),\n<line360>quote (p));\n<line361>}\n<line362>}\n<line363>}\n<line364>qmark_funny_chars = (hide_control_chars_opt < 0\n<line365>? ls_mode == LS_LS && stdout_isatty ()\n<line366>: hide_control_chars_opt);\n<line367>int qs = quoting_style_opt;\n<line368>if (qs < 0)\n<line369>qs = getenv_quoting_style ();\n<line370>if (qs < 0)\n<line371>qs = (ls_mode == LS_LS\n<line372>? (stdout_isatty () ? shell_escape_quoting_style : -1)\n<line373>: escape_quoting_style);\n<line374>if (0 <= qs)\n<line375>set_quoting_style (nullptr, qs);\n<line376>qs = get_quoting_style (nullptr);\n<line377>align_variable_outer_quotes\n<line378>= ((format == long_format\n<line379>|| ((format == many_per_line || format == horizontal) && line_length))\n<line380>&& (qs == shell_quoting_style\n<line381>|| qs == shell_escape_quoting_style\n<line382>|| qs == c_maybe_quoting_style));\n<line383>filename_quoting_options = clone_quoting_options (nullptr);\n<line384>if (qs == escape_quoting_style)\n<line385>set_char_quoting (filename_quoting_options, ' ', 1);\n<line386>if (file_type <= indicator_style)\n<line387>{\n<line388>char const *p;\n<line389>for (p = &"*=>@|"[indicator_style - file_type]; *p; p++)\n<line390>set_char_quoting (filename_quoting_options, *p, 1);\n<line391>}\n<line392>dirname_quoting_options = clone_quoting_options (nullptr);\n<line393>set_char_quoting (dirname_quoting_options, ':', 1);\n<line394>/* --dired is meaningful only with --format=long (-l) and sans --hyperlink.\n<line395>Otherwise, ignore it.  FIXME: warn about this?\n<line396>Alternatively, make --dired imply --format=long?  */\n<line397>dired &= (format == long_format) & !print_hyperlink;\n<line398>if (eolbyte < dired)\n<line399>error (LS_FAILURE, 0, _("--dired and --zero are incompatible"));\n<line400>/* If -c or -u is specified and not -l (or any other option that implies -l),\n<line401>and no sort-type was specified, then sort by the ctime (-c) or atime (-u).\n<line402>The behavior of ls when using either -c or -u but with neither -l nor -t\n<line403>appears to be unspecified by POSIX.  So, with GNU ls, '-u' alone means\n<line404>sort by atime (this is the one that's not specified by the POSIX spec),\n<line405>-lu means show atime and sort by name, -lut means show atime and sort\n<line406>by atime.  */\n<line407>sort_type = (0 <= sort_opt ? sort_opt\n<line408>: (format != long_format\n<line409>&& (time_type == time_ctime || time_type == time_atime\n<line410>|| time_type == time_btime))\n<line411>? sort_time : sort_name);\n<line412>if (format == long_format)\n<line413>{\n<line414>char *style = time_style_option;\n<line415>static char const posix_prefix[] = "posix-";\n<line416>if (! style)\n<line417>if (! (style = getenv ("TIME_STYLE")))\n<line418>style = bad_cast ("locale");\n<line419>while (STREQ_LEN (style, posix_prefix, sizeof posix_prefix - 1))\n<line420>{\n<line421>if (! hard_locale (LC_TIME))\n<line422>return optind;\n<line423>style += sizeof posix_prefix - 1;\n<line424>}\n<line425>if (*style == '+')\n<line426>{\n<line427>char *p0 = style + 1;\n<line428>char *p1 = strchr (p0, '\n');\n<line429>if (! p1)\n<line430>p1 = p0;\n<line431>else\n<line432>{\n<line433>if (strchr (p1 + 1, '\n'))\n<line434>error (LS_FAILURE, 0, _("invalid time style format %s"),\n<line435>quote (p0));\n<line436>*p1++ = '\0';\n<line437>}\n<line438>long_time_format[0] = p0;\n<line439>long_time_format[1] = p1;\n<line440>}\n<line441>else\n<line442>{\n<line443>ptrdiff_t res = argmatch (style, time_style_args,\n<line444>(char const *) time_style_types,\n<line445>sizeof (*time_style_types));\n<line446>if (res < 0)\n<line447>{\n<line448>/* This whole block used to be a simple use of XARGMATCH.\n<line449>but that didn't print the "posix-"-prefixed variants or\n<line450>the "+"-prefixed format string option upon failure.  */\n<line451>argmatch_invalid ("time style", style, res);\n<line452>/* The following is a manual expansion of argmatch_valid,\n<line453>but with the added "+ ..." description and the [posix-]\n<line454>prefixes prepended.  Note that this simplification works\n<line455>only because all four existing time_style_types values\n<line456>are distinct.  */\n<line457>fputs (_("Valid arguments are:\n"), stderr);\n<line458>char const *const *p = time_style_args;\n<line459>while (*p)\n<line460>fprintf (stderr, "  - [posix-]%s\n", *p++);\n<line461>fputs (_("  - +FORMAT (e.g., +%H:%M) for a 'date'-style"\n<line462>" format\n"), stderr);\n<line463>usage (LS_FAILURE);\n<line464>}\n<line465>switch (res)\n<line466>{\n<line467>case full_iso_time_style:\n<line468>long_time_format[0] = long_time_format[1] =\n<line469>"%Y-%m-%d %H:%M:%S.%N %z";\n<line470>break;\n<line471>case long_iso_time_style:\n<line472>long_time_format[0] = long_time_format[1] = "%Y-%m-%d %H:%M";\n<line473>break;\n<line474>case iso_time_style:\n<line475>long_time_format[0] = "%Y-%m-%d ";\n<line476>long_time_format[1] = "%m-%d %H:%M";\n<line477>break;\n<line478>case locale_time_style:\n<line479>if (hard_locale (LC_TIME))\n<line480>{\n<line481>for (int i = 0; i < 2; i++)\n<line482>long_time_format[i] =\n<line483>dcgettext (nullptr, long_time_format[i], LC_TIME);\n<line484>}\n<line485>}\n<line486>}\n<line487>abformat_init ();\n<line488>}\n<line489>return optind;\n<line490>}
----------------------------------------
Function: get_funky_string
Content: <line0>static bool\n<line1>get_funky_string (char **dest, char const **src, bool equals_end,\n<line2>size_t *output_count)\n<line3>{\n<line4>char num;			/* For numerical codes */\n<line5>size_t count;			/* Something to count with */\n<line6>enum {\n<line7>ST_GND, ST_BACKSLASH, ST_OCTAL, ST_HEX, ST_CARET, ST_END, ST_ERROR\n<line8>} state;\n<line9>char const *p;\n<line10>char *q;\n<line11>p = *src;			/* We don't want to double-indirect */\n<line12>q = *dest;			/* the whole darn time.  */\n<line13>count = 0;			/* No characters counted in yet.  */\n<line14>num = 0;\n<line15>state = ST_GND;		/* Start in ground state.  */\n<line16>while (state < ST_END)\n<line17>{\n<line18>switch (state)\n<line19>{\n<line20>case ST_GND:		/* Ground state (no escapes) */\n<line21>switch (*p)\n<line22>{\n<line23>case ':':\n<line24>case '\0':\n<line25>state = ST_END;	/* End of string */\n<line26>break;\n<line27>case '\\':\n<line28>state = ST_BACKSLASH; /* Backslash escape sequence */\n<line29>++p;\n<line30>break;\n<line31>case '^':\n<line32>state = ST_CARET; /* Caret escape */\n<line33>++p;\n<line34>break;\n<line35>case '=':\n<line36>if (equals_end)\n<line37>{\n<line38>state = ST_END; /* End */\n<line39>break;\n<line40>}\n<line41>FALLTHROUGH;\n<line42>default:\n<line43>*(q++) = *(p++);\n<line44>++count;\n<line45>break;\n<line46>}\n<line47>break;\n<line48>case ST_BACKSLASH:	/* Backslash escaped character */\n<line49>switch (*p)\n<line50>{\n<line51>case '0':\n<line52>case '1':\n<line53>case '2':\n<line54>case '3':\n<line55>case '4':\n<line56>case '5':\n<line57>case '6':\n<line58>case '7':\n<line59>state = ST_OCTAL;	/* Octal sequence */\n<line60>num = *p - '0';\n<line61>break;\n<line62>case 'x':\n<line63>case 'X':\n<line64>state = ST_HEX;	/* Hex sequence */\n<line65>num = 0;\n<line66>break;\n<line67>case 'a':		/* Bell */\n<line68>num = '\a';\n<line69>break;\n<line70>case 'b':		/* Backspace */\n<line71>num = '\b';\n<line72>break;\n<line73>case 'e':		/* Escape */\n<line74>num = 27;\n<line75>break;\n<line76>case 'f':		/* Form feed */\n<line77>num = '\f';\n<line78>break;\n<line79>case 'n':		/* Newline */\n<line80>num = '\n';\n<line81>break;\n<line82>case 'r':		/* Carriage return */\n<line83>num = '\r';\n<line84>break;\n<line85>case 't':		/* Tab */\n<line86>num = '\t';\n<line87>break;\n<line88>case 'v':		/* Vtab */\n<line89>num = '\v';\n<line90>break;\n<line91>case '?':		/* Delete */\n<line92>num = 127;\n<line93>break;\n<line94>case '_':		/* Space */\n<line95>num = ' ';\n<line96>break;\n<line97>case '\0':		/* End of string */\n<line98>state = ST_ERROR;	/* Error! */\n<line99>break;\n<line100>default:		/* Escaped character like \ ^ : = */\n<line101>num = *p;\n<line102>break;\n<line103>}\n<line104>if (state == ST_BACKSLASH)\n<line105>{\n<line106>*(q++) = num;\n<line107>++count;\n<line108>state = ST_GND;\n<line109>}\n<line110>++p;\n<line111>break;\n<line112>case ST_OCTAL:		/* Octal sequence */\n<line113>if (*p < '0' || *p > '7')\n<line114>{\n<line115>*(q++) = num;\n<line116>++count;\n<line117>state = ST_GND;\n<line118>}\n<line119>else\n<line120>num = (num << 3) + (*(p++) - '0');\n<line121>break;\n<line122>case ST_HEX:		/* Hex sequence */\n<line123>switch (*p)\n<line124>{\n<line125>case '0':\n<line126>case '1':\n<line127>case '2':\n<line128>case '3':\n<line129>case '4':\n<line130>case '5':\n<line131>case '6':\n<line132>case '7':\n<line133>case '8':\n<line134>case '9':\n<line135>num = (num << 4) + (*(p++) - '0');\n<line136>break;\n<line137>case 'a':\n<line138>case 'b':\n<line139>case 'c':\n<line140>case 'd':\n<line141>case 'e':\n<line142>case 'f':\n<line143>num = (num << 4) + (*(p++) - 'a') + 10;\n<line144>break;\n<line145>case 'A':\n<line146>case 'B':\n<line147>case 'C':\n<line148>case 'D':\n<line149>case 'E':\n<line150>case 'F':\n<line151>num = (num << 4) + (*(p++) - 'A') + 10;\n<line152>break;\n<line153>default:\n<line154>*(q++) = num;\n<line155>++count;\n<line156>state = ST_GND;\n<line157>break;\n<line158>}\n<line159>break;\n<line160>case ST_CARET:		/* Caret escape */\n<line161>state = ST_GND;	/* Should be the next state... */\n<line162>if (*p >= '@' && *p <= '~')\n<line163>{\n<line164>*(q++) = *(p++) & 037;\n<line165>++count;\n<line166>}\n<line167>else if (*p == '?')\n<line168>{\n<line169>*(q++) = 127;\n<line170>++count;\n<line171>}\n<line172>else\n<line173>state = ST_ERROR;\n<line174>break;\n<line175>default:\n<line176>unreachable ();\n<line177>}\n<line178>}\n<line179>*dest = q;\n<line180>*src = p;\n<line181>*output_count = count;\n<line182>return state != ST_ERROR;\n<line183>}
----------------------------------------
Function: known_term_type
Content: <line0>static bool\n<line1>known_term_type (void)\n<line2>{\n<line3>char const *term = getenv ("TERM");\n<line4>if (! term || ! *term)\n<line5>return false;\n<line6>char const *line = G_line;\n<line7>while (line - G_line < sizeof (G_line))\n<line8>{\n<line9>if (STRNCMP_LIT (line, "TERM ") == 0)\n<line10>{\n<line11>if (fnmatch (line + 5, term, 0) == 0)\n<line12>return true;\n<line13>}\n<line14>line += strlen (line) + 1;\n<line15>}\n<line16>return false;\n<line17>}
----------------------------------------
Function: parse_ls_color
Content: <line0>static void\n<line1>parse_ls_color (void)\n<line2>{\n<line3>char const *p;		/* Pointer to character being parsed */\n<line4>char *buf;			/* color_buf buffer pointer */\n<line5>int ind_no;			/* Indicator number */\n<line6>char label[3];		/* Indicator label */\n<line7>struct color_ext_type *ext;	/* Extension we are working on */\n<line8>if ((p = getenv ("LS_COLORS")) == nullptr || *p == '\0')\n<line9>{\n<line10>/* LS_COLORS takes precedence, but if that's not set then\n<line11>honor the COLORTERM and TERM env variables so that\n<line12>we only go with the internal ANSI color codes if the\n<line13>former is non empty or the latter is set to a known value.  */\n<line14>char const *colorterm = getenv ("COLORTERM");\n<line15>if (! (colorterm && *colorterm) && ! known_term_type ())\n<line16>print_with_color = false;\n<line17>return;\n<line18>}\n<line19>ext = nullptr;\n<line20>strcpy (label, "??");\n<line21>/* This is an overly conservative estimate, but any possible\n<line22>LS_COLORS string will *not* generate a color_buf longer than\n<line23>itself, so it is a safe way of allocating a buffer in\n<line24>advance.  */\n<line25>buf = color_buf = xstrdup (p);\n<line26>enum parse_state state = PS_START;\n<line27>while (true)\n<line28>{\n<line29>switch (state)\n<line30>{\n<line31>case PS_START:		/* First label character */\n<line32>switch (*p)\n<line33>{\n<line34>case ':':\n<line35>++p;\n<line36>break;\n<line37>case '*':\n<line38>/* Allocate new extension block and add to head of\n<line39>linked list (this way a later definition will\n<line40>override an earlier one, which can be useful for\n<line41>having terminal-specific defs override global).  */\n<line42>ext = xmalloc (sizeof *ext);\n<line43>ext->next = color_ext_list;\n<line44>color_ext_list = ext;\n<line45>ext->exact_match = false;\n<line46>++p;\n<line47>ext->ext.string = buf;\n<line48>state = (get_funky_string (&buf, &p, true, &ext->ext.len)\n<line49>? PS_4 : PS_FAIL);\n<line50>break;\n<line51>case '\0':\n<line52>state = PS_DONE;	/* Done! */\n<line53>goto done;\n<line54>default:	/* Assume it is file type label */\n<line55>label[0] = *(p++);\n<line56>state = PS_2;\n<line57>break;\n<line58>}\n<line59>break;\n<line60>case PS_2:		/* Second label character */\n<line61>if (*p)\n<line62>{\n<line63>label[1] = *(p++);\n<line64>state = PS_3;\n<line65>}\n<line66>else\n<line67>state = PS_FAIL;	/* Error */\n<line68>break;\n<line69>case PS_3:		/* Equal sign after indicator label */\n<line70>state = PS_FAIL;	/* Assume failure...  */\n<line71>if (*(p++) == '=')/* It *should* be...  */\n<line72>{\n<line73>for (ind_no = 0; indicator_name[ind_no] != nullptr; ++ind_no)\n<line74>{\n<line75>if (STREQ (label, indicator_name[ind_no]))\n<line76>{\n<line77>color_indicator[ind_no].string = buf;\n<line78>state = (get_funky_string (&buf, &p, false,\n<line79>&color_indicator[ind_no].len)\n<line80>? PS_START : PS_FAIL);\n<line81>break;\n<line82>}\n<line83>}\n<line84>if (state == PS_FAIL)\n<line85>error (0, 0, _("unrecognized prefix: %s"), quote (label));\n<line86>}\n<line87>break;\n<line88>case PS_4:		/* Equal sign after *.ext */\n<line89>if (*(p++) == '=')\n<line90>{\n<line91>ext->seq.string = buf;\n<line92>state = (get_funky_string (&buf, &p, false, &ext->seq.len)\n<line93>? PS_START : PS_FAIL);\n<line94>}\n<line95>else\n<line96>state = PS_FAIL;\n<line97>break;\n<line98>case PS_FAIL:\n<line99>goto done;\n<line100>default:\n<line101>affirm (false);\n<line102>}\n<line103>}\n<line104>done:\n<line105>if (state == PS_FAIL)\n<line106>{\n<line107>struct color_ext_type *e;\n<line108>struct color_ext_type *e2;\n<line109>error (0, 0,\n<line110>_("unparsable value for LS_COLORS environment variable"));\n<line111>free (color_buf);\n<line112>for (e = color_ext_list; e != nullptr; /* empty */)\n<line113>{\n<line114>e2 = e;\n<line115>e = e->next;\n<line116>free (e2);\n<line117>}\n<line118>print_with_color = false;\n<line119>}\n<line120>else\n<line121>{\n<line122>/* Postprocess list to set EXACT_MATCH on entries where there are\n<line123>different cased extensions with separate sequences defined.\n<line124>Also set ext.len to SIZE_MAX on any entries that can't\n<line125>match due to precedence, to avoid redundant string compares.  */\n<line126>struct color_ext_type *e1;\n<line127>for (e1 = color_ext_list; e1 != nullptr; e1 = e1->next)\n<line128>{\n<line129>struct color_ext_type *e2;\n<line130>bool case_ignored = false;\n<line131>for (e2 = e1->next; e2 != nullptr; e2 = e2->next)\n<line132>{\n<line133>if (e2->ext.len < SIZE_MAX && e1->ext.len == e2->ext.len)\n<line134>{\n<line135>if (memcmp (e1->ext.string, e2->ext.string, e1->ext.len) == 0)\n<line136>e2->ext.len = SIZE_MAX; /* Ignore */\n<line137>else if (c_strncasecmp (e1->ext.string, e2->ext.string,\n<line138>e1->ext.len) == 0)\n<line139>{\n<line140>if (case_ignored)\n<line141>{\n<line142>e2->ext.len = SIZE_MAX; /* Ignore */\n<line143>}\n<line144>else if (e1->seq.len == e2->seq.len\n<line145>&& memcmp (e1->seq.string, e2->seq.string,\n<line146>e1->seq.len) == 0)\n<line147>{\n<line148>e2->ext.len = SIZE_MAX; /* Ignore */\n<line149>case_ignored = true;    /* Ignore all subsequent */\n<line150>}\n<line151>else\n<line152>{\n<line153>e1->exact_match = true;\n<line154>e2->exact_match = true;\n<line155>}\n<line156>}\n<line157>}\n<line158>}\n<line159>}\n<line160>}\n<line161>if (color_indicator[C_LINK].len == 6\n<line162>&& !STRNCMP_LIT (color_indicator[C_LINK].string, "target"))\n<line163>color_symlink_as_referent = true;\n<line164>}
----------------------------------------
Function: getenv_quoting_style
Content: <line0>static int\n<line1>getenv_quoting_style (void)\n<line2>{\n<line3>char const *q_style = getenv ("QUOTING_STYLE");\n<line4>if (!q_style)\n<line5>return -1;\n<line6>int i = ARGMATCH (q_style, quoting_style_args, quoting_style_vals);\n<line7>if (i < 0)\n<line8>{\n<line9>error (0, 0,\n<line10>_("ignoring invalid value"\n<line11>" of environment variable QUOTING_STYLE: %s"),\n<line12>quote (q_style));\n<line13>return -1;\n<line14>}\n<line15>return quoting_style_vals[i];\n<line16>}
----------------------------------------
Function: set_exit_status
Content: <line0>static void\n<line1>set_exit_status (bool serious)\n<line2>{\n<line3>if (serious)\n<line4>exit_status = LS_FAILURE;\n<line5>else if (exit_status == EXIT_SUCCESS)\n<line6>exit_status = LS_MINOR_PROBLEM;\n<line7>}
----------------------------------------
Function: file_failure
Content: <line0>static void\n<line1>file_failure (bool serious, char const *message, char const *file)\n<line2>{\n<line3>error (0, errno, message, quoteaf (file));\n<line4>set_exit_status (serious);\n<line5>}
----------------------------------------
Function: queue_directory
Content: <line0>static void\n<line1>queue_directory (char const *name, char const *realname, bool command_line_arg)\n<line2>{\n<line3>struct pending *new = xmalloc (sizeof *new);\n<line4>new->realname = realname ? xstrdup (realname) : nullptr;\n<line5>new->name = name ? xstrdup (name) : nullptr;\n<line6>new->command_line_arg = command_line_arg;\n<line7>new->next = pending_dirs;\n<line8>pending_dirs = new;\n<line9>}
----------------------------------------
Function: print_dir
Content: <line0>static void\n<line1>print_dir (char const *name, char const *realname, bool command_line_arg)\n<line2>{\n<line3>DIR *dirp;\n<line4>struct dirent *next;\n<line5>uintmax_t total_blocks = 0;\n<line6>static bool first = true;\n<line7>errno = 0;\n<line8>dirp = opendir (name);\n<line9>if (!dirp)\n<line10>{\n<line11>file_failure (command_line_arg, _("cannot open directory %s"), name);\n<line12>return;\n<line13>}\n<line14>if (LOOP_DETECT)\n<line15>{\n<line16>struct stat dir_stat;\n<line17>int fd = dirfd (dirp);\n<line18>/* If dirfd failed, endure the overhead of stat'ing by path  */\n<line19>if ((0 <= fd\n<line20>? fstat_for_ino (fd, &dir_stat)\n<line21>: stat_for_ino (name, &dir_stat)) < 0)\n<line22>{\n<line23>file_failure (command_line_arg,\n<line24>_("cannot determine device and inode of %s"), name);\n<line25>closedir (dirp);\n<line26>return;\n<line27>}\n<line28>/* If we've already visited this dev/inode pair, warn that\n<line29>we've found a loop, and do not process this directory.  */\n<line30>if (visit_dir (dir_stat.st_dev, dir_stat.st_ino))\n<line31>{\n<line32>error (0, 0, _("%s: not listing already-listed directory"),\n<line33>quotef (name));\n<line34>closedir (dirp);\n<line35>set_exit_status (true);\n<line36>return;\n<line37>}\n<line38>dev_ino_push (dir_stat.st_dev, dir_stat.st_ino);\n<line39>}\n<line40>clear_files ();\n<line41>if (recursive || print_dir_name)\n<line42>{\n<line43>if (!first)\n<line44>dired_outbyte ('\n');\n<line45>first = false;\n<line46>dired_indent ();\n<line47>char *absolute_name = nullptr;\n<line48>if (print_hyperlink)\n<line49>{\n<line50>absolute_name = canonicalize_filename_mode (name, CAN_MISSING);\n<line51>if (! absolute_name)\n<line52>file_failure (command_line_arg,\n<line53>_("error canonicalizing %s"), name);\n<line54>}\n<line55>quote_name (realname ? realname : name, dirname_quoting_options, -1,\n<line56>nullptr, true, &subdired_obstack, absolute_name);\n<line57>free (absolute_name);\n<line58>dired_outstring (":\n");\n<line59>}\n<line60>/* Read the directory entries, and insert the subfiles into the 'cwd_file'\n<line61>table.  */\n<line62>while (true)\n<line63>{\n<line64>/* Set errno to zero so we can distinguish between a readdir failure\n<line65>and when readdir simply finds that there are no more entries.  */\n<line66>errno = 0;\n<line67>next = readdir (dirp);\n<line68>if (next)\n<line69>{\n<line70>if (! file_ignored (next->d_name))\n<line71>{\n<line72>enum filetype type = unknown;\n<line73>#if HAVE_STRUCT_DIRENT_D_TYPE\n<line74>switch (next->d_type)\n<line75>{\n<line76>case DT_BLK:  type = blockdev;		break;\n<line77>case DT_CHR:  type = chardev;		break;\n<line78>case DT_DIR:  type = directory;		break;\n<line79>case DT_FIFO: type = fifo;		break;\n<line80>case DT_LNK:  type = symbolic_link;	break;\n<line81>case DT_REG:  type = normal;		break;\n<line82>case DT_SOCK: type = sock;		break;\n<line83># ifdef DT_WHT\n<line84>case DT_WHT:  type = whiteout;		break;\n<line85># endif\n<line86>}\n<line87>#endif\n<line88>total_blocks += gobble_file (next->d_name, type,\n<line89>RELIABLE_D_INO (next),\n<line90>false, name);\n<line91>/* In this narrow case, print out each name right away, so\n<line92>ls uses constant memory while processing the entries of\n<line93>this directory.  Useful when there are many (millions)\n<line94>of entries in a directory.  */\n<line95>if (format == one_per_line && sort_type == sort_none\n<line96>&& !print_block_size && !recursive)\n<line97>{\n<line98>/* We must call sort_files in spite of\n<line99>"sort_type == sort_none" for its initialization\n<line100>of the sorted_file vector.  */\n<line101>sort_files ();\n<line102>print_current_files ();\n<line103>clear_files ();\n<line104>}\n<line105>}\n<line106>}\n<line107>else if (errno != 0)\n<line108>{\n<line109>file_failure (command_line_arg, _("reading directory %s"), name);\n<line110>if (errno != EOVERFLOW)\n<line111>break;\n<line112>}\n<line113>else\n<line114>break;\n<line115>/* When processing a very large directory, and since we've inhibited\n<line116>interrupts, this loop would take so long that ls would be annoyingly\n<line117>uninterruptible.  This ensures that it handles signals promptly.  */\n<line118>process_signals ();\n<line119>}\n<line120>if (closedir (dirp) != 0)\n<line121>{\n<line122>file_failure (command_line_arg, _("closing directory %s"), name);\n<line123>/* Don't return; print whatever we got.  */\n<line124>}\n<line125>/* Sort the directory contents.  */\n<line126>sort_files ();\n<line127>/* If any member files are subdirectories, perhaps they should have their\n<line128>contents listed rather than being mentioned here as files.  */\n<line129>if (recursive)\n<line130>extract_dirs_from_files (name, false);\n<line131>if (format == long_format || print_block_size)\n<line132>{\n<line133>char buf[LONGEST_HUMAN_READABLE + 3];\n<line134>char *p = human_readable (total_blocks, buf + 1, human_output_opts,\n<line135>ST_NBLOCKSIZE, output_block_size);\n<line136>char *pend = p + strlen (p);\n<line137>*--p = ' ';\n<line138>*pend++ = eolbyte;\n<line139>dired_indent ();\n<line140>dired_outstring (_("total"));\n<line141>dired_outbuf (p, pend - p);\n<line142>}\n<line143>if (cwd_n_used)\n<line144>print_current_files ();\n<line145>}
----------------------------------------
Function: add_ignore_pattern
Content: <line0>static void\n<line1>add_ignore_pattern (char const *pattern)\n<line2>{\n<line3>struct ignore_pattern *ignore;\n<line4>ignore = xmalloc (sizeof *ignore);\n<line5>ignore->pattern = pattern;\n<line6>/* Add it to the head of the linked list.  */\n<line7>ignore->next = ignore_patterns;\n<line8>ignore_patterns = ignore;\n<line9>}
----------------------------------------
Function: patterns_match
Content: <line0>static bool\n<line1>patterns_match (struct ignore_pattern const *patterns, char const *file)\n<line2>{\n<line3>struct ignore_pattern const *p;\n<line4>for (p = patterns; p; p = p->next)\n<line5>if (fnmatch (p->pattern, file, FNM_PERIOD) == 0)\n<line6>return true;\n<line7>return false;\n<line8>}
----------------------------------------
Function: file_ignored
Content: <line0>static bool\n<line1>file_ignored (char const *name)\n<line2>{\n<line3>return ((ignore_mode != IGNORE_MINIMAL\n<line4>&& name[0] == '.'\n<line5>&& (ignore_mode == IGNORE_DEFAULT || ! name[1 + (name[1] == '.')]))\n<line6>|| (ignore_mode == IGNORE_DEFAULT\n<line7>&& patterns_match (hide_patterns, name))\n<line8>|| patterns_match (ignore_patterns, name));\n<line9>}
----------------------------------------
Function: unsigned_file_size
Content: <line0>static uintmax_t\n<line1>unsigned_file_size (off_t size)\n<line2>{\n<line3>return size + (size < 0) * ((uintmax_t) OFF_T_MAX - OFF_T_MIN + 1);\n<line4>}
----------------------------------------
Function: has_capability
Content: <line0>static bool\n<line1>has_capability (MAYBE_UNUSED char const *name)\n<line2>{\n<line3>errno = ENOTSUP;\n<line4>return false;\n<line5>}
----------------------------------------
Function: free_ent
Content: <line0>static void\n<line1>free_ent (struct fileinfo *f)\n<line2>{\n<line3>free (f->name);\n<line4>free (f->linkname);\n<line5>free (f->absolute_name);\n<line6>if (f->scontext != UNKNOWN_SECURITY_CONTEXT)\n<line7>{\n<line8>if (is_smack_enabled ())\n<line9>free (f->scontext);\n<line10>else\n<line11>freecon (f->scontext);\n<line12>}\n<line13>}
----------------------------------------
Function: clear_files
Content: <line0>static void\n<line1>clear_files (void)\n<line2>{\n<line3>for (size_t i = 0; i < cwd_n_used; i++)\n<line4>{\n<line5>struct fileinfo *f = sorted_file[i];\n<line6>free_ent (f);\n<line7>}\n<line8>cwd_n_used = 0;\n<line9>cwd_some_quoted = false;\n<line10>any_has_acl = false;\n<line11>inode_number_width = 0;\n<line12>block_size_width = 0;\n<line13>nlink_width = 0;\n<line14>owner_width = 0;\n<line15>group_width = 0;\n<line16>author_width = 0;\n<line17>scontext_width = 0;\n<line18>major_device_number_width = 0;\n<line19>minor_device_number_width = 0;\n<line20>file_size_width = 0;\n<line21>}
----------------------------------------
Function: errno_unsupported
Content: <line0>static bool\n<line1>errno_unsupported (int err)\n<line2>{\n<line3>return (err == EINVAL || err == ENOSYS || is_ENOTSUP (err));\n<line4>}
----------------------------------------
Function: getfilecon_cache
Content: <line0>static int\n<line1>getfilecon_cache (char const *file, struct fileinfo *f, bool deref)\n<line2>{\n<line3>/* st_dev of the most recently processed device for which we've\n<line4>found that [l]getfilecon fails indicating lack of support.  */\n<line5>static dev_t unsupported_device;\n<line6>if (f->stat.st_dev == unsupported_device)\n<line7>{\n<line8>errno = ENOTSUP;\n<line9>return -1;\n<line10>}\n<line11>int r = 0;\n<line12>#ifdef HAVE_SMACK\n<line13>if (is_smack_enabled ())\n<line14>r = smack_new_label_from_path (file, "security.SMACK64", deref,\n<line15>&f->scontext);\n<line16>else\n<line17>#endif\n<line18>r = (deref\n<line19>? getfilecon (file, &f->scontext)\n<line20>: lgetfilecon (file, &f->scontext));\n<line21>if (r < 0 && errno_unsupported (errno))\n<line22>unsupported_device = f->stat.st_dev;\n<line23>return r;\n<line24>}
----------------------------------------
Function: file_has_acl_cache
Content: <line0>static int\n<line1>file_has_acl_cache (char const *file, struct fileinfo *f)\n<line2>{\n<line3>/* st_dev of the most recently processed device for which we've\n<line4>found that file_has_acl fails indicating lack of support.  */\n<line5>static dev_t unsupported_device;\n<line6>if (f->stat.st_dev == unsupported_device)\n<line7>{\n<line8>errno = ENOTSUP;\n<line9>return 0;\n<line10>}\n<line11>/* Zero errno so that we can distinguish between two 0-returning cases:\n<line12>"has-ACL-support, but only a default ACL" and "no ACL support". */\n<line13>errno = 0;\n<line14>int n = file_has_acl (file, &f->stat);\n<line15>if (n <= 0 && errno_unsupported (errno))\n<line16>unsupported_device = f->stat.st_dev;\n<line17>return n;\n<line18>}
----------------------------------------
Function: has_capability_cache
Content: <line0>static bool\n<line1>has_capability_cache (char const *file, struct fileinfo *f)\n<line2>{\n<line3>/* st_dev of the most recently processed device for which we've\n<line4>found that has_capability fails indicating lack of support.  */\n<line5>static dev_t unsupported_device;\n<line6>if (f->stat.st_dev == unsupported_device)\n<line7>{\n<line8>errno = ENOTSUP;\n<line9>return 0;\n<line10>}\n<line11>bool b = has_capability (file);\n<line12>if ( !b && errno_unsupported (errno))\n<line13>unsupported_device = f->stat.st_dev;\n<line14>return b;\n<line15>}
----------------------------------------
Function: needs_quoting
Content: <line0>static bool\n<line1>needs_quoting (char const *name)\n<line2>{\n<line3>char test[2];\n<line4>size_t len = quotearg_buffer (test, sizeof test , name, -1,\n<line5>filename_quoting_options);\n<line6>return *name != *test || strlen (name) != len;\n<line7>}
----------------------------------------
Function: gobble_file
Content: <line0>static uintmax_t\n<line1>gobble_file (char const *name, enum filetype type, ino_t inode,\n<line2>bool command_line_arg, char const *dirname)\n<line3>{\n<line4>uintmax_t blocks = 0;\n<line5>struct fileinfo *f;\n<line6>/* An inode value prior to gobble_file necessarily came from readdir,\n<line7>which is not used for command line arguments.  */\n<line8>affirm (! command_line_arg || inode == NOT_AN_INODE_NUMBER);\n<line9>if (cwd_n_used == cwd_n_alloc)\n<line10>{\n<line11>cwd_file = xnrealloc (cwd_file, cwd_n_alloc, 2 * sizeof *cwd_file);\n<line12>cwd_n_alloc *= 2;\n<line13>}\n<line14>f = &cwd_file[cwd_n_used];\n<line15>memset (f, '\0', sizeof *f);\n<line16>f->stat.st_ino = inode;\n<line17>f->filetype = type;\n<line18>f->quoted = -1;\n<line19>if ((! cwd_some_quoted) && align_variable_outer_quotes)\n<line20>{\n<line21>/* Determine if any quoted for padding purposes.  */\n<line22>f->quoted = needs_quoting (name);\n<line23>if (f->quoted)\n<line24>cwd_some_quoted = 1;\n<line25>}\n<line26>if (command_line_arg\n<line27>|| print_hyperlink\n<line28>|| format_needs_stat\n<line29>/* When coloring a directory (we may know the type from\n<line30>direct.d_type), we have to stat it in order to indicate\n<line31>sticky and/or other-writable attributes.  */\n<line32>|| (type == directory && print_with_color\n<line33>&& (is_colored (C_OTHER_WRITABLE)\n<line34>|| is_colored (C_STICKY)\n<line35>|| is_colored (C_STICKY_OTHER_WRITABLE)))\n<line36>/* When dereferencing symlinks, the inode and type must come from\n<line37>stat, but readdir provides the inode and type of lstat.  */\n<line38>|| ((print_inode || format_needs_type)\n<line39>&& (type == symbolic_link || type == unknown)\n<line40>&& (dereference == DEREF_ALWAYS\n<line41>|| color_symlink_as_referent || check_symlink_mode))\n<line42>/* Command line dereferences are already taken care of by the above\n<line43>assertion that the inode number is not yet known.  */\n<line44>|| (print_inode && inode == NOT_AN_INODE_NUMBER)\n<line45>|| (format_needs_type\n<line46>&& (type == unknown || command_line_arg\n<line47>/* --indicator-style=classify (aka -F)\n<line48>requires that we stat each regular file\n<line49>to see if it's executable.  */\n<line50>|| (type == normal && (indicator_style == classify\n<line51>/* This is so that --color ends up\n<line52>highlighting files with these mode\n<line53>bits set even when options like -F are\n<line54>not specified.  Note we do a redundant\n<line55>stat in the very unlikely case where\n<line56>C_CAP is set but not the others. */\n<line57>|| (print_with_color\n<line58>&& (is_colored (C_EXEC)\n<line59>|| is_colored (C_SETUID)\n<line60>|| is_colored (C_SETGID)\n<line61>|| is_colored (C_CAP)))\n<line62>)))))\n<line63>{\n<line64>/* Absolute name of this file.  */\n<line65>char *full_name;\n<line66>bool do_deref;\n<line67>int err;\n<line68>if (name[0] == '/' || dirname[0] == 0)\n<line69>full_name = (char *) name;\n<line70>else\n<line71>{\n<line72>full_name = alloca (strlen (name) + strlen (dirname) + 2);\n<line73>attach (full_name, dirname, name);\n<line74>}\n<line75>if (print_hyperlink)\n<line76>{\n<line77>f->absolute_name = canonicalize_filename_mode (full_name,\n<line78>CAN_MISSING);\n<line79>if (! f->absolute_name)\n<line80>file_failure (command_line_arg,\n<line81>_("error canonicalizing %s"), full_name);\n<line82>}\n<line83>switch (dereference)\n<line84>{\n<line85>case DEREF_ALWAYS:\n<line86>err = do_stat (full_name, &f->stat);\n<line87>do_deref = true;\n<line88>break;\n<line89>case DEREF_COMMAND_LINE_ARGUMENTS:\n<line90>case DEREF_COMMAND_LINE_SYMLINK_TO_DIR:\n<line91>if (command_line_arg)\n<line92>{\n<line93>bool need_lstat;\n<line94>err = do_stat (full_name, &f->stat);\n<line95>do_deref = true;\n<line96>if (dereference == DEREF_COMMAND_LINE_ARGUMENTS)\n<line97>break;\n<line98>need_lstat = (err < 0\n<line99>? (errno == ENOENT || errno == ELOOP)\n<line100>: ! S_ISDIR (f->stat.st_mode));\n<line101>if (!need_lstat)\n<line102>break;\n<line103>/* stat failed because of ENOENT || ELOOP, maybe indicating a\n<line104>non-traversable symlink.  Or stat succeeded,\n<line105>FULL_NAME does not refer to a directory,\n<line106>and --dereference-command-line-symlink-to-dir is in effect.\n<line107>Fall through so that we call lstat instead.  */\n<line108>}\n<line109>FALLTHROUGH;\n<line110>default: /* DEREF_NEVER */\n<line111>err = do_lstat (full_name, &f->stat);\n<line112>do_deref = false;\n<line113>break;\n<line114>}\n<line115>if (err != 0)\n<line116>{\n<line117>/* Failure to stat a command line argument leads to\n<line118>an exit status of 2.  For other files, stat failure\n<line119>provokes an exit status of 1.  */\n<line120>file_failure (command_line_arg,\n<line121>_("cannot access %s"), full_name);\n<line122>f->scontext = UNKNOWN_SECURITY_CONTEXT;\n<line123>if (command_line_arg)\n<line124>return 0;\n<line125>f->name = xstrdup (name);\n<line126>cwd_n_used++;\n<line127>return 0;\n<line128>}\n<line129>f->stat_ok = true;\n<line130>/* Note has_capability() adds around 30% runtime to 'ls --color'  */\n<line131>if ((type == normal || S_ISREG (f->stat.st_mode))\n<line132>&& print_with_color && is_colored (C_CAP))\n<line133>f->has_capability = has_capability_cache (full_name, f);\n<line134>if (format == long_format || print_scontext)\n<line135>{\n<line136>bool have_scontext = false;\n<line137>bool have_acl = false;\n<line138>int attr_len = getfilecon_cache (full_name, f, do_deref);\n<line139>err = (attr_len < 0);\n<line140>if (err == 0)\n<line141>{\n<line142>if (is_smack_enabled ())\n<line143>have_scontext = ! STREQ ("_", f->scontext);\n<line144>else\n<line145>have_scontext = ! STREQ ("unlabeled", f->scontext);\n<line146>}\n<line147>else\n<line148>{\n<line149>f->scontext = UNKNOWN_SECURITY_CONTEXT;\n<line150>/* When requesting security context information, don't make\n<line151>ls fail just because the file (even a command line argument)\n<line152>isn't on the right type of file system.  I.e., a getfilecon\n<line153>failure isn't in the same class as a stat failure.  */\n<line154>if (is_ENOTSUP (errno) || errno == ENODATA)\n<line155>err = 0;\n<line156>}\n<line157>if (err == 0 && format == long_format)\n<line158>{\n<line159>int n = file_has_acl_cache (full_name, f);\n<line160>err = (n < 0);\n<line161>have_acl = (0 < n);\n<line162>}\n<line163>f->acl_type = (!have_scontext && !have_acl\n<line164>? ACL_T_NONE\n<line165>: (have_scontext && !have_acl\n<line166>? ACL_T_LSM_CONTEXT_ONLY\n<line167>: ACL_T_YES));\n<line168>any_has_acl |= f->acl_type != ACL_T_NONE;\n<line169>if (err)\n<line170>error (0, errno, "%s", quotef (full_name));\n<line171>}\n<line172>if (S_ISLNK (f->stat.st_mode)\n<line173>&& (format == long_format || check_symlink_mode))\n<line174>{\n<line175>struct stat linkstats;\n<line176>get_link_name (full_name, f, command_line_arg);\n<line177>/* Use the slower quoting path for this entry, though\n<line178>don't update CWD_SOME_QUOTED since alignment not affected.  */\n<line179>if (f->linkname && f->quoted == 0 && needs_quoting (f->linkname))\n<line180>f->quoted = -1;\n<line181>/* Avoid following symbolic links when possible, i.e., when\n<line182>they won't be traced and when no indicator is needed.  */\n<line183>if (f->linkname\n<line184>&& (file_type <= indicator_style || check_symlink_mode)\n<line185>&& stat_for_mode (full_name, &linkstats) == 0)\n<line186>{\n<line187>f->linkok = true;\n<line188>f->linkmode = linkstats.st_mode;\n<line189>}\n<line190>}\n<line191>if (S_ISLNK (f->stat.st_mode))\n<line192>f->filetype = symbolic_link;\n<line193>else if (S_ISDIR (f->stat.st_mode))\n<line194>{\n<line195>if (command_line_arg && !immediate_dirs)\n<line196>f->filetype = arg_directory;\n<line197>else\n<line198>f->filetype = directory;\n<line199>}\n<line200>else\n<line201>f->filetype = normal;\n<line202>blocks = ST_NBLOCKS (f->stat);\n<line203>if (format == long_format || print_block_size)\n<line204>{\n<line205>char buf[LONGEST_HUMAN_READABLE + 1];\n<line206>int len = mbswidth (human_readable (blocks, buf, human_output_opts,\n<line207>ST_NBLOCKSIZE, output_block_size),\n<line208>0);\n<line209>if (block_size_width < len)\n<line210>block_size_width = len;\n<line211>}\n<line212>if (format == long_format)\n<line213>{\n<line214>if (print_owner)\n<line215>{\n<line216>int len = format_user_width (f->stat.st_uid);\n<line217>if (owner_width < len)\n<line218>owner_width = len;\n<line219>}\n<line220>if (print_group)\n<line221>{\n<line222>int len = format_group_width (f->stat.st_gid);\n<line223>if (group_width < len)\n<line224>group_width = len;\n<line225>}\n<line226>if (print_author)\n<line227>{\n<line228>int len = format_user_width (f->stat.st_author);\n<line229>if (author_width < len)\n<line230>author_width = len;\n<line231>}\n<line232>}\n<line233>if (print_scontext)\n<line234>{\n<line235>int len = strlen (f->scontext);\n<line236>if (scontext_width < len)\n<line237>scontext_width = len;\n<line238>}\n<line239>if (format == long_format)\n<line240>{\n<line241>char b[INT_BUFSIZE_BOUND (uintmax_t)];\n<line242>int b_len = strlen (umaxtostr (f->stat.st_nlink, b));\n<line243>if (nlink_width < b_len)\n<line244>nlink_width = b_len;\n<line245>if (S_ISCHR (f->stat.st_mode) || S_ISBLK (f->stat.st_mode))\n<line246>{\n<line247>char buf[INT_BUFSIZE_BOUND (uintmax_t)];\n<line248>int len = strlen (umaxtostr (major (f->stat.st_rdev), buf));\n<line249>if (major_device_number_width < len)\n<line250>major_device_number_width = len;\n<line251>len = strlen (umaxtostr (minor (f->stat.st_rdev), buf));\n<line252>if (minor_device_number_width < len)\n<line253>minor_device_number_width = len;\n<line254>len = major_device_number_width + 2 + minor_device_number_width;\n<line255>if (file_size_width < len)\n<line256>file_size_width = len;\n<line257>}\n<line258>else\n<line259>{\n<line260>char buf[LONGEST_HUMAN_READABLE + 1];\n<line261>uintmax_t size = unsigned_file_size (f->stat.st_size);\n<line262>int len = mbswidth (human_readable (size, buf,\n<line263>file_human_output_opts,\n<line264>1, file_output_block_size),\n<line265>0);\n<line266>if (file_size_width < len)\n<line267>file_size_width = len;\n<line268>}\n<line269>}\n<line270>}\n<line271>if (print_inode)\n<line272>{\n<line273>char buf[INT_BUFSIZE_BOUND (uintmax_t)];\n<line274>int len = strlen (umaxtostr (f->stat.st_ino, buf));\n<line275>if (inode_number_width < len)\n<line276>inode_number_width = len;\n<line277>}\n<line278>f->name = xstrdup (name);\n<line279>cwd_n_used++;\n<line280>return blocks;\n<line281>}
----------------------------------------
Function: is_directory
Content: <line0>static bool\n<line1>is_directory (const struct fileinfo *f)\n<line2>{\n<line3>return f->filetype == directory || f->filetype == arg_directory;\n<line4>}
----------------------------------------
Function: is_linked_directory
Content: <line0>static bool\n<line1>is_linked_directory (const struct fileinfo *f)\n<line2>{\n<line3>return f->filetype == directory || f->filetype == arg_directory\n<line4>|| S_ISDIR (f->linkmode);\n<line5>}
----------------------------------------
Function: get_link_name
Content: <line0>static void\n<line1>get_link_name (char const *filename, struct fileinfo *f, bool command_line_arg)\n<line2>{\n<line3>f->linkname = areadlink_with_size (filename, f->stat.st_size);\n<line4>if (f->linkname == nullptr)\n<line5>file_failure (command_line_arg, _("cannot read symbolic link %s"),\n<line6>filename);\n<line7>}
----------------------------------------
Function: basename_is_dot_or_dotdot
Content: <line0>static bool\n<line1>basename_is_dot_or_dotdot (char const *name)\n<line2>{\n<line3>char const *base = last_component (name);\n<line4>return dot_or_dotdot (base);\n<line5>}
----------------------------------------
Function: extract_dirs_from_files
Content: <line0>static void\n<line1>extract_dirs_from_files (char const *dirname, bool command_line_arg)\n<line2>{\n<line3>size_t i;\n<line4>size_t j;\n<line5>bool ignore_dot_and_dot_dot = (dirname != nullptr);\n<line6>if (dirname && LOOP_DETECT)\n<line7>{\n<line8>/* Insert a marker entry first.  When we dequeue this marker entry,\n<line9>we'll know that DIRNAME has been processed and may be removed\n<line10>from the set of active directories.  */\n<line11>queue_directory (nullptr, dirname, false);\n<line12>}\n<line13>/* Queue the directories last one first, because queueing reverses the\n<line14>order.  */\n<line15>for (i = cwd_n_used; i-- != 0; )\n<line16>{\n<line17>struct fileinfo *f = sorted_file[i];\n<line18>if (is_directory (f)\n<line19>&& (! ignore_dot_and_dot_dot\n<line20>|| ! basename_is_dot_or_dotdot (f->name)))\n<line21>{\n<line22>if (!dirname || f->name[0] == '/')\n<line23>queue_directory (f->name, f->linkname, command_line_arg);\n<line24>else\n<line25>{\n<line26>char *name = file_name_concat (dirname, f->name, nullptr);\n<line27>queue_directory (name, f->linkname, command_line_arg);\n<line28>free (name);\n<line29>}\n<line30>if (f->filetype == arg_directory)\n<line31>free_ent (f);\n<line32>}\n<line33>}\n<line34>/* Now delete the directories from the table, compacting all the remaining\n<line35>entries.  */\n<line36>for (i = 0, j = 0; i < cwd_n_used; i++)\n<line37>{\n<line38>struct fileinfo *f = sorted_file[i];\n<line39>sorted_file[j] = f;\n<line40>j += (f->filetype != arg_directory);\n<line41>}\n<line42>cwd_n_used = j;\n<line43>}
----------------------------------------
Function: xstrcoll
Content: <line0>static int\n<line1>xstrcoll (char const *a, char const *b)\n<line2>{\n<line3>int diff;\n<line4>errno = 0;\n<line5>diff = strcoll (a, b);\n<line6>if (errno)\n<line7>{\n<line8>error (0, errno, _("cannot compare file names %s and %s"),\n<line9>quote_n (0, a), quote_n (1, b));\n<line10>set_exit_status (false);\n<line11>longjmp (failed_strcoll, 1);\n<line12>}\n<line13>return diff;\n<line14>}
----------------------------------------
Function: dirfirst_check
Content: <line0>static int\n<line1>dirfirst_check (struct fileinfo const *a, struct fileinfo const *b,\n<line2>int (*cmp) (V, V))\n<line3>{\n<line4>int diff = is_linked_directory (b) - is_linked_directory (a);\n<line5>return diff ? diff : cmp (a, b);\n<line6>}
----------------------------------------
Function: cmp_ctime
Content: <line0>static int\n<line1>cmp_ctime (struct fileinfo const *a, struct fileinfo const *b,\n<line2>int (*cmp) (char const *, char const *))\n<line3>{\n<line4>int diff = timespec_cmp (get_stat_ctime (&b->stat),\n<line5>get_stat_ctime (&a->stat));\n<line6>return diff ? diff : cmp (a->name, b->name);\n<line7>}
----------------------------------------
Function: cmp_mtime
Content: <line0>static int\n<line1>cmp_mtime (struct fileinfo const *a, struct fileinfo const *b,\n<line2>int (*cmp) (char const *, char const *))\n<line3>{\n<line4>int diff = timespec_cmp (get_stat_mtime (&b->stat),\n<line5>get_stat_mtime (&a->stat));\n<line6>return diff ? diff : cmp (a->name, b->name);\n<line7>}
----------------------------------------
Function: cmp_atime
Content: <line0>static int\n<line1>cmp_atime (struct fileinfo const *a, struct fileinfo const *b,\n<line2>int (*cmp) (char const *, char const *))\n<line3>{\n<line4>int diff = timespec_cmp (get_stat_atime (&b->stat),\n<line5>get_stat_atime (&a->stat));\n<line6>return diff ? diff : cmp (a->name, b->name);\n<line7>}
----------------------------------------
Function: cmp_btime
Content: <line0>static int\n<line1>cmp_btime (struct fileinfo const *a, struct fileinfo const *b,\n<line2>int (*cmp) (char const *, char const *))\n<line3>{\n<line4>int diff = timespec_cmp (get_stat_btime (&b->stat),\n<line5>get_stat_btime (&a->stat));\n<line6>return diff ? diff : cmp (a->name, b->name);\n<line7>}
----------------------------------------
Function: off_cmp
Content: <line0>static int\n<line1>off_cmp (off_t a, off_t b)\n<line2>{\n<line3>return (a > b) - (a < b);\n<line4>}
----------------------------------------
Function: cmp_size
Content: <line0>static int\n<line1>cmp_size (struct fileinfo const *a, struct fileinfo const *b,\n<line2>int (*cmp) (char const *, char const *))\n<line3>{\n<line4>int diff = off_cmp (b->stat.st_size, a->stat.st_size);\n<line5>return diff ? diff : cmp (a->name, b->name);\n<line6>}
----------------------------------------
Function: cmp_name
Content: <line0>static int\n<line1>cmp_name (struct fileinfo const *a, struct fileinfo const *b,\n<line2>int (*cmp) (char const *, char const *))\n<line3>{\n<line4>return cmp (a->name, b->name);\n<line5>}
----------------------------------------
Function: cmp_extension
Content: <line0>static int\n<line1>cmp_extension (struct fileinfo const *a, struct fileinfo const *b,\n<line2>int (*cmp) (char const *, char const *))\n<line3>{\n<line4>char const *base1 = strrchr (a->name, '.');\n<line5>char const *base2 = strrchr (b->name, '.');\n<line6>int diff = cmp (base1 ? base1 : "", base2 ? base2 : "");\n<line7>return diff ? diff : cmp (a->name, b->name);\n<line8>}
----------------------------------------
Function: fileinfo_name_width
Content: <line0>static size_t\n<line1>fileinfo_name_width (struct fileinfo const *f)\n<line2>{\n<line3>return f->width\n<line4>? f->width\n<line5>: quote_name_width (f->name, filename_quoting_options, f->quoted);\n<line6>}
----------------------------------------
Function: cmp_width
Content: <line0>static int\n<line1>cmp_width (struct fileinfo const *a, struct fileinfo const *b,\n<line2>int (*cmp) (char const *, char const *))\n<line3>{\n<line4>int diff = fileinfo_name_width (a) - fileinfo_name_width (b);\n<line5>return diff ? diff : cmp (a->name, b->name);\n<line6>}
----------------------------------------
Function: cmp_version
Content: <line0>static int\n<line1>cmp_version (struct fileinfo const *a, struct fileinfo const *b)\n<line2>{\n<line3>int diff = filevercmp (a->name, b->name);\n<line4>return diff ? diff : strcmp (a->name, b->name);\n<line5>}
----------------------------------------
Function: xstrcoll_version
Content: <line0>static int\n<line1>xstrcoll_version (V a, V b)\n<line2>{\n<line3>return cmp_version (a, b);\n<line4>}
----------------------------------------
Function: rev_xstrcoll_version
Content: <line0>static int\n<line1>rev_xstrcoll_version (V a, V b)\n<line2>{\n<line3>return cmp_version (b, a);\n<line4>}
----------------------------------------
Function: xstrcoll_df_version
Content: <line0>static int\n<line1>xstrcoll_df_version (V a, V b)\n<line2>{\n<line3>return dirfirst_check (a, b, xstrcoll_version);\n<line4>}
----------------------------------------
Function: rev_xstrcoll_df_version
Content: <line0>static int\n<line1>rev_xstrcoll_df_version (V a, V b)\n<line2>{\n<line3>return dirfirst_check (a, b, rev_xstrcoll_version);\n<line4>}
----------------------------------------
Function: initialize_ordering_vector
Content: <line0>static void\n<line1>initialize_ordering_vector (void)\n<line2>{\n<line3>for (size_t i = 0; i < cwd_n_used; i++)\n<line4>sorted_file[i] = &cwd_file[i];\n<line5>}
----------------------------------------
Function: update_current_files_info
Content: <line0>static void\n<line1>update_current_files_info (void)\n<line2>{\n<line3>/* Cache screen width of name, if needed multiple times.  */\n<line4>if (sort_type == sort_width\n<line5>|| (line_length && (format == many_per_line || format == horizontal)))\n<line6>{\n<line7>size_t i;\n<line8>for (i = 0; i < cwd_n_used; i++)\n<line9>{\n<line10>struct fileinfo *f = sorted_file[i];\n<line11>f->width = fileinfo_name_width (f);\n<line12>}\n<line13>}\n<line14>}
----------------------------------------
Function: sort_files
Content: <line0>static void\n<line1>sort_files (void)\n<line2>{\n<line3>bool use_strcmp;\n<line4>if (sorted_file_alloc < cwd_n_used + cwd_n_used / 2)\n<line5>{\n<line6>free (sorted_file);\n<line7>sorted_file = xnmalloc (cwd_n_used, 3 * sizeof *sorted_file);\n<line8>sorted_file_alloc = 3 * cwd_n_used;\n<line9>}\n<line10>initialize_ordering_vector ();\n<line11>update_current_files_info ();\n<line12>if (sort_type == sort_none)\n<line13>return;\n<line14>/* Try strcoll.  If it fails, fall back on strcmp.  We can't safely\n<line15>ignore strcoll failures, as a failing strcoll might be a\n<line16>comparison function that is not a total order, and if we ignored\n<line17>the failure this might cause qsort to dump core.  */\n<line18>if (! setjmp (failed_strcoll))\n<line19>use_strcmp = false;      /* strcoll() succeeded */\n<line20>else\n<line21>{\n<line22>use_strcmp = true;\n<line23>affirm (sort_type != sort_version);\n<line24>initialize_ordering_vector ();\n<line25>}\n<line26>/* When sort_type == sort_time, use time_type as subindex.  */\n<line27>mpsort ((void const **) sorted_file, cwd_n_used,\n<line28>sort_functions[sort_type + (sort_type == sort_time ? time_type : 0)]\n<line29>[use_strcmp][sort_reverse]\n<line30>[directories_first]);\n<line31>}
----------------------------------------
Function: print_current_files
Content: <line0>static void\n<line1>print_current_files (void)\n<line2>{\n<line3>size_t i;\n<line4>switch (format)\n<line5>{\n<line6>case one_per_line:\n<line7>for (i = 0; i < cwd_n_used; i++)\n<line8>{\n<line9>print_file_name_and_frills (sorted_file[i], 0);\n<line10>putchar (eolbyte);\n<line11>}\n<line12>break;\n<line13>case many_per_line:\n<line14>if (! line_length)\n<line15>print_with_separator (' ');\n<line16>else\n<line17>print_many_per_line ();\n<line18>break;\n<line19>case horizontal:\n<line20>if (! line_length)\n<line21>print_with_separator (' ');\n<line22>else\n<line23>print_horizontal ();\n<line24>break;\n<line25>case with_commas:\n<line26>print_with_separator (',');\n<line27>break;\n<line28>case long_format:\n<line29>for (i = 0; i < cwd_n_used; i++)\n<line30>{\n<line31>set_normal_color ();\n<line32>print_long_format (sorted_file[i]);\n<line33>dired_outbyte (eolbyte);\n<line34>}\n<line35>break;\n<line36>}\n<line37>}
----------------------------------------
Function: align_nstrftime
Content: <line0>static size_t\n<line1>align_nstrftime (char *buf, size_t size, bool recent, struct tm const *tm,\n<line2>timezone_t tz, int ns)\n<line3>{\n<line4>char const *nfmt = (use_abformat\n<line5>? abformat[recent][tm->tm_mon]\n<line6>: long_time_format[recent]);\n<line7>return nstrftime (buf, size, nfmt, tm, tz, ns);\n<line8>}
----------------------------------------
Function: long_time_expected_width
Content: <line0>static int\n<line1>long_time_expected_width (void)\n<line2>{\n<line3>static int width = -1;\n<line4>if (width < 0)\n<line5>{\n<line6>time_t epoch = 0;\n<line7>struct tm tm;\n<line8>char buf[TIME_STAMP_LEN_MAXIMUM + 1];\n<line9>/* In case you're wondering if localtime_rz can fail with an input time_t\n<line10>value of 0, let's just say it's very unlikely, but not inconceivable.\n<line11>The TZ environment variable would have to specify a time zone that\n<line12>is 2**31-1900 years or more ahead of UTC.  This could happen only on\n<line13>a 64-bit system that blindly accepts e.g., TZ=UTC+20000000000000.\n<line14>However, this is not possible with Solaris 10 or glibc-2.3.5, since\n<line15>their implementations limit the offset to 167:59 and 24:00, resp.  */\n<line16>if (localtime_rz (localtz, &epoch, &tm))\n<line17>{\n<line18>size_t len = align_nstrftime (buf, sizeof buf, false,\n<line19>&tm, localtz, 0);\n<line20>if (len != 0)\n<line21>width = mbsnwidth (buf, len, 0);\n<line22>}\n<line23>if (width < 0)\n<line24>width = 0;\n<line25>}\n<line26>return width;\n<line27>}
----------------------------------------
Function: format_user_or_group
Content: <line0>static void\n<line1>format_user_or_group (char const *name, uintmax_t id, int width)\n<line2>{\n<line3>if (name)\n<line4>{\n<line5>int width_gap = width - mbswidth (name, 0);\n<line6>int pad = MAX (0, width_gap);\n<line7>dired_outstring (name);\n<line8>do\n<line9>dired_outbyte (' ');\n<line10>while (pad--);\n<line11>}\n<line12>else\n<line13>dired_pos += printf ("%*"PRIuMAX" ", width, id);\n<line14>}
----------------------------------------
Function: format_user
Content: <line0>static void\n<line1>format_user (uid_t u, int width, bool stat_ok)\n<line2>{\n<line3>format_user_or_group (! stat_ok ? "?" :\n<line4>(numeric_ids ? nullptr : getuser (u)), u, width);\n<line5>}
----------------------------------------
Function: format_group
Content: <line0>static void\n<line1>format_group (gid_t g, int width, bool stat_ok)\n<line2>{\n<line3>format_user_or_group (! stat_ok ? "?" :\n<line4>(numeric_ids ? nullptr : getgroup (g)), g, width);\n<line5>}
----------------------------------------
Function: format_user_or_group_width
Content: <line0>static int\n<line1>format_user_or_group_width (char const *name, uintmax_t id)\n<line2>{\n<line3>if (name)\n<line4>{\n<line5>int len = mbswidth (name, 0);\n<line6>return MAX (0, len);\n<line7>}\n<line8>else\n<line9>return snprintf (nullptr, 0, "%"PRIuMAX, id);\n<line10>}
----------------------------------------
Function: format_user_width
Content: <line0>static int\n<line1>format_user_width (uid_t u)\n<line2>{\n<line3>return format_user_or_group_width (numeric_ids ? nullptr : getuser (u), u);\n<line4>}
----------------------------------------
Function: format_group_width
Content: <line0>static int\n<line1>format_group_width (gid_t g)\n<line2>{\n<line3>return format_user_or_group_width (numeric_ids ? nullptr : getgroup (g), g);\n<line4>}
----------------------------------------
Function: format_inode
Content: <line0>static char *\n<line1>format_inode (char buf[INT_BUFSIZE_BOUND (uintmax_t)],\n<line2>const struct fileinfo *f)\n<line3>{\n<line4>return (f->stat_ok && f->stat.st_ino != NOT_AN_INODE_NUMBER\n<line5>? umaxtostr (f->stat.st_ino, buf)\n<line6>: (char *) "?");\n<line7>}
----------------------------------------
Function: print_long_format
Content: <line0>static void\n<line1>print_long_format (const struct fileinfo *f)\n<line2>{\n<line3>char modebuf[12];\n<line4>char buf\n<line5>[LONGEST_HUMAN_READABLE + 1		/* inode */\n<line6>+ LONGEST_HUMAN_READABLE + 1	/* size in blocks */\n<line7>+ sizeof (modebuf) - 1 + 1		/* mode string */\n<line8>+ INT_BUFSIZE_BOUND (uintmax_t)	/* st_nlink */\n<line9>+ LONGEST_HUMAN_READABLE + 2	/* major device number */\n<line10>+ LONGEST_HUMAN_READABLE + 1	/* minor device number */\n<line11>+ TIME_STAMP_LEN_MAXIMUM + 1	/* max length of time/date */\n<line12>];\n<line13>size_t s;\n<line14>char *p;\n<line15>struct timespec when_timespec;\n<line16>struct tm when_local;\n<line17>bool btime_ok = true;\n<line18>/* Compute the mode string, except remove the trailing space if no\n<line19>file in this directory has an ACL or security context.  */\n<line20>if (f->stat_ok)\n<line21>filemodestring (&f->stat, modebuf);\n<line22>else\n<line23>{\n<line24>modebuf[0] = filetype_letter[f->filetype];\n<line25>memset (modebuf + 1, '?', 10);\n<line26>modebuf[11] = '\0';\n<line27>}\n<line28>if (! any_has_acl)\n<line29>modebuf[10] = '\0';\n<line30>else if (f->acl_type == ACL_T_LSM_CONTEXT_ONLY)\n<line31>modebuf[10] = '.';\n<line32>else if (f->acl_type == ACL_T_YES)\n<line33>modebuf[10] = '+';\n<line34>switch (time_type)\n<line35>{\n<line36>case time_ctime:\n<line37>when_timespec = get_stat_ctime (&f->stat);\n<line38>break;\n<line39>case time_mtime:\n<line40>when_timespec = get_stat_mtime (&f->stat);\n<line41>break;\n<line42>case time_atime:\n<line43>when_timespec = get_stat_atime (&f->stat);\n<line44>break;\n<line45>case time_btime:\n<line46>when_timespec = get_stat_btime (&f->stat);\n<line47>if (when_timespec.tv_sec == -1 && when_timespec.tv_nsec == -1)\n<line48>btime_ok = false;\n<line49>break;\n<line50>default:\n<line51>unreachable ();\n<line52>}\n<line53>p = buf;\n<line54>if (print_inode)\n<line55>{\n<line56>char hbuf[INT_BUFSIZE_BOUND (uintmax_t)];\n<line57>p += sprintf (p, "%*s ", inode_number_width, format_inode (hbuf, f));\n<line58>}\n<line59>if (print_block_size)\n<line60>{\n<line61>char hbuf[LONGEST_HUMAN_READABLE + 1];\n<line62>char const *blocks =\n<line63>(! f->stat_ok\n<line64>? "?"\n<line65>: human_readable (ST_NBLOCKS (f->stat), hbuf, human_output_opts,\n<line66>ST_NBLOCKSIZE, output_block_size));\n<line67>int pad;\n<line68>for (pad = block_size_width - mbswidth (blocks, 0); 0 < pad; pad--)\n<line69>*p++ = ' ';\n<line70>while ((*p++ = *blocks++))\n<line71>continue;\n<line72>p[-1] = ' ';\n<line73>}\n<line74>/* The last byte of the mode string is the POSIX\n<line75>"optional alternate access method flag".  */\n<line76>{\n<line77>char hbuf[INT_BUFSIZE_BOUND (uintmax_t)];\n<line78>p += sprintf (p, "%s %*s ", modebuf, nlink_width,\n<line79>! f->stat_ok ? "?" : umaxtostr (f->stat.st_nlink, hbuf));\n<line80>}\n<line81>dired_indent ();\n<line82>if (print_owner || print_group || print_author || print_scontext)\n<line83>{\n<line84>dired_outbuf (buf, p - buf);\n<line85>if (print_owner)\n<line86>format_user (f->stat.st_uid, owner_width, f->stat_ok);\n<line87>if (print_group)\n<line88>format_group (f->stat.st_gid, group_width, f->stat_ok);\n<line89>if (print_author)\n<line90>format_user (f->stat.st_author, author_width, f->stat_ok);\n<line91>if (print_scontext)\n<line92>format_user_or_group (f->scontext, 0, scontext_width);\n<line93>p = buf;\n<line94>}\n<line95>if (f->stat_ok\n<line96>&& (S_ISCHR (f->stat.st_mode) || S_ISBLK (f->stat.st_mode)))\n<line97>{\n<line98>char majorbuf[INT_BUFSIZE_BOUND (uintmax_t)];\n<line99>char minorbuf[INT_BUFSIZE_BOUND (uintmax_t)];\n<line100>int blanks_width = (file_size_width\n<line101>- (major_device_number_width + 2\n<line102>+ minor_device_number_width));\n<line103>p += sprintf (p, "%*s, %*s ",\n<line104>major_device_number_width + MAX (0, blanks_width),\n<line105>umaxtostr (major (f->stat.st_rdev), majorbuf),\n<line106>minor_device_number_width,\n<line107>umaxtostr (minor (f->stat.st_rdev), minorbuf));\n<line108>}\n<line109>else\n<line110>{\n<line111>char hbuf[LONGEST_HUMAN_READABLE + 1];\n<line112>char const *size =\n<line113>(! f->stat_ok\n<line114>? "?"\n<line115>: human_readable (unsigned_file_size (f->stat.st_size),\n<line116>hbuf, file_human_output_opts, 1,\n<line117>file_output_block_size));\n<line118>int pad;\n<line119>for (pad = file_size_width - mbswidth (size, 0); 0 < pad; pad--)\n<line120>*p++ = ' ';\n<line121>while ((*p++ = *size++))\n<line122>continue;\n<line123>p[-1] = ' ';\n<line124>}\n<line125>s = 0;\n<line126>*p = '\1';\n<line127>if (f->stat_ok && btime_ok\n<line128>&& localtime_rz (localtz, &when_timespec.tv_sec, &when_local))\n<line129>{\n<line130>struct timespec six_months_ago;\n<line131>bool recent;\n<line132>/* If the file appears to be in the future, update the current\n<line133>time, in case the file happens to have been modified since\n<line134>the last time we checked the clock.  */\n<line135>if (timespec_cmp (current_time, when_timespec) < 0)\n<line136>gettime (&current_time);\n<line137>/* Consider a time to be recent if it is within the past six months.\n<line138>A Gregorian year has 365.2425 * 24 * 60 * 60 == 31556952 seconds\n<line139>on the average.  Write this value as an integer constant to\n<line140>avoid floating point hassles.  */\n<line141>six_months_ago.tv_sec = current_time.tv_sec - 31556952 / 2;\n<line142>six_months_ago.tv_nsec = current_time.tv_nsec;\n<line143>recent = (timespec_cmp (six_months_ago, when_timespec) < 0\n<line144>&& timespec_cmp (when_timespec, current_time) < 0);\n<line145>/* We assume here that all time zones are offset from UTC by a\n<line146>whole number of seconds.  */\n<line147>s = align_nstrftime (p, TIME_STAMP_LEN_MAXIMUM + 1, recent,\n<line148>&when_local, localtz, when_timespec.tv_nsec);\n<line149>}\n<line150>if (s || !*p)\n<line151>{\n<line152>p += s;\n<line153>*p++ = ' ';\n<line154>}\n<line155>else\n<line156>{\n<line157>/* The time cannot be converted using the desired format, so\n<line158>print it as a huge integer number of seconds.  */\n<line159>char hbuf[INT_BUFSIZE_BOUND (intmax_t)];\n<line160>p += sprintf (p, "%*s ", long_time_expected_width (),\n<line161>(! f->stat_ok || ! btime_ok\n<line162>? "?"\n<line163>: timetostr (when_timespec.tv_sec, hbuf)));\n<line164>/* FIXME: (maybe) We discarded when_timespec.tv_nsec. */\n<line165>}\n<line166>dired_outbuf (buf, p - buf);\n<line167>size_t w = print_name_with_quoting (f, false, &dired_obstack, p - buf);\n<line168>if (f->filetype == symbolic_link)\n<line169>{\n<line170>if (f->linkname)\n<line171>{\n<line172>dired_outstring (" -> ");\n<line173>print_name_with_quoting (f, true, nullptr, (p - buf) + w + 4);\n<line174>if (indicator_style != none)\n<line175>print_type_indicator (true, f->linkmode, unknown);\n<line176>}\n<line177>}\n<line178>else if (indicator_style != none)\n<line179>print_type_indicator (f->stat_ok, f->stat.st_mode, f->filetype);\n<line180>}
----------------------------------------
Function: quote_name_buf
Content: <line0>static size_t\n<line1>quote_name_buf (char **inbuf, size_t bufsize, char *name,\n<line2>struct quoting_options const *options,\n<line3>int needs_general_quoting, size_t *width, bool *pad)\n<line4>{\n<line5>char *buf = *inbuf;\n<line6>size_t displayed_width IF_LINT ( = 0);\n<line7>size_t len = 0;\n<line8>bool quoted;\n<line9>enum quoting_style qs = get_quoting_style (options);\n<line10>bool needs_further_quoting = qmark_funny_chars\n<line11>&& (qs == shell_quoting_style\n<line12>|| qs == shell_always_quoting_style\n<line13>|| qs == literal_quoting_style);\n<line14>if (needs_general_quoting != 0)\n<line15>{\n<line16>len = quotearg_buffer (buf, bufsize, name, -1, options);\n<line17>if (bufsize <= len)\n<line18>{\n<line19>buf = xmalloc (len + 1);\n<line20>quotearg_buffer (buf, len + 1, name, -1, options);\n<line21>}\n<line22>quoted = (*name != *buf) || strlen (name) != len;\n<line23>}\n<line24>else if (needs_further_quoting)\n<line25>{\n<line26>len = strlen (name);\n<line27>if (bufsize <= len)\n<line28>buf = xmalloc (len + 1);\n<line29>memcpy (buf, name, len + 1);\n<line30>quoted = false;\n<line31>}\n<line32>else\n<line33>{\n<line34>len = strlen (name);\n<line35>buf = name;\n<line36>quoted = false;\n<line37>}\n<line38>if (needs_further_quoting)\n<line39>{\n<line40>if (MB_CUR_MAX > 1)\n<line41>{\n<line42>char const *p = buf;\n<line43>char const *plimit = buf + len;\n<line44>char *q = buf;\n<line45>displayed_width = 0;\n<line46>while (p < plimit)\n<line47>switch (*p)\n<line48>{\n<line49>case ' ': case '!': case '"': case '#': case '%':\n<line50>case '&': case '\'': case '(': case ')': case '*':\n<line51>case '+': case ',': case '-': case '.': case '/':\n<line52>case '0': case '1': case '2': case '3': case '4':\n<line53>case '5': case '6': case '7': case '8': case '9':\n<line54>case ':': case ';': case '<': case '=': case '>':\n<line55>case '?':\n<line56>case 'A': case 'B': case 'C': case 'D': case 'E':\n<line57>case 'F': case 'G': case 'H': case 'I': case 'J':\n<line58>case 'K': case 'L': case 'M': case 'N': case 'O':\n<line59>case 'P': case 'Q': case 'R': case 'S': case 'T':\n<line60>case 'U': case 'V': case 'W': case 'X': case 'Y':\n<line61>case 'Z':\n<line62>case '[': case '\\': case ']': case '^': case '_':\n<line63>case 'a': case 'b': case 'c': case 'd': case 'e':\n<line64>case 'f': case 'g': case 'h': case 'i': case 'j':\n<line65>case 'k': case 'l': case 'm': case 'n': case 'o':\n<line66>case 'p': case 'q': case 'r': case 's': case 't':\n<line67>case 'u': case 'v': case 'w': case 'x': case 'y':\n<line68>case 'z': case '{': case '|': case '}': case '~':\n<line69>/* These characters are printable ASCII characters.  */\n<line70>*q++ = *p++;\n<line71>displayed_width += 1;\n<line72>break;\n<line73>default:\n<line74>/* If we have a multibyte sequence, copy it until we\n<line75>reach its end, replacing each non-printable multibyte\n<line76>character with a single question mark.  */\n<line77>{\n<line78>mbstate_t mbstate = { 0, };\n<line79>do\n<line80>{\n<line81>wchar_t wc;\n<line82>size_t bytes;\n<line83>int w;\n<line84>bytes = mbrtowc (&wc, p, plimit - p, &mbstate);\n<line85>if (bytes == (size_t) -1)\n<line86>{\n<line87>/* An invalid multibyte sequence was\n<line88>encountered.  Skip one input byte, and\n<line89>put a question mark.  */\n<line90>p++;\n<line91>*q++ = '?';\n<line92>displayed_width += 1;\n<line93>break;\n<line94>}\n<line95>if (bytes == (size_t) -2)\n<line96>{\n<line97>/* An incomplete multibyte character\n<line98>at the end.  Replace it entirely with\n<line99>a question mark.  */\n<line100>p = plimit;\n<line101>*q++ = '?';\n<line102>displayed_width += 1;\n<line103>break;\n<line104>}\n<line105>if (bytes == 0)\n<line106>/* A null wide character was encountered.  */\n<line107>bytes = 1;\n<line108>w = wcwidth (wc);\n<line109>if (w >= 0)\n<line110>{\n<line111>/* A printable multibyte character.\n<line112>Keep it.  */\n<line113>for (; bytes > 0; --bytes)\n<line114>*q++ = *p++;\n<line115>displayed_width += w;\n<line116>}\n<line117>else\n<line118>{\n<line119>/* An nonprintable multibyte character.\n<line120>Replace it entirely with a question\n<line121>mark.  */\n<line122>p += bytes;\n<line123>*q++ = '?';\n<line124>displayed_width += 1;\n<line125>}\n<line126>}\n<line127>while (! mbsinit (&mbstate));\n<line128>}\n<line129>break;\n<line130>}\n<line131>/* The buffer may have shrunk.  */\n<line132>len = q - buf;\n<line133>}\n<line134>else\n<line135>{\n<line136>char *p = buf;\n<line137>char const *plimit = buf + len;\n<line138>while (p < plimit)\n<line139>{\n<line140>if (! isprint (to_uchar (*p)))\n<line141>*p = '?';\n<line142>p++;\n<line143>}\n<line144>displayed_width = len;\n<line145>}\n<line146>}\n<line147>else if (width != nullptr)\n<line148>{\n<line149>if (MB_CUR_MAX > 1)\n<line150>displayed_width = mbsnwidth (buf, len, 0);\n<line151>else\n<line152>{\n<line153>char const *p = buf;\n<line154>char const *plimit = buf + len;\n<line155>displayed_width = 0;\n<line156>while (p < plimit)\n<line157>{\n<line158>if (isprint (to_uchar (*p)))\n<line159>displayed_width++;\n<line160>p++;\n<line161>}\n<line162>}\n<line163>}\n<line164>/* Set padding to better align quoted items,\n<line165>and also give a visual indication that quotes are\n<line166>not actually part of the name.  */\n<line167>*pad = (align_variable_outer_quotes && cwd_some_quoted && ! quoted);\n<line168>if (width != nullptr)\n<line169>*width = displayed_width;\n<line170>*inbuf = buf;\n<line171>return len;\n<line172>}
----------------------------------------
Function: quote_name_width
Content: <line0>static size_t\n<line1>quote_name_width (char const *name, struct quoting_options const *options,\n<line2>int needs_general_quoting)\n<line3>{\n<line4>char smallbuf[BUFSIZ];\n<line5>char *buf = smallbuf;\n<line6>size_t width;\n<line7>bool pad;\n<line8>quote_name_buf (&buf, sizeof smallbuf, (char *) name, options,\n<line9>needs_general_quoting, &width, &pad);\n<line10>if (buf != smallbuf && buf != name)\n<line11>free (buf);\n<line12>width += pad;\n<line13>return width;\n<line14>}
----------------------------------------
Function: file_escape
Content: <line0>static char *\n<line1>file_escape (char const *str, bool path)\n<line2>{\n<line3>char *esc = xnmalloc (3, strlen (str) + 1);\n<line4>char *p = esc;\n<line5>while (*str)\n<line6>{\n<line7>if (path && ISSLASH (*str))\n<line8>{\n<line9>*p++ = '/';\n<line10>str++;\n<line11>}\n<line12>else if (RFC3986[to_uchar (*str)])\n<line13>*p++ = *str++;\n<line14>else\n<line15>p += sprintf (p, "%%%02x", to_uchar (*str++));\n<line16>}\n<line17>*p = '\0';\n<line18>return esc;\n<line19>}
----------------------------------------
Function: quote_name
Content: <line0>static size_t\n<line1>quote_name (char const *name, struct quoting_options const *options,\n<line2>int needs_general_quoting, const struct bin_str *color,\n<line3>bool allow_pad, struct obstack *stack, char const *absolute_name)\n<line4>{\n<line5>char smallbuf[BUFSIZ];\n<line6>char *buf = smallbuf;\n<line7>size_t len;\n<line8>bool pad;\n<line9>len = quote_name_buf (&buf, sizeof smallbuf, (char *) name, options,\n<line10>needs_general_quoting, nullptr, &pad);\n<line11>if (pad && allow_pad)\n<line12>dired_outbyte (' ');\n<line13>if (color)\n<line14>print_color_indicator (color);\n<line15>/* If we're padding, then don't include the outer quotes in\n<line16>the --hyperlink, to improve the alignment of those links.  */\n<line17>bool skip_quotes = false;\n<line18>if (absolute_name)\n<line19>{\n<line20>if (align_variable_outer_quotes && cwd_some_quoted && ! pad)\n<line21>{\n<line22>skip_quotes = true;\n<line23>putchar (*buf);\n<line24>}\n<line25>char *h = file_escape (hostname, /* path= */ false);\n<line26>char *n = file_escape (absolute_name, /* path= */ true);\n<line27>/* TODO: It would be good to be able to define parameters\n<line28>to give hints to the terminal as how best to render the URI.\n<line29>For example since ls is outputting a dense block of URIs\n<line30>it would be best to not underline by default, and only\n<line31>do so upon hover etc.  */\n<line32>printf ("\033]8;;file://%s%s%s\a", h, *n == '/' ? "" : "/", n);\n<line33>free (h);\n<line34>free (n);\n<line35>}\n<line36>if (stack)\n<line37>push_current_dired_pos (stack);\n<line38>fwrite (buf + skip_quotes, 1, len - (skip_quotes * 2), stdout);\n<line39>dired_pos += len;\n<line40>if (stack)\n<line41>push_current_dired_pos (stack);\n<line42>if (absolute_name)\n<line43>{\n<line44>fputs ("\033]8;;\a", stdout);\n<line45>if (skip_quotes)\n<line46>putchar (*(buf + len - 1));\n<line47>}\n<line48>if (buf != smallbuf && buf != name)\n<line49>free (buf);\n<line50>return len + pad;\n<line51>}
----------------------------------------
Function: print_name_with_quoting
Content: <line0>static size_t\n<line1>print_name_with_quoting (const struct fileinfo *f,\n<line2>bool symlink_target,\n<line3>struct obstack *stack,\n<line4>size_t start_col)\n<line5>{\n<line6>char const *name = symlink_target ? f->linkname : f->name;\n<line7>const struct bin_str *color\n<line8>= print_with_color ? get_color_indicator (f, symlink_target) : nullptr;\n<line9>bool used_color_this_time = (print_with_color\n<line10>&& (color || is_colored (C_NORM)));\n<line11>size_t len = quote_name (name, filename_quoting_options, f->quoted,\n<line12>color, !symlink_target, stack, f->absolute_name);\n<line13>process_signals ();\n<line14>if (used_color_this_time)\n<line15>{\n<line16>prep_non_filename_text ();\n<line17>/* We use the byte length rather than display width here as\n<line18>an optimization to avoid accurately calculating the width,\n<line19>because we only output the clear to EOL sequence if the name\n<line20>_might_ wrap to the next line.  This may output a sequence\n<line21>unnecessarily in multi-byte locales for example,\n<line22>but in that case it's inconsequential to the output.  */\n<line23>if (line_length\n<line24>&& (start_col / line_length != (start_col + len - 1) / line_length))\n<line25>put_indicator (&color_indicator[C_CLR_TO_EOL]);\n<line26>}\n<line27>return len;\n<line28>}
----------------------------------------
Function: prep_non_filename_text
Content: <line0>static void\n<line1>prep_non_filename_text (void)\n<line2>{\n<line3>if (color_indicator[C_END].string != nullptr)\n<line4>put_indicator (&color_indicator[C_END]);\n<line5>else\n<line6>{\n<line7>put_indicator (&color_indicator[C_LEFT]);\n<line8>put_indicator (&color_indicator[C_RESET]);\n<line9>put_indicator (&color_indicator[C_RIGHT]);\n<line10>}\n<line11>}
----------------------------------------
Function: print_file_name_and_frills
Content: <line0>static size_t\n<line1>print_file_name_and_frills (const struct fileinfo *f, size_t start_col)\n<line2>{\n<line3>char buf[MAX (LONGEST_HUMAN_READABLE + 1, INT_BUFSIZE_BOUND (uintmax_t))];\n<line4>set_normal_color ();\n<line5>if (print_inode)\n<line6>printf ("%*s ", format == with_commas ? 0 : inode_number_width,\n<line7>format_inode (buf, f));\n<line8>if (print_block_size)\n<line9>printf ("%*s ", format == with_commas ? 0 : block_size_width,\n<line10>! f->stat_ok ? "?"\n<line11>: human_readable (ST_NBLOCKS (f->stat), buf, human_output_opts,\n<line12>ST_NBLOCKSIZE, output_block_size));\n<line13>if (print_scontext)\n<line14>printf ("%*s ", format == with_commas ? 0 : scontext_width, f->scontext);\n<line15>size_t width = print_name_with_quoting (f, false, nullptr, start_col);\n<line16>if (indicator_style != none)\n<line17>width += print_type_indicator (f->stat_ok, f->stat.st_mode, f->filetype);\n<line18>return width;\n<line19>}
----------------------------------------
Function: get_type_indicator
Content: <line0>static char\n<line1>get_type_indicator (bool stat_ok, mode_t mode, enum filetype type)\n<line2>{\n<line3>char c;\n<line4>if (stat_ok ? S_ISREG (mode) : type == normal)\n<line5>{\n<line6>if (stat_ok && indicator_style == classify && (mode & S_IXUGO))\n<line7>c = '*';\n<line8>else\n<line9>c = 0;\n<line10>}\n<line11>else\n<line12>{\n<line13>if (stat_ok ? S_ISDIR (mode) : type == directory || type == arg_directory)\n<line14>c = '/';\n<line15>else if (indicator_style == slash)\n<line16>c = 0;\n<line17>else if (stat_ok ? S_ISLNK (mode) : type == symbolic_link)\n<line18>c = '@';\n<line19>else if (stat_ok ? S_ISFIFO (mode) : type == fifo)\n<line20>c = '|';\n<line21>else if (stat_ok ? S_ISSOCK (mode) : type == sock)\n<line22>c = '=';\n<line23>else if (stat_ok && S_ISDOOR (mode))\n<line24>c = '>';\n<line25>else\n<line26>c = 0;\n<line27>}\n<line28>return c;\n<line29>}
----------------------------------------
Function: print_type_indicator
Content: <line0>static bool\n<line1>print_type_indicator (bool stat_ok, mode_t mode, enum filetype type)\n<line2>{\n<line3>char c = get_type_indicator (stat_ok, mode, type);\n<line4>if (c)\n<line5>dired_outbyte (c);\n<line6>return !!c;\n<line7>}
----------------------------------------
Function: print_color_indicator
Content: <line0>static bool\n<line1>print_color_indicator (const struct bin_str *ind)\n<line2>{\n<line3>if (ind)\n<line4>{\n<line5>/* Need to reset so not dealing with attribute combinations */\n<line6>if (is_colored (C_NORM))\n<line7>restore_default_color ();\n<line8>put_indicator (&color_indicator[C_LEFT]);\n<line9>put_indicator (ind);\n<line10>put_indicator (&color_indicator[C_RIGHT]);\n<line11>}\n<line12>return ind != nullptr;\n<line13>}
----------------------------------------
Function: put_indicator
Content: <line0>static void\n<line1>put_indicator (const struct bin_str *ind)\n<line2>{\n<line3>if (! used_color)\n<line4>{\n<line5>used_color = true;\n<line6>/* If the standard output is a controlling terminal, watch out\n<line7>for signals, so that the colors can be restored to the\n<line8>default state if "ls" is suspended or interrupted.  */\n<line9>if (0 <= tcgetpgrp (STDOUT_FILENO))\n<line10>signal_init ();\n<line11>prep_non_filename_text ();\n<line12>}\n<line13>fwrite (ind->string, ind->len, 1, stdout);\n<line14>}
----------------------------------------
Function: length_of_file_name_and_frills
Content: <line0>static size_t\n<line1>length_of_file_name_and_frills (const struct fileinfo *f)\n<line2>{\n<line3>size_t len = 0;\n<line4>char buf[MAX (LONGEST_HUMAN_READABLE + 1, INT_BUFSIZE_BOUND (uintmax_t))];\n<line5>if (print_inode)\n<line6>len += 1 + (format == with_commas\n<line7>? strlen (umaxtostr (f->stat.st_ino, buf))\n<line8>: inode_number_width);\n<line9>if (print_block_size)\n<line10>len += 1 + (format == with_commas\n<line11>? strlen (! f->stat_ok ? "?"\n<line12>: human_readable (ST_NBLOCKS (f->stat), buf,\n<line13>human_output_opts, ST_NBLOCKSIZE,\n<line14>output_block_size))\n<line15>: block_size_width);\n<line16>if (print_scontext)\n<line17>len += 1 + (format == with_commas ? strlen (f->scontext) : scontext_width);\n<line18>len += fileinfo_name_width (f);\n<line19>if (indicator_style != none)\n<line20>{\n<line21>char c = get_type_indicator (f->stat_ok, f->stat.st_mode, f->filetype);\n<line22>len += (c != 0);\n<line23>}\n<line24>return len;\n<line25>}
----------------------------------------
Function: print_many_per_line
Content: <line0>static void\n<line1>print_many_per_line (void)\n<line2>{\n<line3>size_t row;			/* Current row.  */\n<line4>size_t cols = calculate_columns (true);\n<line5>struct column_info const *line_fmt = &column_info[cols - 1];\n<line6>/* Calculate the number of rows that will be in each column except possibly\n<line7>for a short column on the right.  */\n<line8>size_t rows = cwd_n_used / cols + (cwd_n_used % cols != 0);\n<line9>for (row = 0; row < rows; row++)\n<line10>{\n<line11>size_t col = 0;\n<line12>size_t filesno = row;\n<line13>size_t pos = 0;\n<line14>/* Print the next row.  */\n<line15>while (true)\n<line16>{\n<line17>struct fileinfo const *f = sorted_file[filesno];\n<line18>size_t name_length = length_of_file_name_and_frills (f);\n<line19>size_t max_name_length = line_fmt->col_arr[col++];\n<line20>print_file_name_and_frills (f, pos);\n<line21>filesno += rows;\n<line22>if (filesno >= cwd_n_used)\n<line23>break;\n<line24>indent (pos + name_length, pos + max_name_length);\n<line25>pos += max_name_length;\n<line26>}\n<line27>putchar (eolbyte);\n<line28>}\n<line29>}
----------------------------------------
Function: print_horizontal
Content: <line0>static void\n<line1>print_horizontal (void)\n<line2>{\n<line3>size_t filesno;\n<line4>size_t pos = 0;\n<line5>size_t cols = calculate_columns (false);\n<line6>struct column_info const *line_fmt = &column_info[cols - 1];\n<line7>struct fileinfo const *f = sorted_file[0];\n<line8>size_t name_length = length_of_file_name_and_frills (f);\n<line9>size_t max_name_length = line_fmt->col_arr[0];\n<line10>/* Print first entry.  */\n<line11>print_file_name_and_frills (f, 0);\n<line12>/* Now the rest.  */\n<line13>for (filesno = 1; filesno < cwd_n_used; ++filesno)\n<line14>{\n<line15>size_t col = filesno % cols;\n<line16>if (col == 0)\n<line17>{\n<line18>putchar (eolbyte);\n<line19>pos = 0;\n<line20>}\n<line21>else\n<line22>{\n<line23>indent (pos + name_length, pos + max_name_length);\n<line24>pos += max_name_length;\n<line25>}\n<line26>f = sorted_file[filesno];\n<line27>print_file_name_and_frills (f, pos);\n<line28>name_length = length_of_file_name_and_frills (f);\n<line29>max_name_length = line_fmt->col_arr[col];\n<line30>}\n<line31>putchar (eolbyte);\n<line32>}
----------------------------------------
Function: print_with_separator
Content: <line0>static void\n<line1>print_with_separator (char sep)\n<line2>{\n<line3>size_t filesno;\n<line4>size_t pos = 0;\n<line5>for (filesno = 0; filesno < cwd_n_used; filesno++)\n<line6>{\n<line7>struct fileinfo const *f = sorted_file[filesno];\n<line8>size_t len = line_length ? length_of_file_name_and_frills (f) : 0;\n<line9>if (filesno != 0)\n<line10>{\n<line11>char separator;\n<line12>if (! line_length\n<line13>|| ((pos + len + 2 < line_length)\n<line14>&& (pos <= SIZE_MAX - len - 2)))\n<line15>{\n<line16>pos += 2;\n<line17>separator = ' ';\n<line18>}\n<line19>else\n<line20>{\n<line21>pos = 0;\n<line22>separator = eolbyte;\n<line23>}\n<line24>putchar (sep);\n<line25>putchar (separator);\n<line26>}\n<line27>print_file_name_and_frills (f, pos);\n<line28>pos += len;\n<line29>}\n<line30>putchar (eolbyte);\n<line31>}
----------------------------------------
Function: indent
Content: <line0>static void\n<line1>indent (size_t from, size_t to)\n<line2>{\n<line3>while (from < to)\n<line4>{\n<line5>if (tabsize != 0 && to / tabsize > (from + 1) / tabsize)\n<line6>{\n<line7>putchar ('\t');\n<line8>from += tabsize - from % tabsize;\n<line9>}\n<line10>else\n<line11>{\n<line12>putchar (' ');\n<line13>from++;\n<line14>}\n<line15>}\n<line16>}
----------------------------------------
Function: attach
Content: <line0>static void\n<line1>attach (char *dest, char const *dirname, char const *name)\n<line2>{\n<line3>char const *dirnamep = dirname;\n<line4>/* Copy dirname if it is not ".".  */\n<line5>if (dirname[0] != '.' || dirname[1] != 0)\n<line6>{\n<line7>while (*dirnamep)\n<line8>*dest++ = *dirnamep++;\n<line9>/* Add '/' if 'dirname' doesn't already end with it.  */\n<line10>if (dirnamep > dirname && dirnamep[-1] != '/')\n<line11>*dest++ = '/';\n<line12>}\n<line13>while (*name)\n<line14>*dest++ = *name++;\n<line15>*dest = 0;\n<line16>}
----------------------------------------
Function: init_column_info
Content: <line0>static void\n<line1>init_column_info (size_t max_cols)\n<line2>{\n<line3>size_t i;\n<line4>/* Currently allocated columns in column_info.  */\n<line5>static size_t column_info_alloc;\n<line6>if (column_info_alloc < max_cols)\n<line7>{\n<line8>size_t new_column_info_alloc;\n<line9>size_t *p;\n<line10>if (!max_idx || max_cols < max_idx / 2)\n<line11>{\n<line12>/* The number of columns is far less than the display width\n<line13>allows.  Grow the allocation, but only so that it's\n<line14>double the current requirements.  If the display is\n<line15>extremely wide, this avoids allocating a lot of memory\n<line16>that is never needed.  */\n<line17>column_info = xnrealloc (column_info, max_cols,\n<line18>2 * sizeof *column_info);\n<line19>new_column_info_alloc = 2 * max_cols;\n<line20>}\n<line21>else\n<line22>{\n<line23>column_info = xnrealloc (column_info, max_idx, sizeof *column_info);\n<line24>new_column_info_alloc = max_idx;\n<line25>}\n<line26>/* Allocate the new size_t objects by computing the triangle\n<line27>formula n * (n + 1) / 2, except that we don't need to\n<line28>allocate the part of the triangle that we've already\n<line29>allocated.  Check for address arithmetic overflow.  */\n<line30>{\n<line31>size_t column_info_growth = new_column_info_alloc - column_info_alloc;\n<line32>size_t s = column_info_alloc + 1 + new_column_info_alloc;\n<line33>size_t t = s * column_info_growth;\n<line34>if (s < new_column_info_alloc || t / column_info_growth != s)\n<line35>xalloc_die ();\n<line36>p = xnmalloc (t / 2, sizeof *p);\n<line37>}\n<line38>/* Grow the triangle by parceling out the cells just allocated.  */\n<line39>for (i = column_info_alloc; i < new_column_info_alloc; i++)\n<line40>{\n<line41>column_info[i].col_arr = p;\n<line42>p += i + 1;\n<line43>}\n<line44>column_info_alloc = new_column_info_alloc;\n<line45>}\n<line46>for (i = 0; i < max_cols; ++i)\n<line47>{\n<line48>size_t j;\n<line49>column_info[i].valid_len = true;\n<line50>column_info[i].line_len = (i + 1) * MIN_COLUMN_WIDTH;\n<line51>for (j = 0; j <= i; ++j)\n<line52>column_info[i].col_arr[j] = MIN_COLUMN_WIDTH;\n<line53>}\n<line54>}
----------------------------------------
Function: calculate_columns
Content: <line0>static size_t\n<line1>calculate_columns (bool by_columns)\n<line2>{\n<line3>size_t filesno;		/* Index into cwd_file.  */\n<line4>size_t cols;			/* Number of files across.  */\n<line5>/* Normally the maximum number of columns is determined by the\n<line6>screen width.  But if few files are available this might limit it\n<line7>as well.  */\n<line8>size_t max_cols = 0 < max_idx && max_idx < cwd_n_used ? max_idx : cwd_n_used;\n<line9>init_column_info (max_cols);\n<line10>/* Compute the maximum number of possible columns.  */\n<line11>for (filesno = 0; filesno < cwd_n_used; ++filesno)\n<line12>{\n<line13>struct fileinfo const *f = sorted_file[filesno];\n<line14>size_t name_length = length_of_file_name_and_frills (f);\n<line15>for (size_t i = 0; i < max_cols; ++i)\n<line16>{\n<line17>if (column_info[i].valid_len)\n<line18>{\n<line19>size_t idx = (by_columns\n<line20>? filesno / ((cwd_n_used + i) / (i + 1))\n<line21>: filesno % (i + 1));\n<line22>size_t real_length = name_length + (idx == i ? 0 : 2);\n<line23>if (column_info[i].col_arr[idx] < real_length)\n<line24>{\n<line25>column_info[i].line_len += (real_length\n<line26>- column_info[i].col_arr[idx]);\n<line27>column_info[i].col_arr[idx] = real_length;\n<line28>column_info[i].valid_len = (column_info[i].line_len\n<line29>< line_length);\n<line30>}\n<line31>}\n<line32>}\n<line33>}\n<line34>/* Find maximum allowed columns.  */\n<line35>for (cols = max_cols; 1 < cols; --cols)\n<line36>{\n<line37>if (column_info[cols - 1].valid_len)\n<line38>break;\n<line39>}\n<line40>return cols;\n<line41>}
----------------------------------------
Function: usage
Content: <line0>void\n<line1>usage (int status)\n<line2>{\n<line3>if (status != EXIT_SUCCESS)\n<line4>emit_try_help ();\n<line5>else\n<line6>{\n<line7>printf (_("Usage: %s [OPTION]... [FILE]...\n"), program_name);\n<line8>fputs (_("\\n<line9>List information about the FILEs (the current directory by default).\n\\n<line10>Sort entries alphabetically if none of -cftuvSUX nor --sort is specified.\n\\n<line11>"), stdout);\n<line12>emit_mandatory_arg_note ();\n<line13>fputs (_("\\n<line14>-a, --all                  do not ignore entries starting with .\n\\n<line15>-A, --almost-all           do not list implied . and ..\n\\n<line16>--author               with -l, print the author of each file\n\\n<line17>-b, --escape               print C-style escapes for nongraphic characters\n\\n<line18>"), stdout);\n<line19>fputs (_("\\n<line20>--block-size=SIZE      with -l, scale sizes by SIZE when printing them;\n\\n<line21>e.g., '--block-size=M'; see SIZE format below\n\\n<line22>\n\\n<line23>"), stdout);\n<line24>fputs (_("\\n<line25>-B, --ignore-backups       do not list implied entries ending with ~\n\\n<line26>"), stdout);\n<line27>fputs (_("\\n<line28>-c                         with -lt: sort by, and show, ctime (time of last\n\\n<line29>change of file status information);\n\\n<line30>with -l: show ctime and sort by name;\n\\n<line31>otherwise: sort by ctime, newest first\n\\n<line32>\n\\n<line33>"), stdout);\n<line34>fputs (_("\\n<line35>-C                         list entries by columns\n\\n<line36>--color[=WHEN]         color the output WHEN; more info below\n\\n<line37>-d, --directory            list directories themselves, not their contents\n\\n<line38>-D, --dired                generate output designed for Emacs' dired mode\n\\n<line39>"), stdout);\n<line40>fputs (_("\\n<line41>-f                         list all entries in directory order\n\\n<line42>-F, --classify[=WHEN]      append indicator (one of */=>@|) to entries WHEN\n\\n<line43>--file-type            likewise, except do not append '*'\n\\n<line44>"), stdout);\n<line45>fputs (_("\\n<line46>--format=WORD          across -x, commas -m, horizontal -x, long -l,\n\\n<line47>single-column -1, verbose -l, vertical -C\n\\n<line48>\n\\n<line49>"), stdout);\n<line50>fputs (_("\\n<line51>--full-time            like -l --time-style=full-iso\n\\n<line52>"), stdout);\n<line53>fputs (_("\\n<line54>-g                         like -l, but do not list owner\n\\n<line55>"), stdout);\n<line56>fputs (_("\\n<line57>--group-directories-first\n\\n<line58>group directories before files;\n\\n<line59>can be augmented with a --sort option, but any\n\\n<line60>use of --sort=none (-U) disables grouping\n\\n<line61>\n\\n<line62>"), stdout);\n<line63>fputs (_("\\n<line64>-G, --no-group             in a long listing, don't print group names\n\\n<line65>"), stdout);\n<line66>fputs (_("\\n<line67>-h, --human-readable       with -l and -s, print sizes like 1K 234M 2G etc.\n\\n<line68>--si                   likewise, but use powers of 1000 not 1024\n\\n<line69>"), stdout);\n<line70>fputs (_("\\n<line71>-H, --dereference-command-line\n\\n<line72>follow symbolic links listed on the command line\n\\n<line73>"), stdout);\n<line74>fputs (_("\\n<line75>--dereference-command-line-symlink-to-dir\n\\n<line76>follow each command line symbolic link\n\\n<line77>that points to a directory\n\\n<line78>\n\\n<line79>"), stdout);\n<line80>fputs (_("\\n<line81>--hide=PATTERN         do not list implied entries matching shell PATTERN\\n<line82>\n\\n<line83>(overridden by -a or -A)\n\\n<line84>\n\\n<line85>"), stdout);\n<line86>fputs (_("\\n<line87>--hyperlink[=WHEN]     hyperlink file names WHEN\n\\n<line88>"), stdout);\n<line89>fputs (_("\\n<line90>--indicator-style=WORD\n\\n<line91>append indicator with style WORD to entry names:\n\\n<line92>none (default), slash (-p),\n\\n<line93>file-type (--file-type), classify (-F)\n\\n<line94>\n\\n<line95>"), stdout);\n<line96>fputs (_("\\n<line97>-i, --inode                print the index number of each file\n\\n<line98>-I, --ignore=PATTERN       do not list implied entries matching shell PATTERN\\n<line99>\n\\n<line100>"), stdout);\n<line101>fputs (_("\\n<line102>-k, --kibibytes            default to 1024-byte blocks for file system usage;\\n<line103>\n\\n<line104>used only with -s and per directory totals\n\\n<line105>\n\\n<line106>"), stdout);\n<line107>fputs (_("\\n<line108>-l                         use a long listing format\n\\n<line109>"), stdout);\n<line110>fputs (_("\\n<line111>-L, --dereference          when showing file information for a symbolic\n\\n<line112>link, show information for the file the link\n\\n<line113>references rather than for the link itself\n\\n<line114>\n\\n<line115>"), stdout);\n<line116>fputs (_("\\n<line117>-m                         fill width with a comma separated list of entries\\n<line118>\n\\n<line119>"), stdout);\n<line120>fputs (_("\\n<line121>-n, --numeric-uid-gid      like -l, but list numeric user and group IDs\n\\n<line122>-N, --literal              print entry names without quoting\n\\n<line123>-o                         like -l, but do not list group information\n\\n<line124>-p, --indicator-style=slash\n\\n<line125>append / indicator to directories\n\\n<line126>"), stdout);\n<line127>fputs (_("\\n<line128>-q, --hide-control-chars   print ? instead of nongraphic characters\n\\n<line129>"), stdout);\n<line130>fputs (_("\\n<line131>--show-control-chars   show nongraphic characters as-is (the default,\n\\n<line132>unless program is 'ls' and output is a terminal)\\n<line133>\n\\n<line134>\n\\n<line135>"), stdout);\n<line136>fputs (_("\\n<line137>-Q, --quote-name           enclose entry names in double quotes\n\\n<line138>"), stdout);\n<line139>fputs (_("\\n<line140>--quoting-style=WORD   use quoting style WORD for entry names:\n\\n<line141>literal, locale, shell, shell-always,\n\\n<line142>shell-escape, shell-escape-always, c, escape\n\\n<line143>(overrides QUOTING_STYLE environment variable)\n\\n<line144>\n\\n<line145>"), stdout);\n<line146>fputs (_("\\n<line147>-r, --reverse              reverse order while sorting\n\\n<line148>-R, --recursive            list subdirectories recursively\n\\n<line149>-s, --size                 print the allocated size of each file, in blocks\n\\n<line150>"), stdout);\n<line151>fputs (_("\\n<line152>-S                         sort by file size, largest first\n\\n<line153>"), stdout);\n<line154>fputs (_("\\n<line155>--sort=WORD            sort by WORD instead of name: none (-U), size (-S)\\n<line156>,\n\\n<line157>time (-t), version (-v), extension (-X), width\n\\n<line158>\n\\n<line159>"), stdout);\n<line160>fputs (_("\\n<line161>--time=WORD            select which timestamp used to display or sort;\n\\n<line162>access time (-u): atime, access, use;\n\\n<line163>metadata change time (-c): ctime, status;\n\\n<line164>modified time (default): mtime, modification;\n\\n<line165>birth time: birth, creation;\n\\n<line166>with -l, WORD determines which time to show;\n\\n<line167>with --sort=time, sort by WORD (newest first)\n\\n<line168>\n\\n<line169>"), stdout);\n<line170>fputs (_("\\n<line171>--time-style=TIME_STYLE\n\\n<line172>time/date format with -l; see TIME_STYLE below\n\\n<line173>"), stdout);\n<line174>fputs (_("\\n<line175>-t                         sort by time, newest first; see --time\n\\n<line176>-T, --tabsize=COLS         assume tab stops at each COLS instead of 8\n\\n<line177>"), stdout);\n<line178>fputs (_("\\n<line179>-u                         with -lt: sort by, and show, access time;\n\\n<line180>with -l: show access time and sort by name;\n\\n<line181>otherwise: sort by access time, newest first\n\\n<line182>\n\\n<line183>"), stdout);\n<line184>fputs (_("\\n<line185>-U                         do not sort; list entries in directory order\n\\n<line186>"), stdout);\n<line187>fputs (_("\\n<line188>-v                         natural sort of (version) numbers within text\n\\n<line189>"), stdout);\n<line190>fputs (_("\\n<line191>-w, --width=COLS           set output width to COLS.  0 means no limit\n\\n<line192>-x                         list entries by lines instead of by columns\n\\n<line193>-X                         sort alphabetically by entry extension\n\\n<line194>-Z, --context              print any security context of each file\n\\n<line195>--zero                 end each output line with NUL, not newline\n\\n<line196>-1                         list one file per line\n\\n<line197>"), stdout);\n<line198>fputs (HELP_OPTION_DESCRIPTION, stdout);\n<line199>fputs (VERSION_OPTION_DESCRIPTION, stdout);\n<line200>emit_size_note ();\n<line201>fputs (_("\\n<line202>\n\\n<line203>The TIME_STYLE argument can be full-iso, long-iso, iso, locale, or +FORMAT.\n\\n<line204>FORMAT is interpreted like in date(1).  If FORMAT is FORMAT1<newline>FORMAT2,\n\\n<line205>then FORMAT1 applies to non-recent files and FORMAT2 to recent files.\n\\n<line206>TIME_STYLE prefixed with 'posix-' takes effect only outside the POSIX locale.\n\\n<line207>Also the TIME_STYLE environment variable sets the default style to use.\n\\n<line208>"), stdout);\n<line209>fputs (_("\\n<line210>\n\\n<line211>The WHEN argument defaults to 'always' and can also be 'auto' or 'never'.\n\\n<line212>"), stdout);\n<line213>fputs (_("\\n<line214>\n\\n<line215>Using color to distinguish file types is disabled both by default and\n\\n<line216>with --color=never.  With --color=auto, ls emits color codes only when\n\\n<line217>standard output is connected to a terminal.  The LS_COLORS environment\n\\n<line218>variable can change the settings.  Use the dircolors(1) command to set it.\n\\n<line219>"), stdout);\n<line220>fputs (_("\\n<line221>\n\\n<line222>Exit status:\n\\n<line223>0  if OK,\n\\n<line224>1  if minor problems (e.g., cannot access subdirectory),\n\\n<line225>2  if serious trouble (e.g., cannot access command-line argument).\n\\n<line226>"), stdout);\n<line227>emit_ancillary_info (PROGRAM_NAME);\n<line228>}\n<line229>exit (status);\n<line230>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/src/ls-dir.c
========================================
========================================
/home/huihui/Downloads/coreutils-9.4/src/dircolors.c
========================================
/home/huihui/Downloads/coreutils-9.4/src/dircolors.c:69:79: warning: '_Static_assert' with no message is a C2x extension [-Wc2x-extensions]
static_assert (ARRAY_CARDINALITY (slack_codes) == ARRAY_CARDINALITY (ls_codes));
                                                                              ^
                                                                              , ""
1 warning generated.
Function: usage
Content: <line0>void\n<line1>usage (int status)\n<line2>{\n<line3>if (status != EXIT_SUCCESS)\n<line4>emit_try_help ();\n<line5>else\n<line6>{\n<line7>printf (_("Usage: %s [OPTION]... [FILE]\n"), program_name);\n<line8>fputs (_("\\n<line9>Output commands to set the LS_COLORS environment variable.\n\\n<line10>\n\\n<line11>Determine format of output:\n\\n<line12>-b, --sh, --bourne-shell    output Bourne shell code to set LS_COLORS\n\\n<line13>-c, --csh, --c-shell        output C shell code to set LS_COLORS\n\\n<line14>-p, --print-database        output defaults\n\\n<line15>--print-ls-colors       output fully escaped colors for display\n\\n<line16>"), stdout);\n<line17>fputs (HELP_OPTION_DESCRIPTION, stdout);\n<line18>fputs (VERSION_OPTION_DESCRIPTION, stdout);\n<line19>fputs (_("\\n<line20>\n\\n<line21>If FILE is specified, read it to determine which colors to use for which\n\\n<line22>file types and extensions.  Otherwise, a precompiled database is used.\n\\n<line23>For details on the format of these files, run 'dircolors --print-database'.\n\\n<line24>"), stdout);\n<line25>emit_ancillary_info (PROGRAM_NAME);\n<line26>}\n<line27>exit (status);\n<line28>}
----------------------------------------
Function: guess_shell_syntax
Content: <line0>static enum Shell_syntax\n<line1>guess_shell_syntax (void)\n<line2>{\n<line3>char *shell;\n<line4>shell = getenv ("SHELL");\n<line5>if (shell == nullptr || *shell == '\0')\n<line6>return SHELL_SYNTAX_UNKNOWN;\n<line7>shell = last_component (shell);\n<line8>if (STREQ (shell, "csh") || STREQ (shell, "tcsh"))\n<line9>return SHELL_SYNTAX_C;\n<line10>return SHELL_SYNTAX_BOURNE;\n<line11>}
----------------------------------------
Function: parse_line
Content: <line0>static void\n<line1>parse_line (char const *line, char **keyword, char **arg)\n<line2>{\n<line3>char const *p;\n<line4>char const *keyword_start;\n<line5>char const *arg_start;\n<line6>*keyword = nullptr;\n<line7>*arg = nullptr;\n<line8>for (p = line; isspace (to_uchar (*p)); ++p)\n<line9>continue;\n<line10>/* Ignore blank lines and shell-style comments.  */\n<line11>if (*p == '\0' || *p == '#')\n<line12>return;\n<line13>keyword_start = p;\n<line14>while (!isspace (to_uchar (*p)) && *p != '\0')\n<line15>{\n<line16>++p;\n<line17>}\n<line18>*keyword = ximemdup0 (keyword_start, p - keyword_start);\n<line19>if (*p  == '\0')\n<line20>return;\n<line21>do\n<line22>{\n<line23>++p;\n<line24>}\n<line25>while (isspace (to_uchar (*p)));\n<line26>if (*p == '\0' || *p == '#')\n<line27>return;\n<line28>arg_start = p;\n<line29>while (*p != '\0' && *p != '#')\n<line30>++p;\n<line31>for (--p; isspace (to_uchar (*p)); --p)\n<line32>continue;\n<line33>++p;\n<line34>*arg = ximemdup0 (arg_start, p - arg_start);\n<line35>}
----------------------------------------
Function: append_quoted
Content: <line0>static void\n<line1>append_quoted (char const *str)\n<line2>{\n<line3>bool need_backslash = true;\n<line4>while (*str != '\0')\n<line5>{\n<line6>if (! print_ls_colors)\n<line7>switch (*str)\n<line8>{\n<line9>case '\'':\n<line10>APPEND_CHAR ('\'');\n<line11>APPEND_CHAR ('\\');\n<line12>APPEND_CHAR ('\'');\n<line13>need_backslash = true;\n<line14>break;\n<line15>case '\\':\n<line16>case '^':\n<line17>need_backslash = !need_backslash;\n<line18>break;\n<line19>case ':':\n<line20>case '=':\n<line21>if (need_backslash)\n<line22>APPEND_CHAR ('\\');\n<line23>FALLTHROUGH;\n<line24>default:\n<line25>need_backslash = true;\n<line26>break;\n<line27>}\n<line28>APPEND_CHAR (*str);\n<line29>++str;\n<line30>}\n<line31>}
----------------------------------------
Function: append_entry
Content: <line0>static void\n<line1>append_entry (char prefix, char const *item, char const *arg)\n<line2>{\n<line3>if (print_ls_colors)\n<line4>{\n<line5>append_quoted ("\x1B[");\n<line6>append_quoted (arg);\n<line7>APPEND_CHAR ('m');\n<line8>}\n<line9>if (prefix)\n<line10>APPEND_CHAR (prefix);\n<line11>append_quoted (item);\n<line12>APPEND_CHAR (print_ls_colors ? '\t' : '=');\n<line13>append_quoted (arg);\n<line14>if (print_ls_colors)\n<line15>append_quoted ("\x1B[0m");\n<line16>APPEND_CHAR (print_ls_colors ? '\n' : ':');\n<line17>}
----------------------------------------
Function: dc_parse_stream
Content: <line0>static bool\n<line1>dc_parse_stream (FILE *fp, char const *filename)\n<line2>{\n<line3>idx_t line_number = 0;\n<line4>char const *next_G_line = G_line;\n<line5>char *input_line = nullptr;\n<line6>size_t input_line_size = 0;\n<line7>char const *line;\n<line8>char const *term;\n<line9>char const *colorterm;\n<line10>bool ok = true;\n<line11>/* State for the parser.  */\n<line12>enum { ST_TERMNO, ST_TERMYES, ST_TERMSURE, ST_GLOBAL } state = ST_GLOBAL;\n<line13>/* Get terminal type */\n<line14>term = getenv ("TERM");\n<line15>if (term == nullptr || *term == '\0')\n<line16>term = "none";\n<line17>/* Also match $COLORTERM.  */\n<line18>colorterm = getenv ("COLORTERM");\n<line19>if (colorterm == nullptr)\n<line20>colorterm = "";  /* Doesn't match default "?*"  */\n<line21>while (true)\n<line22>{\n<line23>char *keywd, *arg;\n<line24>bool unrecognized;\n<line25>++line_number;\n<line26>if (fp)\n<line27>{\n<line28>if (getline (&input_line, &input_line_size, fp) <= 0)\n<line29>{\n<line30>if (ferror (fp))\n<line31>{\n<line32>error (0, errno, _("%s: read error"), quotef (filename));\n<line33>ok = false;\n<line34>}\n<line35>free (input_line);\n<line36>break;\n<line37>}\n<line38>line = input_line;\n<line39>}\n<line40>else\n<line41>{\n<line42>if (next_G_line == G_line + sizeof G_line)\n<line43>break;\n<line44>line = next_G_line;\n<line45>next_G_line += strlen (next_G_line) + 1;\n<line46>}\n<line47>parse_line (line, &keywd, &arg);\n<line48>if (keywd == nullptr)\n<line49>continue;\n<line50>if (arg == nullptr)\n<line51>{\n<line52>error (0, 0, _("%s:%td: invalid line;  missing second token"),\n<line53>quotef (filename), line_number);\n<line54>ok = false;\n<line55>free (keywd);\n<line56>continue;\n<line57>}\n<line58>unrecognized = false;\n<line59>if (c_strcasecmp (keywd, "TERM") == 0)\n<line60>{\n<line61>if (state != ST_TERMSURE)\n<line62>state = fnmatch (arg, term, 0) == 0 ? ST_TERMSURE : ST_TERMNO;\n<line63>}\n<line64>else if (c_strcasecmp (keywd, "COLORTERM") == 0)\n<line65>{\n<line66>if (state != ST_TERMSURE)\n<line67>state = fnmatch (arg, colorterm, 0) == 0 ? ST_TERMSURE : ST_TERMNO;\n<line68>}\n<line69>else\n<line70>{\n<line71>if (state == ST_TERMSURE)\n<line72>state = ST_TERMYES;  /* Another {COLOR,}TERM can cancel.  */\n<line73>if (state != ST_TERMNO)\n<line74>{\n<line75>if (keywd[0] == '.')\n<line76>append_entry ('*', keywd, arg);\n<line77>else if (keywd[0] == '*')\n<line78>append_entry (0, keywd, arg);\n<line79>else if (c_strcasecmp (keywd, "OPTIONS") == 0\n<line80>|| c_strcasecmp (keywd, "COLOR") == 0\n<line81>|| c_strcasecmp (keywd, "EIGHTBIT") == 0)\n<line82>{\n<line83>/* Ignore.  */\n<line84>}\n<line85>else\n<line86>{\n<line87>int i;\n<line88>for (i = 0; slack_codes[i] != nullptr; ++i)\n<line89>if (c_strcasecmp (keywd, slack_codes[i]) == 0)\n<line90>break;\n<line91>if (slack_codes[i] != nullptr)\n<line92>append_entry (0, ls_codes[i], arg);\n<line93>else\n<line94>unrecognized = true;\n<line95>}\n<line96>}\n<line97>else\n<line98>unrecognized = true;\n<line99>}\n<line100>if (unrecognized && (state == ST_TERMSURE || state == ST_TERMYES))\n<line101>{\n<line102>error (0, 0, _("%s:%td: unrecognized keyword %s"),\n<line103>(filename ? quotef (filename) : _("<internal>")),\n<line104>line_number, keywd);\n<line105>ok = false;\n<line106>}\n<line107>free (keywd);\n<line108>free (arg);\n<line109>}\n<line110>return ok;\n<line111>}
----------------------------------------
Function: dc_parse_file
Content: <line0>static bool\n<line1>dc_parse_file (char const *filename)\n<line2>{\n<line3>bool ok;\n<line4>if (! STREQ (filename, "-") && freopen (filename, "r", stdin) == nullptr)\n<line5>{\n<line6>error (0, errno, "%s", quotef (filename));\n<line7>return false;\n<line8>}\n<line9>ok = dc_parse_stream (stdin, filename);\n<line10>if (fclose (stdin) != 0)\n<line11>{\n<line12>error (0, errno, "%s", quotef (filename));\n<line13>return false;\n<line14>}\n<line15>return ok;\n<line16>}
----------------------------------------
Function: main
Content: <line0>int\n<line1>main (int argc, char **argv)\n<line2>{\n<line3>bool ok = true;\n<line4>int optc;\n<line5>enum Shell_syntax syntax = SHELL_SYNTAX_UNKNOWN;\n<line6>bool print_database = false;\n<line7>initialize_main (&argc, &argv);\n<line8>set_program_name (argv[0]);\n<line9>setlocale (LC_ALL, "");\n<line10>bindtextdomain (PACKAGE, LOCALEDIR);\n<line11>textdomain (PACKAGE);\n<line12>atexit (close_stdout);\n<line13>while ((optc = getopt_long (argc, argv, "bcp", long_options, nullptr)) != -1)\n<line14>switch (optc)\n<line15>{\n<line16>case 'b':	/* Bourne shell syntax.  */\n<line17>syntax = SHELL_SYNTAX_BOURNE;\n<line18>break;\n<line19>case 'c':	/* C shell syntax.  */\n<line20>syntax = SHELL_SYNTAX_C;\n<line21>break;\n<line22>case 'p':\n<line23>print_database = true;\n<line24>break;\n<line25>case PRINT_LS_COLORS_OPTION:\n<line26>print_ls_colors = true;\n<line27>break;\n<line28>case_GETOPT_HELP_CHAR;\n<line29>case_GETOPT_VERSION_CHAR (PROGRAM_NAME, AUTHORS);\n<line30>default:\n<line31>usage (EXIT_FAILURE);\n<line32>}\n<line33>argc -= optind;\n<line34>argv += optind;\n<line35>/* It doesn't make sense to use --print with either of\n<line36>--bourne or --c-shell.  */\n<line37>if ((print_database | print_ls_colors) && syntax != SHELL_SYNTAX_UNKNOWN)\n<line38>{\n<line39>error (0, 0,\n<line40>_("the options to output non shell syntax,\n"\n<line41>"and to select a shell syntax are mutually exclusive"));\n<line42>usage (EXIT_FAILURE);\n<line43>}\n<line44>if (print_database && print_ls_colors)\n<line45>{\n<line46>error (0, 0,\n<line47>_("options --print-database and --print-ls-colors "\n<line48>"are mutually exclusive"));\n<line49>usage (EXIT_FAILURE);\n<line50>}\n<line51>if ((!print_database) < argc)\n<line52>{\n<line53>error (0, 0, _("extra operand %s"),\n<line54>quote (argv[!print_database]));\n<line55>if (print_database)\n<line56>fprintf (stderr, "%s\n",\n<line57>_("file operands cannot be combined with "\n<line58>"--print-database (-p)"));\n<line59>usage (EXIT_FAILURE);\n<line60>}\n<line61>if (print_database)\n<line62>{\n<line63>char const *p = G_line;\n<line64>while (p - G_line < sizeof G_line)\n<line65>{\n<line66>puts (p);\n<line67>p += strlen (p) + 1;\n<line68>}\n<line69>}\n<line70>else\n<line71>{\n<line72>/* If shell syntax was not explicitly specified, try to guess it. */\n<line73>if (syntax == SHELL_SYNTAX_UNKNOWN && ! print_ls_colors)\n<line74>{\n<line75>syntax = guess_shell_syntax ();\n<line76>if (syntax == SHELL_SYNTAX_UNKNOWN)\n<line77>error (EXIT_FAILURE, 0,\n<line78>_("no SHELL environment variable,"\n<line79>" and no shell type option given"));\n<line80>}\n<line81>obstack_init (&lsc_obstack);\n<line82>if (argc == 0)\n<line83>ok = dc_parse_stream (nullptr, nullptr);\n<line84>else\n<line85>ok = dc_parse_file (argv[0]);\n<line86>if (ok)\n<line87>{\n<line88>size_t len = obstack_object_size (&lsc_obstack);\n<line89>char *s = obstack_finish (&lsc_obstack);\n<line90>char const *prefix;\n<line91>char const *suffix;\n<line92>if (syntax == SHELL_SYNTAX_BOURNE)\n<line93>{\n<line94>prefix = "LS_COLORS='";\n<line95>suffix = "';\nexport LS_COLORS\n";\n<line96>}\n<line97>else\n<line98>{\n<line99>prefix = "setenv LS_COLORS '";\n<line100>suffix = "'\n";\n<line101>}\n<line102>if (! print_ls_colors)\n<line103>fputs (prefix, stdout);\n<line104>fwrite (s, 1, len, stdout);\n<line105>if (! print_ls_colors)\n<line106>fputs (suffix, stdout);\n<line107>}\n<line108>}\n<line109>return ok ? EXIT_SUCCESS : EXIT_FAILURE;\n<line110>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/src/dirname.c
========================================
Function: usage
Content: <line0>void\n<line1>usage (int status)\n<line2>{\n<line3>if (status != EXIT_SUCCESS)\n<line4>emit_try_help ();\n<line5>else\n<line6>{\n<line7>printf (_("\\n<line8>Usage: %s [OPTION] NAME...\n\\n<line9>"),\n<line10>program_name);\n<line11>fputs (_("\\n<line12>Output each NAME with its last non-slash component and trailing slashes\n\\n<line13>removed; if NAME contains no /'s, output '.' (meaning the current directory).\n\\n<line14>\n\\n<line15>"), stdout);\n<line16>fputs (_("\\n<line17>-z, --zero     end each output line with NUL, not newline\n\\n<line18>"), stdout);\n<line19>fputs (HELP_OPTION_DESCRIPTION, stdout);\n<line20>fputs (VERSION_OPTION_DESCRIPTION, stdout);\n<line21>printf (_("\\n<line22>\n\\n<line23>Examples:\n\\n<line24>%s /usr/bin/          -> \"/usr\"\n\\n<line25>%s dir1/str dir2/str  -> \"dir1\" followed by \"dir2\"\n\\n<line26>%s stdio.h            -> \".\"\n\\n<line27>"),\n<line28>program_name, program_name, program_name);\n<line29>emit_ancillary_info (PROGRAM_NAME);\n<line30>}\n<line31>exit (status);\n<line32>}
----------------------------------------
Function: main
Content: <line0>int\n<line1>main (int argc, char **argv)\n<line2>{\n<line3>static char const dot = '.';\n<line4>bool use_nuls = false;\n<line5>char const *result;\n<line6>size_t len;\n<line7>initialize_main (&argc, &argv);\n<line8>set_program_name (argv[0]);\n<line9>setlocale (LC_ALL, "");\n<line10>bindtextdomain (PACKAGE, LOCALEDIR);\n<line11>textdomain (PACKAGE);\n<line12>atexit (close_stdout);\n<line13>while (true)\n<line14>{\n<line15>int c = getopt_long (argc, argv, "z", longopts, nullptr);\n<line16>if (c == -1)\n<line17>break;\n<line18>switch (c)\n<line19>{\n<line20>case 'z':\n<line21>use_nuls = true;\n<line22>break;\n<line23>case_GETOPT_HELP_CHAR;\n<line24>case_GETOPT_VERSION_CHAR (PROGRAM_NAME, AUTHORS);\n<line25>default:\n<line26>usage (EXIT_FAILURE);\n<line27>}\n<line28>}\n<line29>if (argc < optind + 1)\n<line30>{\n<line31>error (0, 0, _("missing operand"));\n<line32>usage (EXIT_FAILURE);\n<line33>}\n<line34>for (; optind < argc; optind++)\n<line35>{\n<line36>result = argv[optind];\n<line37>len = dir_len (result);\n<line38>if (! len)\n<line39>{\n<line40>result = &dot;\n<line41>len = 1;\n<line42>}\n<line43>fwrite (result, 1, len, stdout);\n<line44>putchar (use_nuls ? '\0' :'\n');\n<line45>}\n<line46>return EXIT_SUCCESS;\n<line47>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/src/du.c
========================================
In file included from /home/huihui/Downloads/coreutils-9.4/src/du.c:42:
In file included from ./lib/xfts.h:1:
In file included from ./lib/fts_.h:83:
./lib/i-ring.h:24:32: warning: '_Static_assert' with no message is a C2x extension [-Wc2x-extensions]
static_assert (1 <= I_RING_SIZE);
                               ^
                               , ""
/home/huihui/Downloads/coreutils-9.4/src/du.c:254:1: warning: '_Static_assert' with no message is a C2x extension [-Wc2x-extensions]
ARGMATCH_VERIFY (time_args, time_types);
^
./lib/argmatch.h:49:54: note: expanded from macro 'ARGMATCH_VERIFY'
                   == ARRAY_CARDINALITY (Vallist) + 1)
                                                     ^
/home/huihui/Downloads/coreutils-9.4/src/du.c:274:1: warning: '_Static_assert' with no message is a C2x extension [-Wc2x-extensions]
ARGMATCH_VERIFY (time_style_args, time_style_types);
^
./lib/argmatch.h:49:54: note: expanded from macro 'ARGMATCH_VERIFY'
                   == ARRAY_CARDINALITY (Vallist) + 1)
                                                     ^
3 warnings generated.
Function: duinfo_init
Content: <line0>static inline void\n<line1>duinfo_init (struct duinfo *a)\n<line2>{\n<line3>a->size = 0;\n<line4>a->inodes = 0;\n<line5>a->tmax.tv_sec = TYPE_MINIMUM (time_t);\n<line6>a->tmax.tv_nsec = -1;\n<line7>}
----------------------------------------
Function: duinfo_set
Content: <line0>static inline void\n<line1>duinfo_set (struct duinfo *a, uintmax_t size, struct timespec tmax)\n<line2>{\n<line3>a->size = size;\n<line4>a->inodes = 1;\n<line5>a->tmax = tmax;\n<line6>}
----------------------------------------
Function: duinfo_add
Content: <line0>static inline void\n<line1>duinfo_add (struct duinfo *a, struct duinfo const *b)\n<line2>{\n<line3>uintmax_t sum = a->size + b->size;\n<line4>a->size = a->size <= sum ? sum : UINTMAX_MAX;\n<line5>a->inodes = a->inodes + b->inodes;\n<line6>if (timespec_cmp (a->tmax, b->tmax) < 0)\n<line7>a->tmax = b->tmax;\n<line8>}
----------------------------------------
Function: usage
Content: <line0>void\n<line1>usage (int status)\n<line2>{\n<line3>if (status != EXIT_SUCCESS)\n<line4>emit_try_help ();\n<line5>else\n<line6>{\n<line7>printf (_("\\n<line8>Usage: %s [OPTION]... [FILE]...\n\\n<line9>or:  %s [OPTION]... --files0-from=F\n\\n<line10>"), program_name, program_name);\n<line11>fputs (_("\\n<line12>Summarize device usage of the set of FILEs, recursively for directories.\n\\n<line13>"), stdout);\n<line14>emit_mandatory_arg_note ();\n<line15>fputs (_("\\n<line16>-0, --null            end each output line with NUL, not newline\n\\n<line17>-a, --all             write counts for all files, not just directories\n\\n<line18>--apparent-size   print apparent sizes rather than device usage; although\\n<line19>\n\\n<line20>the apparent size is usually smaller, it may be\n\\n<line21>larger due to holes in ('sparse') files, internal\n\\n<line22>fragmentation, indirect blocks, and the like\n\\n<line23>"), stdout);\n<line24>fputs (_("\\n<line25>-B, --block-size=SIZE  scale sizes by SIZE before printing them; e.g.,\n\\n<line26>'-BM' prints sizes in units of 1,048,576 bytes;\n\\n<line27>see SIZE format below\n\\n<line28>-b, --bytes           equivalent to '--apparent-size --block-size=1'\n\\n<line29>-c, --total           produce a grand total\n\\n<line30>-D, --dereference-args  dereference only symlinks that are listed on the\n\\n<line31>command line\n\\n<line32>-d, --max-depth=N     print the total for a directory (or file, with --all)\n\\n<line33>only if it is N or fewer levels below the command\n\\n<line34>line argument;  --max-depth=0 is the same as\n\\n<line35>--summarize\n\\n<line36>"), stdout);\n<line37>fputs (_("\\n<line38>--files0-from=F   summarize device usage of the\n\\n<line39>NUL-terminated file names specified in file F;\n\\n<line40>if F is -, then read names from standard input\n\\n<line41>-H                    equivalent to --dereference-args (-D)\n\\n<line42>-h, --human-readable  print sizes in human readable format (e.g., 1K 234M 2G)\\n<line43>\n\\n<line44>--inodes          list inode usage information instead of block usage\n\\n<line45>"), stdout);\n<line46>fputs (_("\\n<line47>-k                    like --block-size=1K\n\\n<line48>-L, --dereference     dereference all symbolic links\n\\n<line49>-l, --count-links     count sizes many times if hard linked\n\\n<line50>-m                    like --block-size=1M\n\\n<line51>"), stdout);\n<line52>fputs (_("\\n<line53>-P, --no-dereference  don't follow any symbolic links (this is the default)\n\\n<line54>-S, --separate-dirs   for directories do not include size of subdirectories\n\\n<line55>--si              like -h, but use powers of 1000 not 1024\n\\n<line56>-s, --summarize       display only a total for each argument\n\\n<line57>"), stdout);\n<line58>fputs (_("\\n<line59>-t, --threshold=SIZE  exclude entries smaller than SIZE if positive,\n\\n<line60>or entries greater than SIZE if negative\n\\n<line61>--time            show time of the last modification of any file in the\n\\n<line62>directory, or any of its subdirectories\n\\n<line63>--time=WORD       show time as WORD instead of modification time:\n\\n<line64>atime, access, use, ctime or status\n\\n<line65>--time-style=STYLE  show times using STYLE, which can be:\n\\n<line66>full-iso, long-iso, iso, or +FORMAT;\n\\n<line67>FORMAT is interpreted like in 'date'\n\\n<line68>"), stdout);\n<line69>fputs (_("\\n<line70>-X, --exclude-from=FILE  exclude files that match any pattern in FILE\n\\n<line71>--exclude=PATTERN    exclude files that match PATTERN\n\\n<line72>-x, --one-file-system    skip directories on different file systems\n\\n<line73>"), stdout);\n<line74>fputs (HELP_OPTION_DESCRIPTION, stdout);\n<line75>fputs (VERSION_OPTION_DESCRIPTION, stdout);\n<line76>emit_blocksize_note ("DU");\n<line77>emit_size_note ();\n<line78>emit_ancillary_info (PROGRAM_NAME);\n<line79>}\n<line80>exit (status);\n<line81>}
----------------------------------------
Function: hash_ins
Content: <line0>static bool\n<line1>hash_ins (struct di_set *di_set, ino_t ino, dev_t dev)\n<line2>{\n<line3>int inserted = di_set_insert (di_set, dev, ino);\n<line4>if (inserted < 0)\n<line5>xalloc_die ();\n<line6>return inserted;\n<line7>}
----------------------------------------
Function: show_date
Content: <line0>static void\n<line1>show_date (char const *format, struct timespec when, timezone_t tz)\n<line2>{\n<line3>struct tm tm;\n<line4>if (localtime_rz (tz, &when.tv_sec, &tm))\n<line5>fprintftime (stdout, format, &tm, tz, when.tv_nsec);\n<line6>else\n<line7>{\n<line8>char buf[INT_BUFSIZE_BOUND (intmax_t)];\n<line9>char *when_str = timetostr (when.tv_sec, buf);\n<line10>error (0, 0, _("time %s is out of range"), quote (when_str));\n<line11>fputs (when_str, stdout);\n<line12>}\n<line13>}
----------------------------------------
Function: print_only_size
Content: <line0>static void\n<line1>print_only_size (uintmax_t n_bytes)\n<line2>{\n<line3>char buf[LONGEST_HUMAN_READABLE + 1];\n<line4>fputs ((n_bytes == UINTMAX_MAX\n<line5>? _("Infinity")\n<line6>: human_readable (n_bytes, buf, human_output_opts,\n<line7>1, output_block_size)),\n<line8>stdout);\n<line9>}
----------------------------------------
Function: print_size
Content: <line0>static void\n<line1>print_size (const struct duinfo *pdui, char const *string)\n<line2>{\n<line3>print_only_size (opt_inodes\n<line4>? pdui->inodes\n<line5>: pdui->size);\n<line6>if (opt_time)\n<line7>{\n<line8>putchar ('\t');\n<line9>show_date (time_format, pdui->tmax, localtz);\n<line10>}\n<line11>printf ("\t%s%c", string, opt_nul_terminate_output ? '\0' : '\n');\n<line12>fflush (stdout);\n<line13>}
----------------------------------------
Function: fill_mount_table
Content: <line0>static void\n<line1>fill_mount_table (void)\n<line2>{\n<line3>struct mount_entry *mnt_ent = read_file_system_list (false);\n<line4>while (mnt_ent)\n<line5>{\n<line6>struct mount_entry *mnt_free;\n<line7>if (!mnt_ent->me_remote && !mnt_ent->me_dummy)\n<line8>{\n<line9>struct stat buf;\n<line10>if (!stat (mnt_ent->me_mountdir, &buf))\n<line11>hash_ins (di_mnt, buf.st_ino, buf.st_dev);\n<line12>else\n<line13>{\n<line14>/* Ignore stat failure.  False positives are too common.\n<line15>E.g., "Permission denied" on /run/user/<name>/gvfs.  */\n<line16>}\n<line17>}\n<line18>mnt_free = mnt_ent;\n<line19>mnt_ent = mnt_ent->me_next;\n<line20>free_mount_entry (mnt_free);\n<line21>}\n<line22>}
----------------------------------------
Function: mount_point_in_fts_cycle
Content: <line0>static bool\n<line1>mount_point_in_fts_cycle (FTSENT const *ent)\n<line2>{\n<line3>FTSENT const *cycle_ent = ent->fts_cycle;\n<line4>if (!di_mnt)\n<line5>{\n<line6>/* Initialize the set of dev,inode pairs.  */\n<line7>di_mnt = di_set_alloc ();\n<line8>if (!di_mnt)\n<line9>xalloc_die ();\n<line10>fill_mount_table ();\n<line11>}\n<line12>while (ent && ent != cycle_ent)\n<line13>{\n<line14>if (di_set_lookup (di_mnt, ent->fts_statp->st_dev,\n<line15>ent->fts_statp->st_ino) > 0)\n<line16>{\n<line17>return true;\n<line18>}\n<line19>ent = ent->fts_parent;\n<line20>}\n<line21>return false;\n<line22>}
----------------------------------------
Function: process_file
Content: <line0>static bool\n<line1>process_file (FTS *fts, FTSENT *ent)\n<line2>{\n<line3>bool ok = true;\n<line4>struct duinfo dui;\n<line5>struct duinfo dui_to_print;\n<line6>size_t level;\n<line7>static size_t n_alloc;\n<line8>/* First element of the structure contains:\n<line9>The sum of the sizes of all entries in the single directory\n<line10>at the corresponding level.  Although this does include the sizes\n<line11>corresponding to each subdirectory, it does not include the size of\n<line12>any file in a subdirectory. Also corresponding last modified date.\n<line13>Second element of the structure contains:\n<line14>The sum of the sizes of all entries in the hierarchy at or below the\n<line15>directory at the specified level.  */\n<line16>static struct dulevel *dulvl;\n<line17>char const *file = ent->fts_path;\n<line18>const struct stat *sb = ent->fts_statp;\n<line19>int info = ent->fts_info;\n<line20>if (info == FTS_DNR)\n<line21>{\n<line22>/* An error occurred, but the size is known, so count it.  */\n<line23>error (0, ent->fts_errno, _("cannot read directory %s"), quoteaf (file));\n<line24>ok = false;\n<line25>}\n<line26>else if (info != FTS_DP)\n<line27>{\n<line28>bool excluded = excluded_file_name (exclude, file);\n<line29>if (! excluded)\n<line30>{\n<line31>/* Make the stat buffer *SB valid, or fail noisily.  */\n<line32>if (info == FTS_NSOK)\n<line33>{\n<line34>fts_set (fts, ent, FTS_AGAIN);\n<line35>MAYBE_UNUSED FTSENT const *e = fts_read (fts);\n<line36>affirm (e == ent);\n<line37>info = ent->fts_info;\n<line38>}\n<line39>if (info == FTS_NS || info == FTS_SLNONE)\n<line40>{\n<line41>error (0, ent->fts_errno, _("cannot access %s"), quoteaf (file));\n<line42>return false;\n<line43>}\n<line44>/* The --one-file-system (-x) option cannot exclude anything\n<line45>specified on the command-line.  By definition, it can exclude\n<line46>a file or directory only when its device number is different\n<line47>from that of its just-processed parent directory, and du does\n<line48>not process the parent of a command-line argument.  */\n<line49>if (fts->fts_options & FTS_XDEV\n<line50>&& FTS_ROOTLEVEL < ent->fts_level\n<line51>&& fts->fts_dev != sb->st_dev)\n<line52>excluded = true;\n<line53>}\n<line54>if (excluded\n<line55>|| (! opt_count_all\n<line56>&& (hash_all || (! S_ISDIR (sb->st_mode) && 1 < sb->st_nlink))\n<line57>&& ! hash_ins (di_files, sb->st_ino, sb->st_dev)))\n<line58>{\n<line59>/* If ignoring a directory in preorder, skip its children.\n<line60>Ignore the next fts_read output too, as it's a postorder\n<line61>visit to the same directory.  */\n<line62>if (info == FTS_D)\n<line63>{\n<line64>fts_set (fts, ent, FTS_SKIP);\n<line65>MAYBE_UNUSED FTSENT const *e = fts_read (fts);\n<line66>affirm (e == ent);\n<line67>}\n<line68>return true;\n<line69>}\n<line70>switch (info)\n<line71>{\n<line72>case FTS_D:\n<line73>return true;\n<line74>case FTS_ERR:\n<line75>/* An error occurred, but the size is known, so count it.  */\n<line76>error (0, ent->fts_errno, "%s", quotef (file));\n<line77>ok = false;\n<line78>break;\n<line79>case FTS_DC:\n<line80>/* If not following symlinks and not a (bind) mount point.  */\n<line81>if (cycle_warning_required (fts, ent)\n<line82>&& ! mount_point_in_fts_cycle (ent))\n<line83>{\n<line84>emit_cycle_warning (file);\n<line85>return false;\n<line86>}\n<line87>return true;\n<line88>}\n<line89>}\n<line90>duinfo_set (&dui,\n<line91>(apparent_size\n<line92>? (usable_st_size (sb) ? MAX (0, sb->st_size) : 0)\n<line93>: (uintmax_t) ST_NBLOCKS (*sb) * ST_NBLOCKSIZE),\n<line94>(time_type == time_mtime ? get_stat_mtime (sb)\n<line95>: time_type == time_atime ? get_stat_atime (sb)\n<line96>: get_stat_ctime (sb)));\n<line97>level = ent->fts_level;\n<line98>dui_to_print = dui;\n<line99>if (n_alloc == 0)\n<line100>{\n<line101>n_alloc = level + 10;\n<line102>dulvl = xcalloc (n_alloc, sizeof *dulvl);\n<line103>}\n<line104>else\n<line105>{\n<line106>if (level == prev_level)\n<line107>{\n<line108>/* This is usually the most common case.  Do nothing.  */\n<line109>}\n<line110>else if (level > prev_level)\n<line111>{\n<line112>/* Descending the hierarchy.\n<line113>Clear the accumulators for *all* levels between prev_level\n<line114>and the current one.  The depth may change dramatically,\n<line115>e.g., from 1 to 10.  */\n<line116>if (n_alloc <= level)\n<line117>{\n<line118>dulvl = xnrealloc (dulvl, level, 2 * sizeof *dulvl);\n<line119>n_alloc = level * 2;\n<line120>}\n<line121>for (size_t i = prev_level + 1; i <= level; i++)\n<line122>{\n<line123>duinfo_init (&dulvl[i].ent);\n<line124>duinfo_init (&dulvl[i].subdir);\n<line125>}\n<line126>}\n<line127>else /* level < prev_level */\n<line128>{\n<line129>/* Ascending the hierarchy.\n<line130>Process a directory only after all entries in that\n<line131>directory have been processed.  When the depth decreases,\n<line132>propagate sums from the children (prev_level) to the parent.\n<line133>Here, the current level is always one smaller than the\n<line134>previous one.  */\n<line135>affirm (level == prev_level - 1);\n<line136>duinfo_add (&dui_to_print, &dulvl[prev_level].ent);\n<line137>if (!opt_separate_dirs)\n<line138>duinfo_add (&dui_to_print, &dulvl[prev_level].subdir);\n<line139>duinfo_add (&dulvl[level].subdir, &dulvl[prev_level].ent);\n<line140>duinfo_add (&dulvl[level].subdir, &dulvl[prev_level].subdir);\n<line141>}\n<line142>}\n<line143>prev_level = level;\n<line144>/* Let the size of a directory entry contribute to the total for the\n<line145>containing directory, unless --separate-dirs (-S) is specified.  */\n<line146>if (! (opt_separate_dirs && IS_DIR_TYPE (info)))\n<line147>duinfo_add (&dulvl[level].ent, &dui);\n<line148>/* Even if this directory is unreadable or we can't chdir into it,\n<line149>do let its size contribute to the total. */\n<line150>duinfo_add (&tot_dui, &dui);\n<line151>if ((IS_DIR_TYPE (info) && level <= max_depth)\n<line152>|| (opt_all && level <= max_depth)\n<line153>|| level == 0)\n<line154>{\n<line155>/* Print or elide this entry according to the --threshold option.  */\n<line156>uintmax_t v = opt_inodes ? dui_to_print.inodes : dui_to_print.size;\n<line157>if (opt_threshold < 0\n<line158>? v <= -opt_threshold\n<line159>: v >= opt_threshold)\n<line160>print_size (&dui_to_print, file);\n<line161>}\n<line162>return ok;\n<line163>}
----------------------------------------
Function: du_files
Content: <line0>static bool\n<line1>du_files (char **files, int bit_flags)\n<line2>{\n<line3>bool ok = true;\n<line4>if (*files)\n<line5>{\n<line6>FTS *fts = xfts_open (files, bit_flags, nullptr);\n<line7>while (true)\n<line8>{\n<line9>FTSENT *ent;\n<line10>ent = fts_read (fts);\n<line11>if (ent == nullptr)\n<line12>{\n<line13>if (errno != 0)\n<line14>{\n<line15>error (0, errno, _("fts_read failed: %s"),\n<line16>quotef (fts->fts_path));\n<line17>ok = false;\n<line18>}\n<line19>/* When exiting this loop early, be careful to reset the\n<line20>global, prev_level, used in process_file.  Otherwise, its\n<line21>(level == prev_level - 1) assertion could fail.  */\n<line22>prev_level = 0;\n<line23>break;\n<line24>}\n<line25>FTS_CROSS_CHECK (fts);\n<line26>ok &= process_file (fts, ent);\n<line27>}\n<line28>if (fts_close (fts) != 0)\n<line29>{\n<line30>error (0, errno, _("fts_close failed"));\n<line31>ok = false;\n<line32>}\n<line33>}\n<line34>return ok;\n<line35>}
----------------------------------------
Function: main
Content: <line0>int\n<line1>main (int argc, char **argv)\n<line2>{\n<line3>char *cwd_only[2];\n<line4>bool max_depth_specified = false;\n<line5>bool ok = true;\n<line6>char *files_from = nullptr;\n<line7>/* Bit flags that control how fts works.  */\n<line8>int bit_flags = FTS_NOSTAT;\n<line9>/* Select one of the three FTS_ options that control if/when\n<line10>to follow a symlink.  */\n<line11>int symlink_deref_bits = FTS_PHYSICAL;\n<line12>/* If true, display only a total for each argument. */\n<line13>bool opt_summarize_only = false;\n<line14>cwd_only[0] = bad_cast (".");\n<line15>cwd_only[1] = nullptr;\n<line16>initialize_main (&argc, &argv);\n<line17>set_program_name (argv[0]);\n<line18>setlocale (LC_ALL, "");\n<line19>bindtextdomain (PACKAGE, LOCALEDIR);\n<line20>textdomain (PACKAGE);\n<line21>atexit (close_stdout);\n<line22>exclude = new_exclude ();\n<line23>human_options (getenv ("DU_BLOCK_SIZE"),\n<line24>&human_output_opts, &output_block_size);\n<line25>while (true)\n<line26>{\n<line27>int oi = -1;\n<line28>int c = getopt_long (argc, argv, "0abd:chHklmst:xB:DLPSX:",\n<line29>long_options, &oi);\n<line30>if (c == -1)\n<line31>break;\n<line32>switch (c)\n<line33>{\n<line34>#if DU_DEBUG\n<line35>case FTS_DEBUG:\n<line36>fts_debug = true;\n<line37>break;\n<line38>#endif\n<line39>case '0':\n<line40>opt_nul_terminate_output = true;\n<line41>break;\n<line42>case 'a':\n<line43>opt_all = true;\n<line44>break;\n<line45>case APPARENT_SIZE_OPTION:\n<line46>apparent_size = true;\n<line47>break;\n<line48>case 'b':\n<line49>apparent_size = true;\n<line50>human_output_opts = 0;\n<line51>output_block_size = 1;\n<line52>break;\n<line53>case 'c':\n<line54>print_grand_total = true;\n<line55>break;\n<line56>case 'h':\n<line57>human_output_opts = human_autoscale | human_SI | human_base_1024;\n<line58>output_block_size = 1;\n<line59>break;\n<line60>case HUMAN_SI_OPTION:\n<line61>human_output_opts = human_autoscale | human_SI;\n<line62>output_block_size = 1;\n<line63>break;\n<line64>case 'k':\n<line65>human_output_opts = 0;\n<line66>output_block_size = 1024;\n<line67>break;\n<line68>case 'd':		/* --max-depth=N */\n<line69>{\n<line70>intmax_t tmp;\n<line71>if (xstrtoimax (optarg, nullptr, 0, &tmp, "") == LONGINT_OK\n<line72>&& tmp <= IDX_MAX)\n<line73>{\n<line74>max_depth_specified = true;\n<line75>max_depth = tmp;\n<line76>}\n<line77>else\n<line78>{\n<line79>error (0, 0, _("invalid maximum depth %s"),\n<line80>quote (optarg));\n<line81>ok = false;\n<line82>}\n<line83>}\n<line84>break;\n<line85>case 'm':\n<line86>human_output_opts = 0;\n<line87>output_block_size = 1024 * 1024;\n<line88>break;\n<line89>case 'l':\n<line90>opt_count_all = true;\n<line91>break;\n<line92>case 's':\n<line93>opt_summarize_only = true;\n<line94>break;\n<line95>case 't':\n<line96>{\n<line97>enum strtol_error e;\n<line98>e = xstrtoimax (optarg, nullptr, 0, &opt_threshold,\n<line99>"kKmMGTPEZYRQ0");\n<line100>if (e != LONGINT_OK)\n<line101>xstrtol_fatal (e, oi, c, long_options, optarg);\n<line102>if (opt_threshold == 0 && *optarg == '-')\n<line103>{\n<line104>/* Do not allow -0, as this wouldn't make sense anyway.  */\n<line105>error (EXIT_FAILURE, 0, _("invalid --threshold argument '-0'"));\n<line106>}\n<line107>}\n<line108>break;\n<line109>case 'x':\n<line110>bit_flags |= FTS_XDEV;\n<line111>break;\n<line112>case 'B':\n<line113>{\n<line114>enum strtol_error e = human_options (optarg, &human_output_opts,\n<line115>&output_block_size);\n<line116>if (e != LONGINT_OK)\n<line117>xstrtol_fatal (e, oi, c, long_options, optarg);\n<line118>}\n<line119>break;\n<line120>case 'H':  /* NOTE: before 2008-12, -H was equivalent to --si.  */\n<line121>case 'D':\n<line122>symlink_deref_bits = FTS_COMFOLLOW | FTS_PHYSICAL;\n<line123>break;\n<line124>case 'L': /* --dereference */\n<line125>symlink_deref_bits = FTS_LOGICAL;\n<line126>break;\n<line127>case 'P': /* --no-dereference */\n<line128>symlink_deref_bits = FTS_PHYSICAL;\n<line129>break;\n<line130>case 'S':\n<line131>opt_separate_dirs = true;\n<line132>break;\n<line133>case 'X':\n<line134>if (add_exclude_file (add_exclude, exclude, optarg,\n<line135>EXCLUDE_WILDCARDS, '\n'))\n<line136>{\n<line137>error (0, errno, "%s", quotef (optarg));\n<line138>ok = false;\n<line139>}\n<line140>break;\n<line141>case FILES0_FROM_OPTION:\n<line142>files_from = optarg;\n<line143>break;\n<line144>case EXCLUDE_OPTION:\n<line145>add_exclude (exclude, optarg, EXCLUDE_WILDCARDS);\n<line146>break;\n<line147>case INODES_OPTION:\n<line148>opt_inodes = true;\n<line149>break;\n<line150>case TIME_OPTION:\n<line151>opt_time = true;\n<line152>time_type =\n<line153>(optarg\n<line154>? XARGMATCH ("--time", optarg, time_args, time_types)\n<line155>: time_mtime);\n<line156>localtz = tzalloc (getenv ("TZ"));\n<line157>break;\n<line158>case TIME_STYLE_OPTION:\n<line159>time_style = optarg;\n<line160>break;\n<line161>case_GETOPT_HELP_CHAR;\n<line162>case_GETOPT_VERSION_CHAR (PROGRAM_NAME, AUTHORS);\n<line163>default:\n<line164>ok = false;\n<line165>}\n<line166>}\n<line167>if (!ok)\n<line168>usage (EXIT_FAILURE);\n<line169>if (opt_all && opt_summarize_only)\n<line170>{\n<line171>error (0, 0, _("cannot both summarize and show all entries"));\n<line172>usage (EXIT_FAILURE);\n<line173>}\n<line174>if (opt_summarize_only && max_depth_specified && max_depth == 0)\n<line175>{\n<line176>error (0, 0,\n<line177>_("warning: summarizing is the same as using --max-depth=0"));\n<line178>}\n<line179>if (opt_summarize_only && max_depth_specified && max_depth != 0)\n<line180>{\n<line181>error (0, 0, _("warning: summarizing conflicts with --max-depth=%td"),\n<line182>max_depth);\n<line183>usage (EXIT_FAILURE);\n<line184>}\n<line185>if (opt_summarize_only)\n<line186>max_depth = 0;\n<line187>if (opt_inodes)\n<line188>{\n<line189>if (apparent_size)\n<line190>{\n<line191>error (0, 0, _("warning: options --apparent-size and -b are "\n<line192>"ineffective with --inodes"));\n<line193>}\n<line194>output_block_size = 1;\n<line195>}\n<line196>/* Process time style if printing last times.  */\n<line197>if (opt_time)\n<line198>{\n<line199>if (! time_style)\n<line200>{\n<line201>time_style = getenv ("TIME_STYLE");\n<line202>/* Ignore TIMESTYLE="locale", for compatibility with ls.  */\n<line203>if (! time_style || STREQ (time_style, "locale"))\n<line204>time_style = "long-iso";\n<line205>else if (*time_style == '+')\n<line206>{\n<line207>/* Ignore anything after a newline, for compatibility\n<line208>with ls.  */\n<line209>char *p = strchr (time_style, '\n');\n<line210>if (p)\n<line211>*p = '\0';\n<line212>}\n<line213>else\n<line214>{\n<line215>/* Ignore "posix-" prefix, for compatibility with ls.  */\n<line216>static char const posix_prefix[] = "posix-";\n<line217>static const size_t prefix_len = sizeof posix_prefix - 1;\n<line218>while (STREQ_LEN (time_style, posix_prefix, prefix_len))\n<line219>time_style += prefix_len;\n<line220>}\n<line221>}\n<line222>if (*time_style == '+')\n<line223>time_format = time_style + 1;\n<line224>else\n<line225>{\n<line226>switch (XARGMATCH ("time style", time_style,\n<line227>time_style_args, time_style_types))\n<line228>{\n<line229>case full_iso_time_style:\n<line230>time_format = "%Y-%m-%d %H:%M:%S.%N %z";\n<line231>break;\n<line232>case long_iso_time_style:\n<line233>time_format = "%Y-%m-%d %H:%M";\n<line234>break;\n<line235>case iso_time_style:\n<line236>time_format = "%Y-%m-%d";\n<line237>break;\n<line238>}\n<line239>}\n<line240>}\n<line241>struct argv_iterator *ai;\n<line242>if (files_from)\n<line243>{\n<line244>/* When using --files0-from=F, you may not specify any files\n<line245>on the command-line.  */\n<line246>if (optind < argc)\n<line247>{\n<line248>error (0, 0, _("extra operand %s"), quote (argv[optind]));\n<line249>fprintf (stderr, "%s\n",\n<line250>_("file operands cannot be combined with --files0-from"));\n<line251>usage (EXIT_FAILURE);\n<line252>}\n<line253>if (! (STREQ (files_from, "-") || freopen (files_from, "r", stdin)))\n<line254>error (EXIT_FAILURE, errno, _("cannot open %s for reading"),\n<line255>quoteaf (files_from));\n<line256>ai = argv_iter_init_stream (stdin);\n<line257>/* It's not easy here to count the arguments, so assume the\n<line258>worst.  */\n<line259>hash_all = true;\n<line260>}\n<line261>else\n<line262>{\n<line263>char **files = (optind < argc ? argv + optind : cwd_only);\n<line264>ai = argv_iter_init_argv (files);\n<line265>/* Hash all dev,ino pairs if there are multiple arguments, or if\n<line266>following non-command-line symlinks, because in either case a\n<line267>file with just one hard link might be seen more than once.  */\n<line268>hash_all = (optind + 1 < argc || symlink_deref_bits == FTS_LOGICAL);\n<line269>}\n<line270>if (!ai)\n<line271>xalloc_die ();\n<line272>/* Initialize the set of dev,inode pairs.  */\n<line273>di_files = di_set_alloc ();\n<line274>if (!di_files)\n<line275>xalloc_die ();\n<line276>/* If not hashing everything, process_file won't find cycles on its\n<line277>own, so ask fts_read to check for them accurately.  */\n<line278>if (opt_count_all || ! hash_all)\n<line279>bit_flags |= FTS_TIGHT_CYCLE_CHECK;\n<line280>bit_flags |= symlink_deref_bits;\n<line281>static char *temp_argv[] = { nullptr, nullptr };\n<line282>while (true)\n<line283>{\n<line284>bool skip_file = false;\n<line285>enum argv_iter_err ai_err;\n<line286>char *file_name = argv_iter (ai, &ai_err);\n<line287>if (!file_name)\n<line288>{\n<line289>switch (ai_err)\n<line290>{\n<line291>case AI_ERR_EOF:\n<line292>goto argv_iter_done;\n<line293>case AI_ERR_READ:\n<line294>error (0, errno, _("%s: read error"),\n<line295>quotef (files_from));\n<line296>ok = false;\n<line297>goto argv_iter_done;\n<line298>case AI_ERR_MEM:\n<line299>xalloc_die ();\n<line300>default:\n<line301>affirm (!"unexpected error code from argv_iter");\n<line302>}\n<line303>}\n<line304>if (files_from && STREQ (files_from, "-") && STREQ (file_name, "-"))\n<line305>{\n<line306>/* Give a better diagnostic in an unusual case:\n<line307>printf - | du --files0-from=- */\n<line308>error (0, 0, _("when reading file names from stdin, "\n<line309>"no file name of %s allowed"),\n<line310>quoteaf (file_name));\n<line311>skip_file = true;\n<line312>}\n<line313>/* Report and skip any empty file names before invoking fts.\n<line314>This works around a glitch in fts, which fails immediately\n<line315>(without looking at the other file names) when given an empty\n<line316>file name.  */\n<line317>if (!file_name[0])\n<line318>{\n<line319>/* Diagnose a zero-length file name.  When it's one\n<line320>among many, knowing the record number may help.\n<line321>FIXME: currently print the record number only with\n<line322>--files0-from=FILE.  Maybe do it for argv, too?  */\n<line323>if (files_from == nullptr)\n<line324>error (0, 0, "%s", _("invalid zero-length file name"));\n<line325>else\n<line326>{\n<line327>/* Using the standard 'filename:line-number:' prefix here is\n<line328>not totally appropriate, since NUL is the separator, not NL,\n<line329>but it might be better than nothing.  */\n<line330>idx_t file_number = argv_iter_n_args (ai);\n<line331>error (0, 0, "%s:%td: %s", quotef (files_from),\n<line332>file_number, _("invalid zero-length file name"));\n<line333>}\n<line334>skip_file = true;\n<line335>}\n<line336>if (skip_file)\n<line337>ok = false;\n<line338>else\n<line339>{\n<line340>temp_argv[0] = file_name;\n<line341>ok &= du_files (temp_argv, bit_flags);\n<line342>}\n<line343>}\n<line344>argv_iter_done:\n<line345>argv_iter_free (ai);\n<line346>di_set_free (di_files);\n<line347>if (di_mnt)\n<line348>di_set_free (di_mnt);\n<line349>if (files_from && (ferror (stdin) || fclose (stdin) != 0) && ok)\n<line350>error (EXIT_FAILURE, 0, _("error reading %s"), quoteaf (files_from));\n<line351>if (print_grand_total)\n<line352>print_size (&tot_dui, _("total"));\n<line353>return ok ? EXIT_SUCCESS : EXIT_FAILURE;\n<line354>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/src/echo.c
========================================
Function: usage
Content: <line0>void\n<line1>usage (int status)\n<line2>{\n<line3>/* STATUS should always be EXIT_SUCCESS (unlike in most other\n<line4>utilities which would call emit_try_help otherwise).  */\n<line5>affirm (status == EXIT_SUCCESS);\n<line6>printf (_("\\n<line7>Usage: %s [SHORT-OPTION]... [STRING]...\n\\n<line8>or:  %s LONG-OPTION\n\\n<line9>"), program_name, program_name);\n<line10>fputs (_("\\n<line11>Echo the STRING(s) to standard output.\n\\n<line12>\n\\n<line13>-n             do not output the trailing newline\n\\n<line14>"), stdout);\n<line15>fputs (_(DEFAULT_ECHO_TO_XPG\n<line16>? N_("\\n<line17>-e             enable interpretation of backslash escapes (default)\n\\n<line18>-E             disable interpretation of backslash escapes\n")\n<line19>: N_("\\n<line20>-e             enable interpretation of backslash escapes\n\\n<line21>-E             disable interpretation of backslash escapes (default)\n")),\n<line22>stdout);\n<line23>fputs (HELP_OPTION_DESCRIPTION, stdout);\n<line24>fputs (VERSION_OPTION_DESCRIPTION, stdout);\n<line25>fputs (_("\\n<line26>\n\\n<line27>If -e is in effect, the following sequences are recognized:\n\\n<line28>\n\\n<line29>"), stdout);\n<line30>fputs (_("\\n<line31>\\\\      backslash\n\\n<line32>\\a      alert (BEL)\n\\n<line33>\\b      backspace\n\\n<line34>\\c      produce no further output\n\\n<line35>\\e      escape\n\\n<line36>\\f      form feed\n\\n<line37>\\n      new line\n\\n<line38>\\r      carriage return\n\\n<line39>\\t      horizontal tab\n\\n<line40>\\v      vertical tab\n\\n<line41>"), stdout);\n<line42>fputs (_("\\n<line43>\\0NNN   byte with octal value NNN (1 to 3 digits)\n\\n<line44>\\xHH    byte with hexadecimal value HH (1 to 2 digits)\n\\n<line45>"), stdout);\n<line46>printf (USAGE_BUILTIN_WARNING, PROGRAM_NAME);\n<line47>fputs (_("\n\\n<line48>NOTE: printf(1) is a preferred alternative,\n\\n<line49>which does not have issues outputting option-like strings.\n\\n<line50>"), stdout);\n<line51>emit_ancillary_info (PROGRAM_NAME);\n<line52>exit (status);\n<line53>}
----------------------------------------
Function: hextobin
Content: <line0>static int\n<line1>hextobin (unsigned char c)\n<line2>{\n<line3>switch (c)\n<line4>{\n<line5>default: return c - '0';\n<line6>case 'a': case 'A': return 10;\n<line7>case 'b': case 'B': return 11;\n<line8>case 'c': case 'C': return 12;\n<line9>case 'd': case 'D': return 13;\n<line10>case 'e': case 'E': return 14;\n<line11>case 'f': case 'F': return 15;\n<line12>}\n<line13>}
----------------------------------------
Function: main
Content: <line0>int\n<line1>main (int argc, char **argv)\n<line2>{\n<line3>bool display_return = true;\n<line4>bool posixly_correct = !!getenv ("POSIXLY_CORRECT");\n<line5>bool allow_options =\n<line6>(! posixly_correct\n<line7>|| (! DEFAULT_ECHO_TO_XPG && 1 < argc && STREQ (argv[1], "-n")));\n<line8>/* System V machines already have a /bin/sh with a v9 behavior.\n<line9>Use the identical behavior for these machines so that the\n<line10>existing system shell scripts won't barf.  */\n<line11>bool do_v9 = DEFAULT_ECHO_TO_XPG;\n<line12>initialize_main (&argc, &argv);\n<line13>set_program_name (argv[0]);\n<line14>setlocale (LC_ALL, "");\n<line15>bindtextdomain (PACKAGE, LOCALEDIR);\n<line16>textdomain (PACKAGE);\n<line17>atexit (close_stdout);\n<line18>/* We directly parse options, rather than use parse_long_options, in\n<line19>order to avoid accepting abbreviations.  */\n<line20>if (allow_options && argc == 2)\n<line21>{\n<line22>if (STREQ (argv[1], "--help"))\n<line23>usage (EXIT_SUCCESS);\n<line24>if (STREQ (argv[1], "--version"))\n<line25>{\n<line26>version_etc (stdout, PROGRAM_NAME, PACKAGE_NAME, Version, AUTHORS,\n<line27>(char *) nullptr);\n<line28>return EXIT_SUCCESS;\n<line29>}\n<line30>}\n<line31>--argc;\n<line32>++argv;\n<line33>if (allow_options)\n<line34>while (argc > 0 && *argv[0] == '-')\n<line35>{\n<line36>char const *temp = argv[0] + 1;\n<line37>size_t i;\n<line38>/* If it appears that we are handling options, then make sure that\n<line39>all of the options specified are actually valid.  Otherwise, the\n<line40>string should just be echoed.  */\n<line41>for (i = 0; temp[i]; i++)\n<line42>switch (temp[i])\n<line43>{\n<line44>case 'e': case 'E': case 'n':\n<line45>break;\n<line46>default:\n<line47>goto just_echo;\n<line48>}\n<line49>if (i == 0)\n<line50>goto just_echo;\n<line51>/* All of the options in TEMP are valid options to ECHO.\n<line52>Handle them. */\n<line53>while (*temp)\n<line54>switch (*temp++)\n<line55>{\n<line56>case 'e':\n<line57>do_v9 = true;\n<line58>break;\n<line59>case 'E':\n<line60>do_v9 = false;\n<line61>break;\n<line62>case 'n':\n<line63>display_return = false;\n<line64>break;\n<line65>}\n<line66>argc--;\n<line67>argv++;\n<line68>}\n<line69>just_echo:\n<line70>if (do_v9 || posixly_correct)\n<line71>{\n<line72>while (argc > 0)\n<line73>{\n<line74>char const *s = argv[0];\n<line75>unsigned char c;\n<line76>while ((c = *s++))\n<line77>{\n<line78>if (c == '\\' && *s)\n<line79>{\n<line80>switch (c = *s++)\n<line81>{\n<line82>case 'a': c = '\a'; break;\n<line83>case 'b': c = '\b'; break;\n<line84>case 'c': return EXIT_SUCCESS;\n<line85>case 'e': c = '\x1B'; break;\n<line86>case 'f': c = '\f'; break;\n<line87>case 'n': c = '\n'; break;\n<line88>case 'r': c = '\r'; break;\n<line89>case 't': c = '\t'; break;\n<line90>case 'v': c = '\v'; break;\n<line91>case 'x':\n<line92>{\n<line93>unsigned char ch = *s;\n<line94>if (! isxdigit (ch))\n<line95>goto not_an_escape;\n<line96>s++;\n<line97>c = hextobin (ch);\n<line98>ch = *s;\n<line99>if (isxdigit (ch))\n<line100>{\n<line101>s++;\n<line102>c = c * 16 + hextobin (ch);\n<line103>}\n<line104>}\n<line105>break;\n<line106>case '0':\n<line107>c = 0;\n<line108>if (! ('0' <= *s && *s <= '7'))\n<line109>break;\n<line110>c = *s++;\n<line111>FALLTHROUGH;\n<line112>case '1': case '2': case '3':\n<line113>case '4': case '5': case '6': case '7':\n<line114>c -= '0';\n<line115>if ('0' <= *s && *s <= '7')\n<line116>c = c * 8 + (*s++ - '0');\n<line117>if ('0' <= *s && *s <= '7')\n<line118>c = c * 8 + (*s++ - '0');\n<line119>break;\n<line120>case '\\': break;\n<line121>not_an_escape:\n<line122>default:  putchar ('\\'); break;\n<line123>}\n<line124>}\n<line125>putchar (c);\n<line126>}\n<line127>argc--;\n<line128>argv++;\n<line129>if (argc > 0)\n<line130>putchar (' ');\n<line131>}\n<line132>}\n<line133>else\n<line134>{\n<line135>while (argc > 0)\n<line136>{\n<line137>fputs (argv[0], stdout);\n<line138>argc--;\n<line139>argv++;\n<line140>if (argc > 0)\n<line141>putchar (' ');\n<line142>}\n<line143>}\n<line144>if (display_return)\n<line145>putchar ('\n');\n<line146>return EXIT_SUCCESS;\n<line147>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/src/env.c
========================================
Function: usage
Content: <line0>void\n<line1>usage (int status)\n<line2>{\n<line3>if (status != EXIT_SUCCESS)\n<line4>emit_try_help ();\n<line5>else\n<line6>{\n<line7>printf (_("\\n<line8>Usage: %s [OPTION]... [-] [NAME=VALUE]... [COMMAND [ARG]...]\n"),\n<line9>program_name);\n<line10>fputs (_("\\n<line11>Set each NAME to VALUE in the environment and run COMMAND.\n\\n<line12>"), stdout);\n<line13>emit_mandatory_arg_note ();\n<line14>fputs (_("\\n<line15>-i, --ignore-environment  start with an empty environment\n\\n<line16>-0, --null           end each output line with NUL, not newline\n\\n<line17>-u, --unset=NAME     remove variable from the environment\n\\n<line18>"), stdout);\n<line19>fputs (_("\\n<line20>-C, --chdir=DIR      change working directory to DIR\n\\n<line21>"), stdout);\n<line22>fputs (_("\\n<line23>-S, --split-string=S  process and split S into separate arguments;\n\\n<line24>used to pass multiple arguments on shebang lines\n\\n<line25>"), stdout);\n<line26>fputs (_("\\n<line27>--block-signal[=SIG]    block delivery of SIG signal(s) to COMMAND\n\\n<line28>"), stdout);\n<line29>fputs (_("\\n<line30>--default-signal[=SIG]  reset handling of SIG signal(s) to the default\n\\n<line31>"), stdout);\n<line32>fputs (_("\\n<line33>--ignore-signal[=SIG]   set handling of SIG signal(s) to do nothing\n\\n<line34>"), stdout);\n<line35>fputs (_("\\n<line36>--list-signal-handling  list non default signal handling to stderr\n\\n<line37>"), stdout);\n<line38>fputs (_("\\n<line39>-v, --debug          print verbose information for each processing step\n\\n<line40>"), stdout);\n<line41>fputs (HELP_OPTION_DESCRIPTION, stdout);\n<line42>fputs (VERSION_OPTION_DESCRIPTION, stdout);\n<line43>fputs (_("\\n<line44>\n\\n<line45>A mere - implies -i.  If no COMMAND, print the resulting environment.\n\\n<line46>"), stdout);\n<line47>fputs (_("\\n<line48>\n\\n<line49>SIG may be a signal name like 'PIPE', or a signal number like '13'.\n\\n<line50>Without SIG, all known signals are included.  Multiple signals can be\n\\n<line51>comma-separated.  An empty SIG argument is a no-op.\n\\n<line52>"), stdout);\n<line53>emit_exec_status (PROGRAM_NAME);\n<line54>emit_ancillary_info (PROGRAM_NAME);\n<line55>}\n<line56>exit (status);\n<line57>}
----------------------------------------
Function: append_unset_var
Content: <line0>static void\n<line1>append_unset_var (char const *var)\n<line2>{\n<line3>if (usvars_used == usvars_alloc)\n<line4>usvars = x2nrealloc (usvars, &usvars_alloc, sizeof *usvars);\n<line5>usvars[usvars_used++] = var;\n<line6>}
----------------------------------------
Function: unset_envvars
Content: <line0>static void\n<line1>unset_envvars (void)\n<line2>{\n<line3>for (idx_t i = 0; i < usvars_used; ++i)\n<line4>{\n<line5>devmsg ("unset:    %s\n", usvars[i]);\n<line6>if (unsetenv (usvars[i]))\n<line7>error (EXIT_CANCELED, errno, _("cannot unset %s"),\n<line8>quote (usvars[i]));\n<line9>}\n<line10>}
----------------------------------------
Function: extract_varname
Content: <line0>static char *\n<line1>extract_varname (char const *str)\n<line2>{\n<line3>idx_t i;\n<line4>char const *p;\n<line5>p = scan_varname (str);\n<line6>if (!p)\n<line7>return nullptr;\n<line8>/* -2 and +2 (below) account for the '${' prefix.  */\n<line9>i = p - str - 2;\n<line10>if (i >= vnlen)\n<line11>{\n<line12>vnlen = i + 1;\n<line13>varname = xrealloc (varname, vnlen);\n<line14>}\n<line15>memcpy (varname, str + 2, i);\n<line16>varname[i] = 0;\n<line17>return varname;\n<line18>}
----------------------------------------
Function: splitbuf_grow
Content: <line0>static void\n<line1>splitbuf_grow (struct splitbuf *ss)\n<line2>{\n<line3>idx_t old_half_alloc = ss->half_alloc;\n<line4>idx_t string_bytes = (intptr_t) ss->argv[ss->argc];\n<line5>ss->argv = xpalloc (ss->argv, &ss->half_alloc, 1,\n<line6>MIN (INT_MAX, IDX_MAX), 2 * sizeof *ss->argv);\n<line7>memmove (ss->argv + ss->half_alloc, ss->argv + old_half_alloc, string_bytes);\n<line8>}
----------------------------------------
Function: splitbuf_append_byte
Content: <line0>static void\n<line1>splitbuf_append_byte (struct splitbuf *ss, char c)\n<line2>{\n<line3>idx_t string_bytes = (intptr_t) ss->argv[ss->argc];\n<line4>if (ss->half_alloc * sizeof *ss->argv <= string_bytes)\n<line5>splitbuf_grow (ss);\n<line6>((char *) (ss->argv + ss->half_alloc))[string_bytes] = c;\n<line7>ss->argv[ss->argc] = (char *) (intptr_t) (string_bytes + 1);\n<line8>}
----------------------------------------
Function: check_start_new_arg
Content: <line0>static void\n<line1>check_start_new_arg (struct splitbuf *ss)\n<line2>{\n<line3>if (ss->sep)\n<line4>{\n<line5>splitbuf_append_byte (ss, '\0');\n<line6>int argc = ss->argc;\n<line7>if (ss->half_alloc <= argc + ss->extra_argc + 1)\n<line8>splitbuf_grow (ss);\n<line9>ss->argv[argc + 1] = ss->argv[argc];\n<line10>ss->argc = argc + 1;\n<line11>ss->sep = false;\n<line12>}\n<line13>}
----------------------------------------
Function: splitbuf_finishup
Content: <line0>static char **\n<line1>splitbuf_finishup (struct splitbuf *ss)\n<line2>{\n<line3>int argc = ss->argc;\n<line4>char **argv = ss->argv;\n<line5>char *stringbase = (char *) (ss->argv + ss->half_alloc);\n<line6>for (int i = 1; i < argc; i++)\n<line7>argv[i] = stringbase + (intptr_t) argv[i];\n<line8>return argv;\n<line9>}
----------------------------------------
Function: build_argv
Content: <line0>static char **\n<line1>build_argv (char const *str, int extra_argc, int *argc)\n<line2>{\n<line3>bool dq = false, sq = false;\n<line4>struct splitbuf ss;\n<line5>ss.argv = xnmalloc (extra_argc + 2, 2 * sizeof *ss.argv);\n<line6>ss.argc = 1;\n<line7>ss.half_alloc = extra_argc + 2;\n<line8>ss.extra_argc = extra_argc;\n<line9>ss.sep = true;\n<line10>ss.argv[ss.argc] = 0;\n<line11>/* In the following loop,\n<line12>'break' causes the character 'newc' to be added to *dest,\n<line13>'continue' skips the character.  */\n<line14>while (*str)\n<line15>{\n<line16>char newc = *str; /* Default: add the next character.  */\n<line17>switch (*str)\n<line18>{\n<line19>case '\'':\n<line20>if (dq)\n<line21>break;\n<line22>sq = !sq;\n<line23>check_start_new_arg (&ss);\n<line24>++str;\n<line25>continue;\n<line26>case '"':\n<line27>if (sq)\n<line28>break;\n<line29>dq = !dq;\n<line30>check_start_new_arg (&ss);\n<line31>++str;\n<line32>continue;\n<line33>case ' ': case '\t': case '\n': case '\v': case '\f': case '\r':\n<line34>/* Start a new argument if outside quotes.  */\n<line35>if (sq || dq)\n<line36>break;\n<line37>ss.sep = true;\n<line38>str += strspn (str, C_ISSPACE_CHARS);\n<line39>continue;\n<line40>case '#':\n<line41>if (!ss.sep)\n<line42>break;\n<line43>goto eos; /* '#' as first char terminates the string.  */\n<line44>case '\\':\n<line45>/* Backslash inside single-quotes is not special, except \\\n<line46>and \'.  */\n<line47>if (sq && str[1] != '\\' && str[1] != '\'')\n<line48>break;\n<line49>/* Skip the backslash and examine the next character.  */\n<line50>newc = *++str;\n<line51>switch (newc)\n<line52>{\n<line53>case '"': case '#': case '$': case '\'': case '\\':\n<line54>/* Pass escaped character as-is.  */\n<line55>break;\n<line56>case '_':\n<line57>if (!dq)\n<line58>{\n<line59>++str;  /* '\_' outside double-quotes is arg separator.  */\n<line60>ss.sep = true;\n<line61>continue;\n<line62>}\n<line63>newc = ' ';  /* '\_' inside double-quotes is space.  */\n<line64>break;\n<line65>case 'c':\n<line66>if (dq)\n<line67>error (EXIT_CANCELED, 0,\n<line68>_("'\\c' must not appear in double-quoted -S string"));\n<line69>goto eos; /* '\c' terminates the string.  */\n<line70>case 'f': newc = '\f'; break;\n<line71>case 'n': newc = '\n'; break;\n<line72>case 'r': newc = '\r'; break;\n<line73>case 't': newc = '\t'; break;\n<line74>case 'v': newc = '\v'; break;\n<line75>case '\0':\n<line76>error (EXIT_CANCELED, 0,\n<line77>_("invalid backslash at end of string in -S"));\n<line78>default:\n<line79>error (EXIT_CANCELED, 0,\n<line80>_("invalid sequence '\\%c' in -S"), newc);\n<line81>}\n<line82>break;\n<line83>case '$':\n<line84>/* ${VARNAME} are not expanded inside single-quotes.  */\n<line85>if (sq)\n<line86>break;\n<line87>/* Store the ${VARNAME} value.  */\n<line88>{\n<line89>char *n = extract_varname (str);\n<line90>if (!n)\n<line91>error (EXIT_CANCELED, 0,\n<line92>_("only ${VARNAME} expansion is supported, error at: %s"),\n<line93>str);\n<line94>char *v = getenv (n);\n<line95>if (v)\n<line96>{\n<line97>check_start_new_arg (&ss);\n<line98>devmsg ("expanding ${%s} into %s\n", n, quote (v));\n<line99>for (; *v; v++)\n<line100>splitbuf_append_byte (&ss, *v);\n<line101>}\n<line102>else\n<line103>devmsg ("replacing ${%s} with null string\n", n);\n<line104>str = strchr (str, '}') + 1;\n<line105>continue;\n<line106>}\n<line107>}\n<line108>check_start_new_arg (&ss);\n<line109>splitbuf_append_byte (&ss, newc);\n<line110>++str;\n<line111>}\n<line112>if (dq || sq)\n<line113>error (EXIT_CANCELED, 0, _("no terminating quote in -S string"));\n<line114>eos:\n<line115>splitbuf_append_byte (&ss, '\0');\n<line116>*argc = ss.argc;\n<line117>return splitbuf_finishup (&ss);\n<line118>}
----------------------------------------
Function: parse_split_string
Content: <line0>static void\n<line1>parse_split_string (char const *str, int *orig_optind,\n<line2>int *orig_argc, char ***orig_argv)\n<line3>{\n<line4>int extra_argc = *orig_argc - *orig_optind, newargc;\n<line5>char **newargv = build_argv (str, extra_argc, &newargc);\n<line6>/* Restore argv[0] - the 'env' executable name.  */\n<line7>*newargv = (*orig_argv)[0];\n<line8>/* Print parsed arguments.  */\n<line9>if (dev_debug && 1 < newargc)\n<line10>{\n<line11>devmsg ("split -S:  %s\n", quote (str));\n<line12>devmsg (" into:    %s\n", quote (newargv[1]));\n<line13>for (int i = 2; i < newargc; i++)\n<line14>devmsg ("     &    %s\n", quote (newargv[i]));\n<line15>}\n<line16>/* Add remaining arguments and terminating null from the original\n<line17>command line.  */\n<line18>memcpy (newargv + newargc, *orig_argv + *orig_optind,\n<line19>(extra_argc + 1) * sizeof *newargv);\n<line20>/* Set new values for original getopt variables.  */\n<line21>*orig_argc = newargc + extra_argc;\n<line22>*orig_argv = newargv;\n<line23>*orig_optind = 0; /* Tell getopt to restart from first argument.  */\n<line24>}
----------------------------------------
Function: parse_signal_action_params
Content: <line0>static void\n<line1>parse_signal_action_params (char const *optarg, bool set_default)\n<line2>{\n<line3>char signame[SIG2STR_MAX];\n<line4>char *opt_sig;\n<line5>char *optarg_writable;\n<line6>if (! optarg)\n<line7>{\n<line8>/* Without an argument, reset all signals.\n<line9>Some signals cannot be set to ignore or default (e.g., SIGKILL,\n<line10>SIGSTOP on most OSes, and SIGCONT on AIX.) - so ignore errors.  */\n<line11>for (int i = 1 ; i <= SIGNUM_BOUND; i++)\n<line12>if (sig2str (i, signame) == 0)\n<line13>signals[i] = set_default ? DEFAULT_NOERR : IGNORE_NOERR;\n<line14>return;\n<line15>}\n<line16>optarg_writable = xstrdup (optarg);\n<line17>opt_sig = strtok (optarg_writable, ",");\n<line18>while (opt_sig)\n<line19>{\n<line20>int signum = operand2sig (opt_sig, signame);\n<line21>/* operand2sig accepts signal 0 (EXIT) - but we reject it.  */\n<line22>if (signum == 0)\n<line23>error (0, 0, _("%s: invalid signal"), quote (opt_sig));\n<line24>if (signum <= 0)\n<line25>usage (exit_failure);\n<line26>signals[signum] = set_default ? DEFAULT : IGNORE;\n<line27>opt_sig = strtok (nullptr, ",");\n<line28>}\n<line29>free (optarg_writable);\n<line30>}
----------------------------------------
Function: reset_signal_handlers
Content: <line0>static void\n<line1>reset_signal_handlers (void)\n<line2>{\n<line3>for (int i = 1; i <= SIGNUM_BOUND; i++)\n<line4>{\n<line5>struct sigaction act;\n<line6>if (signals[i] == UNCHANGED)\n<line7>continue;\n<line8>bool ignore_errors = (signals[i] == DEFAULT_NOERR\n<line9>|| signals[i] == IGNORE_NOERR);\n<line10>bool set_to_default = (signals[i] == DEFAULT\n<line11>|| signals[i] == DEFAULT_NOERR);\n<line12>int sig_err = sigaction (i, nullptr, &act);\n<line13>if (sig_err && !ignore_errors)\n<line14>error (EXIT_CANCELED, errno,\n<line15>_("failed to get signal action for signal %d"), i);\n<line16>if (! sig_err)\n<line17>{\n<line18>act.sa_handler = set_to_default ? SIG_DFL : SIG_IGN;\n<line19>sig_err = sigaction (i, &act, nullptr);\n<line20>if (sig_err && !ignore_errors)\n<line21>error (EXIT_CANCELED, errno,\n<line22>_("failed to set signal action for signal %d"), i);\n<line23>}\n<line24>if (dev_debug)\n<line25>{\n<line26>char signame[SIG2STR_MAX];\n<line27>sig2str (i, signame);\n<line28>devmsg ("Reset signal %s (%d) to %s%s\n",\n<line29>signame, i,\n<line30>set_to_default ? "DEFAULT" : "IGNORE",\n<line31>sig_err ? " (failure ignored)" : "");\n<line32>}\n<line33>}\n<line34>}
----------------------------------------
Function: parse_block_signal_params
Content: <line0>static void\n<line1>parse_block_signal_params (char const *optarg, bool block)\n<line2>{\n<line3>char signame[SIG2STR_MAX];\n<line4>char *opt_sig;\n<line5>char *optarg_writable;\n<line6>if (! optarg)\n<line7>{\n<line8>/* Without an argument, reset all signals.  */\n<line9>sigfillset (block ? &block_signals : &unblock_signals);\n<line10>sigemptyset (block ? &unblock_signals : &block_signals);\n<line11>}\n<line12>else if (! sig_mask_changed)\n<line13>{\n<line14>/* Initialize the sets.  */\n<line15>sigemptyset (&block_signals);\n<line16>sigemptyset (&unblock_signals);\n<line17>}\n<line18>sig_mask_changed = true;\n<line19>if (! optarg)\n<line20>return;\n<line21>optarg_writable = xstrdup (optarg);\n<line22>opt_sig = strtok (optarg_writable, ",");\n<line23>while (opt_sig)\n<line24>{\n<line25>int signum = operand2sig (opt_sig, signame);\n<line26>/* operand2sig accepts signal 0 (EXIT) - but we reject it.  */\n<line27>if (signum == 0)\n<line28>error (0, 0, _("%s: invalid signal"), quote (opt_sig));\n<line29>if (signum <= 0)\n<line30>usage (exit_failure);\n<line31>sigaddset (block ? &block_signals : &unblock_signals, signum);\n<line32>sigdelset (block ? &unblock_signals : &block_signals, signum);\n<line33>opt_sig = strtok (nullptr, ",");\n<line34>}\n<line35>free (optarg_writable);\n<line36>}
----------------------------------------
Function: set_signal_proc_mask
Content: <line0>static void\n<line1>set_signal_proc_mask (void)\n<line2>{\n<line3>/* Get the existing signal mask */\n<line4>sigset_t set;\n<line5>char const *debug_act;\n<line6>sigemptyset (&set);\n<line7>if (sigprocmask (0, nullptr, &set))\n<line8>error (EXIT_CANCELED, errno, _("failed to get signal process mask"));\n<line9>for (int i = 1; i <= SIGNUM_BOUND; i++)\n<line10>{\n<line11>if (sigismember (&block_signals, i))\n<line12>{\n<line13>sigaddset (&set, i);\n<line14>debug_act = "BLOCK";\n<line15>}\n<line16>else if (sigismember (&unblock_signals, i))\n<line17>{\n<line18>sigdelset (&set, i);\n<line19>debug_act = "UNBLOCK";\n<line20>}\n<line21>else\n<line22>{\n<line23>debug_act = nullptr;\n<line24>}\n<line25>if (dev_debug && debug_act)\n<line26>{\n<line27>char signame[SIG2STR_MAX];\n<line28>sig2str (i, signame);\n<line29>devmsg ("signal %s (%d) mask set to %s\n",\n<line30>signame, i, debug_act);\n<line31>}\n<line32>}\n<line33>if (sigprocmask (SIG_SETMASK, &set, nullptr))\n<line34>error (EXIT_CANCELED, errno, _("failed to set signal process mask"));\n<line35>}
----------------------------------------
Function: list_signal_handling
Content: <line0>static void\n<line1>list_signal_handling (void)\n<line2>{\n<line3>sigset_t set;\n<line4>char signame[SIG2STR_MAX];\n<line5>sigemptyset (&set);\n<line6>if (sigprocmask (0, nullptr, &set))\n<line7>error (EXIT_CANCELED, errno, _("failed to get signal process mask"));\n<line8>for (int i = 1; i <= SIGNUM_BOUND; i++)\n<line9>{\n<line10>struct sigaction act;\n<line11>if (sigaction (i, nullptr, &act))\n<line12>continue;\n<line13>char const *ignored = act.sa_handler == SIG_IGN ? "IGNORE" : "";\n<line14>char const *blocked = sigismember (&set, i) ? "BLOCK" : "";\n<line15>char const *connect = *ignored && *blocked ? "," : "";\n<line16>if (! *ignored && ! *blocked)\n<line17>continue;\n<line18>sig2str (i, signame);\n<line19>fprintf (stderr, "%-10s (%2d): %s%s%s\n", signame, i,\n<line20>blocked, connect, ignored);\n<line21>}\n<line22>}
----------------------------------------
Function: initialize_signals
Content: <line0>static void\n<line1>initialize_signals (void)\n<line2>{\n<line3>signals = xmalloc ((sizeof *signals) * (SIGNUM_BOUND + 1));\n<line4>for (int i = 0 ; i <= SIGNUM_BOUND; i++)\n<line5>signals[i] = UNCHANGED;\n<line6>return;\n<line7>}
----------------------------------------
Function: main
Content: <line0>int\n<line1>main (int argc, char **argv)\n<line2>{\n<line3>int optc;\n<line4>bool ignore_environment = false;\n<line5>bool opt_nul_terminate_output = false;\n<line6>char const *newdir = nullptr;\n<line7>initialize_main (&argc, &argv);\n<line8>set_program_name (argv[0]);\n<line9>setlocale (LC_ALL, "");\n<line10>bindtextdomain (PACKAGE, LOCALEDIR);\n<line11>textdomain (PACKAGE);\n<line12>initialize_exit_failure (EXIT_CANCELED);\n<line13>atexit (close_stdout);\n<line14>initialize_signals ();\n<line15>while ((optc = getopt_long (argc, argv, shortopts, longopts, nullptr)) != -1)\n<line16>{\n<line17>switch (optc)\n<line18>{\n<line19>case 'i':\n<line20>ignore_environment = true;\n<line21>break;\n<line22>case 'u':\n<line23>append_unset_var (optarg);\n<line24>break;\n<line25>case 'v':\n<line26>dev_debug = true;\n<line27>break;\n<line28>case '0':\n<line29>opt_nul_terminate_output = true;\n<line30>break;\n<line31>case DEFAULT_SIGNAL_OPTION:\n<line32>parse_signal_action_params (optarg, true);\n<line33>parse_block_signal_params (optarg, false);\n<line34>break;\n<line35>case IGNORE_SIGNAL_OPTION:\n<line36>parse_signal_action_params (optarg, false);\n<line37>break;\n<line38>case BLOCK_SIGNAL_OPTION:\n<line39>parse_block_signal_params (optarg, true);\n<line40>break;\n<line41>case LIST_SIGNAL_HANDLING_OPTION:\n<line42>report_signal_handling = true;\n<line43>break;\n<line44>case 'C':\n<line45>newdir = optarg;\n<line46>break;\n<line47>case 'S':\n<line48>parse_split_string (optarg, &optind, &argc, &argv);\n<line49>break;\n<line50>case ' ': case '\t': case '\n': case '\v': case '\f': case '\r':\n<line51>/* These are undocumented options.  Attempt to detect\n<line52>incorrect shebang usage with extraneous space, e.g.:\n<line53>#!/usr/bin/env -i command\n<line54>In which case argv[1] == "-i command".  */\n<line55>error (0, 0, _("invalid option -- '%c'"), optc);\n<line56>error (0, 0, _("use -[v]S to pass options in shebang lines"));\n<line57>usage (EXIT_CANCELED);\n<line58>case_GETOPT_HELP_CHAR;\n<line59>case_GETOPT_VERSION_CHAR (PROGRAM_NAME, AUTHORS);\n<line60>default:\n<line61>usage (EXIT_CANCELED);\n<line62>}\n<line63>}\n<line64>if (optind < argc && STREQ (argv[optind], "-"))\n<line65>{\n<line66>ignore_environment = true;\n<line67>++optind;\n<line68>}\n<line69>if (ignore_environment)\n<line70>{\n<line71>devmsg ("cleaning environ\n");\n<line72>static char *dummy_environ[] = { nullptr };\n<line73>environ = dummy_environ;\n<line74>}\n<line75>else\n<line76>unset_envvars ();\n<line77>char *eq;\n<line78>while (optind < argc && (eq = strchr (argv[optind], '=')))\n<line79>{\n<line80>devmsg ("setenv:   %s\n", argv[optind]);\n<line81>if (putenv (argv[optind]))\n<line82>{\n<line83>*eq = '\0';\n<line84>error (EXIT_CANCELED, errno, _("cannot set %s"),\n<line85>quote (argv[optind]));\n<line86>}\n<line87>optind++;\n<line88>}\n<line89>bool program_specified = optind < argc;\n<line90>if (opt_nul_terminate_output && program_specified)\n<line91>{\n<line92>error (0, 0, _("cannot specify --null (-0) with command"));\n<line93>usage (EXIT_CANCELED);\n<line94>}\n<line95>if (newdir && ! program_specified)\n<line96>{\n<line97>error (0, 0, _("must specify command with --chdir (-C)"));\n<line98>usage (EXIT_CANCELED);\n<line99>}\n<line100>if (! program_specified)\n<line101>{\n<line102>/* Print the environment and exit.  */\n<line103>char *const *e = environ;\n<line104>while (*e)\n<line105>printf ("%s%c", *e++, opt_nul_terminate_output ? '\0' : '\n');\n<line106>return EXIT_SUCCESS;\n<line107>}\n<line108>reset_signal_handlers ();\n<line109>if (sig_mask_changed)\n<line110>set_signal_proc_mask ();\n<line111>if (report_signal_handling)\n<line112>list_signal_handling ();\n<line113>if (newdir)\n<line114>{\n<line115>devmsg ("chdir:    %s\n", quoteaf (newdir));\n<line116>if (chdir (newdir) != 0)\n<line117>error (EXIT_CANCELED, errno, _("cannot change directory to %s"),\n<line118>quoteaf (newdir));\n<line119>}\n<line120>if (dev_debug)\n<line121>{\n<line122>devmsg ("executing: %s\n", argv[optind]);\n<line123>for (int i=optind; i<argc; ++i)\n<line124>devmsg ("   arg[%d]= %s\n", i-optind, quote (argv[i]));\n<line125>}\n<line126>execvp (argv[optind], &argv[optind]);\n<line127>int exit_status = errno == ENOENT ? EXIT_ENOENT : EXIT_CANNOT_INVOKE;\n<line128>error (0, errno, "%s", quote (argv[optind]));\n<line129>if (exit_status == EXIT_ENOENT && strpbrk (argv[optind], C_ISSPACE_CHARS))\n<line130>error (0, 0, _("use -[v]S to pass options in shebang lines"));\n<line131>main_exit (exit_status);\n<line132>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/src/expand.c
========================================
Function: usage
Content: <line0>void\n<line1>usage (int status)\n<line2>{\n<line3>if (status != EXIT_SUCCESS)\n<line4>emit_try_help ();\n<line5>else\n<line6>{\n<line7>printf (_("\\n<line8>Usage: %s [OPTION]... [FILE]...\n\\n<line9>"),\n<line10>program_name);\n<line11>fputs (_("\\n<line12>Convert tabs in each FILE to spaces, writing to standard output.\n\\n<line13>"), stdout);\n<line14>emit_stdin_note ();\n<line15>emit_mandatory_arg_note ();\n<line16>fputs (_("\\n<line17>-i, --initial    do not convert tabs after non blanks\n\\n<line18>-t, --tabs=N     have tabs N characters apart, not 8\n\\n<line19>"), stdout);\n<line20>emit_tab_list_info ();\n<line21>fputs (HELP_OPTION_DESCRIPTION, stdout);\n<line22>fputs (VERSION_OPTION_DESCRIPTION, stdout);\n<line23>emit_ancillary_info (PROGRAM_NAME);\n<line24>}\n<line25>exit (status);\n<line26>}
----------------------------------------
Function: expand
Content: <line0>static void\n<line1>expand (void)\n<line2>{\n<line3>/* Input stream.  */\n<line4>FILE *fp = next_file (nullptr);\n<line5>if (!fp)\n<line6>return;\n<line7>while (true)\n<line8>{\n<line9>/* Input character, or EOF.  */\n<line10>int c;\n<line11>/* If true, perform translations.  */\n<line12>bool convert = true;\n<line13>/* The following variables have valid values only when CONVERT\n<line14>is true:  */\n<line15>/* Column of next input character.  */\n<line16>uintmax_t column = 0;\n<line17>/* Index in TAB_LIST of next tab stop to examine.  */\n<line18>size_t tab_index = 0;\n<line19>/* Convert a line of text.  */\n<line20>do\n<line21>{\n<line22>while ((c = getc (fp)) < 0 && (fp = next_file (fp)))\n<line23>continue;\n<line24>if (convert)\n<line25>{\n<line26>if (c == '\t')\n<line27>{\n<line28>/* Column the next input tab stop is on.  */\n<line29>uintmax_t next_tab_column;\n<line30>bool last_tab;\n<line31>next_tab_column = get_next_tab_column (column, &tab_index,\n<line32>&last_tab);\n<line33>if (last_tab)\n<line34>next_tab_column = column + 1;\n<line35>if (next_tab_column < column)\n<line36>error (EXIT_FAILURE, 0, _("input line is too long"));\n<line37>while (++column < next_tab_column)\n<line38>if (putchar (' ') < 0)\n<line39>write_error ();\n<line40>c = ' ';\n<line41>}\n<line42>else if (c == '\b')\n<line43>{\n<line44>/* Go back one column, and force recalculation of the\n<line45>next tab stop.  */\n<line46>column -= !!column;\n<line47>tab_index -= !!tab_index;\n<line48>}\n<line49>else\n<line50>{\n<line51>column++;\n<line52>if (!column)\n<line53>error (EXIT_FAILURE, 0, _("input line is too long"));\n<line54>}\n<line55>convert &= convert_entire_line || !! isblank (c);\n<line56>}\n<line57>if (c < 0)\n<line58>return;\n<line59>if (putchar (c) < 0)\n<line60>write_error ();\n<line61>}\n<line62>while (c != '\n');\n<line63>}\n<line64>}
----------------------------------------
Function: main
Content: <line0>int\n<line1>main (int argc, char **argv)\n<line2>{\n<line3>int c;\n<line4>initialize_main (&argc, &argv);\n<line5>set_program_name (argv[0]);\n<line6>setlocale (LC_ALL, "");\n<line7>bindtextdomain (PACKAGE, LOCALEDIR);\n<line8>textdomain (PACKAGE);\n<line9>atexit (close_stdout);\n<line10>convert_entire_line = true;\n<line11>while ((c = getopt_long (argc, argv, shortopts, longopts, nullptr)) != -1)\n<line12>{\n<line13>switch (c)\n<line14>{\n<line15>case 'i':\n<line16>convert_entire_line = false;\n<line17>break;\n<line18>case 't':\n<line19>parse_tab_stops (optarg);\n<line20>break;\n<line21>case '0': case '1': case '2': case '3': case '4':\n<line22>case '5': case '6': case '7': case '8': case '9':\n<line23>if (optarg)\n<line24>parse_tab_stops (optarg - 1);\n<line25>else\n<line26>{\n<line27>char tab_stop[2];\n<line28>tab_stop[0] = c;\n<line29>tab_stop[1] = '\0';\n<line30>parse_tab_stops (tab_stop);\n<line31>}\n<line32>break;\n<line33>case_GETOPT_HELP_CHAR;\n<line34>case_GETOPT_VERSION_CHAR (PROGRAM_NAME, AUTHORS);\n<line35>default:\n<line36>usage (EXIT_FAILURE);\n<line37>}\n<line38>}\n<line39>finalize_tab_stops ();\n<line40>set_file_list (optind < argc ? &argv[optind] : nullptr);\n<line41>expand ();\n<line42>cleanup_file_list_stdin ();\n<line43>return exit_status;\n<line44>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/src/expand-common.c
========================================
Function: add_tab_stop
Content: <line0>extern void\n<line1>add_tab_stop (uintmax_t tabval)\n<line2>{\n<line3>uintmax_t prev_column = first_free_tab ? tab_list[first_free_tab - 1] : 0;\n<line4>uintmax_t column_width = prev_column <= tabval ? tabval - prev_column : 0;\n<line5>if (first_free_tab == n_tabs_allocated)\n<line6>tab_list = X2NREALLOC (tab_list, &n_tabs_allocated);\n<line7>tab_list[first_free_tab++] = tabval;\n<line8>if (max_column_width < column_width)\n<line9>{\n<line10>if (SIZE_MAX < column_width)\n<line11>error (EXIT_FAILURE, 0, _("tabs are too far apart"));\n<line12>max_column_width = column_width;\n<line13>}\n<line14>}
----------------------------------------
Function: set_extend_size
Content: <line0>static bool\n<line1>set_extend_size (uintmax_t tabval)\n<line2>{\n<line3>bool ok = true;\n<line4>if (extend_size)\n<line5>{\n<line6>error (0, 0,\n<line7>_("'/' specifier only allowed"\n<line8>" with the last value"));\n<line9>ok = false;\n<line10>}\n<line11>extend_size = tabval;\n<line12>return ok;\n<line13>}
----------------------------------------
Function: set_increment_size
Content: <line0>static bool\n<line1>set_increment_size (uintmax_t tabval)\n<line2>{\n<line3>bool ok = true;\n<line4>if (increment_size)\n<line5>{\n<line6>error (0,0,\n<line7>_("'+' specifier only allowed"\n<line8>" with the last value"));\n<line9>ok = false;\n<line10>}\n<line11>increment_size = tabval;\n<line12>return ok;\n<line13>}
----------------------------------------
Function: parse_tab_stops
Content: <line0>extern void\n<line1>parse_tab_stops (char const *stops)\n<line2>{\n<line3>bool have_tabval = false;\n<line4>uintmax_t tabval = 0;\n<line5>bool extend_tabval = false;\n<line6>bool increment_tabval = false;\n<line7>char const *num_start = nullptr;\n<line8>bool ok = true;\n<line9>for (; *stops; stops++)\n<line10>{\n<line11>if (*stops == ',' || isblank (to_uchar (*stops)))\n<line12>{\n<line13>if (have_tabval)\n<line14>{\n<line15>if (extend_tabval)\n<line16>{\n<line17>if (! set_extend_size (tabval))\n<line18>{\n<line19>ok = false;\n<line20>break;\n<line21>}\n<line22>}\n<line23>else if (increment_tabval)\n<line24>{\n<line25>if (! set_increment_size (tabval))\n<line26>{\n<line27>ok = false;\n<line28>break;\n<line29>}\n<line30>}\n<line31>else\n<line32>add_tab_stop (tabval);\n<line33>}\n<line34>have_tabval = false;\n<line35>}\n<line36>else if (*stops == '/')\n<line37>{\n<line38>if (have_tabval)\n<line39>{\n<line40>error (0, 0, _("'/' specifier not at start of number: %s"),\n<line41>quote (stops));\n<line42>ok = false;\n<line43>}\n<line44>extend_tabval = true;\n<line45>increment_tabval = false;\n<line46>}\n<line47>else if (*stops == '+')\n<line48>{\n<line49>if (have_tabval)\n<line50>{\n<line51>error (0, 0, _("'+' specifier not at start of number: %s"),\n<line52>quote (stops));\n<line53>ok = false;\n<line54>}\n<line55>increment_tabval = true;\n<line56>extend_tabval = false;\n<line57>}\n<line58>else if (ISDIGIT (*stops))\n<line59>{\n<line60>if (!have_tabval)\n<line61>{\n<line62>tabval = 0;\n<line63>have_tabval = true;\n<line64>num_start = stops;\n<line65>}\n<line66>/* Detect overflow.  */\n<line67>if (!DECIMAL_DIGIT_ACCUMULATE (tabval, *stops - '0', uintmax_t))\n<line68>{\n<line69>size_t len = strspn (num_start, "0123456789");\n<line70>char *bad_num = ximemdup0 (num_start, len);\n<line71>error (0, 0, _("tab stop is too large %s"), quote (bad_num));\n<line72>free (bad_num);\n<line73>ok = false;\n<line74>stops = num_start + len - 1;\n<line75>}\n<line76>}\n<line77>else\n<line78>{\n<line79>error (0, 0, _("tab size contains invalid character(s): %s"),\n<line80>quote (stops));\n<line81>ok = false;\n<line82>break;\n<line83>}\n<line84>}\n<line85>if (ok && have_tabval)\n<line86>{\n<line87>if (extend_tabval)\n<line88>ok &= set_extend_size (tabval);\n<line89>else if (increment_tabval)\n<line90>ok &= set_increment_size (tabval);\n<line91>else\n<line92>add_tab_stop (tabval);\n<line93>}\n<line94>if (! ok)\n<line95>exit (EXIT_FAILURE);\n<line96>}
----------------------------------------
Function: validate_tab_stops
Content: <line0>static void\n<line1>validate_tab_stops (uintmax_t const *tabs, size_t entries)\n<line2>{\n<line3>uintmax_t prev_tab = 0;\n<line4>for (size_t i = 0; i < entries; i++)\n<line5>{\n<line6>if (tabs[i] == 0)\n<line7>error (EXIT_FAILURE, 0, _("tab size cannot be 0"));\n<line8>if (tabs[i] <= prev_tab)\n<line9>error (EXIT_FAILURE, 0, _("tab sizes must be ascending"));\n<line10>prev_tab = tabs[i];\n<line11>}\n<line12>if (increment_size && extend_size)\n<line13>error (EXIT_FAILURE, 0, _("'/' specifier is mutually exclusive with '+'"));\n<line14>}
----------------------------------------
Function: finalize_tab_stops
Content: <line0>extern void\n<line1>finalize_tab_stops (void)\n<line2>{\n<line3>validate_tab_stops (tab_list, first_free_tab);\n<line4>if (first_free_tab == 0)\n<line5>tab_size = max_column_width = extend_size\n<line6>? extend_size : increment_size\n<line7>? increment_size : 8;\n<line8>else if (first_free_tab == 1 && ! extend_size && ! increment_size)\n<line9>tab_size = tab_list[0];\n<line10>else\n<line11>tab_size = 0;\n<line12>}
----------------------------------------
Function: get_next_tab_column
Content: <line0>extern uintmax_t\n<line1>get_next_tab_column (const uintmax_t column, size_t *tab_index,\n<line2>bool *last_tab)\n<line3>{\n<line4>*last_tab = false;\n<line5>/* single tab-size - return multiples of it */\n<line6>if (tab_size)\n<line7>return column + (tab_size - column % tab_size);\n<line8>/* multiple tab-sizes - iterate them until the tab position is beyond\n<line9>the current input column. */\n<line10>for ( ; *tab_index < first_free_tab ; (*tab_index)++ )\n<line11>{\n<line12>uintmax_t tab = tab_list[*tab_index];\n<line13>if (column < tab)\n<line14>return tab;\n<line15>}\n<line16>/* relative last tab - return multiples of it */\n<line17>if (extend_size)\n<line18>return column + (extend_size - column % extend_size);\n<line19>/* incremental last tab - add increment_size to the previous tab stop */\n<line20>if (increment_size)\n<line21>{\n<line22>uintmax_t end_tab = tab_list[first_free_tab - 1];\n<line23>return column + (increment_size - ((column - end_tab) % increment_size));\n<line24>}\n<line25>*last_tab = true;\n<line26>return 0;\n<line27>}
----------------------------------------
Function: set_file_list
Content: <line0>extern void\n<line1>set_file_list (char **list)\n<line2>{\n<line3>have_read_stdin = false;\n<line4>if (!list)\n<line5>file_list = stdin_argv;\n<line6>else\n<line7>file_list = list;\n<line8>}
----------------------------------------
Function: next_file
Content: <line0>extern FILE *\n<line1>next_file (FILE *fp)\n<line2>{\n<line3>static char *prev_file;\n<line4>char *file;\n<line5>if (fp)\n<line6>{\n<line7>int err = errno;\n<line8>if (!ferror (fp))\n<line9>err = 0;\n<line10>if (STREQ (prev_file, "-"))\n<line11>clearerr (fp);		/* Also clear EOF.  */\n<line12>else if (fclose (fp) != 0)\n<line13>err = errno;\n<line14>if (err)\n<line15>{\n<line16>error (0, err, "%s", quotef (prev_file));\n<line17>exit_status = EXIT_FAILURE;\n<line18>}\n<line19>}\n<line20>while ((file = *file_list++) != nullptr)\n<line21>{\n<line22>if (STREQ (file, "-"))\n<line23>{\n<line24>have_read_stdin = true;\n<line25>fp = stdin;\n<line26>}\n<line27>else\n<line28>fp = fopen (file, "r");\n<line29>if (fp)\n<line30>{\n<line31>prev_file = file;\n<line32>fadvise (fp, FADVISE_SEQUENTIAL);\n<line33>return fp;\n<line34>}\n<line35>error (0, errno, "%s", quotef (file));\n<line36>exit_status = EXIT_FAILURE;\n<line37>}\n<line38>return nullptr;\n<line39>}
----------------------------------------
Function: cleanup_file_list_stdin
Content: <line0>extern void\n<line1>cleanup_file_list_stdin (void)\n<line2>{\n<line3>if (have_read_stdin && fclose (stdin) != 0)\n<line4>error (EXIT_FAILURE, errno, "-");\n<line5>}
----------------------------------------
Function: emit_tab_list_info
Content: <line0>extern void\n<line1>emit_tab_list_info (void)\n<line2>{\n<line3>/* suppress syntax check for emit_mandatory_arg_note() */\n<line4>fputs (_("\\n<line5>-t, --tabs=LIST  use comma separated list of tab positions.\n\\n<line6>"), stdout);\n<line7>fputs (_("\\n<line8>The last specified position can be prefixed with '/'\n\\n<line9>to specify a tab size to use after the last\n\\n<line10>explicitly specified tab stop.  Also a prefix of '+'\n\\n<line11>can be used to align remaining tab stops relative to\n\\n<line12>the last specified tab stop instead of the first column\n\\n<line13>"), stdout);\n<line14>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/src/expr.c
========================================
/home/huihui/Downloads/coreutils-9.4/src/expr.c:45:37: warning: '_Static_assert' with no message is a C2x extension [-Wc2x-extensions]
static_assert (SIZE_MAX <= ULONG_MAX);
                                    ^
                                    , ""
1 warning generated.
Function: mbs_logical_cspn
Content: <line0>static size_t\n<line1>mbs_logical_cspn (char const *s, char const *accept)\n<line2>{\n<line3>size_t idx = 0;\n<line4>if (accept[0] == '\0')\n<line5>return 0;\n<line6>/* General case.  */\n<line7>if (MB_CUR_MAX > 1)\n<line8>{\n<line9>mbui_iterator_t iter;\n<line10>for (mbui_init (iter, s); mbui_avail (iter); mbui_advance (iter))\n<line11>{\n<line12>++idx;\n<line13>if (mb_len (mbui_cur (iter)) == 1)\n<line14>{\n<line15>if (mbschr (accept, *mbui_cur_ptr (iter)))\n<line16>return idx;\n<line17>}\n<line18>else\n<line19>{\n<line20>mbui_iterator_t aiter;\n<line21>for (mbui_init (aiter, accept);\n<line22>mbui_avail (aiter);\n<line23>mbui_advance (aiter))\n<line24>if (mb_equal (mbui_cur (aiter), mbui_cur (iter)))\n<line25>return idx;\n<line26>}\n<line27>}\n<line28>/* not found */\n<line29>return 0;\n<line30>}\n<line31>else\n<line32>{\n<line33>/* single-byte locale,\n<line34>convert returned byte offset to 1-based index or zero if not found. */\n<line35>size_t i = strcspn (s, accept);\n<line36>return (s[i] ? i + 1 : 0);\n<line37>}\n<line38>}
----------------------------------------
Function: mbs_logical_substr
Content: <line0>static char *\n<line1>mbs_logical_substr (char const *s, size_t pos, size_t len)\n<line2>{\n<line3>char *v, *vlim;\n<line4>size_t blen = strlen (s); /* byte length */\n<line5>size_t llen = (MB_CUR_MAX > 1) ? mbslen (s) : blen; /* logical length */\n<line6>if (llen < pos || pos == 0 || len == 0 || len == SIZE_MAX)\n<line7>return xstrdup ("");\n<line8>/* characters to copy */\n<line9>size_t vlen = MIN (len, llen - pos + 1);\n<line10>if (MB_CUR_MAX == 1)\n<line11>{\n<line12>/* Single-byte case */\n<line13>v = xmalloc (vlen + 1);\n<line14>vlim = mempcpy (v, s + pos - 1, vlen);\n<line15>}\n<line16>else\n<line17>{\n<line18>/* Multibyte case */\n<line19>/* FIXME: this is wasteful. Some memory can be saved by counting\n<line20>how many bytes the matching characters occupy. */\n<line21>vlim = v = xmalloc (blen + 1);\n<line22>mbui_iterator_t iter;\n<line23>size_t idx=1;\n<line24>for (mbui_init (iter, s);\n<line25>mbui_avail (iter) && vlen > 0;\n<line26>mbui_advance (iter), ++idx)\n<line27>{\n<line28>/* Skip until we reach the starting position */\n<line29>if (idx < pos)\n<line30>continue;\n<line31>/* Copy one character */\n<line32>--vlen;\n<line33>vlim = mempcpy (vlim, mbui_cur_ptr (iter), mb_len (mbui_cur (iter)));\n<line34>}\n<line35>}\n<line36>*vlim = '\0';\n<line37>return v;\n<line38>}
----------------------------------------
Function: mbs_offset_to_chars
Content: <line0>static size_t\n<line1>mbs_offset_to_chars (char const *s, size_t ofs)\n<line2>{\n<line3>mbui_iterator_t iter;\n<line4>size_t c = 0;\n<line5>for (mbui_init (iter, s); mbui_avail (iter); mbui_advance (iter))\n<line6>{\n<line7>ptrdiff_t d = mbui_cur_ptr (iter) - s;\n<line8>if (d >= ofs)\n<line9>break;\n<line10>++c;\n<line11>}\n<line12>return c;\n<line13>}
----------------------------------------
Function: usage
Content: <line0>void\n<line1>usage (int status)\n<line2>{\n<line3>if (status != EXIT_SUCCESS)\n<line4>emit_try_help ();\n<line5>else\n<line6>{\n<line7>printf (_("\\n<line8>Usage: %s EXPRESSION\n\\n<line9>or:  %s OPTION\n\\n<line10>"),\n<line11>program_name, program_name);\n<line12>putchar ('\n');\n<line13>fputs (HELP_OPTION_DESCRIPTION, stdout);\n<line14>fputs (VERSION_OPTION_DESCRIPTION, stdout);\n<line15>fputs (_("\\n<line16>\n\\n<line17>Print the value of EXPRESSION to standard output.  A blank line below\n\\n<line18>separates increasing precedence groups.  EXPRESSION may be:\n\\n<line19>\n\\n<line20>ARG1 | ARG2       ARG1 if it is neither null nor 0, otherwise ARG2\n\\n<line21>\n\\n<line22>ARG1 & ARG2       ARG1 if neither argument is null or 0, otherwise 0\n\\n<line23>"), stdout);\n<line24>fputs (_("\\n<line25>\n\\n<line26>ARG1 < ARG2       ARG1 is less than ARG2\n\\n<line27>ARG1 <= ARG2      ARG1 is less than or equal to ARG2\n\\n<line28>ARG1 = ARG2       ARG1 is equal to ARG2\n\\n<line29>ARG1 != ARG2      ARG1 is unequal to ARG2\n\\n<line30>ARG1 >= ARG2      ARG1 is greater than or equal to ARG2\n\\n<line31>ARG1 > ARG2       ARG1 is greater than ARG2\n\\n<line32>"), stdout);\n<line33>fputs (_("\\n<line34>\n\\n<line35>ARG1 + ARG2       arithmetic sum of ARG1 and ARG2\n\\n<line36>ARG1 - ARG2       arithmetic difference of ARG1 and ARG2\n\\n<line37>"), stdout);\n<line38>/* Tell xgettext that the "% A" below is not a printf-style\n<line39>format string:  xgettext:no-c-format */\n<line40>fputs (_("\\n<line41>\n\\n<line42>ARG1 * ARG2       arithmetic product of ARG1 and ARG2\n\\n<line43>ARG1 / ARG2       arithmetic quotient of ARG1 divided by ARG2\n\\n<line44>ARG1 % ARG2       arithmetic remainder of ARG1 divided by ARG2\n\\n<line45>"), stdout);\n<line46>fputs (_("\\n<line47>\n\\n<line48>STRING : REGEXP   anchored pattern match of REGEXP in STRING\n\\n<line49>\n\\n<line50>match STRING REGEXP        same as STRING : REGEXP\n\\n<line51>substr STRING POS LENGTH   substring of STRING, POS counted from 1\n\\n<line52>index STRING CHARS         index in STRING where any CHARS is found, or 0\n\\n<line53>length STRING              length of STRING\n\\n<line54>"), stdout);\n<line55>fputs (_("\\n<line56>+ TOKEN                    interpret TOKEN as a string, even if it is a\n\\n<line57>keyword like 'match' or an operator like '/'\n\\n<line58>\n\\n<line59>( EXPRESSION )             value of EXPRESSION\n\\n<line60>"), stdout);\n<line61>fputs (_("\\n<line62>\n\\n<line63>Beware that many operators need to be escaped or quoted for shells.\n\\n<line64>Comparisons are arithmetic if both ARGs are numbers, else lexicographical.\n\\n<line65>Pattern matches return the string matched between \\( and \\) or null; if\n\\n<line66>\\( and \\) are not used, they return the number of characters matched or 0.\n\\n<line67>"), stdout);\n<line68>fputs (_("\\n<line69>\n\\n<line70>Exit status is 0 if EXPRESSION is neither null nor 0, 1 if EXPRESSION is null\n\\n<line71>or 0, 2 if EXPRESSION is syntactically invalid, and 3 if an error occurred.\n\\n<line72>"), stdout);\n<line73>emit_ancillary_info (PROGRAM_NAME);\n<line74>}\n<line75>exit (status);\n<line76>}
----------------------------------------
Function: main
Content: <line0>int\n<line1>main (int argc, char **argv)\n<line2>{\n<line3>VALUE *v;\n<line4>initialize_main (&argc, &argv);\n<line5>set_program_name (argv[0]);\n<line6>setlocale (LC_ALL, "");\n<line7>bindtextdomain (PACKAGE, LOCALEDIR);\n<line8>textdomain (PACKAGE);\n<line9>initialize_exit_failure (EXPR_FAILURE);\n<line10>atexit (close_stdout);\n<line11>parse_long_options (argc, argv, PROGRAM_NAME, PACKAGE_NAME, VERSION,\n<line12>usage, AUTHORS, (char const *) nullptr);\n<line13>/* The above handles --help and --version.\n<line14>Since there is no other invocation of getopt, handle '--' here.  */\n<line15>if (1 < argc && STREQ (argv[1], "--"))\n<line16>{\n<line17>--argc;\n<line18>++argv;\n<line19>}\n<line20>if (argc <= 1)\n<line21>{\n<line22>error (0, 0, _("missing operand"));\n<line23>usage (EXPR_INVALID);\n<line24>}\n<line25>args = argv + 1;\n<line26>v = eval (true);\n<line27>if (!nomoreargs ())\n<line28>error (EXPR_INVALID, 0, _("syntax error: unexpected argument %s"),\n<line29>quotearg_n_style (0, locale_quoting_style, *args));\n<line30>printv (v);\n<line31>main_exit (null (v));\n<line32>}
----------------------------------------
Function: int_value
Content: <line0>static VALUE *\n<line1>int_value (unsigned long int i)\n<line2>{\n<line3>VALUE *v = xmalloc (sizeof *v);\n<line4>v->type = integer;\n<line5>mpz_init_set_ui (v->u.i, i);\n<line6>return v;\n<line7>}
----------------------------------------
Function: str_value
Content: <line0>static VALUE *\n<line1>str_value (char const *s)\n<line2>{\n<line3>VALUE *v = xmalloc (sizeof *v);\n<line4>v->type = string;\n<line5>v->u.s = xstrdup (s);\n<line6>return v;\n<line7>}
----------------------------------------
Function: freev
Content: <line0>static void\n<line1>freev (VALUE *v)\n<line2>{\n<line3>if (v->type == string)\n<line4>free (v->u.s);\n<line5>else\n<line6>mpz_clear (v->u.i);\n<line7>free (v);\n<line8>}
----------------------------------------
Function: printv
Content: <line0>static void\n<line1>printv (VALUE *v)\n<line2>{\n<line3>switch (v->type)\n<line4>{\n<line5>case integer:\n<line6>mpz_out_str (stdout, 10, v->u.i);\n<line7>putchar ('\n');\n<line8>break;\n<line9>case string:\n<line10>puts (v->u.s);\n<line11>break;\n<line12>default:\n<line13>unreachable ();\n<line14>}\n<line15>}
----------------------------------------
Function: tostring
Content: <line0>static void\n<line1>tostring (VALUE *v)\n<line2>{\n<line3>switch (v->type)\n<line4>{\n<line5>case integer:\n<line6>{\n<line7>char *s = mpz_get_str (nullptr, 10, v->u.i);\n<line8>mpz_clear (v->u.i);\n<line9>v->u.s = s;\n<line10>v->type = string;\n<line11>}\n<line12>break;\n<line13>case string:\n<line14>break;\n<line15>default:\n<line16>unreachable ();\n<line17>}\n<line18>}
----------------------------------------
Function: toarith
Content: <line0>static bool\n<line1>toarith (VALUE *v)\n<line2>{\n<line3>switch (v->type)\n<line4>{\n<line5>case integer:\n<line6>return true;\n<line7>case string:\n<line8>{\n<line9>char *s = v->u.s;\n<line10>if (! looks_like_integer (s))\n<line11>return false;\n<line12>if (mpz_init_set_str (v->u.i, s, 10) != 0)\n<line13>error (EXPR_FAILURE, ERANGE, "%s", (s));\n<line14>free (s);\n<line15>v->type = integer;\n<line16>return true;\n<line17>}\n<line18>default:\n<line19>unreachable ();\n<line20>}\n<line21>}
----------------------------------------
Function: getsize
Content: <line0>static size_t\n<line1>getsize (mpz_t i)\n<line2>{\n<line3>if (mpz_sgn (i) < 0)\n<line4>return SIZE_MAX;\n<line5>if (mpz_fits_ulong_p (i))\n<line6>{\n<line7>unsigned long int ul = mpz_get_ui (i);\n<line8>if (ul < SIZE_MAX)\n<line9>return ul;\n<line10>}\n<line11>return SIZE_MAX - 1;\n<line12>}
----------------------------------------
Function: nextarg
Content: <line0>static bool\n<line1>nextarg (char const *str)\n<line2>{\n<line3>if (*args == nullptr)\n<line4>return false;\n<line5>else\n<line6>{\n<line7>bool r = STREQ (*args, str);\n<line8>args += r;\n<line9>return r;\n<line10>}\n<line11>}
----------------------------------------
Function: nomoreargs
Content: <line0>static bool\n<line1>nomoreargs (void)\n<line2>{\n<line3>return *args == 0;\n<line4>}
----------------------------------------
Function: require_more_args
Content: <line0>static void\n<line1>require_more_args (void)\n<line2>{\n<line3>if (nomoreargs ())\n<line4>error (EXPR_INVALID, 0, _("syntax error: missing argument after %s"),\n<line5>quotearg_n_style (0, locale_quoting_style, *(args - 1)));\n<line6>}
----------------------------------------
Function: docolon
Content: <line0>static VALUE *\n<line1>docolon (VALUE *sv, VALUE *pv)\n<line2>{\n<line3>VALUE *v;\n<line4>char const *errmsg;\n<line5>struct re_pattern_buffer re_buffer;\n<line6>char fastmap[UCHAR_MAX + 1];\n<line7>struct re_registers re_regs;\n<line8>regoff_t matchlen;\n<line9>tostring (sv);\n<line10>tostring (pv);\n<line11>re_regs.num_regs = 0;\n<line12>re_regs.start = nullptr;\n<line13>re_regs.end = nullptr;\n<line14>re_buffer.buffer = nullptr;\n<line15>re_buffer.allocated = 0;\n<line16>re_buffer.fastmap = fastmap;\n<line17>re_buffer.translate = nullptr;\n<line18>re_syntax_options =\n<line19>RE_SYNTAX_POSIX_BASIC & ~RE_CONTEXT_INVALID_DUP & ~RE_NO_EMPTY_RANGES;\n<line20>errmsg = re_compile_pattern (pv->u.s, strlen (pv->u.s), &re_buffer);\n<line21>if (errmsg)\n<line22>error (EXPR_INVALID, 0, "%s", (errmsg));\n<line23>re_buffer.newline_anchor = 0;\n<line24>matchlen = re_match (&re_buffer, sv->u.s, strlen (sv->u.s), 0, &re_regs);\n<line25>if (0 <= matchlen)\n<line26>{\n<line27>/* Were \(...\) used? */\n<line28>if (re_buffer.re_nsub > 0)\n<line29>{\n<line30>if (re_regs.end[1] < 0)\n<line31>v = str_value ("");\n<line32>else\n<line33>{\n<line34>sv->u.s[re_regs.end[1]] = '\0';\n<line35>v = str_value (sv->u.s + re_regs.start[1]);\n<line36>}\n<line37>}\n<line38>else\n<line39>{\n<line40>/* In multibyte locales, convert the matched offset (=number of bytes)\n<line41>to the number of matched characters. */\n<line42>size_t i = (MB_CUR_MAX == 1\n<line43>? matchlen\n<line44>: mbs_offset_to_chars (sv->u.s, matchlen));\n<line45>v = int_value (i);\n<line46>}\n<line47>}\n<line48>else if (matchlen == -1)\n<line49>{\n<line50>/* Match failed -- return the right kind of null.  */\n<line51>if (re_buffer.re_nsub > 0)\n<line52>v = str_value ("");\n<line53>else\n<line54>v = int_value (0);\n<line55>}\n<line56>else\n<line57>error (EXPR_FAILURE,\n<line58>matchlen == -2 ? errno : EOVERFLOW,\n<line59>_("error in regular expression matcher"));\n<line60>if (0 < re_regs.num_regs)\n<line61>{\n<line62>free (re_regs.start);\n<line63>free (re_regs.end);\n<line64>}\n<line65>re_buffer.fastmap = nullptr;\n<line66>regfree (&re_buffer);\n<line67>return v;\n<line68>}
----------------------------------------
Function: eval7
Content: <line0>static VALUE *\n<line1>eval7 (bool evaluate)\n<line2>{\n<line3>VALUE *v;\n<line4>#ifdef EVAL_TRACE\n<line5>trace ("eval7");\n<line6>#endif\n<line7>require_more_args ();\n<line8>if (nextarg ("("))\n<line9>{\n<line10>v = eval (evaluate);\n<line11>if (nomoreargs ())\n<line12>error (EXPR_INVALID, 0, _("syntax error: expecting ')' after %s"),\n<line13>quotearg_n_style (0, locale_quoting_style, *(args - 1)));\n<line14>if (!nextarg (")"))\n<line15>error (EXPR_INVALID, 0, _("syntax error: expecting ')' instead of %s"),\n<line16>quotearg_n_style (0, locale_quoting_style, *args));\n<line17>return v;\n<line18>}\n<line19>if (nextarg (")"))\n<line20>error (EXPR_INVALID, 0, _("syntax error: unexpected ')'"));\n<line21>return str_value (*args++);\n<line22>}
----------------------------------------
Function: eval6
Content: <line0>static VALUE *\n<line1>eval6 (bool evaluate)\n<line2>{\n<line3>VALUE *l;\n<line4>VALUE *r;\n<line5>VALUE *v;\n<line6>VALUE *i1;\n<line7>VALUE *i2;\n<line8>#ifdef EVAL_TRACE\n<line9>trace ("eval6");\n<line10>#endif\n<line11>if (nextarg ("+"))\n<line12>{\n<line13>require_more_args ();\n<line14>return str_value (*args++);\n<line15>}\n<line16>else if (nextarg ("length"))\n<line17>{\n<line18>r = eval6 (evaluate);\n<line19>tostring (r);\n<line20>v = int_value (mbslen (r->u.s));\n<line21>freev (r);\n<line22>return v;\n<line23>}\n<line24>else if (nextarg ("match"))\n<line25>{\n<line26>l = eval6 (evaluate);\n<line27>r = eval6 (evaluate);\n<line28>if (evaluate)\n<line29>{\n<line30>v = docolon (l, r);\n<line31>freev (l);\n<line32>}\n<line33>else\n<line34>v = l;\n<line35>freev (r);\n<line36>return v;\n<line37>}\n<line38>else if (nextarg ("index"))\n<line39>{\n<line40>size_t pos;\n<line41>l = eval6 (evaluate);\n<line42>r = eval6 (evaluate);\n<line43>tostring (l);\n<line44>tostring (r);\n<line45>pos = mbs_logical_cspn (l->u.s, r->u.s);\n<line46>v = int_value (pos);\n<line47>freev (l);\n<line48>freev (r);\n<line49>return v;\n<line50>}\n<line51>else if (nextarg ("substr"))\n<line52>{\n<line53>l = eval6 (evaluate);\n<line54>i1 = eval6 (evaluate);\n<line55>i2 = eval6 (evaluate);\n<line56>tostring (l);\n<line57>if (!toarith (i1) || !toarith (i2))\n<line58>v = str_value ("");\n<line59>else\n<line60>{\n<line61>size_t pos = getsize (i1->u.i);\n<line62>size_t len = getsize (i2->u.i);\n<line63>char *s = mbs_logical_substr (l->u.s, pos, len);\n<line64>v = str_value (s);\n<line65>free (s);\n<line66>}\n<line67>freev (l);\n<line68>freev (i1);\n<line69>freev (i2);\n<line70>return v;\n<line71>}\n<line72>else\n<line73>return eval7 (evaluate);\n<line74>}
----------------------------------------
Function: eval5
Content: <line0>static VALUE *\n<line1>eval5 (bool evaluate)\n<line2>{\n<line3>VALUE *l;\n<line4>VALUE *r;\n<line5>VALUE *v;\n<line6>#ifdef EVAL_TRACE\n<line7>trace ("eval5");\n<line8>#endif\n<line9>l = eval6 (evaluate);\n<line10>while (true)\n<line11>{\n<line12>if (nextarg (":"))\n<line13>{\n<line14>r = eval6 (evaluate);\n<line15>if (evaluate)\n<line16>{\n<line17>v = docolon (l, r);\n<line18>freev (l);\n<line19>l = v;\n<line20>}\n<line21>freev (r);\n<line22>}\n<line23>else\n<line24>return l;\n<line25>}\n<line26>}
----------------------------------------
Function: eval4
Content: <line0>static VALUE *\n<line1>eval4 (bool evaluate)\n<line2>{\n<line3>VALUE *l;\n<line4>VALUE *r;\n<line5>enum { multiply, divide, mod } fxn;\n<line6>#ifdef EVAL_TRACE\n<line7>trace ("eval4");\n<line8>#endif\n<line9>l = eval5 (evaluate);\n<line10>while (true)\n<line11>{\n<line12>if (nextarg ("*"))\n<line13>fxn = multiply;\n<line14>else if (nextarg ("/"))\n<line15>fxn = divide;\n<line16>else if (nextarg ("%"))\n<line17>fxn = mod;\n<line18>else\n<line19>return l;\n<line20>r = eval5 (evaluate);\n<line21>if (evaluate)\n<line22>{\n<line23>if (!toarith (l) || !toarith (r))\n<line24>error (EXPR_INVALID, 0, _("non-integer argument"));\n<line25>if (fxn != multiply && mpz_sgn (r->u.i) == 0)\n<line26>error (EXPR_INVALID, 0, _("division by zero"));\n<line27>((fxn == multiply ? mpz_mul\n<line28>: fxn == divide ? mpz_tdiv_q\n<line29>: mpz_tdiv_r)\n<line30>(l->u.i, l->u.i, r->u.i));\n<line31>}\n<line32>freev (r);\n<line33>}\n<line34>}
----------------------------------------
Function: eval3
Content: <line0>static VALUE *\n<line1>eval3 (bool evaluate)\n<line2>{\n<line3>VALUE *l;\n<line4>VALUE *r;\n<line5>enum { plus, minus } fxn;\n<line6>#ifdef EVAL_TRACE\n<line7>trace ("eval3");\n<line8>#endif\n<line9>l = eval4 (evaluate);\n<line10>while (true)\n<line11>{\n<line12>if (nextarg ("+"))\n<line13>fxn = plus;\n<line14>else if (nextarg ("-"))\n<line15>fxn = minus;\n<line16>else\n<line17>return l;\n<line18>r = eval4 (evaluate);\n<line19>if (evaluate)\n<line20>{\n<line21>if (!toarith (l) || !toarith (r))\n<line22>error (EXPR_INVALID, 0, _("non-integer argument"));\n<line23>(fxn == plus ? mpz_add : mpz_sub) (l->u.i, l->u.i, r->u.i);\n<line24>}\n<line25>freev (r);\n<line26>}\n<line27>}
----------------------------------------
Function: eval2
Content: <line0>static VALUE *\n<line1>eval2 (bool evaluate)\n<line2>{\n<line3>VALUE *l;\n<line4>#ifdef EVAL_TRACE\n<line5>trace ("eval2");\n<line6>#endif\n<line7>l = eval3 (evaluate);\n<line8>while (true)\n<line9>{\n<line10>VALUE *r;\n<line11>enum\n<line12>{\n<line13>less_than, less_equal, equal, not_equal, greater_equal, greater_than\n<line14>} fxn;\n<line15>bool val = false;\n<line16>if (nextarg ("<"))\n<line17>fxn = less_than;\n<line18>else if (nextarg ("<="))\n<line19>fxn = less_equal;\n<line20>else if (nextarg ("=") || nextarg ("=="))\n<line21>fxn = equal;\n<line22>else if (nextarg ("!="))\n<line23>fxn = not_equal;\n<line24>else if (nextarg (">="))\n<line25>fxn = greater_equal;\n<line26>else if (nextarg (">"))\n<line27>fxn = greater_than;\n<line28>else\n<line29>return l;\n<line30>r = eval3 (evaluate);\n<line31>if (evaluate)\n<line32>{\n<line33>int cmp;\n<line34>tostring (l);\n<line35>tostring (r);\n<line36>if (looks_like_integer (l->u.s) && looks_like_integer (r->u.s))\n<line37>cmp = strintcmp (l->u.s, r->u.s);\n<line38>else\n<line39>{\n<line40>errno = 0;\n<line41>cmp = strcoll (l->u.s, r->u.s);\n<line42>if (errno)\n<line43>{\n<line44>error (0, errno, _("string comparison failed"));\n<line45>error (0, 0, _("set LC_ALL='C' to work around the problem"));\n<line46>error (EXPR_INVALID, 0,\n<line47>_("the strings compared were %s and %s"),\n<line48>quotearg_n_style (0, locale_quoting_style, l->u.s),\n<line49>quotearg_n_style (1, locale_quoting_style, r->u.s));\n<line50>}\n<line51>}\n<line52>switch (fxn)\n<line53>{\n<line54>case less_than:     val = (cmp <  0); break;\n<line55>case less_equal:    val = (cmp <= 0); break;\n<line56>case equal:         val = (cmp == 0); break;\n<line57>case not_equal:     val = (cmp != 0); break;\n<line58>case greater_equal: val = (cmp >= 0); break;\n<line59>case greater_than:  val = (cmp >  0); break;\n<line60>default: unreachable ();\n<line61>}\n<line62>}\n<line63>freev (l);\n<line64>freev (r);\n<line65>l = int_value (val);\n<line66>}\n<line67>}
----------------------------------------
Function: eval1
Content: <line0>static VALUE *\n<line1>eval1 (bool evaluate)\n<line2>{\n<line3>VALUE *l;\n<line4>VALUE *r;\n<line5>#ifdef EVAL_TRACE\n<line6>trace ("eval1");\n<line7>#endif\n<line8>l = eval2 (evaluate);\n<line9>while (true)\n<line10>{\n<line11>if (nextarg ("&"))\n<line12>{\n<line13>r = eval2 (evaluate && !null (l));\n<line14>if (null (l) || null (r))\n<line15>{\n<line16>freev (l);\n<line17>freev (r);\n<line18>l = int_value (0);\n<line19>}\n<line20>else\n<line21>freev (r);\n<line22>}\n<line23>else\n<line24>return l;\n<line25>}\n<line26>}
----------------------------------------
Function: eval
Content: <line0>static VALUE *\n<line1>eval (bool evaluate)\n<line2>{\n<line3>VALUE *l;\n<line4>VALUE *r;\n<line5>#ifdef EVAL_TRACE\n<line6>trace ("eval");\n<line7>#endif\n<line8>l = eval1 (evaluate);\n<line9>while (true)\n<line10>{\n<line11>if (nextarg ("|"))\n<line12>{\n<line13>r = eval1 (evaluate && null (l));\n<line14>if (null (l))\n<line15>{\n<line16>freev (l);\n<line17>l = r;\n<line18>if (null (l))\n<line19>{\n<line20>freev (l);\n<line21>l = int_value (0);\n<line22>}\n<line23>}\n<line24>else\n<line25>freev (r);\n<line26>}\n<line27>else\n<line28>return l;\n<line29>}\n<line30>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/src/factor.c
========================================
/home/huihui/Downloads/coreutils-9.4/src/factor.c:664:43: warning: '_Static_assert' with no message is a C2x extension [-Wc2x-extensions]
static_assert (UINTMAX_MAX >> (W - 1) == 1);
                                          ^
                                          , ""
/home/huihui/Downloads/coreutils-9.4/src/factor.c:697:35: warning: '_Static_assert' with no message is a C2x extension [-Wc2x-extensions]
static_assert (W <= WIDE_UINT_BITS);
                                  ^
                                  , ""
2 warnings generated.
Function: mod2
Content: <line0>static uintmax_t\n<line1>mod2 (uintmax_t *r1, uintmax_t a1, uintmax_t a0, uintmax_t d1, uintmax_t d0)\n<line2>{\n<line3>int cntd, cnta;\n<line4>affirm (d1 != 0);\n<line5>if (a1 == 0)\n<line6>{\n<line7>*r1 = 0;\n<line8>return a0;\n<line9>}\n<line10>count_leading_zeros (cntd, d1);\n<line11>count_leading_zeros (cnta, a1);\n<line12>int cnt = cntd - cnta;\n<line13>lsh2 (d1, d0, d1, d0, cnt);\n<line14>for (int i = 0; i < cnt; i++)\n<line15>{\n<line16>if (ge2 (a1, a0, d1, d0))\n<line17>sub_ddmmss (a1, a0, a1, a0, d1, d0);\n<line18>rsh2 (d1, d0, d1, d0, 1);\n<line19>}\n<line20>*r1 = a1;\n<line21>return a0;\n<line22>}
----------------------------------------
Function: gcd2_odd
Content: <line0>static uintmax_t\n<line1>gcd2_odd (uintmax_t *r1, uintmax_t a1, uintmax_t a0, uintmax_t b1, uintmax_t b0)\n<line2>{\n<line3>affirm (b0 & 1);\n<line4>if ((a0 | a1) == 0)\n<line5>{\n<line6>*r1 = b1;\n<line7>return b0;\n<line8>}\n<line9>while ((a0 & 1) == 0)\n<line10>rsh2 (a1, a0, a1, a0, 1);\n<line11>for (;;)\n<line12>{\n<line13>if ((b1 | a1) == 0)\n<line14>{\n<line15>*r1 = 0;\n<line16>return gcd_odd (b0, a0);\n<line17>}\n<line18>if (gt2 (a1, a0, b1, b0))\n<line19>{\n<line20>sub_ddmmss (a1, a0, a1, a0, b1, b0);\n<line21>do\n<line22>rsh2 (a1, a0, a1, a0, 1);\n<line23>while ((a0 & 1) == 0);\n<line24>}\n<line25>else if (gt2 (b1, b0, a1, a0))\n<line26>{\n<line27>sub_ddmmss (b1, b0, b1, b0, a1, a0);\n<line28>do\n<line29>rsh2 (b1, b0, b1, b0, 1);\n<line30>while ((b0 & 1) == 0);\n<line31>}\n<line32>else\n<line33>break;\n<line34>}\n<line35>*r1 = a1;\n<line36>return a0;\n<line37>}
----------------------------------------
Function: factor_insert_multiplicity
Content: <line0>static void\n<line1>factor_insert_multiplicity (struct factors *factors,\n<line2>uintmax_t prime, int m)\n<line3>{\n<line4>int nfactors = factors->nfactors;\n<line5>uintmax_t *p = factors->p;\n<line6>unsigned char *e = factors->e;\n<line7>/* Locate position for insert new or increment e.  */\n<line8>int i;\n<line9>for (i = nfactors - 1; i >= 0; i--)\n<line10>{\n<line11>if (p[i] <= prime)\n<line12>break;\n<line13>}\n<line14>if (i < 0 || p[i] != prime)\n<line15>{\n<line16>for (int j = nfactors - 1; j > i; j--)\n<line17>{\n<line18>p[j + 1] = p[j];\n<line19>e[j + 1] = e[j];\n<line20>}\n<line21>p[i + 1] = prime;\n<line22>e[i + 1] = m;\n<line23>factors->nfactors = nfactors + 1;\n<line24>}\n<line25>else\n<line26>{\n<line27>e[i] += m;\n<line28>}\n<line29>}
----------------------------------------
Function: factor_insert_large
Content: <line0>static void\n<line1>factor_insert_large (struct factors *factors,\n<line2>uintmax_t p1, uintmax_t p0)\n<line3>{\n<line4>if (p1 > 0)\n<line5>{\n<line6>affirm (factors->plarge[1] == 0);\n<line7>factors->plarge[0] = p0;\n<line8>factors->plarge[1] = p1;\n<line9>}\n<line10>else\n<line11>factor_insert (factors, p0);\n<line12>}
----------------------------------------
Function: mpz_va_init
Content: <line0>static void\n<line1>mpz_va_init (void (*mpz_single_init)(mpz_t), ...)\n<line2>{\n<line3>va_list ap;\n<line4>va_start (ap, mpz_single_init);\n<line5>mpz_t *mpz;\n<line6>while ((mpz = va_arg (ap, mpz_t *)))\n<line7>mpz_single_init (*mpz);\n<line8>va_end (ap);\n<line9>}
----------------------------------------
Function: mp_factor_init
Content: <line0>static void\n<line1>mp_factor_init (struct mp_factors *factors)\n<line2>{\n<line3>factors->p = nullptr;\n<line4>factors->e = nullptr;\n<line5>factors->nfactors = 0;\n<line6>}
----------------------------------------
Function: mp_factor_clear
Content: <line0>static void\n<line1>mp_factor_clear (struct mp_factors *factors)\n<line2>{\n<line3>for (idx_t i = 0; i < factors->nfactors; i++)\n<line4>mpz_clear (factors->p[i]);\n<line5>free (factors->p);\n<line6>free (factors->e);\n<line7>}
----------------------------------------
Function: mp_factor_insert
Content: <line0>static void\n<line1>mp_factor_insert (struct mp_factors *factors, mpz_t prime)\n<line2>{\n<line3>idx_t nfactors = factors->nfactors;\n<line4>mpz_t *p = factors->p;\n<line5>unsigned long int *e = factors->e;\n<line6>ptrdiff_t i;\n<line7>/* Locate position for insert new or increment e.  */\n<line8>for (i = nfactors - 1; i >= 0; i--)\n<line9>{\n<line10>if (mpz_cmp (p[i], prime) <= 0)\n<line11>break;\n<line12>}\n<line13>if (i < 0 || mpz_cmp (p[i], prime) != 0)\n<line14>{\n<line15>p = xireallocarray (p, nfactors + 1, sizeof p[0]);\n<line16>e = xireallocarray (e, nfactors + 1, sizeof e[0]);\n<line17>mpz_init (p[nfactors]);\n<line18>for (long j = nfactors - 1; j > i; j--)\n<line19>{\n<line20>mpz_set (p[j + 1], p[j]);\n<line21>e[j + 1] = e[j];\n<line22>}\n<line23>mpz_set (p[i + 1], prime);\n<line24>e[i + 1] = 1;\n<line25>factors->p = p;\n<line26>factors->e = e;\n<line27>factors->nfactors = nfactors + 1;\n<line28>}\n<line29>else\n<line30>{\n<line31>e[i] += 1;\n<line32>}\n<line33>}
----------------------------------------
Function: mp_factor_insert_ui
Content: <line0>static void\n<line1>mp_factor_insert_ui (struct mp_factors *factors, unsigned long int prime)\n<line2>{\n<line3>mpz_t pz;\n<line4>mpz_init_set_ui (pz, prime);\n<line5>mp_factor_insert (factors, pz);\n<line6>mpz_clear (pz);\n<line7>}
----------------------------------------
Function: factor_insert_refind
Content: <line0>static void\n<line1>factor_insert_refind (struct factors *factors, uintmax_t p, int i, int off)\n<line2>{\n<line3>for (int j = 0; j < off; j++)\n<line4>p += primes_diff[i + j];\n<line5>factor_insert (factors, p);\n<line6>}
----------------------------------------
Function: factor_using_division
Content: <line0>static uintmax_t\n<line1>factor_using_division (uintmax_t *t1p, uintmax_t t1, uintmax_t t0,\n<line2>struct factors *factors)\n<line3>{\n<line4>if (t0 % 2 == 0)\n<line5>{\n<line6>int cnt;\n<line7>if (t0 == 0)\n<line8>{\n<line9>count_trailing_zeros (cnt, t1);\n<line10>t0 = t1 >> cnt;\n<line11>t1 = 0;\n<line12>cnt += W_TYPE_SIZE;\n<line13>}\n<line14>else\n<line15>{\n<line16>count_trailing_zeros (cnt, t0);\n<line17>rsh2 (t1, t0, t1, t0, cnt);\n<line18>}\n<line19>factor_insert_multiplicity (factors, 2, cnt);\n<line20>}\n<line21>uintmax_t p = 3;\n<line22>idx_t i;\n<line23>for (i = 0; t1 > 0 && i < PRIMES_PTAB_ENTRIES; i++)\n<line24>{\n<line25>for (;;)\n<line26>{\n<line27>uintmax_t q1, q0, hi;\n<line28>MAYBE_UNUSED uintmax_t lo;\n<line29>q0 = t0 * primes_dtab[i].binv;\n<line30>umul_ppmm (hi, lo, q0, p);\n<line31>if (hi > t1)\n<line32>break;\n<line33>hi = t1 - hi;\n<line34>q1 = hi * primes_dtab[i].binv;\n<line35>if (LIKELY (q1 > primes_dtab[i].lim))\n<line36>break;\n<line37>t1 = q1; t0 = q0;\n<line38>factor_insert (factors, p);\n<line39>}\n<line40>p += primes_diff[i + 1];\n<line41>}\n<line42>if (t1p)\n<line43>*t1p = t1;\n<line44>#define DIVBLOCK(I)                                                     \\n<line45>do {                                                                  \\n<line46>for (;;)                                                            \\n<line47>{                                                                 \\n<line48>q = t0 * pd[I].binv;                                            \\n<line49>if (LIKELY (q > pd[I].lim))                                     \\n<line50>break;                                                        \\n<line51>t0 = q;                                                         \\n<line52>factor_insert_refind (factors, p, i + 1, I);                    \\n<line53>}                                                                 \\n<line54>} while (0)\n<line55>for (; i < PRIMES_PTAB_ENTRIES; i += 8)\n<line56>{\n<line57>uintmax_t q;\n<line58>const struct primes_dtab *pd = &primes_dtab[i];\n<line59>DIVBLOCK (0);\n<line60>DIVBLOCK (1);\n<line61>DIVBLOCK (2);\n<line62>DIVBLOCK (3);\n<line63>DIVBLOCK (4);\n<line64>DIVBLOCK (5);\n<line65>DIVBLOCK (6);\n<line66>DIVBLOCK (7);\n<line67>p += primes_diff8[i];\n<line68>if (p * p > t0)\n<line69>break;\n<line70>}\n<line71>return t0;\n<line72>}
----------------------------------------
Function: mp_factor_using_division
Content: <line0>static void\n<line1>mp_factor_using_division (mpz_t t, struct mp_factors *factors)\n<line2>{\n<line3>mpz_t q;\n<line4>mp_bitcnt_t p;\n<line5>devmsg ("[trial division] ");\n<line6>mpz_init (q);\n<line7>p = mpz_scan1 (t, 0);\n<line8>mpz_fdiv_q_2exp (t, t, p);\n<line9>while (p)\n<line10>{\n<line11>mp_factor_insert_ui (factors, 2);\n<line12>--p;\n<line13>}\n<line14>unsigned long int d = 3;\n<line15>for (idx_t i = 1; i <= PRIMES_PTAB_ENTRIES;)\n<line16>{\n<line17>if (! mpz_divisible_ui_p (t, d))\n<line18>{\n<line19>d += primes_diff[i++];\n<line20>if (mpz_cmp_ui (t, d * d) < 0)\n<line21>break;\n<line22>}\n<line23>else\n<line24>{\n<line25>mpz_tdiv_q_ui (t, t, d);\n<line26>mp_factor_insert_ui (factors, d);\n<line27>}\n<line28>}\n<line29>mpz_clear (q);\n<line30>}
----------------------------------------
Function: mulredc
Content: <line0>static inline uintmax_t\n<line1>mulredc (uintmax_t a, uintmax_t b, uintmax_t m, uintmax_t mi)\n<line2>{\n<line3>uintmax_t rh, rl, q, th, xh;\n<line4>MAYBE_UNUSED uintmax_t tl;\n<line5>umul_ppmm (rh, rl, a, b);\n<line6>q = rl * mi;\n<line7>umul_ppmm (th, tl, q, m);\n<line8>xh = rh - th;\n<line9>if (rh < th)\n<line10>xh += m;\n<line11>return xh;\n<line12>}
----------------------------------------
Function: mulredc2
Content: <line0>static uintmax_t\n<line1>mulredc2 (uintmax_t *r1p,\n<line2>uintmax_t a1, uintmax_t a0, uintmax_t b1, uintmax_t b0,\n<line3>uintmax_t m1, uintmax_t m0, uintmax_t mi)\n<line4>{\n<line5>uintmax_t r1, r0, q, p1, t1, t0, s1, s0;\n<line6>MAYBE_UNUSED uintmax_t p0;\n<line7>mi = -mi;\n<line8>affirm ((a1 >> (W_TYPE_SIZE - 1)) == 0);\n<line9>affirm ((b1 >> (W_TYPE_SIZE - 1)) == 0);\n<line10>affirm ((m1 >> (W_TYPE_SIZE - 1)) == 0);\n<line11>/* First compute a0 * <b1, b0> B^{-1}\n<line12>+-----+\n<line13>|a0 b0|\n<line14>+--+--+--+\n<line15>|a0 b1|\n<line16>+--+--+--+\n<line17>|q0 m0|\n<line18>+--+--+--+\n<line19>|q0 m1|\n<line20>-+--+--+--+\n<line21>|r1|r0| 0|\n<line22>+--+--+--+\n<line23>*/\n<line24>umul_ppmm (t1, t0, a0, b0);\n<line25>umul_ppmm (r1, r0, a0, b1);\n<line26>q = mi * t0;\n<line27>umul_ppmm (p1, p0, q, m0);\n<line28>umul_ppmm (s1, s0, q, m1);\n<line29>r0 += (t0 != 0); /* Carry */\n<line30>add_ssaaaa (r1, r0, r1, r0, 0, p1);\n<line31>add_ssaaaa (r1, r0, r1, r0, 0, t1);\n<line32>add_ssaaaa (r1, r0, r1, r0, s1, s0);\n<line33>/* Next, (a1 * <b1, b0> + <r1, r0> B^{-1}\n<line34>+-----+\n<line35>|a1 b0|\n<line36>+--+--+\n<line37>|r1|r0|\n<line38>+--+--+--+\n<line39>|a1 b1|\n<line40>+--+--+--+\n<line41>|q1 m0|\n<line42>+--+--+--+\n<line43>|q1 m1|\n<line44>-+--+--+--+\n<line45>|r1|r0| 0|\n<line46>+--+--+--+\n<line47>*/\n<line48>umul_ppmm (t1, t0, a1, b0);\n<line49>umul_ppmm (s1, s0, a1, b1);\n<line50>add_ssaaaa (t1, t0, t1, t0, 0, r0);\n<line51>q = mi * t0;\n<line52>add_ssaaaa (r1, r0, s1, s0, 0, r1);\n<line53>umul_ppmm (p1, p0, q, m0);\n<line54>umul_ppmm (s1, s0, q, m1);\n<line55>r0 += (t0 != 0); /* Carry */\n<line56>add_ssaaaa (r1, r0, r1, r0, 0, p1);\n<line57>add_ssaaaa (r1, r0, r1, r0, 0, t1);\n<line58>add_ssaaaa (r1, r0, r1, r0, s1, s0);\n<line59>if (ge2 (r1, r0, m1, m0))\n<line60>sub_ddmmss (r1, r0, r1, r0, m1, m0);\n<line61>*r1p = r1;\n<line62>return r0;\n<line63>}
----------------------------------------
Function: powm2
Content: <line0>static uintmax_t\n<line1>powm2 (uintmax_t *r1m,\n<line2>const uintmax_t *bp, const uintmax_t *ep, const uintmax_t *np,\n<line3>uintmax_t ni, const uintmax_t *one)\n<line4>{\n<line5>uintmax_t r1, r0, b1, b0, n1, n0;\n<line6>int i;\n<line7>uintmax_t e;\n<line8>b0 = bp[0];\n<line9>b1 = bp[1];\n<line10>n0 = np[0];\n<line11>n1 = np[1];\n<line12>r0 = one[0];\n<line13>r1 = one[1];\n<line14>for (e = ep[0], i = W_TYPE_SIZE; i > 0; i--, e >>= 1)\n<line15>{\n<line16>if (e & 1)\n<line17>{\n<line18>r0 = mulredc2 (r1m, r1, r0, b1, b0, n1, n0, ni);\n<line19>r1 = *r1m;\n<line20>}\n<line21>b0 = mulredc2 (r1m, b1, b0, b1, b0, n1, n0, ni);\n<line22>b1 = *r1m;\n<line23>}\n<line24>for (e = ep[1]; e > 0; e >>= 1)\n<line25>{\n<line26>if (e & 1)\n<line27>{\n<line28>r0 = mulredc2 (r1m, r1, r0, b1, b0, n1, n0, ni);\n<line29>r1 = *r1m;\n<line30>}\n<line31>b0 = mulredc2 (r1m, b1, b0, b1, b0, n1, n0, ni);\n<line32>b1 = *r1m;\n<line33>}\n<line34>*r1m = r1;\n<line35>return r0;\n<line36>}
----------------------------------------
Function: mp_millerrabin
Content: <line0>static bool\n<line1>mp_millerrabin (mpz_srcptr n, mpz_srcptr nm1, mpz_ptr x, mpz_ptr y,\n<line2>mpz_srcptr q, mp_bitcnt_t k)\n<line3>{\n<line4>mpz_powm (y, x, q, n);\n<line5>if (mpz_cmp_ui (y, 1) == 0 || mpz_cmp (y, nm1) == 0)\n<line6>return true;\n<line7>for (mp_bitcnt_t i = 1; i < k; i++)\n<line8>{\n<line9>mpz_powm_ui (y, y, 2, n);\n<line10>if (mpz_cmp (y, nm1) == 0)\n<line11>return true;\n<line12>if (mpz_cmp_ui (y, 1) == 0)\n<line13>return false;\n<line14>}\n<line15>return false;\n<line16>}
----------------------------------------
Function: prime_p
Content: <line0>static bool ATTRIBUTE_PURE\n<line1>prime_p (uintmax_t n)\n<line2>{\n<line3>mp_bitcnt_t k;\n<line4>bool is_prime;\n<line5>uintmax_t a_prim, one, ni;\n<line6>struct factors factors;\n<line7>if (n <= 1)\n<line8>return false;\n<line9>/* We have already cast out small primes.  */\n<line10>if (n < (uintmax_t) FIRST_OMITTED_PRIME * FIRST_OMITTED_PRIME)\n<line11>return true;\n<line12>/* Precomputation for Miller-Rabin.  */\n<line13>uintmax_t q = n - 1;\n<line14>for (k = 0; (q & 1) == 0; k++)\n<line15>q >>= 1;\n<line16>uintmax_t a = 2;\n<line17>binv (ni, n);                 /* ni <- 1/n mod B */\n<line18>redcify (one, 1, n);\n<line19>addmod (a_prim, one, one, n); /* i.e., redcify a = 2 */\n<line20>/* Perform a Miller-Rabin test, finds most composites quickly.  */\n<line21>if (!millerrabin (n, ni, a_prim, q, k, one))\n<line22>return false;\n<line23>if (flag_prove_primality)\n<line24>{\n<line25>/* Factor n-1 for Lucas.  */\n<line26>factor (0, n - 1, &factors);\n<line27>}\n<line28>/* Loop until Lucas proves our number prime, or Miller-Rabin proves our\n<line29>number composite.  */\n<line30>for (idx_t r = 0; r < PRIMES_PTAB_ENTRIES; r++)\n<line31>{\n<line32>if (flag_prove_primality)\n<line33>{\n<line34>is_prime = true;\n<line35>for (int i = 0; i < factors.nfactors && is_prime; i++)\n<line36>{\n<line37>is_prime\n<line38>= powm (a_prim, (n - 1) / factors.p[i], n, ni, one) != one;\n<line39>}\n<line40>}\n<line41>else\n<line42>{\n<line43>/* After enough Miller-Rabin runs, be content.  */\n<line44>is_prime = (r == MR_REPS - 1);\n<line45>}\n<line46>if (is_prime)\n<line47>return true;\n<line48>a += primes_diff[r];      /* Establish new base.  */\n<line49>/* The following is equivalent to redcify (a_prim, a, n).  It runs faster\n<line50>on most processors, since it avoids udiv_qrnnd.  If we go down the\n<line51>udiv_qrnnd_preinv path, this code should be replaced.  */\n<line52>{\n<line53>uintmax_t s1, s0;\n<line54>umul_ppmm (s1, s0, one, a);\n<line55>if (LIKELY (s1 == 0))\n<line56>a_prim = s0 % n;\n<line57>else\n<line58>{\n<line59>MAYBE_UNUSED uintmax_t dummy;\n<line60>udiv_qrnnd (dummy, a_prim, s1, s0, n);\n<line61>}\n<line62>}\n<line63>if (!millerrabin (n, ni, a_prim, q, k, one))\n<line64>return false;\n<line65>}\n<line66>affirm (!"Lucas prime test failure.  This should not happen");\n<line67>}
----------------------------------------
Function: prime2_p
Content: <line0>static bool ATTRIBUTE_PURE\n<line1>prime2_p (uintmax_t n1, uintmax_t n0)\n<line2>{\n<line3>uintmax_t q[2], nm1[2];\n<line4>uintmax_t a_prim[2];\n<line5>uintmax_t one[2];\n<line6>uintmax_t na[2];\n<line7>uintmax_t ni;\n<line8>int k;\n<line9>struct factors factors;\n<line10>if (n1 == 0)\n<line11>return prime_p (n0);\n<line12>nm1[1] = n1 - (n0 == 0);\n<line13>nm1[0] = n0 - 1;\n<line14>if (nm1[0] == 0)\n<line15>{\n<line16>count_trailing_zeros (k, nm1[1]);\n<line17>q[0] = nm1[1] >> k;\n<line18>q[1] = 0;\n<line19>k += W_TYPE_SIZE;\n<line20>}\n<line21>else\n<line22>{\n<line23>count_trailing_zeros (k, nm1[0]);\n<line24>rsh2 (q[1], q[0], nm1[1], nm1[0], k);\n<line25>}\n<line26>uintmax_t a = 2;\n<line27>binv (ni, n0);\n<line28>redcify2 (one[1], one[0], 1, n1, n0);\n<line29>addmod2 (a_prim[1], a_prim[0], one[1], one[0], one[1], one[0], n1, n0);\n<line30>/* FIXME: Use scalars or pointers in arguments?  Some consistency needed.  */\n<line31>na[0] = n0;\n<line32>na[1] = n1;\n<line33>if (!millerrabin2 (na, ni, a_prim, q, k, one))\n<line34>return false;\n<line35>if (flag_prove_primality)\n<line36>{\n<line37>/* Factor n-1 for Lucas.  */\n<line38>factor (nm1[1], nm1[0], &factors);\n<line39>}\n<line40>/* Loop until Lucas proves our number prime, or Miller-Rabin proves our\n<line41>number composite.  */\n<line42>for (idx_t r = 0; r < PRIMES_PTAB_ENTRIES; r++)\n<line43>{\n<line44>bool is_prime;\n<line45>uintmax_t e[2], y[2];\n<line46>if (flag_prove_primality)\n<line47>{\n<line48>is_prime = true;\n<line49>if (factors.plarge[1])\n<line50>{\n<line51>uintmax_t pi;\n<line52>binv (pi, factors.plarge[0]);\n<line53>e[0] = pi * nm1[0];\n<line54>e[1] = 0;\n<line55>y[0] = powm2 (&y[1], a_prim, e, na, ni, one);\n<line56>is_prime = (y[0] != one[0] || y[1] != one[1]);\n<line57>}\n<line58>for (int i = 0; i < factors.nfactors && is_prime; i++)\n<line59>{\n<line60>/* FIXME: We always have the factor 2.  Do we really need to\n<line61>handle it here?  We have done the same powering as part\n<line62>of millerrabin.  */\n<line63>if (factors.p[i] == 2)\n<line64>rsh2 (e[1], e[0], nm1[1], nm1[0], 1);\n<line65>else\n<line66>divexact_21 (e[1], e[0], nm1[1], nm1[0], factors.p[i]);\n<line67>y[0] = powm2 (&y[1], a_prim, e, na, ni, one);\n<line68>is_prime = (y[0] != one[0] || y[1] != one[1]);\n<line69>}\n<line70>}\n<line71>else\n<line72>{\n<line73>/* After enough Miller-Rabin runs, be content.  */\n<line74>is_prime = (r == MR_REPS - 1);\n<line75>}\n<line76>if (is_prime)\n<line77>return true;\n<line78>a += primes_diff[r];      /* Establish new base.  */\n<line79>redcify2 (a_prim[1], a_prim[0], a, n1, n0);\n<line80>if (!millerrabin2 (na, ni, a_prim, q, k, one))\n<line81>return false;\n<line82>}\n<line83>affirm (!"Lucas prime test failure.  This should not happen");\n<line84>}
----------------------------------------
Function: mp_prime_p
Content: <line0>static bool\n<line1>mp_prime_p (mpz_t n)\n<line2>{\n<line3>bool is_prime;\n<line4>mpz_t q, a, nm1, tmp;\n<line5>struct mp_factors factors;\n<line6>if (mpz_cmp_ui (n, 1) <= 0)\n<line7>return false;\n<line8>/* We have already cast out small primes.  */\n<line9>if (mpz_cmp_ui (n, (long) FIRST_OMITTED_PRIME * FIRST_OMITTED_PRIME) < 0)\n<line10>return true;\n<line11>mpz_inits (q, a, nm1, tmp, nullptr);\n<line12>/* Precomputation for Miller-Rabin.  */\n<line13>mpz_sub_ui (nm1, n, 1);\n<line14>/* Find q and k, where q is odd and n = 1 + 2**k * q.  */\n<line15>mp_bitcnt_t k = mpz_scan1 (nm1, 0);\n<line16>mpz_tdiv_q_2exp (q, nm1, k);\n<line17>mpz_set_ui (a, 2);\n<line18>/* Perform a Miller-Rabin test, finds most composites quickly.  */\n<line19>if (!mp_millerrabin (n, nm1, a, tmp, q, k))\n<line20>{\n<line21>is_prime = false;\n<line22>goto ret2;\n<line23>}\n<line24>if (flag_prove_primality)\n<line25>{\n<line26>/* Factor n-1 for Lucas.  */\n<line27>mpz_set (tmp, nm1);\n<line28>mp_factor (tmp, &factors);\n<line29>}\n<line30>/* Loop until Lucas proves our number prime, or Miller-Rabin proves our\n<line31>number composite.  */\n<line32>for (idx_t r = 0; r < PRIMES_PTAB_ENTRIES; r++)\n<line33>{\n<line34>if (flag_prove_primality)\n<line35>{\n<line36>is_prime = true;\n<line37>for (idx_t i = 0; i < factors.nfactors && is_prime; i++)\n<line38>{\n<line39>mpz_divexact (tmp, nm1, factors.p[i]);\n<line40>mpz_powm (tmp, a, tmp, n);\n<line41>is_prime = mpz_cmp_ui (tmp, 1) != 0;\n<line42>}\n<line43>}\n<line44>else\n<line45>{\n<line46>/* After enough Miller-Rabin runs, be content.  */\n<line47>is_prime = (r == MR_REPS - 1);\n<line48>}\n<line49>if (is_prime)\n<line50>goto ret1;\n<line51>mpz_add_ui (a, a, primes_diff[r]);        /* Establish new base.  */\n<line52>if (!mp_millerrabin (n, nm1, a, tmp, q, k))\n<line53>{\n<line54>is_prime = false;\n<line55>goto ret1;\n<line56>}\n<line57>}\n<line58>affirm (!"Lucas prime test failure.  This should not happen");\n<line59>ret1:\n<line60>if (flag_prove_primality)\n<line61>mp_factor_clear (&factors);\n<line62>ret2:\n<line63>mpz_clears (q, a, nm1, tmp, nullptr);\n<line64>return is_prime;\n<line65>}
----------------------------------------
Function: factor_using_pollard_rho
Content: <line0>static void\n<line1>factor_using_pollard_rho (uintmax_t n, unsigned long int a,\n<line2>struct factors *factors)\n<line3>{\n<line4>uintmax_t x, z, y, P, t, ni, g;\n<line5>unsigned long int k = 1;\n<line6>unsigned long int l = 1;\n<line7>redcify (P, 1, n);\n<line8>addmod (x, P, P, n);          /* i.e., redcify(2) */\n<line9>y = z = x;\n<line10>while (n != 1)\n<line11>{\n<line12>affirm (a < n);\n<line13>binv (ni, n);             /* FIXME: when could we use old 'ni' value?  */\n<line14>for (;;)\n<line15>{\n<line16>do\n<line17>{\n<line18>x = mulredc (x, x, n, ni);\n<line19>addmod (x, x, a, n);\n<line20>submod (t, z, x, n);\n<line21>P = mulredc (P, t, n, ni);\n<line22>if (k % 32 == 1)\n<line23>{\n<line24>if (gcd_odd (P, n) != 1)\n<line25>goto factor_found;\n<line26>y = x;\n<line27>}\n<line28>}\n<line29>while (--k != 0);\n<line30>z = x;\n<line31>k = l;\n<line32>l = 2 * l;\n<line33>for (unsigned long int i = 0; i < k; i++)\n<line34>{\n<line35>x = mulredc (x, x, n, ni);\n<line36>addmod (x, x, a, n);\n<line37>}\n<line38>y = x;\n<line39>}\n<line40>factor_found:\n<line41>do\n<line42>{\n<line43>y = mulredc (y, y, n, ni);\n<line44>addmod (y, y, a, n);\n<line45>submod (t, z, y, n);\n<line46>g = gcd_odd (t, n);\n<line47>}\n<line48>while (g == 1);\n<line49>if (n == g)\n<line50>{\n<line51>/* Found n itself as factor.  Restart with different params.  */\n<line52>factor_using_pollard_rho (n, a + 1, factors);\n<line53>return;\n<line54>}\n<line55>n = n / g;\n<line56>if (!prime_p (g))\n<line57>factor_using_pollard_rho (g, a + 1, factors);\n<line58>else\n<line59>factor_insert (factors, g);\n<line60>if (prime_p (n))\n<line61>{\n<line62>factor_insert (factors, n);\n<line63>break;\n<line64>}\n<line65>x = x % n;\n<line66>z = z % n;\n<line67>y = y % n;\n<line68>}\n<line69>}
----------------------------------------
Function: factor_using_pollard_rho2
Content: <line0>static void\n<line1>factor_using_pollard_rho2 (uintmax_t n1, uintmax_t n0, unsigned long int a,\n<line2>struct factors *factors)\n<line3>{\n<line4>uintmax_t x1, x0, z1, z0, y1, y0, P1, P0, t1, t0, ni, g1, g0, r1m;\n<line5>unsigned long int k = 1;\n<line6>unsigned long int l = 1;\n<line7>redcify2 (P1, P0, 1, n1, n0);\n<line8>addmod2 (x1, x0, P1, P0, P1, P0, n1, n0); /* i.e., redcify(2) */\n<line9>y1 = z1 = x1;\n<line10>y0 = z0 = x0;\n<line11>while (n1 != 0 || n0 != 1)\n<line12>{\n<line13>binv (ni, n0);\n<line14>for (;;)\n<line15>{\n<line16>do\n<line17>{\n<line18>x0 = mulredc2 (&r1m, x1, x0, x1, x0, n1, n0, ni);\n<line19>x1 = r1m;\n<line20>addmod2 (x1, x0, x1, x0, 0, (uintmax_t) a, n1, n0);\n<line21>submod2 (t1, t0, z1, z0, x1, x0, n1, n0);\n<line22>P0 = mulredc2 (&r1m, P1, P0, t1, t0, n1, n0, ni);\n<line23>P1 = r1m;\n<line24>if (k % 32 == 1)\n<line25>{\n<line26>g0 = gcd2_odd (&g1, P1, P0, n1, n0);\n<line27>if (g1 != 0 || g0 != 1)\n<line28>goto factor_found;\n<line29>y1 = x1; y0 = x0;\n<line30>}\n<line31>}\n<line32>while (--k != 0);\n<line33>z1 = x1; z0 = x0;\n<line34>k = l;\n<line35>l = 2 * l;\n<line36>for (unsigned long int i = 0; i < k; i++)\n<line37>{\n<line38>x0 = mulredc2 (&r1m, x1, x0, x1, x0, n1, n0, ni);\n<line39>x1 = r1m;\n<line40>addmod2 (x1, x0, x1, x0, 0, (uintmax_t) a, n1, n0);\n<line41>}\n<line42>y1 = x1; y0 = x0;\n<line43>}\n<line44>factor_found:\n<line45>do\n<line46>{\n<line47>y0 = mulredc2 (&r1m, y1, y0, y1, y0, n1, n0, ni);\n<line48>y1 = r1m;\n<line49>addmod2 (y1, y0, y1, y0, 0, (uintmax_t) a, n1, n0);\n<line50>submod2 (t1, t0, z1, z0, y1, y0, n1, n0);\n<line51>g0 = gcd2_odd (&g1, t1, t0, n1, n0);\n<line52>}\n<line53>while (g1 == 0 && g0 == 1);\n<line54>if (g1 == 0)\n<line55>{\n<line56>/* The found factor is one word, and > 1.  */\n<line57>divexact_21 (n1, n0, n1, n0, g0);     /* n = n / g */\n<line58>if (!prime_p (g0))\n<line59>factor_using_pollard_rho (g0, a + 1, factors);\n<line60>else\n<line61>factor_insert (factors, g0);\n<line62>}\n<line63>else\n<line64>{\n<line65>/* The found factor is two words.  This is highly unlikely, thus hard\n<line66>to trigger.  Please be careful before you change this code!  */\n<line67>uintmax_t ginv;\n<line68>if (n1 == g1 && n0 == g0)\n<line69>{\n<line70>/* Found n itself as factor.  Restart with different params.  */\n<line71>factor_using_pollard_rho2 (n1, n0, a + 1, factors);\n<line72>return;\n<line73>}\n<line74>/* Compute n = n / g.  Since the result will fit one word,\n<line75>we can compute the quotient modulo B, ignoring the high\n<line76>divisor word.  */\n<line77>binv (ginv, g0);\n<line78>n0 = ginv * n0;\n<line79>n1 = 0;\n<line80>if (!prime2_p (g1, g0))\n<line81>factor_using_pollard_rho2 (g1, g0, a + 1, factors);\n<line82>else\n<line83>factor_insert_large (factors, g1, g0);\n<line84>}\n<line85>if (n1 == 0)\n<line86>{\n<line87>if (prime_p (n0))\n<line88>{\n<line89>factor_insert (factors, n0);\n<line90>break;\n<line91>}\n<line92>factor_using_pollard_rho (n0, a, factors);\n<line93>return;\n<line94>}\n<line95>if (prime2_p (n1, n0))\n<line96>{\n<line97>factor_insert_large (factors, n1, n0);\n<line98>break;\n<line99>}\n<line100>x0 = mod2 (&x1, x1, x0, n1, n0);\n<line101>z0 = mod2 (&z1, z1, z0, n1, n0);\n<line102>y0 = mod2 (&y1, y1, y0, n1, n0);\n<line103>}\n<line104>}
----------------------------------------
Function: mp_factor_using_pollard_rho
Content: <line0>static void\n<line1>mp_factor_using_pollard_rho (mpz_t n, unsigned long int a,\n<line2>struct mp_factors *factors)\n<line3>{\n<line4>mpz_t x, z, y, P;\n<line5>mpz_t t, t2;\n<line6>devmsg ("[pollard-rho (%lu)] ", a);\n<line7>mpz_inits (t, t2, nullptr);\n<line8>mpz_init_set_si (y, 2);\n<line9>mpz_init_set_si (x, 2);\n<line10>mpz_init_set_si (z, 2);\n<line11>mpz_init_set_ui (P, 1);\n<line12>unsigned long long int k = 1;\n<line13>unsigned long long int l = 1;\n<line14>while (mpz_cmp_ui (n, 1) != 0)\n<line15>{\n<line16>for (;;)\n<line17>{\n<line18>do\n<line19>{\n<line20>mpz_mul (t, x, x);\n<line21>mpz_mod (x, t, n);\n<line22>mpz_add_ui (x, x, a);\n<line23>mpz_sub (t, z, x);\n<line24>mpz_mul (t2, P, t);\n<line25>mpz_mod (P, t2, n);\n<line26>if (k % 32 == 1)\n<line27>{\n<line28>mpz_gcd (t, P, n);\n<line29>if (mpz_cmp_ui (t, 1) != 0)\n<line30>goto factor_found;\n<line31>mpz_set (y, x);\n<line32>}\n<line33>}\n<line34>while (--k != 0);\n<line35>mpz_set (z, x);\n<line36>k = l;\n<line37>l = 2 * l;\n<line38>for (unsigned long long int i = 0; i < k; i++)\n<line39>{\n<line40>mpz_mul (t, x, x);\n<line41>mpz_mod (x, t, n);\n<line42>mpz_add_ui (x, x, a);\n<line43>}\n<line44>mpz_set (y, x);\n<line45>}\n<line46>factor_found:\n<line47>do\n<line48>{\n<line49>mpz_mul (t, y, y);\n<line50>mpz_mod (y, t, n);\n<line51>mpz_add_ui (y, y, a);\n<line52>mpz_sub (t, z, y);\n<line53>mpz_gcd (t, t, n);\n<line54>}\n<line55>while (mpz_cmp_ui (t, 1) == 0);\n<line56>mpz_divexact (n, n, t);   /* divide by t, before t is overwritten */\n<line57>if (!mp_prime_p (t))\n<line58>{\n<line59>devmsg ("[composite factor--restarting pollard-rho] ");\n<line60>mp_factor_using_pollard_rho (t, a + 1, factors);\n<line61>}\n<line62>else\n<line63>{\n<line64>mp_factor_insert (factors, t);\n<line65>}\n<line66>if (mp_prime_p (n))\n<line67>{\n<line68>mp_factor_insert (factors, n);\n<line69>break;\n<line70>}\n<line71>mpz_mod (x, x, n);\n<line72>mpz_mod (z, z, n);\n<line73>mpz_mod (y, y, n);\n<line74>}\n<line75>mpz_clears (P, t2, t, z, x, y, nullptr);\n<line76>}
----------------------------------------
Function: factor
Content: <line0>static void\n<line1>factor (uintmax_t t1, uintmax_t t0, struct factors *factors)\n<line2>{\n<line3>factors->nfactors = 0;\n<line4>factors->plarge[1] = 0;\n<line5>if (t1 == 0 && t0 < 2)\n<line6>return;\n<line7>t0 = factor_using_division (&t1, t1, t0, factors);\n<line8>if (t1 == 0 && t0 < 2)\n<line9>return;\n<line10>if (prime2_p (t1, t0))\n<line11>factor_insert_large (factors, t1, t0);\n<line12>else\n<line13>{\n<line14>#if USE_SQUFOF\n<line15>if (factor_using_squfof (t1, t0, factors))\n<line16>return;\n<line17>#endif\n<line18>if (t1 == 0)\n<line19>factor_using_pollard_rho (t0, 1, factors);\n<line20>else\n<line21>factor_using_pollard_rho2 (t1, t0, 1, factors);\n<line22>}\n<line23>}
----------------------------------------
Function: mp_factor
Content: <line0>static void\n<line1>mp_factor (mpz_t t, struct mp_factors *factors)\n<line2>{\n<line3>mp_factor_init (factors);\n<line4>if (mpz_sgn (t) != 0)\n<line5>{\n<line6>mp_factor_using_division (t, factors);\n<line7>if (mpz_cmp_ui (t, 1) != 0)\n<line8>{\n<line9>devmsg ("[is number prime?] ");\n<line10>if (mp_prime_p (t))\n<line11>mp_factor_insert (factors, t);\n<line12>else\n<line13>mp_factor_using_pollard_rho (t, 1, factors);\n<line14>}\n<line15>}\n<line16>}
----------------------------------------
Function: strto2uintmax
Content: <line0>static strtol_error\n<line1>strto2uintmax (uintmax_t *hip, uintmax_t *lop, char const *s)\n<line2>{\n<line3>int lo_carry;\n<line4>uintmax_t hi = 0, lo = 0;\n<line5>strtol_error err = LONGINT_INVALID;\n<line6>/* Initial scan for invalid digits.  */\n<line7>char const *p = s;\n<line8>for (;;)\n<line9>{\n<line10>unsigned char c = *p++;\n<line11>if (c == 0)\n<line12>break;\n<line13>if (UNLIKELY (!ISDIGIT (c)))\n<line14>{\n<line15>err = LONGINT_INVALID;\n<line16>break;\n<line17>}\n<line18>err = LONGINT_OK;           /* we've seen at least one valid digit */\n<line19>}\n<line20>while (err == LONGINT_OK)\n<line21>{\n<line22>unsigned char c = *s++;\n<line23>if (c == 0)\n<line24>break;\n<line25>c -= '0';\n<line26>if (UNLIKELY (hi > ~(uintmax_t)0 / 10))\n<line27>{\n<line28>err = LONGINT_OVERFLOW;\n<line29>break;\n<line30>}\n<line31>hi = 10 * hi;\n<line32>lo_carry = (lo >> (W_TYPE_SIZE - 3)) + (lo >> (W_TYPE_SIZE - 1));\n<line33>lo_carry += 10 * lo < 2 * lo;\n<line34>lo = 10 * lo;\n<line35>lo += c;\n<line36>lo_carry += lo < c;\n<line37>hi += lo_carry;\n<line38>if (UNLIKELY (hi < lo_carry))\n<line39>{\n<line40>err = LONGINT_OVERFLOW;\n<line41>break;\n<line42>}\n<line43>}\n<line44>*hip = hi;\n<line45>*lop = lo;\n<line46>return err;\n<line47>}
----------------------------------------
Function: lbuf_alloc
Content: <line0>static void\n<line1>lbuf_alloc (void)\n<line2>{\n<line3>if (lbuf.buf)\n<line4>return;\n<line5>/* Double to ensure enough space for\n<line6>previous numbers + next number.  */\n<line7>lbuf.buf = xmalloc (FACTOR_PIPE_BUF * 2);\n<line8>lbuf.end = lbuf.buf;\n<line9>}
----------------------------------------
Function: lbuf_flush
Content: <line0>static void\n<line1>lbuf_flush (void)\n<line2>{\n<line3>size_t size = lbuf.end - lbuf.buf;\n<line4>if (full_write (STDOUT_FILENO, lbuf.buf, size) != size)\n<line5>write_error ();\n<line6>lbuf.end = lbuf.buf;\n<line7>}
----------------------------------------
Function: lbuf_putc
Content: <line0>static void\n<line1>lbuf_putc (char c)\n<line2>{\n<line3>*lbuf.end++ = c;\n<line4>if (c == '\n')\n<line5>{\n<line6>size_t buffered = lbuf.end - lbuf.buf;\n<line7>/* Provide immediate output for interactive use.  */\n<line8>static int line_buffered = -1;\n<line9>if (line_buffered == -1)\n<line10>line_buffered = isatty (STDIN_FILENO) || isatty (STDOUT_FILENO);\n<line11>if (line_buffered)\n<line12>lbuf_flush ();\n<line13>else if (buffered >= FACTOR_PIPE_BUF)\n<line14>{\n<line15>/* Write output in <= PIPE_BUF chunks\n<line16>so consumers can read atomically.  */\n<line17>char const *tend = lbuf.end;\n<line18>/* Since a umaxint_t's factors must fit in 512\n<line19>we're guaranteed to find a newline here.  */\n<line20>char *tlend = lbuf.buf + FACTOR_PIPE_BUF;\n<line21>while (*--tlend != '\n');\n<line22>tlend++;\n<line23>lbuf.end = tlend;\n<line24>lbuf_flush ();\n<line25>/* Buffer the remainder.  */\n<line26>memcpy (lbuf.buf, tlend, tend - tlend);\n<line27>lbuf.end = lbuf.buf + (tend - tlend);\n<line28>}\n<line29>}\n<line30>}
----------------------------------------
Function: lbuf_putint
Content: <line0>static void\n<line1>lbuf_putint (uintmax_t i, size_t min_width)\n<line2>{\n<line3>char buf[INT_BUFSIZE_BOUND (uintmax_t)];\n<line4>char const *umaxstr = umaxtostr (i, buf);\n<line5>size_t width = sizeof (buf) - (umaxstr - buf) - 1;\n<line6>size_t z = width;\n<line7>for (; z < min_width; z++)\n<line8>*lbuf.end++ = '0';\n<line9>memcpy (lbuf.end, umaxstr, width);\n<line10>lbuf.end += width;\n<line11>}
----------------------------------------
Function: print_uintmaxes
Content: <line0>static void\n<line1>print_uintmaxes (uintmax_t t1, uintmax_t t0)\n<line2>{\n<line3>uintmax_t q, r;\n<line4>if (t1 == 0)\n<line5>lbuf_putint (t0, 0);\n<line6>else\n<line7>{\n<line8>/* Use very plain code here since it seems hard to write fast code\n<line9>without assuming a specific word size.  */\n<line10>q = t1 / 1000000000;\n<line11>r = t1 % 1000000000;\n<line12>udiv_qrnnd (t0, r, r, t0, 1000000000);\n<line13>print_uintmaxes (q, t0);\n<line14>lbuf_putint (r, 9);\n<line15>}\n<line16>}
----------------------------------------
Function: print_factors_single
Content: <line0>static void\n<line1>print_factors_single (uintmax_t t1, uintmax_t t0)\n<line2>{\n<line3>struct factors factors;\n<line4>print_uintmaxes (t1, t0);\n<line5>lbuf_putc (':');\n<line6>factor (t1, t0, &factors);\n<line7>for (int j = 0; j < factors.nfactors; j++)\n<line8>for (int k = 0; k < factors.e[j]; k++)\n<line9>{\n<line10>lbuf_putc (' ');\n<line11>print_uintmaxes (0, factors.p[j]);\n<line12>if (print_exponents && factors.e[j] > 1)\n<line13>{\n<line14>lbuf_putc ('^');\n<line15>lbuf_putint (factors.e[j], 0);\n<line16>break;\n<line17>}\n<line18>}\n<line19>if (factors.plarge[1])\n<line20>{\n<line21>lbuf_putc (' ');\n<line22>print_uintmaxes (factors.plarge[1], factors.plarge[0]);\n<line23>}\n<line24>lbuf_putc ('\n');\n<line25>}
----------------------------------------
Function: print_factors
Content: <line0>static bool\n<line1>print_factors (char const *input)\n<line2>{\n<line3>/* Skip initial spaces and '+'.  */\n<line4>char const *str = input;\n<line5>while (*str == ' ')\n<line6>str++;\n<line7>str += *str == '+';\n<line8>uintmax_t t1, t0;\n<line9>/* Try converting the number to one or two words.  If it fails, use GMP or\n<line10>print an error message.  The 2nd condition checks that the most\n<line11>significant bit of the two-word number is clear, in a typesize neutral\n<line12>way.  */\n<line13>strtol_error err = strto2uintmax (&t1, &t0, str);\n<line14>switch (err)\n<line15>{\n<line16>case LONGINT_OK:\n<line17>if (((t1 << 1) >> 1) == t1)\n<line18>{\n<line19>devmsg ("[using single-precision arithmetic] ");\n<line20>print_factors_single (t1, t0);\n<line21>return true;\n<line22>}\n<line23>break;\n<line24>case LONGINT_OVERFLOW:\n<line25>/* Try GMP.  */\n<line26>break;\n<line27>default:\n<line28>error (0, 0, _("%s is not a valid positive integer"), quote (input));\n<line29>return false;\n<line30>}\n<line31>devmsg ("[using arbitrary-precision arithmetic] ");\n<line32>mpz_t t;\n<line33>struct mp_factors factors;\n<line34>mpz_init_set_str (t, str, 10);\n<line35>mpz_out_str (stdout, 10, t);\n<line36>putchar (':');\n<line37>mp_factor (t, &factors);\n<line38>for (idx_t j = 0; j < factors.nfactors; j++)\n<line39>for (unsigned long int k = 0; k < factors.e[j]; k++)\n<line40>{\n<line41>putchar (' ');\n<line42>mpz_out_str (stdout, 10, factors.p[j]);\n<line43>if (print_exponents && factors.e[j] > 1)\n<line44>{\n<line45>printf ("^%lu", factors.e[j]);\n<line46>break;\n<line47>}\n<line48>}\n<line49>mp_factor_clear (&factors);\n<line50>mpz_clear (t);\n<line51>putchar ('\n');\n<line52>fflush (stdout);\n<line53>return true;\n<line54>}
----------------------------------------
Function: usage
Content: <line0>void\n<line1>usage (int status)\n<line2>{\n<line3>if (status != EXIT_SUCCESS)\n<line4>emit_try_help ();\n<line5>else\n<line6>{\n<line7>printf (_("\\n<line8>Usage: %s [OPTION] [NUMBER]...\n\\n<line9>"),\n<line10>program_name);\n<line11>fputs (_("\\n<line12>Print the prime factors of each specified integer NUMBER.  If none\n\\n<line13>are specified on the command line, read them from standard input.\n\\n<line14>\n\\n<line15>"), stdout);\n<line16>fputs ("\\n<line17>-h, --exponents   print repeated factors in form p^e unless e is 1\n\\n<line18>", stdout);\n<line19>fputs (HELP_OPTION_DESCRIPTION, stdout);\n<line20>fputs (VERSION_OPTION_DESCRIPTION, stdout);\n<line21>emit_ancillary_info (PROGRAM_NAME);\n<line22>}\n<line23>exit (status);\n<line24>}
----------------------------------------
Function: do_stdin
Content: <line0>static bool\n<line1>do_stdin (void)\n<line2>{\n<line3>bool ok = true;\n<line4>token_buffer tokenbuffer;\n<line5>init_tokenbuffer (&tokenbuffer);\n<line6>while (true)\n<line7>{\n<line8>size_t token_length = readtoken (stdin, DELIM, sizeof (DELIM) - 1,\n<line9>&tokenbuffer);\n<line10>if (token_length == (size_t) -1)\n<line11>{\n<line12>if (ferror (stdin))\n<line13>error (EXIT_FAILURE, errno, _("error reading input"));\n<line14>break;\n<line15>}\n<line16>ok &= print_factors (tokenbuffer.buffer);\n<line17>}\n<line18>free (tokenbuffer.buffer);\n<line19>return ok;\n<line20>}
----------------------------------------
Function: main
Content: <line0>int\n<line1>main (int argc, char **argv)\n<line2>{\n<line3>initialize_main (&argc, &argv);\n<line4>set_program_name (argv[0]);\n<line5>setlocale (LC_ALL, "");\n<line6>bindtextdomain (PACKAGE, LOCALEDIR);\n<line7>textdomain (PACKAGE);\n<line8>lbuf_alloc ();\n<line9>atexit (close_stdout);\n<line10>atexit (lbuf_flush);\n<line11>int c;\n<line12>while ((c = getopt_long (argc, argv, "h", long_options, nullptr)) != -1)\n<line13>{\n<line14>switch (c)\n<line15>{\n<line16>case 'h':  /* NetBSD used -h for this functionality first.  */\n<line17>print_exponents = true;\n<line18>break;\n<line19>case DEV_DEBUG_OPTION:\n<line20>dev_debug = true;\n<line21>break;\n<line22>case_GETOPT_HELP_CHAR;\n<line23>case_GETOPT_VERSION_CHAR (PROGRAM_NAME, AUTHORS);\n<line24>default:\n<line25>usage (EXIT_FAILURE);\n<line26>}\n<line27>}\n<line28>#if STAT_SQUFOF\n<line29>memset (q_freq, 0, sizeof (q_freq));\n<line30>#endif\n<line31>bool ok;\n<line32>if (argc <= optind)\n<line33>ok = do_stdin ();\n<line34>else\n<line35>{\n<line36>ok = true;\n<line37>for (int i = optind; i < argc; i++)\n<line38>if (! print_factors (argv[i]))\n<line39>ok = false;\n<line40>}\n<line41>#if STAT_SQUFOF\n<line42>if (q_freq[0] > 0)\n<line43>{\n<line44>double acc_f;\n<line45>printf ("q  freq.  cum. freq.(total: %d)\n", q_freq[0]);\n<line46>for (int i = 1, acc_f = 0.0; i <= Q_FREQ_SIZE; i++)\n<line47>{\n<line48>double f = (double) q_freq[i] / q_freq[0];\n<line49>acc_f += f;\n<line50>printf ("%s%d %.2f%% %.2f%%\n", i == Q_FREQ_SIZE ? ">=" : "", i,\n<line51>100.0 * f, 100.0 * acc_f);\n<line52>}\n<line53>}\n<line54>#endif\n<line55>return ok ? EXIT_SUCCESS : EXIT_FAILURE;\n<line56>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/src/false.c
========================================
========================================
/home/huihui/Downloads/coreutils-9.4/src/fmt.c
========================================
Function: usage
Content: <line0>void\n<line1>usage (int status)\n<line2>{\n<line3>if (status != EXIT_SUCCESS)\n<line4>emit_try_help ();\n<line5>else\n<line6>{\n<line7>printf (_("Usage: %s [-WIDTH] [OPTION]... [FILE]...\n"), program_name);\n<line8>fputs (_("\\n<line9>Reformat each paragraph in the FILE(s), writing to standard output.\n\\n<line10>The option -WIDTH is an abbreviated form of --width=DIGITS.\n\\n<line11>"), stdout);\n<line12>emit_stdin_note ();\n<line13>emit_mandatory_arg_note ();\n<line14>fputs (_("\\n<line15>-c, --crown-margin        preserve indentation of first two lines\n\\n<line16>-p, --prefix=STRING       reformat only lines beginning with STRING,\n\\n<line17>reattaching the prefix to reformatted lines\n\\n<line18>-s, --split-only          split long lines, but do not refill\n\\n<line19>"),\n<line20>stdout);\n<line21>/* Tell xgettext that the "% o" below is not a printf-style\n<line22>format string:  xgettext:no-c-format */\n<line23>fputs (_("\\n<line24>-t, --tagged-paragraph    indentation of first line different from second\n\\n<line25>-u, --uniform-spacing     one space between words, two after sentences\n\\n<line26>-w, --width=WIDTH         maximum line width (default of 75 columns)\n\\n<line27>-g, --goal=WIDTH          goal width (default of 93% of width)\n\\n<line28>"), stdout);\n<line29>fputs (HELP_OPTION_DESCRIPTION, stdout);\n<line30>fputs (VERSION_OPTION_DESCRIPTION, stdout);\n<line31>emit_ancillary_info (PROGRAM_NAME);\n<line32>}\n<line33>exit (status);\n<line34>}
----------------------------------------
Function: main
Content: <line0>int\n<line1>main (int argc, char **argv)\n<line2>{\n<line3>int optchar;\n<line4>bool ok = true;\n<line5>char const *max_width_option = nullptr;\n<line6>char const *goal_width_option = nullptr;\n<line7>initialize_main (&argc, &argv);\n<line8>set_program_name (argv[0]);\n<line9>setlocale (LC_ALL, "");\n<line10>bindtextdomain (PACKAGE, LOCALEDIR);\n<line11>textdomain (PACKAGE);\n<line12>atexit (close_stdout);\n<line13>crown = tagged = split = uniform = false;\n<line14>max_width = WIDTH;\n<line15>prefix = "";\n<line16>prefix_length = prefix_lead_space = prefix_full_length = 0;\n<line17>if (argc > 1 && argv[1][0] == '-' && ISDIGIT (argv[1][1]))\n<line18>{\n<line19>/* Old option syntax; a dash followed by one or more digits.  */\n<line20>max_width_option = argv[1] + 1;\n<line21>/* Make the option we just parsed invisible to getopt.  */\n<line22>argv[1] = argv[0];\n<line23>argv++;\n<line24>argc--;\n<line25>}\n<line26>while ((optchar = getopt_long (argc, argv, "0123456789cstuw:p:g:",\n<line27>long_options, nullptr))\n<line28>!= -1)\n<line29>switch (optchar)\n<line30>{\n<line31>default:\n<line32>if (ISDIGIT (optchar))\n<line33>error (0, 0, _("invalid option -- %c; -WIDTH is recognized\\n<line34>only when it is the first\noption; use -w N instead"),\n<line35>optchar);\n<line36>usage (EXIT_FAILURE);\n<line37>case 'c':\n<line38>crown = true;\n<line39>break;\n<line40>case 's':\n<line41>split = true;\n<line42>break;\n<line43>case 't':\n<line44>tagged = true;\n<line45>break;\n<line46>case 'u':\n<line47>uniform = true;\n<line48>break;\n<line49>case 'w':\n<line50>max_width_option = optarg;\n<line51>break;\n<line52>case 'g':\n<line53>goal_width_option = optarg;\n<line54>break;\n<line55>case 'p':\n<line56>set_prefix (optarg);\n<line57>break;\n<line58>case_GETOPT_HELP_CHAR;\n<line59>case_GETOPT_VERSION_CHAR (PROGRAM_NAME, AUTHORS);\n<line60>}\n<line61>if (max_width_option)\n<line62>{\n<line63>/* Limit max_width to MAXCHARS / 2; otherwise, the resulting\n<line64>output can be quite ugly.  */\n<line65>max_width = xdectoumax (max_width_option, 0, MAXCHARS / 2, "",\n<line66>_("invalid width"), 0);\n<line67>}\n<line68>if (goal_width_option)\n<line69>{\n<line70>/* Limit goal_width to max_width.  */\n<line71>goal_width = xdectoumax (goal_width_option, 0, max_width, "",\n<line72>_("invalid width"), 0);\n<line73>if (max_width_option == nullptr)\n<line74>max_width = goal_width + 10;\n<line75>}\n<line76>else\n<line77>{\n<line78>goal_width = max_width * (2 * (100 - LEEWAY) + 1) / 200;\n<line79>}\n<line80>bool have_read_stdin = false;\n<line81>if (optind == argc)\n<line82>{\n<line83>have_read_stdin = true;\n<line84>ok = fmt (stdin, "-");\n<line85>}\n<line86>else\n<line87>{\n<line88>for (; optind < argc; optind++)\n<line89>{\n<line90>char *file = argv[optind];\n<line91>if (STREQ (file, "-"))\n<line92>{\n<line93>ok &= fmt (stdin, file);\n<line94>have_read_stdin = true;\n<line95>}\n<line96>else\n<line97>{\n<line98>FILE *in_stream;\n<line99>in_stream = fopen (file, "r");\n<line100>if (in_stream != nullptr)\n<line101>ok &= fmt (in_stream, file);\n<line102>else\n<line103>{\n<line104>error (0, errno, _("cannot open %s for reading"),\n<line105>quoteaf (file));\n<line106>ok = false;\n<line107>}\n<line108>}\n<line109>}\n<line110>}\n<line111>if (have_read_stdin && fclose (stdin) != 0)\n<line112>error (EXIT_FAILURE, errno, "%s", _("closing standard input"));\n<line113>return ok ? EXIT_SUCCESS : EXIT_FAILURE;\n<line114>}
----------------------------------------
Function: set_prefix
Content: <line0>static void\n<line1>set_prefix (char *p)\n<line2>{\n<line3>char *s;\n<line4>prefix_lead_space = 0;\n<line5>while (*p == ' ')\n<line6>{\n<line7>prefix_lead_space++;\n<line8>p++;\n<line9>}\n<line10>prefix = p;\n<line11>prefix_full_length = strlen (p);\n<line12>s = p + prefix_full_length;\n<line13>while (s > p && s[-1] == ' ')\n<line14>s--;\n<line15>*s = '\0';\n<line16>prefix_length = s - p;\n<line17>}
----------------------------------------
Function: fmt
Content: <line0>static bool\n<line1>fmt (FILE *f, char const *file)\n<line2>{\n<line3>fadvise (f, FADVISE_SEQUENTIAL);\n<line4>tabs = false;\n<line5>other_indent = 0;\n<line6>next_char = get_prefix (f);\n<line7>while (get_paragraph (f))\n<line8>{\n<line9>fmt_paragraph ();\n<line10>put_paragraph (word_limit);\n<line11>}\n<line12>int err = ferror (f) ? 0 : -1;\n<line13>if (f == stdin)\n<line14>clearerr (f);\n<line15>else if (fclose (f) != 0 && err < 0)\n<line16>err = errno;\n<line17>if (0 <= err)\n<line18>error (0, err, err ? "%s" : _("read error"), quotef (file));\n<line19>return err < 0;\n<line20>}
----------------------------------------
Function: set_other_indent
Content: <line0>static void\n<line1>set_other_indent (bool same_paragraph)\n<line2>{\n<line3>if (split)\n<line4>other_indent = first_indent;\n<line5>else if (crown)\n<line6>{\n<line7>other_indent = (same_paragraph ? in_column : first_indent);\n<line8>}\n<line9>else if (tagged)\n<line10>{\n<line11>if (same_paragraph && in_column != first_indent)\n<line12>{\n<line13>other_indent = in_column;\n<line14>}\n<line15>/* Only one line: use the secondary indent from last time if it\n<line16>splits, or 0 if there have been no multi-line paragraphs in the\n<line17>input so far.  But if these rules make the two indents the same,\n<line18>pick a new secondary indent.  */\n<line19>else if (other_indent == first_indent)\n<line20>other_indent = first_indent == 0 ? DEF_INDENT : 0;\n<line21>}\n<line22>else\n<line23>{\n<line24>other_indent = first_indent;\n<line25>}\n<line26>}
----------------------------------------
Function: get_paragraph
Content: <line0>static bool\n<line1>get_paragraph (FILE *f)\n<line2>{\n<line3>int c;\n<line4>last_line_length = 0;\n<line5>c = next_char;\n<line6>/* Scan (and copy) blank lines, and lines not introduced by the prefix.  */\n<line7>while (c == '\n' || c == EOF\n<line8>|| next_prefix_indent < prefix_lead_space\n<line9>|| in_column < next_prefix_indent + prefix_full_length)\n<line10>{\n<line11>c = copy_rest (f, c);\n<line12>if (c == EOF)\n<line13>{\n<line14>next_char = EOF;\n<line15>return false;\n<line16>}\n<line17>putchar ('\n');\n<line18>c = get_prefix (f);\n<line19>}\n<line20>/* Got a suitable first line for a paragraph.  */\n<line21>prefix_indent = next_prefix_indent;\n<line22>first_indent = in_column;\n<line23>wptr = parabuf;\n<line24>word_limit = word;\n<line25>c = get_line (f, c);\n<line26>set_other_indent (same_para (c));\n<line27>/* Read rest of paragraph (unless split is specified).  */\n<line28>if (split)\n<line29>{\n<line30>/* empty */\n<line31>}\n<line32>else if (crown)\n<line33>{\n<line34>if (same_para (c))\n<line35>{\n<line36>do\n<line37>{			/* for each line till the end of the para */\n<line38>c = get_line (f, c);\n<line39>}\n<line40>while (same_para (c) && in_column == other_indent);\n<line41>}\n<line42>}\n<line43>else if (tagged)\n<line44>{\n<line45>if (same_para (c) && in_column != first_indent)\n<line46>{\n<line47>do\n<line48>{			/* for each line till the end of the para */\n<line49>c = get_line (f, c);\n<line50>}\n<line51>while (same_para (c) && in_column == other_indent);\n<line52>}\n<line53>}\n<line54>else\n<line55>{\n<line56>while (same_para (c) && in_column == other_indent)\n<line57>c = get_line (f, c);\n<line58>}\n<line59>(word_limit - 1)->period = (word_limit - 1)->final = true;\n<line60>next_char = c;\n<line61>return true;\n<line62>}
----------------------------------------
Function: copy_rest
Content: <line0>static int\n<line1>copy_rest (FILE *f, int c)\n<line2>{\n<line3>char const *s;\n<line4>out_column = 0;\n<line5>if (in_column > next_prefix_indent || (c != '\n' && c != EOF))\n<line6>{\n<line7>put_space (next_prefix_indent);\n<line8>for (s = prefix; out_column != in_column && *s; out_column++)\n<line9>putchar (*s++);\n<line10>if (c != EOF && c != '\n')\n<line11>put_space (in_column - out_column);\n<line12>if (c == EOF && in_column >= next_prefix_indent + prefix_length)\n<line13>putchar ('\n');\n<line14>}\n<line15>while (c != '\n' && c != EOF)\n<line16>{\n<line17>putchar (c);\n<line18>c = getc (f);\n<line19>}\n<line20>return c;\n<line21>}
----------------------------------------
Function: same_para
Content: <line0>static bool\n<line1>same_para (int c)\n<line2>{\n<line3>return (next_prefix_indent == prefix_indent\n<line4>&& in_column >= next_prefix_indent + prefix_full_length\n<line5>&& c != '\n' && c != EOF);\n<line6>}
----------------------------------------
Function: get_line
Content: <line0>static int\n<line1>get_line (FILE *f, int c)\n<line2>{\n<line3>int start;\n<line4>char *end_of_parabuf;\n<line5>WORD *end_of_word;\n<line6>end_of_parabuf = &parabuf[MAXCHARS];\n<line7>end_of_word = &word[MAXWORDS - 2];\n<line8>do\n<line9>{				/* for each word in a line */\n<line10>/* Scan word.  */\n<line11>word_limit->text = wptr;\n<line12>do\n<line13>{\n<line14>if (wptr == end_of_parabuf)\n<line15>{\n<line16>set_other_indent (true);\n<line17>flush_paragraph ();\n<line18>}\n<line19>*wptr++ = c;\n<line20>c = getc (f);\n<line21>}\n<line22>while (c != EOF && !c_isspace (c));\n<line23>in_column += word_limit->length = wptr - word_limit->text;\n<line24>check_punctuation (word_limit);\n<line25>/* Scan inter-word space.  */\n<line26>start = in_column;\n<line27>c = get_space (f, c);\n<line28>word_limit->space = in_column - start;\n<line29>word_limit->final = (c == EOF\n<line30>|| (word_limit->period\n<line31>&& (c == '\n' || word_limit->space > 1)));\n<line32>if (c == '\n' || c == EOF || uniform)\n<line33>word_limit->space = word_limit->final ? 2 : 1;\n<line34>if (word_limit == end_of_word)\n<line35>{\n<line36>set_other_indent (true);\n<line37>flush_paragraph ();\n<line38>}\n<line39>word_limit++;\n<line40>}\n<line41>while (c != '\n' && c != EOF);\n<line42>return get_prefix (f);\n<line43>}
----------------------------------------
Function: get_prefix
Content: <line0>static int\n<line1>get_prefix (FILE *f)\n<line2>{\n<line3>int c;\n<line4>in_column = 0;\n<line5>c = get_space (f, getc (f));\n<line6>if (prefix_length == 0)\n<line7>next_prefix_indent = prefix_lead_space < in_column ?\n<line8>prefix_lead_space : in_column;\n<line9>else\n<line10>{\n<line11>char const *p;\n<line12>next_prefix_indent = in_column;\n<line13>for (p = prefix; *p != '\0'; p++)\n<line14>{\n<line15>unsigned char pc = *p;\n<line16>if (c != pc)\n<line17>return c;\n<line18>in_column++;\n<line19>c = getc (f);\n<line20>}\n<line21>c = get_space (f, c);\n<line22>}\n<line23>return c;\n<line24>}
----------------------------------------
Function: get_space
Content: <line0>static int\n<line1>get_space (FILE *f, int c)\n<line2>{\n<line3>while (true)\n<line4>{\n<line5>if (c == ' ')\n<line6>in_column++;\n<line7>else if (c == '\t')\n<line8>{\n<line9>tabs = true;\n<line10>in_column = (in_column / TABWIDTH + 1) * TABWIDTH;\n<line11>}\n<line12>else\n<line13>return c;\n<line14>c = getc (f);\n<line15>}\n<line16>}
----------------------------------------
Function: check_punctuation
Content: <line0>static void\n<line1>check_punctuation (WORD *w)\n<line2>{\n<line3>char const *start = w->text;\n<line4>char const *finish = start + (w->length - 1);\n<line5>unsigned char fin = *finish;\n<line6>w->paren = isopen (*start);\n<line7>w->punct = !! ispunct (fin);\n<line8>while (start < finish && isclose (*finish))\n<line9>finish--;\n<line10>w->period = isperiod (*finish);\n<line11>}
----------------------------------------
Function: flush_paragraph
Content: <line0>static void\n<line1>flush_paragraph (void)\n<line2>{\n<line3>WORD *split_point;\n<line4>WORD *w;\n<line5>int shift;\n<line6>COST best_break;\n<line7>/* In the special case where it's all one word, just flush it.  */\n<line8>if (word_limit == word)\n<line9>{\n<line10>fwrite (parabuf, sizeof *parabuf, wptr - parabuf, stdout);\n<line11>wptr = parabuf;\n<line12>return;\n<line13>}\n<line14>/* Otherwise:\n<line15>- format what you have so far as a paragraph,\n<line16>- find a low-cost line break near the end,\n<line17>- output to there,\n<line18>- make that the start of the paragraph.  */\n<line19>fmt_paragraph ();\n<line20>/* Choose a good split point.  */\n<line21>split_point = word_limit;\n<line22>best_break = MAXCOST;\n<line23>for (w = word->next_break; w != word_limit; w = w->next_break)\n<line24>{\n<line25>if (w->best_cost - w->next_break->best_cost < best_break)\n<line26>{\n<line27>split_point = w;\n<line28>best_break = w->best_cost - w->next_break->best_cost;\n<line29>}\n<line30>if (best_break <= MAXCOST - LINE_CREDIT)\n<line31>best_break += LINE_CREDIT;\n<line32>}\n<line33>put_paragraph (split_point);\n<line34>/* Copy text of words down to start of parabuf -- we use memmove because\n<line35>the source and target may overlap.  */\n<line36>memmove (parabuf, split_point->text, wptr - split_point->text);\n<line37>shift = split_point->text - parabuf;\n<line38>wptr -= shift;\n<line39>/* Adjust text pointers.  */\n<line40>for (w = split_point; w <= word_limit; w++)\n<line41>w->text -= shift;\n<line42>/* Copy words from split_point down to word -- we use memmove because\n<line43>the source and target may overlap.  */\n<line44>memmove (word, split_point, (word_limit - split_point + 1) * sizeof *word);\n<line45>word_limit -= split_point - word;\n<line46>}
----------------------------------------
Function: fmt_paragraph
Content: <line0>static void\n<line1>fmt_paragraph (void)\n<line2>{\n<line3>WORD *start, *w;\n<line4>int len;\n<line5>COST wcost, best;\n<line6>int saved_length;\n<line7>word_limit->best_cost = 0;\n<line8>saved_length = word_limit->length;\n<line9>word_limit->length = max_width;	/* sentinel */\n<line10>for (start = word_limit - 1; start >= word; start--)\n<line11>{\n<line12>best = MAXCOST;\n<line13>len = start == word ? first_indent : other_indent;\n<line14>/* At least one word, however long, in the line.  */\n<line15>w = start;\n<line16>len += w->length;\n<line17>do\n<line18>{\n<line19>w++;\n<line20>/* Consider breaking before w.  */\n<line21>wcost = line_cost (w, len) + w->best_cost;\n<line22>if (start == word && last_line_length > 0)\n<line23>wcost += RAGGED_COST (len - last_line_length);\n<line24>if (wcost < best)\n<line25>{\n<line26>best = wcost;\n<line27>start->next_break = w;\n<line28>start->line_length = len;\n<line29>}\n<line30>/* This is a kludge to keep us from computing 'len' as the\n<line31>sum of the sentinel length and some non-zero number.\n<line32>Since the sentinel w->length may be INT_MAX, adding\n<line33>to that would give a negative result.  */\n<line34>if (w == word_limit)\n<line35>break;\n<line36>len += (w - 1)->space + w->length;	/* w > start >= word */\n<line37>}\n<line38>while (len < max_width);\n<line39>start->best_cost = best + base_cost (start);\n<line40>}\n<line41>word_limit->length = saved_length;\n<line42>}
----------------------------------------
Function: base_cost
Content: <line0>static COST\n<line1>base_cost (WORD *this)\n<line2>{\n<line3>COST cost;\n<line4>cost = LINE_COST;\n<line5>if (this > word)\n<line6>{\n<line7>if ((this - 1)->period)\n<line8>{\n<line9>if ((this - 1)->final)\n<line10>cost -= SENTENCE_BONUS;\n<line11>else\n<line12>cost += NOBREAK_COST;\n<line13>}\n<line14>else if ((this - 1)->punct)\n<line15>cost -= PUNCT_BONUS;\n<line16>else if (this > word + 1 && (this - 2)->final)\n<line17>cost += WIDOW_COST ((this - 1)->length);\n<line18>}\n<line19>if (this->paren)\n<line20>cost -= PAREN_BONUS;\n<line21>else if (this->final)\n<line22>cost += ORPHAN_COST (this->length);\n<line23>return cost;\n<line24>}
----------------------------------------
Function: line_cost
Content: <line0>static COST\n<line1>line_cost (WORD *next, int len)\n<line2>{\n<line3>int n;\n<line4>COST cost;\n<line5>if (next == word_limit)\n<line6>return 0;\n<line7>n = goal_width - len;\n<line8>cost = SHORT_COST (n);\n<line9>if (next->next_break != word_limit)\n<line10>{\n<line11>n = len - next->line_length;\n<line12>cost += RAGGED_COST (n);\n<line13>}\n<line14>return cost;\n<line15>}
----------------------------------------
Function: put_paragraph
Content: <line0>static void\n<line1>put_paragraph (WORD *finish)\n<line2>{\n<line3>WORD *w;\n<line4>put_line (word, first_indent);\n<line5>for (w = word->next_break; w != finish; w = w->next_break)\n<line6>put_line (w, other_indent);\n<line7>}
----------------------------------------
Function: put_line
Content: <line0>static void\n<line1>put_line (WORD *w, int indent)\n<line2>{\n<line3>WORD *endline;\n<line4>out_column = 0;\n<line5>put_space (prefix_indent);\n<line6>fputs (prefix, stdout);\n<line7>out_column += prefix_length;\n<line8>put_space (indent - out_column);\n<line9>endline = w->next_break - 1;\n<line10>for (; w != endline; w++)\n<line11>{\n<line12>put_word (w);\n<line13>put_space (w->space);\n<line14>}\n<line15>put_word (w);\n<line16>last_line_length = out_column;\n<line17>putchar ('\n');\n<line18>}
----------------------------------------
Function: put_word
Content: <line0>static void\n<line1>put_word (WORD *w)\n<line2>{\n<line3>char const *s;\n<line4>int n;\n<line5>s = w->text;\n<line6>for (n = w->length; n != 0; n--)\n<line7>putchar (*s++);\n<line8>out_column += w->length;\n<line9>}
----------------------------------------
Function: put_space
Content: <line0>static void\n<line1>put_space (int space)\n<line2>{\n<line3>int space_target, tab_target;\n<line4>space_target = out_column + space;\n<line5>if (tabs)\n<line6>{\n<line7>tab_target = space_target / TABWIDTH * TABWIDTH;\n<line8>if (out_column + 1 < tab_target)\n<line9>while (out_column < tab_target)\n<line10>{\n<line11>putchar ('\t');\n<line12>out_column = (out_column / TABWIDTH + 1) * TABWIDTH;\n<line13>}\n<line14>}\n<line15>while (out_column < space_target)\n<line16>{\n<line17>putchar (' ');\n<line18>out_column++;\n<line19>}\n<line20>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/src/fold.c
========================================
Function: usage
Content: <line0>void\n<line1>usage (int status)\n<line2>{\n<line3>if (status != EXIT_SUCCESS)\n<line4>emit_try_help ();\n<line5>else\n<line6>{\n<line7>printf (_("\\n<line8>Usage: %s [OPTION]... [FILE]...\n\\n<line9>"),\n<line10>program_name);\n<line11>fputs (_("\\n<line12>Wrap input lines in each FILE, writing to standard output.\n\\n<line13>"), stdout);\n<line14>emit_stdin_note ();\n<line15>emit_mandatory_arg_note ();\n<line16>fputs (_("\\n<line17>-b, --bytes         count bytes rather than columns\n\\n<line18>-s, --spaces        break at spaces\n\\n<line19>-w, --width=WIDTH   use WIDTH columns instead of 80\n\\n<line20>"), stdout);\n<line21>fputs (HELP_OPTION_DESCRIPTION, stdout);\n<line22>fputs (VERSION_OPTION_DESCRIPTION, stdout);\n<line23>emit_ancillary_info (PROGRAM_NAME);\n<line24>}\n<line25>exit (status);\n<line26>}
----------------------------------------
Function: adjust_column
Content: <line0>static size_t\n<line1>adjust_column (size_t column, char c)\n<line2>{\n<line3>if (!count_bytes)\n<line4>{\n<line5>if (c == '\b')\n<line6>{\n<line7>if (column > 0)\n<line8>column--;\n<line9>}\n<line10>else if (c == '\r')\n<line11>column = 0;\n<line12>else if (c == '\t')\n<line13>column += TAB_WIDTH - column % TAB_WIDTH;\n<line14>else /* if (isprint (c)) */\n<line15>column++;\n<line16>}\n<line17>else\n<line18>column++;\n<line19>return column;\n<line20>}
----------------------------------------
Function: fold_file
Content: <line0>static bool\n<line1>fold_file (char const *filename, size_t width)\n<line2>{\n<line3>FILE *istream;\n<line4>int c;\n<line5>size_t column = 0;		/* Screen column where next char will go. */\n<line6>size_t offset_out = 0;	/* Index in 'line_out' for next char. */\n<line7>static char *line_out = nullptr;\n<line8>static size_t allocated_out = 0;\n<line9>int saved_errno;\n<line10>if (STREQ (filename, "-"))\n<line11>{\n<line12>istream = stdin;\n<line13>have_read_stdin = true;\n<line14>}\n<line15>else\n<line16>istream = fopen (filename, "r");\n<line17>if (istream == nullptr)\n<line18>{\n<line19>error (0, errno, "%s", quotef (filename));\n<line20>return false;\n<line21>}\n<line22>fadvise (istream, FADVISE_SEQUENTIAL);\n<line23>while ((c = getc (istream)) != EOF)\n<line24>{\n<line25>if (offset_out + 1 >= allocated_out)\n<line26>line_out = X2REALLOC (line_out, &allocated_out);\n<line27>if (c == '\n')\n<line28>{\n<line29>line_out[offset_out++] = c;\n<line30>fwrite (line_out, sizeof (char), offset_out, stdout);\n<line31>column = offset_out = 0;\n<line32>continue;\n<line33>}\n<line34>rescan:\n<line35>column = adjust_column (column, c);\n<line36>if (column > width)\n<line37>{\n<line38>/* This character would make the line too long.\n<line39>Print the line plus a newline, and make this character\n<line40>start the next line. */\n<line41>if (break_spaces)\n<line42>{\n<line43>bool found_blank = false;\n<line44>size_t logical_end = offset_out;\n<line45>/* Look for the last blank. */\n<line46>while (logical_end)\n<line47>{\n<line48>--logical_end;\n<line49>if (isblank (to_uchar (line_out[logical_end])))\n<line50>{\n<line51>found_blank = true;\n<line52>break;\n<line53>}\n<line54>}\n<line55>if (found_blank)\n<line56>{\n<line57>size_t i;\n<line58>/* Found a blank.  Don't output the part after it. */\n<line59>logical_end++;\n<line60>fwrite (line_out, sizeof (char), (size_t) logical_end,\n<line61>stdout);\n<line62>putchar ('\n');\n<line63>/* Move the remainder to the beginning of the next line.\n<line64>The areas being copied here might overlap. */\n<line65>memmove (line_out, line_out + logical_end,\n<line66>offset_out - logical_end);\n<line67>offset_out -= logical_end;\n<line68>for (column = i = 0; i < offset_out; i++)\n<line69>column = adjust_column (column, line_out[i]);\n<line70>goto rescan;\n<line71>}\n<line72>}\n<line73>if (offset_out == 0)\n<line74>{\n<line75>line_out[offset_out++] = c;\n<line76>continue;\n<line77>}\n<line78>line_out[offset_out++] = '\n';\n<line79>fwrite (line_out, sizeof (char), (size_t) offset_out, stdout);\n<line80>column = offset_out = 0;\n<line81>goto rescan;\n<line82>}\n<line83>line_out[offset_out++] = c;\n<line84>}\n<line85>saved_errno = errno;\n<line86>if (!ferror (istream))\n<line87>saved_errno = 0;\n<line88>if (offset_out)\n<line89>fwrite (line_out, sizeof (char), (size_t) offset_out, stdout);\n<line90>if (STREQ (filename, "-"))\n<line91>clearerr (istream);\n<line92>else if (fclose (istream) != 0 && !saved_errno)\n<line93>saved_errno = errno;\n<line94>if (saved_errno)\n<line95>{\n<line96>error (0, saved_errno, "%s", quotef (filename));\n<line97>return false;\n<line98>}\n<line99>return true;\n<line100>}
----------------------------------------
Function: main
Content: <line0>int\n<line1>main (int argc, char **argv)\n<line2>{\n<line3>size_t width = 80;\n<line4>int i;\n<line5>int optc;\n<line6>bool ok;\n<line7>initialize_main (&argc, &argv);\n<line8>set_program_name (argv[0]);\n<line9>setlocale (LC_ALL, "");\n<line10>bindtextdomain (PACKAGE, LOCALEDIR);\n<line11>textdomain (PACKAGE);\n<line12>atexit (close_stdout);\n<line13>break_spaces = count_bytes = have_read_stdin = false;\n<line14>while ((optc = getopt_long (argc, argv, shortopts, longopts, nullptr)) != -1)\n<line15>{\n<line16>char optargbuf[2];\n<line17>switch (optc)\n<line18>{\n<line19>case 'b':		/* Count bytes rather than columns. */\n<line20>count_bytes = true;\n<line21>break;\n<line22>case 's':		/* Break at word boundaries. */\n<line23>break_spaces = true;\n<line24>break;\n<line25>case '0': case '1': case '2': case '3': case '4':\n<line26>case '5': case '6': case '7': case '8': case '9':\n<line27>if (optarg)\n<line28>optarg--;\n<line29>else\n<line30>{\n<line31>optargbuf[0] = optc;\n<line32>optargbuf[1] = '\0';\n<line33>optarg = optargbuf;\n<line34>}\n<line35>FALLTHROUGH;\n<line36>case 'w':		/* Line width. */\n<line37>width = xdectoumax (optarg, 1, SIZE_MAX - TAB_WIDTH - 1, "",\n<line38>_("invalid number of columns"), 0);\n<line39>break;\n<line40>case_GETOPT_HELP_CHAR;\n<line41>case_GETOPT_VERSION_CHAR (PROGRAM_NAME, AUTHORS);\n<line42>default:\n<line43>usage (EXIT_FAILURE);\n<line44>}\n<line45>}\n<line46>if (argc == optind)\n<line47>ok = fold_file ("-", width);\n<line48>else\n<line49>{\n<line50>ok = true;\n<line51>for (i = optind; i < argc; i++)\n<line52>ok &= fold_file (argv[i], width);\n<line53>}\n<line54>if (have_read_stdin && fclose (stdin) == EOF)\n<line55>error (EXIT_FAILURE, errno, "-");\n<line56>return ok ? EXIT_SUCCESS : EXIT_FAILURE;\n<line57>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/src/install.c
========================================
Function: have_same_content
Content: <line0>static bool\n<line1>have_same_content (int a_fd, int b_fd)\n<line2>{\n<line3>enum { CMP_BLOCK_SIZE = 4096 };\n<line4>static char a_buff[CMP_BLOCK_SIZE];\n<line5>static char b_buff[CMP_BLOCK_SIZE];\n<line6>size_t size;\n<line7>while (0 < (size = full_read (a_fd, a_buff, sizeof a_buff))) {\n<line8>if (size != full_read (b_fd, b_buff, sizeof b_buff))\n<line9>return false;\n<line10>if (memcmp (a_buff, b_buff, size) != 0)\n<line11>return false;\n<line12>}\n<line13>return size == 0;\n<line14>}
----------------------------------------
Function: extra_mode
Content: <line0>static bool\n<line1>extra_mode (mode_t input)\n<line2>{\n<line3>mode_t mask = S_IRWXUGO | S_IFMT;\n<line4>return !! (input & ~ mask);\n<line5>}
----------------------------------------
Function: need_copy
Content: <line0>static bool\n<line1>need_copy (char const *src_name, char const *dest_name,\n<line2>int dest_dirfd, char const *dest_relname,\n<line3>const struct cp_options *x)\n<line4>{\n<line5>struct stat src_sb, dest_sb;\n<line6>int src_fd, dest_fd;\n<line7>bool content_match;\n<line8>if (extra_mode (mode))\n<line9>return true;\n<line10>/* compare files using stat */\n<line11>if (lstat (src_name, &src_sb) != 0)\n<line12>return true;\n<line13>if (fstatat (dest_dirfd, dest_relname, &dest_sb, AT_SYMLINK_NOFOLLOW) != 0)\n<line14>return true;\n<line15>if (!S_ISREG (src_sb.st_mode) || !S_ISREG (dest_sb.st_mode)\n<line16>|| extra_mode (src_sb.st_mode) || extra_mode (dest_sb.st_mode))\n<line17>return true;\n<line18>if (src_sb.st_size != dest_sb.st_size\n<line19>|| (dest_sb.st_mode & CHMOD_MODE_BITS) != mode)\n<line20>return true;\n<line21>if (owner_id == (uid_t) -1)\n<line22>{\n<line23>errno = 0;\n<line24>uid_t ruid = getuid ();\n<line25>if ((ruid == (uid_t) -1 && errno) || dest_sb.st_uid != ruid)\n<line26>return true;\n<line27>}\n<line28>else if (dest_sb.st_uid != owner_id)\n<line29>return true;\n<line30>if (group_id == (uid_t) -1)\n<line31>{\n<line32>errno = 0;\n<line33>gid_t rgid = getgid ();\n<line34>if ((rgid == (uid_t) -1 && errno) || dest_sb.st_gid != rgid)\n<line35>return true;\n<line36>}\n<line37>else if (dest_sb.st_gid != group_id)\n<line38>return true;\n<line39>/* compare SELinux context if preserving */\n<line40>if (selinux_enabled && x->preserve_security_context)\n<line41>{\n<line42>char *file_scontext = nullptr;\n<line43>char *to_scontext = nullptr;\n<line44>bool scontext_match;\n<line45>if (getfilecon (src_name, &file_scontext) == -1)\n<line46>return true;\n<line47>if (getfilecon (dest_name, &to_scontext) == -1)\n<line48>{\n<line49>freecon (file_scontext);\n<line50>return true;\n<line51>}\n<line52>scontext_match = STREQ (file_scontext, to_scontext);\n<line53>freecon (file_scontext);\n<line54>freecon (to_scontext);\n<line55>if (!scontext_match)\n<line56>return true;\n<line57>}\n<line58>/* compare files content */\n<line59>src_fd = open (src_name, O_RDONLY | O_BINARY);\n<line60>if (src_fd < 0)\n<line61>return true;\n<line62>dest_fd = openat (dest_dirfd, dest_relname, O_RDONLY | O_BINARY);\n<line63>if (dest_fd < 0)\n<line64>{\n<line65>close (src_fd);\n<line66>return true;\n<line67>}\n<line68>content_match = have_same_content (src_fd, dest_fd);\n<line69>close (src_fd);\n<line70>close (dest_fd);\n<line71>return !content_match;\n<line72>}
----------------------------------------
Function: cp_option_init
Content: <line0>static void\n<line1>cp_option_init (struct cp_options *x)\n<line2>{\n<line3>cp_options_default (x);\n<line4>x->copy_as_regular = true;\n<line5>x->reflink_mode = REFLINK_AUTO;\n<line6>x->dereference = DEREF_ALWAYS;\n<line7>x->unlink_dest_before_opening = true;\n<line8>x->unlink_dest_after_failed_open = false;\n<line9>x->hard_link = false;\n<line10>x->interactive = I_UNSPECIFIED;\n<line11>x->move_mode = false;\n<line12>x->install_mode = true;\n<line13>x->one_file_system = false;\n<line14>x->preserve_ownership = false;\n<line15>x->preserve_links = false;\n<line16>x->preserve_mode = false;\n<line17>x->preserve_timestamps = false;\n<line18>x->explicit_no_preserve_mode = false;\n<line19>x->reduce_diagnostics=false;\n<line20>x->data_copy_required = true;\n<line21>x->require_preserve = false;\n<line22>x->require_preserve_xattr = false;\n<line23>x->recursive = false;\n<line24>x->sparse_mode = SPARSE_AUTO;\n<line25>x->symbolic_link = false;\n<line26>x->backup_type = no_backups;\n<line27>/* Create destination files initially writable so we can run strip on them.\n<line28>Although GNU strip works fine on read-only files, some others\n<line29>would fail.  */\n<line30>x->set_mode = true;\n<line31>x->mode = S_IRUSR | S_IWUSR;\n<line32>x->stdin_tty = false;\n<line33>x->open_dangling_dest_symlink = false;\n<line34>x->update = false;\n<line35>x->require_preserve_context = false;  /* Not used by install currently.  */\n<line36>x->preserve_security_context = false; /* Whether to copy context from src.  */\n<line37>x->set_security_context = nullptr; /* Whether to set sys default context.  */\n<line38>x->preserve_xattr = false;\n<line39>x->verbose = false;\n<line40>x->dest_info = nullptr;\n<line41>x->src_info = nullptr;\n<line42>}
----------------------------------------
Function: get_labeling_handle
Content: <line0>static struct selabel_handle *\n<line1>get_labeling_handle (void)\n<line2>{\n<line3>static bool initialized;\n<line4>static struct selabel_handle *hnd;\n<line5>if (!initialized)\n<line6>{\n<line7>initialized = true;\n<line8>hnd = selabel_open (SELABEL_CTX_FILE, nullptr, 0);\n<line9>if (!hnd)\n<line10>error (0, errno, _("warning: security labeling handle failed"));\n<line11>}\n<line12>return hnd;\n<line13>}
----------------------------------------
Function: setdefaultfilecon
Content: <line0>static void\n<line1>setdefaultfilecon (char const *file)\n<line2>{\n<line3>struct stat st;\n<line4>char *scontext = nullptr;\n<line5>if (selinux_enabled != 1)\n<line6>{\n<line7>/* Indicate no context found. */\n<line8>return;\n<line9>}\n<line10>if (lstat (file, &st) != 0)\n<line11>return;\n<line12>struct selabel_handle *hnd = get_labeling_handle ();\n<line13>if (!hnd)\n<line14>return;\n<line15>if (selabel_lookup (hnd, &scontext, file, st.st_mode) != 0)\n<line16>{\n<line17>if (errno != ENOENT && ! ignorable_ctx_err (errno))\n<line18>error (0, errno, _("warning: %s: context lookup failed"),\n<line19>quotef (file));\n<line20>return;\n<line21>}\n<line22>if (lsetfilecon (file, scontext) < 0 && errno != ENOTSUP)\n<line23>error (0, errno,\n<line24>_("warning: %s: failed to change context to %s"),\n<line25>quotef_n (0, file), quote_n (1, scontext));\n<line26>freecon (scontext);\n<line27>}
----------------------------------------
Function: announce_mkdir
Content: <line0>static void\n<line1>announce_mkdir (char const *dir, void *options)\n<line2>{\n<line3>struct cp_options const *x = options;\n<line4>if (x->verbose)\n<line5>prog_fprintf (stdout, _("creating directory %s"), quoteaf (dir));\n<line6>}
----------------------------------------
Function: make_ancestor
Content: <line0>static int\n<line1>make_ancestor (char const *dir, char const *component, void *options)\n<line2>{\n<line3>struct cp_options const *x = options;\n<line4>if (x->set_security_context\n<line5>&& defaultcon (x->set_security_context, component, S_IFDIR) < 0\n<line6>&& ! ignorable_ctx_err (errno))\n<line7>error (0, errno, _("failed to set default creation context for %s"),\n<line8>quoteaf (dir));\n<line9>int r = mkdir (component, DEFAULT_MODE);\n<line10>if (r == 0)\n<line11>announce_mkdir (dir, options);\n<line12>return r;\n<line13>}
----------------------------------------
Function: process_dir
Content: <line0>static int\n<line1>process_dir (char *dir, struct savewd *wd, void *options)\n<line2>{\n<line3>struct cp_options const *x = options;\n<line4>int ret = (make_dir_parents (dir, wd, make_ancestor, options,\n<line5>dir_mode, announce_mkdir,\n<line6>dir_mode_bits, owner_id, group_id, false)\n<line7>? EXIT_SUCCESS\n<line8>: EXIT_FAILURE);\n<line9>/* FIXME: Due to the current structure of make_dir_parents()\n<line10>we don't have the facility to call defaultcon() before the\n<line11>final component of DIR is created.  So for now, create the\n<line12>final component with the context from previous component\n<line13>and here we set the context for the final component. */\n<line14>if (ret == EXIT_SUCCESS && x->set_security_context)\n<line15>{\n<line16>if (! restorecon (x->set_security_context, last_component (dir), false)\n<line17>&& ! ignorable_ctx_err (errno))\n<line18>error (0, errno, _("failed to restore context for %s"),\n<line19>quoteaf (dir));\n<line20>}\n<line21>return ret;\n<line22>}
----------------------------------------
Function: copy_file
Content: <line0>static bool\n<line1>copy_file (char const *from, char const *to,\n<line2>int to_dirfd, char const *to_relname, const struct cp_options *x)\n<line3>{\n<line4>bool copy_into_self;\n<line5>if (copy_only_if_needed && !need_copy (from, to, to_dirfd, to_relname, x))\n<line6>return true;\n<line7>/* Allow installing from non-regular files like /dev/null.\n<line8>Charles Karney reported that some Sun version of install allows that\n<line9>and that sendmail's installation process relies on the behavior.\n<line10>However, since !x->recursive, the call to "copy" will fail if FROM\n<line11>is a directory.  */\n<line12>return copy (from, to, to_dirfd, to_relname, 0, x, &copy_into_self, nullptr);\n<line13>}
----------------------------------------
Function: change_attributes
Content: <line0>static bool\n<line1>change_attributes (char const *name, int dirfd, char const *relname)\n<line2>{\n<line3>bool ok = false;\n<line4>/* chown must precede chmod because on some systems,\n<line5>chown clears the set[ug]id bits for non-superusers,\n<line6>resulting in incorrect permissions.\n<line7>On System V, users can give away files with chown and then not\n<line8>be able to chmod them.  So don't give files away.\n<line9>We don't normally ignore errors from chown because the idea of\n<line10>the install command is that the file is supposed to end up with\n<line11>precisely the attributes that the user specified (or defaulted).\n<line12>If the file doesn't end up with the group they asked for, they'll\n<line13>want to know.  */\n<line14>if (! (owner_id == (uid_t) -1 && group_id == (gid_t) -1)\n<line15>&& lchownat (dirfd, relname, owner_id, group_id) != 0)\n<line16>error (0, errno, _("cannot change ownership of %s"), quoteaf (name));\n<line17>else if (chmodat (dirfd, relname, mode) != 0)\n<line18>error (0, errno, _("cannot change permissions of %s"), quoteaf (name));\n<line19>else\n<line20>ok = true;\n<line21>if (use_default_selinux_context)\n<line22>setdefaultfilecon (name);\n<line23>return ok;\n<line24>}
----------------------------------------
Function: change_timestamps
Content: <line0>static bool\n<line1>change_timestamps (struct stat const *src_sb, char const *dest,\n<line2>int dirfd, char const *relname)\n<line3>{\n<line4>struct timespec timespec[2];\n<line5>timespec[0] = get_stat_atime (src_sb);\n<line6>timespec[1] = get_stat_mtime (src_sb);\n<line7>if (utimensat (dirfd, relname, timespec, 0))\n<line8>{\n<line9>error (0, errno, _("cannot set timestamps for %s"), quoteaf (dest));\n<line10>return false;\n<line11>}\n<line12>return true;\n<line13>}
----------------------------------------
Function: strip
Content: <line0>static bool\n<line1>strip (char const *name)\n<line2>{\n<line3>int status;\n<line4>bool ok = false;\n<line5>pid_t pid = fork ();\n<line6>switch (pid)\n<line7>{\n<line8>case -1:\n<line9>error (0, errno, _("fork system call failed"));\n<line10>break;\n<line11>case 0:			/* Child. */\n<line12>{\n<line13>char const *safe_name = name;\n<line14>if (name && *name == '-')\n<line15>safe_name = file_name_concat (".", name, nullptr);\n<line16>execlp (strip_program, strip_program, safe_name, nullptr);\n<line17>error (EXIT_FAILURE, errno, _("cannot run %s"),\n<line18>quoteaf (strip_program));\n<line19>}\n<line20>default:			/* Parent. */\n<line21>if (waitpid (pid, &status, 0) < 0)\n<line22>error (0, errno, _("waiting for strip"));\n<line23>else if (! WIFEXITED (status) || WEXITSTATUS (status))\n<line24>error (0, 0, _("strip process terminated abnormally"));\n<line25>else\n<line26>ok = true;      /* strip succeeded */\n<line27>break;\n<line28>}\n<line29>return ok;\n<line30>}
----------------------------------------
Function: get_ids
Content: <line0>static void\n<line1>get_ids (void)\n<line2>{\n<line3>struct passwd *pw;\n<line4>struct group *gr;\n<line5>if (owner_name)\n<line6>{\n<line7>pw = getpwnam (owner_name);\n<line8>if (pw == nullptr)\n<line9>{\n<line10>uintmax_t tmp;\n<line11>if (xstrtoumax (owner_name, nullptr, 0, &tmp, "") != LONGINT_OK\n<line12>|| UID_T_MAX < tmp)\n<line13>error (EXIT_FAILURE, 0, _("invalid user %s"),\n<line14>quoteaf (owner_name));\n<line15>owner_id = tmp;\n<line16>}\n<line17>else\n<line18>owner_id = pw->pw_uid;\n<line19>endpwent ();\n<line20>}\n<line21>else\n<line22>owner_id = (uid_t) -1;\n<line23>if (group_name)\n<line24>{\n<line25>gr = getgrnam (group_name);\n<line26>if (gr == nullptr)\n<line27>{\n<line28>uintmax_t tmp;\n<line29>if (xstrtoumax (group_name, nullptr, 0, &tmp, "") != LONGINT_OK\n<line30>|| GID_T_MAX < tmp)\n<line31>error (EXIT_FAILURE, 0, _("invalid group %s"),\n<line32>quoteaf (group_name));\n<line33>group_id = tmp;\n<line34>}\n<line35>else\n<line36>group_id = gr->gr_gid;\n<line37>endgrent ();\n<line38>}\n<line39>else\n<line40>group_id = (gid_t) -1;\n<line41>}
----------------------------------------
Function: usage
Content: <line0>void\n<line1>usage (int status)\n<line2>{\n<line3>if (status != EXIT_SUCCESS)\n<line4>emit_try_help ();\n<line5>else\n<line6>{\n<line7>printf (_("\\n<line8>Usage: %s [OPTION]... [-T] SOURCE DEST\n\\n<line9>or:  %s [OPTION]... SOURCE... DIRECTORY\n\\n<line10>or:  %s [OPTION]... -t DIRECTORY SOURCE...\n\\n<line11>or:  %s [OPTION]... -d DIRECTORY...\n\\n<line12>"),\n<line13>program_name, program_name, program_name, program_name);\n<line14>fputs (_("\\n<line15>\n\\n<line16>This install program copies files (often just compiled) into destination\n\\n<line17>locations you choose.  If you want to download and install a ready-to-use\n\\n<line18>package on a GNU/Linux system, you should instead be using a package manager\n\\n<line19>like yum(1) or apt-get(1).\n\\n<line20>\n\\n<line21>In the first three forms, copy SOURCE to DEST or multiple SOURCE(s) to\n\\n<line22>the existing DIRECTORY, while setting permission modes and owner/group.\n\\n<line23>In the 4th form, create all components of the given DIRECTORY(ies).\n\\n<line24>"), stdout);\n<line25>emit_mandatory_arg_note ();\n<line26>fputs (_("\\n<line27>--backup[=CONTROL]  make a backup of each existing destination file\n\\n<line28>-b                  like --backup but does not accept an argument\n\\n<line29>-c                  (ignored)\n\\n<line30>-C, --compare       compare content of source and destination files, and\n\\n<line31>if no change to content, ownership, and permissions,\n\\n<line32>do not modify the destination at all\n\\n<line33>-d, --directory     treat all arguments as directory names; create all\n\\n<line34>components of the specified directories\n\\n<line35>"), stdout);\n<line36>fputs (_("\\n<line37>-D                  create all leading components of DEST except the last,\n\\n<line38>or all components of --target-directory,\n\\n<line39>then copy SOURCE to DEST\n\\n<line40>"), stdout);\n<line41>fputs (_("\\n<line42>--debug         explain how a file is copied.  Implies -v\n\\n<line43>"), stdout);\n<line44>fputs (_("\\n<line45>-g, --group=GROUP   set group ownership, instead of process' current group\n\\n<line46>-m, --mode=MODE     set permission mode (as in chmod), instead of rwxr-xr-x\n\\n<line47>-o, --owner=OWNER   set ownership (super-user only)\n\\n<line48>"), stdout);\n<line49>fputs (_("\\n<line50>-p, --preserve-timestamps   apply access/modification times of SOURCE files\n\\n<line51>to corresponding destination files\n\\n<line52>-s, --strip         strip symbol tables\n\\n<line53>--strip-program=PROGRAM  program used to strip binaries\n\\n<line54>-S, --suffix=SUFFIX  override the usual backup suffix\n\\n<line55>-t, --target-directory=DIRECTORY  copy all SOURCE arguments into DIRECTORY\n\\n<line56>-T, --no-target-directory  treat DEST as a normal file\n\\n<line57>"), stdout);\n<line58>fputs (_("\\n<line59>-v, --verbose       print the name of each created file or directory\n\\n<line60>"), stdout);\n<line61>fputs (_("\\n<line62>--preserve-context  preserve SELinux security context\n\\n<line63>-Z                      set SELinux security context of destination\n\\n<line64>file and each created directory to default type\n\\n<line65>--context[=CTX]     like -Z, or if CTX is specified then set the\n\\n<line66>SELinux or SMACK security context to CTX\n\\n<line67>"), stdout);\n<line68>fputs (HELP_OPTION_DESCRIPTION, stdout);\n<line69>fputs (VERSION_OPTION_DESCRIPTION, stdout);\n<line70>emit_backup_suffix_note ();\n<line71>emit_ancillary_info (PROGRAM_NAME);\n<line72>}\n<line73>exit (status);\n<line74>}
----------------------------------------
Function: install_file_in_file
Content: <line0>static bool\n<line1>install_file_in_file (char const *from, char const *to,\n<line2>int to_dirfd, char const *to_relname,\n<line3>const struct cp_options *x)\n<line4>{\n<line5>struct stat from_sb;\n<line6>if (x->preserve_timestamps && stat (from, &from_sb) != 0)\n<line7>{\n<line8>error (0, errno, _("cannot stat %s"), quoteaf (from));\n<line9>return false;\n<line10>}\n<line11>if (! copy_file (from, to, to_dirfd, to_relname, x))\n<line12>return false;\n<line13>if (strip_files)\n<line14>if (! strip (to))\n<line15>{\n<line16>if (unlinkat (to_dirfd, to_relname, 0) != 0)  /* Cleanup.  */\n<line17>error (EXIT_FAILURE, errno, _("cannot unlink %s"), quoteaf (to));\n<line18>return false;\n<line19>}\n<line20>if (x->preserve_timestamps && (strip_files || ! S_ISREG (from_sb.st_mode))\n<line21>&& ! change_timestamps (&from_sb, to, to_dirfd, to_relname))\n<line22>return false;\n<line23>return change_attributes (to, to_dirfd, to_relname);\n<line24>}
----------------------------------------
Function: mkancesdirs_safe_wd
Content: <line0>static bool\n<line1>mkancesdirs_safe_wd (char const *from, char *to, struct cp_options *x,\n<line2>bool save_always)\n<line3>{\n<line4>bool save_working_directory =\n<line5>save_always\n<line6>|| ! (IS_ABSOLUTE_FILE_NAME (from) && IS_ABSOLUTE_FILE_NAME (to));\n<line7>int status = EXIT_SUCCESS;\n<line8>struct savewd wd;\n<line9>savewd_init (&wd);\n<line10>if (! save_working_directory)\n<line11>savewd_finish (&wd);\n<line12>if (mkancesdirs (to, &wd, make_ancestor, x) == -1)\n<line13>{\n<line14>error (0, errno, _("cannot create directory %s"), quoteaf (to));\n<line15>status = EXIT_FAILURE;\n<line16>}\n<line17>if (save_working_directory)\n<line18>{\n<line19>int restore_result = savewd_restore (&wd, status);\n<line20>int restore_errno = errno;\n<line21>savewd_finish (&wd);\n<line22>if (EXIT_SUCCESS < restore_result)\n<line23>return false;\n<line24>if (restore_result < 0 && status == EXIT_SUCCESS)\n<line25>{\n<line26>error (0, restore_errno, _("cannot create directory %s"),\n<line27>quoteaf (to));\n<line28>return false;\n<line29>}\n<line30>}\n<line31>return status == EXIT_SUCCESS;\n<line32>}
----------------------------------------
Function: install_file_in_file_parents
Content: <line0>static bool\n<line1>install_file_in_file_parents (char const *from, char *to,\n<line2>const struct cp_options *x)\n<line3>{\n<line4>return (mkancesdirs_safe_wd (from, to, (struct cp_options *)x, false)\n<line5>&& install_file_in_file (from, to, AT_FDCWD, to, x));\n<line6>}
----------------------------------------
Function: install_file_in_dir
Content: <line0>static bool\n<line1>install_file_in_dir (char const *from, char const *to_dir,\n<line2>const struct cp_options *x, bool mkdir_and_install,\n<line3>int *target_dirfd)\n<line4>{\n<line5>char const *from_base = last_component (from);\n<line6>char *to_relname;\n<line7>char *to = file_name_concat (to_dir, from_base, &to_relname);\n<line8>bool ret = true;\n<line9>if (!target_dirfd_valid (*target_dirfd)\n<line10>&& (ret = mkdir_and_install)\n<line11>&& (ret = mkancesdirs_safe_wd (from, to, (struct cp_options *) x, true)))\n<line12>{\n<line13>int fd = open (to_dir, O_PATHSEARCH | O_DIRECTORY);\n<line14>if (fd < 0)\n<line15>{\n<line16>error (0, errno, _("cannot open %s"), quoteaf (to));\n<line17>ret = false;\n<line18>}\n<line19>else\n<line20>*target_dirfd = fd;\n<line21>}\n<line22>if (ret)\n<line23>{\n<line24>int to_dirfd = *target_dirfd;\n<line25>if (!target_dirfd_valid (to_dirfd))\n<line26>{\n<line27>to_dirfd = AT_FDCWD;\n<line28>to_relname = to;\n<line29>}\n<line30>ret = install_file_in_file (from, to, to_dirfd, to_relname, x);\n<line31>}\n<line32>free (to);\n<line33>return ret;\n<line34>}
----------------------------------------
Function: main
Content: <line0>int\n<line1>main (int argc, char **argv)\n<line2>{\n<line3>int optc;\n<line4>int exit_status = EXIT_SUCCESS;\n<line5>char const *specified_mode = nullptr;\n<line6>bool make_backups = false;\n<line7>char const *backup_suffix = nullptr;\n<line8>char *version_control_string = nullptr;\n<line9>bool mkdir_and_install = false;\n<line10>struct cp_options x;\n<line11>char const *target_directory = nullptr;\n<line12>bool no_target_directory = false;\n<line13>int n_files;\n<line14>char **file;\n<line15>bool strip_program_specified = false;\n<line16>char const *scontext = nullptr;\n<line17>/* set iff kernel has extra selinux system calls */\n<line18>selinux_enabled = (0 < is_selinux_enabled ());\n<line19>initialize_main (&argc, &argv);\n<line20>set_program_name (argv[0]);\n<line21>setlocale (LC_ALL, "");\n<line22>bindtextdomain (PACKAGE, LOCALEDIR);\n<line23>textdomain (PACKAGE);\n<line24>atexit (close_stdin);\n<line25>cp_option_init (&x);\n<line26>owner_name = nullptr;\n<line27>group_name = nullptr;\n<line28>strip_files = false;\n<line29>dir_arg = false;\n<line30>umask (0);\n<line31>while ((optc = getopt_long (argc, argv, "bcCsDdg:m:o:pt:TvS:Z", long_options,\n<line32>nullptr))\n<line33>!= -1)\n<line34>{\n<line35>switch (optc)\n<line36>{\n<line37>case 'b':\n<line38>make_backups = true;\n<line39>if (optarg)\n<line40>version_control_string = optarg;\n<line41>break;\n<line42>case 'c':\n<line43>break;\n<line44>case 'C':\n<line45>copy_only_if_needed = true;\n<line46>break;\n<line47>case 's':\n<line48>strip_files = true;\n<line49>#ifdef SIGCHLD\n<line50>/* System V fork+wait does not work if SIGCHLD is ignored.  */\n<line51>signal (SIGCHLD, SIG_DFL);\n<line52>#endif\n<line53>break;\n<line54>case DEBUG_OPTION:\n<line55>x.debug = x.verbose = true;\n<line56>break;\n<line57>case STRIP_PROGRAM_OPTION:\n<line58>strip_program = xstrdup (optarg);\n<line59>strip_program_specified = true;\n<line60>break;\n<line61>case 'd':\n<line62>dir_arg = true;\n<line63>break;\n<line64>case 'D':\n<line65>mkdir_and_install = true;\n<line66>break;\n<line67>case 'v':\n<line68>x.verbose = true;\n<line69>break;\n<line70>case 'g':\n<line71>group_name = optarg;\n<line72>break;\n<line73>case 'm':\n<line74>specified_mode = optarg;\n<line75>break;\n<line76>case 'o':\n<line77>owner_name = optarg;\n<line78>break;\n<line79>case 'p':\n<line80>x.preserve_timestamps = true;\n<line81>break;\n<line82>case 'S':\n<line83>make_backups = true;\n<line84>backup_suffix = optarg;\n<line85>break;\n<line86>case 't':\n<line87>if (target_directory)\n<line88>error (EXIT_FAILURE, 0,\n<line89>_("multiple target directories specified"));\n<line90>target_directory = optarg;\n<line91>break;\n<line92>case 'T':\n<line93>no_target_directory = true;\n<line94>break;\n<line95>case PRESERVE_CONTEXT_OPTION:\n<line96>if (! selinux_enabled)\n<line97>{\n<line98>error (0, 0, _("WARNING: ignoring --preserve-context; "\n<line99>"this kernel is not SELinux-enabled"));\n<line100>break;\n<line101>}\n<line102>x.preserve_security_context = true;\n<line103>use_default_selinux_context = false;\n<line104>break;\n<line105>case 'Z':\n<line106>if (selinux_enabled)\n<line107>{\n<line108>/* Disable use of the install(1) specific setdefaultfilecon().\n<line109>Note setdefaultfilecon() is different from the newer and more\n<line110>generic restorecon() in that the former sets the context of\n<line111>the dest files to that returned by selabel_lookup directly,\n<line112>thus discarding MLS level and user identity of the file.\n<line113>TODO: consider removing setdefaultfilecon() in future.  */\n<line114>use_default_selinux_context = false;\n<line115>if (optarg)\n<line116>scontext = optarg;\n<line117>else\n<line118>x.set_security_context = get_labeling_handle ();\n<line119>}\n<line120>else if (optarg)\n<line121>{\n<line122>error (0, 0,\n<line123>_("warning: ignoring --context; "\n<line124>"it requires an SELinux-enabled kernel"));\n<line125>}\n<line126>break;\n<line127>case_GETOPT_HELP_CHAR;\n<line128>case_GETOPT_VERSION_CHAR (PROGRAM_NAME, AUTHORS);\n<line129>default:\n<line130>usage (EXIT_FAILURE);\n<line131>}\n<line132>}\n<line133>/* Check for invalid combinations of arguments. */\n<line134>if (dir_arg && strip_files)\n<line135>error (EXIT_FAILURE, 0,\n<line136>_("the strip option may not be used when installing a directory"));\n<line137>if (dir_arg && target_directory)\n<line138>error (EXIT_FAILURE, 0,\n<line139>_("target directory not allowed when installing a directory"));\n<line140>x.backup_type = (make_backups\n<line141>? xget_version (_("backup type"),\n<line142>version_control_string)\n<line143>: no_backups);\n<line144>set_simple_backup_suffix (backup_suffix);\n<line145>if (x.preserve_security_context && (x.set_security_context || scontext))\n<line146>error (EXIT_FAILURE, 0,\n<line147>_("cannot set target context and preserve it"));\n<line148>if (scontext && setfscreatecon (scontext) < 0)\n<line149>error (EXIT_FAILURE, errno,\n<line150>_("failed to set default file creation context to %s"),\n<line151>quote (scontext));\n<line152>n_files = argc - optind;\n<line153>file = argv + optind;\n<line154>if (n_files <= ! (dir_arg || target_directory))\n<line155>{\n<line156>if (n_files <= 0)\n<line157>error (0, 0, _("missing file operand"));\n<line158>else\n<line159>error (0, 0, _("missing destination file operand after %s"),\n<line160>quoteaf (file[0]));\n<line161>usage (EXIT_FAILURE);\n<line162>}\n<line163>struct stat sb;\n<line164>int target_dirfd = AT_FDCWD;\n<line165>if (no_target_directory)\n<line166>{\n<line167>if (target_directory)\n<line168>error (EXIT_FAILURE, 0,\n<line169>_("cannot combine --target-directory (-t) "\n<line170>"and --no-target-directory (-T)"));\n<line171>if (2 < n_files)\n<line172>{\n<line173>error (0, 0, _("extra operand %s"), quoteaf (file[2]));\n<line174>usage (EXIT_FAILURE);\n<line175>}\n<line176>}\n<line177>else if (target_directory)\n<line178>{\n<line179>target_dirfd = target_directory_operand (target_directory, &sb);\n<line180>if (! (target_dirfd_valid (target_dirfd)\n<line181>|| (mkdir_and_install && errno == ENOENT)))\n<line182>error (EXIT_FAILURE, errno, _("failed to access %s"),\n<line183>quoteaf (target_directory));\n<line184>}\n<line185>else if (!dir_arg)\n<line186>{\n<line187>char const *lastfile = file[n_files - 1];\n<line188>int fd = target_directory_operand (lastfile, &sb);\n<line189>if (target_dirfd_valid (fd))\n<line190>{\n<line191>target_dirfd = fd;\n<line192>target_directory = lastfile;\n<line193>n_files--;\n<line194>}\n<line195>else if (2 < n_files)\n<line196>error (EXIT_FAILURE, errno, _("target %s"), quoteaf (lastfile));\n<line197>}\n<line198>if (specified_mode)\n<line199>{\n<line200>struct mode_change *change = mode_compile (specified_mode);\n<line201>if (!change)\n<line202>error (EXIT_FAILURE, 0, _("invalid mode %s"), quote (specified_mode));\n<line203>mode = mode_adjust (0, false, 0, change, nullptr);\n<line204>dir_mode = mode_adjust (0, true, 0, change, &dir_mode_bits);\n<line205>free (change);\n<line206>}\n<line207>if (strip_program_specified && !strip_files)\n<line208>error (0, 0, _("WARNING: ignoring --strip-program option as -s option was "\n<line209>"not specified"));\n<line210>if (copy_only_if_needed && x.preserve_timestamps)\n<line211>{\n<line212>error (0, 0, _("options --compare (-C) and --preserve-timestamps are "\n<line213>"mutually exclusive"));\n<line214>usage (EXIT_FAILURE);\n<line215>}\n<line216>if (copy_only_if_needed && strip_files)\n<line217>{\n<line218>error (0, 0, _("options --compare (-C) and --strip are mutually "\n<line219>"exclusive"));\n<line220>usage (EXIT_FAILURE);\n<line221>}\n<line222>if (copy_only_if_needed && extra_mode (mode))\n<line223>error (0, 0, _("the --compare (-C) option is ignored when you"\n<line224>" specify a mode with non-permission bits"));\n<line225>get_ids ();\n<line226>if (dir_arg)\n<line227>exit_status = savewd_process_files (n_files, file, process_dir, &x);\n<line228>else\n<line229>{\n<line230>/* FIXME: it's a little gross that this initialization is\n<line231>required by copy.c::copy. */\n<line232>hash_init ();\n<line233>if (!target_directory)\n<line234>{\n<line235>if (! (mkdir_and_install\n<line236>? install_file_in_file_parents (file[0], file[1], &x)\n<line237>: install_file_in_file (file[0], file[1], AT_FDCWD,\n<line238>file[1], &x)))\n<line239>exit_status = EXIT_FAILURE;\n<line240>}\n<line241>else\n<line242>{\n<line243>int i;\n<line244>dest_info_init (&x);\n<line245>for (i = 0; i < n_files; i++)\n<line246>if (! install_file_in_dir (file[i], target_directory, &x,\n<line247>i == 0 && mkdir_and_install,\n<line248>&target_dirfd))\n<line249>exit_status = EXIT_FAILURE;\n<line250>}\n<line251>}\n<line252>main_exit (exit_status);\n<line253>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/src/prog-fprintf.c
========================================
Function: prog_fprintf
Content: <line0>void\n<line1>prog_fprintf (FILE *fp, char const *fmt, ...)\n<line2>{\n<line3>va_list ap;\n<line4>fputs (program_name, fp);\n<line5>fputs (": ", fp);\n<line6>va_start (ap, fmt);\n<line7>vfprintf (fp, fmt, ap);\n<line8>va_end (ap);\n<line9>fputc ('\n', fp);\n<line10>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/src/groups.c
========================================
Function: usage
Content: <line0>void\n<line1>usage (int status)\n<line2>{\n<line3>if (status != EXIT_SUCCESS)\n<line4>emit_try_help ();\n<line5>else\n<line6>{\n<line7>printf (_("Usage: %s [OPTION]... [USERNAME]...\n"), program_name);\n<line8>fputs (_("\\n<line9>Print group memberships for each USERNAME or, if no USERNAME is specified, for\\n<line10>\n\\n<line11>the current process (which may differ if the groups database has changed).\n"),\n<line12>stdout);\n<line13>fputs (HELP_OPTION_DESCRIPTION, stdout);\n<line14>fputs (VERSION_OPTION_DESCRIPTION, stdout);\n<line15>emit_ancillary_info (PROGRAM_NAME);\n<line16>}\n<line17>exit (status);\n<line18>}
----------------------------------------
Function: main
Content: <line0>int\n<line1>main (int argc, char **argv)\n<line2>{\n<line3>int optc;\n<line4>bool ok = true;\n<line5>gid_t rgid, egid;\n<line6>uid_t ruid;\n<line7>initialize_main (&argc, &argv);\n<line8>set_program_name (argv[0]);\n<line9>setlocale (LC_ALL, "");\n<line10>bindtextdomain (PACKAGE, LOCALEDIR);\n<line11>textdomain (PACKAGE);\n<line12>atexit (close_stdout);\n<line13>/* Processing the arguments this way makes groups.c behave differently to\n<line14>* groups.sh if one of the arguments is "--".\n<line15>*/\n<line16>while ((optc = getopt_long (argc, argv, "", longopts, nullptr)) != -1)\n<line17>{\n<line18>switch (optc)\n<line19>{\n<line20>case_GETOPT_HELP_CHAR;\n<line21>case_GETOPT_VERSION_CHAR (PROGRAM_NAME, AUTHORS);\n<line22>default:\n<line23>usage (EXIT_FAILURE);\n<line24>}\n<line25>}\n<line26>if (optind == argc)\n<line27>{\n<line28>/* No arguments.  Divulge the details of the current process. */\n<line29>uid_t NO_UID = -1;\n<line30>gid_t NO_GID = -1;\n<line31>errno = 0;\n<line32>ruid = getuid ();\n<line33>if (ruid == NO_UID && errno)\n<line34>error (EXIT_FAILURE, errno, _("cannot get real UID"));\n<line35>errno = 0;\n<line36>egid = getegid ();\n<line37>if (egid == NO_GID && errno)\n<line38>error (EXIT_FAILURE, errno, _("cannot get effective GID"));\n<line39>errno = 0;\n<line40>rgid = getgid ();\n<line41>if (rgid == NO_GID && errno)\n<line42>error (EXIT_FAILURE, errno, _("cannot get real GID"));\n<line43>if (!print_group_list (nullptr, ruid, rgid, egid, true, ' '))\n<line44>ok = false;\n<line45>putchar ('\n');\n<line46>}\n<line47>else\n<line48>{\n<line49>/* At least one argument.  Divulge the details of the specified users.  */\n<line50>for ( ; optind < argc; optind++)\n<line51>{\n<line52>struct passwd *pwd = getpwnam (argv[optind]);\n<line53>if (pwd == nullptr)\n<line54>{\n<line55>error (0, 0, _("%s: no such user"), quote (argv[optind]));\n<line56>ok = false;\n<line57>continue;\n<line58>}\n<line59>ruid = pwd->pw_uid;\n<line60>rgid = egid = pwd->pw_gid;\n<line61>printf ("%s : ", argv[optind]);\n<line62>if (!print_group_list (argv[optind], ruid, rgid, egid, true, ' '))\n<line63>ok = false;\n<line64>putchar ('\n');\n<line65>}\n<line66>}\n<line67>return ok ? EXIT_SUCCESS : EXIT_FAILURE;\n<line68>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/src/group-list.c
========================================
Function: print_group_list
Content: <line0>extern bool\n<line1>print_group_list (char const *username,\n<line2>uid_t ruid, gid_t rgid, gid_t egid,\n<line3>bool use_names, char delim)\n<line4>{\n<line5>bool ok = true;\n<line6>struct passwd *pwd = nullptr;\n<line7>if (username)\n<line8>{\n<line9>pwd = getpwuid (ruid);\n<line10>if (pwd == nullptr)\n<line11>ok = false;\n<line12>}\n<line13>if (!print_group (rgid, use_names))\n<line14>ok = false;\n<line15>if (egid != rgid)\n<line16>{\n<line17>putchar (delim);\n<line18>if (!print_group (egid, use_names))\n<line19>ok = false;\n<line20>}\n<line21>{\n<line22>gid_t *groups;\n<line23>int n_groups = xgetgroups (username, (pwd ? pwd->pw_gid : egid), &groups);\n<line24>if (n_groups < 0)\n<line25>{\n<line26>if (username)\n<line27>{\n<line28>error (0, errno, _("failed to get groups for user %s"),\n<line29>quote (username));\n<line30>}\n<line31>else\n<line32>{\n<line33>error (0, errno, _("failed to get groups for the current process"));\n<line34>}\n<line35>return false;\n<line36>}\n<line37>for (int i = 0; i < n_groups; i++)\n<line38>if (groups[i] != rgid && groups[i] != egid)\n<line39>{\n<line40>putchar (delim);\n<line41>if (!print_group (groups[i], use_names))\n<line42>ok = false;\n<line43>}\n<line44>free (groups);\n<line45>}\n<line46>return ok;\n<line47>}
----------------------------------------
Function: gidtostr_ptr
Content: <line0>static char *\n<line1>gidtostr_ptr (gid_t const *gid)\n<line2>{\n<line3>static char buf[INT_BUFSIZE_BOUND (uintmax_t)];\n<line4>return umaxtostr (*gid, buf);\n<line5>}
----------------------------------------
Function: print_group
Content: <line0>extern bool\n<line1>print_group (gid_t gid, bool use_name)\n<line2>{\n<line3>struct group *grp = nullptr;\n<line4>bool ok = true;\n<line5>if (use_name)\n<line6>{\n<line7>grp = getgrgid (gid);\n<line8>if (grp == nullptr)\n<line9>{\n<line10>if (TYPE_SIGNED (gid_t))\n<line11>{\n<line12>intmax_t g = gid;\n<line13>error (0, 0, _("cannot find name for group ID %"PRIdMAX), g);\n<line14>}\n<line15>else\n<line16>{\n<line17>uintmax_t g = gid;\n<line18>error (0, 0, _("cannot find name for group ID %"PRIuMAX), g);\n<line19>}\n<line20>ok = false;\n<line21>}\n<line22>}\n<line23>char *s = grp ? grp->gr_name : gidtostr (gid);\n<line24>fputs (s, stdout);\n<line25>return ok;\n<line26>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/src/head.c
========================================
Function: usage
Content: <line0>void\n<line1>usage (int status)\n<line2>{\n<line3>if (status != EXIT_SUCCESS)\n<line4>emit_try_help ();\n<line5>else\n<line6>{\n<line7>printf (_("\\n<line8>Usage: %s [OPTION]... [FILE]...\n\\n<line9>"),\n<line10>program_name);\n<line11>printf (_("\\n<line12>Print the first %d lines of each FILE to standard output.\n\\n<line13>With more than one FILE, precede each with a header giving the file name.\n\\n<line14>"), DEFAULT_NUMBER);\n<line15>emit_stdin_note ();\n<line16>emit_mandatory_arg_note ();\n<line17>printf (_("\\n<line18>-c, --bytes=[-]NUM       print the first NUM bytes of each file;\n\\n<line19>with the leading '-', print all but the last\n\\n<line20>NUM bytes of each file\n\\n<line21>-n, --lines=[-]NUM       print the first NUM lines instead of the first %d;\n\\n<line22>with the leading '-', print all but the last\n\\n<line23>NUM lines of each file\n\\n<line24>"), DEFAULT_NUMBER);\n<line25>fputs (_("\\n<line26>-q, --quiet, --silent    never print headers giving file names\n\\n<line27>-v, --verbose            always print headers giving file names\n\\n<line28>"), stdout);\n<line29>fputs (_("\\n<line30>-z, --zero-terminated    line delimiter is NUL, not newline\n\\n<line31>"), stdout);\n<line32>fputs (HELP_OPTION_DESCRIPTION, stdout);\n<line33>fputs (VERSION_OPTION_DESCRIPTION, stdout);\n<line34>fputs (_("\\n<line35>\n\\n<line36>NUM may have a multiplier suffix:\n\\n<line37>b 512, kB 1000, K 1024, MB 1000*1000, M 1024*1024,\n\\n<line38>GB 1000*1000*1000, G 1024*1024*1024, and so on for T, P, E, Z, Y, R, Q.\n\\n<line39>Binary prefixes can be used, too: KiB=K, MiB=M, and so on.\n\\n<line40>"), stdout);\n<line41>emit_ancillary_info (PROGRAM_NAME);\n<line42>}\n<line43>exit (status);\n<line44>}
----------------------------------------
Function: diagnose_copy_fd_failure
Content: <line0>static void\n<line1>diagnose_copy_fd_failure (enum Copy_fd_status err, char const *filename)\n<line2>{\n<line3>switch (err)\n<line4>{\n<line5>case COPY_FD_READ_ERROR:\n<line6>error (0, errno, _("error reading %s"), quoteaf (filename));\n<line7>break;\n<line8>case COPY_FD_UNEXPECTED_EOF:\n<line9>error (0, errno, _("%s: file has shrunk too much"), quotef (filename));\n<line10>break;\n<line11>default:\n<line12>affirm (false);\n<line13>}\n<line14>}
----------------------------------------
Function: write_header
Content: <line0>static void\n<line1>write_header (char const *filename)\n<line2>{\n<line3>static bool first_file = true;\n<line4>printf ("%s==> %s <==\n", (first_file ? "" : "\n"), filename);\n<line5>first_file = false;\n<line6>}
----------------------------------------
Function: xwrite_stdout
Content: <line0>static void\n<line1>xwrite_stdout (char const *buffer, size_t n_bytes)\n<line2>{\n<line3>if (n_bytes > 0 && fwrite (buffer, 1, n_bytes, stdout) < n_bytes)\n<line4>{\n<line5>clearerr (stdout); /* To avoid redundant close_stdout diagnostic.  */\n<line6>fpurge (stdout);\n<line7>error (EXIT_FAILURE, errno, _("error writing %s"),\n<line8>quoteaf ("standard output"));\n<line9>}\n<line10>}
----------------------------------------
Function: copy_fd
Content: <line0>static enum Copy_fd_status\n<line1>copy_fd (int src_fd, uintmax_t n_bytes)\n<line2>{\n<line3>char buf[BUFSIZ];\n<line4>const size_t buf_size = sizeof (buf);\n<line5>/* Copy the file contents.  */\n<line6>while (0 < n_bytes)\n<line7>{\n<line8>size_t n_to_read = MIN (buf_size, n_bytes);\n<line9>size_t n_read = safe_read (src_fd, buf, n_to_read);\n<line10>if (n_read == SAFE_READ_ERROR)\n<line11>return COPY_FD_READ_ERROR;\n<line12>n_bytes -= n_read;\n<line13>if (n_read == 0 && n_bytes != 0)\n<line14>return COPY_FD_UNEXPECTED_EOF;\n<line15>xwrite_stdout (buf, n_read);\n<line16>}\n<line17>return COPY_FD_OK;\n<line18>}
----------------------------------------
Function: elseek
Content: <line0>static off_t\n<line1>elseek (int fd, off_t offset, int whence, char const *filename)\n<line2>{\n<line3>off_t new_offset = lseek (fd, offset, whence);\n<line4>char buf[INT_BUFSIZE_BOUND (offset)];\n<line5>if (new_offset < 0)\n<line6>error (0, errno,\n<line7>_(whence == SEEK_SET\n<line8>? N_("%s: cannot seek to offset %s")\n<line9>: N_("%s: cannot seek to relative offset %s")),\n<line10>quotef (filename),\n<line11>offtostr (offset, buf));\n<line12>return new_offset;\n<line13>}
----------------------------------------
Function: elide_tail_bytes_pipe
Content: <line0>static bool\n<line1>elide_tail_bytes_pipe (char const *filename, int fd, uintmax_t n_elide_0,\n<line2>off_t current_pos)\n<line3>{\n<line4>size_t n_elide = n_elide_0;\n<line5>uintmax_t desired_pos = current_pos;\n<line6>bool ok = true;\n<line7>#ifndef HEAD_TAIL_PIPE_READ_BUFSIZE\n<line8># define HEAD_TAIL_PIPE_READ_BUFSIZE BUFSIZ\n<line9>#endif\n<line10>#define READ_BUFSIZE HEAD_TAIL_PIPE_READ_BUFSIZE\n<line11>/* If we're eliding no more than this many bytes, then it's ok to allocate\n<line12>more memory in order to use a more time-efficient algorithm.\n<line13>FIXME: use a fraction of available memory instead, as in sort.\n<line14>FIXME: is this even worthwhile?  */\n<line15>#ifndef HEAD_TAIL_PIPE_BYTECOUNT_THRESHOLD\n<line16># define HEAD_TAIL_PIPE_BYTECOUNT_THRESHOLD 1024 * 1024\n<line17>#endif\n<line18>#if HEAD_TAIL_PIPE_BYTECOUNT_THRESHOLD < 2 * READ_BUFSIZE\n<line19>"HEAD_TAIL_PIPE_BYTECOUNT_THRESHOLD must be at least 2 * READ_BUFSIZE"\n<line20>#endif\n<line21>if (SIZE_MAX < n_elide_0 + READ_BUFSIZE)\n<line22>{\n<line23>char umax_buf[INT_BUFSIZE_BOUND (n_elide_0)];\n<line24>error (EXIT_FAILURE, 0, _("%s: number of bytes is too large"),\n<line25>umaxtostr (n_elide_0, umax_buf));\n<line26>}\n<line27>/* Two cases to consider...\n<line28>1) n_elide is small enough that we can afford to double-buffer:\n<line29>allocate 2 * (READ_BUFSIZE + n_elide) bytes\n<line30>2) n_elide is too big for that, so we allocate only\n<line31>(READ_BUFSIZE + n_elide) bytes\n<line32>FIXME: profile, to see if double-buffering is worthwhile\n<line33>CAUTION: do not fail (out of memory) when asked to elide\n<line34>a ridiculous amount, but when given only a small input.  */\n<line35>if (n_elide <= HEAD_TAIL_PIPE_BYTECOUNT_THRESHOLD)\n<line36>{\n<line37>bool first = true;\n<line38>bool eof = false;\n<line39>size_t n_to_read = READ_BUFSIZE + n_elide;\n<line40>bool i;\n<line41>char *b[2];\n<line42>b[0] = xnmalloc (2, n_to_read);\n<line43>b[1] = b[0] + n_to_read;\n<line44>for (i = false; ! eof ; i = !i)\n<line45>{\n<line46>size_t n_read = full_read (fd, b[i], n_to_read);\n<line47>size_t delta = 0;\n<line48>if (n_read < n_to_read)\n<line49>{\n<line50>if (errno != 0)\n<line51>{\n<line52>error (0, errno, _("error reading %s"), quoteaf (filename));\n<line53>ok = false;\n<line54>break;\n<line55>}\n<line56>/* reached EOF */\n<line57>if (n_read <= n_elide)\n<line58>{\n<line59>if (first)\n<line60>{\n<line61>/* The input is no larger than the number of bytes\n<line62>to elide.  So there's nothing to output, and\n<line63>we're done.  */\n<line64>}\n<line65>else\n<line66>{\n<line67>delta = n_elide - n_read;\n<line68>}\n<line69>}\n<line70>eof = true;\n<line71>}\n<line72>/* Output any (but maybe just part of the) elided data from\n<line73>the previous round.  */\n<line74>if (! first)\n<line75>{\n<line76>desired_pos += n_elide - delta;\n<line77>xwrite_stdout (b[!i] + READ_BUFSIZE, n_elide - delta);\n<line78>}\n<line79>first = false;\n<line80>if (n_elide < n_read)\n<line81>{\n<line82>desired_pos += n_read - n_elide;\n<line83>xwrite_stdout (b[i], n_read - n_elide);\n<line84>}\n<line85>}\n<line86>free (b[0]);\n<line87>}\n<line88>else\n<line89>{\n<line90>/* Read blocks of size READ_BUFSIZE, until we've read at least n_elide\n<line91>bytes.  Then, for each new buffer we read, also write an old one.  */\n<line92>bool eof = false;\n<line93>size_t n_read;\n<line94>bool buffered_enough;\n<line95>size_t i, i_next;\n<line96>char **b = nullptr;\n<line97>/* Round n_elide up to a multiple of READ_BUFSIZE.  */\n<line98>size_t rem = READ_BUFSIZE - (n_elide % READ_BUFSIZE);\n<line99>size_t n_elide_round = n_elide + rem;\n<line100>size_t n_bufs = n_elide_round / READ_BUFSIZE + 1;\n<line101>size_t n_alloc = 0;\n<line102>size_t n_array_alloc = 0;\n<line103>buffered_enough = false;\n<line104>for (i = 0, i_next = 1; !eof; i = i_next, i_next = (i_next + 1) % n_bufs)\n<line105>{\n<line106>if (n_array_alloc == i)\n<line107>{\n<line108>/* reallocate between 16 and n_bufs entries.  */\n<line109>if (n_array_alloc == 0)\n<line110>n_array_alloc = MIN (n_bufs, 16);\n<line111>else if (n_array_alloc <= n_bufs / 2)\n<line112>n_array_alloc *= 2;\n<line113>else\n<line114>n_array_alloc = n_bufs;\n<line115>b = xnrealloc (b, n_array_alloc, sizeof *b);\n<line116>}\n<line117>if (! buffered_enough)\n<line118>{\n<line119>b[i] = xmalloc (READ_BUFSIZE);\n<line120>n_alloc = i + 1;\n<line121>}\n<line122>n_read = full_read (fd, b[i], READ_BUFSIZE);\n<line123>if (n_read < READ_BUFSIZE)\n<line124>{\n<line125>if (errno != 0)\n<line126>{\n<line127>error (0, errno, _("error reading %s"), quoteaf (filename));\n<line128>ok = false;\n<line129>goto free_mem;\n<line130>}\n<line131>eof = true;\n<line132>}\n<line133>if (i + 1 == n_bufs)\n<line134>buffered_enough = true;\n<line135>if (buffered_enough)\n<line136>{\n<line137>desired_pos += n_read;\n<line138>xwrite_stdout (b[i_next], n_read);\n<line139>}\n<line140>}\n<line141>/* Output any remainder: rem bytes from b[i] + n_read.  */\n<line142>if (rem)\n<line143>{\n<line144>if (buffered_enough)\n<line145>{\n<line146>size_t n_bytes_left_in_b_i = READ_BUFSIZE - n_read;\n<line147>desired_pos += rem;\n<line148>if (rem < n_bytes_left_in_b_i)\n<line149>{\n<line150>xwrite_stdout (b[i] + n_read, rem);\n<line151>}\n<line152>else\n<line153>{\n<line154>xwrite_stdout (b[i] + n_read, n_bytes_left_in_b_i);\n<line155>xwrite_stdout (b[i_next], rem - n_bytes_left_in_b_i);\n<line156>}\n<line157>}\n<line158>else if (i + 1 == n_bufs)\n<line159>{\n<line160>/* This happens when n_elide < file_size < n_elide_round.\n<line161>|READ_BUF.|\n<line162>|                      |  rem |\n<line163>|---------!---------!---------!---------|\n<line164>|---- n_elide ---------|\n<line165>|                      | x |\n<line166>|                   |y |\n<line167>|---- file size -----------|\n<line168>|                   |n_read|\n<line169>|---- n_elide_round ----------|\n<line170>*/\n<line171>size_t y = READ_BUFSIZE - rem;\n<line172>size_t x = n_read - y;\n<line173>desired_pos += x;\n<line174>xwrite_stdout (b[i_next], x);\n<line175>}\n<line176>}\n<line177>free_mem:\n<line178>for (i = 0; i < n_alloc; i++)\n<line179>free (b[i]);\n<line180>free (b);\n<line181>}\n<line182>if (0 <= current_pos && elseek (fd, desired_pos, SEEK_SET, filename) < 0)\n<line183>ok = false;\n<line184>return ok;\n<line185>}
----------------------------------------
Function: elide_tail_bytes_file
Content: <line0>static bool\n<line1>elide_tail_bytes_file (char const *filename, int fd, uintmax_t n_elide,\n<line2>struct stat const *st, off_t current_pos)\n<line3>{\n<line4>off_t size = st->st_size;\n<line5>if (presume_input_pipe || current_pos < 0 || size <= ST_BLKSIZE (*st))\n<line6>return elide_tail_bytes_pipe (filename, fd, n_elide, current_pos);\n<line7>else\n<line8>{\n<line9>/* Be careful here.  The current position may actually be\n<line10>beyond the end of the file.  */\n<line11>off_t diff = size - current_pos;\n<line12>off_t bytes_remaining = diff < 0 ? 0 : diff;\n<line13>if (bytes_remaining <= n_elide)\n<line14>return true;\n<line15>enum Copy_fd_status err = copy_fd (fd, bytes_remaining - n_elide);\n<line16>if (err == COPY_FD_OK)\n<line17>return true;\n<line18>diagnose_copy_fd_failure (err, filename);\n<line19>return false;\n<line20>}\n<line21>}
----------------------------------------
Function: elide_tail_lines_pipe
Content: <line0>static bool\n<line1>elide_tail_lines_pipe (char const *filename, int fd, uintmax_t n_elide,\n<line2>off_t current_pos)\n<line3>{\n<line4>struct linebuffer\n<line5>{\n<line6>char buffer[BUFSIZ + 1];\n<line7>size_t nbytes;\n<line8>size_t nlines;\n<line9>struct linebuffer *next;\n<line10>};\n<line11>uintmax_t desired_pos = current_pos;\n<line12>typedef struct linebuffer LBUFFER;\n<line13>LBUFFER *first, *last, *tmp;\n<line14>size_t total_lines = 0;	/* Total number of newlines in all buffers.  */\n<line15>bool ok = true;\n<line16>size_t n_read;		/* Size in bytes of most recent read */\n<line17>first = last = xmalloc (sizeof (LBUFFER));\n<line18>first->nbytes = first->nlines = 0;\n<line19>first->next = nullptr;\n<line20>tmp = xmalloc (sizeof (LBUFFER));\n<line21>/* Always read into a fresh buffer.\n<line22>Read, (producing no output) until we've accumulated at least\n<line23>n_elide newlines, or until EOF, whichever comes first.  */\n<line24>while (true)\n<line25>{\n<line26>n_read = safe_read (fd, tmp->buffer, BUFSIZ);\n<line27>if (n_read == 0 || n_read == SAFE_READ_ERROR)\n<line28>break;\n<line29>if (! n_elide)\n<line30>{\n<line31>desired_pos += n_read;\n<line32>xwrite_stdout (tmp->buffer, n_read);\n<line33>continue;\n<line34>}\n<line35>tmp->nbytes = n_read;\n<line36>tmp->nlines = 0;\n<line37>tmp->next = nullptr;\n<line38>/* Count the number of newlines just read.  */\n<line39>{\n<line40>char *buffer_end = tmp->buffer + n_read;\n<line41>*buffer_end = line_end;\n<line42>char const *p = tmp->buffer;\n<line43>while ((p = rawmemchr (p, line_end)) < buffer_end)\n<line44>{\n<line45>++p;\n<line46>++tmp->nlines;\n<line47>}\n<line48>}\n<line49>total_lines += tmp->nlines;\n<line50>/* If there is enough room in the last buffer read, just append the new\n<line51>one to it.  This is because when reading from a pipe, 'n_read' can\n<line52>often be very small.  */\n<line53>if (tmp->nbytes + last->nbytes < BUFSIZ)\n<line54>{\n<line55>memcpy (&last->buffer[last->nbytes], tmp->buffer, tmp->nbytes);\n<line56>last->nbytes += tmp->nbytes;\n<line57>last->nlines += tmp->nlines;\n<line58>}\n<line59>else\n<line60>{\n<line61>/* If there's not enough room, link the new buffer onto the end of\n<line62>the list, then either free up the oldest buffer for the next\n<line63>read if that would leave enough lines, or else malloc a new one.\n<line64>Some compaction mechanism is possible but probably not\n<line65>worthwhile.  */\n<line66>last = last->next = tmp;\n<line67>if (n_elide < total_lines - first->nlines)\n<line68>{\n<line69>desired_pos += first->nbytes;\n<line70>xwrite_stdout (first->buffer, first->nbytes);\n<line71>tmp = first;\n<line72>total_lines -= first->nlines;\n<line73>first = first->next;\n<line74>}\n<line75>else\n<line76>tmp = xmalloc (sizeof (LBUFFER));\n<line77>}\n<line78>}\n<line79>free (tmp);\n<line80>if (n_read == SAFE_READ_ERROR)\n<line81>{\n<line82>error (0, errno, _("error reading %s"), quoteaf (filename));\n<line83>ok = false;\n<line84>goto free_lbuffers;\n<line85>}\n<line86>/* If we read any bytes at all, count the incomplete line\n<line87>on files that don't end with a newline.  */\n<line88>if (last->nbytes && last->buffer[last->nbytes - 1] != line_end)\n<line89>{\n<line90>++last->nlines;\n<line91>++total_lines;\n<line92>}\n<line93>for (tmp = first; n_elide < total_lines - tmp->nlines; tmp = tmp->next)\n<line94>{\n<line95>desired_pos += tmp->nbytes;\n<line96>xwrite_stdout (tmp->buffer, tmp->nbytes);\n<line97>total_lines -= tmp->nlines;\n<line98>}\n<line99>/* Print the first 'total_lines - n_elide' lines of tmp->buffer.  */\n<line100>if (n_elide < total_lines)\n<line101>{\n<line102>size_t n = total_lines - n_elide;\n<line103>char const *buffer_end = tmp->buffer + tmp->nbytes;\n<line104>char const *p = tmp->buffer;\n<line105>while (n && (p = memchr (p, line_end, buffer_end - p)))\n<line106>{\n<line107>++p;\n<line108>++tmp->nlines;\n<line109>--n;\n<line110>}\n<line111>desired_pos += p - tmp->buffer;\n<line112>xwrite_stdout (tmp->buffer, p - tmp->buffer);\n<line113>}\n<line114>free_lbuffers:\n<line115>while (first)\n<line116>{\n<line117>tmp = first->next;\n<line118>free (first);\n<line119>first = tmp;\n<line120>}\n<line121>if (0 <= current_pos && elseek (fd, desired_pos, SEEK_SET, filename) < 0)\n<line122>ok = false;\n<line123>return ok;\n<line124>}
----------------------------------------
Function: elide_tail_lines_seekable
Content: <line0>static bool\n<line1>elide_tail_lines_seekable (char const *pretty_filename, int fd,\n<line2>uintmax_t n_lines,\n<line3>off_t start_pos, off_t size)\n<line4>{\n<line5>char buffer[BUFSIZ];\n<line6>size_t bytes_read;\n<line7>off_t pos = size;\n<line8>/* Set 'bytes_read' to the size of the last, probably partial, buffer;\n<line9>0 < 'bytes_read' <= 'BUFSIZ'.  */\n<line10>bytes_read = (pos - start_pos) % BUFSIZ;\n<line11>if (bytes_read == 0)\n<line12>bytes_read = BUFSIZ;\n<line13>/* Make 'pos' a multiple of 'BUFSIZ' (0 if the file is short), so that all\n<line14>reads will be on block boundaries, which might increase efficiency.  */\n<line15>pos -= bytes_read;\n<line16>if (elseek (fd, pos, SEEK_SET, pretty_filename) < 0)\n<line17>return false;\n<line18>bytes_read = safe_read (fd, buffer, bytes_read);\n<line19>if (bytes_read == SAFE_READ_ERROR)\n<line20>{\n<line21>error (0, errno, _("error reading %s"), quoteaf (pretty_filename));\n<line22>return false;\n<line23>}\n<line24>/* n_lines == 0 case needs special treatment. */\n<line25>const bool all_lines = !n_lines;\n<line26>/* Count the incomplete line on files that don't end with a newline.  */\n<line27>if (n_lines && bytes_read && buffer[bytes_read - 1] != line_end)\n<line28>--n_lines;\n<line29>while (true)\n<line30>{\n<line31>/* Scan backward, counting the newlines in this bufferfull.  */\n<line32>size_t n = bytes_read;\n<line33>while (n)\n<line34>{\n<line35>if (all_lines)\n<line36>n -= 1;\n<line37>else\n<line38>{\n<line39>char const *nl;\n<line40>nl = memrchr (buffer, line_end, n);\n<line41>if (nl == nullptr)\n<line42>break;\n<line43>n = nl - buffer;\n<line44>}\n<line45>if (n_lines-- == 0)\n<line46>{\n<line47>/* Found it.  */\n<line48>/* If necessary, restore the file pointer and copy\n<line49>input to output up to position, POS.  */\n<line50>if (start_pos < pos)\n<line51>{\n<line52>enum Copy_fd_status err;\n<line53>if (elseek (fd, start_pos, SEEK_SET, pretty_filename) < 0)\n<line54>return false;\n<line55>err = copy_fd (fd, pos - start_pos);\n<line56>if (err != COPY_FD_OK)\n<line57>{\n<line58>diagnose_copy_fd_failure (err, pretty_filename);\n<line59>return false;\n<line60>}\n<line61>}\n<line62>/* Output the initial portion of the buffer\n<line63>in which we found the desired newline byte.  */\n<line64>xwrite_stdout (buffer, n + 1);\n<line65>/* Set file pointer to the byte after what we've output.  */\n<line66>return 0 <= elseek (fd, pos + n + 1, SEEK_SET, pretty_filename);\n<line67>}\n<line68>}\n<line69>/* Not enough newlines in that bufferfull.  */\n<line70>if (pos == start_pos)\n<line71>{\n<line72>/* Not enough lines in the file.  */\n<line73>return true;\n<line74>}\n<line75>pos -= BUFSIZ;\n<line76>if (elseek (fd, pos, SEEK_SET, pretty_filename) < 0)\n<line77>return false;\n<line78>bytes_read = safe_read (fd, buffer, BUFSIZ);\n<line79>if (bytes_read == SAFE_READ_ERROR)\n<line80>{\n<line81>error (0, errno, _("error reading %s"), quoteaf (pretty_filename));\n<line82>return false;\n<line83>}\n<line84>/* FIXME: is this dead code?\n<line85>Consider the test, pos == start_pos, above. */\n<line86>if (bytes_read == 0)\n<line87>return true;\n<line88>}\n<line89>}
----------------------------------------
Function: elide_tail_lines_file
Content: <line0>static bool\n<line1>elide_tail_lines_file (char const *filename, int fd, uintmax_t n_elide,\n<line2>struct stat const *st, off_t current_pos)\n<line3>{\n<line4>off_t size = st->st_size;\n<line5>if (presume_input_pipe || current_pos < 0 || size <= ST_BLKSIZE (*st))\n<line6>return elide_tail_lines_pipe (filename, fd, n_elide, current_pos);\n<line7>else\n<line8>{\n<line9>/* Find the offset, OFF, of the Nth newline from the end,\n<line10>but not counting the last byte of the file.\n<line11>If found, write from current position to OFF, inclusive.\n<line12>Otherwise, just return true.  */\n<line13>return (size <= current_pos\n<line14>|| elide_tail_lines_seekable (filename, fd, n_elide,\n<line15>current_pos, size));\n<line16>}\n<line17>}
----------------------------------------
Function: head_bytes
Content: <line0>static bool\n<line1>head_bytes (char const *filename, int fd, uintmax_t bytes_to_write)\n<line2>{\n<line3>char buffer[BUFSIZ];\n<line4>size_t bytes_to_read = BUFSIZ;\n<line5>while (bytes_to_write)\n<line6>{\n<line7>size_t bytes_read;\n<line8>if (bytes_to_write < bytes_to_read)\n<line9>bytes_to_read = bytes_to_write;\n<line10>bytes_read = safe_read (fd, buffer, bytes_to_read);\n<line11>if (bytes_read == SAFE_READ_ERROR)\n<line12>{\n<line13>error (0, errno, _("error reading %s"), quoteaf (filename));\n<line14>return false;\n<line15>}\n<line16>if (bytes_read == 0)\n<line17>break;\n<line18>xwrite_stdout (buffer, bytes_read);\n<line19>bytes_to_write -= bytes_read;\n<line20>}\n<line21>return true;\n<line22>}
----------------------------------------
Function: head_lines
Content: <line0>static bool\n<line1>head_lines (char const *filename, int fd, uintmax_t lines_to_write)\n<line2>{\n<line3>char buffer[BUFSIZ];\n<line4>while (lines_to_write)\n<line5>{\n<line6>size_t bytes_read = safe_read (fd, buffer, BUFSIZ);\n<line7>size_t bytes_to_write = 0;\n<line8>if (bytes_read == SAFE_READ_ERROR)\n<line9>{\n<line10>error (0, errno, _("error reading %s"), quoteaf (filename));\n<line11>return false;\n<line12>}\n<line13>if (bytes_read == 0)\n<line14>break;\n<line15>while (bytes_to_write < bytes_read)\n<line16>if (buffer[bytes_to_write++] == line_end && --lines_to_write == 0)\n<line17>{\n<line18>off_t n_bytes_past_EOL = bytes_read - bytes_to_write;\n<line19>/* If we have read more data than that on the specified number\n<line20>of lines, try to seek back to the position we would have\n<line21>gotten to had we been reading one byte at a time.  */\n<line22>if (lseek (fd, -n_bytes_past_EOL, SEEK_CUR) < 0)\n<line23>{\n<line24>struct stat st;\n<line25>if (fstat (fd, &st) != 0 || S_ISREG (st.st_mode))\n<line26>elseek (fd, -n_bytes_past_EOL, SEEK_CUR, filename);\n<line27>}\n<line28>break;\n<line29>}\n<line30>xwrite_stdout (buffer, bytes_to_write);\n<line31>}\n<line32>return true;\n<line33>}
----------------------------------------
Function: head
Content: <line0>static bool\n<line1>head (char const *filename, int fd, uintmax_t n_units, bool count_lines,\n<line2>bool elide_from_end)\n<line3>{\n<line4>if (print_headers)\n<line5>write_header (filename);\n<line6>if (elide_from_end)\n<line7>{\n<line8>off_t current_pos = -1;\n<line9>struct stat st;\n<line10>if (fstat (fd, &st) != 0)\n<line11>{\n<line12>error (0, errno, _("cannot fstat %s"),\n<line13>quoteaf (filename));\n<line14>return false;\n<line15>}\n<line16>if (! presume_input_pipe && usable_st_size (&st))\n<line17>{\n<line18>current_pos = elseek (fd, 0, SEEK_CUR, filename);\n<line19>if (current_pos < 0)\n<line20>return false;\n<line21>}\n<line22>if (count_lines)\n<line23>return elide_tail_lines_file (filename, fd, n_units, &st, current_pos);\n<line24>else\n<line25>return elide_tail_bytes_file (filename, fd, n_units, &st, current_pos);\n<line26>}\n<line27>if (count_lines)\n<line28>return head_lines (filename, fd, n_units);\n<line29>else\n<line30>return head_bytes (filename, fd, n_units);\n<line31>}
----------------------------------------
Function: head_file
Content: <line0>static bool\n<line1>head_file (char const *filename, uintmax_t n_units, bool count_lines,\n<line2>bool elide_from_end)\n<line3>{\n<line4>int fd;\n<line5>bool ok;\n<line6>bool is_stdin = STREQ (filename, "-");\n<line7>if (is_stdin)\n<line8>{\n<line9>have_read_stdin = true;\n<line10>fd = STDIN_FILENO;\n<line11>filename = _("standard input");\n<line12>xset_binary_mode (STDIN_FILENO, O_BINARY);\n<line13>}\n<line14>else\n<line15>{\n<line16>fd = open (filename, O_RDONLY | O_BINARY);\n<line17>if (fd < 0)\n<line18>{\n<line19>error (0, errno, _("cannot open %s for reading"), quoteaf (filename));\n<line20>return false;\n<line21>}\n<line22>}\n<line23>ok = head (filename, fd, n_units, count_lines, elide_from_end);\n<line24>if (!is_stdin && close (fd) != 0)\n<line25>{\n<line26>error (0, errno, _("failed to close %s"), quoteaf (filename));\n<line27>return false;\n<line28>}\n<line29>return ok;\n<line30>}
----------------------------------------
Function: string_to_integer
Content: <line0>static uintmax_t\n<line1>string_to_integer (bool count_lines, char const *n_string)\n<line2>{\n<line3>return xdectoumax (n_string, 0, UINTMAX_MAX, "bkKmMGTPEZYRQ0",\n<line4>count_lines ? _("invalid number of lines")\n<line5>: _("invalid number of bytes"), 0);\n<line6>}
----------------------------------------
Function: main
Content: <line0>int\n<line1>main (int argc, char **argv)\n<line2>{\n<line3>enum header_mode header_mode = multiple_files;\n<line4>bool ok = true;\n<line5>int c;\n<line6>size_t i;\n<line7>/* Number of items to print. */\n<line8>uintmax_t n_units = DEFAULT_NUMBER;\n<line9>/* If true, interpret the numeric argument as the number of lines.\n<line10>Otherwise, interpret it as the number of bytes.  */\n<line11>bool count_lines = true;\n<line12>/* Elide the specified number of lines or bytes, counting from\n<line13>the end of the file.  */\n<line14>bool elide_from_end = false;\n<line15>/* Initializer for file_list if no file-arguments\n<line16>were specified on the command line.  */\n<line17>static char const *const default_file_list[] = {"-", nullptr};\n<line18>char const *const *file_list;\n<line19>initialize_main (&argc, &argv);\n<line20>set_program_name (argv[0]);\n<line21>setlocale (LC_ALL, "");\n<line22>bindtextdomain (PACKAGE, LOCALEDIR);\n<line23>textdomain (PACKAGE);\n<line24>atexit (close_stdout);\n<line25>have_read_stdin = false;\n<line26>print_headers = false;\n<line27>line_end = '\n';\n<line28>if (1 < argc && argv[1][0] == '-' && ISDIGIT (argv[1][1]))\n<line29>{\n<line30>char *a = argv[1];\n<line31>char *n_string = ++a;\n<line32>char *end_n_string;\n<line33>char multiplier_char = 0;\n<line34>/* Old option syntax; a dash, one or more digits, and one or\n<line35>more option letters.  Move past the number. */\n<line36>do ++a;\n<line37>while (ISDIGIT (*a));\n<line38>/* Pointer to the byte after the last digit.  */\n<line39>end_n_string = a;\n<line40>/* Parse any appended option letters. */\n<line41>for (; *a; a++)\n<line42>{\n<line43>switch (*a)\n<line44>{\n<line45>case 'c':\n<line46>count_lines = false;\n<line47>multiplier_char = 0;\n<line48>break;\n<line49>case 'b':\n<line50>case 'k':\n<line51>case 'm':\n<line52>count_lines = false;\n<line53>multiplier_char = *a;\n<line54>break;\n<line55>case 'l':\n<line56>count_lines = true;\n<line57>break;\n<line58>case 'q':\n<line59>header_mode = never;\n<line60>break;\n<line61>case 'v':\n<line62>header_mode = always;\n<line63>break;\n<line64>case 'z':\n<line65>line_end = '\0';\n<line66>break;\n<line67>default:\n<line68>error (0, 0, _("invalid trailing option -- %c"), *a);\n<line69>usage (EXIT_FAILURE);\n<line70>}\n<line71>}\n<line72>/* Append the multiplier character (if any) onto the end of\n<line73>the digit string.  Then add NUL byte if necessary.  */\n<line74>*end_n_string = multiplier_char;\n<line75>if (multiplier_char)\n<line76>*(++end_n_string) = 0;\n<line77>n_units = string_to_integer (count_lines, n_string);\n<line78>/* Make the options we just parsed invisible to getopt. */\n<line79>argv[1] = argv[0];\n<line80>argv++;\n<line81>argc--;\n<line82>}\n<line83>while ((c = getopt_long (argc, argv, "c:n:qvz0123456789",\n<line84>long_options, nullptr))\n<line85>!= -1)\n<line86>{\n<line87>switch (c)\n<line88>{\n<line89>case PRESUME_INPUT_PIPE_OPTION:\n<line90>presume_input_pipe = true;\n<line91>break;\n<line92>case 'c':\n<line93>count_lines = false;\n<line94>elide_from_end = (*optarg == '-');\n<line95>if (elide_from_end)\n<line96>++optarg;\n<line97>n_units = string_to_integer (count_lines, optarg);\n<line98>break;\n<line99>case 'n':\n<line100>count_lines = true;\n<line101>elide_from_end = (*optarg == '-');\n<line102>if (elide_from_end)\n<line103>++optarg;\n<line104>n_units = string_to_integer (count_lines, optarg);\n<line105>break;\n<line106>case 'q':\n<line107>header_mode = never;\n<line108>break;\n<line109>case 'v':\n<line110>header_mode = always;\n<line111>break;\n<line112>case 'z':\n<line113>line_end = '\0';\n<line114>break;\n<line115>case_GETOPT_HELP_CHAR;\n<line116>case_GETOPT_VERSION_CHAR (PROGRAM_NAME, AUTHORS);\n<line117>default:\n<line118>if (ISDIGIT (c))\n<line119>error (0, 0, _("invalid trailing option -- %c"), c);\n<line120>usage (EXIT_FAILURE);\n<line121>}\n<line122>}\n<line123>if (header_mode == always\n<line124>|| (header_mode == multiple_files && optind < argc - 1))\n<line125>print_headers = true;\n<line126>if ( ! count_lines && elide_from_end && OFF_T_MAX < n_units)\n<line127>{\n<line128>char umax_buf[INT_BUFSIZE_BOUND (n_units)];\n<line129>error (EXIT_FAILURE, EOVERFLOW, "%s: %s", _("invalid number of bytes"),\n<line130>quote (umaxtostr (n_units, umax_buf)));\n<line131>}\n<line132>file_list = (optind < argc\n<line133>? (char const *const *) &argv[optind]\n<line134>: default_file_list);\n<line135>xset_binary_mode (STDOUT_FILENO, O_BINARY);\n<line136>for (i = 0; file_list[i]; ++i)\n<line137>ok &= head_file (file_list[i], n_units, count_lines, elide_from_end);\n<line138>if (have_read_stdin && close (STDIN_FILENO) < 0)\n<line139>error (EXIT_FAILURE, errno, "-");\n<line140>return ok ? EXIT_SUCCESS : EXIT_FAILURE;\n<line141>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/src/id.c
========================================
Function: usage
Content: <line0>void\n<line1>usage (int status)\n<line2>{\n<line3>if (status != EXIT_SUCCESS)\n<line4>emit_try_help ();\n<line5>else\n<line6>{\n<line7>printf (_("Usage: %s [OPTION]... [USER]...\n"), program_name);\n<line8>fputs (_("\\n<line9>Print user and group information for each specified USER,\n\\n<line10>or (when USER omitted) for the current process.\n\\n<line11>\n"),\n<line12>stdout);\n<line13>fputs (_("\\n<line14>-a             ignore, for compatibility with other versions\n\\n<line15>-Z, --context  print only the security context of the process\n\\n<line16>-g, --group    print only the effective group ID\n\\n<line17>-G, --groups   print all group IDs\n\\n<line18>-n, --name     print a name instead of a number, for -ugG\n\\n<line19>-r, --real     print the real ID instead of the effective ID, with -ugG\n\\n<line20>-u, --user     print only the effective user ID\n\\n<line21>-z, --zero     delimit entries with NUL characters, not whitespace;\n\\n<line22>not permitted in default format\n\\n<line23>"), stdout);\n<line24>fputs (HELP_OPTION_DESCRIPTION, stdout);\n<line25>fputs (VERSION_OPTION_DESCRIPTION, stdout);\n<line26>fputs (_("\\n<line27>\n\\n<line28>Without any OPTION, print some useful set of identified information.\n\\n<line29>"), stdout);\n<line30>emit_ancillary_info (PROGRAM_NAME);\n<line31>}\n<line32>exit (status);\n<line33>}
----------------------------------------
Function: main
Content: <line0>int\n<line1>main (int argc, char **argv)\n<line2>{\n<line3>int optc;\n<line4>int selinux_enabled = (is_selinux_enabled () > 0);\n<line5>bool smack_enabled = is_smack_enabled ();\n<line6>initialize_main (&argc, &argv);\n<line7>set_program_name (argv[0]);\n<line8>setlocale (LC_ALL, "");\n<line9>bindtextdomain (PACKAGE, LOCALEDIR);\n<line10>textdomain (PACKAGE);\n<line11>atexit (close_stdout);\n<line12>while ((optc = getopt_long (argc, argv, "agnruzGZ", longopts, nullptr)) != -1)\n<line13>{\n<line14>switch (optc)\n<line15>{\n<line16>case 'a':\n<line17>/* Ignore -a, for compatibility with SVR4.  */\n<line18>break;\n<line19>case 'Z':\n<line20>/* politely decline if we're not on a SELinux/SMACK-enabled kernel. */\n<line21>#ifdef HAVE_SMACK\n<line22>if (!selinux_enabled && !smack_enabled)\n<line23>error (EXIT_FAILURE, 0,\n<line24>_("--context (-Z) works only on "\n<line25>"an SELinux/SMACK-enabled kernel"));\n<line26>#else\n<line27>if (!selinux_enabled)\n<line28>error (EXIT_FAILURE, 0,\n<line29>_("--context (-Z) works only on an SELinux-enabled kernel"));\n<line30>#endif\n<line31>just_context = true;\n<line32>break;\n<line33>case 'g':\n<line34>just_group = true;\n<line35>break;\n<line36>case 'n':\n<line37>use_name = true;\n<line38>break;\n<line39>case 'r':\n<line40>use_real = true;\n<line41>break;\n<line42>case 'u':\n<line43>just_user = true;\n<line44>break;\n<line45>case 'z':\n<line46>opt_zero = true;\n<line47>break;\n<line48>case 'G':\n<line49>just_group_list = true;\n<line50>break;\n<line51>case_GETOPT_HELP_CHAR;\n<line52>case_GETOPT_VERSION_CHAR (PROGRAM_NAME, AUTHORS);\n<line53>default:\n<line54>usage (EXIT_FAILURE);\n<line55>}\n<line56>}\n<line57>size_t n_ids = argc - optind;\n<line58>if (n_ids && just_context)\n<line59>error (EXIT_FAILURE, 0,\n<line60>_("cannot print security context when user specified"));\n<line61>if (just_user + just_group + just_group_list + just_context > 1)\n<line62>error (EXIT_FAILURE, 0, _("cannot print \"only\" of more than one choice"));\n<line63>bool default_format = ! (just_user\n<line64>|| just_group\n<line65>|| just_group_list\n<line66>|| just_context);\n<line67>if (default_format && (use_real || use_name))\n<line68>error (EXIT_FAILURE, 0,\n<line69>_("cannot print only names or real IDs in default format"));\n<line70>if (default_format && opt_zero)\n<line71>error (EXIT_FAILURE, 0,\n<line72>_("option --zero not permitted in default format"));\n<line73>/* If we are on a SELinux/SMACK-enabled kernel, no user is specified, and\n<line74>either --context is specified or none of (-u,-g,-G) is specified,\n<line75>and we're not in POSIXLY_CORRECT mode, get our context.  Otherwise,\n<line76>leave the context variable alone - it has been initialized to an\n<line77>invalid value that will be not displayed in print_full_info().  */\n<line78>if (n_ids == 0\n<line79>&& (just_context\n<line80>|| (default_format && ! getenv ("POSIXLY_CORRECT"))))\n<line81>{\n<line82>/* Report failure only if --context (-Z) was explicitly requested.  */\n<line83>if ((selinux_enabled && getcon (&context) && just_context)\n<line84>|| (smack_enabled\n<line85>&& smack_new_label_from_self (&context) < 0\n<line86>&& just_context))\n<line87>error (EXIT_FAILURE, 0, _("can't get process context"));\n<line88>}\n<line89>if (n_ids >= 1)\n<line90>{\n<line91>multiple_users = n_ids > 1 ? true : false;\n<line92>/* Changing the value of n_ids to the last index in the array where we\n<line93>have the last possible user id. This helps us because we don't have\n<line94>to declare a different variable to keep a track of where the\n<line95>last username lies in argv[].  */\n<line96>n_ids += optind;\n<line97>/* For each username/userid to get its pw_name field */\n<line98>for (; optind < n_ids; optind++)\n<line99>{\n<line100>char *pw_name = nullptr;\n<line101>struct passwd *pwd = nullptr;\n<line102>char const *spec = argv[optind];\n<line103>/* Disallow an empty spec here as parse_user_spec() doesn't\n<line104>give an error for that as it seems it's a valid way to\n<line105>specify a noop or "reset special bits" depending on the system.  */\n<line106>if (*spec)\n<line107>{\n<line108>if (! parse_user_spec (spec, &euid, nullptr, &pw_name, nullptr))\n<line109>pwd = pw_name ? getpwnam (pw_name) : getpwuid (euid);\n<line110>}\n<line111>if (pwd == nullptr)\n<line112>{\n<line113>error (0, errno, _("%s: no such user"), quote (spec));\n<line114>ok &= false;\n<line115>}\n<line116>else\n<line117>{\n<line118>if (!pw_name)\n<line119>pw_name = xstrdup (pwd->pw_name);\n<line120>ruid = euid = pwd->pw_uid;\n<line121>rgid = egid = pwd->pw_gid;\n<line122>print_stuff (pw_name);\n<line123>}\n<line124>free (pw_name);\n<line125>}\n<line126>}\n<line127>else\n<line128>{\n<line129>/* POSIX says identification functions (getuid, getgid, and\n<line130>others) cannot fail, but they can fail under GNU/Hurd and a\n<line131>few other systems.  Test for failure by checking errno.  */\n<line132>uid_t NO_UID = -1;\n<line133>gid_t NO_GID = -1;\n<line134>if (just_user ? !use_real\n<line135>: !just_group && !just_group_list && !just_context)\n<line136>{\n<line137>errno = 0;\n<line138>euid = geteuid ();\n<line139>if (euid == NO_UID && errno)\n<line140>error (EXIT_FAILURE, errno, _("cannot get effective UID"));\n<line141>}\n<line142>if (just_user ? use_real\n<line143>: !just_group && (just_group_list || !just_context))\n<line144>{\n<line145>errno = 0;\n<line146>ruid = getuid ();\n<line147>if (ruid == NO_UID && errno)\n<line148>error (EXIT_FAILURE, errno, _("cannot get real UID"));\n<line149>}\n<line150>if (!just_user && (just_group || just_group_list || !just_context))\n<line151>{\n<line152>errno = 0;\n<line153>egid = getegid ();\n<line154>if (egid == NO_GID && errno)\n<line155>error (EXIT_FAILURE, errno, _("cannot get effective GID"));\n<line156>errno = 0;\n<line157>rgid = getgid ();\n<line158>if (rgid == NO_GID && errno)\n<line159>error (EXIT_FAILURE, errno, _("cannot get real GID"));\n<line160>}\n<line161>print_stuff (nullptr);\n<line162>}\n<line163>return ok ? EXIT_SUCCESS : EXIT_FAILURE;\n<line164>}
----------------------------------------
Function: gidtostr_ptr
Content: <line0>static char *\n<line1>gidtostr_ptr (gid_t const *gid)\n<line2>{\n<line3>static char buf[INT_BUFSIZE_BOUND (uintmax_t)];\n<line4>return umaxtostr (*gid, buf);\n<line5>}
----------------------------------------
Function: uidtostr_ptr
Content: <line0>static char *\n<line1>uidtostr_ptr (uid_t const *uid)\n<line2>{\n<line3>static char buf[INT_BUFSIZE_BOUND (uintmax_t)];\n<line4>return umaxtostr (*uid, buf);\n<line5>}
----------------------------------------
Function: print_user
Content: <line0>static void\n<line1>print_user (uid_t uid)\n<line2>{\n<line3>struct passwd *pwd = nullptr;\n<line4>if (use_name)\n<line5>{\n<line6>pwd = getpwuid (uid);\n<line7>if (pwd == nullptr)\n<line8>{\n<line9>error (0, 0, _("cannot find name for user ID %s"),\n<line10>uidtostr (uid));\n<line11>ok &= false;\n<line12>}\n<line13>}\n<line14>char *s = pwd ? pwd->pw_name : uidtostr (uid);\n<line15>fputs (s, stdout);\n<line16>}
----------------------------------------
Function: print_full_info
Content: <line0>static void\n<line1>print_full_info (char const *username)\n<line2>{\n<line3>struct passwd *pwd;\n<line4>struct group *grp;\n<line5>printf (_("uid=%s"), uidtostr (ruid));\n<line6>pwd = getpwuid (ruid);\n<line7>if (pwd)\n<line8>printf ("(%s)", pwd->pw_name);\n<line9>printf (_(" gid=%s"), gidtostr (rgid));\n<line10>grp = getgrgid (rgid);\n<line11>if (grp)\n<line12>printf ("(%s)", grp->gr_name);\n<line13>if (euid != ruid)\n<line14>{\n<line15>printf (_(" euid=%s"), uidtostr (euid));\n<line16>pwd = getpwuid (euid);\n<line17>if (pwd)\n<line18>printf ("(%s)", pwd->pw_name);\n<line19>}\n<line20>if (egid != rgid)\n<line21>{\n<line22>printf (_(" egid=%s"), gidtostr (egid));\n<line23>grp = getgrgid (egid);\n<line24>if (grp)\n<line25>printf ("(%s)", grp->gr_name);\n<line26>}\n<line27>{\n<line28>gid_t *groups;\n<line29>gid_t primary_group;\n<line30>if (username)\n<line31>primary_group = pwd ? pwd->pw_gid : -1;\n<line32>else\n<line33>primary_group = egid;\n<line34>int n_groups = xgetgroups (username, primary_group, &groups);\n<line35>if (n_groups < 0)\n<line36>{\n<line37>if (username)\n<line38>error (0, errno, _("failed to get groups for user %s"),\n<line39>quote (username));\n<line40>else\n<line41>error (0, errno, _("failed to get groups for the current process"));\n<line42>ok &= false;\n<line43>return;\n<line44>}\n<line45>if (n_groups > 0)\n<line46>fputs (_(" groups="), stdout);\n<line47>for (int i = 0; i < n_groups; i++)\n<line48>{\n<line49>if (i > 0)\n<line50>putchar (',');\n<line51>fputs (gidtostr (groups[i]), stdout);\n<line52>grp = getgrgid (groups[i]);\n<line53>if (grp)\n<line54>printf ("(%s)", grp->gr_name);\n<line55>}\n<line56>free (groups);\n<line57>}\n<line58>/* POSIX mandates the precise output format, and that it not include\n<line59>any context=... part, so skip that if POSIXLY_CORRECT is set.  */\n<line60>if (context)\n<line61>printf (_(" context=%s"), context);\n<line62>}
----------------------------------------
Function: print_stuff
Content: <line0>static void\n<line1>print_stuff (char const *pw_name)\n<line2>{\n<line3>if (just_user)\n<line4>print_user (use_real ? ruid : euid);\n<line5>/* print_group and print_group_list return true on successful\n<line6>execution but false if something goes wrong. We then AND this value with\n<line7>the current value of 'ok' because we want to know if one of the previous\n<line8>users faced a problem in these functions. This value of 'ok' is later used\n<line9>to understand what status program should exit with. */\n<line10>else if (just_group)\n<line11>ok &= print_group (use_real ? rgid : egid, use_name);\n<line12>else if (just_group_list)\n<line13>ok &= print_group_list (pw_name, ruid, rgid, egid,\n<line14>use_name, opt_zero ? '\0' : ' ');\n<line15>else if (just_context)\n<line16>fputs (context, stdout);\n<line17>else\n<line18>print_full_info (pw_name);\n<line19>/* When printing records for more than 1 user, at the end of groups\n<line20>of each user terminate the record with two consequent NUL characters\n<line21>to make parsing and distinguishing between two records possible. */\n<line22>if (opt_zero && just_group_list && multiple_users)\n<line23>{\n<line24>putchar ('\0');\n<line25>putchar ('\0');\n<line26>}\n<line27>else\n<line28>{\n<line29>putchar (opt_zero ? '\0' : '\n');\n<line30>}\n<line31>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/src/join.c
========================================
Function: usage
Content: <line0>void\n<line1>usage (int status)\n<line2>{\n<line3>if (status != EXIT_SUCCESS)\n<line4>emit_try_help ();\n<line5>else\n<line6>{\n<line7>printf (_("\\n<line8>Usage: %s [OPTION]... FILE1 FILE2\n\\n<line9>"),\n<line10>program_name);\n<line11>fputs (_("\\n<line12>For each pair of input lines with identical join fields, write a line to\n\\n<line13>standard output.  The default join field is the first, delimited by blanks.\\n<line14>\n\\n<line15>"), stdout);\n<line16>fputs (_("\\n<line17>\n\\n<line18>When FILE1 or FILE2 (not both) is -, read standard input.\n\\n<line19>"), stdout);\n<line20>fputs (_("\\n<line21>\n\\n<line22>-a FILENUM             also print unpairable lines from file FILENUM, where\n\\n<line23>FILENUM is 1 or 2, corresponding to FILE1 or FILE2\n\\n<line24>"), stdout);\n<line25>fputs (_("\\n<line26>-e STRING              replace missing (empty) input fields with STRING;\n\\n<line27>I.e., missing fields specified with '-12jo' options\\n<line28>\n\\n<line29>"), stdout);\n<line30>fputs (_("\\n<line31>-i, --ignore-case      ignore differences in case when comparing fields\n\\n<line32>-j FIELD               equivalent to '-1 FIELD -2 FIELD'\n\\n<line33>-o FORMAT              obey FORMAT while constructing output line\n\\n<line34>-t CHAR                use CHAR as input and output field separator\n\\n<line35>"), stdout);\n<line36>fputs (_("\\n<line37>-v FILENUM             like -a FILENUM, but suppress joined output lines\n\\n<line38>-1 FIELD               join on this FIELD of file 1\n\\n<line39>-2 FIELD               join on this FIELD of file 2\n\\n<line40>--check-order      check that the input is correctly sorted, even\n\\n<line41>if all input lines are pairable\n\\n<line42>--nocheck-order    do not check that the input is correctly sorted\n\\n<line43>--header           treat the first line in each file as field headers,\n\\n<line44>print them without trying to pair them\n\\n<line45>"), stdout);\n<line46>fputs (_("\\n<line47>-z, --zero-terminated  line delimiter is NUL, not newline\n\\n<line48>"), stdout);\n<line49>fputs (HELP_OPTION_DESCRIPTION, stdout);\n<line50>fputs (VERSION_OPTION_DESCRIPTION, stdout);\n<line51>fputs (_("\\n<line52>\n\\n<line53>Unless -t CHAR is given, leading blanks separate fields and are ignored,\n\\n<line54>else fields are separated by CHAR.  Any FIELD is a field number counted\n\\n<line55>from 1.  FORMAT is one or more comma or blank separated specifications,\n\\n<line56>each being 'FILENUM.FIELD' or '0'.  Default FORMAT outputs the join field,\n\\n<line57>the remaining fields from FILE1, the remaining fields from FILE2, all\n\\n<line58>separated by CHAR.  If FORMAT is the keyword 'auto', then the first\n\\n<line59>line of each file determines the number of fields output for each line.\n\\n<line60>\n\\n<line61>Important: FILE1 and FILE2 must be sorted on the join fields.\n\\n<line62>E.g., use \"sort -k 1b,1\" if 'join' has no options,\n\\n<line63>or use \"join -t ''\" if 'sort' has no options.\n\\n<line64>Note, comparisons honor the rules specified by 'LC_COLLATE'.\n\\n<line65>If the input is not sorted and some lines cannot be joined, a\n\\n<line66>warning message will be given.\n\\n<line67>"), stdout);\n<line68>emit_ancillary_info (PROGRAM_NAME);\n<line69>}\n<line70>exit (status);\n<line71>}
----------------------------------------
Function: extract_field
Content: <line0>static void\n<line1>extract_field (struct line *line, char *field, idx_t len)\n<line2>{\n<line3>if (line->nfields >= line->nfields_allocated)\n<line4>line->fields = xpalloc (line->fields, &line->nfields_allocated, 1,\n<line5>-1, sizeof *line->fields);\n<line6>line->fields[line->nfields].beg = field;\n<line7>line->fields[line->nfields].len = len;\n<line8>++(line->nfields);\n<line9>}
----------------------------------------
Function: xfields
Content: <line0>static void\n<line1>xfields (struct line *line)\n<line2>{\n<line3>char *ptr = line->buf.buffer;\n<line4>char const *lim = ptr + line->buf.length - 1;\n<line5>if (ptr == lim)\n<line6>return;\n<line7>if (0 <= tab && tab != '\n')\n<line8>{\n<line9>char *sep;\n<line10>for (; (sep = memchr (ptr, tab, lim - ptr)) != nullptr; ptr = sep + 1)\n<line11>extract_field (line, ptr, sep - ptr);\n<line12>}\n<line13>else if (tab < 0)\n<line14>{\n<line15>/* Skip leading blanks before the first field.  */\n<line16>while (field_sep (*ptr))\n<line17>if (++ptr == lim)\n<line18>return;\n<line19>do\n<line20>{\n<line21>char *sep;\n<line22>for (sep = ptr + 1; sep != lim && ! field_sep (*sep); sep++)\n<line23>continue;\n<line24>extract_field (line, ptr, sep - ptr);\n<line25>if (sep == lim)\n<line26>return;\n<line27>for (ptr = sep + 1; ptr != lim && field_sep (*ptr); ptr++)\n<line28>continue;\n<line29>}\n<line30>while (ptr != lim);\n<line31>}\n<line32>extract_field (line, ptr, lim - ptr);\n<line33>}
----------------------------------------
Function: freeline
Content: <line0>static void\n<line1>freeline (struct line *line)\n<line2>{\n<line3>if (line == nullptr)\n<line4>return;\n<line5>free (line->fields);\n<line6>line->fields = nullptr;\n<line7>free (line->buf.buffer);\n<line8>line->buf.buffer = nullptr;\n<line9>}
----------------------------------------
Function: keycmp
Content: <line0>static int\n<line1>keycmp (struct line const *line1, struct line const *line2,\n<line2>idx_t jf_1, idx_t jf_2)\n<line3>{\n<line4>/* Start of field to compare in each file.  */\n<line5>char *beg1;\n<line6>char *beg2;\n<line7>idx_t len1;\n<line8>idx_t len2;		/* Length of fields to compare.  */\n<line9>int diff;\n<line10>if (jf_1 < line1->nfields)\n<line11>{\n<line12>beg1 = line1->fields[jf_1].beg;\n<line13>len1 = line1->fields[jf_1].len;\n<line14>}\n<line15>else\n<line16>{\n<line17>beg1 = nullptr;\n<line18>len1 = 0;\n<line19>}\n<line20>if (jf_2 < line2->nfields)\n<line21>{\n<line22>beg2 = line2->fields[jf_2].beg;\n<line23>len2 = line2->fields[jf_2].len;\n<line24>}\n<line25>else\n<line26>{\n<line27>beg2 = nullptr;\n<line28>len2 = 0;\n<line29>}\n<line30>if (len1 == 0)\n<line31>return len2 == 0 ? 0 : -1;\n<line32>if (len2 == 0)\n<line33>return 1;\n<line34>if (ignore_case)\n<line35>{\n<line36>/* FIXME: ignore_case does not work with NLS (in particular,\n<line37>with multibyte chars).  */\n<line38>diff = memcasecmp (beg1, beg2, MIN (len1, len2));\n<line39>}\n<line40>else\n<line41>{\n<line42>if (hard_LC_COLLATE)\n<line43>return xmemcoll (beg1, len1, beg2, len2);\n<line44>diff = memcmp (beg1, beg2, MIN (len1, len2));\n<line45>}\n<line46>if (diff)\n<line47>return diff;\n<line48>return (len1 > len2) - (len1 < len2);\n<line49>}
----------------------------------------
Function: check_order
Content: <line0>static void\n<line1>check_order (const struct line *prev,\n<line2>const struct line *current,\n<line3>int whatfile)\n<line4>{\n<line5>if (check_input_order != CHECK_ORDER_DISABLED\n<line6>&& ((check_input_order == CHECK_ORDER_ENABLED) || seen_unpairable))\n<line7>{\n<line8>if (!issued_disorder_warning[whatfile - 1])\n<line9>{\n<line10>idx_t join_field = whatfile == 1 ? join_field_1 : join_field_2;\n<line11>if (keycmp (prev, current, join_field, join_field) > 0)\n<line12>{\n<line13>/* Exclude any trailing newline. */\n<line14>idx_t len = current->buf.length;\n<line15>if (0 < len && current->buf.buffer[len - 1] == '\n')\n<line16>--len;\n<line17>/* If the offending line is longer than INT_MAX, output\n<line18>only the first INT_MAX bytes in this diagnostic.  */\n<line19>len = MIN (INT_MAX, len);\n<line20>error ((check_input_order == CHECK_ORDER_ENABLED\n<line21>? EXIT_FAILURE : 0),\n<line22>0, _("%s:%"PRIuMAX": is not sorted: %.*s"),\n<line23>g_names[whatfile - 1], line_no[whatfile - 1],\n<line24>(int) len, current->buf.buffer);\n<line25>/* If we get to here, the message was merely a warning.\n<line26>Arrange to issue it only once per file.  */\n<line27>issued_disorder_warning[whatfile - 1] = true;\n<line28>}\n<line29>}\n<line30>}\n<line31>}
----------------------------------------
Function: reset_line
Content: <line0>static inline void\n<line1>reset_line (struct line *line)\n<line2>{\n<line3>line->nfields = 0;\n<line4>}
----------------------------------------
Function: init_linep
Content: <line0>static struct line *\n<line1>init_linep (struct line **linep)\n<line2>{\n<line3>struct line *line = xzalloc (sizeof *line);\n<line4>*linep = line;\n<line5>return line;\n<line6>}
----------------------------------------
Function: get_line
Content: <line0>static bool\n<line1>get_line (FILE *fp, struct line **linep, int which)\n<line2>{\n<line3>struct line *line = *linep;\n<line4>if (line == prevline[which - 1])\n<line5>{\n<line6>SWAPLINES (line, spareline[which - 1]);\n<line7>*linep = line;\n<line8>}\n<line9>if (line)\n<line10>reset_line (line);\n<line11>else\n<line12>line = init_linep (linep);\n<line13>if (! readlinebuffer_delim (&line->buf, fp, eolchar))\n<line14>{\n<line15>if (ferror (fp))\n<line16>error (EXIT_FAILURE, errno, _("read error"));\n<line17>freeline (line);\n<line18>return false;\n<line19>}\n<line20>++line_no[which - 1];\n<line21>xfields (line);\n<line22>if (prevline[which - 1])\n<line23>check_order (prevline[which - 1], line, which);\n<line24>prevline[which - 1] = line;\n<line25>return true;\n<line26>}
----------------------------------------
Function: free_spareline
Content: <line0>static void\n<line1>free_spareline (void)\n<line2>{\n<line3>for (idx_t i = 0; i < ARRAY_CARDINALITY (spareline); i++)\n<line4>{\n<line5>if (spareline[i])\n<line6>{\n<line7>freeline (spareline[i]);\n<line8>free (spareline[i]);\n<line9>}\n<line10>}\n<line11>}
----------------------------------------
Function: initseq
Content: <line0>static void\n<line1>initseq (struct seq *seq)\n<line2>{\n<line3>seq->count = 0;\n<line4>seq->alloc = 0;\n<line5>seq->lines = nullptr;\n<line6>}
----------------------------------------
Function: getseq
Content: <line0>static bool\n<line1>getseq (FILE *fp, struct seq *seq, int whichfile)\n<line2>{\n<line3>if (seq->count == seq->alloc)\n<line4>{\n<line5>seq->lines = xpalloc (seq->lines, &seq->alloc, 1, -1, sizeof *seq->lines);\n<line6>for (idx_t i = seq->count; i < seq->alloc; i++)\n<line7>seq->lines[i] = nullptr;\n<line8>}\n<line9>if (get_line (fp, &seq->lines[seq->count], whichfile))\n<line10>{\n<line11>++seq->count;\n<line12>return true;\n<line13>}\n<line14>return false;\n<line15>}
----------------------------------------
Function: advance_seq
Content: <line0>static bool\n<line1>advance_seq (FILE *fp, struct seq *seq, bool first, int whichfile)\n<line2>{\n<line3>if (first)\n<line4>seq->count = 0;\n<line5>return getseq (fp, seq, whichfile);\n<line6>}
----------------------------------------
Function: delseq
Content: <line0>static void\n<line1>delseq (struct seq *seq)\n<line2>{\n<line3>for (idx_t i = 0; i < seq->alloc; i++)\n<line4>{\n<line5>freeline (seq->lines[i]);\n<line6>free (seq->lines[i]);\n<line7>}\n<line8>free (seq->lines);\n<line9>}
----------------------------------------
Function: prfield
Content: <line0>static void\n<line1>prfield (idx_t n, struct line const *line)\n<line2>{\n<line3>if (n < line->nfields)\n<line4>{\n<line5>idx_t len = line->fields[n].len;\n<line6>if (len)\n<line7>fwrite (line->fields[n].beg, 1, len, stdout);\n<line8>else if (empty_filler)\n<line9>fputs (empty_filler, stdout);\n<line10>}\n<line11>else if (empty_filler)\n<line12>fputs (empty_filler, stdout);\n<line13>}
----------------------------------------
Function: prfields
Content: <line0>static void\n<line1>prfields (struct line const *line, idx_t join_field, idx_t autocount)\n<line2>{\n<line3>idx_t i;\n<line4>idx_t nfields = autoformat ? autocount : line->nfields;\n<line5>char output_separator = tab < 0 ? ' ' : tab;\n<line6>for (i = 0; i < join_field && i < nfields; ++i)\n<line7>{\n<line8>putchar (output_separator);\n<line9>prfield (i, line);\n<line10>}\n<line11>for (i = join_field + 1; i < nfields; ++i)\n<line12>{\n<line13>putchar (output_separator);\n<line14>prfield (i, line);\n<line15>}\n<line16>}
----------------------------------------
Function: prjoin
Content: <line0>static void\n<line1>prjoin (struct line const *line1, struct line const *line2)\n<line2>{\n<line3>const struct outlist *outlist;\n<line4>char output_separator = tab < 0 ? ' ' : tab;\n<line5>idx_t field;\n<line6>struct line const *line;\n<line7>outlist = outlist_head.next;\n<line8>if (outlist)\n<line9>{\n<line10>const struct outlist *o;\n<line11>o = outlist;\n<line12>while (true)\n<line13>{\n<line14>if (o->file == 0)\n<line15>{\n<line16>if (line1 == &uni_blank)\n<line17>{\n<line18>line = line2;\n<line19>field = join_field_2;\n<line20>}\n<line21>else\n<line22>{\n<line23>line = line1;\n<line24>field = join_field_1;\n<line25>}\n<line26>}\n<line27>else\n<line28>{\n<line29>line = (o->file == 1 ? line1 : line2);\n<line30>field = o->field;\n<line31>}\n<line32>prfield (field, line);\n<line33>o = o->next;\n<line34>if (o == nullptr)\n<line35>break;\n<line36>putchar (output_separator);\n<line37>}\n<line38>putchar (eolchar);\n<line39>}\n<line40>else\n<line41>{\n<line42>if (line1 == &uni_blank)\n<line43>{\n<line44>line = line2;\n<line45>field = join_field_2;\n<line46>}\n<line47>else\n<line48>{\n<line49>line = line1;\n<line50>field = join_field_1;\n<line51>}\n<line52>/* Output the join field.  */\n<line53>prfield (field, line);\n<line54>/* Output other fields.  */\n<line55>prfields (line1, join_field_1, autocount_1);\n<line56>prfields (line2, join_field_2, autocount_2);\n<line57>putchar (eolchar);\n<line58>}\n<line59>if (ferror (stdout))\n<line60>write_error ();\n<line61>}
----------------------------------------
Function: system_join
Content: <line0>static void\n<line1>join (FILE *fp1, FILE *fp2)\n<line2>{\n<line3>struct seq seq1, seq2;\n<line4>int diff;\n<line5>bool eof1, eof2;\n<line6>fadvise (fp1, FADVISE_SEQUENTIAL);\n<line7>fadvise (fp2, FADVISE_SEQUENTIAL);\n<line8>/* Read the first line of each file.  */\n<line9>initseq (&seq1);\n<line10>getseq (fp1, &seq1, 1);\n<line11>initseq (&seq2);\n<line12>getseq (fp2, &seq2, 2);\n<line13>if (autoformat)\n<line14>{\n<line15>autocount_1 = seq1.count ? seq1.lines[0]->nfields : 0;\n<line16>autocount_2 = seq2.count ? seq2.lines[0]->nfields : 0;\n<line17>}\n<line18>if (join_header_lines && (seq1.count || seq2.count))\n<line19>{\n<line20>struct line const *hline1 = seq1.count ? seq1.lines[0] : &uni_blank;\n<line21>struct line const *hline2 = seq2.count ? seq2.lines[0] : &uni_blank;\n<line22>prjoin (hline1, hline2);\n<line23>prevline[0] = nullptr;\n<line24>prevline[1] = nullptr;\n<line25>if (seq1.count)\n<line26>advance_seq (fp1, &seq1, true, 1);\n<line27>if (seq2.count)\n<line28>advance_seq (fp2, &seq2, true, 2);\n<line29>}\n<line30>while (seq1.count && seq2.count)\n<line31>{\n<line32>diff = keycmp (seq1.lines[0], seq2.lines[0],\n<line33>join_field_1, join_field_2);\n<line34>if (diff < 0)\n<line35>{\n<line36>if (print_unpairables_1)\n<line37>prjoin (seq1.lines[0], &uni_blank);\n<line38>advance_seq (fp1, &seq1, true, 1);\n<line39>seen_unpairable = true;\n<line40>continue;\n<line41>}\n<line42>if (diff > 0)\n<line43>{\n<line44>if (print_unpairables_2)\n<line45>prjoin (&uni_blank, seq2.lines[0]);\n<line46>advance_seq (fp2, &seq2, true, 2);\n<line47>seen_unpairable = true;\n<line48>continue;\n<line49>}\n<line50>/* Keep reading lines from file1 as long as they continue to\n<line51>match the current line from file2.  */\n<line52>eof1 = false;\n<line53>do\n<line54>if (!advance_seq (fp1, &seq1, false, 1))\n<line55>{\n<line56>eof1 = true;\n<line57>++seq1.count;\n<line58>break;\n<line59>}\n<line60>while (!keycmp (seq1.lines[seq1.count - 1], seq2.lines[0],\n<line61>join_field_1, join_field_2));\n<line62>/* Keep reading lines from file2 as long as they continue to\n<line63>match the current line from file1.  */\n<line64>eof2 = false;\n<line65>do\n<line66>if (!advance_seq (fp2, &seq2, false, 2))\n<line67>{\n<line68>eof2 = true;\n<line69>++seq2.count;\n<line70>break;\n<line71>}\n<line72>while (!keycmp (seq1.lines[0], seq2.lines[seq2.count - 1],\n<line73>join_field_1, join_field_2));\n<line74>if (print_pairables)\n<line75>{\n<line76>for (idx_t i = 0; i < seq1.count - 1; ++i)\n<line77>{\n<line78>idx_t j;\n<line79>for (j = 0; j < seq2.count - 1; ++j)\n<line80>prjoin (seq1.lines[i], seq2.lines[j]);\n<line81>}\n<line82>}\n<line83>if (!eof1)\n<line84>{\n<line85>SWAPLINES (seq1.lines[0], seq1.lines[seq1.count - 1]);\n<line86>seq1.count = 1;\n<line87>}\n<line88>else\n<line89>seq1.count = 0;\n<line90>if (!eof2)\n<line91>{\n<line92>SWAPLINES (seq2.lines[0], seq2.lines[seq2.count - 1]);\n<line93>seq2.count = 1;\n<line94>}\n<line95>else\n<line96>seq2.count = 0;\n<line97>}\n<line98>/* If the user did not specify --nocheck-order, then we read the\n<line99>tail ends of both inputs to verify that they are in order.  We\n<line100>skip the rest of the tail once we have issued a warning for that\n<line101>file, unless we actually need to print the unpairable lines.  */\n<line102>struct line *line = nullptr;\n<line103>bool checktail = false;\n<line104>if (check_input_order != CHECK_ORDER_DISABLED\n<line105>&& !(issued_disorder_warning[0] && issued_disorder_warning[1]))\n<line106>checktail = true;\n<line107>if ((print_unpairables_1 || checktail) && seq1.count)\n<line108>{\n<line109>if (print_unpairables_1)\n<line110>prjoin (seq1.lines[0], &uni_blank);\n<line111>if (seq2.count)\n<line112>seen_unpairable = true;\n<line113>while (get_line (fp1, &line, 1))\n<line114>{\n<line115>if (print_unpairables_1)\n<line116>prjoin (line, &uni_blank);\n<line117>if (issued_disorder_warning[0] && !print_unpairables_1)\n<line118>break;\n<line119>}\n<line120>}\n<line121>if ((print_unpairables_2 || checktail) && seq2.count)\n<line122>{\n<line123>if (print_unpairables_2)\n<line124>prjoin (&uni_blank, seq2.lines[0]);\n<line125>if (seq1.count)\n<line126>seen_unpairable = true;\n<line127>while (get_line (fp2, &line, 2))\n<line128>{\n<line129>if (print_unpairables_2)\n<line130>prjoin (&uni_blank, line);\n<line131>if (issued_disorder_warning[1] && !print_unpairables_2)\n<line132>break;\n<line133>}\n<line134>}\n<line135>freeline (line);\n<line136>free (line);\n<line137>delseq (&seq1);\n<line138>delseq (&seq2);\n<line139>}
----------------------------------------
Function: add_field
Content: <line0>static void\n<line1>add_field (int file, idx_t field)\n<line2>{\n<line3>struct outlist *o;\n<line4>affirm (file == 0 || file == 1 || file == 2);\n<line5>affirm (file != 0 || field == 0);\n<line6>o = xmalloc (sizeof *o);\n<line7>o->file = file;\n<line8>o->field = field;\n<line9>o->next = nullptr;\n<line10>/* Add to the end of the list so the fields are in the right order.  */\n<line11>outlist_end->next = o;\n<line12>outlist_end = o;\n<line13>}
----------------------------------------
Function: string_to_join_field
Content: <line0>static idx_t\n<line1>string_to_join_field (char const *str)\n<line2>{\n<line3>intmax_t val;\n<line4>strtol_error s_err = xstrtoimax (str, nullptr, 10, &val, "");\n<line5>if (s_err == LONGINT_OVERFLOW || (s_err == LONGINT_OK && PTRDIFF_MAX < val))\n<line6>val = PTRDIFF_MAX;\n<line7>else if (s_err != LONGINT_OK || val <= 0)\n<line8>error (EXIT_FAILURE, 0, _("invalid field number: %s"), quote (str));\n<line9>return val - 1;\n<line10>}
----------------------------------------
Function: decode_field_spec
Content: <line0>static void\n<line1>decode_field_spec (char const *s, int *file_index, idx_t *field_index)\n<line2>{\n<line3>/* The first character must be 0, 1, or 2.  */\n<line4>switch (s[0])\n<line5>{\n<line6>case '0':\n<line7>if (s[1])\n<line8>{\n<line9>/* '0' must be all alone -- no '.FIELD'.  */\n<line10>error (EXIT_FAILURE, 0, _("invalid field specifier: %s"), quote (s));\n<line11>}\n<line12>*file_index = 0;\n<line13>*field_index = 0;\n<line14>break;\n<line15>case '1':\n<line16>case '2':\n<line17>if (s[1] != '.')\n<line18>error (EXIT_FAILURE, 0, _("invalid field specifier: %s"), quote (s));\n<line19>*file_index = s[0] - '0';\n<line20>*field_index = string_to_join_field (s + 2);\n<line21>break;\n<line22>default:\n<line23>error (EXIT_FAILURE, 0,\n<line24>_("invalid file number in field spec: %s"), quote (s));\n<line25>}\n<line26>}
----------------------------------------
Function: add_field_list
Content: <line0>static void\n<line1>add_field_list (char *str)\n<line2>{\n<line3>char *p = str;\n<line4>do\n<line5>{\n<line6>int file_index;\n<line7>idx_t field_index;\n<line8>char const *spec_item = p;\n<line9>p = strpbrk (p, ", \t");\n<line10>if (p)\n<line11>*p++ = '\0';\n<line12>decode_field_spec (spec_item, &file_index, &field_index);\n<line13>add_field (file_index, field_index);\n<line14>}\n<line15>while (p);\n<line16>}
----------------------------------------
Function: set_join_field
Content: <line0>static void\n<line1>set_join_field (ptrdiff_t *var, idx_t val)\n<line2>{\n<line3>if (0 <= *var && *var != val)\n<line4>error (EXIT_FAILURE, 0,\n<line5>_("incompatible join fields %td, %td"), *var, val);\n<line6>*var = val;\n<line7>}
----------------------------------------
Function: add_file_name
Content: <line0>static void\n<line1>add_file_name (char *name, char *names[2],\n<line2>int operand_status[2], int joption_count[2], int *nfiles,\n<line3>int *prev_optc_status, int *optc_status)\n<line4>{\n<line5>int n = *nfiles;\n<line6>if (n == 2)\n<line7>{\n<line8>bool op0 = (operand_status[0] == MUST_BE_OPERAND);\n<line9>char *arg = names[op0];\n<line10>switch (operand_status[op0])\n<line11>{\n<line12>case MUST_BE_OPERAND:\n<line13>error (0, 0, _("extra operand %s"), quoteaf (name));\n<line14>usage (EXIT_FAILURE);\n<line15>case MIGHT_BE_J1_ARG:\n<line16>joption_count[0]--;\n<line17>set_join_field (&join_field_1, string_to_join_field (arg));\n<line18>break;\n<line19>case MIGHT_BE_J2_ARG:\n<line20>joption_count[1]--;\n<line21>set_join_field (&join_field_2, string_to_join_field (arg));\n<line22>break;\n<line23>case MIGHT_BE_O_ARG:\n<line24>add_field_list (arg);\n<line25>break;\n<line26>}\n<line27>if (!op0)\n<line28>{\n<line29>operand_status[0] = operand_status[1];\n<line30>names[0] = names[1];\n<line31>}\n<line32>n = 1;\n<line33>}\n<line34>operand_status[n] = *prev_optc_status;\n<line35>names[n] = name;\n<line36>*nfiles = n + 1;\n<line37>if (*prev_optc_status == MIGHT_BE_O_ARG)\n<line38>*optc_status = MIGHT_BE_O_ARG;\n<line39>}
----------------------------------------
Function: main
Content: <line0>int\n<line1>main (int argc, char **argv)\n<line2>{\n<line3>int optc_status;\n<line4>int prev_optc_status = MUST_BE_OPERAND;\n<line5>int operand_status[2];\n<line6>int joption_count[2] = { 0, 0 };\n<line7>FILE *fp1, *fp2;\n<line8>int optc;\n<line9>int nfiles = 0;\n<line10>int i;\n<line11>initialize_main (&argc, &argv);\n<line12>set_program_name (argv[0]);\n<line13>setlocale (LC_ALL, "");\n<line14>bindtextdomain (PACKAGE, LOCALEDIR);\n<line15>textdomain (PACKAGE);\n<line16>hard_LC_COLLATE = hard_locale (LC_COLLATE);\n<line17>atexit (close_stdout);\n<line18>atexit (free_spareline);\n<line19>print_pairables = true;\n<line20>seen_unpairable = false;\n<line21>issued_disorder_warning[0] = issued_disorder_warning[1] = false;\n<line22>check_input_order = CHECK_ORDER_DEFAULT;\n<line23>while ((optc = getopt_long (argc, argv, "-a:e:i1:2:j:o:t:v:z",\n<line24>longopts, nullptr))\n<line25>!= -1)\n<line26>{\n<line27>optc_status = MUST_BE_OPERAND;\n<line28>switch (optc)\n<line29>{\n<line30>case 'v':\n<line31>print_pairables = false;\n<line32>FALLTHROUGH;\n<line33>case 'a':\n<line34>{\n<line35>long int val;\n<line36>if (xstrtol (optarg, nullptr, 10, &val, "") != LONGINT_OK\n<line37>|| (val != 1 && val != 2))\n<line38>error (EXIT_FAILURE, 0,\n<line39>_("invalid field number: %s"), quote (optarg));\n<line40>if (val == 1)\n<line41>print_unpairables_1 = true;\n<line42>else\n<line43>print_unpairables_2 = true;\n<line44>}\n<line45>break;\n<line46>case 'e':\n<line47>if (empty_filler && ! STREQ (empty_filler, optarg))\n<line48>error (EXIT_FAILURE, 0,\n<line49>_("conflicting empty-field replacement strings"));\n<line50>empty_filler = optarg;\n<line51>break;\n<line52>case 'i':\n<line53>ignore_case = true;\n<line54>break;\n<line55>case '1':\n<line56>set_join_field (&join_field_1, string_to_join_field (optarg));\n<line57>break;\n<line58>case '2':\n<line59>set_join_field (&join_field_2, string_to_join_field (optarg));\n<line60>break;\n<line61>case 'j':\n<line62>if ((optarg[0] == '1' || optarg[0] == '2') && !optarg[1]\n<line63>&& optarg == argv[optind - 1] + 2)\n<line64>{\n<line65>/* The argument was either "-j1" or "-j2".  */\n<line66>bool is_j2 = (optarg[0] == '2');\n<line67>joption_count[is_j2]++;\n<line68>optc_status = MIGHT_BE_J1_ARG + is_j2;\n<line69>}\n<line70>else\n<line71>{\n<line72>set_join_field (&join_field_1, string_to_join_field (optarg));\n<line73>set_join_field (&join_field_2, join_field_1);\n<line74>}\n<line75>break;\n<line76>case 'o':\n<line77>if (STREQ (optarg, "auto"))\n<line78>autoformat = true;\n<line79>else\n<line80>{\n<line81>add_field_list (optarg);\n<line82>optc_status = MIGHT_BE_O_ARG;\n<line83>}\n<line84>break;\n<line85>case 't':\n<line86>{\n<line87>unsigned char newtab = optarg[0];\n<line88>if (! newtab)\n<line89>newtab = '\n'; /* '' => process the whole line.  */\n<line90>else if (optarg[1])\n<line91>{\n<line92>if (STREQ (optarg, "\\0"))\n<line93>newtab = '\0';\n<line94>else\n<line95>error (EXIT_FAILURE, 0, _("multi-character tab %s"),\n<line96>quote (optarg));\n<line97>}\n<line98>if (0 <= tab && tab != newtab)\n<line99>error (EXIT_FAILURE, 0, _("incompatible tabs"));\n<line100>tab = newtab;\n<line101>}\n<line102>break;\n<line103>case 'z':\n<line104>eolchar = 0;\n<line105>break;\n<line106>case NOCHECK_ORDER_OPTION:\n<line107>check_input_order = CHECK_ORDER_DISABLED;\n<line108>break;\n<line109>case CHECK_ORDER_OPTION:\n<line110>check_input_order = CHECK_ORDER_ENABLED;\n<line111>break;\n<line112>case 1:		/* Non-option argument.  */\n<line113>add_file_name (optarg, g_names, operand_status, joption_count,\n<line114>&nfiles, &prev_optc_status, &optc_status);\n<line115>break;\n<line116>case HEADER_LINE_OPTION:\n<line117>join_header_lines = true;\n<line118>break;\n<line119>case_GETOPT_HELP_CHAR;\n<line120>case_GETOPT_VERSION_CHAR (PROGRAM_NAME, AUTHORS);\n<line121>default:\n<line122>usage (EXIT_FAILURE);\n<line123>}\n<line124>prev_optc_status = optc_status;\n<line125>}\n<line126>/* Process any operands after "--".  */\n<line127>prev_optc_status = MUST_BE_OPERAND;\n<line128>while (optind < argc)\n<line129>add_file_name (argv[optind++], g_names, operand_status, joption_count,\n<line130>&nfiles, &prev_optc_status, &optc_status);\n<line131>if (nfiles != 2)\n<line132>{\n<line133>if (nfiles == 0)\n<line134>error (0, 0, _("missing operand"));\n<line135>else\n<line136>error (0, 0, _("missing operand after %s"), quote (argv[argc - 1]));\n<line137>usage (EXIT_FAILURE);\n<line138>}\n<line139>/* If "-j1" was specified and it turns out not to have had an argument,\n<line140>treat it as "-j 1".  Likewise for -j2.  */\n<line141>for (i = 0; i < 2; i++)\n<line142>if (joption_count[i] != 0)\n<line143>{\n<line144>set_join_field (&join_field_1, i);\n<line145>set_join_field (&join_field_2, i);\n<line146>}\n<line147>if (join_field_1 < 0)\n<line148>join_field_1 = 0;\n<line149>if (join_field_2 < 0)\n<line150>join_field_2 = 0;\n<line151>fp1 = STREQ (g_names[0], "-") ? stdin : fopen (g_names[0], "r");\n<line152>if (!fp1)\n<line153>error (EXIT_FAILURE, errno, "%s", quotef (g_names[0]));\n<line154>fp2 = STREQ (g_names[1], "-") ? stdin : fopen (g_names[1], "r");\n<line155>if (!fp2)\n<line156>error (EXIT_FAILURE, errno, "%s", quotef (g_names[1]));\n<line157>if (fp1 == fp2)\n<line158>error (EXIT_FAILURE, errno, _("both files cannot be standard input"));\n<line159>join (fp1, fp2);\n<line160>if (fclose (fp1) != 0)\n<line161>error (EXIT_FAILURE, errno, "%s", quotef (g_names[0]));\n<line162>if (fclose (fp2) != 0)\n<line163>error (EXIT_FAILURE, errno, "%s", quotef (g_names[1]));\n<line164>if (issued_disorder_warning[0] || issued_disorder_warning[1])\n<line165>error (EXIT_FAILURE, 0, _("input is not in sorted order"));\n<line166>else\n<line167>return EXIT_SUCCESS;\n<line168>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/src/kill.c
========================================
Function: usage
Content: <line0>void\n<line1>usage (int status)\n<line2>{\n<line3>if (status != EXIT_SUCCESS)\n<line4>emit_try_help ();\n<line5>else\n<line6>{\n<line7>printf (_("\\n<line8>Usage: %s [-s SIGNAL | -SIGNAL] PID...\n\\n<line9>or:  %s -l [SIGNAL]...\n\\n<line10>or:  %s -t [SIGNAL]...\n\\n<line11>"),\n<line12>program_name, program_name, program_name);\n<line13>fputs (_("\\n<line14>Send signals to processes, or list signals.\n\\n<line15>"), stdout);\n<line16>emit_mandatory_arg_note ();\n<line17>fputs (_("\\n<line18>-s, --signal=SIGNAL, -SIGNAL\n\\n<line19>specify the name or number of the signal to be sent\n\\n<line20>-l, --list       list signal names, or convert signal names to/from numbers\n\\n<line21>-t, --table      print a table of signal information\n\\n<line22>"), stdout);\n<line23>fputs (HELP_OPTION_DESCRIPTION, stdout);\n<line24>fputs (VERSION_OPTION_DESCRIPTION, stdout);\n<line25>fputs (_("\n\\n<line26>SIGNAL may be a signal name like 'HUP', or a signal number like '1',\n\\n<line27>or the exit status of a process terminated by a signal.\n\\n<line28>PID is an integer; if negative it identifies a process group.\n\\n<line29>"), stdout);\n<line30>printf (USAGE_BUILTIN_WARNING, PROGRAM_NAME);\n<line31>emit_ancillary_info (PROGRAM_NAME);\n<line32>}\n<line33>exit (status);\n<line34>}
----------------------------------------
Function: print_table_row
Content: <line0>static void\n<line1>print_table_row (int num_width, int signum,\n<line2>int name_width, char const *signame)\n<line3>{\n<line4>char const *description = strsignal (signum);\n<line5>printf ("%*d %-*s %s\n", num_width, signum, name_width, signame,\n<line6>description ? description : "?");\n<line7>}
----------------------------------------
Function: list_signals
Content: <line0>static int\n<line1>list_signals (bool table, char *const *argv)\n<line2>{\n<line3>int signum;\n<line4>int status = EXIT_SUCCESS;\n<line5>char signame[SIG2STR_MAX];\n<line6>if (table)\n<line7>{\n<line8>int name_width = 0;\n<line9>/* Compute the maximum width of a signal number.  */\n<line10>int num_width = 1;\n<line11>for (signum = 1; signum <= SIGNUM_BOUND / 10; signum *= 10)\n<line12>num_width++;\n<line13>/* Compute the maximum width of a signal name.  */\n<line14>for (signum = 1; signum <= SIGNUM_BOUND; signum++)\n<line15>if (sig2str (signum, signame) == 0)\n<line16>{\n<line17>idx_t len = strlen (signame);\n<line18>if (name_width < len)\n<line19>name_width = len;\n<line20>}\n<line21>if (argv)\n<line22>for (; *argv; argv++)\n<line23>{\n<line24>signum = operand2sig (*argv, signame);\n<line25>if (signum < 0)\n<line26>status = EXIT_FAILURE;\n<line27>else\n<line28>print_table_row (num_width, signum, name_width, signame);\n<line29>}\n<line30>else\n<line31>for (signum = 1; signum <= SIGNUM_BOUND; signum++)\n<line32>if (sig2str (signum, signame) == 0)\n<line33>print_table_row (num_width, signum, name_width, signame);\n<line34>}\n<line35>else\n<line36>{\n<line37>if (argv)\n<line38>for (; *argv; argv++)\n<line39>{\n<line40>signum = operand2sig (*argv, signame);\n<line41>if (signum < 0)\n<line42>status = EXIT_FAILURE;\n<line43>else\n<line44>{\n<line45>if (ISDIGIT (**argv))\n<line46>puts (signame);\n<line47>else\n<line48>printf ("%d\n", signum);\n<line49>}\n<line50>}\n<line51>else\n<line52>for (signum = 1; signum <= SIGNUM_BOUND; signum++)\n<line53>if (sig2str (signum, signame) == 0)\n<line54>puts (signame);\n<line55>}\n<line56>return status;\n<line57>}
----------------------------------------
Function: send_signals
Content: <line0>static int\n<line1>send_signals (int signum, char *const *argv)\n<line2>{\n<line3>int status = EXIT_SUCCESS;\n<line4>char const *arg = *argv;\n<line5>do\n<line6>{\n<line7>char *endp;\n<line8>intmax_t n = (errno = 0, strtoimax (arg, &endp, 10));\n<line9>pid_t pid;\n<line10>if (errno == ERANGE || ckd_add (&pid, n, 0)\n<line11>|| arg == endp || *endp)\n<line12>{\n<line13>error (0, 0, _("%s: invalid process id"), quote (arg));\n<line14>status = EXIT_FAILURE;\n<line15>}\n<line16>else if (kill (pid, signum) != 0)\n<line17>{\n<line18>error (0, errno, "%s", quote (arg));\n<line19>status = EXIT_FAILURE;\n<line20>}\n<line21>}\n<line22>while ((arg = *++argv));\n<line23>return status;\n<line24>}
----------------------------------------
Function: main
Content: <line0>int\n<line1>main (int argc, char **argv)\n<line2>{\n<line3>int optc;\n<line4>bool list = false;\n<line5>bool table = false;\n<line6>int signum = -1;\n<line7>char signame[SIG2STR_MAX];\n<line8>initialize_main (&argc, &argv);\n<line9>set_program_name (argv[0]);\n<line10>setlocale (LC_ALL, "");\n<line11>bindtextdomain (PACKAGE, LOCALEDIR);\n<line12>textdomain (PACKAGE);\n<line13>atexit (close_stdout);\n<line14>while ((optc = getopt_long (argc, argv, short_options, long_options, nullptr))\n<line15>!= -1)\n<line16>switch (optc)\n<line17>{\n<line18>case '0': case '1': case '2': case '3': case '4':\n<line19>case '5': case '6': case '7': case '8': case '9':\n<line20>if (optind != 2)\n<line21>{\n<line22>/* This option is actually a process-id.  */\n<line23>optind--;\n<line24>goto no_more_options;\n<line25>}\n<line26>FALLTHROUGH;\n<line27>case 'A': case 'B': case 'C': case 'D': case 'E':\n<line28>case 'F': case 'G': case 'H': case 'I': case 'J':\n<line29>case 'K': /*case 'L':*/ case 'M': case 'N': case 'O':\n<line30>case 'P': case 'Q': case 'R': case 'S': case 'T':\n<line31>case 'U': case 'V': case 'W': case 'X': case 'Y':\n<line32>case 'Z':\n<line33>if (! optarg)\n<line34>optarg = argv[optind - 1] + strlen (argv[optind - 1]);\n<line35>if (optarg != argv[optind - 1] + 2)\n<line36>{\n<line37>error (0, 0, _("invalid option -- %c"), optc);\n<line38>usage (EXIT_FAILURE);\n<line39>}\n<line40>optarg--;\n<line41>FALLTHROUGH;\n<line42>case 'n': /* -n is not documented, but is for Bash compatibility.  */\n<line43>case 's':\n<line44>if (0 <= signum)\n<line45>{\n<line46>error (0, 0, _("%s: multiple signals specified"), quote (optarg));\n<line47>usage (EXIT_FAILURE);\n<line48>}\n<line49>signum = operand2sig (optarg, signame);\n<line50>if (signum < 0)\n<line51>usage (EXIT_FAILURE);\n<line52>break;\n<line53>case 'L': /* -L is not documented, but is for procps compatibility.  */\n<line54>case 't':\n<line55>table = true;\n<line56>FALLTHROUGH;\n<line57>case 'l':\n<line58>if (list)\n<line59>{\n<line60>error (0, 0, _("multiple -l or -t options specified"));\n<line61>usage (EXIT_FAILURE);\n<line62>}\n<line63>list = true;\n<line64>break;\n<line65>case_GETOPT_HELP_CHAR;\n<line66>case_GETOPT_VERSION_CHAR (PROGRAM_NAME, AUTHORS);\n<line67>default:\n<line68>usage (EXIT_FAILURE);\n<line69>}\n<line70>no_more_options:\n<line71>if (signum < 0)\n<line72>signum = SIGTERM;\n<line73>else if (list)\n<line74>{\n<line75>error (0, 0, _("cannot combine signal with -l or -t"));\n<line76>usage (EXIT_FAILURE);\n<line77>}\n<line78>if ( ! list && argc <= optind)\n<line79>{\n<line80>error (0, 0, _("no process ID specified"));\n<line81>usage (EXIT_FAILURE);\n<line82>}\n<line83>return (list\n<line84>? list_signals (table, optind < argc ? argv + optind : nullptr)\n<line85>: send_signals (signum, argv + optind));\n<line86>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/src/link.c
========================================
Function: usage
Content: <line0>void\n<line1>usage (int status)\n<line2>{\n<line3>if (status != EXIT_SUCCESS)\n<line4>emit_try_help ();\n<line5>else\n<line6>{\n<line7>printf (_("\\n<line8>Usage: %s FILE1 FILE2\n\\n<line9>or:  %s OPTION\n"), program_name, program_name);\n<line10>fputs (_("Call the link function to create a link named FILE2\\n<line11>to an existing FILE1.\n\n"),\n<line12>stdout);\n<line13>fputs (HELP_OPTION_DESCRIPTION, stdout);\n<line14>fputs (VERSION_OPTION_DESCRIPTION, stdout);\n<line15>emit_ancillary_info (PROGRAM_NAME);\n<line16>}\n<line17>exit (status);\n<line18>}
----------------------------------------
Function: main
Content: <line0>int\n<line1>main (int argc, char **argv)\n<line2>{\n<line3>initialize_main (&argc, &argv);\n<line4>set_program_name (argv[0]);\n<line5>setlocale (LC_ALL, "");\n<line6>bindtextdomain (PACKAGE, LOCALEDIR);\n<line7>textdomain (PACKAGE);\n<line8>atexit (close_stdout);\n<line9>parse_gnu_standard_options_only (argc, argv, PROGRAM_NAME, PACKAGE_NAME,\n<line10>Version, true, usage, AUTHORS,\n<line11>(char const *) nullptr);\n<line12>if (argc < optind + 2)\n<line13>{\n<line14>if (argc < optind + 1)\n<line15>error (0, 0, _("missing operand"));\n<line16>else\n<line17>error (0, 0, _("missing operand after %s"), quote (argv[optind]));\n<line18>usage (EXIT_FAILURE);\n<line19>}\n<line20>if (optind + 2 < argc)\n<line21>{\n<line22>error (0, 0, _("extra operand %s"), quote (argv[optind + 2]));\n<line23>usage (EXIT_FAILURE);\n<line24>}\n<line25>if (link (argv[optind], argv[optind + 1]) != 0)\n<line26>error (EXIT_FAILURE, errno, _("cannot create link %s to %s"),\n<line27>quoteaf_n (0, argv[optind + 1]), quoteaf_n (1, argv[optind]));\n<line28>return EXIT_SUCCESS;\n<line29>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/src/ln.c
========================================
Function: errnoize
Content: <line0>static int\n<line1>errnoize (int status)\n<line2>{\n<line3>return status < 0 ? errno : 0;\n<line4>}
----------------------------------------
Function: convert_abs_rel
Content: <line0>static char *\n<line1>convert_abs_rel (char const *from, char const *target)\n<line2>{\n<line3>/* Get dirname to generate paths relative to.  We don't resolve\n<line4>the full TARGET as the last component could be an existing symlink.  */\n<line5>char *targetdir = dir_name (target);\n<line6>char *realdest = canonicalize_filename_mode (targetdir, CAN_MISSING);\n<line7>char *realfrom = canonicalize_filename_mode (from, CAN_MISSING);\n<line8>char *relative_from = nullptr;\n<line9>if (realdest && realfrom)\n<line10>{\n<line11>/* Write to a PATH_MAX buffer.  */\n<line12>relative_from = xmalloc (PATH_MAX);\n<line13>if (!relpath (realfrom, realdest, relative_from, PATH_MAX))\n<line14>{\n<line15>free (relative_from);\n<line16>relative_from = nullptr;\n<line17>}\n<line18>}\n<line19>free (targetdir);\n<line20>free (realdest);\n<line21>free (realfrom);\n<line22>return relative_from ? relative_from : xstrdup (from);\n<line23>}
----------------------------------------
Function: atomic_link
Content: <line0>static int\n<line1>atomic_link (char const *source, int destdir_fd, char const *dest_base)\n<line2>{\n<line3>return (symbolic_link\n<line4>? (relative ? -1\n<line5>: errnoize (symlinkat (source, destdir_fd, dest_base)))\n<line6>: beware_hard_dir_link ? -1\n<line7>: errnoize (linkat (AT_FDCWD, source, destdir_fd, dest_base,\n<line8>logical ? AT_SYMLINK_FOLLOW : 0)));\n<line9>}
----------------------------------------
Function: do_link
Content: <line0>static bool\n<line1>do_link (char const *source, int destdir_fd, char const *dest_base,\n<line2>char const *dest, int link_errno)\n<line3>{\n<line4>struct stat source_stats;\n<line5>int source_status = 1;\n<line6>char *backup_base = nullptr;\n<line7>char *rel_source = nullptr;\n<line8>int nofollow_flag = logical ? 0 : AT_SYMLINK_NOFOLLOW;\n<line9>if (link_errno < 0)\n<line10>link_errno = atomic_link (source, destdir_fd, dest_base);\n<line11>/* Get SOURCE_STATS if later code will need it, if only for sharper\n<line12>diagnostics.  */\n<line13>if ((link_errno || dest_set) && !symbolic_link)\n<line14>{\n<line15>source_status = fstatat (AT_FDCWD, source, &source_stats, nofollow_flag);\n<line16>if (source_status != 0)\n<line17>{\n<line18>error (0, errno, _("failed to access %s"), quoteaf (source));\n<line19>return false;\n<line20>}\n<line21>}\n<line22>if (link_errno)\n<line23>{\n<line24>if (!symbolic_link && !hard_dir_link && S_ISDIR (source_stats.st_mode))\n<line25>{\n<line26>error (0, 0, _("%s: hard link not allowed for directory"),\n<line27>quotef (source));\n<line28>return false;\n<line29>}\n<line30>if (relative)\n<line31>source = rel_source = convert_abs_rel (source, dest);\n<line32>bool force = (remove_existing_files || interactive\n<line33>|| backup_type != no_backups);\n<line34>if (force)\n<line35>{\n<line36>struct stat dest_stats;\n<line37>if (fstatat (destdir_fd, dest_base, &dest_stats, AT_SYMLINK_NOFOLLOW)\n<line38>!= 0)\n<line39>{\n<line40>if (errno != ENOENT)\n<line41>{\n<line42>error (0, errno, _("failed to access %s"), quoteaf (dest));\n<line43>goto fail;\n<line44>}\n<line45>force = false;\n<line46>}\n<line47>else if (S_ISDIR (dest_stats.st_mode))\n<line48>{\n<line49>error (0, 0, _("%s: cannot overwrite directory"), quotef (dest));\n<line50>goto fail;\n<line51>}\n<line52>else if (seen_file (dest_set, dest, &dest_stats))\n<line53>{\n<line54>/* The current target was created as a hard link to another\n<line55>source file.  */\n<line56>error (0, 0,\n<line57>_("will not overwrite just-created %s with %s"),\n<line58>quoteaf_n (0, dest), quoteaf_n (1, source));\n<line59>goto fail;\n<line60>}\n<line61>else\n<line62>{\n<line63>/* Beware removing DEST if it is the same directory entry as\n<line64>SOURCE, because in that case removing DEST can cause the\n<line65>subsequent link creation either to fail (for hard links), or\n<line66>to replace a non-symlink DEST with a self-loop (for symbolic\n<line67>links) which loses the contents of DEST.  So, when backing\n<line68>up, worry about creating hard links (since the backups cover\n<line69>the symlink case); otherwise, worry about about -f.  */\n<line70>if (backup_type != no_backups\n<line71>? !symbolic_link\n<line72>: remove_existing_files)\n<line73>{\n<line74>/* Detect whether removing DEST would also remove SOURCE.\n<line75>If the file has only one link then both are surely the\n<line76>same directory entry.  Otherwise check whether they point\n<line77>to the same name in the same directory.  */\n<line78>if (source_status != 0)\n<line79>source_status = stat (source, &source_stats);\n<line80>if (source_status == 0\n<line81>&& SAME_INODE (source_stats, dest_stats)\n<line82>&& (source_stats.st_nlink == 1\n<line83>|| same_nameat (AT_FDCWD, source,\n<line84>destdir_fd, dest_base)))\n<line85>{\n<line86>error (0, 0, _("%s and %s are the same file"),\n<line87>quoteaf_n (0, source), quoteaf_n (1, dest));\n<line88>goto fail;\n<line89>}\n<line90>}\n<line91>if (link_errno < 0 || link_errno == EEXIST)\n<line92>{\n<line93>if (interactive)\n<line94>{\n<line95>fprintf (stderr, _("%s: replace %s? "),\n<line96>program_name, quoteaf (dest));\n<line97>if (!yesno ())\n<line98>{\n<line99>free (rel_source);\n<line100>return false;\n<line101>}\n<line102>}\n<line103>if (backup_type != no_backups)\n<line104>{\n<line105>backup_base = find_backup_file_name (destdir_fd,\n<line106>dest_base,\n<line107>backup_type);\n<line108>if (renameat (destdir_fd, dest_base,\n<line109>destdir_fd, backup_base)\n<line110>!= 0)\n<line111>{\n<line112>int rename_errno = errno;\n<line113>free (backup_base);\n<line114>backup_base = nullptr;\n<line115>if (rename_errno != ENOENT)\n<line116>{\n<line117>error (0, rename_errno, _("cannot backup %s"),\n<line118>quoteaf (dest));\n<line119>goto fail;\n<line120>}\n<line121>force = false;\n<line122>}\n<line123>}\n<line124>}\n<line125>}\n<line126>}\n<line127>/* If the attempt to create a link fails and we are removing or\n<line128>backing up destinations, unlink the destination and try again.\n<line129>On the surface, POSIX states that 'ln -f A B' unlinks B before trying\n<line130>to link A to B.  But strictly following this has the counterintuitive\n<line131>effect of losing the contents of B if A does not exist.  Fortunately,\n<line132>POSIX 2008 clarified that an application is free to fail early if it\n<line133>can prove that continuing onward cannot succeed, so we can try to\n<line134>link A to B before blindly unlinking B, thus sometimes attempting to\n<line135>link a second time during a successful 'ln -f A B'.\n<line136>Try to unlink DEST even if we may have backed it up successfully.\n<line137>In some unusual cases (when DEST and the backup are hard-links\n<line138>that refer to the same file), rename succeeds and DEST remains.\n<line139>If we didn't remove DEST in that case, the subsequent symlink or\n<line140>link call would fail.  */\n<line141>link_errno\n<line142>= (symbolic_link\n<line143>? force_symlinkat (source, destdir_fd, dest_base,\n<line144>force, link_errno)\n<line145>: force_linkat (AT_FDCWD, source, destdir_fd, dest_base,\n<line146>logical ? AT_SYMLINK_FOLLOW : 0,\n<line147>force, link_errno));\n<line148>/* Until now, link_errno < 0 meant the link has not been tried.\n<line149>From here on, link_errno < 0 means the link worked but\n<line150>required removing the destination first.  */\n<line151>}\n<line152>if (link_errno <= 0)\n<line153>{\n<line154>/* Right after creating a hard link, do this: (note dest name and\n<line155>source_stats, which are also the just-linked-destinations stats) */\n<line156>if (! symbolic_link)\n<line157>record_file (dest_set, dest, &source_stats);\n<line158>if (verbose)\n<line159>{\n<line160>char const *quoted_backup = "";\n<line161>char const *backup_sep = "";\n<line162>if (backup_base)\n<line163>{\n<line164>char *backup = backup_base;\n<line165>void *alloc = nullptr;\n<line166>ptrdiff_t destdirlen = dest_base - dest;\n<line167>if (0 < destdirlen)\n<line168>{\n<line169>alloc = xmalloc (destdirlen + strlen (backup_base) + 1);\n<line170>backup = memcpy (alloc, dest, destdirlen);\n<line171>strcpy (backup + destdirlen, backup_base);\n<line172>}\n<line173>quoted_backup = quoteaf_n (2, backup);\n<line174>backup_sep = " ~ ";\n<line175>free (alloc);\n<line176>}\n<line177>printf ("%s%s%s %c> %s\n", quoted_backup, backup_sep,\n<line178>quoteaf_n (0, dest), symbolic_link ? '-' : '=',\n<line179>quoteaf_n (1, source));\n<line180>}\n<line181>}\n<line182>else\n<line183>{\n<line184>error (0, link_errno,\n<line185>(symbolic_link\n<line186>? (link_errno != ENAMETOOLONG && *source\n<line187>? _("failed to create symbolic link %s")\n<line188>: _("failed to create symbolic link %s -> %s"))\n<line189>: (link_errno == EMLINK\n<line190>? _("failed to create hard link to %.0s%s")\n<line191>: (link_errno == EDQUOT || link_errno == EEXIST\n<line192>|| link_errno == ENOSPC || link_errno == EROFS)\n<line193>? _("failed to create hard link %s")\n<line194>: _("failed to create hard link %s => %s"))),\n<line195>quoteaf_n (0, dest), quoteaf_n (1, source));\n<line196>if (backup_base)\n<line197>{\n<line198>if (renameat (destdir_fd, backup_base, destdir_fd, dest_base) != 0)\n<line199>error (0, errno, _("cannot un-backup %s"), quoteaf (dest));\n<line200>}\n<line201>}\n<line202>free (backup_base);\n<line203>free (rel_source);\n<line204>return link_errno <= 0;\n<line205>fail:\n<line206>free (rel_source);\n<line207>return false;\n<line208>}
----------------------------------------
Function: usage
Content: <line0>void\n<line1>usage (int status)\n<line2>{\n<line3>if (status != EXIT_SUCCESS)\n<line4>emit_try_help ();\n<line5>else\n<line6>{\n<line7>printf (_("\\n<line8>Usage: %s [OPTION]... [-T] TARGET LINK_NAME\n\\n<line9>or:  %s [OPTION]... TARGET\n\\n<line10>or:  %s [OPTION]... TARGET... DIRECTORY\n\\n<line11>or:  %s [OPTION]... -t DIRECTORY TARGET...\n\\n<line12>"),\n<line13>program_name, program_name, program_name, program_name);\n<line14>fputs (_("\\n<line15>In the 1st form, create a link to TARGET with the name LINK_NAME.\n\\n<line16>In the 2nd form, create a link to TARGET in the current directory.\n\\n<line17>In the 3rd and 4th forms, create links to each TARGET in DIRECTORY.\n\\n<line18>Create hard links by default, symbolic links with --symbolic.\n\\n<line19>By default, each destination (name of new link) should not already exist.\n\\n<line20>When creating hard links, each TARGET must exist.  Symbolic links\n\\n<line21>can hold arbitrary text; if later resolved, a relative link is\n\\n<line22>interpreted in relation to its parent directory.\n\\n<line23>"), stdout);\n<line24>emit_mandatory_arg_note ();\n<line25>fputs (_("\\n<line26>--backup[=CONTROL]      make a backup of each existing destination file\n\\n<line27>-b                          like --backup but does not accept an argument\n\\n<line28>-d, -F, --directory         allow the superuser to attempt to hard link\n\\n<line29>directories (note: will probably fail due to\n\\n<line30>system restrictions, even for the superuser)\n\\n<line31>-f, --force                 remove existing destination files\n\\n<line32>"), stdout);\n<line33>fputs (_("\\n<line34>-i, --interactive           prompt whether to remove destinations\n\\n<line35>-L, --logical               dereference TARGETs that are symbolic links\n\\n<line36>-n, --no-dereference        treat LINK_NAME as a normal file if\n\\n<line37>it is a symbolic link to a directory\n\\n<line38>-P, --physical              make hard links directly to symbolic links\n\\n<line39>-r, --relative              with -s, create links relative to link location\n\\n<line40>-s, --symbolic              make symbolic links instead of hard links\n\\n<line41>"), stdout);\n<line42>fputs (_("\\n<line43>-S, --suffix=SUFFIX         override the usual backup suffix\n\\n<line44>-t, --target-directory=DIRECTORY  specify the DIRECTORY in which to create\n\\n<line45>the links\n\\n<line46>-T, --no-target-directory   treat LINK_NAME as a normal file always\n\\n<line47>-v, --verbose               print name of each linked file\n\\n<line48>"), stdout);\n<line49>fputs (HELP_OPTION_DESCRIPTION, stdout);\n<line50>fputs (VERSION_OPTION_DESCRIPTION, stdout);\n<line51>emit_backup_suffix_note ();\n<line52>printf (_("\\n<line53>\n\\n<line54>Using -s ignores -L and -P.  Otherwise, the last option specified controls\n\\n<line55>behavior when a TARGET is a symbolic link, defaulting to %s.\n\\n<line56>"), LINK_FOLLOWS_SYMLINKS ? "-L" : "-P");\n<line57>emit_ancillary_info (PROGRAM_NAME);\n<line58>}\n<line59>exit (status);\n<line60>}
----------------------------------------
Function: main
Content: <line0>int\n<line1>main (int argc, char **argv)\n<line2>{\n<line3>int c;\n<line4>bool ok;\n<line5>bool make_backups = false;\n<line6>char const *backup_suffix = nullptr;\n<line7>char *version_control_string = nullptr;\n<line8>char const *target_directory = nullptr;\n<line9>int destdir_fd;\n<line10>bool no_target_directory = false;\n<line11>int n_files;\n<line12>char **file;\n<line13>int link_errno = -1;\n<line14>initialize_main (&argc, &argv);\n<line15>set_program_name (argv[0]);\n<line16>setlocale (LC_ALL, "");\n<line17>bindtextdomain (PACKAGE, LOCALEDIR);\n<line18>textdomain (PACKAGE);\n<line19>atexit (close_stdin);\n<line20>symbolic_link = remove_existing_files = interactive = verbose\n<line21>= hard_dir_link = false;\n<line22>while ((c = getopt_long (argc, argv, "bdfinrst:vFLPS:T",\n<line23>long_options, nullptr))\n<line24>!= -1)\n<line25>{\n<line26>switch (c)\n<line27>{\n<line28>case 'b':\n<line29>make_backups = true;\n<line30>if (optarg)\n<line31>version_control_string = optarg;\n<line32>break;\n<line33>case 'd':\n<line34>case 'F':\n<line35>hard_dir_link = true;\n<line36>break;\n<line37>case 'f':\n<line38>remove_existing_files = true;\n<line39>interactive = false;\n<line40>break;\n<line41>case 'i':\n<line42>remove_existing_files = false;\n<line43>interactive = true;\n<line44>break;\n<line45>case 'L':\n<line46>logical = true;\n<line47>break;\n<line48>case 'n':\n<line49>dereference_dest_dir_symlinks = false;\n<line50>break;\n<line51>case 'P':\n<line52>logical = false;\n<line53>break;\n<line54>case 'r':\n<line55>relative = true;\n<line56>break;\n<line57>case 's':\n<line58>symbolic_link = true;\n<line59>break;\n<line60>case 't':\n<line61>if (target_directory)\n<line62>error (EXIT_FAILURE, 0, _("multiple target directories specified"));\n<line63>else\n<line64>{\n<line65>struct stat st;\n<line66>if (stat (optarg, &st) != 0)\n<line67>error (EXIT_FAILURE, errno, _("failed to access %s"),\n<line68>quoteaf (optarg));\n<line69>if (! S_ISDIR (st.st_mode))\n<line70>error (EXIT_FAILURE, 0, _("target %s is not a directory"),\n<line71>quoteaf (optarg));\n<line72>}\n<line73>target_directory = optarg;\n<line74>break;\n<line75>case 'T':\n<line76>no_target_directory = true;\n<line77>break;\n<line78>case 'v':\n<line79>verbose = true;\n<line80>break;\n<line81>case 'S':\n<line82>make_backups = true;\n<line83>backup_suffix = optarg;\n<line84>break;\n<line85>case_GETOPT_HELP_CHAR;\n<line86>case_GETOPT_VERSION_CHAR (PROGRAM_NAME, AUTHORS);\n<line87>default:\n<line88>usage (EXIT_FAILURE);\n<line89>break;\n<line90>}\n<line91>}\n<line92>n_files = argc - optind;\n<line93>file = argv + optind;\n<line94>if (n_files <= 0)\n<line95>{\n<line96>error (0, 0, _("missing file operand"));\n<line97>usage (EXIT_FAILURE);\n<line98>}\n<line99>if (relative && !symbolic_link)\n<line100>error (EXIT_FAILURE, 0, _("cannot do --relative without --symbolic"));\n<line101>if (!hard_dir_link)\n<line102>{\n<line103>priv_set_remove_linkdir ();\n<line104>beware_hard_dir_link = !cannot_unlink_dir ();\n<line105>}\n<line106>if (no_target_directory)\n<line107>{\n<line108>if (target_directory)\n<line109>error (EXIT_FAILURE, 0,\n<line110>_("cannot combine --target-directory "\n<line111>"and --no-target-directory"));\n<line112>if (n_files != 2)\n<line113>{\n<line114>if (n_files < 2)\n<line115>error (0, 0,\n<line116>_("missing destination file operand after %s"),\n<line117>quoteaf (file[0]));\n<line118>else\n<line119>error (0, 0, _("extra operand %s"), quoteaf (file[2]));\n<line120>usage (EXIT_FAILURE);\n<line121>}\n<line122>}\n<line123>else if (n_files < 2 && !target_directory)\n<line124>{\n<line125>target_directory = ".";\n<line126>destdir_fd = AT_FDCWD;\n<line127>}\n<line128>else\n<line129>{\n<line130>if (n_files == 2 && !target_directory)\n<line131>link_errno = atomic_link (file[0], AT_FDCWD, file[1]);\n<line132>if (link_errno < 0 || link_errno == EEXIST || link_errno == ENOTDIR\n<line133>|| link_errno == EINVAL)\n<line134>{\n<line135>char const *d\n<line136>= target_directory ? target_directory : file[n_files - 1];\n<line137>int flags = (O_PATHSEARCH | O_DIRECTORY\n<line138>| (dereference_dest_dir_symlinks ? 0 : O_NOFOLLOW));\n<line139>destdir_fd = openat_safer (AT_FDCWD, d, flags);\n<line140>int err = errno;\n<line141>if (!O_DIRECTORY && 0 <= destdir_fd)\n<line142>{\n<line143>struct stat st;\n<line144>err = (fstat (destdir_fd, &st) != 0 ? errno\n<line145>: S_ISDIR (st.st_mode) ? 0 : ENOTDIR);\n<line146>if (err != 0)\n<line147>{\n<line148>close (destdir_fd);\n<line149>destdir_fd = -1;\n<line150>}\n<line151>}\n<line152>if (0 <= destdir_fd)\n<line153>{\n<line154>n_files -= !target_directory;\n<line155>target_directory = d;\n<line156>}\n<line157>else if (! (n_files == 2 && !target_directory))\n<line158>error (EXIT_FAILURE, err, _("target %s"), quoteaf (d));\n<line159>}\n<line160>}\n<line161>backup_type = (make_backups\n<line162>? xget_version (_("backup type"), version_control_string)\n<line163>: no_backups);\n<line164>set_simple_backup_suffix (backup_suffix);\n<line165>if (target_directory)\n<line166>{\n<line167>/* Create the data structure we'll use to record which hard links we\n<line168>create.  Used to ensure that ln detects an obscure corner case that\n<line169>might result in user data loss.  Create it only if needed.  */\n<line170>if (2 <= n_files\n<line171>&& remove_existing_files\n<line172>/* Don't bother trying to protect symlinks, since ln clobbering\n<line173>a just-created symlink won't ever lead to real data loss.  */\n<line174>&& ! symbolic_link\n<line175>/* No destination hard link can be clobbered when making\n<line176>numbered backups.  */\n<line177>&& backup_type != numbered_backups)\n<line178>{\n<line179>dest_set = hash_initialize (DEST_INFO_INITIAL_CAPACITY,\n<line180>nullptr,\n<line181>triple_hash,\n<line182>triple_compare,\n<line183>triple_free);\n<line184>if (dest_set == nullptr)\n<line185>xalloc_die ();\n<line186>}\n<line187>ok = true;\n<line188>for (int i = 0; i < n_files; ++i)\n<line189>{\n<line190>char *dest_base;\n<line191>char *dest = file_name_concat (target_directory,\n<line192>last_component (file[i]),\n<line193>&dest_base);\n<line194>strip_trailing_slashes (dest_base);\n<line195>ok &= do_link (file[i], destdir_fd, dest_base, dest, -1);\n<line196>free (dest);\n<line197>}\n<line198>}\n<line199>else\n<line200>ok = do_link (file[0], AT_FDCWD, file[1], file[1], link_errno);\n<line201>main_exit (ok ? EXIT_SUCCESS : EXIT_FAILURE);\n<line202>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/src/relpath.c
========================================
Function: buffer_or_output
Content: <line0>static bool\n<line1>buffer_or_output (char const *str, char **pbuf, size_t *plen)\n<line2>{\n<line3>if (*pbuf)\n<line4>{\n<line5>size_t slen = strlen (str);\n<line6>if (slen >= *plen)\n<line7>return true;\n<line8>memcpy (*pbuf, str, slen + 1);\n<line9>*pbuf += slen;\n<line10>*plen -= slen;\n<line11>}\n<line12>else\n<line13>{\n<line14>fputs (str, stdout);\n<line15>}\n<line16>return false;\n<line17>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/src/logname.c
========================================
Function: usage
Content: <line0>void\n<line1>usage (int status)\n<line2>{\n<line3>if (status != EXIT_SUCCESS)\n<line4>emit_try_help ();\n<line5>else\n<line6>{\n<line7>printf (_("Usage: %s [OPTION]\n"), program_name);\n<line8>fputs (_("\\n<line9>Print the user's login name.\n\\n<line10>\n\\n<line11>"), stdout);\n<line12>fputs (HELP_OPTION_DESCRIPTION, stdout);\n<line13>fputs (VERSION_OPTION_DESCRIPTION, stdout);\n<line14>emit_ancillary_info (PROGRAM_NAME);\n<line15>}\n<line16>exit (status);\n<line17>}
----------------------------------------
Function: main
Content: <line0>int\n<line1>main (int argc, char **argv)\n<line2>{\n<line3>char *cp;\n<line4>initialize_main (&argc, &argv);\n<line5>set_program_name (argv[0]);\n<line6>setlocale (LC_ALL, "");\n<line7>bindtextdomain (PACKAGE, LOCALEDIR);\n<line8>textdomain (PACKAGE);\n<line9>atexit (close_stdout);\n<line10>parse_gnu_standard_options_only (argc, argv, PROGRAM_NAME, PACKAGE_NAME,\n<line11>Version, true, usage, AUTHORS,\n<line12>(char const *) nullptr);\n<line13>if (optind < argc)\n<line14>{\n<line15>error (0, 0, _("extra operand %s"), quote (argv[optind]));\n<line16>usage (EXIT_FAILURE);\n<line17>}\n<line18>/* POSIX requires using getlogin (or equivalent code) and prohibits\n<line19>using a fallback technique.  */\n<line20>cp = getlogin ();\n<line21>if (! cp)\n<line22>error (EXIT_FAILURE, 0, _("no login name"));\n<line23>puts (cp);\n<line24>return EXIT_SUCCESS;\n<line25>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/src/ls-ls.c
========================================
========================================
/home/huihui/Downloads/coreutils-9.4/src/digest.c
========================================
Function: usage
Content: <line0>void\n<line1>usage (int status)\n<line2>{\n<line3>if (status != EXIT_SUCCESS)\n<line4>emit_try_help ();\n<line5>else\n<line6>{\n<line7>printf (_("\\n<line8>Usage: %s [OPTION]... [FILE]...\n\\n<line9>"), program_name);\n<line10>#if HASH_ALGO_CKSUM\n<line11>fputs (_("\\n<line12>Print or verify checksums.\n\\n<line13>By default use the 32 bit CRC algorithm.\n\\n<line14>"), stdout);\n<line15>#else\n<line16>printf (_("\\n<line17>Print or check %s (%d-bit) checksums.\n\\n<line18>"),\n<line19>DIGEST_TYPE_STRING,\n<line20>DIGEST_BITS);\n<line21>#endif\n<line22>emit_stdin_note ();\n<line23>#if HASH_ALGO_SUM\n<line24>fputs (_("\\n<line25>\n\\n<line26>-r              use BSD sum algorithm (the default), use 1K blocks\n\\n<line27>-s, --sysv      use System V sum algorithm, use 512 bytes blocks\n\\n<line28>"), stdout);\n<line29>#endif\n<line30>#if HASH_ALGO_BLAKE2 || HASH_ALGO_CKSUM\n<line31>emit_mandatory_arg_note ();\n<line32>#endif\n<line33>#if HASH_ALGO_CKSUM\n<line34>fputs (_("\\n<line35>-a, --algorithm=TYPE  select the digest type to use.  See DIGEST below.\\n<line36>\n\\n<line37>"), stdout);\n<line38>fputs (_("\\n<line39>--base64          emit base64-encoded digests, not hexadecimal\\n<line40>\n\\n<line41>"), stdout);\n<line42>#endif\n<line43>#if !HASH_ALGO_SUM\n<line44># if !HASH_ALGO_CKSUM\n<line45>if (O_BINARY)\n<line46>fputs (_("\\n<line47>-b, --binary          read in binary mode (default unless reading tty stdin)\\n<line48>\n\\n<line49>"), stdout);\n<line50>else\n<line51>fputs (_("\\n<line52>-b, --binary          read in binary mode\n\\n<line53>"), stdout);\n<line54># endif\n<line55>fputs (_("\\n<line56>-c, --check           read checksums from the FILEs and check them\n\\n<line57>"), stdout);\n<line58># if HASH_ALGO_BLAKE2 || HASH_ALGO_CKSUM\n<line59>fputs (_("\\n<line60>-l, --length=BITS     digest length in bits; must not exceed the max for\n\\n<line61>the blake2 algorithm and must be a multiple of 8\n\\n<line62>"), stdout);\n<line63># endif\n<line64># if HASH_ALGO_CKSUM\n<line65>fputs (_("\\n<line66>--raw             emit a raw binary digest, not hexadecimal\\n<line67>\n\\n<line68>"), stdout);\n<line69>fputs (_("\\n<line70>--tag             create a BSD-style checksum (the default)\n\\n<line71>"), stdout);\n<line72>fputs (_("\\n<line73>--untagged        create a reversed style checksum, without digest type\n\\n<line74>"), stdout);\n<line75># else\n<line76>fputs (_("\\n<line77>--tag             create a BSD-style checksum\n\\n<line78>"), stdout);\n<line79># endif\n<line80># if !HASH_ALGO_CKSUM\n<line81>if (O_BINARY)\n<line82>fputs (_("\\n<line83>-t, --text            read in text mode (default if reading tty stdin)\n\\n<line84>"), stdout);\n<line85>else\n<line86>fputs (_("\\n<line87>-t, --text            read in text mode (default)\n\\n<line88>"), stdout);\n<line89># endif\n<line90>fputs (_("\\n<line91>-z, --zero            end each output line with NUL, not newline,\n\\n<line92>and disable file name escaping\n\\n<line93>"), stdout);\n<line94>fputs (_("\\n<line95>\n\\n<line96>The following five options are useful only when verifying checksums:\n\\n<line97>--ignore-missing  don't fail or report status for missing files\n\\n<line98>--quiet           don't print OK for each successfully verified file\n\\n<line99>--status          don't output anything, status code shows success\n\\n<line100>--strict          exit non-zero for improperly formatted checksum lines\n\\n<line101>-w, --warn            warn about improperly formatted checksum lines\n\\n<line102>\n\\n<line103>"), stdout);\n<line104>#endif\n<line105>#if HASH_ALGO_CKSUM\n<line106>fputs (_("\\n<line107>--debug           indicate which implementation used\n\\n<line108>"), stdout);\n<line109>#endif\n<line110>fputs (HELP_OPTION_DESCRIPTION, stdout);\n<line111>fputs (VERSION_OPTION_DESCRIPTION, stdout);\n<line112>#if HASH_ALGO_CKSUM\n<line113>fputs (_("\\n<line114>\n\\n<line115>DIGEST determines the digest algorithm and default output format:\n\\n<line116>sysv      (equivalent to sum -s)\n\\n<line117>bsd       (equivalent to sum -r)\n\\n<line118>crc       (equivalent to cksum)\n\\n<line119>md5       (equivalent to md5sum)\n\\n<line120>sha1      (equivalent to sha1sum)\n\\n<line121>sha224    (equivalent to sha224sum)\n\\n<line122>sha256    (equivalent to sha256sum)\n\\n<line123>sha384    (equivalent to sha384sum)\n\\n<line124>sha512    (equivalent to sha512sum)\n\\n<line125>blake2b   (equivalent to b2sum)\n\\n<line126>sm3       (only available through cksum)\n\\n<line127>\n"), stdout);\n<line128>#endif\n<line129>#if !HASH_ALGO_SUM && !HASH_ALGO_CKSUM\n<line130>printf (_("\\n<line131>\n\\n<line132>The sums are computed as described in %s.\n"), DIGEST_REFERENCE);\n<line133>fputs (_("\\n<line134>When checking, the input should be a former output of this program.\n\\n<line135>The default mode is to print a line with: checksum, a space,\n\\n<line136>a character indicating input mode ('*' for binary, ' ' for text\n\\n<line137>or where binary is insignificant), and name for each FILE.\n\\n<line138>\n\\n<line139>Note: There is no difference between binary mode and text mode on GNU systems.\\n<line140>\n"), stdout);\n<line141>#endif\n<line142>#if HASH_ALGO_CKSUM\n<line143>fputs (_("\\n<line144>When checking, the input should be a former output of this program,\n\\n<line145>or equivalent standalone program.\\n<line146>\n"), stdout);\n<line147>#endif\n<line148>emit_ancillary_info (PROGRAM_NAME);\n<line149>}\n<line150>exit (status);\n<line151>}
----------------------------------------
Function: filename_unescape
Content: <line0>static char *\n<line1>filename_unescape (char *s, size_t s_len)\n<line2>{\n<line3>char *dst = s;\n<line4>for (size_t i = 0; i < s_len; i++)\n<line5>{\n<line6>switch (s[i])\n<line7>{\n<line8>case '\\':\n<line9>if (i == s_len - 1)\n<line10>{\n<line11>/* File name ends with an unescaped backslash: invalid.  */\n<line12>return nullptr;\n<line13>}\n<line14>++i;\n<line15>switch (s[i])\n<line16>{\n<line17>case 'n':\n<line18>*dst++ = '\n';\n<line19>break;\n<line20>case 'r':\n<line21>*dst++ = '\r';\n<line22>break;\n<line23>case '\\':\n<line24>*dst++ = '\\';\n<line25>break;\n<line26>default:\n<line27>/* Only '\', 'n' or 'r' may follow a backslash.  */\n<line28>return nullptr;\n<line29>}\n<line30>break;\n<line31>case '\0':\n<line32>/* The file name may not contain a NUL.  */\n<line33>return nullptr;\n<line34>default:\n<line35>*dst++ = s[i];\n<line36>break;\n<line37>}\n<line38>}\n<line39>if (dst < s + s_len)\n<line40>*dst = '\0';\n<line41>return s;\n<line42>}
----------------------------------------
Function: bsd_split_3
Content: <line0>static bool\n<line1>bsd_split_3 (char *s, size_t s_len,\n<line2>unsigned char **digest, size_t *d_len,\n<line3>char **file_name, bool escaped_filename)\n<line4>{\n<line5>if (s_len == 0)\n<line6>return false;\n<line7>/* Find end of filename.  */\n<line8>size_t i = s_len - 1;\n<line9>while (i && s[i] != ')')\n<line10>i--;\n<line11>if (s[i] != ')')\n<line12>return false;\n<line13>*file_name = s;\n<line14>if (escaped_filename && filename_unescape (s, i) == nullptr)\n<line15>return false;\n<line16>s[i++] = '\0';\n<line17>while (ISWHITE (s[i]))\n<line18>i++;\n<line19>if (s[i] != '=')\n<line20>return false;\n<line21>i++;\n<line22>while (ISWHITE (s[i]))\n<line23>i++;\n<line24>*digest = (unsigned char *) &s[i];\n<line25>*d_len = s_len - i;\n<line26>return valid_digits (*digest, *d_len);\n<line27>}
----------------------------------------
Function: split_3
Content: <line0>static bool\n<line1>split_3 (char *s, size_t s_len,\n<line2>unsigned char **digest, size_t *d_len, int *binary, char **file_name)\n<line3>{\n<line4>bool escaped_filename = false;\n<line5>size_t algo_name_len;\n<line6>size_t i = 0;\n<line7>while (ISWHITE (s[i]))\n<line8>++i;\n<line9>if (s[i] == '\\')\n<line10>{\n<line11>++i;\n<line12>escaped_filename = true;\n<line13>}\n<line14>/* Check for BSD-style checksum line. */\n<line15>#if HASH_ALGO_CKSUM\n<line16>if (! algorithm_specified)\n<line17>{\n<line18>ptrdiff_t algo_tag = algorithm_from_tag (s + i);\n<line19>if (algo_tag >= 0)\n<line20>{\n<line21>if (algo_tag <= crc)\n<line22>return false;  /* We don't support checking these older formats.  */\n<line23>cksum_algorithm = algo_tag;\n<line24>}\n<line25>else\n<line26>return false;  /* We only support tagged format without -a.  */\n<line27>}\n<line28>#endif\n<line29>algo_name_len = strlen (DIGEST_TYPE_STRING);\n<line30>if (STREQ_LEN (s + i, DIGEST_TYPE_STRING, algo_name_len))\n<line31>{\n<line32>i += algo_name_len;\n<line33>#if HASH_ALGO_BLAKE2 || HASH_ALGO_CKSUM\n<line34>/* Terminate and match algorithm name.  */\n<line35>char const *algo_name = &s[i - algo_name_len];\n<line36>bool length_specified = s[i] == '-';\n<line37>bool openssl_format = s[i] == '('; /* and no length_specified */\n<line38>s[i++] = '\0';\n<line39>if (!STREQ (algo_name, DIGEST_TYPE_STRING))\n<line40>return false;\n<line41>if (openssl_format)\n<line42>s[--i] = '(';\n<line43># if HASH_ALGO_BLAKE2\n<line44>digest_length = BLAKE2B_MAX_LEN * 8;\n<line45># else\n<line46>digest_length = algorithm_bits[cksum_algorithm];\n<line47># endif\n<line48>if (length_specified)\n<line49>{\n<line50>uintmax_t length;\n<line51>char *siend;\n<line52>if (! (xstrtoumax (s + i, &siend, 0, &length, nullptr) == LONGINT_OK\n<line53>&& 0 < length && length <= digest_length\n<line54>&& length % 8 == 0))\n<line55>return false;\n<line56>i = siend - s;\n<line57>digest_length = length;\n<line58>}\n<line59>digest_hex_bytes = digest_length / 4;\n<line60>#endif\n<line61>if (s[i] == ' ')\n<line62>++i;\n<line63>if (s[i] == '(')\n<line64>{\n<line65>++i;\n<line66>*binary = 0;\n<line67>return bsd_split_3 (s + i, s_len - i,\n<line68>digest, d_len, file_name, escaped_filename);\n<line69>}\n<line70>return false;\n<line71>}\n<line72>/* Ignore this line if it is too short.\n<line73>Each line must have at least 'min_digest_line_length - 1' (or one more, if\n<line74>the first is a backslash) more characters to contain correct message digest\n<line75>information.  */\n<line76>if (s_len - i < min_digest_line_length + (s[i] == '\\'))\n<line77>return false;\n<line78>*digest = (unsigned char *) &s[i];\n<line79>#if HASH_ALGO_BLAKE2 || HASH_ALGO_CKSUM\n<line80>/* Auto determine length.  */\n<line81># if HASH_ALGO_CKSUM\n<line82>if (cksum_algorithm == blake2b) {\n<line83># endif\n<line84>unsigned char const *hp = *digest;\n<line85>digest_hex_bytes = 0;\n<line86>while (isxdigit (*hp++))\n<line87>digest_hex_bytes++;\n<line88>if (digest_hex_bytes < 2 || digest_hex_bytes % 2\n<line89>|| BLAKE2B_MAX_LEN * 2 < digest_hex_bytes)\n<line90>return false;\n<line91>digest_length = digest_hex_bytes * 4;\n<line92># if HASH_ALGO_CKSUM\n<line93>}\n<line94># endif\n<line95>#endif\n<line96>/* This field must be the hexadecimal or base64 representation\n<line97>of the message digest.  */\n<line98>while (s[i] && !ISWHITE (s[i]))\n<line99>i++;\n<line100>/* The digest must be followed by at least one whitespace character.  */\n<line101>if (i == s_len)\n<line102>return false;\n<line103>*d_len = &s[i] - (char *) *digest;\n<line104>s[i++] = '\0';\n<line105>if (! valid_digits (*digest, *d_len))\n<line106>return false;\n<line107>/* If "bsd reversed" format detected.  */\n<line108>if ((s_len - i == 1) || (s[i] != ' ' && s[i] != '*'))\n<line109>{\n<line110>/* Don't allow mixing bsd and standard formats,\n<line111>to minimize security issues with attackers\n<line112>renaming files with leading spaces.\n<line113>This assumes that with bsd format checksums\n<line114>that the first file name does not have\n<line115>a leading ' ' or '*'.  */\n<line116>if (bsd_reversed == 0)\n<line117>return false;\n<line118>bsd_reversed = 1;\n<line119>}\n<line120>else if (bsd_reversed != 1)\n<line121>{\n<line122>bsd_reversed = 0;\n<line123>*binary = (s[i++] == '*');\n<line124>}\n<line125>/* All characters between the type indicator and end of line are\n<line126>significant -- that includes leading and trailing white space.  */\n<line127>*file_name = &s[i];\n<line128>if (escaped_filename)\n<line129>return filename_unescape (&s[i], s_len - i) != nullptr;\n<line130>return true;\n<line131>}
----------------------------------------
Function: print_filename
Content: <line0>static void\n<line1>print_filename (char const *file, bool escape)\n<line2>{\n<line3>if (! escape)\n<line4>{\n<line5>fputs (file, stdout);\n<line6>return;\n<line7>}\n<line8>while (*file)\n<line9>{\n<line10>switch (*file)\n<line11>{\n<line12>case '\n':\n<line13>fputs ("\\n", stdout);\n<line14>break;\n<line15>case '\r':\n<line16>fputs ("\\r", stdout);\n<line17>break;\n<line18>case '\\':\n<line19>fputs ("\\\\", stdout);\n<line20>break;\n<line21>default:\n<line22>putchar (*file);\n<line23>break;\n<line24>}\n<line25>file++;\n<line26>}\n<line27>}
----------------------------------------
Function: digest_file
Content: <line0>static bool\n<line1>digest_file (char const *filename, int *binary, unsigned char *bin_result,\n<line2>bool *missing, MAYBE_UNUSED uintmax_t *length)\n<line3>{\n<line4>FILE *fp;\n<line5>int err;\n<line6>bool is_stdin = STREQ (filename, "-");\n<line7>*missing = false;\n<line8>if (is_stdin)\n<line9>{\n<line10>have_read_stdin = true;\n<line11>fp = stdin;\n<line12>if (O_BINARY && *binary)\n<line13>{\n<line14>if (*binary < 0)\n<line15>*binary = ! isatty (STDIN_FILENO);\n<line16>if (*binary)\n<line17>xset_binary_mode (STDIN_FILENO, O_BINARY);\n<line18>}\n<line19>}\n<line20>else\n<line21>{\n<line22>fp = fopen (filename, (O_BINARY && *binary ? "rb" : "r"));\n<line23>if (fp == nullptr)\n<line24>{\n<line25>if (ignore_missing && errno == ENOENT)\n<line26>{\n<line27>*missing = true;\n<line28>return true;\n<line29>}\n<line30>error (0, errno, "%s", quotef (filename));\n<line31>return false;\n<line32>}\n<line33>}\n<line34>fadvise (fp, FADVISE_SEQUENTIAL);\n<line35>#if HASH_ALGO_CKSUM\n<line36>if (cksum_algorithm == blake2b)\n<line37>*length = digest_length / 8;\n<line38>err = DIGEST_STREAM (fp, bin_result, length);\n<line39>#elif HASH_ALGO_SUM\n<line40>err = DIGEST_STREAM (fp, bin_result, length);\n<line41>#elif HASH_ALGO_BLAKE2\n<line42>err = DIGEST_STREAM (fp, bin_result, digest_length / 8);\n<line43>#else\n<line44>err = DIGEST_STREAM (fp, bin_result);\n<line45>#endif\n<line46>err = err ? errno : 0;\n<line47>if (is_stdin)\n<line48>clearerr (fp);\n<line49>else if (fclose (fp) != 0 && !err)\n<line50>err = errno;\n<line51>if (err)\n<line52>{\n<line53>error (0, err, "%s", quotef (filename));\n<line54>return false;\n<line55>}\n<line56>return true;\n<line57>}
----------------------------------------
Function: output_file
Content: <line0>static void\n<line1>output_file (char const *file, int binary_file, void const *digest,\n<line2>bool raw, bool tagged, unsigned char delim, MAYBE_UNUSED bool args,\n<line3>MAYBE_UNUSED uintmax_t length)\n<line4>{\n<line5># if HASH_ALGO_CKSUM\n<line6>if (raw)\n<line7>{\n<line8>fwrite (digest, 1, digest_length / 8, stdout);\n<line9>return;\n<line10>}\n<line11># endif\n<line12>unsigned char const *bin_buffer = digest;\n<line13>/* Output a leading backslash if the file name contains problematic chars.  */\n<line14>bool needs_escape = delim == '\n' && problematic_chars (file);\n<line15>if (needs_escape)\n<line16>putchar ('\\');\n<line17>if (tagged)\n<line18>{\n<line19>fputs (DIGEST_TYPE_STRING, stdout);\n<line20># if HASH_ALGO_BLAKE2\n<line21>if (digest_length < BLAKE2B_MAX_LEN * 8)\n<line22>printf ("-%"PRIuMAX, digest_length);\n<line23># elif HASH_ALGO_CKSUM\n<line24>if (cksum_algorithm == blake2b)\n<line25>{\n<line26>if (digest_length < BLAKE2B_MAX_LEN * 8)\n<line27>printf ("-%"PRIuMAX, digest_length);\n<line28>}\n<line29># endif\n<line30>fputs (" (", stdout);\n<line31>print_filename (file, needs_escape);\n<line32>fputs (") = ", stdout);\n<line33>}\n<line34># if HASH_ALGO_CKSUM\n<line35>if (base64_digest)\n<line36>{\n<line37>char b64[BASE64_LENGTH (DIGEST_BIN_BYTES) + 1];\n<line38>base64_encode ((char const *) bin_buffer, digest_length / 8,\n<line39>b64, sizeof b64);\n<line40>fputs (b64, stdout);\n<line41>}\n<line42>else\n<line43># endif\n<line44>{\n<line45>for (size_t i = 0; i < (digest_hex_bytes / 2); ++i)\n<line46>printf ("%02x", bin_buffer[i]);\n<line47>}\n<line48>if (!tagged)\n<line49>{\n<line50>putchar (' ');\n<line51>putchar (binary_file ? '*' : ' ');\n<line52>print_filename (file, needs_escape);\n<line53>}\n<line54>putchar (delim);\n<line55>}
----------------------------------------
Function: hex_equal
Content: <line0>static bool\n<line1>hex_equal (unsigned char const *hex_digest, unsigned char const *bin_buffer)\n<line2>{\n<line3>static const char bin2hex[] = { '0', '1', '2', '3',\n<line4>'4', '5', '6', '7',\n<line5>'8', '9', 'a', 'b',\n<line6>'c', 'd', 'e', 'f' };\n<line7>size_t digest_bin_bytes = digest_hex_bytes / 2;\n<line8>/* Compare generated binary number with text representation\n<line9>in check file.  Ignore case of hex digits.  */\n<line10>size_t cnt;\n<line11>for (cnt = 0; cnt < digest_bin_bytes; ++cnt)\n<line12>{\n<line13>if (tolower (hex_digest[2 * cnt])\n<line14>!= bin2hex[bin_buffer[cnt] >> 4]\n<line15>|| (tolower (hex_digest[2 * cnt + 1])\n<line16>!= (bin2hex[bin_buffer[cnt] & 0xf])))\n<line17>break;\n<line18>}\n<line19>return cnt == digest_bin_bytes;\n<line20>}
----------------------------------------
Function: digest_check
Content: <line0>static bool\n<line1>digest_check (char const *checkfile_name)\n<line2>{\n<line3>FILE *checkfile_stream;\n<line4>uintmax_t n_misformatted_lines = 0;\n<line5>uintmax_t n_mismatched_checksums = 0;\n<line6>uintmax_t n_open_or_read_failures = 0;\n<line7>bool properly_formatted_lines = false;\n<line8>bool matched_checksums = false;\n<line9>unsigned char bin_buffer_unaligned[DIGEST_BIN_BYTES + DIGEST_ALIGN];\n<line10>/* Make sure bin_buffer is properly aligned. */\n<line11>unsigned char *bin_buffer = ptr_align (bin_buffer_unaligned, DIGEST_ALIGN);\n<line12>uintmax_t line_number;\n<line13>char *line;\n<line14>size_t line_chars_allocated;\n<line15>bool is_stdin = STREQ (checkfile_name, "-");\n<line16>if (is_stdin)\n<line17>{\n<line18>have_read_stdin = true;\n<line19>checkfile_name = _("standard input");\n<line20>checkfile_stream = stdin;\n<line21>}\n<line22>else\n<line23>{\n<line24>checkfile_stream = fopen (checkfile_name, "r");\n<line25>if (checkfile_stream == nullptr)\n<line26>{\n<line27>error (0, errno, "%s", quotef (checkfile_name));\n<line28>return false;\n<line29>}\n<line30>}\n<line31>line_number = 0;\n<line32>line = nullptr;\n<line33>line_chars_allocated = 0;\n<line34>do\n<line35>{\n<line36>char *filename;\n<line37>int binary;\n<line38>unsigned char *digest;\n<line39>ssize_t line_length;\n<line40>++line_number;\n<line41>if (line_number == 0)\n<line42>error (EXIT_FAILURE, 0, _("%s: too many checksum lines"),\n<line43>quotef (checkfile_name));\n<line44>line_length = getline (&line, &line_chars_allocated, checkfile_stream);\n<line45>if (line_length <= 0)\n<line46>break;\n<line47>/* Ignore comment lines, which begin with a '#' character.  */\n<line48>if (line[0] == '#')\n<line49>continue;\n<line50>/* Remove any trailing newline.  */\n<line51>line_length -= line[line_length - 1] == '\n';\n<line52>/* Remove any trailing carriage return.  */\n<line53>line_length -= line[line_length - (0 < line_length)] == '\r';\n<line54>/* Ignore empty lines.  */\n<line55>if (line_length == 0)\n<line56>continue;\n<line57>line[line_length] = '\0';\n<line58>size_t d_len;\n<line59>if (! (split_3 (line, line_length, &digest, &d_len, &binary, &filename)\n<line60>&& ! (is_stdin && STREQ (filename, "-"))))\n<line61>{\n<line62>++n_misformatted_lines;\n<line63>if (warn)\n<line64>{\n<line65>error (0, 0,\n<line66>_("%s: %" PRIuMAX\n<line67>": improperly formatted %s checksum line"),\n<line68>quotef (checkfile_name), line_number,\n<line69>DIGEST_TYPE_STRING);\n<line70>}\n<line71>}\n<line72>else\n<line73>{\n<line74>bool ok;\n<line75>bool missing;\n<line76>bool needs_escape = ! status_only && problematic_chars (filename);\n<line77>properly_formatted_lines = true;\n<line78>uintmax_t length;\n<line79>ok = digest_file (filename, &binary, bin_buffer, &missing, &length);\n<line80>if (!ok)\n<line81>{\n<line82>++n_open_or_read_failures;\n<line83>if (!status_only)\n<line84>{\n<line85>if (needs_escape)\n<line86>putchar ('\\');\n<line87>print_filename (filename, needs_escape);\n<line88>printf (": %s\n", _("FAILED open or read"));\n<line89>}\n<line90>}\n<line91>else if (ignore_missing && missing)\n<line92>{\n<line93>/* Ignore missing files with --ignore-missing.  */\n<line94>;\n<line95>}\n<line96>else\n<line97>{\n<line98>bool match = false;\n<line99>#if HASH_ALGO_CKSUM\n<line100>if (d_len < digest_hex_bytes)\n<line101>match = b64_equal (digest, bin_buffer);\n<line102>else\n<line103>#endif\n<line104>if (d_len == digest_hex_bytes)\n<line105>match = hex_equal (digest, bin_buffer);\n<line106>if (match)\n<line107>matched_checksums = true;\n<line108>else\n<line109>++n_mismatched_checksums;\n<line110>if (!status_only)\n<line111>{\n<line112>if (! match || ! quiet)\n<line113>{\n<line114>if (needs_escape)\n<line115>putchar ('\\');\n<line116>print_filename (filename, needs_escape);\n<line117>}\n<line118>if (! match)\n<line119>printf (": %s\n", _("FAILED"));\n<line120>else if (!quiet)\n<line121>printf (": %s\n", _("OK"));\n<line122>}\n<line123>}\n<line124>}\n<line125>}\n<line126>while (!feof (checkfile_stream) && !ferror (checkfile_stream));\n<line127>free (line);\n<line128>int err = ferror (checkfile_stream) ? 0 : -1;\n<line129>if (is_stdin)\n<line130>clearerr (checkfile_stream);\n<line131>else if (fclose (checkfile_stream) != 0 && err < 0)\n<line132>err = errno;\n<line133>if (0 <= err)\n<line134>{\n<line135>error (0, err, err ? "%s" : _("%s: read error"),\n<line136>quotef (checkfile_name));\n<line137>return false;\n<line138>}\n<line139>if (! properly_formatted_lines)\n<line140>{\n<line141>/* Warn if no tests are found.  */\n<line142>error (0, 0, _("%s: no properly formatted checksum lines found"),\n<line143>quotef (checkfile_name));\n<line144>}\n<line145>else\n<line146>{\n<line147>if (!status_only)\n<line148>{\n<line149>if (n_misformatted_lines != 0)\n<line150>error (0, 0,\n<line151>(ngettext\n<line152>("WARNING: %" PRIuMAX " line is improperly formatted",\n<line153>"WARNING: %" PRIuMAX " lines are improperly formatted",\n<line154>select_plural (n_misformatted_lines))),\n<line155>n_misformatted_lines);\n<line156>if (n_open_or_read_failures != 0)\n<line157>error (0, 0,\n<line158>(ngettext\n<line159>("WARNING: %" PRIuMAX " listed file could not be read",\n<line160>"WARNING: %" PRIuMAX " listed files could not be read",\n<line161>select_plural (n_open_or_read_failures))),\n<line162>n_open_or_read_failures);\n<line163>if (n_mismatched_checksums != 0)\n<line164>error (0, 0,\n<line165>(ngettext\n<line166>("WARNING: %" PRIuMAX " computed checksum did NOT match",\n<line167>"WARNING: %" PRIuMAX " computed checksums did NOT match",\n<line168>select_plural (n_mismatched_checksums))),\n<line169>n_mismatched_checksums);\n<line170>if (ignore_missing && ! matched_checksums)\n<line171>error (0, 0, _("%s: no file was verified"),\n<line172>quotef (checkfile_name));\n<line173>}\n<line174>}\n<line175>return (properly_formatted_lines\n<line176>&& matched_checksums\n<line177>&& n_mismatched_checksums == 0\n<line178>&& n_open_or_read_failures == 0\n<line179>&& (!strict || n_misformatted_lines == 0));\n<line180>}
----------------------------------------
Function: main
Content: <line0>int\n<line1>main (int argc, char **argv)\n<line2>{\n<line3>unsigned char bin_buffer_unaligned[DIGEST_BIN_BYTES + DIGEST_ALIGN];\n<line4>/* Make sure bin_buffer is properly aligned. */\n<line5>unsigned char *bin_buffer = ptr_align (bin_buffer_unaligned, DIGEST_ALIGN);\n<line6>bool do_check = false;\n<line7>int opt;\n<line8>bool ok = true;\n<line9>int binary = -1;\n<line10>#if HASH_ALGO_CKSUM\n<line11>bool prefix_tag = true;\n<line12>#else\n<line13>bool prefix_tag = false;\n<line14>#endif\n<line15>/* Setting values of global variables.  */\n<line16>initialize_main (&argc, &argv);\n<line17>set_program_name (argv[0]);\n<line18>setlocale (LC_ALL, "");\n<line19>bindtextdomain (PACKAGE, LOCALEDIR);\n<line20>textdomain (PACKAGE);\n<line21>atexit (close_stdout);\n<line22>/* Line buffer stdout to ensure lines are written atomically and immediately\n<line23>so that processes running in parallel do not intersperse their output.  */\n<line24>setvbuf (stdout, nullptr, _IOLBF, 0);\n<line25>#if HASH_ALGO_SUM\n<line26>char const *short_opts = "rs";\n<line27>#elif HASH_ALGO_CKSUM\n<line28>char const *short_opts = "a:l:bctwz";\n<line29>char const *digest_length_str = "";\n<line30>#elif HASH_ALGO_BLAKE2\n<line31>char const *short_opts = "l:bctwz";\n<line32>char const *digest_length_str = "";\n<line33>#else\n<line34>char const *short_opts = "bctwz";\n<line35>#endif\n<line36>while ((opt = getopt_long (argc, argv, short_opts, long_options, nullptr))\n<line37>!= -1)\n<line38>switch (opt)\n<line39>{\n<line40>#if HASH_ALGO_CKSUM\n<line41>case 'a':\n<line42>cksum_algorithm = XARGMATCH_EXACT ("--algorithm", optarg,\n<line43>algorithm_args, algorithm_types);\n<line44>algorithm_specified = true;\n<line45>break;\n<line46>case DEBUG_PROGRAM_OPTION:\n<line47>cksum_debug = true;\n<line48>break;\n<line49>#endif\n<line50>#if HASH_ALGO_BLAKE2 || HASH_ALGO_CKSUM\n<line51>case 'l':\n<line52>digest_length = xdectoumax (optarg, 0, UINTMAX_MAX, "",\n<line53>_("invalid length"), 0);\n<line54>digest_length_str = optarg;\n<line55>if (digest_length % 8 != 0)\n<line56>{\n<line57>error (0, 0, _("invalid length: %s"), quote (digest_length_str));\n<line58>error (EXIT_FAILURE, 0, _("length is not a multiple of 8"));\n<line59>}\n<line60>break;\n<line61>#endif\n<line62>#if !HASH_ALGO_SUM\n<line63>case 'c':\n<line64>do_check = true;\n<line65>break;\n<line66>case STATUS_OPTION:\n<line67>status_only = true;\n<line68>warn = false;\n<line69>quiet = false;\n<line70>break;\n<line71>case 'b':\n<line72>binary = 1;\n<line73>break;\n<line74>case 't':\n<line75>binary = 0;\n<line76>break;\n<line77>case 'w':\n<line78>status_only = false;\n<line79>warn = true;\n<line80>quiet = false;\n<line81>break;\n<line82>case IGNORE_MISSING_OPTION:\n<line83>ignore_missing = true;\n<line84>break;\n<line85>case QUIET_OPTION:\n<line86>status_only = false;\n<line87>warn = false;\n<line88>quiet = true;\n<line89>break;\n<line90>case STRICT_OPTION:\n<line91>strict = true;\n<line92>break;\n<line93># if HASH_ALGO_CKSUM\n<line94>case BASE64_OPTION:\n<line95>base64_digest = true;\n<line96>break;\n<line97>case RAW_OPTION:\n<line98>raw_digest = true;\n<line99>break;\n<line100>case UNTAG_OPTION:\n<line101>prefix_tag = false;\n<line102>break;\n<line103># endif\n<line104>case TAG_OPTION:\n<line105>prefix_tag = true;\n<line106>binary = 1;\n<line107>break;\n<line108>case 'z':\n<line109>digest_delim = '\0';\n<line110>break;\n<line111>#endif\n<line112>#if HASH_ALGO_SUM\n<line113>case 'r':		/* For SysV compatibility. */\n<line114>sum_algorithm = bsd;\n<line115>break;\n<line116>case 's':\n<line117>sum_algorithm = sysv;\n<line118>break;\n<line119>#endif\n<line120>case_GETOPT_HELP_CHAR;\n<line121>case_GETOPT_VERSION_CHAR (PROGRAM_NAME, AUTHORS);\n<line122>default:\n<line123>usage (EXIT_FAILURE);\n<line124>}\n<line125>min_digest_line_length = MIN_DIGEST_LINE_LENGTH;\n<line126>#if HASH_ALGO_BLAKE2 || HASH_ALGO_CKSUM\n<line127># if HASH_ALGO_CKSUM\n<line128>if (digest_length && cksum_algorithm != blake2b)\n<line129>error (EXIT_FAILURE, 0,\n<line130>_("--length is only supported with --algorithm=blake2b"));\n<line131># endif\n<line132>if (digest_length > BLAKE2B_MAX_LEN * 8)\n<line133>{\n<line134>error (0, 0, _("invalid length: %s"), quote (digest_length_str));\n<line135>error (EXIT_FAILURE, 0,\n<line136>_("maximum digest length for %s is %d bits"),\n<line137>quote (DIGEST_TYPE_STRING),\n<line138>BLAKE2B_MAX_LEN * 8);\n<line139>}\n<line140>if (digest_length == 0)\n<line141>{\n<line142># if HASH_ALGO_BLAKE2\n<line143>digest_length = BLAKE2B_MAX_LEN * 8;\n<line144># else\n<line145>digest_length = algorithm_bits[cksum_algorithm];\n<line146># endif\n<line147>}\n<line148>digest_hex_bytes = digest_length / 4;\n<line149>#else\n<line150>digest_hex_bytes = DIGEST_HEX_BYTES;\n<line151>#endif\n<line152>#if HASH_ALGO_CKSUM\n<line153>switch (cksum_algorithm)\n<line154>{\n<line155>case bsd:\n<line156>case sysv:\n<line157>case crc:\n<line158>if (do_check && algorithm_specified)\n<line159>error (EXIT_FAILURE, 0,\n<line160>_("--check is not supported with --algorithm={bsd,sysv,crc}"));\n<line161>break;\n<line162>default:\n<line163>break;\n<line164>}\n<line165>if (base64_digest && raw_digest)\n<line166>{\n<line167>error (0, 0, _("--base64 and --raw are mutually exclusive"));\n<line168>usage (EXIT_FAILURE);\n<line169>}\n<line170>#endif\n<line171>if (prefix_tag && !binary)\n<line172>{\n<line173>/* This could be supported in a backwards compatible way\n<line174>by prefixing the output line with a space in text mode.\n<line175>However that's invasive enough that it was agreed to\n<line176>not support this mode with --tag, as --text use cases\n<line177>are adequately supported by the default output format.  */\n<line178>#if !HASH_ALGO_CKSUM\n<line179>error (0, 0, _("--tag does not support --text mode"));\n<line180>#else\n<line181>error (0, 0, _("--text mode is only supported with --untagged"));\n<line182>#endif\n<line183>usage (EXIT_FAILURE);\n<line184>}\n<line185>if (digest_delim != '\n' && do_check)\n<line186>{\n<line187>error (0, 0, _("the --zero option is not supported when "\n<line188>"verifying checksums"));\n<line189>usage (EXIT_FAILURE);\n<line190>}\n<line191>#if !HASH_ALGO_CKSUM\n<line192>if (prefix_tag && do_check)\n<line193>{\n<line194>error (0, 0, _("the --tag option is meaningless when "\n<line195>"verifying checksums"));\n<line196>usage (EXIT_FAILURE);\n<line197>}\n<line198>#endif\n<line199>if (0 <= binary && do_check)\n<line200>{\n<line201>error (0, 0, _("the --binary and --text options are meaningless when "\n<line202>"verifying checksums"));\n<line203>usage (EXIT_FAILURE);\n<line204>}\n<line205>if (ignore_missing && !do_check)\n<line206>{\n<line207>error (0, 0,\n<line208>_("the --ignore-missing option is meaningful only when "\n<line209>"verifying checksums"));\n<line210>usage (EXIT_FAILURE);\n<line211>}\n<line212>if (status_only && !do_check)\n<line213>{\n<line214>error (0, 0,\n<line215>_("the --status option is meaningful only when verifying checksums"));\n<line216>usage (EXIT_FAILURE);\n<line217>}\n<line218>if (warn && !do_check)\n<line219>{\n<line220>error (0, 0,\n<line221>_("the --warn option is meaningful only when verifying checksums"));\n<line222>usage (EXIT_FAILURE);\n<line223>}\n<line224>if (quiet && !do_check)\n<line225>{\n<line226>error (0, 0,\n<line227>_("the --quiet option is meaningful only when verifying checksums"));\n<line228>usage (EXIT_FAILURE);\n<line229>}\n<line230>if (strict & !do_check)\n<line231>{\n<line232>error (0, 0,\n<line233>_("the --strict option is meaningful only when verifying checksums"));\n<line234>usage (EXIT_FAILURE);\n<line235>}\n<line236>if (!O_BINARY && binary < 0)\n<line237>binary = 0;\n<line238>char **operand_lim = argv + argc;\n<line239>if (optind == argc)\n<line240>*operand_lim++ = bad_cast ("-");\n<line241>else if (1 < argc - optind && raw_digest)\n<line242>error (EXIT_FAILURE, 0,\n<line243>_("the --raw option is not supported with multiple files"));\n<line244>for (char **operandp = argv + optind; operandp < operand_lim; operandp++)\n<line245>{\n<line246>char *file = *operandp;\n<line247>if (do_check)\n<line248>ok &= digest_check (file);\n<line249>else\n<line250>{\n<line251>int binary_file = binary;\n<line252>bool missing;\n<line253>uintmax_t length;\n<line254>if (! digest_file (file, &binary_file, bin_buffer, &missing, &length))\n<line255>ok = false;\n<line256>else\n<line257>{\n<line258>DIGEST_OUT (file, binary_file, bin_buffer, raw_digest, prefix_tag,\n<line259>digest_delim, optind != argc, length);\n<line260>}\n<line261>}\n<line262>}\n<line263>if (have_read_stdin && fclose (stdin) == EOF)\n<line264>error (EXIT_FAILURE, errno, _("standard input"));\n<line265>return ok ? EXIT_SUCCESS : EXIT_FAILURE;\n<line266>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/src/mkdir.c
========================================
Function: usage
Content: <line0>void\n<line1>usage (int status)\n<line2>{\n<line3>if (status != EXIT_SUCCESS)\n<line4>emit_try_help ();\n<line5>else\n<line6>{\n<line7>printf (_("Usage: %s [OPTION]... DIRECTORY...\n"), program_name);\n<line8>fputs (_("\\n<line9>Create the DIRECTORY(ies), if they do not already exist.\n\\n<line10>"), stdout);\n<line11>emit_mandatory_arg_note ();\n<line12>fputs (_("\\n<line13>-m, --mode=MODE   set file mode (as in chmod), not a=rwx - umask\n\\n<line14>-p, --parents     no error if existing, make parent directories as needed,\n\\n<line15>with their file modes unaffected by any -m option.\n\\n<line16>-v, --verbose     print a message for each created directory\n\\n<line17>"), stdout);\n<line18>fputs (_("\\n<line19>-Z                   set SELinux security context of each created directory\n\\n<line20>to the default type\n\\n<line21>--context[=CTX]  like -Z, or if CTX is specified then set the SELinux\n\\n<line22>or SMACK security context to CTX\n\\n<line23>"), stdout);\n<line24>fputs (HELP_OPTION_DESCRIPTION, stdout);\n<line25>fputs (VERSION_OPTION_DESCRIPTION, stdout);\n<line26>emit_ancillary_info (PROGRAM_NAME);\n<line27>}\n<line28>exit (status);\n<line29>}
----------------------------------------
Function: announce_mkdir
Content: <line0>static void\n<line1>announce_mkdir (char const *dir, void *options)\n<line2>{\n<line3>struct mkdir_options const *o = options;\n<line4>if (o->created_directory_format)\n<line5>prog_fprintf (stdout, o->created_directory_format, quoteaf (dir));\n<line6>}
----------------------------------------
Function: make_ancestor
Content: <line0>static int\n<line1>make_ancestor (char const *dir, char const *component, void *options)\n<line2>{\n<line3>struct mkdir_options const *o = options;\n<line4>if (o->set_security_context\n<line5>&& defaultcon (o->set_security_context, component, S_IFDIR) < 0\n<line6>&& ! ignorable_ctx_err (errno))\n<line7>error (0, errno, _("failed to set default creation context for %s"),\n<line8>quoteaf (dir));\n<line9>if (o->umask_ancestor != o->umask_self)\n<line10>umask (o->umask_ancestor);\n<line11>int r = mkdir (component, S_IRWXUGO);\n<line12>if (o->umask_ancestor != o->umask_self)\n<line13>{\n<line14>int mkdir_errno = errno;\n<line15>umask (o->umask_self);\n<line16>errno = mkdir_errno;\n<line17>}\n<line18>if (r == 0)\n<line19>{\n<line20>r = (o->umask_ancestor & S_IRUSR) != 0;\n<line21>announce_mkdir (dir, options);\n<line22>}\n<line23>return r;\n<line24>}
----------------------------------------
Function: process_dir
Content: <line0>static int\n<line1>process_dir (char *dir, struct savewd *wd, void *options)\n<line2>{\n<line3>struct mkdir_options const *o = options;\n<line4>/* If possible set context before DIR created.  */\n<line5>if (o->set_security_context)\n<line6>{\n<line7>if (! o->make_ancestor_function\n<line8>&& defaultcon (o->set_security_context, dir, S_IFDIR) < 0\n<line9>&& ! ignorable_ctx_err (errno))\n<line10>error (0, errno, _("failed to set default creation context for %s"),\n<line11>quoteaf (dir));\n<line12>}\n<line13>int ret = (make_dir_parents (dir, wd, o->make_ancestor_function, options,\n<line14>o->mode, announce_mkdir,\n<line15>o->mode_bits, (uid_t) -1, (gid_t) -1, true)\n<line16>? EXIT_SUCCESS\n<line17>: EXIT_FAILURE);\n<line18>/* FIXME: Due to the current structure of make_dir_parents()\n<line19>we don't have the facility to call defaultcon() before the\n<line20>final component of DIR is created.  So for now, create the\n<line21>final component with the context from previous component\n<line22>and here we set the context for the final component. */\n<line23>if (ret == EXIT_SUCCESS && o->set_security_context\n<line24>&& o->make_ancestor_function)\n<line25>{\n<line26>if (! restorecon (o->set_security_context, last_component (dir), false)\n<line27>&& ! ignorable_ctx_err (errno))\n<line28>error (0, errno, _("failed to restore context for %s"),\n<line29>quoteaf (dir));\n<line30>}\n<line31>return ret;\n<line32>}
----------------------------------------
Function: main
Content: <line0>int\n<line1>main (int argc, char **argv)\n<line2>{\n<line3>char const *specified_mode = nullptr;\n<line4>int optc;\n<line5>char const *scontext = nullptr;\n<line6>struct mkdir_options options;\n<line7>options.make_ancestor_function = nullptr;\n<line8>options.mode = S_IRWXUGO;\n<line9>options.mode_bits = 0;\n<line10>options.created_directory_format = nullptr;\n<line11>options.set_security_context = nullptr;\n<line12>initialize_main (&argc, &argv);\n<line13>set_program_name (argv[0]);\n<line14>setlocale (LC_ALL, "");\n<line15>bindtextdomain (PACKAGE, LOCALEDIR);\n<line16>textdomain (PACKAGE);\n<line17>atexit (close_stdout);\n<line18>while ((optc = getopt_long (argc, argv, "pm:vZ", longopts, nullptr)) != -1)\n<line19>{\n<line20>switch (optc)\n<line21>{\n<line22>case 'p':\n<line23>options.make_ancestor_function = make_ancestor;\n<line24>break;\n<line25>case 'm':\n<line26>specified_mode = optarg;\n<line27>break;\n<line28>case 'v': /* --verbose  */\n<line29>options.created_directory_format = _("created directory %s");\n<line30>break;\n<line31>case 'Z':\n<line32>if (is_smack_enabled ())\n<line33>{\n<line34>/* We don't yet support -Z to restore context with SMACK.  */\n<line35>scontext = optarg;\n<line36>}\n<line37>else if (is_selinux_enabled () > 0)\n<line38>{\n<line39>if (optarg)\n<line40>scontext = optarg;\n<line41>else\n<line42>{\n<line43>options.set_security_context = selabel_open (SELABEL_CTX_FILE,\n<line44>nullptr, 0);\n<line45>if (! options.set_security_context)\n<line46>error (0, errno, _("warning: ignoring --context"));\n<line47>}\n<line48>}\n<line49>else if (optarg)\n<line50>{\n<line51>error (0, 0,\n<line52>_("warning: ignoring --context; "\n<line53>"it requires an SELinux/SMACK-enabled kernel"));\n<line54>}\n<line55>break;\n<line56>case_GETOPT_HELP_CHAR;\n<line57>case_GETOPT_VERSION_CHAR (PROGRAM_NAME, AUTHORS);\n<line58>default:\n<line59>usage (EXIT_FAILURE);\n<line60>}\n<line61>}\n<line62>if (optind == argc)\n<line63>{\n<line64>error (0, 0, _("missing operand"));\n<line65>usage (EXIT_FAILURE);\n<line66>}\n<line67>/* FIXME: This assumes mkdir() is done in the same process.\n<line68>If that's not always the case we would need to call this\n<line69>like we do when options.set_security_context.  */\n<line70>if (scontext)\n<line71>{\n<line72>int ret = 0;\n<line73>if (is_smack_enabled ())\n<line74>ret = smack_set_label_for_self (scontext);\n<line75>else\n<line76>ret = setfscreatecon (scontext);\n<line77>if (ret < 0)\n<line78>error (EXIT_FAILURE, errno,\n<line79>_("failed to set default file creation context to %s"),\n<line80>quote (scontext));\n<line81>}\n<line82>if (options.make_ancestor_function || specified_mode)\n<line83>{\n<line84>mode_t umask_value = umask (0);\n<line85>options.umask_ancestor = umask_value & ~(S_IWUSR | S_IXUSR);\n<line86>if (specified_mode)\n<line87>{\n<line88>struct mode_change *change = mode_compile (specified_mode);\n<line89>if (!change)\n<line90>error (EXIT_FAILURE, 0, _("invalid mode %s"),\n<line91>quote (specified_mode));\n<line92>options.mode = mode_adjust (S_IRWXUGO, true, umask_value, change,\n<line93>&options.mode_bits);\n<line94>options.umask_self = umask_value & ~options.mode;\n<line95>free (change);\n<line96>}\n<line97>else\n<line98>{\n<line99>options.mode = S_IRWXUGO;\n<line100>options.umask_self = umask_value;\n<line101>}\n<line102>umask (options.umask_self);\n<line103>}\n<line104>return savewd_process_files (argc - optind, argv + optind,\n<line105>process_dir, &options);\n<line106>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/src/mkfifo.c
========================================
Function: usage
Content: <line0>void\n<line1>usage (int status)\n<line2>{\n<line3>if (status != EXIT_SUCCESS)\n<line4>emit_try_help ();\n<line5>else\n<line6>{\n<line7>printf (_("Usage: %s [OPTION]... NAME...\n"), program_name);\n<line8>fputs (_("\\n<line9>Create named pipes (FIFOs) with the given NAMEs.\n\\n<line10>"), stdout);\n<line11>emit_mandatory_arg_note ();\n<line12>fputs (_("\\n<line13>-m, --mode=MODE    set file permission bits to MODE, not a=rw - umask\n\\n<line14>"), stdout);\n<line15>fputs (_("\\n<line16>-Z                   set the SELinux security context to default type\n\\n<line17>--context[=CTX]  like -Z, or if CTX is specified then set the SELinux\n\\n<line18>or SMACK security context to CTX\n\\n<line19>"), stdout);\n<line20>fputs (HELP_OPTION_DESCRIPTION, stdout);\n<line21>fputs (VERSION_OPTION_DESCRIPTION, stdout);\n<line22>emit_ancillary_info (PROGRAM_NAME);\n<line23>}\n<line24>exit (status);\n<line25>}
----------------------------------------
Function: main
Content: <line0>int\n<line1>main (int argc, char **argv)\n<line2>{\n<line3>mode_t newmode;\n<line4>char const *specified_mode = nullptr;\n<line5>int exit_status = EXIT_SUCCESS;\n<line6>int optc;\n<line7>char const *scontext = nullptr;\n<line8>struct selabel_handle *set_security_context = nullptr;\n<line9>initialize_main (&argc, &argv);\n<line10>set_program_name (argv[0]);\n<line11>setlocale (LC_ALL, "");\n<line12>bindtextdomain (PACKAGE, LOCALEDIR);\n<line13>textdomain (PACKAGE);\n<line14>atexit (close_stdout);\n<line15>while ((optc = getopt_long (argc, argv, "m:Z", longopts, nullptr)) != -1)\n<line16>{\n<line17>switch (optc)\n<line18>{\n<line19>case 'm':\n<line20>specified_mode = optarg;\n<line21>break;\n<line22>case 'Z':\n<line23>if (is_smack_enabled ())\n<line24>{\n<line25>/* We don't yet support -Z to restore context with SMACK.  */\n<line26>scontext = optarg;\n<line27>}\n<line28>else if (is_selinux_enabled () > 0)\n<line29>{\n<line30>if (optarg)\n<line31>scontext = optarg;\n<line32>else\n<line33>{\n<line34>set_security_context = selabel_open (SELABEL_CTX_FILE,\n<line35>nullptr, 0);\n<line36>if (! set_security_context)\n<line37>error (0, errno, _("warning: ignoring --context"));\n<line38>}\n<line39>}\n<line40>else if (optarg)\n<line41>{\n<line42>error (0, 0,\n<line43>_("warning: ignoring --context; "\n<line44>"it requires an SELinux/SMACK-enabled kernel"));\n<line45>}\n<line46>break;\n<line47>case_GETOPT_HELP_CHAR;\n<line48>case_GETOPT_VERSION_CHAR (PROGRAM_NAME, AUTHORS);\n<line49>default:\n<line50>usage (EXIT_FAILURE);\n<line51>}\n<line52>}\n<line53>if (optind == argc)\n<line54>{\n<line55>error (0, 0, _("missing operand"));\n<line56>usage (EXIT_FAILURE);\n<line57>}\n<line58>if (scontext)\n<line59>{\n<line60>int ret = 0;\n<line61>if (is_smack_enabled ())\n<line62>ret = smack_set_label_for_self (scontext);\n<line63>else\n<line64>ret = setfscreatecon (scontext);\n<line65>if (ret < 0)\n<line66>error (EXIT_FAILURE, errno,\n<line67>_("failed to set default file creation context to %s"),\n<line68>quote (scontext));\n<line69>}\n<line70>newmode = MODE_RW_UGO;\n<line71>if (specified_mode)\n<line72>{\n<line73>mode_t umask_value;\n<line74>struct mode_change *change = mode_compile (specified_mode);\n<line75>if (!change)\n<line76>error (EXIT_FAILURE, 0, _("invalid mode"));\n<line77>umask_value = umask (0);\n<line78>umask (umask_value);\n<line79>newmode = mode_adjust (newmode, false, umask_value, change, nullptr);\n<line80>free (change);\n<line81>if (newmode & ~S_IRWXUGO)\n<line82>error (EXIT_FAILURE, 0,\n<line83>_("mode must specify only file permission bits"));\n<line84>}\n<line85>for (; optind < argc; ++optind)\n<line86>{\n<line87>if (set_security_context)\n<line88>defaultcon (set_security_context, argv[optind], S_IFIFO);\n<line89>if (mkfifo (argv[optind], newmode) != 0)\n<line90>{\n<line91>error (0, errno, _("cannot create fifo %s"), quoteaf (argv[optind]));\n<line92>exit_status = EXIT_FAILURE;\n<line93>}\n<line94>else if (specified_mode && lchmod (argv[optind], newmode) != 0)\n<line95>{\n<line96>error (0, errno, _("cannot set permissions of %s"),\n<line97>quoteaf (argv[optind]));\n<line98>exit_status = EXIT_FAILURE;\n<line99>}\n<line100>}\n<line101>return exit_status;\n<line102>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/src/mknod.c
========================================
Function: usage
Content: <line0>void\n<line1>usage (int status)\n<line2>{\n<line3>if (status != EXIT_SUCCESS)\n<line4>emit_try_help ();\n<line5>else\n<line6>{\n<line7>printf (_("Usage: %s [OPTION]... NAME TYPE [MAJOR MINOR]\n"),\n<line8>program_name);\n<line9>fputs (_("\\n<line10>Create the special file NAME of the given TYPE.\n\\n<line11>"), stdout);\n<line12>emit_mandatory_arg_note ();\n<line13>fputs (_("\\n<line14>-m, --mode=MODE    set file permission bits to MODE, not a=rw - umask\n\\n<line15>"), stdout);\n<line16>fputs (_("\\n<line17>-Z                   set the SELinux security context to default type\n\\n<line18>--context[=CTX]  like -Z, or if CTX is specified then set the SELinux\n\\n<line19>or SMACK security context to CTX\n\\n<line20>"), stdout);\n<line21>fputs (HELP_OPTION_DESCRIPTION, stdout);\n<line22>fputs (VERSION_OPTION_DESCRIPTION, stdout);\n<line23>fputs (_("\\n<line24>\n\\n<line25>Both MAJOR and MINOR must be specified when TYPE is b, c, or u, and they\n\\n<line26>must be omitted when TYPE is p.  If MAJOR or MINOR begins with 0x or 0X,\n\\n<line27>it is interpreted as hexadecimal; otherwise, if it begins with 0, as octal;\n\\n<line28>otherwise, as decimal.  TYPE may be:\n\\n<line29>"), stdout);\n<line30>fputs (_("\\n<line31>\n\\n<line32>b      create a block (buffered) special file\n\\n<line33>c, u   create a character (unbuffered) special file\n\\n<line34>p      create a FIFO\n\\n<line35>"), stdout);\n<line36>printf (USAGE_BUILTIN_WARNING, PROGRAM_NAME);\n<line37>emit_ancillary_info (PROGRAM_NAME);\n<line38>}\n<line39>exit (status);\n<line40>}
----------------------------------------
Function: main
Content: <line0>int\n<line1>main (int argc, char **argv)\n<line2>{\n<line3>mode_t newmode;\n<line4>char const *specified_mode = nullptr;\n<line5>int optc;\n<line6>size_t expected_operands;\n<line7>mode_t node_type;\n<line8>char const *scontext = nullptr;\n<line9>struct selabel_handle *set_security_context = nullptr;\n<line10>initialize_main (&argc, &argv);\n<line11>set_program_name (argv[0]);\n<line12>setlocale (LC_ALL, "");\n<line13>bindtextdomain (PACKAGE, LOCALEDIR);\n<line14>textdomain (PACKAGE);\n<line15>atexit (close_stdout);\n<line16>while ((optc = getopt_long (argc, argv, "m:Z", longopts, nullptr)) != -1)\n<line17>{\n<line18>switch (optc)\n<line19>{\n<line20>case 'm':\n<line21>specified_mode = optarg;\n<line22>break;\n<line23>case 'Z':\n<line24>if (is_smack_enabled ())\n<line25>{\n<line26>/* We don't yet support -Z to restore context with SMACK.  */\n<line27>scontext = optarg;\n<line28>}\n<line29>else if (is_selinux_enabled () > 0)\n<line30>{\n<line31>if (optarg)\n<line32>scontext = optarg;\n<line33>else\n<line34>{\n<line35>set_security_context = selabel_open (SELABEL_CTX_FILE,\n<line36>nullptr, 0);\n<line37>if (! set_security_context)\n<line38>error (0, errno, _("warning: ignoring --context"));\n<line39>}\n<line40>}\n<line41>else if (optarg)\n<line42>{\n<line43>error (0, 0,\n<line44>_("warning: ignoring --context; "\n<line45>"it requires an SELinux/SMACK-enabled kernel"));\n<line46>}\n<line47>break;\n<line48>case_GETOPT_HELP_CHAR;\n<line49>case_GETOPT_VERSION_CHAR (PROGRAM_NAME, AUTHORS);\n<line50>default:\n<line51>usage (EXIT_FAILURE);\n<line52>}\n<line53>}\n<line54>newmode = MODE_RW_UGO;\n<line55>if (specified_mode)\n<line56>{\n<line57>mode_t umask_value;\n<line58>struct mode_change *change = mode_compile (specified_mode);\n<line59>if (!change)\n<line60>error (EXIT_FAILURE, 0, _("invalid mode"));\n<line61>umask_value = umask (0);\n<line62>umask (umask_value);\n<line63>newmode = mode_adjust (newmode, false, umask_value, change, nullptr);\n<line64>free (change);\n<line65>if (newmode & ~S_IRWXUGO)\n<line66>error (EXIT_FAILURE, 0,\n<line67>_("mode must specify only file permission bits"));\n<line68>}\n<line69>/* If the number of arguments is 0 or 1,\n<line70>or (if it's 2 or more and the second one starts with 'p'), then there\n<line71>must be exactly two operands.  Otherwise, there must be four.  */\n<line72>expected_operands = (argc <= optind\n<line73>|| (optind + 1 < argc && argv[optind + 1][0] == 'p')\n<line74>? 2 : 4);\n<line75>if (argc - optind < expected_operands)\n<line76>{\n<line77>if (argc <= optind)\n<line78>error (0, 0, _("missing operand"));\n<line79>else\n<line80>error (0, 0, _("missing operand after %s"), quote (argv[argc - 1]));\n<line81>if (expected_operands == 4 && argc - optind == 2)\n<line82>fprintf (stderr, "%s\n",\n<line83>_("Special files require major and minor device numbers."));\n<line84>usage (EXIT_FAILURE);\n<line85>}\n<line86>if (expected_operands < argc - optind)\n<line87>{\n<line88>error (0, 0, _("extra operand %s"),\n<line89>quote (argv[optind + expected_operands]));\n<line90>if (expected_operands == 2 && argc - optind == 4)\n<line91>fprintf (stderr, "%s\n",\n<line92>_("Fifos do not have major and minor device numbers."));\n<line93>usage (EXIT_FAILURE);\n<line94>}\n<line95>if (scontext)\n<line96>{\n<line97>int ret = 0;\n<line98>if (is_smack_enabled ())\n<line99>ret = smack_set_label_for_self (scontext);\n<line100>else\n<line101>ret = setfscreatecon (scontext);\n<line102>if (ret < 0)\n<line103>error (EXIT_FAILURE, errno,\n<line104>_("failed to set default file creation context to %s"),\n<line105>quote (scontext));\n<line106>}\n<line107>/* Only check the first character, to allow mnemonic usage like\n<line108>'mknod /dev/rst0 character 18 0'. */\n<line109>switch (argv[optind + 1][0])\n<line110>{\n<line111>case 'b':			/* 'block' or 'buffered' */\n<line112>#ifndef S_IFBLK\n<line113>error (EXIT_FAILURE, 0, _("block special files not supported"));\n<line114>#else\n<line115>node_type = S_IFBLK;\n<line116>#endif\n<line117>goto block_or_character;\n<line118>case 'c':			/* 'character' */\n<line119>case 'u':			/* 'unbuffered' */\n<line120>#ifndef S_IFCHR\n<line121>error (EXIT_FAILURE, 0, _("character special files not supported"));\n<line122>#else\n<line123>node_type = S_IFCHR;\n<line124>#endif\n<line125>goto block_or_character;\n<line126>block_or_character:\n<line127>{\n<line128>char const *s_major = argv[optind + 2];\n<line129>char const *s_minor = argv[optind + 3];\n<line130>uintmax_t i_major, i_minor;\n<line131>dev_t device;\n<line132>if (xstrtoumax (s_major, nullptr, 0, &i_major, "") != LONGINT_OK\n<line133>|| i_major != (major_t) i_major)\n<line134>error (EXIT_FAILURE, 0,\n<line135>_("invalid major device number %s"), quote (s_major));\n<line136>if (xstrtoumax (s_minor, nullptr, 0, &i_minor, "") != LONGINT_OK\n<line137>|| i_minor != (minor_t) i_minor)\n<line138>error (EXIT_FAILURE, 0,\n<line139>_("invalid minor device number %s"), quote (s_minor));\n<line140>device = makedev (i_major, i_minor);\n<line141>#ifdef NODEV\n<line142>if (device == NODEV)\n<line143>error (EXIT_FAILURE, 0, _("invalid device %s %s"),\n<line144>s_major, s_minor);\n<line145>#endif\n<line146>if (set_security_context)\n<line147>defaultcon (set_security_context, argv[optind], node_type);\n<line148>if (mknod (argv[optind], newmode | node_type, device) != 0)\n<line149>error (EXIT_FAILURE, errno, "%s", quotef (argv[optind]));\n<line150>}\n<line151>break;\n<line152>case 'p':			/* 'pipe' */\n<line153>if (set_security_context)\n<line154>defaultcon (set_security_context, argv[optind], S_IFIFO);\n<line155>if (mkfifo (argv[optind], newmode) != 0)\n<line156>error (EXIT_FAILURE, errno, "%s", quotef (argv[optind]));\n<line157>break;\n<line158>default:\n<line159>error (0, 0, _("invalid device type %s"), quote (argv[optind + 1]));\n<line160>usage (EXIT_FAILURE);\n<line161>}\n<line162>if (specified_mode && lchmod (argv[optind], newmode) != 0)\n<line163>error (EXIT_FAILURE, errno, _("cannot set permissions of %s"),\n<line164>quoteaf (argv[optind]));\n<line165>return EXIT_SUCCESS;\n<line166>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/src/mktemp.c
========================================
Function: usage
Content: <line0>void\n<line1>usage (int status)\n<line2>{\n<line3>if (status != EXIT_SUCCESS)\n<line4>emit_try_help ();\n<line5>else\n<line6>{\n<line7>printf (_("Usage: %s [OPTION]... [TEMPLATE]\n"), program_name);\n<line8>fputs (_("\\n<line9>Create a temporary file or directory, safely, and print its name.\n\\n<line10>TEMPLATE must contain at least 3 consecutive 'X's in last component.\n\\n<line11>If TEMPLATE is not specified, use tmp.XXXXXXXXXX, and --tmpdir is implied.\n\\n<line12>"), stdout);\n<line13>fputs (_("\\n<line14>Files are created u+rw, and directories u+rwx, minus umask restrictions.\n\\n<line15>"), stdout);\n<line16>fputs ("\n", stdout);\n<line17>fputs (_("\\n<line18>-d, --directory     create a directory, not a file\n\\n<line19>-u, --dry-run       do not create anything; merely print a name (unsafe)\n\\n<line20>-q, --quiet         suppress diagnostics about file/dir-creation failure\n\\n<line21>"), stdout);\n<line22>fputs (_("\\n<line23>--suffix=SUFF   append SUFF to TEMPLATE; SUFF must not contain a slash.\n\\n<line24>This option is implied if TEMPLATE does not end in X\n\\n<line25>"), stdout);\n<line26>fputs (_("\\n<line27>-p DIR, --tmpdir[=DIR]  interpret TEMPLATE relative to DIR; if DIR is not\n\\n<line28>specified, use $TMPDIR if set, else /tmp.  With\n\\n<line29>this option, TEMPLATE must not be an absolute name;\n\\n<line30>unlike with -t, TEMPLATE may contain slashes, but\n\\n<line31>mktemp creates only the final component\n\\n<line32>"), stdout);\n<line33>fputs (_("\\n<line34>-t                  interpret TEMPLATE as a single file name component,\n\\n<line35>relative to a directory: $TMPDIR, if set; else the\n\\n<line36>directory specified via -p; else /tmp [deprecated]\n\\n<line37>"), stdout);\n<line38>fputs (HELP_OPTION_DESCRIPTION, stdout);\n<line39>fputs (VERSION_OPTION_DESCRIPTION, stdout);\n<line40>emit_ancillary_info (PROGRAM_NAME);\n<line41>}\n<line42>exit (status);\n<line43>}
----------------------------------------
Function: count_consecutive_X_s
Content: <line0>static size_t\n<line1>count_consecutive_X_s (char const *s, size_t len)\n<line2>{\n<line3>size_t n = 0;\n<line4>for ( ; len && s[len - 1] == 'X'; len--)\n<line5>++n;\n<line6>return n;\n<line7>}
----------------------------------------
Function: mkstemp_len
Content: <line0>static int\n<line1>mkstemp_len (char *tmpl, size_t suff_len, size_t x_len, bool dry_run)\n<line2>{\n<line3>return gen_tempname_len (tmpl, suff_len, 0, dry_run ? GT_NOCREATE : GT_FILE,\n<line4>x_len);\n<line5>}
----------------------------------------
Function: mkdtemp_len
Content: <line0>static int\n<line1>mkdtemp_len (char *tmpl, size_t suff_len, size_t x_len, bool dry_run)\n<line2>{\n<line3>return gen_tempname_len (tmpl, suff_len, 0, dry_run ? GT_NOCREATE : GT_DIR,\n<line4>x_len);\n<line5>}
----------------------------------------
Function: maybe_close_stdout
Content: <line0>static void\n<line1>maybe_close_stdout (void)\n<line2>{\n<line3>if (!stdout_closed)\n<line4>close_stdout ();\n<line5>else if (close_stream (stderr) != 0)\n<line6>_exit (EXIT_FAILURE);\n<line7>}
----------------------------------------
Function: main
Content: <line0>int\n<line1>main (int argc, char **argv)\n<line2>{\n<line3>char const *dest_dir;\n<line4>char const *dest_dir_arg = nullptr;\n<line5>bool suppress_file_err = false;\n<line6>int c;\n<line7>char *template;\n<line8>char *suffix = nullptr;\n<line9>bool use_dest_dir = false;\n<line10>bool deprecated_t_option = false;\n<line11>bool create_directory = false;\n<line12>bool dry_run = false;\n<line13>int status = EXIT_SUCCESS;\n<line14>size_t x_count;\n<line15>size_t suffix_len;\n<line16>char *dest_name;\n<line17>initialize_main (&argc, &argv);\n<line18>set_program_name (argv[0]);\n<line19>setlocale (LC_ALL, "");\n<line20>bindtextdomain (PACKAGE, LOCALEDIR);\n<line21>textdomain (PACKAGE);\n<line22>atexit (maybe_close_stdout);\n<line23>while ((c = getopt_long (argc, argv, "dp:qtuV", longopts, nullptr)) != -1)\n<line24>{\n<line25>switch (c)\n<line26>{\n<line27>case 'd':\n<line28>create_directory = true;\n<line29>break;\n<line30>case 'p':\n<line31>dest_dir_arg = optarg;\n<line32>use_dest_dir = true;\n<line33>break;\n<line34>case 'q':\n<line35>suppress_file_err = true;\n<line36>break;\n<line37>case 't':\n<line38>use_dest_dir = true;\n<line39>deprecated_t_option = true;\n<line40>break;\n<line41>case 'u':\n<line42>dry_run = true;\n<line43>break;\n<line44>case SUFFIX_OPTION:\n<line45>suffix = optarg;\n<line46>break;\n<line47>case_GETOPT_HELP_CHAR;\n<line48>case 'V': /* Undocumented alias, for compatibility with the original\n<line49>mktemp program.  */\n<line50>case_GETOPT_VERSION_CHAR (PROGRAM_NAME, AUTHORS);\n<line51>default:\n<line52>usage (EXIT_FAILURE);\n<line53>}\n<line54>}\n<line55>int n_args = argc - optind;\n<line56>if (2 <= n_args)\n<line57>{\n<line58>error (0, 0, _("too many templates"));\n<line59>usage (EXIT_FAILURE);\n<line60>}\n<line61>if (n_args == 0)\n<line62>{\n<line63>use_dest_dir = true;\n<line64>template = (char *) default_template;\n<line65>}\n<line66>else\n<line67>{\n<line68>template = argv[optind];\n<line69>}\n<line70>if (suffix)\n<line71>{\n<line72>size_t len = strlen (template);\n<line73>if (!len || template[len - 1] != 'X')\n<line74>{\n<line75>error (EXIT_FAILURE, 0,\n<line76>_("with --suffix, template %s must end in X"),\n<line77>quote (template));\n<line78>}\n<line79>suffix_len = strlen (suffix);\n<line80>dest_name = xcharalloc (len + suffix_len + 1);\n<line81>memcpy (dest_name, template, len);\n<line82>memcpy (dest_name + len, suffix, suffix_len + 1);\n<line83>template = dest_name;\n<line84>suffix = dest_name + len;\n<line85>}\n<line86>else\n<line87>{\n<line88>template = xstrdup (template);\n<line89>suffix = strrchr (template, 'X');\n<line90>if (!suffix)\n<line91>suffix = strchr (template, '\0');\n<line92>else\n<line93>suffix++;\n<line94>suffix_len = strlen (suffix);\n<line95>}\n<line96>/* At this point, template is malloc'd, and suffix points into template.  */\n<line97>if (suffix_len && last_component (suffix) != suffix)\n<line98>{\n<line99>error (EXIT_FAILURE, 0,\n<line100>_("invalid suffix %s, contains directory separator"),\n<line101>quote (suffix));\n<line102>}\n<line103>x_count = count_consecutive_X_s (template, suffix - template);\n<line104>if (x_count < 3)\n<line105>error (EXIT_FAILURE, 0, _("too few X's in template %s"), quote (template));\n<line106>if (use_dest_dir)\n<line107>{\n<line108>if (deprecated_t_option)\n<line109>{\n<line110>char *env = getenv ("TMPDIR");\n<line111>if (env && *env)\n<line112>dest_dir = env;\n<line113>else if (dest_dir_arg && *dest_dir_arg)\n<line114>dest_dir = dest_dir_arg;\n<line115>else\n<line116>dest_dir = "/tmp";\n<line117>if (last_component (template) != template)\n<line118>error (EXIT_FAILURE, 0,\n<line119>_("invalid template, %s, contains directory separator"),\n<line120>quote (template));\n<line121>}\n<line122>else\n<line123>{\n<line124>if (dest_dir_arg && *dest_dir_arg)\n<line125>dest_dir = dest_dir_arg;\n<line126>else\n<line127>{\n<line128>char *env = getenv ("TMPDIR");\n<line129>dest_dir = (env && *env ? env : "/tmp");\n<line130>}\n<line131>if (IS_ABSOLUTE_FILE_NAME (template))\n<line132>error (EXIT_FAILURE, 0,\n<line133>_("invalid template, %s; with --tmpdir,"\n<line134>" it may not be absolute"),\n<line135>quote (template));\n<line136>}\n<line137>dest_name = file_name_concat (dest_dir, template, nullptr);\n<line138>free (template);\n<line139>template = dest_name;\n<line140>/* Note that suffix is now invalid.  */\n<line141>}\n<line142>/* Make a copy to be used in case of diagnostic, since failing\n<line143>mkstemp may leave the buffer in an undefined state.  */\n<line144>dest_name = xstrdup (template);\n<line145>if (create_directory)\n<line146>{\n<line147>int err = mkdtemp_len (dest_name, suffix_len, x_count, dry_run);\n<line148>if (err != 0)\n<line149>{\n<line150>if (!suppress_file_err)\n<line151>error (0, errno, _("failed to create directory via template %s"),\n<line152>quote (template));\n<line153>status = EXIT_FAILURE;\n<line154>}\n<line155>}\n<line156>else\n<line157>{\n<line158>int fd = mkstemp_len (dest_name, suffix_len, x_count, dry_run);\n<line159>if (fd < 0 || (!dry_run && close (fd) != 0))\n<line160>{\n<line161>if (!suppress_file_err)\n<line162>error (0, errno, _("failed to create file via template %s"),\n<line163>quote (template));\n<line164>status = EXIT_FAILURE;\n<line165>}\n<line166>}\n<line167>if (status == EXIT_SUCCESS)\n<line168>{\n<line169>puts (dest_name);\n<line170>/* If we created a file, but then failed to output the file\n<line171>name, we should clean up the mess before failing.  */\n<line172>if (!dry_run && ((stdout_closed = true), close_stream (stdout) != 0))\n<line173>{\n<line174>int saved_errno = errno;\n<line175>remove (dest_name);\n<line176>if (!suppress_file_err)\n<line177>error (0, saved_errno, _("write error"));\n<line178>status = EXIT_FAILURE;\n<line179>}\n<line180>}\n<line181>main_exit (status);\n<line182>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/src/mv.c
========================================
/home/huihui/Downloads/coreutils-9.4/src/mv.c:63:1: warning: '_Static_assert' with no message is a C2x extension [-Wc2x-extensions]
ARGMATCH_VERIFY (update_type_string, update_type);
^
./lib/argmatch.h:49:54: note: expanded from macro 'ARGMATCH_VERIFY'
                   == ARRAY_CARDINALITY (Vallist) + 1)
                                                     ^
1 warning generated.
Function: rm_option_init
Content: <line0>static void\n<line1>rm_option_init (struct rm_options *x)\n<line2>{\n<line3>x->ignore_missing_files = false;\n<line4>x->remove_empty_directories = true;\n<line5>x->recursive = true;\n<line6>x->one_file_system = false;\n<line7>/* Should we prompt for removal, too?  No.  Prompting for the 'move'\n<line8>part is enough.  It implies removal.  */\n<line9>x->interactive = RMI_NEVER;\n<line10>x->stdin_tty = false;\n<line11>x->verbose = false;\n<line12>/* Since this program may well have to process additional command\n<line13>line arguments after any call to 'rm', that function must preserve\n<line14>the initial working directory, in case one of those is a\n<line15>'.'-relative name.  */\n<line16>x->require_restore_cwd = true;\n<line17>{\n<line18>static struct dev_ino dev_ino_buf;\n<line19>x->root_dev_ino = get_root_dev_ino (&dev_ino_buf);\n<line20>if (x->root_dev_ino == nullptr)\n<line21>error (EXIT_FAILURE, errno, _("failed to get attributes of %s"),\n<line22>quoteaf ("/"));\n<line23>}\n<line24>x->preserve_all_root = false;\n<line25>}
----------------------------------------
Function: cp_option_init
Content: <line0>static void\n<line1>cp_option_init (struct cp_options *x)\n<line2>{\n<line3>bool selinux_enabled = (0 < is_selinux_enabled ());\n<line4>cp_options_default (x);\n<line5>x->copy_as_regular = false;  /* FIXME: maybe make this an option */\n<line6>x->reflink_mode = REFLINK_AUTO;\n<line7>x->dereference = DEREF_NEVER;\n<line8>x->unlink_dest_before_opening = false;\n<line9>x->unlink_dest_after_failed_open = false;\n<line10>x->hard_link = false;\n<line11>x->interactive = I_UNSPECIFIED;\n<line12>x->move_mode = true;\n<line13>x->install_mode = false;\n<line14>x->one_file_system = false;\n<line15>x->preserve_ownership = true;\n<line16>x->preserve_links = true;\n<line17>x->preserve_mode = true;\n<line18>x->preserve_timestamps = true;\n<line19>x->explicit_no_preserve_mode= false;\n<line20>x->preserve_security_context = selinux_enabled;\n<line21>x->set_security_context = nullptr;\n<line22>x->reduce_diagnostics = false;\n<line23>x->data_copy_required = true;\n<line24>x->require_preserve = false;  /* FIXME: maybe make this an option */\n<line25>x->require_preserve_context = false;\n<line26>x->preserve_xattr = true;\n<line27>x->require_preserve_xattr = false;\n<line28>x->recursive = true;\n<line29>x->sparse_mode = SPARSE_AUTO;  /* FIXME: maybe make this an option */\n<line30>x->symbolic_link = false;\n<line31>x->set_mode = false;\n<line32>x->mode = 0;\n<line33>x->stdin_tty = isatty (STDIN_FILENO);\n<line34>x->open_dangling_dest_symlink = false;\n<line35>x->update = false;\n<line36>x->verbose = false;\n<line37>x->dest_info = nullptr;\n<line38>x->src_info = nullptr;\n<line39>}
----------------------------------------
Function: do_move
Content: <line0>static bool\n<line1>do_move (char const *source, char const *dest,\n<line2>int dest_dirfd, char const *dest_relname, const struct cp_options *x)\n<line3>{\n<line4>bool copy_into_self;\n<line5>bool rename_succeeded;\n<line6>bool ok = copy (source, dest, dest_dirfd, dest_relname, 0, x,\n<line7>&copy_into_self, &rename_succeeded);\n<line8>if (ok)\n<line9>{\n<line10>char const *dir_to_remove;\n<line11>if (copy_into_self)\n<line12>{\n<line13>/* In general, when copy returns with copy_into_self set, SOURCE is\n<line14>the same as, or a parent of DEST.  In this case we know it's a\n<line15>parent.  It doesn't make sense to move a directory into itself, and\n<line16>besides in some situations doing so would give highly unintuitive\n<line17>results.  Run this 'mkdir b; touch a c; mv * b' in an empty\n<line18>directory.  Here's the result of running echo $(find b -print):\n<line19>b b/a b/b b/b/a b/c.  Notice that only file 'a' was copied\n<line20>into b/b.  Handle this by giving a diagnostic, removing the\n<line21>copied-into-self directory, DEST ('b/b' in the example),\n<line22>and failing.  */\n<line23>dir_to_remove = nullptr;\n<line24>ok = false;\n<line25>}\n<line26>else if (rename_succeeded)\n<line27>{\n<line28>/* No need to remove anything.  SOURCE was successfully\n<line29>renamed to DEST.  Or the user declined to rename a file.  */\n<line30>dir_to_remove = nullptr;\n<line31>}\n<line32>else\n<line33>{\n<line34>/* This may mean SOURCE and DEST referred to different devices.\n<line35>It may also conceivably mean that even though they referred\n<line36>to the same device, rename wasn't implemented for that device.\n<line37>E.g., (from Joel N. Weber),\n<line38>[...] there might someday be cases where you can't rename\n<line39>but you can copy where the device name is the same, especially\n<line40>on Hurd.  Consider an ftpfs with a primitive ftp server that\n<line41>supports uploading, downloading and deleting, but not renaming.\n<line42>Also, note that comparing device numbers is not a reliable\n<line43>check for 'can-rename'.  Some systems can be set up so that\n<line44>files from many different physical devices all have the same\n<line45>st_dev field.  This is a feature of some NFS mounting\n<line46>configurations.\n<line47>We reach this point if SOURCE has been successfully copied\n<line48>to DEST.  Now we have to remove SOURCE.\n<line49>This function used to resort to copying only when rename\n<line50>failed and set errno to EXDEV.  */\n<line51>dir_to_remove = source;\n<line52>}\n<line53>if (dir_to_remove != nullptr)\n<line54>{\n<line55>struct rm_options rm_options;\n<line56>enum RM_status status;\n<line57>char const *dir[2];\n<line58>rm_option_init (&rm_options);\n<line59>rm_options.verbose = x->verbose;\n<line60>dir[0] = dir_to_remove;\n<line61>dir[1] = nullptr;\n<line62>status = rm ((void *) dir, &rm_options);\n<line63>affirm (VALID_STATUS (status));\n<line64>if (status == RM_ERROR)\n<line65>ok = false;\n<line66>}\n<line67>}\n<line68>return ok;\n<line69>}
----------------------------------------
Function: usage
Content: <line0>void\n<line1>usage (int status)\n<line2>{\n<line3>if (status != EXIT_SUCCESS)\n<line4>emit_try_help ();\n<line5>else\n<line6>{\n<line7>printf (_("\\n<line8>Usage: %s [OPTION]... [-T] SOURCE DEST\n\\n<line9>or:  %s [OPTION]... SOURCE... DIRECTORY\n\\n<line10>or:  %s [OPTION]... -t DIRECTORY SOURCE...\n\\n<line11>"),\n<line12>program_name, program_name, program_name);\n<line13>fputs (_("\\n<line14>Rename SOURCE to DEST, or move SOURCE(s) to DIRECTORY.\n\\n<line15>"), stdout);\n<line16>emit_mandatory_arg_note ();\n<line17>fputs (_("\\n<line18>--backup[=CONTROL]       make a backup of each existing destination file\\n<line19>\n\\n<line20>-b                           like --backup but does not accept an argument\n\\n<line21>"), stdout);\n<line22>fputs (_("\\n<line23>--debug                  explain how a file is copied.  Implies -v\n\\n<line24>"), stdout);\n<line25>fputs (_("\\n<line26>-f, --force                  do not prompt before overwriting\n\\n<line27>-i, --interactive            prompt before overwrite\n\\n<line28>-n, --no-clobber             do not overwrite an existing file\n\\n<line29>If you specify more than one of -i, -f, -n, only the final one takes effect.\n\\n<line30>"), stdout);\n<line31>fputs (_("\\n<line32>--no-copy                do not copy if renaming fails\n\\n<line33>--strip-trailing-slashes  remove any trailing slashes from each SOURCE\n\\n<line34>argument\n\\n<line35>-S, --suffix=SUFFIX          override the usual backup suffix\n\\n<line36>"), stdout);\n<line37>fputs (_("\\n<line38>-t, --target-directory=DIRECTORY  move all SOURCE arguments into DIRECTORY\n\\n<line39>-T, --no-target-directory    treat DEST as a normal file\n\\n<line40>"), stdout);\n<line41>fputs (_("\\n<line42>--update[=UPDATE]            control which existing files are updated;\n\\n<line43>UPDATE={all,none,older(default)}.  See below\n\\n<line44>-u                           equivalent to --update[=older]\n\\n<line45>"), stdout);\n<line46>fputs (_("\\n<line47>-v, --verbose                explain what is being done\n\\n<line48>-Z, --context                set SELinux security context of destination\n\\n<line49>file to default type\n\\n<line50>"), stdout);\n<line51>fputs (HELP_OPTION_DESCRIPTION, stdout);\n<line52>fputs (VERSION_OPTION_DESCRIPTION, stdout);\n<line53>emit_update_parameters_note ();\n<line54>emit_backup_suffix_note ();\n<line55>emit_ancillary_info (PROGRAM_NAME);\n<line56>}\n<line57>exit (status);\n<line58>}
----------------------------------------
Function: main
Content: <line0>int\n<line1>main (int argc, char **argv)\n<line2>{\n<line3>int c;\n<line4>bool ok;\n<line5>bool make_backups = false;\n<line6>char const *backup_suffix = nullptr;\n<line7>char *version_control_string = nullptr;\n<line8>struct cp_options x;\n<line9>bool remove_trailing_slashes = false;\n<line10>char const *target_directory = nullptr;\n<line11>bool no_target_directory = false;\n<line12>int n_files;\n<line13>char **file;\n<line14>bool selinux_enabled = (0 < is_selinux_enabled ());\n<line15>initialize_main (&argc, &argv);\n<line16>set_program_name (argv[0]);\n<line17>setlocale (LC_ALL, "");\n<line18>bindtextdomain (PACKAGE, LOCALEDIR);\n<line19>textdomain (PACKAGE);\n<line20>atexit (close_stdin);\n<line21>cp_option_init (&x);\n<line22>/* Try to disable the ability to unlink a directory.  */\n<line23>priv_set_remove_linkdir ();\n<line24>while ((c = getopt_long (argc, argv, "bfint:uvS:TZ", long_options, nullptr))\n<line25>!= -1)\n<line26>{\n<line27>switch (c)\n<line28>{\n<line29>case 'b':\n<line30>make_backups = true;\n<line31>if (optarg)\n<line32>version_control_string = optarg;\n<line33>break;\n<line34>case 'f':\n<line35>x.interactive = I_ALWAYS_YES;\n<line36>break;\n<line37>case 'i':\n<line38>x.interactive = I_ASK_USER;\n<line39>break;\n<line40>case 'n':\n<line41>x.interactive = I_ALWAYS_NO;\n<line42>break;\n<line43>case DEBUG_OPTION:\n<line44>x.debug = x.verbose = true;\n<line45>break;\n<line46>case NO_COPY_OPTION:\n<line47>x.no_copy = true;\n<line48>break;\n<line49>case STRIP_TRAILING_SLASHES_OPTION:\n<line50>remove_trailing_slashes = true;\n<line51>break;\n<line52>case 't':\n<line53>if (target_directory)\n<line54>error (EXIT_FAILURE, 0, _("multiple target directories specified"));\n<line55>target_directory = optarg;\n<line56>break;\n<line57>case 'T':\n<line58>no_target_directory = true;\n<line59>break;\n<line60>case 'u':\n<line61>if (optarg == nullptr)\n<line62>x.update = true;\n<line63>else if (x.interactive != I_ALWAYS_NO)  /* -n takes precedence.  */\n<line64>{\n<line65>enum Update_type update_opt;\n<line66>update_opt = XARGMATCH ("--update", optarg,\n<line67>update_type_string, update_type);\n<line68>if (update_opt == UPDATE_ALL)\n<line69>{\n<line70>/* Default mv operation.  */\n<line71>x.update = false;\n<line72>x.interactive = I_UNSPECIFIED;\n<line73>}\n<line74>else if (update_opt == UPDATE_NONE)\n<line75>{\n<line76>x.update = false;\n<line77>x.interactive = I_ALWAYS_SKIP;\n<line78>}\n<line79>else if (update_opt == UPDATE_OLDER)\n<line80>{\n<line81>x.update = true;\n<line82>x.interactive = I_UNSPECIFIED;\n<line83>}\n<line84>}\n<line85>break;\n<line86>case 'v':\n<line87>x.verbose = true;\n<line88>break;\n<line89>case 'S':\n<line90>make_backups = true;\n<line91>backup_suffix = optarg;\n<line92>break;\n<line93>case 'Z':\n<line94>/* As a performance enhancement, don't even bother trying\n<line95>to "restorecon" when not on an selinux-enabled kernel.  */\n<line96>if (selinux_enabled)\n<line97>{\n<line98>x.preserve_security_context = false;\n<line99>x.set_security_context = selabel_open (SELABEL_CTX_FILE,\n<line100>nullptr, 0);\n<line101>if (! x.set_security_context)\n<line102>error (0, errno, _("warning: ignoring --context"));\n<line103>}\n<line104>break;\n<line105>case_GETOPT_HELP_CHAR;\n<line106>case_GETOPT_VERSION_CHAR (PROGRAM_NAME, AUTHORS);\n<line107>default:\n<line108>usage (EXIT_FAILURE);\n<line109>}\n<line110>}\n<line111>n_files = argc - optind;\n<line112>file = argv + optind;\n<line113>if (n_files <= !target_directory)\n<line114>{\n<line115>if (n_files <= 0)\n<line116>error (0, 0, _("missing file operand"));\n<line117>else\n<line118>error (0, 0, _("missing destination file operand after %s"),\n<line119>quoteaf (file[0]));\n<line120>usage (EXIT_FAILURE);\n<line121>}\n<line122>struct stat sb;\n<line123>sb.st_mode = 0;\n<line124>int target_dirfd = AT_FDCWD;\n<line125>if (no_target_directory)\n<line126>{\n<line127>if (target_directory)\n<line128>error (EXIT_FAILURE, 0,\n<line129>_("cannot combine --target-directory (-t) "\n<line130>"and --no-target-directory (-T)"));\n<line131>if (2 < n_files)\n<line132>{\n<line133>error (0, 0, _("extra operand %s"), quoteaf (file[2]));\n<line134>usage (EXIT_FAILURE);\n<line135>}\n<line136>}\n<line137>else if (target_directory)\n<line138>{\n<line139>target_dirfd = target_directory_operand (target_directory, &sb);\n<line140>if (! target_dirfd_valid (target_dirfd))\n<line141>error (EXIT_FAILURE, errno, _("target directory %s"),\n<line142>quoteaf (target_directory));\n<line143>}\n<line144>else\n<line145>{\n<line146>char const *lastfile = file[n_files - 1];\n<line147>if (n_files == 2)\n<line148>x.rename_errno = (renameatu (AT_FDCWD, file[0], AT_FDCWD, lastfile,\n<line149>RENAME_NOREPLACE)\n<line150>? errno : 0);\n<line151>if (x.rename_errno != 0)\n<line152>{\n<line153>int fd = target_directory_operand (lastfile, &sb);\n<line154>if (target_dirfd_valid (fd))\n<line155>{\n<line156>x.rename_errno = -1;\n<line157>target_dirfd = fd;\n<line158>target_directory = lastfile;\n<line159>n_files--;\n<line160>}\n<line161>else\n<line162>{\n<line163>/* The last operand LASTFILE cannot be opened as a directory.\n<line164>If there are more than two operands, report an error.\n<line165>Also, report an error if LASTFILE is known to be a directory\n<line166>even though it could not be opened, which can happen if\n<line167>opening failed with EACCES on a platform lacking O_PATH.\n<line168>In this case use stat to test whether LASTFILE is a\n<line169>directory, in case opening a non-directory with (O_SEARCH\n<line170>| O_DIRECTORY) failed with EACCES not ENOTDIR.  */\n<line171>int err = errno;\n<line172>if (2 < n_files\n<line173>|| (O_PATHSEARCH == O_SEARCH && err == EACCES\n<line174>&& (sb.st_mode != 0 || stat (lastfile, &sb) == 0)\n<line175>&& S_ISDIR (sb.st_mode)))\n<line176>error (EXIT_FAILURE, err, _("target %s"), quoteaf (lastfile));\n<line177>}\n<line178>}\n<line179>}\n<line180>/* Handle the ambiguity in the semantics of mv induced by the\n<line181>varying semantics of the rename function.  POSIX-compatible\n<line182>systems (e.g., GNU/Linux) have a rename function that honors a\n<line183>trailing slash in the source, while others (Solaris 9, FreeBSD\n<line184>7.2) have a rename function that ignores it.  */\n<line185>if (remove_trailing_slashes)\n<line186>for (int i = 0; i < n_files; i++)\n<line187>strip_trailing_slashes (file[i]);\n<line188>if (x.interactive == I_ALWAYS_NO)\n<line189>x.update = false;\n<line190>if (make_backups && x.interactive == I_ALWAYS_NO)\n<line191>{\n<line192>error (0, 0,\n<line193>_("options --backup and --no-clobber are mutually exclusive"));\n<line194>usage (EXIT_FAILURE);\n<line195>}\n<line196>x.backup_type = (make_backups\n<line197>? xget_version (_("backup type"),\n<line198>version_control_string)\n<line199>: no_backups);\n<line200>set_simple_backup_suffix (backup_suffix);\n<line201>hash_init ();\n<line202>if (target_directory)\n<line203>{\n<line204>/* Initialize the hash table only if we'll need it.\n<line205>The problem it is used to detect can arise only if there are\n<line206>two or more files to move.  */\n<line207>if (2 <= n_files)\n<line208>dest_info_init (&x);\n<line209>ok = true;\n<line210>for (int i = 0; i < n_files; ++i)\n<line211>{\n<line212>x.last_file = i + 1 == n_files;\n<line213>char const *source = file[i];\n<line214>char const *source_basename = last_component (source);\n<line215>char *dest_relname;\n<line216>char *dest = file_name_concat (target_directory, source_basename,\n<line217>&dest_relname);\n<line218>strip_trailing_slashes (dest_relname);\n<line219>ok &= do_move (source, dest, target_dirfd, dest_relname, &x);\n<line220>free (dest);\n<line221>}\n<line222>}\n<line223>else\n<line224>{\n<line225>x.last_file = true;\n<line226>ok = do_move (file[0], file[1], AT_FDCWD, file[1], &x);\n<line227>}\n<line228>main_exit (ok ? EXIT_SUCCESS : EXIT_FAILURE);\n<line229>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/src/remove.c
========================================
In file included from /home/huihui/Downloads/coreutils-9.4/src/remove.c:32:
In file included from ./lib/xfts.h:1:
In file included from ./lib/fts_.h:83:
./lib/i-ring.h:24:32: warning: '_Static_assert' with no message is a C2x extension [-Wc2x-extensions]
static_assert (1 <= I_RING_SIZE);
                               ^
                               , ""
1 warning generated.
Function: cache_fstatat
Content: <line0>static int\n<line1>cache_fstatat (int fd, char const *file, struct stat *st, int flag)\n<line2>{\n<line3>#if HAVE_STRUCT_STAT_ST_ATIM_TV_NSEC\n<line4>/* If ST->st_atim.tv_nsec is -1, the status has not been gotten yet.\n<line5>If less than -1, fstatat failed with errno == ST->st_ino.\n<line6>Otherwise, the status has already been gotten, so return 0.  */\n<line7>if (0 <= st->st_atim.tv_nsec)\n<line8>return 0;\n<line9>if (st->st_atim.tv_nsec == -1)\n<line10>{\n<line11>if (fstatat (fd, file, st, flag) == 0)\n<line12>return 0;\n<line13>st->st_atim.tv_nsec = -2;\n<line14>st->st_ino = errno;\n<line15>}\n<line16>errno = st->st_ino;\n<line17>return -1;\n<line18>#else\n<line19>return fstatat (fd, file, st, flag);\n<line20>#endif\n<line21>}
----------------------------------------
Function: cache_stat_init
Content: <line0>static inline struct stat *\n<line1>cache_stat_init (struct stat *st)\n<line2>{\n<line3>#if HAVE_STRUCT_STAT_ST_ATIM_TV_NSEC\n<line4>st->st_atim.tv_nsec = -1;\n<line5>#endif\n<line6>return st;\n<line7>}
----------------------------------------
Function: write_protected_non_symlink
Content: <line0>static int\n<line1>write_protected_non_symlink (int fd_cwd,\n<line2>char const *file,\n<line3>struct stat *buf)\n<line4>{\n<line5>if (can_write_any_file ())\n<line6>return 0;\n<line7>if (cache_fstatat (fd_cwd, file, buf, AT_SYMLINK_NOFOLLOW) != 0)\n<line8>return -1;\n<line9>if (S_ISLNK (buf->st_mode))\n<line10>return 0;\n<line11>/* Here, we know FILE is not a symbolic link.  */\n<line12>/* In order to be reentrant -- i.e., to avoid changing the working\n<line13>directory, and at the same time to be able to deal with alternate\n<line14>access control mechanisms (ACLs, xattr-style attributes) and\n<line15>arbitrarily deep trees -- we need a function like eaccessat, i.e.,\n<line16>like Solaris' eaccess, but fd-relative, in the spirit of openat.  */\n<line17>/* In the absence of a native eaccessat function, here are some of\n<line18>the implementation choices [#4 and #5 were suggested by Paul Eggert]:\n<line19>1) call openat with O_WRONLY|O_NOCTTY\n<line20>Disadvantage: may create the file and doesn't work for directory,\n<line21>may mistakenly report 'unwritable' for EROFS or ACLs even though\n<line22>perm bits say the file is writable.\n<line23>2) fake eaccessat (save_cwd, fchdir, call euidaccess, restore_cwd)\n<line24>Disadvantage: changes working directory (not reentrant) and can't\n<line25>work if save_cwd fails.\n<line26>3) if (euidaccess (full_name, W_OK) == 0)\n<line27>Disadvantage: doesn't work if full_name is too long.\n<line28>Inefficient for very deep trees (O(Depth^2)).\n<line29>4) If the full pathname is sufficiently short (say, less than\n<line30>PATH_MAX or 8192 bytes, whichever is shorter):\n<line31>use method (3) (i.e., euidaccess (full_name, W_OK));\n<line32>Otherwise: vfork, fchdir in the child, run euidaccess in the\n<line33>child, then the child exits with a status that tells the parent\n<line34>whether euidaccess succeeded.\n<line35>This avoids the O(N**2) algorithm of method (3), and it also avoids\n<line36>the failure-due-to-too-long-file-names of method (3), but it's fast\n<line37>in the normal shallow case.  It also avoids the lack-of-reentrancy\n<line38>and the save_cwd problems.\n<line39>Disadvantage; it uses a process slot for very-long file names,\n<line40>and would be very slow for hierarchies with many such files.\n<line41>5) If the full file name is sufficiently short (say, less than\n<line42>PATH_MAX or 8192 bytes, whichever is shorter):\n<line43>use method (3) (i.e., euidaccess (full_name, W_OK));\n<line44>Otherwise: look just at the file bits.  Perhaps issue a warning\n<line45>the first time this occurs.\n<line46>This is like (4), except for the "Otherwise" case where it isn't as\n<line47>"perfect" as (4) but is considerably faster.  It conforms to current\n<line48>POSIX, and is uniformly better than what Solaris and FreeBSD do (they\n<line49>mess up with long file names). */\n<line50>{\n<line51>if (faccessat (fd_cwd, file, W_OK, AT_EACCESS) == 0)\n<line52>return 0;\n<line53>return errno == EACCES ? 1 : -1;\n<line54>}\n<line55>}
----------------------------------------
Function: get_dir_status
Content: <line0>static int\n<line1>get_dir_status (FTS const *fts, FTSENT const *ent, int *dir_status)\n<line2>{\n<line3>if (*dir_status == DS_UNKNOWN)\n<line4>*dir_status = directory_status (fts->fts_cwd_fd, ent->fts_accpath);\n<line5>return *dir_status;\n<line6>}
----------------------------------------
Function: prompt
Content: <line0>static enum RM_status\n<line1>prompt (FTS const *fts, FTSENT const *ent, bool is_dir,\n<line2>struct rm_options const *x, enum Prompt_action mode,\n<line3>int *dir_status)\n<line4>{\n<line5>int fd_cwd = fts->fts_cwd_fd;\n<line6>char const *full_name = ent->fts_path;\n<line7>char const *filename = ent->fts_accpath;\n<line8>struct stat st;\n<line9>struct stat *sbuf = &st;\n<line10>cache_stat_init (sbuf);\n<line11>int dirent_type = is_dir ? DT_DIR : DT_UNKNOWN;\n<line12>int write_protected = 0;\n<line13>/* When nonzero, this indicates that we failed to remove a child entry,\n<line14>either because the user declined an interactive prompt, or due to\n<line15>some other failure, like permissions.  */\n<line16>if (ent->fts_number)\n<line17>return RM_USER_DECLINED;\n<line18>if (x->interactive == RMI_NEVER)\n<line19>return RM_OK;\n<line20>int wp_errno = 0;\n<line21>if (!x->ignore_missing_files\n<line22>&& (x->interactive == RMI_ALWAYS || x->stdin_tty)\n<line23>&& dirent_type != DT_LNK)\n<line24>{\n<line25>write_protected = write_protected_non_symlink (fd_cwd, filename, sbuf);\n<line26>wp_errno = errno;\n<line27>}\n<line28>if (write_protected || x->interactive == RMI_ALWAYS)\n<line29>{\n<line30>if (0 <= write_protected && dirent_type == DT_UNKNOWN)\n<line31>{\n<line32>if (cache_fstatat (fd_cwd, filename, sbuf, AT_SYMLINK_NOFOLLOW) == 0)\n<line33>{\n<line34>if (S_ISLNK (sbuf->st_mode))\n<line35>dirent_type = DT_LNK;\n<line36>else if (S_ISDIR (sbuf->st_mode))\n<line37>dirent_type = DT_DIR;\n<line38>/* Otherwise it doesn't matter, so leave it DT_UNKNOWN.  */\n<line39>}\n<line40>else\n<line41>{\n<line42>/* This happens, e.g., with 'rm '''.  */\n<line43>write_protected = -1;\n<line44>wp_errno = errno;\n<line45>}\n<line46>}\n<line47>if (0 <= write_protected)\n<line48>switch (dirent_type)\n<line49>{\n<line50>case DT_LNK:\n<line51>/* Using permissions doesn't make sense for symlinks.  */\n<line52>if (x->interactive != RMI_ALWAYS)\n<line53>return RM_OK;\n<line54>break;\n<line55>case DT_DIR:\n<line56>/* Unless we're either deleting directories or deleting\n<line57>recursively, we want to raise an EISDIR error rather than\n<line58>prompting the user  */\n<line59>if ( ! (x->recursive\n<line60>|| (x->remove_empty_directories\n<line61>&& get_dir_status (fts, ent, dir_status) != 0)))\n<line62>{\n<line63>write_protected = -1;\n<line64>wp_errno = *dir_status <= 0 ? EISDIR : *dir_status;\n<line65>}\n<line66>break;\n<line67>}\n<line68>char const *quoted_name = quoteaf (full_name);\n<line69>if (write_protected < 0)\n<line70>{\n<line71>error (0, wp_errno, _("cannot remove %s"), quoted_name);\n<line72>return RM_ERROR;\n<line73>}\n<line74>/* Issue the prompt.  */\n<line75>if (dirent_type == DT_DIR\n<line76>&& mode == PA_DESCEND_INTO_DIR\n<line77>&& get_dir_status (fts, ent, dir_status) == DS_NONEMPTY)\n<line78>fprintf (stderr,\n<line79>(write_protected\n<line80>? _("%s: descend into write-protected directory %s? ")\n<line81>: _("%s: descend into directory %s? ")),\n<line82>program_name, quoted_name);\n<line83>else if (0 < *dir_status)\n<line84>{\n<line85>if ( ! (x->remove_empty_directories && *dir_status == EACCES))\n<line86>{\n<line87>error (0, *dir_status, _("cannot remove %s"), quoted_name);\n<line88>return RM_ERROR;\n<line89>}\n<line90>/* The following code can lead to a successful deletion only with\n<line91>the --dir (-d) option (remove_empty_directories) and an empty\n<line92>inaccessible directory. In the first prompt call for a directory,\n<line93>we'd normally ask whether to descend into it, but in this case\n<line94>(it's inaccessible), that is not possible, so don't prompt.  */\n<line95>if (mode == PA_DESCEND_INTO_DIR)\n<line96>return RM_OK;\n<line97>fprintf (stderr,\n<line98>_("%s: attempt removal of inaccessible directory %s? "),\n<line99>program_name, quoted_name);\n<line100>}\n<line101>else\n<line102>{\n<line103>if (cache_fstatat (fd_cwd, filename, sbuf, AT_SYMLINK_NOFOLLOW) != 0)\n<line104>{\n<line105>error (0, errno, _("cannot remove %s"), quoted_name);\n<line106>return RM_ERROR;\n<line107>}\n<line108>fprintf (stderr,\n<line109>(write_protected\n<line110>/* TRANSLATORS: In the next two strings the second %s is\n<line111>replaced by the type of the file.  To avoid grammatical\n<line112>problems, it may be more convenient to translate these\n<line113>strings instead as: "%1$s: %3$s is write-protected and\n<line114>is of type '%2$s' -- remove it? ".  */\n<line115>? _("%s: remove write-protected %s %s? ")\n<line116>: _("%s: remove %s %s? ")),\n<line117>program_name, file_type (sbuf), quoted_name);\n<line118>}\n<line119>return yesno () ? RM_USER_ACCEPTED : RM_USER_DECLINED;\n<line120>}\n<line121>return RM_OK;\n<line122>}
----------------------------------------
Function: nonexistent_file_errno
Content: <line0>static inline bool\n<line1>nonexistent_file_errno (int errnum)\n<line2>{\n<line3>/* Do not include ELOOP here, since the specified file may indeed\n<line4>exist, but be (in)accessible only via too long a symlink chain.\n<line5>Likewise for ENAMETOOLONG, since rm -f ./././.../foo may fail\n<line6>if the "..." part expands to a long enough sequence of "./"s,\n<line7>even though ./foo does indeed exist.\n<line8>Another case to consider is when a particular name is invalid for\n<line9>a given file system.  In 2011, smbfs returns EINVAL, but the next\n<line10>revision of POSIX will require EILSEQ for that situation:\n<line11>https://austingroupbugs.net/view.php?id=293\n<line12>*/\n<line13>switch (errnum)\n<line14>{\n<line15>case EILSEQ:\n<line16>case EINVAL:\n<line17>case ENOENT:\n<line18>case ENOTDIR:\n<line19>return true;\n<line20>default:\n<line21>return false;\n<line22>}\n<line23>}
----------------------------------------
Function: ignorable_missing
Content: <line0>static inline bool\n<line1>ignorable_missing (struct rm_options const *x, int errnum)\n<line2>{\n<line3>return x->ignore_missing_files && nonexistent_file_errno (errnum);\n<line4>}
----------------------------------------
Function: fts_skip_tree
Content: <line0>static void\n<line1>fts_skip_tree (FTS *fts, FTSENT *ent)\n<line2>{\n<line3>fts_set (fts, ent, FTS_SKIP);\n<line4>/* Ensure that we do not process ENT a second time.  */\n<line5>ignore_value (fts_read (fts));\n<line6>}
----------------------------------------
Function: mark_ancestor_dirs
Content: <line0>static void\n<line1>mark_ancestor_dirs (FTSENT *ent)\n<line2>{\n<line3>FTSENT *p;\n<line4>for (p = ent->fts_parent; FTS_ROOTLEVEL <= p->fts_level; p = p->fts_parent)\n<line5>{\n<line6>if (p->fts_number)\n<line7>break;\n<line8>p->fts_number = 1;\n<line9>}\n<line10>}
----------------------------------------
Function: excise
Content: <line0>static enum RM_status\n<line1>excise (FTS *fts, FTSENT *ent, struct rm_options const *x, bool is_dir)\n<line2>{\n<line3>int flag = is_dir ? AT_REMOVEDIR : 0;\n<line4>if (unlinkat (fts->fts_cwd_fd, ent->fts_accpath, flag) == 0)\n<line5>{\n<line6>if (x->verbose)\n<line7>{\n<line8>printf ((is_dir\n<line9>? _("removed directory %s\n")\n<line10>: _("removed %s\n")), quoteaf (ent->fts_path));\n<line11>}\n<line12>return RM_OK;\n<line13>}\n<line14>/* The unlinkat from kernels like linux-2.6.32 reports EROFS even for\n<line15>nonexistent files.  When the file is indeed missing, map that to ENOENT,\n<line16>so that rm -f ignores it, as required.  Even without -f, this is useful\n<line17>because it makes rm print the more precise diagnostic.  */\n<line18>if (errno == EROFS)\n<line19>{\n<line20>struct stat st;\n<line21>if ( ! (fstatat (fts->fts_cwd_fd, ent->fts_accpath, &st,\n<line22>AT_SYMLINK_NOFOLLOW)\n<line23>&& errno == ENOENT))\n<line24>errno = EROFS;\n<line25>}\n<line26>if (ignorable_missing (x, errno))\n<line27>return RM_OK;\n<line28>/* When failing to rmdir an unreadable directory, we see errno values\n<line29>like EISDIR or ENOTDIR (or, on Solaris 10, EEXIST), but they would be\n<line30>meaningless in a diagnostic.  When that happens, use the earlier, more\n<line31>descriptive errno value.  */\n<line32>if (ent->fts_info == FTS_DNR\n<line33>&& (errno == ENOTEMPTY || errno == EISDIR || errno == ENOTDIR\n<line34>|| errno == EEXIST)\n<line35>&& ent->fts_errno != 0)\n<line36>errno = ent->fts_errno;\n<line37>error (0, errno, _("cannot remove %s"), quoteaf (ent->fts_path));\n<line38>mark_ancestor_dirs (ent);\n<line39>return RM_ERROR;\n<line40>}
----------------------------------------
Function: rm_fts
Content: <line0>static enum RM_status\n<line1>rm_fts (FTS *fts, FTSENT *ent, struct rm_options const *x)\n<line2>{\n<line3>int dir_status = DS_UNKNOWN;\n<line4>switch (ent->fts_info)\n<line5>{\n<line6>case FTS_D:			/* preorder directory */\n<line7>if (! x->recursive\n<line8>&& !(x->remove_empty_directories\n<line9>&& get_dir_status (fts, ent, &dir_status) != 0))\n<line10>{\n<line11>/* This is the first (pre-order) encounter with a directory\n<line12>that we cannot delete.\n<line13>Not recursive, and it's not an empty directory (if we're removing\n<line14>them) so arrange to skip contents.  */\n<line15>int err = x->remove_empty_directories ? ENOTEMPTY : EISDIR;\n<line16>error (0, err, _("cannot remove %s"), quoteaf (ent->fts_path));\n<line17>mark_ancestor_dirs (ent);\n<line18>fts_skip_tree (fts, ent);\n<line19>return RM_ERROR;\n<line20>}\n<line21>/* Perform checks that can apply only for command-line arguments.  */\n<line22>if (ent->fts_level == FTS_ROOTLEVEL)\n<line23>{\n<line24>/* POSIX says:\n<line25>If the basename of a command line argument is "." or "..",\n<line26>diagnose it and do nothing more with that argument.  */\n<line27>if (dot_or_dotdot (last_component (ent->fts_accpath)))\n<line28>{\n<line29>error (0, 0,\n<line30>_("refusing to remove %s or %s directory: skipping %s"),\n<line31>quoteaf_n (0, "."), quoteaf_n (1, ".."),\n<line32>quoteaf_n (2, ent->fts_path));\n<line33>fts_skip_tree (fts, ent);\n<line34>return RM_ERROR;\n<line35>}\n<line36>/* POSIX also says:\n<line37>If a command line argument resolves to "/" (and --preserve-root\n<line38>is in effect -- default) diagnose and skip it.  */\n<line39>if (ROOT_DEV_INO_CHECK (x->root_dev_ino, ent->fts_statp))\n<line40>{\n<line41>ROOT_DEV_INO_WARN (ent->fts_path);\n<line42>fts_skip_tree (fts, ent);\n<line43>return RM_ERROR;\n<line44>}\n<line45>/* If a command line argument is a mount point and\n<line46>--preserve-root=all is in effect, diagnose and skip it.\n<line47>This doesn't handle "/", but that's handled above.  */\n<line48>if (x->preserve_all_root)\n<line49>{\n<line50>bool failed = false;\n<line51>char *parent = file_name_concat (ent->fts_accpath, "..", nullptr);\n<line52>struct stat statbuf;\n<line53>if (!parent || lstat (parent, &statbuf))\n<line54>{\n<line55>error (0, 0,\n<line56>_("failed to stat %s: skipping %s"),\n<line57>quoteaf_n (0, parent),\n<line58>quoteaf_n (1, ent->fts_accpath));\n<line59>failed = true;\n<line60>}\n<line61>free (parent);\n<line62>if (failed || fts->fts_dev != statbuf.st_dev)\n<line63>{\n<line64>if (! failed)\n<line65>{\n<line66>error (0, 0,\n<line67>_("skipping %s, since it's on a different device"),\n<line68>quoteaf (ent->fts_path));\n<line69>error (0, 0, _("and --preserve-root=all is in effect"));\n<line70>}\n<line71>fts_skip_tree (fts, ent);\n<line72>return RM_ERROR;\n<line73>}\n<line74>}\n<line75>}\n<line76>{\n<line77>enum RM_status s = prompt (fts, ent, true /*is_dir*/, x,\n<line78>PA_DESCEND_INTO_DIR, &dir_status);\n<line79>if (s == RM_USER_ACCEPTED && dir_status == DS_EMPTY)\n<line80>{\n<line81>/* When we know (from prompt when in interactive mode)\n<line82>that this is an empty directory, don't prompt twice.  */\n<line83>s = excise (fts, ent, x, true);\n<line84>if (s == RM_OK)\n<line85>fts_skip_tree (fts, ent);\n<line86>}\n<line87>if (! (s == RM_OK || s == RM_USER_ACCEPTED))\n<line88>{\n<line89>mark_ancestor_dirs (ent);\n<line90>fts_skip_tree (fts, ent);\n<line91>}\n<line92>return s;\n<line93>}\n<line94>case FTS_F:			/* regular file */\n<line95>case FTS_NS:		/* stat(2) failed */\n<line96>case FTS_SL:		/* symbolic link */\n<line97>case FTS_SLNONE:		/* symbolic link without target */\n<line98>case FTS_DP:		/* postorder directory */\n<line99>case FTS_DNR:		/* unreadable directory */\n<line100>case FTS_NSOK:		/* e.g., dangling symlink */\n<line101>case FTS_DEFAULT:		/* none of the above */\n<line102>{\n<line103>/* With --one-file-system, do not attempt to remove a mount point.\n<line104>fts' FTS_XDEV ensures that we don't process any entries under\n<line105>the mount point.  */\n<line106>if (ent->fts_info == FTS_DP\n<line107>&& x->one_file_system\n<line108>&& FTS_ROOTLEVEL < ent->fts_level\n<line109>&& ent->fts_statp->st_dev != fts->fts_dev)\n<line110>{\n<line111>mark_ancestor_dirs (ent);\n<line112>error (0, 0, _("skipping %s, since it's on a different device"),\n<line113>quoteaf (ent->fts_path));\n<line114>return RM_ERROR;\n<line115>}\n<line116>bool is_dir = ent->fts_info == FTS_DP || ent->fts_info == FTS_DNR;\n<line117>enum RM_status s = prompt (fts, ent, is_dir, x, PA_REMOVE_DIR,\n<line118>&dir_status);\n<line119>if (! (s == RM_OK || s == RM_USER_ACCEPTED))\n<line120>return s;\n<line121>return excise (fts, ent, x, is_dir);\n<line122>}\n<line123>case FTS_DC:		/* directory that causes cycles */\n<line124>emit_cycle_warning (ent->fts_path);\n<line125>fts_skip_tree (fts, ent);\n<line126>return RM_ERROR;\n<line127>case FTS_ERR:\n<line128>/* Various failures, from opendir to ENOMEM, to failure to "return"\n<line129>to preceding directory, can provoke this.  */\n<line130>error (0, ent->fts_errno, _("traversal failed: %s"),\n<line131>quotef (ent->fts_path));\n<line132>fts_skip_tree (fts, ent);\n<line133>return RM_ERROR;\n<line134>default:\n<line135>error (0, 0, _("unexpected failure: fts_info=%d: %s\n"\n<line136>"please report to %s"),\n<line137>ent->fts_info,\n<line138>quotef (ent->fts_path),\n<line139>PACKAGE_BUGREPORT);\n<line140>abort ();\n<line141>}\n<line142>}
----------------------------------------
Function: rm
Content: <line0>enum RM_status\n<line1>rm (char *const *file, struct rm_options const *x)\n<line2>{\n<line3>enum RM_status rm_status = RM_OK;\n<line4>if (*file)\n<line5>{\n<line6>int bit_flags = (FTS_CWDFD\n<line7>| FTS_NOSTAT\n<line8>| FTS_PHYSICAL);\n<line9>if (x->one_file_system)\n<line10>bit_flags |= FTS_XDEV;\n<line11>FTS *fts = xfts_open (file, bit_flags, nullptr);\n<line12>while (true)\n<line13>{\n<line14>FTSENT *ent;\n<line15>ent = fts_read (fts);\n<line16>if (ent == nullptr)\n<line17>{\n<line18>if (errno != 0)\n<line19>{\n<line20>error (0, errno, _("fts_read failed"));\n<line21>rm_status = RM_ERROR;\n<line22>}\n<line23>break;\n<line24>}\n<line25>enum RM_status s = rm_fts (fts, ent, x);\n<line26>affirm (VALID_STATUS (s));\n<line27>UPDATE_STATUS (rm_status, s);\n<line28>}\n<line29>if (fts_close (fts) != 0)\n<line30>{\n<line31>error (0, errno, _("fts_close failed"));\n<line32>rm_status = RM_ERROR;\n<line33>}\n<line34>}\n<line35>return rm_status;\n<line36>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/src/nl.c
========================================
Function: usage
Content: <line0>void\n<line1>usage (int status)\n<line2>{\n<line3>if (status != EXIT_SUCCESS)\n<line4>emit_try_help ();\n<line5>else\n<line6>{\n<line7>printf (_("\\n<line8>Usage: %s [OPTION]... [FILE]...\n\\n<line9>"),\n<line10>program_name);\n<line11>fputs (_("\\n<line12>Write each FILE to standard output, with line numbers added.\n\\n<line13>"), stdout);\n<line14>emit_stdin_note ();\n<line15>emit_mandatory_arg_note ();\n<line16>fputs (_("\\n<line17>-b, --body-numbering=STYLE      use STYLE for numbering body lines\n\\n<line18>-d, --section-delimiter=CC      use CC for logical page delimiters\n\\n<line19>-f, --footer-numbering=STYLE    use STYLE for numbering footer lines\n\\n<line20>"), stdout);\n<line21>fputs (_("\\n<line22>-h, --header-numbering=STYLE    use STYLE for numbering header lines\n\\n<line23>-i, --line-increment=NUMBER     line number increment at each line\n\\n<line24>-l, --join-blank-lines=NUMBER   group of NUMBER empty lines counted as one\n\\n<line25>-n, --number-format=FORMAT      insert line numbers according to FORMAT\n\\n<line26>-p, --no-renumber               do not reset line numbers for each section\n\\n<line27>-s, --number-separator=STRING   add STRING after (possible) line number\n\\n<line28>"), stdout);\n<line29>fputs (_("\\n<line30>-v, --starting-line-number=NUMBER  first line number for each section\n\\n<line31>-w, --number-width=NUMBER       use NUMBER columns for line numbers\n\\n<line32>"), stdout);\n<line33>fputs (HELP_OPTION_DESCRIPTION, stdout);\n<line34>fputs (VERSION_OPTION_DESCRIPTION, stdout);\n<line35>fputs (_("\\n<line36>\n\\n<line37>Default options are: -bt -d'\\:' -fn -hn -i1 -l1 -n'rn' -s<TAB> -v1 -w6\n\\n<line38>\n\\n<line39>CC are two delimiter characters used to construct logical page delimiters;\n\\n<line40>a missing second character implies ':'.  As a GNU extension one can specify\n\\n<line41>more than two characters, and also specifying the empty string (-d '')\n\\n<line42>disables section matching.\n\\n<line43>"), stdout);\n<line44>fputs (_("\\n<line45>\n\\n<line46>STYLE is one of:\n\\n<line47>\n\\n<line48>a      number all lines\n\\n<line49>t      number only nonempty lines\n\\n<line50>n      number no lines\n\\n<line51>pBRE   number only lines that contain a match for the basic regular\n\\n<line52>expression, BRE\n\\n<line53>"), stdout);\n<line54>fputs (_("\\n<line55>\n\\n<line56>FORMAT is one of:\n\\n<line57>\n\\n<line58>ln     left justified, no leading zeros\n\\n<line59>rn     right justified, no leading zeros\n\\n<line60>rz     right justified, leading zeros\n\\n<line61>\n\\n<line62>"), stdout);\n<line63>emit_ancillary_info (PROGRAM_NAME);\n<line64>}\n<line65>exit (status);\n<line66>}
----------------------------------------
Function: build_type_arg
Content: <line0>static bool\n<line1>build_type_arg (char const **typep,\n<line2>struct re_pattern_buffer *regexp, char *fastmap)\n<line3>{\n<line4>char const *errmsg;\n<line5>bool rval = true;\n<line6>switch (*optarg)\n<line7>{\n<line8>case 'a':\n<line9>case 't':\n<line10>case 'n':\n<line11>*typep = optarg;\n<line12>break;\n<line13>case 'p':\n<line14>*typep = optarg++;\n<line15>regexp->buffer = nullptr;\n<line16>regexp->allocated = 0;\n<line17>regexp->fastmap = fastmap;\n<line18>regexp->translate = nullptr;\n<line19>re_syntax_options =\n<line20>RE_SYNTAX_POSIX_BASIC & ~RE_CONTEXT_INVALID_DUP & ~RE_NO_EMPTY_RANGES;\n<line21>errmsg = re_compile_pattern (optarg, strlen (optarg), regexp);\n<line22>if (errmsg)\n<line23>error (EXIT_FAILURE, 0, "%s", (errmsg));\n<line24>break;\n<line25>default:\n<line26>rval = false;\n<line27>break;\n<line28>}\n<line29>return rval;\n<line30>}
----------------------------------------
Function: print_lineno
Content: <line0>static void\n<line1>print_lineno (void)\n<line2>{\n<line3>if (line_no_overflow)\n<line4>error (EXIT_FAILURE, 0, _("line number overflow"));\n<line5>printf (lineno_format, lineno_width, line_no, separator_str);\n<line6>if (ckd_add (&line_no, line_no, page_incr))\n<line7>line_no_overflow = true;\n<line8>}
----------------------------------------
Function: reset_lineno
Content: <line0>static void\n<line1>reset_lineno (void)\n<line2>{\n<line3>if (reset_numbers)\n<line4>{\n<line5>line_no = starting_line_number;\n<line6>line_no_overflow = false;\n<line7>}\n<line8>}
----------------------------------------
Function: proc_header
Content: <line0>static void\n<line1>proc_header (void)\n<line2>{\n<line3>current_type = header_type;\n<line4>current_regex = &header_regex;\n<line5>reset_lineno ();\n<line6>putchar ('\n');\n<line7>}
----------------------------------------
Function: proc_body
Content: <line0>static void\n<line1>proc_body (void)\n<line2>{\n<line3>current_type = body_type;\n<line4>current_regex = &body_regex;\n<line5>reset_lineno ();\n<line6>putchar ('\n');\n<line7>}
----------------------------------------
Function: proc_footer
Content: <line0>static void\n<line1>proc_footer (void)\n<line2>{\n<line3>current_type = footer_type;\n<line4>current_regex = &footer_regex;\n<line5>reset_lineno ();\n<line6>putchar ('\n');\n<line7>}
----------------------------------------
Function: proc_text
Content: <line0>static void\n<line1>proc_text (void)\n<line2>{\n<line3>static intmax_t blank_lines = 0;	/* Consecutive blank lines so far. */\n<line4>switch (*current_type)\n<line5>{\n<line6>case 'a':\n<line7>if (blank_join > 1)\n<line8>{\n<line9>if (1 < line_buf.length || ++blank_lines == blank_join)\n<line10>{\n<line11>print_lineno ();\n<line12>blank_lines = 0;\n<line13>}\n<line14>else\n<line15>fputs (print_no_line_fmt, stdout);\n<line16>}\n<line17>else\n<line18>print_lineno ();\n<line19>break;\n<line20>case 't':\n<line21>if (1 < line_buf.length)\n<line22>print_lineno ();\n<line23>else\n<line24>fputs (print_no_line_fmt, stdout);\n<line25>break;\n<line26>case 'n':\n<line27>fputs (print_no_line_fmt, stdout);\n<line28>break;\n<line29>case 'p':\n<line30>switch (re_search (current_regex, line_buf.buffer, line_buf.length - 1,\n<line31>0, line_buf.length - 1, nullptr))\n<line32>{\n<line33>case -2:\n<line34>error (EXIT_FAILURE, errno, _("error in regular expression search"));\n<line35>case -1:\n<line36>fputs (print_no_line_fmt, stdout);\n<line37>break;\n<line38>default:\n<line39>print_lineno ();\n<line40>break;\n<line41>}\n<line42>}\n<line43>fwrite (line_buf.buffer, sizeof (char), line_buf.length, stdout);\n<line44>}
----------------------------------------
Function: check_section
Content: <line0>static enum section\n<line1>check_section (void)\n<line2>{\n<line3>size_t len = line_buf.length - 1;\n<line4>if (len < 2 || footer_del_len < 2\n<line5>|| memcmp (line_buf.buffer, section_del, 2))\n<line6>return Text;\n<line7>if (len == header_del_len\n<line8>&& !memcmp (line_buf.buffer, header_del, header_del_len))\n<line9>return Header;\n<line10>if (len == body_del_len\n<line11>&& !memcmp (line_buf.buffer, body_del, body_del_len))\n<line12>return Body;\n<line13>if (len == footer_del_len\n<line14>&& !memcmp (line_buf.buffer, footer_del, footer_del_len))\n<line15>return Footer;\n<line16>return Text;\n<line17>}
----------------------------------------
Function: process_file
Content: <line0>static void\n<line1>process_file (FILE *fp)\n<line2>{\n<line3>while (readlinebuffer (&line_buf, fp))\n<line4>{\n<line5>switch (check_section ())\n<line6>{\n<line7>case Header:\n<line8>proc_header ();\n<line9>break;\n<line10>case Body:\n<line11>proc_body ();\n<line12>break;\n<line13>case Footer:\n<line14>proc_footer ();\n<line15>break;\n<line16>case Text:\n<line17>proc_text ();\n<line18>break;\n<line19>}\n<line20>}\n<line21>}
----------------------------------------
Function: nl_file
Content: <line0>static bool\n<line1>nl_file (char const *file)\n<line2>{\n<line3>FILE *stream;\n<line4>if (STREQ (file, "-"))\n<line5>{\n<line6>have_read_stdin = true;\n<line7>stream = stdin;\n<line8>assume (stream);  /* Pacify GCC bug#109613.  */\n<line9>}\n<line10>else\n<line11>{\n<line12>stream = fopen (file, "r");\n<line13>if (stream == nullptr)\n<line14>{\n<line15>error (0, errno, "%s", quotef (file));\n<line16>return false;\n<line17>}\n<line18>}\n<line19>fadvise (stream, FADVISE_SEQUENTIAL);\n<line20>process_file (stream);\n<line21>int err = errno;\n<line22>if (!ferror (stream))\n<line23>err = 0;\n<line24>if (STREQ (file, "-"))\n<line25>clearerr (stream);		/* Also clear EOF. */\n<line26>else if (fclose (stream) != 0 && !err)\n<line27>err = errno;\n<line28>if (err)\n<line29>{\n<line30>error (0, err, "%s", quotef (file));\n<line31>return false;\n<line32>}\n<line33>return true;\n<line34>}
----------------------------------------
Function: main
Content: <line0>int\n<line1>main (int argc, char **argv)\n<line2>{\n<line3>int c;\n<line4>size_t len;\n<line5>bool ok = true;\n<line6>initialize_main (&argc, &argv);\n<line7>set_program_name (argv[0]);\n<line8>setlocale (LC_ALL, "");\n<line9>bindtextdomain (PACKAGE, LOCALEDIR);\n<line10>textdomain (PACKAGE);\n<line11>atexit (close_stdout);\n<line12>have_read_stdin = false;\n<line13>while ((c = getopt_long (argc, argv, "h:b:f:v:i:pl:s:w:n:d:", longopts,\n<line14>nullptr))\n<line15>!= -1)\n<line16>{\n<line17>switch (c)\n<line18>{\n<line19>case 'h':\n<line20>if (! build_type_arg (&header_type, &header_regex, header_fastmap))\n<line21>{\n<line22>error (0, 0, _("invalid header numbering style: %s"),\n<line23>quote (optarg));\n<line24>ok = false;\n<line25>}\n<line26>break;\n<line27>case 'b':\n<line28>if (! build_type_arg (&body_type, &body_regex, body_fastmap))\n<line29>{\n<line30>error (0, 0, _("invalid body numbering style: %s"),\n<line31>quote (optarg));\n<line32>ok = false;\n<line33>}\n<line34>break;\n<line35>case 'f':\n<line36>if (! build_type_arg (&footer_type, &footer_regex, footer_fastmap))\n<line37>{\n<line38>error (0, 0, _("invalid footer numbering style: %s"),\n<line39>quote (optarg));\n<line40>ok = false;\n<line41>}\n<line42>break;\n<line43>case 'v':\n<line44>starting_line_number = xdectoimax (optarg, INTMAX_MIN, INTMAX_MAX, "",\n<line45>_("invalid starting line number"),\n<line46>0);\n<line47>break;\n<line48>case 'i':\n<line49>page_incr = xdectoimax (optarg, INTMAX_MIN, INTMAX_MAX, "",\n<line50>_("invalid line number increment"), 0);\n<line51>break;\n<line52>case 'p':\n<line53>reset_numbers = false;\n<line54>break;\n<line55>case 'l':\n<line56>blank_join = xdectoimax (optarg, 1, INTMAX_MAX, "",\n<line57>_("invalid line number of blank lines"), 0);\n<line58>break;\n<line59>case 's':\n<line60>separator_str = optarg;\n<line61>break;\n<line62>case 'w':\n<line63>lineno_width = xdectoimax (optarg, 1, INT_MAX, "",\n<line64>_("invalid line number field width"), 0);\n<line65>break;\n<line66>case 'n':\n<line67>if (STREQ (optarg, "ln"))\n<line68>lineno_format = FORMAT_LEFT;\n<line69>else if (STREQ (optarg, "rn"))\n<line70>lineno_format = FORMAT_RIGHT_NOLZ;\n<line71>else if (STREQ (optarg, "rz"))\n<line72>lineno_format = FORMAT_RIGHT_LZ;\n<line73>else\n<line74>{\n<line75>error (0, 0, _("invalid line numbering format: %s"),\n<line76>quote (optarg));\n<line77>ok = false;\n<line78>}\n<line79>break;\n<line80>case 'd':\n<line81>len = strlen (optarg);\n<line82>if (len == 1 || len == 2)  /* POSIX.  */\n<line83>{\n<line84>char *p = section_del;\n<line85>while (*optarg)\n<line86>*p++ = *optarg++;\n<line87>}\n<line88>else\n<line89>section_del = optarg;  /* GNU extension.  */\n<line90>break;\n<line91>case_GETOPT_HELP_CHAR;\n<line92>case_GETOPT_VERSION_CHAR (PROGRAM_NAME, AUTHORS);\n<line93>default:\n<line94>ok = false;\n<line95>break;\n<line96>}\n<line97>}\n<line98>if (!ok)\n<line99>usage (EXIT_FAILURE);\n<line100>/* Initialize the section delimiters.  */\n<line101>len = strlen (section_del);\n<line102>header_del_len = len * 3;\n<line103>header_del = xmalloc (header_del_len + 1);\n<line104>stpcpy (stpcpy (stpcpy (header_del, section_del), section_del), section_del);\n<line105>body_del_len = len * 2;\n<line106>body_del = header_del + len;\n<line107>footer_del_len = len;\n<line108>footer_del = body_del + len;\n<line109>/* Initialize the input buffer.  */\n<line110>initbuffer (&line_buf);\n<line111>/* Initialize the printf format for unnumbered lines. */\n<line112>len = strlen (separator_str);\n<line113>print_no_line_fmt = xmalloc (lineno_width + len + 1);\n<line114>memset (print_no_line_fmt, ' ', lineno_width + len);\n<line115>print_no_line_fmt[lineno_width + len] = '\0';\n<line116>line_no = starting_line_number;\n<line117>current_type = body_type;\n<line118>current_regex = &body_regex;\n<line119>/* Main processing. */\n<line120>if (optind == argc)\n<line121>ok = nl_file ("-");\n<line122>else\n<line123>for (; optind < argc; optind++)\n<line124>ok &= nl_file (argv[optind]);\n<line125>if (have_read_stdin && fclose (stdin) == EOF)\n<line126>error (EXIT_FAILURE, errno, "-");\n<line127>return ok ? EXIT_SUCCESS : EXIT_FAILURE;\n<line128>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/src/nproc.c
========================================
Function: usage
Content: <line0>void\n<line1>usage (int status)\n<line2>{\n<line3>if (status != EXIT_SUCCESS)\n<line4>emit_try_help ();\n<line5>else\n<line6>{\n<line7>printf (_("Usage: %s [OPTION]...\n"), program_name);\n<line8>fputs (_("\\n<line9>Print the number of processing units available to the current process,\n\\n<line10>which may be less than the number of online processors\n\\n<line11>\n\\n<line12>"), stdout);\n<line13>fputs (_("\\n<line14>--all      print the number of installed processors\n\\n<line15>--ignore=N  if possible, exclude N processing units\n\\n<line16>"), stdout);\n<line17>fputs (HELP_OPTION_DESCRIPTION, stdout);\n<line18>fputs (VERSION_OPTION_DESCRIPTION, stdout);\n<line19>emit_ancillary_info (PROGRAM_NAME);\n<line20>}\n<line21>exit (status);\n<line22>}
----------------------------------------
Function: main
Content: <line0>int\n<line1>main (int argc, char **argv)\n<line2>{\n<line3>unsigned long nproc, ignore = 0;\n<line4>initialize_main (&argc, &argv);\n<line5>set_program_name (argv[0]);\n<line6>setlocale (LC_ALL, "");\n<line7>bindtextdomain (PACKAGE, LOCALEDIR);\n<line8>textdomain (PACKAGE);\n<line9>atexit (close_stdout);\n<line10>enum nproc_query mode = NPROC_CURRENT_OVERRIDABLE;\n<line11>while (true)\n<line12>{\n<line13>int c = getopt_long (argc, argv, "", longopts, nullptr);\n<line14>if (c == -1)\n<line15>break;\n<line16>switch (c)\n<line17>{\n<line18>case_GETOPT_HELP_CHAR;\n<line19>case_GETOPT_VERSION_CHAR (PROGRAM_NAME, AUTHORS);\n<line20>case ALL_OPTION:\n<line21>mode = NPROC_ALL;\n<line22>break;\n<line23>case IGNORE_OPTION:\n<line24>ignore = xdectoumax (optarg, 0, ULONG_MAX, "", _("invalid number"),0);\n<line25>break;\n<line26>default:\n<line27>usage (EXIT_FAILURE);\n<line28>}\n<line29>}\n<line30>if (argc != optind)\n<line31>{\n<line32>error (0, 0, _("extra operand %s"), quote (argv[optind]));\n<line33>usage (EXIT_FAILURE);\n<line34>}\n<line35>nproc = num_processors (mode);\n<line36>if (ignore < nproc)\n<line37>nproc -= ignore;\n<line38>else\n<line39>nproc = 1;\n<line40>printf ("%lu\n", nproc);\n<line41>return EXIT_SUCCESS;\n<line42>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/src/nohup.c
========================================
Function: usage
Content: <line0>void\n<line1>usage (int status)\n<line2>{\n<line3>if (status != EXIT_SUCCESS)\n<line4>emit_try_help ();\n<line5>else\n<line6>{\n<line7>printf (_("\\n<line8>Usage: %s COMMAND [ARG]...\n\\n<line9>or:  %s OPTION\n\\n<line10>"),\n<line11>program_name, program_name);\n<line12>fputs (_("\\n<line13>Run COMMAND, ignoring hangup signals.\n\\n<line14>\n\\n<line15>"), stdout);\n<line16>fputs (HELP_OPTION_DESCRIPTION, stdout);\n<line17>fputs (VERSION_OPTION_DESCRIPTION, stdout);\n<line18>printf (_("\n\\n<line19>If standard input is a terminal, redirect it from an unreadable file.\n\\n<line20>If standard output is a terminal, append output to 'nohup.out' if possible,\n\\n<line21>'$HOME/nohup.out' otherwise.\n\\n<line22>If standard error is a terminal, redirect it to standard output.\n\\n<line23>To save output to FILE, use '%s COMMAND > FILE'.\n"),\n<line24>program_name);\n<line25>printf (USAGE_BUILTIN_WARNING, PROGRAM_NAME);\n<line26>emit_exec_status (PROGRAM_NAME);\n<line27>emit_ancillary_info (PROGRAM_NAME);\n<line28>}\n<line29>exit (status);\n<line30>}
----------------------------------------
Function: main
Content: <line0>int\n<line1>main (int argc, char **argv)\n<line2>{\n<line3>int out_fd = STDOUT_FILENO;\n<line4>int saved_stderr_fd = STDERR_FILENO;\n<line5>bool ignoring_input;\n<line6>bool redirecting_stdout;\n<line7>bool stdout_is_closed;\n<line8>bool redirecting_stderr;\n<line9>int exit_internal_failure;\n<line10>initialize_main (&argc, &argv);\n<line11>set_program_name (argv[0]);\n<line12>setlocale (LC_ALL, "");\n<line13>bindtextdomain (PACKAGE, LOCALEDIR);\n<line14>textdomain (PACKAGE);\n<line15>/* POSIX 2008 requires that internal failure give status 127; unlike\n<line16>for env, exec, nice, time, and xargs where it requires internal\n<line17>failure give something in the range 1-125.  For consistency with\n<line18>other tools, fail with EXIT_CANCELED unless POSIXLY_CORRECT.  */\n<line19>exit_internal_failure = (getenv ("POSIXLY_CORRECT")\n<line20>? POSIX_NOHUP_FAILURE : EXIT_CANCELED);\n<line21>initialize_exit_failure (exit_internal_failure);\n<line22>atexit (close_stdout);\n<line23>parse_gnu_standard_options_only (argc, argv, PROGRAM_NAME, PACKAGE_NAME,\n<line24>Version, false, usage, AUTHORS,\n<line25>(char const *) nullptr);\n<line26>if (argc <= optind)\n<line27>{\n<line28>error (0, 0, _("missing operand"));\n<line29>usage (exit_internal_failure);\n<line30>}\n<line31>ignoring_input = isatty (STDIN_FILENO);\n<line32>redirecting_stdout = isatty (STDOUT_FILENO);\n<line33>stdout_is_closed = (!redirecting_stdout && errno == EBADF);\n<line34>redirecting_stderr = isatty (STDERR_FILENO);\n<line35>/* If standard input is a tty, replace it with /dev/null if possible.\n<line36>Note that it is deliberately opened for *writing*,\n<line37>to ensure any read evokes an error.  */\n<line38>if (ignoring_input)\n<line39>{\n<line40>if (fd_reopen (STDIN_FILENO, "/dev/null", O_WRONLY, 0) < 0)\n<line41>error (exit_internal_failure, errno,\n<line42>_("failed to render standard input unusable"));\n<line43>if (!redirecting_stdout && !redirecting_stderr)\n<line44>error (0, 0, _("ignoring input"));\n<line45>}\n<line46>/* If standard output is a tty, redirect it (appending) to a file.\n<line47>First try nohup.out, then $HOME/nohup.out.  If standard error is\n<line48>a tty and standard output is closed, open nohup.out or\n<line49>$HOME/nohup.out without redirecting anything.  */\n<line50>if (redirecting_stdout || (redirecting_stderr && stdout_is_closed))\n<line51>{\n<line52>char *in_home = nullptr;\n<line53>char const *file = "nohup.out";\n<line54>int flags = O_CREAT | O_WRONLY | O_APPEND;\n<line55>mode_t mode = S_IRUSR | S_IWUSR;\n<line56>mode_t umask_value = umask (~mode);\n<line57>out_fd = (redirecting_stdout\n<line58>? fd_reopen (STDOUT_FILENO, file, flags, mode)\n<line59>: open (file, flags, mode));\n<line60>if (out_fd < 0)\n<line61>{\n<line62>int saved_errno = errno;\n<line63>char const *home = getenv ("HOME");\n<line64>if (home)\n<line65>{\n<line66>in_home = file_name_concat (home, file, nullptr);\n<line67>out_fd = (redirecting_stdout\n<line68>? fd_reopen (STDOUT_FILENO, in_home, flags, mode)\n<line69>: open (in_home, flags, mode));\n<line70>}\n<line71>if (out_fd < 0)\n<line72>{\n<line73>int saved_errno2 = errno;\n<line74>error (0, saved_errno, _("failed to open %s"), quoteaf (file));\n<line75>if (in_home)\n<line76>error (0, saved_errno2, _("failed to open %s"),\n<line77>quoteaf (in_home));\n<line78>return exit_internal_failure;\n<line79>}\n<line80>file = in_home;\n<line81>}\n<line82>umask (umask_value);\n<line83>error (0, 0,\n<line84>_(ignoring_input\n<line85>? N_("ignoring input and appending output to %s")\n<line86>: N_("appending output to %s")),\n<line87>quoteaf (file));\n<line88>free (in_home);\n<line89>}\n<line90>/* If standard error is a tty, redirect it.  */\n<line91>if (redirecting_stderr)\n<line92>{\n<line93>/* Save a copy of stderr before redirecting, so we can use the original\n<line94>if execve fails.  It's no big deal if this dup fails.  It might\n<line95>not change anything, and at worst, it'll lead to suppression of\n<line96>the post-failed-execve diagnostic.  */\n<line97>saved_stderr_fd = fcntl (STDERR_FILENO, F_DUPFD_CLOEXEC,\n<line98>STDERR_FILENO + 1);\n<line99>if (!redirecting_stdout)\n<line100>error (0, 0,\n<line101>_(ignoring_input\n<line102>? N_("ignoring input and redirecting stderr to stdout")\n<line103>: N_("redirecting stderr to stdout")));\n<line104>if (dup2 (out_fd, STDERR_FILENO) < 0)\n<line105>error (exit_internal_failure, errno,\n<line106>_("failed to redirect standard error"));\n<line107>if (stdout_is_closed)\n<line108>close (out_fd);\n<line109>}\n<line110>/* error() flushes stderr, but does not check for write failure.\n<line111>Normally, we would catch this via our atexit() hook of\n<line112>close_stdout, but execvp() gets in the way.  If stderr\n<line113>encountered a write failure, there is no need to try calling\n<line114>error() again, particularly since we may have just changed the\n<line115>underlying fd out from under stderr.  */\n<line116>if (ferror (stderr))\n<line117>return exit_internal_failure;\n<line118>signal (SIGHUP, SIG_IGN);\n<line119>char **cmd = argv + optind;\n<line120>execvp (*cmd, cmd);\n<line121>int exit_status = errno == ENOENT ? EXIT_ENOENT : EXIT_CANNOT_INVOKE;\n<line122>int saved_errno = errno;\n<line123>/* The execve failed.  Output a diagnostic to stderr only if:\n<line124>- stderr was initially redirected to a non-tty, or\n<line125>- stderr was initially directed to a tty, and we\n<line126>can dup2 it to point back to that same tty.\n<line127>In other words, output the diagnostic if possible, but only if\n<line128>it will go to the original stderr.  */\n<line129>if (dup2 (saved_stderr_fd, STDERR_FILENO) == STDERR_FILENO)\n<line130>error (0, saved_errno, _("failed to run command %s"), quoteaf (*cmd));\n<line131>return exit_status;\n<line132>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/src/numfmt.c
========================================
/home/huihui/Downloads/coreutils-9.4/src/numfmt.c:742:30: warning: '_Static_assert' with no message is a C2x extension [-Wc2x-extensions]
                 < sizeof fmt);
                             ^
                             , ""
1 warning generated.
Function: default_scale_base
Content: <line0>static inline int\n<line1>default_scale_base (enum scale_type scale)\n<line2>{\n<line3>switch (scale)\n<line4>{\n<line5>case scale_IEC:\n<line6>case scale_IEC_I:\n<line7>return 1024;\n<line8>case scale_none:\n<line9>case scale_auto:\n<line10>case scale_SI:\n<line11>default:\n<line12>return 1000;\n<line13>}\n<line14>}
----------------------------------------
Function: valid_suffix
Content: <line0>static inline bool\n<line1>valid_suffix (const char suf)\n<line2>{\n<line3>return strchr (valid_suffixes, suf) != nullptr;\n<line4>}
----------------------------------------
Function: suffix_power
Content: <line0>static inline int\n<line1>suffix_power (const char suf)\n<line2>{\n<line3>switch (suf)\n<line4>{\n<line5>case 'K':                  /* kilo or kibi.  */\n<line6>return 1;\n<line7>case 'M':                  /* mega or mebi.  */\n<line8>return 2;\n<line9>case 'G':                  /* giga or gibi.  */\n<line10>return 3;\n<line11>case 'T':                  /* tera or tebi.  */\n<line12>return 4;\n<line13>case 'P':                  /* peta or pebi.  */\n<line14>return 5;\n<line15>case 'E':                  /* exa or exbi.  */\n<line16>return 6;\n<line17>case 'Z':                  /* zetta or 2**70.  */\n<line18>return 7;\n<line19>case 'Y':                  /* yotta or 2**80.  */\n<line20>return 8;\n<line21>case 'R':                  /* ronna or 2**90.  */\n<line22>return 9;\n<line23>case 'Q':                  /* quetta or 2**100.  */\n<line24>return 10;\n<line25>default:                   /* should never happen. assert?  */\n<line26>return 0;\n<line27>}\n<line28>}
----------------------------------------
Function: suffix_power_char
Content: <line0>static inline char const *\n<line1>suffix_power_char (int power)\n<line2>{\n<line3>switch (power)\n<line4>{\n<line5>case 0:\n<line6>return "";\n<line7>case 1:\n<line8>return "K";\n<line9>case 2:\n<line10>return "M";\n<line11>case 3:\n<line12>return "G";\n<line13>case 4:\n<line14>return "T";\n<line15>case 5:\n<line16>return "P";\n<line17>case 6:\n<line18>return "E";\n<line19>case 7:\n<line20>return "Z";\n<line21>case 8:\n<line22>return "Y";\n<line23>case 9:\n<line24>return "R";\n<line25>case 10:\n<line26>return "Q";\n<line27>default:\n<line28>return "(error)";\n<line29>}\n<line30>}
----------------------------------------
Function: powerld
Content: <line0>static long double\n<line1>powerld (long double base, int x)\n<line2>{\n<line3>long double result = base;\n<line4>if (x == 0)\n<line5>return 1;                   /* note for test coverage: this is never\n<line6>reached, as 'powerld' won't be called if\n<line7>there's no suffix, hence, no "power".  */\n<line8>/* TODO: check for overflow, inf?  */\n<line9>while (--x)\n<line10>result *= base;\n<line11>return result;\n<line12>}
----------------------------------------
Function: absld
Content: <line0>static inline long double\n<line1>absld (long double val)\n<line2>{\n<line3>return val < 0 ? -val : val;\n<line4>}
----------------------------------------
Function: expld
Content: <line0>static long double\n<line1>expld (long double val, int base, int /*output */ *x)\n<line2>{\n<line3>int power = 0;\n<line4>if (val >= -LDBL_MAX && val <= LDBL_MAX)\n<line5>{\n<line6>while (absld (val) >= base)\n<line7>{\n<line8>++power;\n<line9>val /= base;\n<line10>}\n<line11>}\n<line12>if (x)\n<line13>*x = power;\n<line14>return val;\n<line15>}
----------------------------------------
Function: simple_round_ceiling
Content: <line0>static inline intmax_t\n<line1>simple_round_ceiling (long double val)\n<line2>{\n<line3>intmax_t intval = val;\n<line4>if (intval < val)\n<line5>intval++;\n<line6>return intval;\n<line7>}
----------------------------------------
Function: simple_round_floor
Content: <line0>static inline intmax_t\n<line1>simple_round_floor (long double val)\n<line2>{\n<line3>return -simple_round_ceiling (-val);\n<line4>}
----------------------------------------
Function: simple_round_from_zero
Content: <line0>static inline intmax_t\n<line1>simple_round_from_zero (long double val)\n<line2>{\n<line3>return val < 0 ? simple_round_floor (val) : simple_round_ceiling (val);\n<line4>}
----------------------------------------
Function: simple_round_to_zero
Content: <line0>static inline intmax_t\n<line1>simple_round_to_zero (long double val)\n<line2>{\n<line3>return val;\n<line4>}
----------------------------------------
Function: simple_round_nearest
Content: <line0>static inline intmax_t\n<line1>simple_round_nearest (long double val)\n<line2>{\n<line3>return val < 0 ? val - 0.5 : val + 0.5;\n<line4>}
----------------------------------------
Function: simple_strtod_int
Content: <line0>static enum simple_strtod_error\n<line1>simple_strtod_int (char const *input_str,\n<line2>char **endptr, long double *value, bool *negative)\n<line3>{\n<line4>enum simple_strtod_error e = SSE_OK;\n<line5>long double val = 0;\n<line6>int digits = 0;\n<line7>bool found_digit = false;\n<line8>if (*input_str == '-')\n<line9>{\n<line10>input_str++;\n<line11>*negative = true;\n<line12>}\n<line13>else\n<line14>*negative = false;\n<line15>*endptr = (char *) input_str;\n<line16>while (c_isdigit (**endptr))\n<line17>{\n<line18>int digit = (**endptr) - '0';\n<line19>found_digit = true;\n<line20>if (val || digit)\n<line21>digits++;\n<line22>if (digits > MAX_UNSCALED_DIGITS)\n<line23>e = SSE_OK_PRECISION_LOSS;\n<line24>if (digits > MAX_ACCEPTABLE_DIGITS)\n<line25>return SSE_OVERFLOW;\n<line26>val *= 10;\n<line27>val += digit;\n<line28>++(*endptr);\n<line29>}\n<line30>if (! found_digit\n<line31>&& ! STREQ_LEN (*endptr, decimal_point, decimal_point_length))\n<line32>return SSE_INVALID_NUMBER;\n<line33>if (*negative)\n<line34>val = -val;\n<line35>if (value)\n<line36>*value = val;\n<line37>return e;\n<line38>}
----------------------------------------
Function: simple_strtod_float
Content: <line0>static enum simple_strtod_error\n<line1>simple_strtod_float (char const *input_str,\n<line2>char **endptr,\n<line3>long double *value,\n<line4>size_t *precision)\n<line5>{\n<line6>bool negative;\n<line7>enum simple_strtod_error e = SSE_OK;\n<line8>if (precision)\n<line9>*precision = 0;\n<line10>/* TODO: accept locale'd grouped values for the integral part.  */\n<line11>e = simple_strtod_int (input_str, endptr, value, &negative);\n<line12>if (e != SSE_OK && e != SSE_OK_PRECISION_LOSS)\n<line13>return e;\n<line14>/* optional decimal point + fraction.  */\n<line15>if (STREQ_LEN (*endptr, decimal_point, decimal_point_length))\n<line16>{\n<line17>char *ptr2;\n<line18>long double val_frac = 0;\n<line19>bool neg_frac;\n<line20>(*endptr) += decimal_point_length;\n<line21>enum simple_strtod_error e2 =\n<line22>simple_strtod_int (*endptr, &ptr2, &val_frac, &neg_frac);\n<line23>if (e2 != SSE_OK && e2 != SSE_OK_PRECISION_LOSS)\n<line24>return e2;\n<line25>if (e2 == SSE_OK_PRECISION_LOSS)\n<line26>e = e2;                       /* propagate warning.  */\n<line27>if (neg_frac)\n<line28>return SSE_INVALID_NUMBER;\n<line29>/* number of digits in the fractions.  */\n<line30>size_t exponent = ptr2 - *endptr;\n<line31>val_frac = ((long double) val_frac) / powerld (10, exponent);\n<line32>/* TODO: detect loss of precision (only really 18 digits\n<line33>of precision across all digits (before and after '.')).  */\n<line34>if (value)\n<line35>{\n<line36>if (negative)\n<line37>*value -= val_frac;\n<line38>else\n<line39>*value += val_frac;\n<line40>}\n<line41>if (precision)\n<line42>*precision = exponent;\n<line43>*endptr = ptr2;\n<line44>}\n<line45>return e;\n<line46>}
----------------------------------------
Function: simple_strtod_human
Content: <line0>static enum simple_strtod_error\n<line1>simple_strtod_human (char const *input_str,\n<line2>char **endptr, long double *value, size_t *precision,\n<line3>enum scale_type allowed_scaling)\n<line4>{\n<line5>int power = 0;\n<line6>/* 'scale_auto' is checked below.  */\n<line7>int scale_base = default_scale_base (allowed_scaling);\n<line8>devmsg ("simple_strtod_human:\n  input string: %s\n"\n<line9>"  locale decimal-point: %s\n"\n<line10>"  MAX_UNSCALED_DIGITS: %d\n",\n<line11>quote_n (0, input_str),\n<line12>quote_n (1, decimal_point),\n<line13>MAX_UNSCALED_DIGITS);\n<line14>enum simple_strtod_error e =\n<line15>simple_strtod_float (input_str, endptr, value, precision);\n<line16>if (e != SSE_OK && e != SSE_OK_PRECISION_LOSS)\n<line17>return e;\n<line18>devmsg ("  parsed numeric value: %Lf\n"\n<line19>"  input precision = %d\n", *value, (int)*precision);\n<line20>if (**endptr != '\0')\n<line21>{\n<line22>/* process suffix.  */\n<line23>/* Skip any blanks between the number and suffix.  */\n<line24>while (isblank (to_uchar (**endptr)))\n<line25>(*endptr)++;\n<line26>if (!valid_suffix (**endptr))\n<line27>return SSE_INVALID_SUFFIX;\n<line28>if (allowed_scaling == scale_none)\n<line29>return SSE_VALID_BUT_FORBIDDEN_SUFFIX;\n<line30>power = suffix_power (**endptr);\n<line31>(*endptr)++;                     /* skip first suffix character.  */\n<line32>if (allowed_scaling == scale_auto && **endptr == 'i')\n<line33>{\n<line34>/* auto-scaling enabled, and the first suffix character\n<line35>is followed by an 'i' (e.g. Ki, Mi, Gi).  */\n<line36>scale_base = 1024;\n<line37>(*endptr)++;              /* skip second  ('i') suffix character.  */\n<line38>devmsg ("  Auto-scaling, found 'i', switching to base %d\n",\n<line39>scale_base);\n<line40>}\n<line41>*precision = 0;  /* Reset, to select precision based on scale.  */\n<line42>}\n<line43>if (allowed_scaling == scale_IEC_I)\n<line44>{\n<line45>if (**endptr == 'i')\n<line46>(*endptr)++;\n<line47>else\n<line48>return SSE_MISSING_I_SUFFIX;\n<line49>}\n<line50>long double multiplier = powerld (scale_base, power);\n<line51>devmsg ("  suffix power=%d^%d = %Lf\n", scale_base, power, multiplier);\n<line52>/* TODO: detect loss of precision and overflows.  */\n<line53>(*value) = (*value) * multiplier;\n<line54>devmsg ("  returning value: %Lf (%LG)\n", *value, *value);\n<line55>return e;\n<line56>}
----------------------------------------
Function: simple_strtod_fatal
Content: <line0>static void\n<line1>simple_strtod_fatal (enum simple_strtod_error err, char const *input_str)\n<line2>{\n<line3>char const *msgid = nullptr;\n<line4>switch (err)\n<line5>{\n<line6>case SSE_OK_PRECISION_LOSS:\n<line7>case SSE_OK:\n<line8>/* should never happen - this function isn't called when OK.  */\n<line9>unreachable ();\n<line10>case SSE_OVERFLOW:\n<line11>msgid = N_("value too large to be converted: %s");\n<line12>break;\n<line13>case SSE_INVALID_NUMBER:\n<line14>msgid = N_("invalid number: %s");\n<line15>break;\n<line16>case SSE_VALID_BUT_FORBIDDEN_SUFFIX:\n<line17>msgid = N_("rejecting suffix in input: %s (consider using --from)");\n<line18>break;\n<line19>case SSE_INVALID_SUFFIX:\n<line20>msgid = N_("invalid suffix in input: %s");\n<line21>break;\n<line22>case SSE_MISSING_I_SUFFIX:\n<line23>msgid = N_("missing 'i' suffix in input: %s (e.g Ki/Mi/Gi)");\n<line24>break;\n<line25>}\n<line26>if (inval_style != inval_ignore)\n<line27>error (conv_exit_code, 0, gettext (msgid), quote (input_str));\n<line28>}
----------------------------------------
Function: double_to_human
Content: <line0>static void\n<line1>double_to_human (long double val, int precision,\n<line2>char *buf, size_t buf_size,\n<line3>enum scale_type scale, int group, enum round_type round)\n<line4>{\n<line5>int num_size;\n<line6>char fmt[64];\n<line7>static_assert ((INT_BUFSIZE_BOUND (zero_padding_width)\n<line8>+ INT_BUFSIZE_BOUND (precision)\n<line9>+ 10 /* for %.Lf  etc.  */)\n<line10>< sizeof fmt);\n<line11>char *pfmt = fmt;\n<line12>*pfmt++ = '%';\n<line13>if (group)\n<line14>*pfmt++ = '\'';\n<line15>if (zero_padding_width)\n<line16>pfmt += snprintf (pfmt, sizeof (fmt) - 2, "0%ld", zero_padding_width);\n<line17>devmsg ("double_to_human:\n");\n<line18>if (scale == scale_none)\n<line19>{\n<line20>val *= powerld (10, precision);\n<line21>val = simple_round (val, round);\n<line22>val /= powerld (10, precision);\n<line23>devmsg ((group) ?\n<line24>"  no scaling, returning (grouped) value: %'.*Lf\n" :\n<line25>"  no scaling, returning value: %.*Lf\n", precision, val);\n<line26>stpcpy (pfmt, ".*Lf");\n<line27>num_size = snprintf (buf, buf_size, fmt, precision, val);\n<line28>if (num_size < 0 || num_size >= (int) buf_size)\n<line29>error (EXIT_FAILURE, 0,\n<line30>_("failed to prepare value '%Lf' for printing"), val);\n<line31>return;\n<line32>}\n<line33>/* Scaling requested by user. */\n<line34>double scale_base = default_scale_base (scale);\n<line35>/* Normalize val to scale. */\n<line36>int power = 0;\n<line37>val = expld (val, scale_base, &power);\n<line38>devmsg ("  scaled value to %Lf * %0.f ^ %d\n", val, scale_base, power);\n<line39>/* Perform rounding. */\n<line40>int power_adjust = 0;\n<line41>if (user_precision != -1)\n<line42>power_adjust = MIN (power * 3, user_precision);\n<line43>else if (absld (val) < 10)\n<line44>{\n<line45>/* for values less than 10, we allow one decimal-point digit,\n<line46>so adjust before rounding. */\n<line47>power_adjust = 1;\n<line48>}\n<line49>val *= powerld (10, power_adjust);\n<line50>val = simple_round (val, round);\n<line51>val /= powerld (10, power_adjust);\n<line52>/* two special cases after rounding:\n<line53>1. a "999.99" can turn into 1000 - so scale down\n<line54>2. a "9.99" can turn into 10 - so don't display decimal-point.  */\n<line55>if (absld (val) >= scale_base)\n<line56>{\n<line57>val /= scale_base;\n<line58>power++;\n<line59>}\n<line60>/* should "7.0" be printed as "7" ?\n<line61>if removing the ".0" is preferred, enable the fourth condition.  */\n<line62>int show_decimal_point = (val != 0) && (absld (val) < 10) && (power > 0);\n<line63>/* && (absld (val) > simple_round_floor (val))) */\n<line64>devmsg ("  after rounding, value=%Lf * %0.f ^ %d\n", val, scale_base, power);\n<line65>stpcpy (pfmt, ".*Lf%s");\n<line66>int prec = user_precision == -1 ? show_decimal_point : user_precision;\n<line67>/* buf_size - 1 used here to ensure place for possible scale_IEC_I suffix.  */\n<line68>num_size = snprintf (buf, buf_size - 1, fmt, prec, val,\n<line69>suffix_power_char (power));\n<line70>if (num_size < 0 || num_size >= (int) buf_size - 1)\n<line71>error (EXIT_FAILURE, 0,\n<line72>_("failed to prepare value '%Lf' for printing"), val);\n<line73>if (scale == scale_IEC_I && power > 0)\n<line74>strncat (buf, "i", buf_size - num_size - 1);\n<line75>devmsg ("  returning value: %s\n", quote (buf));\n<line76>return;\n<line77>}
----------------------------------------
Function: unit_to_umax
Content: <line0>static uintmax_t\n<line1>unit_to_umax (char const *n_string)\n<line2>{\n<line3>strtol_error s_err;\n<line4>char const *c_string = n_string;\n<line5>char *t_string = nullptr;\n<line6>size_t n_len = strlen (n_string);\n<line7>char *end = nullptr;\n<line8>uintmax_t n;\n<line9>char const *suffixes = valid_suffixes;\n<line10>/* Adjust suffixes so K=1000, Ki=1024, KiB=invalid.  */\n<line11>if (n_len && ! c_isdigit (n_string[n_len - 1]))\n<line12>{\n<line13>t_string = xmalloc (n_len + 2);\n<line14>end = t_string + n_len - 1;\n<line15>memcpy (t_string, n_string, n_len);\n<line16>if (*end == 'i' && 2 <= n_len && ! c_isdigit (*(end - 1)))\n<line17>*end = '\0';\n<line18>else\n<line19>{\n<line20>*++end = 'B';\n<line21>*++end = '\0';\n<line22>suffixes = zero_and_valid_suffixes;\n<line23>}\n<line24>c_string = t_string;\n<line25>}\n<line26>s_err = xstrtoumax (c_string, &end, 10, &n, suffixes);\n<line27>if (s_err != LONGINT_OK || *end || n == 0)\n<line28>{\n<line29>free (t_string);\n<line30>error (EXIT_FAILURE, 0, _("invalid unit size: %s"), quote (n_string));\n<line31>}\n<line32>free (t_string);\n<line33>return n;\n<line34>}
----------------------------------------
Function: setup_padding_buffer
Content: <line0>static void\n<line1>setup_padding_buffer (size_t min_size)\n<line2>{\n<line3>if (padding_buffer_size > min_size)\n<line4>return;\n<line5>padding_buffer_size = min_size + 1;\n<line6>padding_buffer = xrealloc (padding_buffer, padding_buffer_size);\n<line7>}
----------------------------------------
Function: usage
Content: <line0>void\n<line1>usage (int status)\n<line2>{\n<line3>if (status != EXIT_SUCCESS)\n<line4>emit_try_help ();\n<line5>else\n<line6>{\n<line7>printf (_("\\n<line8>Usage: %s [OPTION]... [NUMBER]...\n\\n<line9>"), program_name);\n<line10>fputs (_("\\n<line11>Reformat NUMBER(s), or the numbers from standard input if none are specified.\n\\n<line12>"), stdout);\n<line13>emit_mandatory_arg_note ();\n<line14>fputs (_("\\n<line15>--debug          print warnings about invalid input\n\\n<line16>"), stdout);\n<line17>fputs (_("\\n<line18>-d, --delimiter=X    use X instead of whitespace for field delimiter\n\\n<line19>"), stdout);\n<line20>fputs (_("\\n<line21>--field=FIELDS   replace the numbers in these input fields (default=1);\n\\n<line22>see FIELDS below\n\\n<line23>"), stdout);\n<line24>fputs (_("\\n<line25>--format=FORMAT  use printf style floating-point FORMAT;\n\\n<line26>see FORMAT below for details\n\\n<line27>"), stdout);\n<line28>fputs (_("\\n<line29>--from=UNIT      auto-scale input numbers to UNITs; default is 'none';\n\\n<line30>see UNIT below\n\\n<line31>"), stdout);\n<line32>fputs (_("\\n<line33>--from-unit=N    specify the input unit size (instead of the default 1)\n\\n<line34>"), stdout);\n<line35>fputs (_("\\n<line36>--grouping       use locale-defined grouping of digits, e.g. 1,000,000\n\\n<line37>(which means it has no effect in the C/POSIX locale)\n\\n<line38>"), stdout);\n<line39>fputs (_("\\n<line40>--header[=N]     print (without converting) the first N header lines;\n\\n<line41>N defaults to 1 if not specified\n\\n<line42>"), stdout);\n<line43>fputs (_("\\n<line44>--invalid=MODE   failure mode for invalid numbers: MODE can be:\n\\n<line45>abort (default), fail, warn, ignore\n\\n<line46>"), stdout);\n<line47>fputs (_("\\n<line48>--padding=N      pad the output to N characters; positive N will\n\\n<line49>right-align; negative N will left-align;\n\\n<line50>padding is ignored if the output is wider than N;\n\\n<line51>the default is to automatically pad if a whitespace\n\\n<line52>is found\n\\n<line53>"), stdout);\n<line54>fputs (_("\\n<line55>--round=METHOD   use METHOD for rounding when scaling; METHOD can be:\n\\n<line56>up, down, from-zero (default), towards-zero, nearest\n\\n<line57>"), stdout);\n<line58>fputs (_("\\n<line59>--suffix=SUFFIX  add SUFFIX to output numbers, and accept optional\n\\n<line60>SUFFIX in input numbers\n\\n<line61>"), stdout);\n<line62>fputs (_("\\n<line63>--to=UNIT        auto-scale output numbers to UNITs; see UNIT below\n\\n<line64>"), stdout);\n<line65>fputs (_("\\n<line66>--to-unit=N      the output unit size (instead of the default 1)\n\\n<line67>"), stdout);\n<line68>fputs (_("\\n<line69>-z, --zero-terminated    line delimiter is NUL, not newline\n\\n<line70>"), stdout);\n<line71>fputs (HELP_OPTION_DESCRIPTION, stdout);\n<line72>fputs (VERSION_OPTION_DESCRIPTION, stdout);\n<line73>fputs (_("\\n<line74>\n\\n<line75>UNIT options:\n"), stdout);\n<line76>fputs (_("\\n<line77>none       no auto-scaling is done; suffixes will trigger an error\n\\n<line78>"), stdout);\n<line79>fputs (_("\\n<line80>auto       accept optional single/two letter suffix:\n\\n<line81>1K = 1000,\n\\n<line82>1Ki = 1024,\n\\n<line83>1M = 1000000,\n\\n<line84>1Mi = 1048576,\n"), stdout);\n<line85>fputs (_("\\n<line86>si         accept optional single letter suffix:\n\\n<line87>1K = 1000,\n\\n<line88>1M = 1000000,\n\\n<line89>...\n"), stdout);\n<line90>fputs (_("\\n<line91>iec        accept optional single letter suffix:\n\\n<line92>1K = 1024,\n\\n<line93>1M = 1048576,\n\\n<line94>...\n"), stdout);\n<line95>fputs (_("\\n<line96>iec-i      accept optional two-letter suffix:\n\\n<line97>1Ki = 1024,\n\\n<line98>1Mi = 1048576,\n\\n<line99>...\n"), stdout);\n<line100>fputs (_("\n\\n<line101>FIELDS supports cut(1) style field ranges:\n\\n<line102>N    N'th field, counted from 1\n\\n<line103>N-   from N'th field, to end of line\n\\n<line104>N-M  from N'th to M'th field (inclusive)\n\\n<line105>-M   from first to M'th field (inclusive)\n\\n<line106>-    all fields\n\\n<line107>Multiple fields/ranges can be separated with commas\n\\n<line108>"), stdout);\n<line109>fputs (_("\n\\n<line110>FORMAT must be suitable for printing one floating-point argument '%f'.\n\\n<line111>Optional quote (%'f) will enable --grouping (if supported by current locale).\n\\n<line112>Optional width value (%10f) will pad output. Optional zero (%010f) width\n\\n<line113>will zero pad the number. Optional negative values (%-10f) will left align.\n\\n<line114>Optional precision (%.1f) will override the input determined precision.\n\\n<line115>"), stdout);\n<line116>printf (_("\n\\n<line117>Exit status is 0 if all input numbers were successfully converted.\n\\n<line118>By default, %s will stop at the first conversion error with exit status 2.\n\\n<line119>With --invalid='fail' a warning is printed for each conversion error\n\\n<line120>and the exit status is 2.  With --invalid='warn' each conversion error is\n\\n<line121>diagnosed, but the exit status is 0.  With --invalid='ignore' conversion\n\\n<line122>errors are not diagnosed and the exit status is 0.\n\\n<line123>"), program_name);\n<line124>printf (_("\n\\n<line125>Examples:\n\\n<line126>$ %s --to=si 1000\n\\n<line127>-> \"1.0K\"\n\\n<line128>$ %s --to=iec 2048\n\\n<line129>-> \"2.0K\"\n\\n<line130>$ %s --to=iec-i 4096\n\\n<line131>-> \"4.0Ki\"\n\\n<line132>$ echo 1K | %s --from=si\n\\n<line133>-> \"1000\"\n\\n<line134>$ echo 1K | %s --from=iec\n\\n<line135>-> \"1024\"\n\\n<line136>$ df -B1 | %s --header --field 2-4 --to=si\n\\n<line137>$ ls -l  | %s --header --field 5 --to=iec\n\\n<line138>$ ls -lh | %s --header --field 5 --from=iec --padding=10\n\\n<line139>$ ls -lh | %s --header --field 5 --from=iec --format %%10f\n"),\n<line140>program_name, program_name, program_name,\n<line141>program_name, program_name, program_name,\n<line142>program_name, program_name, program_name);\n<line143>emit_ancillary_info (PROGRAM_NAME);\n<line144>}\n<line145>exit (status);\n<line146>}
----------------------------------------
Function: parse_format_string
Content: <line0>static void\n<line1>parse_format_string (char const *fmt)\n<line2>{\n<line3>size_t i;\n<line4>size_t prefix_len = 0;\n<line5>size_t suffix_pos;\n<line6>long int pad = 0;\n<line7>char *endptr = nullptr;\n<line8>bool zero_padding = false;\n<line9>for (i = 0; !(fmt[i] == '%' && fmt[i + 1] != '%'); i += (fmt[i] == '%') + 1)\n<line10>{\n<line11>if (!fmt[i])\n<line12>error (EXIT_FAILURE, 0,\n<line13>_("format %s has no %% directive"), quote (fmt));\n<line14>prefix_len++;\n<line15>}\n<line16>i++;\n<line17>while (true)\n<line18>{\n<line19>size_t skip = strspn (fmt + i, " ");\n<line20>i += skip;\n<line21>if (fmt[i] == '\'')\n<line22>{\n<line23>grouping = 1;\n<line24>i++;\n<line25>}\n<line26>else if (fmt[i] == '0')\n<line27>{\n<line28>zero_padding = true;\n<line29>i++;\n<line30>}\n<line31>else if (! skip)\n<line32>break;\n<line33>}\n<line34>errno = 0;\n<line35>pad = strtol (fmt + i, &endptr, 10);\n<line36>if (errno == ERANGE || pad < -LONG_MAX)\n<line37>error (EXIT_FAILURE, 0,\n<line38>_("invalid format %s (width overflow)"), quote (fmt));\n<line39>if (endptr != (fmt + i) && pad != 0)\n<line40>{\n<line41>if (debug && padding_width && !(zero_padding && pad > 0))\n<line42>error (0, 0, _("--format padding overriding --padding"));\n<line43>if (pad < 0)\n<line44>{\n<line45>padding_alignment = MBS_ALIGN_LEFT;\n<line46>padding_width = -pad;\n<line47>}\n<line48>else\n<line49>{\n<line50>if (zero_padding)\n<line51>zero_padding_width = pad;\n<line52>else\n<line53>padding_width = pad;\n<line54>}\n<line55>}\n<line56>i = endptr - fmt;\n<line57>if (fmt[i] == '\0')\n<line58>error (EXIT_FAILURE, 0, _("format %s ends in %%"), quote (fmt));\n<line59>if (fmt[i] == '.')\n<line60>{\n<line61>i++;\n<line62>errno = 0;\n<line63>user_precision = strtol (fmt + i, &endptr, 10);\n<line64>if (errno == ERANGE || user_precision < 0 || SIZE_MAX < user_precision\n<line65>|| isblank (fmt[i]) || fmt[i] == '+')\n<line66>{\n<line67>/* Note we disallow negative user_precision to be\n<line68>consistent with printf(1).  POSIX states that\n<line69>negative precision is only supported (and ignored)\n<line70>when used with '.*f'.  glibc at least will malform\n<line71>output when passed a direct negative precision.  */\n<line72>error (EXIT_FAILURE, 0,\n<line73>_("invalid precision in format %s"), quote (fmt));\n<line74>}\n<line75>i = endptr - fmt;\n<line76>}\n<line77>if (fmt[i] != 'f')\n<line78>error (EXIT_FAILURE, 0, _("invalid format %s,"\n<line79>" directive must be %%[0]['][-][N][.][N]f"),\n<line80>quote (fmt));\n<line81>i++;\n<line82>suffix_pos = i;\n<line83>for (; fmt[i] != '\0'; i += (fmt[i] == '%') + 1)\n<line84>if (fmt[i] == '%' && fmt[i + 1] != '%')\n<line85>error (EXIT_FAILURE, 0, _("format %s has too many %% directives"),\n<line86>quote (fmt));\n<line87>if (prefix_len)\n<line88>format_str_prefix = ximemdup0 (fmt, prefix_len);\n<line89>if (fmt[suffix_pos] != '\0')\n<line90>format_str_suffix = xstrdup (fmt + suffix_pos);\n<line91>devmsg ("format String:\n  input: %s\n  grouping: %s\n"\n<line92>"  padding width: %ld\n  alignment: %s\n"\n<line93>"  prefix: %s\n  suffix: %s\n",\n<line94>quote_n (0, fmt), (grouping) ? "yes" : "no",\n<line95>padding_width,\n<line96>(padding_alignment == MBS_ALIGN_LEFT) ? "Left" : "Right",\n<line97>quote_n (1, format_str_prefix ? format_str_prefix : ""),\n<line98>quote_n (2, format_str_suffix ? format_str_suffix : ""));\n<line99>}
----------------------------------------
Function: parse_human_number
Content: <line0>static enum simple_strtod_error\n<line1>parse_human_number (char const *str, long double /*output */ *value,\n<line2>size_t *precision)\n<line3>{\n<line4>char *ptr = nullptr;\n<line5>enum simple_strtod_error e =\n<line6>simple_strtod_human (str, &ptr, value, precision, scale_from);\n<line7>if (e != SSE_OK && e != SSE_OK_PRECISION_LOSS)\n<line8>{\n<line9>simple_strtod_fatal (e, str);\n<line10>return e;\n<line11>}\n<line12>if (ptr && *ptr != '\0')\n<line13>{\n<line14>if (inval_style != inval_ignore)\n<line15>error (conv_exit_code, 0, _("invalid suffix in input %s: %s"),\n<line16>quote_n (0, str), quote_n (1, ptr));\n<line17>e = SSE_INVALID_SUFFIX;\n<line18>}\n<line19>return e;\n<line20>}
----------------------------------------
Function: prepare_padded_number
Content: <line0>static int\n<line1>prepare_padded_number (const long double val, size_t precision)\n<line2>{\n<line3>/* Generate Output. */\n<line4>char buf[128];\n<line5>size_t precision_used = user_precision == -1 ? precision : user_precision;\n<line6>/* Can't reliably print too-large values without auto-scaling. */\n<line7>int x;\n<line8>expld (val, 10, &x);\n<line9>if (scale_to == scale_none\n<line10>&& x + precision_used > MAX_UNSCALED_DIGITS)\n<line11>{\n<line12>if (inval_style != inval_ignore)\n<line13>{\n<line14>if (precision_used)\n<line15>error (conv_exit_code, 0,\n<line16>_("value/precision too large to be printed: '%Lg/%"PRIuMAX"'"\n<line17>" (consider using --to)"), val, (uintmax_t)precision_used);\n<line18>else\n<line19>error (conv_exit_code, 0,\n<line20>_("value too large to be printed: '%Lg'"\n<line21>" (consider using --to)"), val);\n<line22>}\n<line23>return 0;\n<line24>}\n<line25>if (x > MAX_ACCEPTABLE_DIGITS - 1)\n<line26>{\n<line27>if (inval_style != inval_ignore)\n<line28>error (conv_exit_code, 0, _("value too large to be printed: '%Lg'"\n<line29>" (cannot handle values > 999Q)"), val);\n<line30>return 0;\n<line31>}\n<line32>double_to_human (val, precision_used, buf, sizeof (buf),\n<line33>scale_to, grouping, round_style);\n<line34>if (suffix)\n<line35>strncat (buf, suffix, sizeof (buf) - strlen (buf) -1);\n<line36>devmsg ("formatting output:\n  value: %Lf\n  humanized: %s\n",\n<line37>val, quote (buf));\n<line38>if (padding_width && strlen (buf) < padding_width)\n<line39>{\n<line40>size_t w = padding_width;\n<line41>mbsalign (buf, padding_buffer, padding_buffer_size, &w,\n<line42>padding_alignment, MBA_UNIBYTE_ONLY);\n<line43>devmsg ("  After padding: %s\n", quote (padding_buffer));\n<line44>}\n<line45>else\n<line46>{\n<line47>setup_padding_buffer (strlen (buf) + 1);\n<line48>strcpy (padding_buffer, buf);\n<line49>}\n<line50>return 1;\n<line51>}
----------------------------------------
Function: print_padded_number
Content: <line0>static void\n<line1>print_padded_number (void)\n<line2>{\n<line3>if (format_str_prefix)\n<line4>fputs (format_str_prefix, stdout);\n<line5>fputs (padding_buffer, stdout);\n<line6>if (format_str_suffix)\n<line7>fputs (format_str_suffix, stdout);\n<line8>}
----------------------------------------
Function: process_suffixed_number
Content: <line0>static int\n<line1>process_suffixed_number (char *text, long double *result,\n<line2>size_t *precision, long int field)\n<line3>{\n<line4>if (suffix && strlen (text) > strlen (suffix))\n<line5>{\n<line6>char *possible_suffix = text + strlen (text) - strlen (suffix);\n<line7>if (STREQ (suffix, possible_suffix))\n<line8>{\n<line9>/* trim suffix, ONLY if it's at the end of the text.  */\n<line10>*possible_suffix = '\0';\n<line11>devmsg ("trimming suffix %s\n", quote (suffix));\n<line12>}\n<line13>else\n<line14>devmsg ("no valid suffix found\n");\n<line15>}\n<line16>/* Skip white space - always.  */\n<line17>char *p = text;\n<line18>while (*p && isblank (to_uchar (*p)))\n<line19>++p;\n<line20>/* setup auto-padding.  */\n<line21>if (auto_padding)\n<line22>{\n<line23>if (text < p || field > 1)\n<line24>{\n<line25>padding_width = strlen (text);\n<line26>setup_padding_buffer (padding_width);\n<line27>}\n<line28>else\n<line29>{\n<line30>padding_width = 0;\n<line31>}\n<line32>devmsg ("setting Auto-Padding to %ld characters\n", padding_width);\n<line33>}\n<line34>long double val = 0;\n<line35>enum simple_strtod_error e = parse_human_number (p, &val, precision);\n<line36>if (e == SSE_OK_PRECISION_LOSS && debug)\n<line37>error (0, 0, _("large input value %s: possible precision loss"),\n<line38>quote (p));\n<line39>if (from_unit_size != 1 || to_unit_size != 1)\n<line40>val = (val * from_unit_size) / to_unit_size;\n<line41>*result = val;\n<line42>return (e == SSE_OK || e == SSE_OK_PRECISION_LOSS);\n<line43>}
----------------------------------------
Function: next_field
Content: <line0>static char*\n<line1>next_field (char **line)\n<line2>{\n<line3>char *field_start = *line;\n<line4>char *field_end   = field_start;\n<line5>if (delimiter != DELIMITER_DEFAULT)\n<line6>{\n<line7>if (*field_start != delimiter)\n<line8>{\n<line9>while (*field_end && *field_end != delimiter)\n<line10>++field_end;\n<line11>}\n<line12>/* else empty field */\n<line13>}\n<line14>else\n<line15>{\n<line16>/* keep any space prefix in the returned field */\n<line17>while (*field_end && field_sep (*field_end))\n<line18>++field_end;\n<line19>while (*field_end && ! field_sep (*field_end))\n<line20>++field_end;\n<line21>}\n<line22>*line = field_end;\n<line23>return field_start;\n<line24>}
----------------------------------------
Function: process_field
Content: <line0>static bool\n<line1>process_field (char *text, uintmax_t field)\n<line2>{\n<line3>long double val = 0;\n<line4>size_t precision = 0;\n<line5>bool valid_number = true;\n<line6>if (include_field (field))\n<line7>{\n<line8>valid_number =\n<line9>process_suffixed_number (text, &val, &precision, field);\n<line10>if (valid_number)\n<line11>valid_number = prepare_padded_number (val, precision);\n<line12>if (valid_number)\n<line13>print_padded_number ();\n<line14>else\n<line15>fputs (text, stdout);\n<line16>}\n<line17>else\n<line18>fputs (text, stdout);\n<line19>return valid_number;\n<line20>}
----------------------------------------
Function: process_line
Content: <line0>static int\n<line1>process_line (char *line, bool newline)\n<line2>{\n<line3>char *next;\n<line4>uintmax_t field = 0;\n<line5>bool valid_number = true;\n<line6>while (true) {\n<line7>++field;\n<line8>next = next_field (&line);\n<line9>if (*line != '\0')\n<line10>{\n<line11>/* nul terminate the current field string and process */\n<line12>*line = '\0';\n<line13>if (! process_field (next, field))\n<line14>valid_number = false;\n<line15>fputc ((delimiter == DELIMITER_DEFAULT) ?\n<line16>' ' : delimiter, stdout);\n<line17>++line;\n<line18>}\n<line19>else\n<line20>{\n<line21>/* end of the line, process the last field and finish */\n<line22>if (! process_field (next, field))\n<line23>valid_number = false;\n<line24>break;\n<line25>}\n<line26>}\n<line27>if (newline)\n<line28>putchar (line_delim);\n<line29>return valid_number;\n<line30>}
----------------------------------------
Function: main
Content: <line0>int\n<line1>main (int argc, char **argv)\n<line2>{\n<line3>int valid_numbers = 1;\n<line4>bool locale_ok;\n<line5>initialize_main (&argc, &argv);\n<line6>set_program_name (argv[0]);\n<line7>locale_ok = !!setlocale (LC_ALL, "");\n<line8>bindtextdomain (PACKAGE, LOCALEDIR);\n<line9>textdomain (PACKAGE);\n<line10>#if HAVE_FPSETPREC\n<line11>/* Enabled extended precision if needed.  */\n<line12>fpsetprec (FP_PE);\n<line13>#endif\n<line14>decimal_point = nl_langinfo (RADIXCHAR);\n<line15>if (decimal_point == nullptr || strlen (decimal_point) == 0)\n<line16>decimal_point = ".";\n<line17>decimal_point_length = strlen (decimal_point);\n<line18>atexit (close_stdout);\n<line19>while (true)\n<line20>{\n<line21>int c = getopt_long (argc, argv, "d:z", longopts, nullptr);\n<line22>if (c == -1)\n<line23>break;\n<line24>switch (c)\n<line25>{\n<line26>case FROM_OPTION:\n<line27>scale_from = XARGMATCH ("--from", optarg,\n<line28>scale_from_args, scale_from_types);\n<line29>break;\n<line30>case FROM_UNIT_OPTION:\n<line31>from_unit_size = unit_to_umax (optarg);\n<line32>break;\n<line33>case TO_OPTION:\n<line34>scale_to =\n<line35>XARGMATCH ("--to", optarg, scale_to_args, scale_to_types);\n<line36>break;\n<line37>case TO_UNIT_OPTION:\n<line38>to_unit_size = unit_to_umax (optarg);\n<line39>break;\n<line40>case ROUND_OPTION:\n<line41>round_style = XARGMATCH ("--round", optarg, round_args, round_types);\n<line42>break;\n<line43>case GROUPING_OPTION:\n<line44>grouping = 1;\n<line45>break;\n<line46>case PADDING_OPTION:\n<line47>if (xstrtol (optarg, nullptr, 10, &padding_width, "") != LONGINT_OK\n<line48>|| padding_width == 0 || padding_width < -LONG_MAX)\n<line49>error (EXIT_FAILURE, 0, _("invalid padding value %s"),\n<line50>quote (optarg));\n<line51>if (padding_width < 0)\n<line52>{\n<line53>padding_alignment = MBS_ALIGN_LEFT;\n<line54>padding_width = -padding_width;\n<line55>}\n<line56>/* TODO: We probably want to apply a specific --padding\n<line57>to --header lines too.  */\n<line58>break;\n<line59>case FIELD_OPTION:\n<line60>if (n_frp)\n<line61>error (EXIT_FAILURE, 0, _("multiple field specifications"));\n<line62>set_fields (optarg, SETFLD_ALLOW_DASH);\n<line63>break;\n<line64>case 'd':\n<line65>/* Interpret -d '' to mean 'use the NUL byte as the delimiter.'  */\n<line66>if (optarg[0] != '\0' && optarg[1] != '\0')\n<line67>error (EXIT_FAILURE, 0,\n<line68>_("the delimiter must be a single character"));\n<line69>delimiter = optarg[0];\n<line70>break;\n<line71>case 'z':\n<line72>line_delim = '\0';\n<line73>break;\n<line74>case SUFFIX_OPTION:\n<line75>suffix = optarg;\n<line76>break;\n<line77>case DEBUG_OPTION:\n<line78>debug = true;\n<line79>break;\n<line80>case DEV_DEBUG_OPTION:\n<line81>dev_debug = true;\n<line82>debug = true;\n<line83>break;\n<line84>case HEADER_OPTION:\n<line85>if (optarg)\n<line86>{\n<line87>if (xstrtoumax (optarg, nullptr, 10, &header, "") != LONGINT_OK\n<line88>|| header == 0)\n<line89>error (EXIT_FAILURE, 0, _("invalid header value %s"),\n<line90>quote (optarg));\n<line91>}\n<line92>else\n<line93>{\n<line94>header = 1;\n<line95>}\n<line96>break;\n<line97>case FORMAT_OPTION:\n<line98>format_str = optarg;\n<line99>break;\n<line100>case INVALID_OPTION:\n<line101>inval_style = XARGMATCH ("--invalid", optarg,\n<line102>inval_args, inval_types);\n<line103>break;\n<line104>case_GETOPT_HELP_CHAR;\n<line105>case_GETOPT_VERSION_CHAR (PROGRAM_NAME, AUTHORS);\n<line106>default:\n<line107>usage (EXIT_FAILURE);\n<line108>}\n<line109>}\n<line110>if (format_str != nullptr && grouping)\n<line111>error (EXIT_FAILURE, 0, _("--grouping cannot be combined with --format"));\n<line112>if (debug && ! locale_ok)\n<line113>error (0, 0, _("failed to set locale"));\n<line114>/* Warn about no-op.  */\n<line115>if (debug && scale_from == scale_none && scale_to == scale_none\n<line116>&& !grouping && (padding_width == 0) && (format_str == nullptr))\n<line117>error (0, 0, _("no conversion option specified"));\n<line118>if (format_str)\n<line119>parse_format_string (format_str);\n<line120>if (grouping)\n<line121>{\n<line122>if (scale_to != scale_none)\n<line123>error (EXIT_FAILURE, 0, _("grouping cannot be combined with --to"));\n<line124>if (debug && (strlen (nl_langinfo (THOUSEP)) == 0))\n<line125>error (0, 0, _("grouping has no effect in this locale"));\n<line126>}\n<line127>setup_padding_buffer (padding_width);\n<line128>auto_padding = (padding_width == 0 && delimiter == DELIMITER_DEFAULT);\n<line129>if (inval_style != inval_abort)\n<line130>conv_exit_code = 0;\n<line131>if (argc > optind)\n<line132>{\n<line133>if (debug && header)\n<line134>error (0, 0, _("--header ignored with command-line input"));\n<line135>for (; optind < argc; optind++)\n<line136>valid_numbers &= process_line (argv[optind], true);\n<line137>}\n<line138>else\n<line139>{\n<line140>char *line = nullptr;\n<line141>size_t line_allocated = 0;\n<line142>ssize_t len;\n<line143>while (header-- && getdelim (&line, &line_allocated,\n<line144>line_delim, stdin) > 0)\n<line145>fputs (line, stdout);\n<line146>while ((len = getdelim (&line, &line_allocated,\n<line147>line_delim, stdin)) > 0)\n<line148>{\n<line149>bool newline = line[len - 1] == line_delim;\n<line150>if (newline)\n<line151>line[len - 1] = '\0';\n<line152>valid_numbers &= process_line (line, newline);\n<line153>}\n<line154>if (ferror (stdin))\n<line155>error (EXIT_FAILURE, errno, _("error reading input"));\n<line156>}\n<line157>if (debug && !valid_numbers)\n<line158>error (0, 0, _("failed to convert some of the input numbers"));\n<line159>int exit_status = EXIT_SUCCESS;\n<line160>if (!valid_numbers\n<line161>&& inval_style != inval_warn && inval_style != inval_ignore)\n<line162>exit_status = EXIT_CONVERSION_WARNINGS;\n<line163>main_exit (exit_status);\n<line164>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/src/od.c
========================================
/home/huihui/Downloads/coreutils-9.4/src/od.c:96:59: warning: '_Static_assert' with no message is a C2x extension [-Wc2x-extensions]
static_assert (MAX_INTEGRAL_TYPE_SIZE * CHAR_BIT / 3 <= 99);
                                                          ^
                                                          , ""
/home/huihui/Downloads/coreutils-9.4/src/od.c:142:57: warning: '_Static_assert' with no message is a C2x extension [-Wc2x-extensions]
               < ARRAY_CARDINALITY (bytes_to_hex_digits));
                                                        ^
                                                        , ""
/home/huihui/Downloads/coreutils-9.4/src/od.c:145:79: warning: '_Static_assert' with no message is a C2x extension [-Wc2x-extensions]
static_assert (sizeof bytes_to_oct_digits == sizeof bytes_to_signed_dec_digits);
                                                                              ^
                                                                              , ""
/home/huihui/Downloads/coreutils-9.4/src/od.c:147:54: warning: '_Static_assert' with no message is a C2x extension [-Wc2x-extensions]
               == sizeof bytes_to_unsigned_dec_digits);
                                                     ^
                                                     , ""
/home/huihui/Downloads/coreutils-9.4/src/od.c:148:72: warning: '_Static_assert' with no message is a C2x extension [-Wc2x-extensions]
static_assert (sizeof bytes_to_oct_digits == sizeof bytes_to_hex_digits);
                                                                       ^
                                                                       , ""
/home/huihui/Downloads/coreutils-9.4/src/od.c:166:63: warning: '_Static_assert' with no message is a C2x extension [-Wc2x-extensions]
static_assert (ARRAY_CARDINALITY (width_bytes) == N_SIZE_SPECS);
                                                              ^
                                                              , ""
6 warnings generated.
Function: usage
Content: <line0>void\n<line1>usage (int status)\n<line2>{\n<line3>if (status != EXIT_SUCCESS)\n<line4>emit_try_help ();\n<line5>else\n<line6>{\n<line7>printf (_("\\n<line8>Usage: %s [OPTION]... [FILE]...\n\\n<line9>or:  %s [-abcdfilosx]... [FILE] [[+]OFFSET[.][b]]\n\\n<line10>or:  %s --traditional [OPTION]... [FILE] [[+]OFFSET[.][b] [+][LABEL][.][b]]\n\\n<line11>"),\n<line12>program_name, program_name, program_name);\n<line13>fputs (_("\n\\n<line14>Write an unambiguous representation, octal bytes by default,\n\\n<line15>of FILE to standard output.  With more than one FILE argument,\n\\n<line16>concatenate them in the listed order to form the input.\n\\n<line17>"), stdout);\n<line18>emit_stdin_note ();\n<line19>fputs (_("\\n<line20>\n\\n<line21>If first and second call formats both apply, the second format is assumed\n\\n<line22>if the last operand begins with + or (if there are 2 operands) a digit.\n\\n<line23>An OFFSET operand means -j OFFSET.  LABEL is the pseudo-address\n\\n<line24>at first byte printed, incremented when dump is progressing.\n\\n<line25>For OFFSET and LABEL, a 0x or 0X prefix indicates hexadecimal;\n\\n<line26>suffixes may be . for octal and b for multiply by 512.\n\\n<line27>"), stdout);\n<line28>emit_mandatory_arg_note ();\n<line29>fputs (_("\\n<line30>-A, --address-radix=RADIX   output format for file offsets; RADIX is one\n\\n<line31>of [doxn], for Decimal, Octal, Hex or None\n\\n<line32>--endian={big|little}   swap input bytes according the specified order\n\\n<line33>-j, --skip-bytes=BYTES      skip BYTES input bytes first\n\\n<line34>"), stdout);\n<line35>fputs (_("\\n<line36>-N, --read-bytes=BYTES      limit dump to BYTES input bytes\n\\n<line37>-S BYTES, --strings[=BYTES]  show only NUL terminated strings\n\\n<line38>of at least BYTES (3) printable characters\n\\n<line39>-t, --format=TYPE           select output format or formats\n\\n<line40>-v, --output-duplicates     do not use * to mark line suppression\n\\n<line41>-w[BYTES], --width[=BYTES]  output BYTES bytes per output line;\n\\n<line42>32 is implied when BYTES is not specified\n\\n<line43>--traditional           accept arguments in third form above\n\\n<line44>"), stdout);\n<line45>fputs (HELP_OPTION_DESCRIPTION, stdout);\n<line46>fputs (VERSION_OPTION_DESCRIPTION, stdout);\n<line47>fputs (_("\\n<line48>\n\\n<line49>\n\\n<line50>Traditional format specifications may be intermixed; they accumulate:\n\\n<line51>-a   same as -t a,  select named characters, ignoring high-order bit\n\\n<line52>-b   same as -t o1, select octal bytes\n\\n<line53>-c   same as -t c,  select printable characters or backslash escapes\n\\n<line54>-d   same as -t u2, select unsigned decimal 2-byte units\n\\n<line55>"), stdout);\n<line56>fputs (_("\\n<line57>-f   same as -t fF, select floats\n\\n<line58>-i   same as -t dI, select decimal ints\n\\n<line59>-l   same as -t dL, select decimal longs\n\\n<line60>-o   same as -t o2, select octal 2-byte units\n\\n<line61>-s   same as -t d2, select decimal 2-byte units\n\\n<line62>-x   same as -t x2, select hexadecimal 2-byte units\n\\n<line63>"), stdout);\n<line64>fputs (_("\\n<line65>\n\\n<line66>\n\\n<line67>TYPE is made up of one or more of these specifications:\n\\n<line68>a          named character, ignoring high-order bit\n\\n<line69>c          printable character or backslash escape\n\\n<line70>"), stdout);\n<line71>fputs (_("\\n<line72>d[SIZE]    signed decimal, SIZE bytes per integer\n\\n<line73>f[SIZE]    floating point, SIZE bytes per float\n\\n<line74>o[SIZE]    octal, SIZE bytes per integer\n\\n<line75>u[SIZE]    unsigned decimal, SIZE bytes per integer\n\\n<line76>x[SIZE]    hexadecimal, SIZE bytes per integer\n\\n<line77>"), stdout);\n<line78>fputs (_("\\n<line79>\n\\n<line80>SIZE is a number.  For TYPE in [doux], SIZE may also be C for\n\\n<line81>sizeof(char), S for sizeof(short), I for sizeof(int) or L for\n\\n<line82>sizeof(long).  If TYPE is f, SIZE may also be F for sizeof(float), D\n\\n<line83>for sizeof(double) or L for sizeof(long double).\n\\n<line84>"), stdout);\n<line85>fputs (_("\\n<line86>\n\\n<line87>Adding a z suffix to any type displays printable characters at the end of\n\\n<line88>each output line.\n\\n<line89>"), stdout);\n<line90>fputs (_("\\n<line91>\n\\n<line92>\n\\n<line93>BYTES is hex with 0x or 0X prefix, and may have a multiplier suffix:\n\\n<line94>b    512\n\\n<line95>KB   1000\n\\n<line96>K    1024\n\\n<line97>MB   1000*1000\n\\n<line98>M    1024*1024\n\\n<line99>and so on for G, T, P, E, Z, Y, R, Q.\n\\n<line100>Binary prefixes can be used, too: KiB=K, MiB=M, and so on.\n\\n<line101>"), stdout);\n<line102>emit_ancillary_info (PROGRAM_NAME);\n<line103>}\n<line104>exit (status);\n<line105>}
----------------------------------------
Function: dump_hexl_mode_trailer
Content: <line0>static void\n<line1>dump_hexl_mode_trailer (size_t n_bytes, char const *block)\n<line2>{\n<line3>fputs ("  >", stdout);\n<line4>for (size_t i = n_bytes; i > 0; i--)\n<line5>{\n<line6>unsigned char c = *block++;\n<line7>unsigned char c2 = (isprint (c) ? c : '.');\n<line8>putchar (c2);\n<line9>}\n<line10>putchar ('<');\n<line11>}
----------------------------------------
Function: print_named_ascii
Content: <line0>static void\n<line1>print_named_ascii (size_t fields, size_t blank, void const *block,\n<line2>MAYBE_UNUSED char const *unused_fmt_string,\n<line3>int width, int pad)\n<line4>{\n<line5>unsigned char const *p = block;\n<line6>uintmax_t i;\n<line7>int pad_remaining = pad;\n<line8>for (i = fields; blank < i; i--)\n<line9>{\n<line10>int next_pad = pad * (i - 1) / fields;\n<line11>int masked_c = *p++ & 0x7f;\n<line12>char const *s;\n<line13>char buf[2];\n<line14>if (masked_c == 127)\n<line15>s = "del";\n<line16>else if (masked_c <= 040)\n<line17>s = charname[masked_c];\n<line18>else\n<line19>{\n<line20>buf[0] = masked_c;\n<line21>buf[1] = 0;\n<line22>s = buf;\n<line23>}\n<line24>xprintf ("%*s", pad_remaining - next_pad + width, s);\n<line25>pad_remaining = next_pad;\n<line26>}\n<line27>}
----------------------------------------
Function: print_ascii
Content: <line0>static void\n<line1>print_ascii (size_t fields, size_t blank, void const *block,\n<line2>MAYBE_UNUSED char const *unused_fmt_string, int width,\n<line3>int pad)\n<line4>{\n<line5>unsigned char const *p = block;\n<line6>uintmax_t i;\n<line7>int pad_remaining = pad;\n<line8>for (i = fields; blank < i; i--)\n<line9>{\n<line10>int next_pad = pad * (i - 1) / fields;\n<line11>unsigned char c = *p++;\n<line12>char const *s;\n<line13>char buf[4];\n<line14>switch (c)\n<line15>{\n<line16>case '\0':\n<line17>s = "\\0";\n<line18>break;\n<line19>case '\a':\n<line20>s = "\\a";\n<line21>break;\n<line22>case '\b':\n<line23>s = "\\b";\n<line24>break;\n<line25>case '\f':\n<line26>s = "\\f";\n<line27>break;\n<line28>case '\n':\n<line29>s = "\\n";\n<line30>break;\n<line31>case '\r':\n<line32>s = "\\r";\n<line33>break;\n<line34>case '\t':\n<line35>s = "\\t";\n<line36>break;\n<line37>case '\v':\n<line38>s = "\\v";\n<line39>break;\n<line40>default:\n<line41>sprintf (buf, (isprint (c) ? "%c" : "%03o"), c);\n<line42>s = buf;\n<line43>}\n<line44>xprintf ("%*s", pad_remaining - next_pad + width, s);\n<line45>pad_remaining = next_pad;\n<line46>}\n<line47>}
----------------------------------------
Function: simple_strtoi
Content: <line0>static bool\n<line1>simple_strtoi (char const *s, char const **p, int *val)\n<line2>{\n<line3>int sum;\n<line4>for (sum = 0; ISDIGIT (*s); s++)\n<line5>if (ckd_mul (&sum, sum, 10) || ckd_add (&sum, sum, *s - '0'))\n<line6>return false;\n<line7>*p = s;\n<line8>*val = sum;\n<line9>return true;\n<line10>}
----------------------------------------
Function: decode_one_format
Content: <line0>static bool ATTRIBUTE_NONNULL ()\n<line1>decode_one_format (char const *s_orig, char const *s, char const **next,\n<line2>struct tspec *tspec)\n<line3>{\n<line4>enum size_spec size_spec;\n<line5>int size;\n<line6>enum output_format fmt;\n<line7>void (*print_function) (size_t, size_t, void const *, char const *,\n<line8>int, int);\n<line9>char const *p;\n<line10>char c;\n<line11>int field_width;\n<line12>switch (*s)\n<line13>{\n<line14>case 'd':\n<line15>case 'o':\n<line16>case 'u':\n<line17>case 'x':\n<line18>c = *s;\n<line19>++s;\n<line20>switch (*s)\n<line21>{\n<line22>case 'C':\n<line23>++s;\n<line24>size = sizeof (char);\n<line25>break;\n<line26>case 'S':\n<line27>++s;\n<line28>size = sizeof (short int);\n<line29>break;\n<line30>case 'I':\n<line31>++s;\n<line32>size = sizeof (int);\n<line33>break;\n<line34>case 'L':\n<line35>++s;\n<line36>size = sizeof (long int);\n<line37>break;\n<line38>default:\n<line39>if (! simple_strtoi (s, &p, &size))\n<line40>{\n<line41>/* The integer at P in S would overflow an int.\n<line42>A digit string that long is sufficiently odd looking\n<line43>that the following diagnostic is sufficient.  */\n<line44>error (0, 0, _("invalid type string %s"), quote (s_orig));\n<line45>return false;\n<line46>}\n<line47>if (p == s)\n<line48>size = sizeof (int);\n<line49>else\n<line50>{\n<line51>if (MAX_INTEGRAL_TYPE_SIZE < size\n<line52>|| integral_type_size[size] == NO_SIZE)\n<line53>{\n<line54>error (0, 0, _("invalid type string %s;\nthis system"\n<line55>" doesn't provide a %d-byte integral type"),\n<line56>quote (s_orig), size);\n<line57>return false;\n<line58>}\n<line59>s = p;\n<line60>}\n<line61>break;\n<line62>}\n<line63>#define ISPEC_TO_FORMAT(Spec, Min_format, Long_format, Max_format)	\\n<line64>((Spec) == LONG_LONG ? (Max_format)					\\n<line65>: ((Spec) == LONG ? (Long_format)					\\n<line66>: (Min_format)))							\\n<line67>size_spec = integral_type_size[size];\n<line68>switch (c)\n<line69>{\n<line70>case 'd':\n<line71>fmt = SIGNED_DECIMAL;\n<line72>field_width = bytes_to_signed_dec_digits[size];\n<line73>sprintf (tspec->fmt_string, "%%*%s",\n<line74>ISPEC_TO_FORMAT (size_spec, "d", "ld", PRIdMAX));\n<line75>break;\n<line76>case 'o':\n<line77>fmt = OCTAL;\n<line78>sprintf (tspec->fmt_string, "%%*.%d%s",\n<line79>(field_width = bytes_to_oct_digits[size]),\n<line80>ISPEC_TO_FORMAT (size_spec, "o", "lo", PRIoMAX));\n<line81>break;\n<line82>case 'u':\n<line83>fmt = UNSIGNED_DECIMAL;\n<line84>field_width = bytes_to_unsigned_dec_digits[size];\n<line85>sprintf (tspec->fmt_string, "%%*%s",\n<line86>ISPEC_TO_FORMAT (size_spec, "u", "lu", PRIuMAX));\n<line87>break;\n<line88>case 'x':\n<line89>fmt = HEXADECIMAL;\n<line90>sprintf (tspec->fmt_string, "%%*.%d%s",\n<line91>(field_width = bytes_to_hex_digits[size]),\n<line92>ISPEC_TO_FORMAT (size_spec, "x", "lx", PRIxMAX));\n<line93>break;\n<line94>default:\n<line95>unreachable ();\n<line96>}\n<line97>switch (size_spec)\n<line98>{\n<line99>case CHAR:\n<line100>print_function = (fmt == SIGNED_DECIMAL\n<line101>? print_s_char\n<line102>: print_char);\n<line103>break;\n<line104>case SHORT:\n<line105>print_function = (fmt == SIGNED_DECIMAL\n<line106>? print_s_short\n<line107>: print_short);\n<line108>break;\n<line109>case INT:\n<line110>print_function = print_int;\n<line111>break;\n<line112>case LONG:\n<line113>print_function = print_long;\n<line114>break;\n<line115>case LONG_LONG:\n<line116>print_function = print_long_long;\n<line117>break;\n<line118>default:\n<line119>affirm (false);\n<line120>}\n<line121>break;\n<line122>case 'f':\n<line123>fmt = FLOATING_POINT;\n<line124>++s;\n<line125>switch (*s)\n<line126>{\n<line127>case 'F':\n<line128>++s;\n<line129>size = sizeof (float);\n<line130>break;\n<line131>case 'D':\n<line132>++s;\n<line133>size = sizeof (double);\n<line134>break;\n<line135>case 'L':\n<line136>++s;\n<line137>size = sizeof (long double);\n<line138>break;\n<line139>default:\n<line140>if (! simple_strtoi (s, &p, &size))\n<line141>{\n<line142>/* The integer at P in S would overflow an int.\n<line143>A digit string that long is sufficiently odd looking\n<line144>that the following diagnostic is sufficient.  */\n<line145>error (0, 0, _("invalid type string %s"), quote (s_orig));\n<line146>return false;\n<line147>}\n<line148>if (p == s)\n<line149>size = sizeof (double);\n<line150>else\n<line151>{\n<line152>if (size > MAX_FP_TYPE_SIZE\n<line153>|| fp_type_size[size] == NO_SIZE)\n<line154>{\n<line155>error (0, 0,\n<line156>_("invalid type string %s;\n"\n<line157>"this system doesn't provide a %d-byte"\n<line158>" floating point type"),\n<line159>quote (s_orig), size);\n<line160>return false;\n<line161>}\n<line162>s = p;\n<line163>}\n<line164>break;\n<line165>}\n<line166>size_spec = fp_type_size[size];\n<line167>{\n<line168>struct lconv const *locale = localeconv ();\n<line169>size_t decimal_point_len =\n<line170>(locale->decimal_point[0] ? strlen (locale->decimal_point) : 1);\n<line171>switch (size_spec)\n<line172>{\n<line173>case FLOAT_SINGLE:\n<line174>print_function = print_float;\n<line175>field_width = FLT_STRLEN_BOUND_L (decimal_point_len);\n<line176>break;\n<line177>case FLOAT_DOUBLE:\n<line178>print_function = print_double;\n<line179>field_width = DBL_STRLEN_BOUND_L (decimal_point_len);\n<line180>break;\n<line181>case FLOAT_LONG_DOUBLE:\n<line182>print_function = print_long_double;\n<line183>field_width = LDBL_STRLEN_BOUND_L (decimal_point_len);\n<line184>break;\n<line185>default:\n<line186>affirm (false);\n<line187>}\n<line188>break;\n<line189>}\n<line190>case 'a':\n<line191>++s;\n<line192>fmt = NAMED_CHARACTER;\n<line193>size_spec = CHAR;\n<line194>print_function = print_named_ascii;\n<line195>field_width = 3;\n<line196>break;\n<line197>case 'c':\n<line198>++s;\n<line199>fmt = CHARACTER;\n<line200>size_spec = CHAR;\n<line201>print_function = print_ascii;\n<line202>field_width = 3;\n<line203>break;\n<line204>default:\n<line205>error (0, 0, _("invalid character '%c' in type string %s"),\n<line206>*s, quote (s_orig));\n<line207>return false;\n<line208>}\n<line209>tspec->size = size_spec;\n<line210>tspec->fmt = fmt;\n<line211>tspec->print_function = print_function;\n<line212>tspec->field_width = field_width;\n<line213>tspec->hexl_mode_trailer = (*s == 'z');\n<line214>if (tspec->hexl_mode_trailer)\n<line215>s++;\n<line216>*next = s;\n<line217>return true;\n<line218>}
----------------------------------------
Function: open_next_file
Content: <line0>static bool\n<line1>open_next_file (void)\n<line2>{\n<line3>bool ok = true;\n<line4>do\n<line5>{\n<line6>input_filename = *file_list;\n<line7>if (input_filename == nullptr)\n<line8>return ok;\n<line9>++file_list;\n<line10>if (STREQ (input_filename, "-"))\n<line11>{\n<line12>input_filename = _("standard input");\n<line13>in_stream = stdin;\n<line14>have_read_stdin = true;\n<line15>xset_binary_mode (STDIN_FILENO, O_BINARY);\n<line16>}\n<line17>else\n<line18>{\n<line19>in_stream = fopen (input_filename, (O_BINARY ? "rb" : "r"));\n<line20>if (in_stream == nullptr)\n<line21>{\n<line22>error (0, errno, "%s", quotef (input_filename));\n<line23>ok = false;\n<line24>}\n<line25>}\n<line26>}\n<line27>while (in_stream == nullptr);\n<line28>if (limit_bytes_to_format && !flag_dump_strings)\n<line29>setvbuf (in_stream, nullptr, _IONBF, 0);\n<line30>return ok;\n<line31>}
----------------------------------------
Function: check_and_close
Content: <line0>static bool\n<line1>check_and_close (int in_errno)\n<line2>{\n<line3>bool ok = true;\n<line4>if (in_stream != nullptr)\n<line5>{\n<line6>if (!ferror (in_stream))\n<line7>in_errno = 0;\n<line8>if (STREQ (file_list[-1], "-"))\n<line9>clearerr (in_stream);\n<line10>else if (fclose (in_stream) != 0 && !in_errno)\n<line11>in_errno = errno;\n<line12>if (in_errno)\n<line13>{\n<line14>error (0, in_errno, "%s", quotef (input_filename));\n<line15>ok = false;\n<line16>}\n<line17>in_stream = nullptr;\n<line18>}\n<line19>if (ferror (stdout))\n<line20>{\n<line21>error (0, 0, _("write error"));\n<line22>ok = false;\n<line23>}\n<line24>return ok;\n<line25>}
----------------------------------------
Function: decode_format_string
Content: <line0>static bool ATTRIBUTE_NONNULL ()\n<line1>decode_format_string (char const *s)\n<line2>{\n<line3>char const *s_orig = s;\n<line4>while (*s != '\0')\n<line5>{\n<line6>char const *next;\n<line7>if (n_specs_allocated <= n_specs)\n<line8>spec = X2NREALLOC (spec, &n_specs_allocated);\n<line9>if (! decode_one_format (s_orig, s, &next, &spec[n_specs]))\n<line10>return false;\n<line11>affirm (s != next);\n<line12>s = next;\n<line13>++n_specs;\n<line14>}\n<line15>return true;\n<line16>}
----------------------------------------
Function: skip
Content: <line0>static bool\n<line1>skip (uintmax_t n_skip)\n<line2>{\n<line3>bool ok = true;\n<line4>int in_errno = 0;\n<line5>if (n_skip == 0)\n<line6>return true;\n<line7>while (in_stream != nullptr)	/* EOF.  */\n<line8>{\n<line9>struct stat file_stats;\n<line10>/* First try seeking.  For large offsets, this extra work is\n<line11>worthwhile.  If the offset is below some threshold it may be\n<line12>more efficient to move the pointer by reading.  There are two\n<line13>issues when trying to seek:\n<line14>- the file must be seekable.\n<line15>- before seeking to the specified position, make sure\n<line16>that the new position is in the current file.\n<line17>Try to do that by getting file's size using fstat.\n<line18>But that will work only for regular files.  */\n<line19>if (fstat (fileno (in_stream), &file_stats) == 0)\n<line20>{\n<line21>bool usable_size = usable_st_size (&file_stats);\n<line22>/* The st_size field is valid for regular files.\n<line23>If the number of bytes left to skip is larger than\n<line24>the size of the current file, we can decrement n_skip\n<line25>and go on to the next file.  Skip this optimization also\n<line26>when st_size is no greater than the block size, because\n<line27>some kernels report nonsense small file sizes for\n<line28>proc-like file systems.  */\n<line29>if (usable_size && ST_BLKSIZE (file_stats) < file_stats.st_size)\n<line30>{\n<line31>if ((uintmax_t) file_stats.st_size < n_skip)\n<line32>n_skip -= file_stats.st_size;\n<line33>else\n<line34>{\n<line35>if (fseeko (in_stream, n_skip, SEEK_CUR) != 0)\n<line36>{\n<line37>in_errno = errno;\n<line38>ok = false;\n<line39>}\n<line40>n_skip = 0;\n<line41>}\n<line42>}\n<line43>else if (!usable_size && fseeko (in_stream, n_skip, SEEK_CUR) == 0)\n<line44>n_skip = 0;\n<line45>/* If it's not a regular file with nonnegative size,\n<line46>or if it's so small that it might be in a proc-like file system,\n<line47>position the file pointer by reading.  */\n<line48>else\n<line49>{\n<line50>char buf[BUFSIZ];\n<line51>size_t n_bytes_read, n_bytes_to_read = BUFSIZ;\n<line52>while (0 < n_skip)\n<line53>{\n<line54>if (n_skip < n_bytes_to_read)\n<line55>n_bytes_to_read = n_skip;\n<line56>n_bytes_read = fread (buf, 1, n_bytes_to_read, in_stream);\n<line57>n_skip -= n_bytes_read;\n<line58>if (n_bytes_read != n_bytes_to_read)\n<line59>{\n<line60>if (ferror (in_stream))\n<line61>{\n<line62>in_errno = errno;\n<line63>ok = false;\n<line64>n_skip = 0;\n<line65>break;\n<line66>}\n<line67>if (feof (in_stream))\n<line68>break;\n<line69>}\n<line70>}\n<line71>}\n<line72>if (n_skip == 0)\n<line73>break;\n<line74>}\n<line75>else   /* cannot fstat() file */\n<line76>{\n<line77>error (0, errno, "%s", quotef (input_filename));\n<line78>ok = false;\n<line79>}\n<line80>ok &= check_and_close (in_errno);\n<line81>ok &= open_next_file ();\n<line82>}\n<line83>if (n_skip != 0)\n<line84>error (EXIT_FAILURE, 0, _("cannot skip past end of combined input"));\n<line85>return ok;\n<line86>}
----------------------------------------
Function: format_address_none
Content: <line0>static void\n<line1>format_address_none (MAYBE_UNUSED uintmax_t address,\n<line2>MAYBE_UNUSED char c)\n<line3>{\n<line4>}
----------------------------------------
Function: format_address_std
Content: <line0>static void\n<line1>format_address_std (uintmax_t address, char c)\n<line2>{\n<line3>char buf[MAX_ADDRESS_LENGTH + 2];\n<line4>char *p = buf + sizeof buf;\n<line5>char const *pbound;\n<line6>*--p = '\0';\n<line7>*--p = c;\n<line8>pbound = p - address_pad_len;\n<line9>/* Use a special case of the code for each base.  This is measurably\n<line10>faster than generic code.  */\n<line11>switch (address_base)\n<line12>{\n<line13>case 8:\n<line14>do\n<line15>*--p = '0' + (address & 7);\n<line16>while ((address >>= 3) != 0);\n<line17>break;\n<line18>case 10:\n<line19>do\n<line20>*--p = '0' + (address % 10);\n<line21>while ((address /= 10) != 0);\n<line22>break;\n<line23>case 16:\n<line24>do\n<line25>*--p = "0123456789abcdef"[address & 15];\n<line26>while ((address >>= 4) != 0);\n<line27>break;\n<line28>}\n<line29>while (pbound < p)\n<line30>*--p = '0';\n<line31>fputs (p, stdout);\n<line32>}
----------------------------------------
Function: format_address_paren
Content: <line0>static void\n<line1>format_address_paren (uintmax_t address, char c)\n<line2>{\n<line3>putchar ('(');\n<line4>format_address_std (address, ')');\n<line5>if (c)\n<line6>putchar (c);\n<line7>}
----------------------------------------
Function: format_address_label
Content: <line0>static void\n<line1>format_address_label (uintmax_t address, char c)\n<line2>{\n<line3>format_address_std (address, ' ');\n<line4>format_address_paren (address + pseudo_offset, c);\n<line5>}
----------------------------------------
Function: write_block
Content: <line0>static void\n<line1>write_block (uintmax_t current_offset, size_t n_bytes,\n<line2>char const *prev_block, char const *curr_block)\n<line3>{\n<line4>static bool first = true;\n<line5>static bool prev_pair_equal = false;\n<line6>#define EQUAL_BLOCKS(b1, b2) (memcmp (b1, b2, bytes_per_block) == 0)\n<line7>if (abbreviate_duplicate_blocks\n<line8>&& !first && n_bytes == bytes_per_block\n<line9>&& EQUAL_BLOCKS (prev_block, curr_block))\n<line10>{\n<line11>if (prev_pair_equal)\n<line12>{\n<line13>/* The two preceding blocks were equal, and the current\n<line14>block is the same as the last one, so print nothing.  */\n<line15>}\n<line16>else\n<line17>{\n<line18>printf ("*\n");\n<line19>prev_pair_equal = true;\n<line20>}\n<line21>}\n<line22>else\n<line23>{\n<line24>prev_pair_equal = false;\n<line25>for (size_t i = 0; i < n_specs; i++)\n<line26>{\n<line27>int datum_width = width_bytes[spec[i].size];\n<line28>int fields_per_block = bytes_per_block / datum_width;\n<line29>int blank_fields = (bytes_per_block - n_bytes) / datum_width;\n<line30>if (i == 0)\n<line31>format_address (current_offset, '\0');\n<line32>else\n<line33>printf ("%*s", address_pad_len, "");\n<line34>(*spec[i].print_function) (fields_per_block, blank_fields,\n<line35>curr_block, spec[i].fmt_string,\n<line36>spec[i].field_width, spec[i].pad_width);\n<line37>if (spec[i].hexl_mode_trailer)\n<line38>{\n<line39>/* space-pad out to full line width, then dump the trailer */\n<line40>int field_width = spec[i].field_width;\n<line41>int pad_width = (spec[i].pad_width * blank_fields\n<line42>/ fields_per_block);\n<line43>printf ("%*s", blank_fields * field_width + pad_width, "");\n<line44>dump_hexl_mode_trailer (n_bytes, curr_block);\n<line45>}\n<line46>putchar ('\n');\n<line47>}\n<line48>}\n<line49>first = false;\n<line50>}
----------------------------------------
Function: read_char
Content: <line0>static bool\n<line1>read_char (int *c)\n<line2>{\n<line3>bool ok = true;\n<line4>*c = EOF;\n<line5>while (in_stream != nullptr)	/* EOF.  */\n<line6>{\n<line7>*c = fgetc (in_stream);\n<line8>if (*c != EOF)\n<line9>break;\n<line10>ok &= check_and_close (errno);\n<line11>ok &= open_next_file ();\n<line12>}\n<line13>return ok;\n<line14>}
----------------------------------------
Function: read_block
Content: <line0>static bool\n<line1>read_block (size_t n, char *block, size_t *n_bytes_in_buffer)\n<line2>{\n<line3>bool ok = true;\n<line4>affirm (0 < n && n <= bytes_per_block);\n<line5>*n_bytes_in_buffer = 0;\n<line6>while (in_stream != nullptr)	/* EOF.  */\n<line7>{\n<line8>size_t n_needed;\n<line9>size_t n_read;\n<line10>n_needed = n - *n_bytes_in_buffer;\n<line11>n_read = fread (block + *n_bytes_in_buffer, 1, n_needed, in_stream);\n<line12>*n_bytes_in_buffer += n_read;\n<line13>if (n_read == n_needed)\n<line14>break;\n<line15>ok &= check_and_close (errno);\n<line16>ok &= open_next_file ();\n<line17>}\n<line18>return ok;\n<line19>}
----------------------------------------
Function: parse_old_offset
Content: <line0>static bool\n<line1>parse_old_offset (char const *s, uintmax_t *offset)\n<line2>{\n<line3>int radix;\n<line4>if (*s == '\0')\n<line5>return false;\n<line6>/* Skip over any leading '+'. */\n<line7>if (s[0] == '+')\n<line8>++s;\n<line9>/* Determine the radix we'll use to interpret S.  If there is a '.',\n<line10>it's decimal, otherwise, if the string begins with '0X'or '0x',\n<line11>it's hexadecimal, else octal.  */\n<line12>if (strchr (s, '.') != nullptr)\n<line13>radix = 10;\n<line14>else\n<line15>{\n<line16>if (s[0] == '0' && (s[1] == 'x' || s[1] == 'X'))\n<line17>radix = 16;\n<line18>else\n<line19>radix = 8;\n<line20>}\n<line21>return xstrtoumax (s, nullptr, radix, offset, "Bb") == LONGINT_OK;\n<line22>}
----------------------------------------
Function: dump
Content: <line0>static bool\n<line1>dump (void)\n<line2>{\n<line3>char *block[2];\n<line4>uintmax_t current_offset;\n<line5>bool idx = false;\n<line6>bool ok = true;\n<line7>size_t n_bytes_read;\n<line8>block[0] = xnmalloc (2, bytes_per_block);\n<line9>block[1] = block[0] + bytes_per_block;\n<line10>current_offset = n_bytes_to_skip;\n<line11>if (limit_bytes_to_format)\n<line12>{\n<line13>while (ok)\n<line14>{\n<line15>size_t n_needed;\n<line16>if (current_offset >= end_offset)\n<line17>{\n<line18>n_bytes_read = 0;\n<line19>break;\n<line20>}\n<line21>n_needed = MIN (end_offset - current_offset,\n<line22>(uintmax_t) bytes_per_block);\n<line23>ok &= read_block (n_needed, block[idx], &n_bytes_read);\n<line24>if (n_bytes_read < bytes_per_block)\n<line25>break;\n<line26>affirm (n_bytes_read == bytes_per_block);\n<line27>write_block (current_offset, n_bytes_read,\n<line28>block[!idx], block[idx]);\n<line29>if (ferror (stdout))\n<line30>ok = false;\n<line31>current_offset += n_bytes_read;\n<line32>idx = !idx;\n<line33>}\n<line34>}\n<line35>else\n<line36>{\n<line37>while (ok)\n<line38>{\n<line39>ok &= read_block (bytes_per_block, block[idx], &n_bytes_read);\n<line40>if (n_bytes_read < bytes_per_block)\n<line41>break;\n<line42>affirm (n_bytes_read == bytes_per_block);\n<line43>write_block (current_offset, n_bytes_read,\n<line44>block[!idx], block[idx]);\n<line45>if (ferror (stdout))\n<line46>ok = false;\n<line47>current_offset += n_bytes_read;\n<line48>idx = !idx;\n<line49>}\n<line50>}\n<line51>if (n_bytes_read > 0)\n<line52>{\n<line53>int l_c_m;\n<line54>size_t bytes_to_write;\n<line55>l_c_m = get_lcm ();\n<line56>/* Ensure zero-byte padding up to the smallest multiple of l_c_m that\n<line57>is at least as large as n_bytes_read.  */\n<line58>bytes_to_write = l_c_m * ((n_bytes_read + l_c_m - 1) / l_c_m);\n<line59>memset (block[idx] + n_bytes_read, 0, bytes_to_write - n_bytes_read);\n<line60>write_block (current_offset, n_bytes_read, block[!idx], block[idx]);\n<line61>current_offset += n_bytes_read;\n<line62>}\n<line63>format_address (current_offset, '\n');\n<line64>if (limit_bytes_to_format && current_offset >= end_offset)\n<line65>ok &= check_and_close (0);\n<line66>free (block[0]);\n<line67>return ok;\n<line68>}
----------------------------------------
Function: dump_strings
Content: <line0>static bool\n<line1>dump_strings (void)\n<line2>{\n<line3>size_t bufsize = MAX (100, string_min);\n<line4>char *buf = xmalloc (bufsize);\n<line5>uintmax_t address = n_bytes_to_skip;\n<line6>bool ok = true;\n<line7>while (true)\n<line8>{\n<line9>size_t i;\n<line10>int c;\n<line11>/* See if the next 'string_min' chars are all printing chars.  */\n<line12>tryline:\n<line13>if (limit_bytes_to_format\n<line14>&& (end_offset < string_min || end_offset - string_min <= address))\n<line15>break;\n<line16>for (i = 0; i < string_min; i++)\n<line17>{\n<line18>ok &= read_char (&c);\n<line19>address++;\n<line20>if (c < 0)\n<line21>{\n<line22>free (buf);\n<line23>return ok;\n<line24>}\n<line25>if (! isprint (c))\n<line26>/* Found a non-printing.  Try again starting with next char.  */\n<line27>goto tryline;\n<line28>buf[i] = c;\n<line29>}\n<line30>/* We found a run of 'string_min' printable characters.\n<line31>Now see if it is terminated with a null byte.  */\n<line32>while (!limit_bytes_to_format || address < end_offset)\n<line33>{\n<line34>if (i == bufsize)\n<line35>{\n<line36>buf = X2REALLOC (buf, &bufsize);\n<line37>}\n<line38>ok &= read_char (&c);\n<line39>address++;\n<line40>if (c < 0)\n<line41>{\n<line42>free (buf);\n<line43>return ok;\n<line44>}\n<line45>if (c == '\0')\n<line46>break;		/* It is; print this string.  */\n<line47>if (! isprint (c))\n<line48>goto tryline;	/* It isn't; give up on this string.  */\n<line49>buf[i++] = c;		/* String continues; store it all.  */\n<line50>}\n<line51>/* If we get here, the string is all printable and null-terminated,\n<line52>so print it.  It is all in 'buf' and 'i' is its length.  */\n<line53>buf[i] = 0;\n<line54>format_address (address - i - 1, ' ');\n<line55>for (i = 0; (c = buf[i]); i++)\n<line56>{\n<line57>switch (c)\n<line58>{\n<line59>case '\a':\n<line60>fputs ("\\a", stdout);\n<line61>break;\n<line62>case '\b':\n<line63>fputs ("\\b", stdout);\n<line64>break;\n<line65>case '\f':\n<line66>fputs ("\\f", stdout);\n<line67>break;\n<line68>case '\n':\n<line69>fputs ("\\n", stdout);\n<line70>break;\n<line71>case '\r':\n<line72>fputs ("\\r", stdout);\n<line73>break;\n<line74>case '\t':\n<line75>fputs ("\\t", stdout);\n<line76>break;\n<line77>case '\v':\n<line78>fputs ("\\v", stdout);\n<line79>break;\n<line80>default:\n<line81>putc (c, stdout);\n<line82>}\n<line83>}\n<line84>putchar ('\n');\n<line85>}\n<line86>/* We reach this point only if we search through\n<line87>(max_bytes_to_format - string_min) bytes before reaching EOF.  */\n<line88>free (buf);\n<line89>ok &= check_and_close (0);\n<line90>return ok;\n<line91>}
----------------------------------------
Function: main
Content: <line0>int\n<line1>main (int argc, char **argv)\n<line2>{\n<line3>int n_files;\n<line4>size_t i;\n<line5>int l_c_m;\n<line6>idx_t desired_width IF_LINT ( = 0);\n<line7>bool modern = false;\n<line8>bool width_specified = false;\n<line9>bool ok = true;\n<line10>size_t width_per_block = 0;\n<line11>static char const multipliers[] = "bEGKkMmPQRTYZ0";\n<line12>/* The old-style 'pseudo starting address' to be printed in parentheses\n<line13>after any true address.  */\n<line14>uintmax_t pseudo_start IF_LINT ( = 0);\n<line15>initialize_main (&argc, &argv);\n<line16>set_program_name (argv[0]);\n<line17>setlocale (LC_ALL, "");\n<line18>bindtextdomain (PACKAGE, LOCALEDIR);\n<line19>textdomain (PACKAGE);\n<line20>atexit (close_stdout);\n<line21>for (i = 0; i <= MAX_INTEGRAL_TYPE_SIZE; i++)\n<line22>integral_type_size[i] = NO_SIZE;\n<line23>integral_type_size[sizeof (char)] = CHAR;\n<line24>integral_type_size[sizeof (short int)] = SHORT;\n<line25>integral_type_size[sizeof (int)] = INT;\n<line26>integral_type_size[sizeof (long int)] = LONG;\n<line27>#if HAVE_UNSIGNED_LONG_LONG_INT\n<line28>/* If 'long int' and 'long long int' have the same size, it's fine\n<line29>to overwrite the entry for 'long' with this one.  */\n<line30>integral_type_size[sizeof (unsigned_long_long_int)] = LONG_LONG;\n<line31>#endif\n<line32>for (i = 0; i <= MAX_FP_TYPE_SIZE; i++)\n<line33>fp_type_size[i] = NO_SIZE;\n<line34>fp_type_size[sizeof (float)] = FLOAT_SINGLE;\n<line35>/* The array entry for 'double' is filled in after that for 'long double'\n<line36>so that if they are the same size, we avoid any overhead of\n<line37>long double computation in libc.  */\n<line38>fp_type_size[sizeof (long double)] = FLOAT_LONG_DOUBLE;\n<line39>fp_type_size[sizeof (double)] = FLOAT_DOUBLE;\n<line40>n_specs = 0;\n<line41>n_specs_allocated = 0;\n<line42>spec = nullptr;\n<line43>format_address = format_address_std;\n<line44>address_base = 8;\n<line45>address_pad_len = 7;\n<line46>flag_dump_strings = false;\n<line47>while (true)\n<line48>{\n<line49>uintmax_t tmp;\n<line50>enum strtol_error s_err;\n<line51>int oi = -1;\n<line52>int c = getopt_long (argc, argv, short_options, long_options, &oi);\n<line53>if (c == -1)\n<line54>break;\n<line55>switch (c)\n<line56>{\n<line57>case 'A':\n<line58>modern = true;\n<line59>switch (optarg[0])\n<line60>{\n<line61>case 'd':\n<line62>format_address = format_address_std;\n<line63>address_base = 10;\n<line64>address_pad_len = 7;\n<line65>break;\n<line66>case 'o':\n<line67>format_address = format_address_std;\n<line68>address_base = 8;\n<line69>address_pad_len = 7;\n<line70>break;\n<line71>case 'x':\n<line72>format_address = format_address_std;\n<line73>address_base = 16;\n<line74>address_pad_len = 6;\n<line75>break;\n<line76>case 'n':\n<line77>format_address = format_address_none;\n<line78>address_pad_len = 0;\n<line79>break;\n<line80>default:\n<line81>error (EXIT_FAILURE, 0,\n<line82>_("invalid output address radix '%c';"\n<line83>" it must be one character from [doxn]"),\n<line84>optarg[0]);\n<line85>break;\n<line86>}\n<line87>break;\n<line88>case 'j':\n<line89>modern = true;\n<line90>s_err = xstrtoumax (optarg, nullptr, 0,\n<line91>&n_bytes_to_skip, multipliers);\n<line92>if (s_err != LONGINT_OK)\n<line93>xstrtol_fatal (s_err, oi, c, long_options, optarg);\n<line94>break;\n<line95>case 'N':\n<line96>modern = true;\n<line97>limit_bytes_to_format = true;\n<line98>s_err = xstrtoumax (optarg, nullptr, 0, &max_bytes_to_format,\n<line99>multipliers);\n<line100>if (s_err != LONGINT_OK)\n<line101>xstrtol_fatal (s_err, oi, c, long_options, optarg);\n<line102>break;\n<line103>case 'S':\n<line104>modern = true;\n<line105>if (optarg == nullptr)\n<line106>string_min = 3;\n<line107>else\n<line108>{\n<line109>s_err = xstrtoumax (optarg, nullptr, 0, &tmp, multipliers);\n<line110>if (s_err != LONGINT_OK)\n<line111>xstrtol_fatal (s_err, oi, c, long_options, optarg);\n<line112>/* The minimum string length may be no larger than SIZE_MAX,\n<line113>since we may allocate a buffer of this size.  */\n<line114>if (SIZE_MAX < tmp)\n<line115>error (EXIT_FAILURE, 0, _("%s is too large"), quote (optarg));\n<line116>string_min = tmp;\n<line117>}\n<line118>flag_dump_strings = true;\n<line119>break;\n<line120>case 't':\n<line121>modern = true;\n<line122>ok &= decode_format_string (optarg);\n<line123>break;\n<line124>case 'v':\n<line125>modern = true;\n<line126>abbreviate_duplicate_blocks = false;\n<line127>break;\n<line128>case TRADITIONAL_OPTION:\n<line129>traditional = true;\n<line130>break;\n<line131>case ENDIAN_OPTION:\n<line132>switch (XARGMATCH ("--endian", optarg, endian_args, endian_types))\n<line133>{\n<line134>case endian_big:\n<line135>input_swap = ! WORDS_BIGENDIAN;\n<line136>break;\n<line137>case endian_little:\n<line138>input_swap = WORDS_BIGENDIAN;\n<line139>break;\n<line140>}\n<line141>break;\n<line142>/* The next several cases map the traditional format\n<line143>specification options to the corresponding modern format\n<line144>specs.  GNU od accepts any combination of old- and\n<line145>new-style options.  Format specification options accumulate.\n<line146>The obsolescent and undocumented formats are compatible\n<line147>with FreeBSD 4.10 od.  */\n<line148>#define CASE_OLD_ARG(old_char,new_string)		\\n<line149>case old_char:					\\n<line150>ok &= decode_format_string (new_string);	\\n<line151>break\n<line152>CASE_OLD_ARG ('a', "a");\n<line153>CASE_OLD_ARG ('b', "o1");\n<line154>CASE_OLD_ARG ('c', "c");\n<line155>CASE_OLD_ARG ('D', "u4"); /* obsolescent and undocumented */\n<line156>CASE_OLD_ARG ('d', "u2");\n<line157>case 'F': /* obsolescent and undocumented alias */\n<line158>CASE_OLD_ARG ('e', "fD"); /* obsolescent and undocumented */\n<line159>CASE_OLD_ARG ('f', "fF");\n<line160>case 'X': /* obsolescent and undocumented alias */\n<line161>CASE_OLD_ARG ('H', "x4"); /* obsolescent and undocumented */\n<line162>CASE_OLD_ARG ('i', "dI");\n<line163>case 'I': case 'L': /* obsolescent and undocumented aliases */\n<line164>CASE_OLD_ARG ('l', "dL");\n<line165>CASE_OLD_ARG ('O', "o4"); /* obsolescent and undocumented */\n<line166>case 'B': /* obsolescent and undocumented alias */\n<line167>CASE_OLD_ARG ('o', "o2");\n<line168>CASE_OLD_ARG ('s', "d2");\n<line169>case 'h': /* obsolescent and undocumented alias */\n<line170>CASE_OLD_ARG ('x', "x2");\n<line171>#undef CASE_OLD_ARG\n<line172>case 'w':\n<line173>modern = true;\n<line174>width_specified = true;\n<line175>if (optarg == nullptr)\n<line176>{\n<line177>desired_width = 32;\n<line178>}\n<line179>else\n<line180>{\n<line181>intmax_t w_tmp;\n<line182>s_err = xstrtoimax (optarg, nullptr, 10, &w_tmp, "");\n<line183>if (s_err != LONGINT_OK || w_tmp <= 0)\n<line184>xstrtol_fatal (s_err, oi, c, long_options, optarg);\n<line185>if (ckd_add (&desired_width, w_tmp, 0))\n<line186>error (EXIT_FAILURE, 0, _("%s is too large"), quote (optarg));\n<line187>}\n<line188>break;\n<line189>case_GETOPT_HELP_CHAR;\n<line190>case_GETOPT_VERSION_CHAR (PROGRAM_NAME, AUTHORS);\n<line191>default:\n<line192>usage (EXIT_FAILURE);\n<line193>break;\n<line194>}\n<line195>}\n<line196>if (!ok)\n<line197>return EXIT_FAILURE;\n<line198>if (flag_dump_strings && n_specs > 0)\n<line199>error (EXIT_FAILURE, 0,\n<line200>_("no type may be specified when dumping strings"));\n<line201>n_files = argc - optind;\n<line202>/* If the --traditional option is used, there may be from\n<line203>0 to 3 remaining command line arguments;  handle each case\n<line204>separately.\n<line205>od [file] [[+]offset[.][b] [[+]label[.][b]]]\n<line206>The offset and label have the same syntax.\n<line207>If --traditional is not given, and if no modern options are\n<line208>given, and if the offset begins with + or (if there are two\n<line209>operands) a digit, accept only this form, as per POSIX:\n<line210>od [file] [[+]offset[.][b]]\n<line211>*/\n<line212>if (!modern || traditional)\n<line213>{\n<line214>uintmax_t o1;\n<line215>uintmax_t o2;\n<line216>switch (n_files)\n<line217>{\n<line218>case 1:\n<line219>if ((traditional || argv[optind][0] == '+')\n<line220>&& parse_old_offset (argv[optind], &o1))\n<line221>{\n<line222>n_bytes_to_skip = o1;\n<line223>--n_files;\n<line224>++argv;\n<line225>}\n<line226>break;\n<line227>case 2:\n<line228>if ((traditional || argv[optind + 1][0] == '+'\n<line229>|| ISDIGIT (argv[optind + 1][0]))\n<line230>&& parse_old_offset (argv[optind + 1], &o2))\n<line231>{\n<line232>if (traditional && parse_old_offset (argv[optind], &o1))\n<line233>{\n<line234>n_bytes_to_skip = o1;\n<line235>flag_pseudo_start = true;\n<line236>pseudo_start = o2;\n<line237>argv += 2;\n<line238>n_files -= 2;\n<line239>}\n<line240>else\n<line241>{\n<line242>n_bytes_to_skip = o2;\n<line243>--n_files;\n<line244>argv[optind + 1] = argv[optind];\n<line245>++argv;\n<line246>}\n<line247>}\n<line248>break;\n<line249>case 3:\n<line250>if (traditional\n<line251>&& parse_old_offset (argv[optind + 1], &o1)\n<line252>&& parse_old_offset (argv[optind + 2], &o2))\n<line253>{\n<line254>n_bytes_to_skip = o1;\n<line255>flag_pseudo_start = true;\n<line256>pseudo_start = o2;\n<line257>argv[optind + 2] = argv[optind];\n<line258>argv += 2;\n<line259>n_files -= 2;\n<line260>}\n<line261>break;\n<line262>}\n<line263>if (traditional && 1 < n_files)\n<line264>{\n<line265>error (0, 0, _("extra operand %s"), quote (argv[optind + 1]));\n<line266>error (0, 0, "%s",\n<line267>_("compatibility mode supports at most one file"));\n<line268>usage (EXIT_FAILURE);\n<line269>}\n<line270>}\n<line271>if (flag_pseudo_start)\n<line272>{\n<line273>if (format_address == format_address_none)\n<line274>{\n<line275>address_base = 8;\n<line276>address_pad_len = 7;\n<line277>format_address = format_address_paren;\n<line278>}\n<line279>else\n<line280>format_address = format_address_label;\n<line281>}\n<line282>if (limit_bytes_to_format)\n<line283>{\n<line284>end_offset = n_bytes_to_skip + max_bytes_to_format;\n<line285>if (end_offset < n_bytes_to_skip)\n<line286>error (EXIT_FAILURE, 0, _("skip-bytes + read-bytes is too large"));\n<line287>}\n<line288>if (n_specs == 0)\n<line289>decode_format_string ("oS");\n<line290>if (n_files > 0)\n<line291>{\n<line292>/* Set the global pointer FILE_LIST so that it\n<line293>references the first file-argument on the command-line.  */\n<line294>file_list = (char const *const *) &argv[optind];\n<line295>}\n<line296>else\n<line297>{\n<line298>/* No files were listed on the command line.\n<line299>Set the global pointer FILE_LIST so that it\n<line300>references the null-terminated list of one name: "-".  */\n<line301>file_list = default_file_list;\n<line302>}\n<line303>/* open the first input file */\n<line304>ok = open_next_file ();\n<line305>if (in_stream == nullptr)\n<line306>goto cleanup;\n<line307>/* skip over any unwanted header bytes */\n<line308>ok &= skip (n_bytes_to_skip);\n<line309>if (in_stream == nullptr)\n<line310>goto cleanup;\n<line311>pseudo_offset = (flag_pseudo_start ? pseudo_start - n_bytes_to_skip : 0);\n<line312>/* Compute output block length.  */\n<line313>l_c_m = get_lcm ();\n<line314>if (width_specified)\n<line315>{\n<line316>if (desired_width != 0 && desired_width % l_c_m == 0)\n<line317>bytes_per_block = desired_width;\n<line318>else\n<line319>{\n<line320>error (0, 0, _("warning: invalid width %td; using %d instead"),\n<line321>desired_width, l_c_m);\n<line322>bytes_per_block = l_c_m;\n<line323>}\n<line324>}\n<line325>else\n<line326>{\n<line327>if (l_c_m < DEFAULT_BYTES_PER_BLOCK)\n<line328>bytes_per_block = l_c_m * (DEFAULT_BYTES_PER_BLOCK / l_c_m);\n<line329>else\n<line330>bytes_per_block = l_c_m;\n<line331>}\n<line332>/* Compute padding necessary to align output block.  */\n<line333>for (i = 0; i < n_specs; i++)\n<line334>{\n<line335>int fields_per_block = bytes_per_block / width_bytes[spec[i].size];\n<line336>int block_width = (spec[i].field_width + 1) * fields_per_block;\n<line337>if (width_per_block < block_width)\n<line338>width_per_block = block_width;\n<line339>}\n<line340>for (i = 0; i < n_specs; i++)\n<line341>{\n<line342>int fields_per_block = bytes_per_block / width_bytes[spec[i].size];\n<line343>int block_width = spec[i].field_width * fields_per_block;\n<line344>spec[i].pad_width = width_per_block - block_width;\n<line345>}\n<line346>#ifdef DEBUG\n<line347>printf ("lcm=%d, width_per_block=%"PRIuMAX"\n", l_c_m,\n<line348>(uintmax_t) width_per_block);\n<line349>for (i = 0; i < n_specs; i++)\n<line350>{\n<line351>int fields_per_block = bytes_per_block / width_bytes[spec[i].size];\n<line352>affirm (bytes_per_block % width_bytes[spec[i].size] == 0);\n<line353>affirm (1 <= spec[i].pad_width / fields_per_block);\n<line354>printf ("%d: fmt=\"%s\" in_width=%d out_width=%d pad=%d\n",\n<line355>i, spec[i].fmt_string, width_bytes[spec[i].size],\n<line356>spec[i].field_width, spec[i].pad_width);\n<line357>}\n<line358>#endif\n<line359>ok &= (flag_dump_strings ? dump_strings () : dump ());\n<line360>cleanup:\n<line361>if (have_read_stdin && fclose (stdin) == EOF)\n<line362>error (EXIT_FAILURE, errno, _("standard input"));\n<line363>return ok ? EXIT_SUCCESS : EXIT_FAILURE;\n<line364>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/src/paste.c
========================================
Function: collapse_escapes
Content: <line0>static int\n<line1>collapse_escapes (char const *strptr)\n<line2>{\n<line3>char *strout = xstrdup (strptr);\n<line4>bool backslash_at_end = false;\n<line5>delims = strout;\n<line6>while (*strptr)\n<line7>{\n<line8>if (*strptr != '\\')	/* Is it an escape character? */\n<line9>*strout++ = *strptr++;	/* No, just transfer it. */\n<line10>else\n<line11>{\n<line12>switch (*++strptr)\n<line13>{\n<line14>case '0':\n<line15>*strout++ = EMPTY_DELIM;\n<line16>break;\n<line17>case 'b':\n<line18>*strout++ = '\b';\n<line19>break;\n<line20>case 'f':\n<line21>*strout++ = '\f';\n<line22>break;\n<line23>case 'n':\n<line24>*strout++ = '\n';\n<line25>break;\n<line26>case 'r':\n<line27>*strout++ = '\r';\n<line28>break;\n<line29>case 't':\n<line30>*strout++ = '\t';\n<line31>break;\n<line32>case 'v':\n<line33>*strout++ = '\v';\n<line34>break;\n<line35>case '\\':\n<line36>*strout++ = '\\';\n<line37>break;\n<line38>case '\0':\n<line39>backslash_at_end = true;\n<line40>goto done;\n<line41>default:\n<line42>*strout++ = *strptr;\n<line43>break;\n<line44>}\n<line45>strptr++;\n<line46>}\n<line47>}\n<line48>done:\n<line49>delim_end = strout;\n<line50>return backslash_at_end ? 1 : 0;\n<line51>}
----------------------------------------
Function: xputchar
Content: <line0>static inline void\n<line1>xputchar (char c)\n<line2>{\n<line3>if (putchar (c) < 0)\n<line4>write_error ();\n<line5>}
----------------------------------------
Function: paste_parallel
Content: <line0>static bool\n<line1>paste_parallel (size_t nfiles, char **fnamptr)\n<line2>{\n<line3>bool ok = true;\n<line4>/* If all files are just ready to be closed, or will be on this\n<line5>round, the string of delimiters must be preserved.\n<line6>delbuf[0] through delbuf[nfiles]\n<line7>store the delimiters for closed files. */\n<line8>char *delbuf = xmalloc (nfiles + 2);\n<line9>/* Streams open to the files to process; null if the corresponding\n<line10>stream is closed.  */\n<line11>FILE **fileptr = xnmalloc (nfiles + 1, sizeof *fileptr);\n<line12>/* Number of files still open to process.  */\n<line13>size_t files_open;\n<line14>/* True if any fopen got fd == STDIN_FILENO.  */\n<line15>bool opened_stdin = false;\n<line16>/* Attempt to open all files.  This could be expanded to an infinite\n<line17>number of files, but at the (considerable) expense of remembering\n<line18>each file and its current offset, then opening/reading/closing.  */\n<line19>for (files_open = 0; files_open < nfiles; ++files_open)\n<line20>{\n<line21>if (STREQ (fnamptr[files_open], "-"))\n<line22>{\n<line23>have_read_stdin = true;\n<line24>fileptr[files_open] = stdin;\n<line25>}\n<line26>else\n<line27>{\n<line28>fileptr[files_open] = fopen (fnamptr[files_open], "r");\n<line29>if (fileptr[files_open] == nullptr)\n<line30>error (EXIT_FAILURE, errno, "%s", quotef (fnamptr[files_open]));\n<line31>else if (fileno (fileptr[files_open]) == STDIN_FILENO)\n<line32>opened_stdin = true;\n<line33>fadvise (fileptr[files_open], FADVISE_SEQUENTIAL);\n<line34>}\n<line35>}\n<line36>if (opened_stdin && have_read_stdin)\n<line37>error (EXIT_FAILURE, 0, _("standard input is closed"));\n<line38>/* Read a line from each file and output it to stdout separated by a\n<line39>delimiter, until we go through the loop without successfully\n<line40>reading from any of the files. */\n<line41>while (files_open)\n<line42>{\n<line43>/* Set up for the next line. */\n<line44>bool somedone = false;\n<line45>char const *delimptr = delims;\n<line46>size_t delims_saved = 0;	/* Number of delims saved in 'delbuf'. */\n<line47>for (size_t i = 0; i < nfiles && files_open; i++)\n<line48>{\n<line49>int chr;			/* Input character. */\n<line50>int err;			/* Input errno value.  */\n<line51>bool sometodo = false;	/* Input chars to process.  */\n<line52>if (fileptr[i])\n<line53>{\n<line54>chr = getc (fileptr[i]);\n<line55>err = errno;\n<line56>if (chr != EOF && delims_saved)\n<line57>{\n<line58>if (fwrite (delbuf, 1, delims_saved, stdout) != delims_saved)\n<line59>write_error ();\n<line60>delims_saved = 0;\n<line61>}\n<line62>while (chr != EOF)\n<line63>{\n<line64>sometodo = true;\n<line65>if (chr == line_delim)\n<line66>break;\n<line67>xputchar (chr);\n<line68>chr = getc (fileptr[i]);\n<line69>err = errno;\n<line70>}\n<line71>}\n<line72>if (! sometodo)\n<line73>{\n<line74>/* EOF, read error, or closed file.\n<line75>If an EOF or error, close the file.  */\n<line76>if (fileptr[i])\n<line77>{\n<line78>if (!ferror (fileptr[i]))\n<line79>err = 0;\n<line80>if (fileptr[i] == stdin)\n<line81>clearerr (fileptr[i]); /* Also clear EOF. */\n<line82>else if (fclose (fileptr[i]) == EOF && !err)\n<line83>err = errno;\n<line84>if (err)\n<line85>{\n<line86>error (0, err, "%s", quotef (fnamptr[i]));\n<line87>ok = false;\n<line88>}\n<line89>fileptr[i] = nullptr;\n<line90>files_open--;\n<line91>}\n<line92>if (i + 1 == nfiles)\n<line93>{\n<line94>/* End of this output line.\n<line95>Is this the end of the whole thing? */\n<line96>if (somedone)\n<line97>{\n<line98>/* No.  Some files were not closed for this line. */\n<line99>if (delims_saved)\n<line100>{\n<line101>if (fwrite (delbuf, 1, delims_saved, stdout)\n<line102>!= delims_saved)\n<line103>write_error ();\n<line104>delims_saved = 0;\n<line105>}\n<line106>xputchar (line_delim);\n<line107>}\n<line108>continue;	/* Next read of files, or exit. */\n<line109>}\n<line110>else\n<line111>{\n<line112>/* Closed file; add delimiter to 'delbuf'. */\n<line113>if (*delimptr != EMPTY_DELIM)\n<line114>delbuf[delims_saved++] = *delimptr;\n<line115>if (++delimptr == delim_end)\n<line116>delimptr = delims;\n<line117>}\n<line118>}\n<line119>else\n<line120>{\n<line121>/* Some data read. */\n<line122>somedone = true;\n<line123>/* Except for last file, replace last newline with delim. */\n<line124>if (i + 1 != nfiles)\n<line125>{\n<line126>if (chr != line_delim && chr != EOF)\n<line127>xputchar (chr);\n<line128>if (*delimptr != EMPTY_DELIM)\n<line129>xputchar (*delimptr);\n<line130>if (++delimptr == delim_end)\n<line131>delimptr = delims;\n<line132>}\n<line133>else\n<line134>{\n<line135>/* If the last line of the last file lacks a newline,\n<line136>print one anyhow.  POSIX requires this.  */\n<line137>char c = (chr == EOF ? line_delim : chr);\n<line138>xputchar (c);\n<line139>}\n<line140>}\n<line141>}\n<line142>}\n<line143>free (fileptr);\n<line144>free (delbuf);\n<line145>return ok;\n<line146>}
----------------------------------------
Function: paste_serial
Content: <line0>static bool\n<line1>paste_serial (size_t nfiles, char **fnamptr)\n<line2>{\n<line3>bool ok = true;	/* false if open or read errors occur. */\n<line4>int charnew, charold; /* Current and previous char read. */\n<line5>char const *delimptr;	/* Current delimiter char. */\n<line6>FILE *fileptr;	/* Open for reading current file. */\n<line7>for (; nfiles; nfiles--, fnamptr++)\n<line8>{\n<line9>int saved_errno;\n<line10>bool is_stdin = STREQ (*fnamptr, "-");\n<line11>if (is_stdin)\n<line12>{\n<line13>have_read_stdin = true;\n<line14>fileptr = stdin;\n<line15>}\n<line16>else\n<line17>{\n<line18>fileptr = fopen (*fnamptr, "r");\n<line19>if (fileptr == nullptr)\n<line20>{\n<line21>error (0, errno, "%s", quotef (*fnamptr));\n<line22>ok = false;\n<line23>continue;\n<line24>}\n<line25>fadvise (fileptr, FADVISE_SEQUENTIAL);\n<line26>}\n<line27>delimptr = delims;	/* Set up for delimiter string. */\n<line28>charold = getc (fileptr);\n<line29>saved_errno = errno;\n<line30>if (charold != EOF)\n<line31>{\n<line32>/* 'charold' is set up.  Hit it!\n<line33>Keep reading characters, stashing them in 'charnew';\n<line34>output 'charold', converting to the appropriate delimiter\n<line35>character if needed.  After the EOF, output 'charold'\n<line36>if it's a newline; otherwise, output it and then a newline. */\n<line37>while ((charnew = getc (fileptr)) != EOF)\n<line38>{\n<line39>/* Process the old character. */\n<line40>if (charold == line_delim)\n<line41>{\n<line42>if (*delimptr != EMPTY_DELIM)\n<line43>xputchar (*delimptr);\n<line44>if (++delimptr == delim_end)\n<line45>delimptr = delims;\n<line46>}\n<line47>else\n<line48>xputchar (charold);\n<line49>charold = charnew;\n<line50>}\n<line51>saved_errno = errno;\n<line52>/* Hit EOF.  Process that last character. */\n<line53>xputchar (charold);\n<line54>}\n<line55>if (charold != line_delim)\n<line56>xputchar (line_delim);\n<line57>if (!ferror (fileptr))\n<line58>saved_errno = 0;\n<line59>if (is_stdin)\n<line60>clearerr (fileptr);	/* Also clear EOF. */\n<line61>else if (fclose (fileptr) != 0 && !saved_errno)\n<line62>saved_errno = errno;\n<line63>if (saved_errno)\n<line64>{\n<line65>error (0, saved_errno, "%s", quotef (*fnamptr));\n<line66>ok = false;\n<line67>}\n<line68>}\n<line69>return ok;\n<line70>}
----------------------------------------
Function: usage
Content: <line0>void\n<line1>usage (int status)\n<line2>{\n<line3>if (status != EXIT_SUCCESS)\n<line4>emit_try_help ();\n<line5>else\n<line6>{\n<line7>printf (_("\\n<line8>Usage: %s [OPTION]... [FILE]...\n\\n<line9>"),\n<line10>program_name);\n<line11>fputs (_("\\n<line12>Write lines consisting of the sequentially corresponding lines from\n\\n<line13>each FILE, separated by TABs, to standard output.\n\\n<line14>"), stdout);\n<line15>emit_stdin_note ();\n<line16>emit_mandatory_arg_note ();\n<line17>fputs (_("\\n<line18>-d, --delimiters=LIST   reuse characters from LIST instead of TABs\n\\n<line19>-s, --serial            paste one file at a time instead of in parallel\n\\n<line20>"), stdout);\n<line21>fputs (_("\\n<line22>-z, --zero-terminated    line delimiter is NUL, not newline\n\\n<line23>"), stdout);\n<line24>fputs (HELP_OPTION_DESCRIPTION, stdout);\n<line25>fputs (VERSION_OPTION_DESCRIPTION, stdout);\n<line26>/* FIXME: add a couple of examples.  */\n<line27>emit_ancillary_info (PROGRAM_NAME);\n<line28>}\n<line29>exit (status);\n<line30>}
----------------------------------------
Function: main
Content: <line0>int\n<line1>main (int argc, char **argv)\n<line2>{\n<line3>int optc;\n<line4>char const *delim_arg = "\t";\n<line5>initialize_main (&argc, &argv);\n<line6>set_program_name (argv[0]);\n<line7>setlocale (LC_ALL, "");\n<line8>bindtextdomain (PACKAGE, LOCALEDIR);\n<line9>textdomain (PACKAGE);\n<line10>atexit (close_stdout);\n<line11>have_read_stdin = false;\n<line12>serial_merge = false;\n<line13>while ((optc = getopt_long (argc, argv, "d:sz", longopts, nullptr)) != -1)\n<line14>{\n<line15>switch (optc)\n<line16>{\n<line17>case 'd':\n<line18>/* Delimiter character(s). */\n<line19>delim_arg = (optarg[0] == '\0' ? "\\0" : optarg);\n<line20>break;\n<line21>case 's':\n<line22>serial_merge = true;\n<line23>break;\n<line24>case 'z':\n<line25>line_delim = '\0';\n<line26>break;\n<line27>case_GETOPT_HELP_CHAR;\n<line28>case_GETOPT_VERSION_CHAR (PROGRAM_NAME, AUTHORS);\n<line29>default:\n<line30>usage (EXIT_FAILURE);\n<line31>}\n<line32>}\n<line33>int nfiles = argc - optind;\n<line34>if (nfiles == 0)\n<line35>{\n<line36>argv[optind] = bad_cast ("-");\n<line37>nfiles++;\n<line38>}\n<line39>if (collapse_escapes (delim_arg))\n<line40>{\n<line41>/* Don't use the quote() quoting style, because that would double the\n<line42>number of displayed backslashes, making the diagnostic look bogus.  */\n<line43>error (EXIT_FAILURE, 0,\n<line44>_("delimiter list ends with an unescaped backslash: %s"),\n<line45>quotearg_n_style_colon (0, c_maybe_quoting_style, delim_arg));\n<line46>}\n<line47>bool ok = ((serial_merge ? paste_serial : paste_parallel)\n<line48>(nfiles, &argv[optind]));\n<line49>free (delims);\n<line50>if (have_read_stdin && fclose (stdin) == EOF)\n<line51>error (EXIT_FAILURE, errno, "-");\n<line52>return ok ? EXIT_SUCCESS : EXIT_FAILURE;\n<line53>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/src/pathchk.c
========================================
Function: usage
Content: <line0>void\n<line1>usage (int status)\n<line2>{\n<line3>if (status != EXIT_SUCCESS)\n<line4>emit_try_help ();\n<line5>else\n<line6>{\n<line7>printf (_("Usage: %s [OPTION]... NAME...\n"), program_name);\n<line8>fputs (_("\\n<line9>Diagnose invalid or non-portable file names.\n\\n<line10>\n\\n<line11>-p                  check for most POSIX systems\n\\n<line12>-P                  check for empty names and leading \"-\"\n\\n<line13>--portability   check for all POSIX systems (equivalent to -p -P)\n\\n<line14>"), stdout);\n<line15>fputs (HELP_OPTION_DESCRIPTION, stdout);\n<line16>fputs (VERSION_OPTION_DESCRIPTION, stdout);\n<line17>emit_ancillary_info (PROGRAM_NAME);\n<line18>}\n<line19>exit (status);\n<line20>}
----------------------------------------
Function: main
Content: <line0>int\n<line1>main (int argc, char **argv)\n<line2>{\n<line3>bool ok = true;\n<line4>bool check_basic_portability = false;\n<line5>bool check_extra_portability = false;\n<line6>int optc;\n<line7>initialize_main (&argc, &argv);\n<line8>set_program_name (argv[0]);\n<line9>setlocale (LC_ALL, "");\n<line10>bindtextdomain (PACKAGE, LOCALEDIR);\n<line11>textdomain (PACKAGE);\n<line12>atexit (close_stdout);\n<line13>while ((optc = getopt_long (argc, argv, "+pP", longopts, nullptr)) != -1)\n<line14>{\n<line15>switch (optc)\n<line16>{\n<line17>case PORTABILITY_OPTION:\n<line18>check_basic_portability = true;\n<line19>check_extra_portability = true;\n<line20>break;\n<line21>case 'p':\n<line22>check_basic_portability = true;\n<line23>break;\n<line24>case 'P':\n<line25>check_extra_portability = true;\n<line26>break;\n<line27>case_GETOPT_HELP_CHAR;\n<line28>case_GETOPT_VERSION_CHAR (PROGRAM_NAME, AUTHORS);\n<line29>default:\n<line30>usage (EXIT_FAILURE);\n<line31>}\n<line32>}\n<line33>if (optind == argc)\n<line34>{\n<line35>error (0, 0, _("missing operand"));\n<line36>usage (EXIT_FAILURE);\n<line37>}\n<line38>for (; optind < argc; ++optind)\n<line39>ok &= validate_file_name (argv[optind],\n<line40>check_basic_portability, check_extra_portability);\n<line41>return ok ? EXIT_SUCCESS : EXIT_FAILURE;\n<line42>}
----------------------------------------
Function: no_leading_hyphen
Content: <line0>static bool\n<line1>no_leading_hyphen (char const *file)\n<line2>{\n<line3>char const *p;\n<line4>for (p = file;  (p = strchr (p, '-'));  p++)\n<line5>if (p == file || p[-1] == '/')\n<line6>{\n<line7>error (0, 0, _("leading '-' in a component of file name %s"),\n<line8>quoteaf (file));\n<line9>return false;\n<line10>}\n<line11>return true;\n<line12>}
----------------------------------------
Function: portable_chars_only
Content: <line0>static bool\n<line1>portable_chars_only (char const *file, size_t filelen)\n<line2>{\n<line3>size_t validlen = strspn (file,\n<line4>("/"\n<line5>"ABCDEFGHIJKLMNOPQRSTUVWXYZ"\n<line6>"abcdefghijklmnopqrstuvwxyz"\n<line7>"0123456789._-"));\n<line8>char const *invalid = file + validlen;\n<line9>if (*invalid)\n<line10>{\n<line11>mbstate_t mbstate = { 0, };\n<line12>size_t charlen = mbrlen (invalid, filelen - validlen, &mbstate);\n<line13>error (0, 0,\n<line14>_("non-portable character %s in file name %s"),\n<line15>quotearg_n_style_mem (1, locale_quoting_style, invalid,\n<line16>(charlen <= MB_LEN_MAX ? charlen : 1)),\n<line17>quoteaf_n (0, file));\n<line18>return false;\n<line19>}\n<line20>return true;\n<line21>}
----------------------------------------
Function: validate_file_name
Content: <line0>static bool\n<line1>validate_file_name (char *file, bool check_basic_portability,\n<line2>bool check_extra_portability)\n<line3>{\n<line4>idx_t filelen = strlen (file);\n<line5>/* Start of file name component being checked.  */\n<line6>char *start;\n<line7>/* True if component lengths need to be checked.  */\n<line8>bool check_component_lengths;\n<line9>/* True if the file is known to exist.  */\n<line10>bool file_exists = false;\n<line11>if (check_extra_portability && ! no_leading_hyphen (file))\n<line12>return false;\n<line13>if ((check_basic_portability || check_extra_portability)\n<line14>&& filelen == 0)\n<line15>{\n<line16>/* Fail, since empty names are not portable.  As of\n<line17>2005-01-06 POSIX does not address whether "pathchk -p ''"\n<line18>should (or is allowed to) fail, so this is not a\n<line19>conformance violation.  */\n<line20>error (0, 0, _("empty file name"));\n<line21>return false;\n<line22>}\n<line23>if (check_basic_portability)\n<line24>{\n<line25>if (! portable_chars_only (file, filelen))\n<line26>return false;\n<line27>}\n<line28>else\n<line29>{\n<line30>/* Check whether a file name component is in a directory that\n<line31>is not searchable, or has some other serious problem.\n<line32>POSIX does not allow "" as a file name, but some non-POSIX\n<line33>hosts do (as an alias for "."), so allow "" if lstat does.  */\n<line34>struct stat st;\n<line35>if (lstat (file, &st) == 0)\n<line36>file_exists = true;\n<line37>else if (errno != ENOENT || filelen == 0)\n<line38>{\n<line39>error (0, errno, "%s", quotef (file));\n<line40>return false;\n<line41>}\n<line42>}\n<line43>if (check_basic_portability\n<line44>|| (! file_exists && PATH_MAX_MINIMUM <= filelen))\n<line45>{\n<line46>idx_t maxsize;\n<line47>if (check_basic_portability)\n<line48>maxsize = _POSIX_PATH_MAX;\n<line49>else\n<line50>{\n<line51>long int size;\n<line52>char const *dir = (*file == '/' ? "/" : ".");\n<line53>errno = 0;\n<line54>size = pathconf (dir, _PC_PATH_MAX);\n<line55>if (size < 0 && errno != 0)\n<line56>{\n<line57>error (0, errno,\n<line58>_("%s: unable to determine maximum file name length"),\n<line59>dir);\n<line60>return false;\n<line61>}\n<line62>maxsize = MIN (size, MIN (SSIZE_MAX, IDX_MAX));\n<line63>}\n<line64>if (maxsize <= filelen)\n<line65>{\n<line66>error (0, 0, _("limit %td exceeded by length %td of file name %s"),\n<line67>maxsize - 1, filelen, quoteaf (file));\n<line68>return false;\n<line69>}\n<line70>}\n<line71>/* Check whether pathconf (..., _PC_NAME_MAX) can be avoided, i.e.,\n<line72>whether all file name components are so short that they are valid\n<line73>in any file system on this platform.  If CHECK_BASIC_PORTABILITY, though,\n<line74>it's more convenient to check component lengths below.  */\n<line75>check_component_lengths = check_basic_portability;\n<line76>if (! check_component_lengths && ! file_exists)\n<line77>{\n<line78>for (start = file; *(start = component_start (start)); )\n<line79>{\n<line80>size_t length = component_len (start);\n<line81>if (NAME_MAX_MINIMUM < length)\n<line82>{\n<line83>check_component_lengths = true;\n<line84>break;\n<line85>}\n<line86>start += length;\n<line87>}\n<line88>}\n<line89>if (check_component_lengths)\n<line90>{\n<line91>/* The limit on file name components for the current component.\n<line92>This defaults to NAME_MAX_MINIMUM, for the sake of non-POSIX\n<line93>systems (NFS, say?) where pathconf fails on "." or "/" with\n<line94>errno == ENOENT.  */\n<line95>idx_t name_max = NAME_MAX_MINIMUM;\n<line96>/* If nonzero, the known limit on file name components.  */\n<line97>idx_t known_name_max = check_basic_portability ? _POSIX_NAME_MAX : 0;\n<line98>for (start = file; *(start = component_start (start)); )\n<line99>{\n<line100>idx_t length;\n<line101>if (known_name_max)\n<line102>name_max = known_name_max;\n<line103>else\n<line104>{\n<line105>long int len;\n<line106>char const *dir = (start == file ? "." : file);\n<line107>char c = *start;\n<line108>errno = 0;\n<line109>*start = '\0';\n<line110>len = pathconf (dir, _PC_NAME_MAX);\n<line111>*start = c;\n<line112>if (0 <= len)\n<line113>name_max = MIN (len, MIN (SSIZE_MAX, IDX_MAX));\n<line114>else\n<line115>switch (errno)\n<line116>{\n<line117>case 0:\n<line118>/* There is no limit.  */\n<line119>name_max = IDX_MAX;\n<line120>break;\n<line121>case ENOENT:\n<line122>/* DIR does not exist; use its parent's maximum.  */\n<line123>known_name_max = name_max;\n<line124>break;\n<line125>default:\n<line126>*start = '\0';\n<line127>error (0, errno, "%s", quotef (dir));\n<line128>*start = c;\n<line129>return false;\n<line130>}\n<line131>}\n<line132>length = component_len (start);\n<line133>if (name_max < length)\n<line134>{\n<line135>char c = start[length];\n<line136>start[length] = '\0';\n<line137>error (0, 0,\n<line138>_("limit %td exceeded by length %td "\n<line139>"of file name component %s"),\n<line140>name_max, length, quote (start));\n<line141>start[length] = c;\n<line142>return false;\n<line143>}\n<line144>start += length;\n<line145>}\n<line146>}\n<line147>return true;\n<line148>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/src/pr.c
========================================
Function: integer_overflow
Content: <line0>static _Noreturn void\n<line1>integer_overflow (void)\n<line2>{\n<line3>error (EXIT_FAILURE, 0, _("integer overflow"));\n<line4>}
----------------------------------------
Function: first_last_page
Content: <line0>static bool\n<line1>first_last_page (int oi, char c, char const *pages)\n<line2>{\n<line3>char *p;\n<line4>uintmax_t first;\n<line5>uintmax_t last = UINTMAX_MAX;\n<line6>strtol_error err = xstrtoumax (pages, &p, 10, &first, "");\n<line7>if (err != LONGINT_OK && err != LONGINT_INVALID_SUFFIX_CHAR)\n<line8>xstrtol_fatal (err, oi, c, long_options, pages);\n<line9>if (p == pages || !first)\n<line10>return false;\n<line11>if (*p == ':')\n<line12>{\n<line13>char const *p1 = p + 1;\n<line14>err = xstrtoumax (p1, &p, 10, &last, "");\n<line15>if (err != LONGINT_OK)\n<line16>xstrtol_fatal (err, oi, c, long_options, pages);\n<line17>if (p1 == p || last < first)\n<line18>return false;\n<line19>}\n<line20>if (*p)\n<line21>return false;\n<line22>first_page_number = first;\n<line23>last_page_number = last;\n<line24>return true;\n<line25>}
----------------------------------------
Function: parse_column_count
Content: <line0>static void\n<line1>parse_column_count (char const *s)\n<line2>{\n<line3>getoptnum (s, 1, &columns, _("invalid number of columns"));\n<line4>explicit_columns = true;\n<line5>}
----------------------------------------
Function: separator_string
Content: <line0>static void\n<line1>separator_string (char const *optarg_S)\n<line2>{\n<line3>size_t len = strlen (optarg_S);\n<line4>if (INT_MAX < len)\n<line5>integer_overflow ();\n<line6>col_sep_length = len;\n<line7>col_sep_string = optarg_S;\n<line8>}
----------------------------------------
Function: main
Content: <line0>int\n<line1>main (int argc, char **argv)\n<line2>{\n<line3>unsigned int n_files;\n<line4>bool old_options = false;\n<line5>bool old_w = false;\n<line6>bool old_s = false;\n<line7>char **file_names;\n<line8>/* Accumulate the digits of old-style options like -99.  */\n<line9>char *column_count_string = nullptr;\n<line10>size_t n_digits = 0;\n<line11>size_t n_alloc = 0;\n<line12>initialize_main (&argc, &argv);\n<line13>set_program_name (argv[0]);\n<line14>setlocale (LC_ALL, "");\n<line15>bindtextdomain (PACKAGE, LOCALEDIR);\n<line16>textdomain (PACKAGE);\n<line17>atexit (close_stdout);\n<line18>n_files = 0;\n<line19>file_names = (argc > 1\n<line20>? xnmalloc (argc - 1, sizeof (char *))\n<line21>: nullptr);\n<line22>while (true)\n<line23>{\n<line24>int oi = -1;\n<line25>int c = getopt_long (argc, argv, short_options, long_options, &oi);\n<line26>if (c == -1)\n<line27>break;\n<line28>if (ISDIGIT (c))\n<line29>{\n<line30>/* Accumulate column-count digits specified via old-style options. */\n<line31>if (n_digits + 1 >= n_alloc)\n<line32>column_count_string\n<line33>= X2REALLOC (column_count_string, &n_alloc);\n<line34>column_count_string[n_digits++] = c;\n<line35>column_count_string[n_digits] = '\0';\n<line36>continue;\n<line37>}\n<line38>n_digits = 0;\n<line39>switch (c)\n<line40>{\n<line41>case 1:			/* Non-option argument. */\n<line42>/* long option --page dominates old '+FIRST_PAGE ...'.  */\n<line43>if (! (first_page_number == 0\n<line44>&& *optarg == '+' && first_last_page (-2, '+', optarg + 1)))\n<line45>file_names[n_files++] = optarg;\n<line46>break;\n<line47>case PAGES_OPTION:	/* --pages=FIRST_PAGE[:LAST_PAGE] */\n<line48>{			/* dominates old opt +... */\n<line49>if (! optarg)\n<line50>error (EXIT_FAILURE, 0,\n<line51>_("'--pages=FIRST_PAGE[:LAST_PAGE]' missing argument"));\n<line52>else if (! first_last_page (oi, 0, optarg))\n<line53>error (EXIT_FAILURE, 0, _("invalid page range %s"),\n<line54>quote (optarg));\n<line55>break;\n<line56>}\n<line57>case COLUMNS_OPTION:	/* --columns=COLUMN */\n<line58>{\n<line59>parse_column_count (optarg);\n<line60>/* If there was a prior column count specified via the\n<line61>short-named option syntax, e.g., -9, ensure that this\n<line62>long-name-specified value overrides it.  */\n<line63>free (column_count_string);\n<line64>column_count_string = nullptr;\n<line65>n_alloc = 0;\n<line66>break;\n<line67>}\n<line68>case 'a':\n<line69>print_across_flag = true;\n<line70>storing_columns = false;\n<line71>break;\n<line72>case 'b':\n<line73>balance_columns = true;\n<line74>break;\n<line75>case 'c':\n<line76>use_cntrl_prefix = true;\n<line77>break;\n<line78>case 'd':\n<line79>double_space = true;\n<line80>break;\n<line81>case 'D':\n<line82>date_format = optarg;\n<line83>break;\n<line84>case 'e':\n<line85>if (optarg)\n<line86>getoptarg (optarg, 'e', &input_tab_char,\n<line87>&chars_per_input_tab);\n<line88>/* Could check tab width > 0. */\n<line89>untabify_input = true;\n<line90>break;\n<line91>case 'f':\n<line92>case 'F':\n<line93>use_form_feed = true;\n<line94>break;\n<line95>case 'h':\n<line96>custom_header = optarg;\n<line97>break;\n<line98>case 'i':\n<line99>if (optarg)\n<line100>getoptarg (optarg, 'i', &output_tab_char,\n<line101>&chars_per_output_tab);\n<line102>/* Could check tab width > 0. */\n<line103>tabify_output = true;\n<line104>break;\n<line105>case 'J':\n<line106>join_lines = true;\n<line107>break;\n<line108>case 'l':\n<line109>getoptnum (optarg, 1, &lines_per_page,\n<line110>_("'-l PAGE_LENGTH' invalid number of lines"));\n<line111>break;\n<line112>case 'm':\n<line113>parallel_files = true;\n<line114>storing_columns = false;\n<line115>break;\n<line116>case 'n':\n<line117>numbered_lines = true;\n<line118>if (optarg)\n<line119>getoptarg (optarg, 'n', &number_separator,\n<line120>&chars_per_number);\n<line121>break;\n<line122>case 'N':\n<line123>skip_count = false;\n<line124>getoptnum (optarg, INT_MIN, &start_line_num,\n<line125>_("'-N NUMBER' invalid starting line number"));\n<line126>break;\n<line127>case 'o':\n<line128>getoptnum (optarg, 0, &chars_per_margin,\n<line129>_("'-o MARGIN' invalid line offset"));\n<line130>break;\n<line131>case 'r':\n<line132>ignore_failed_opens = true;\n<line133>break;\n<line134>case 's':\n<line135>old_options = true;\n<line136>old_s = true;\n<line137>if (!use_col_separator && optarg)\n<line138>separator_string (optarg);\n<line139>break;\n<line140>case 'S':\n<line141>old_s = false;\n<line142>/* Reset an additional input of -s, -S dominates -s */\n<line143>col_sep_string = "";\n<line144>col_sep_length = 0;\n<line145>use_col_separator = true;\n<line146>if (optarg)\n<line147>separator_string (optarg);\n<line148>break;\n<line149>case 't':\n<line150>extremities = false;\n<line151>keep_FF = true;\n<line152>break;\n<line153>case 'T':\n<line154>extremities = false;\n<line155>keep_FF = false;\n<line156>break;\n<line157>case 'v':\n<line158>use_esc_sequence = true;\n<line159>break;\n<line160>case 'w':\n<line161>old_options = true;\n<line162>old_w = true;\n<line163>{\n<line164>int tmp_cpl;\n<line165>getoptnum (optarg, 1, &tmp_cpl,\n<line166>_("'-w PAGE_WIDTH' invalid number of characters"));\n<line167>if (! truncate_lines)\n<line168>chars_per_line = tmp_cpl;\n<line169>}\n<line170>break;\n<line171>case 'W':\n<line172>old_w = false;			/* dominates -w */\n<line173>truncate_lines = true;\n<line174>getoptnum (optarg, 1, &chars_per_line,\n<line175>_("'-W PAGE_WIDTH' invalid number of characters"));\n<line176>break;\n<line177>case_GETOPT_HELP_CHAR;\n<line178>case_GETOPT_VERSION_CHAR (PROGRAM_NAME, AUTHORS);\n<line179>default:\n<line180>usage (EXIT_FAILURE);\n<line181>break;\n<line182>}\n<line183>}\n<line184>if (column_count_string)\n<line185>{\n<line186>parse_column_count (column_count_string);\n<line187>free (column_count_string);\n<line188>}\n<line189>if (! date_format)\n<line190>date_format = (getenv ("POSIXLY_CORRECT") && !hard_locale (LC_TIME)\n<line191>? "%b %e %H:%M %Y"\n<line192>: "%Y-%m-%d %H:%M");\n<line193>localtz = tzalloc (getenv ("TZ"));\n<line194>/* Now we can set a reasonable initial value: */\n<line195>if (first_page_number == 0)\n<line196>first_page_number = 1;\n<line197>if (parallel_files && explicit_columns)\n<line198>error (EXIT_FAILURE, 0,\n<line199>_("cannot specify number of columns when printing in parallel"));\n<line200>if (parallel_files && print_across_flag)\n<line201>error (EXIT_FAILURE, 0,\n<line202>_("cannot specify both printing across and printing in parallel"));\n<line203>/* Translate some old short options to new/long options.\n<line204>To meet downward compatibility with other UNIX pr utilities\n<line205>and some POSIX specifications. */\n<line206>if (old_options)\n<line207>{\n<line208>if (old_w)\n<line209>{\n<line210>if (parallel_files || explicit_columns)\n<line211>{\n<line212>/* activate -W */\n<line213>truncate_lines = true;\n<line214>if (old_s)\n<line215>/* adapt HP-UX and SunOS: -s = no separator;\n<line216>activate -S */\n<line217>use_col_separator = true;\n<line218>}\n<line219>else\n<line220>/* old -w sets width with columns only\n<line221>activate -J */\n<line222>join_lines = true;\n<line223>}\n<line224>else if (!use_col_separator)\n<line225>{\n<line226>/* No -S option read */\n<line227>if (old_s && (parallel_files || explicit_columns))\n<line228>{\n<line229>if (!truncate_lines)\n<line230>{\n<line231>/* old -s (without -w and -W) annuls column alignment,\n<line232>uses fields, activate -J */\n<line233>join_lines = true;\n<line234>if (col_sep_length > 0)\n<line235>/* activate -S */\n<line236>use_col_separator = true;\n<line237>}\n<line238>else\n<line239>/* with -W */\n<line240>/* adapt HP-UX and SunOS: -s = no separator;\n<line241>activate -S */\n<line242>use_col_separator = true;\n<line243>}\n<line244>}\n<line245>}\n<line246>for (; optind < argc; optind++)\n<line247>{\n<line248>file_names[n_files++] = argv[optind];\n<line249>}\n<line250>if (n_files == 0)\n<line251>{\n<line252>/* No file arguments specified;  read from standard input.  */\n<line253>print_files (0, nullptr);\n<line254>}\n<line255>else\n<line256>{\n<line257>if (parallel_files)\n<line258>print_files (n_files, file_names);\n<line259>else\n<line260>{\n<line261>for (unsigned int i = 0; i < n_files; i++)\n<line262>print_files (1, &file_names[i]);\n<line263>}\n<line264>}\n<line265>cleanup ();\n<line266>if (have_read_stdin && fclose (stdin) == EOF)\n<line267>error (EXIT_FAILURE, errno, _("standard input"));\n<line268>main_exit (failed_opens ? EXIT_FAILURE : EXIT_SUCCESS);\n<line269>}
----------------------------------------
Function: getoptnum
Content: <line0>static void\n<line1>getoptnum (char const *n_str, int min, int *num, char const *err)\n<line2>{\n<line3>intmax_t tnum = xdectoimax (n_str, min, INT_MAX, "", err, 0);\n<line4>*num = tnum;\n<line5>}
----------------------------------------
Function: getoptarg
Content: <line0>static void\n<line1>getoptarg (char *arg, char switch_char, char *character, int *number)\n<line2>{\n<line3>if (!*arg)\n<line4>{\n<line5>error (0, 0, _("'-%c': Invalid argument: %s"), switch_char, quote (arg));\n<line6>usage (EXIT_FAILURE);\n<line7>}\n<line8>if (!ISDIGIT (*arg))\n<line9>*character = *arg++;\n<line10>if (*arg)\n<line11>{\n<line12>long int tmp_long;\n<line13>strtol_error e = xstrtol (arg, nullptr, 10, &tmp_long, "");\n<line14>if (e == LONGINT_OK)\n<line15>{\n<line16>if (tmp_long <= 0)\n<line17>e = LONGINT_INVALID;\n<line18>else if (INT_MAX < tmp_long)\n<line19>e = LONGINT_OVERFLOW;\n<line20>}\n<line21>if (e != LONGINT_OK)\n<line22>{\n<line23>error (0, e & LONGINT_OVERFLOW ? EOVERFLOW : 0,\n<line24>_("'-%c' extra characters or invalid number in the argument: %s"),\n<line25>switch_char, quote (arg));\n<line26>usage (EXIT_FAILURE);\n<line27>}\n<line28>*number = tmp_long;\n<line29>}\n<line30>}
----------------------------------------
Function: init_parameters
Content: <line0>static void\n<line1>init_parameters (int number_of_files)\n<line2>{\n<line3>int chars_used_by_number = 0;\n<line4>lines_per_body = lines_per_page - lines_per_header - lines_per_footer;\n<line5>if (lines_per_body <= 0)\n<line6>{\n<line7>extremities = false;\n<line8>keep_FF = true;\n<line9>}\n<line10>if (extremities == false)\n<line11>lines_per_body = lines_per_page;\n<line12>if (double_space)\n<line13>lines_per_body = MAX (1, lines_per_body / 2);\n<line14>/* If input is stdin, cannot print parallel files.  BSD dumps core\n<line15>on this. */\n<line16>if (number_of_files == 0)\n<line17>parallel_files = false;\n<line18>if (parallel_files)\n<line19>columns = number_of_files;\n<line20>/* One file, multi columns down: -b option is set to get a consistent\n<line21>formulation with "FF set by hand" in input files. */\n<line22>if (storing_columns)\n<line23>balance_columns = true;\n<line24>/* Tabification is assumed for multiple columns. */\n<line25>if (columns > 1)\n<line26>{\n<line27>if (!use_col_separator)\n<line28>{\n<line29>/* Use default separator */\n<line30>if (join_lines)\n<line31>col_sep_string = line_separator;\n<line32>else\n<line33>col_sep_string = column_separator;\n<line34>col_sep_length = 1;\n<line35>use_col_separator = true;\n<line36>}\n<line37>/* It's rather pointless to define a TAB separator with column\n<line38>alignment */\n<line39>else if (!join_lines && col_sep_length == 1 && *col_sep_string == '\t')\n<line40>col_sep_string = column_separator;\n<line41>truncate_lines = true;\n<line42>if (! (col_sep_length == 1 && *col_sep_string == '\t'))\n<line43>untabify_input = true;\n<line44>tabify_output = true;\n<line45>}\n<line46>else\n<line47>storing_columns = false;\n<line48>/* -J dominates -w in any case */\n<line49>if (join_lines)\n<line50>truncate_lines = false;\n<line51>if (numbered_lines)\n<line52>{\n<line53>int chars_per_default_tab = 8;\n<line54>line_count = start_line_num;\n<line55>/* To allow input tab-expansion (-e sensitive) use:\n<line56>if (number_separator == input_tab_char)\n<line57>number_width = chars_per_number\n<line58>+ TAB_WIDTH (chars_per_input_tab, chars_per_number);   */\n<line59>/* Estimate chars_per_text without any margin and keep it constant. */\n<line60>if (number_separator == '\t')\n<line61>number_width = (chars_per_number\n<line62>+ TAB_WIDTH (chars_per_default_tab, chars_per_number));\n<line63>else\n<line64>number_width = chars_per_number + 1;\n<line65>/* The number is part of the column width unless we are\n<line66>printing files in parallel. */\n<line67>if (parallel_files)\n<line68>chars_used_by_number = number_width;\n<line69>}\n<line70>int sep_chars, useful_chars;\n<line71>if (ckd_mul (&sep_chars, columns - 1, col_sep_length))\n<line72>sep_chars = INT_MAX;\n<line73>if (ckd_sub (&useful_chars, chars_per_line - chars_used_by_number,\n<line74>sep_chars))\n<line75>useful_chars = 0;\n<line76>chars_per_column = useful_chars / columns;\n<line77>if (chars_per_column < 1)\n<line78>error (EXIT_FAILURE, 0, _("page width too narrow"));\n<line79>if (numbered_lines)\n<line80>{\n<line81>free (number_buff);\n<line82>number_buff = xmalloc (MAX (chars_per_number,\n<line83>INT_STRLEN_BOUND (line_number)) + 1);\n<line84>}\n<line85>/* Pick the maximum between the tab width and the width of an\n<line86>escape sequence.\n<line87>The width of an escape sequence (4) isn't the lower limit any longer.\n<line88>We've to use 8 as the lower limit, if we use chars_per_default_tab = 8\n<line89>to expand a tab which is not an input_tab-char. */\n<line90>free (clump_buff);\n<line91>clump_buff = xmalloc (MAX (8, chars_per_input_tab));\n<line92>}
----------------------------------------
Function: init_fps
Content: <line0>static bool\n<line1>init_fps (int number_of_files, char **av)\n<line2>{\n<line3>COLUMN *p;\n<line4>total_files = 0;\n<line5>free (column_vector);\n<line6>column_vector = xnmalloc (columns, sizeof (COLUMN));\n<line7>if (parallel_files)\n<line8>{\n<line9>int files_left = number_of_files;\n<line10>for (p = column_vector; files_left--; ++p, ++av)\n<line11>{\n<line12>if (! open_file (*av, p))\n<line13>{\n<line14>--p;\n<line15>--columns;\n<line16>}\n<line17>}\n<line18>if (columns == 0)\n<line19>return false;\n<line20>init_header ("", -1);\n<line21>}\n<line22>else\n<line23>{\n<line24>p = column_vector;\n<line25>if (number_of_files > 0)\n<line26>{\n<line27>if (! open_file (*av, p))\n<line28>return false;\n<line29>init_header (*av, fileno (p->fp));\n<line30>p->lines_stored = 0;\n<line31>}\n<line32>else\n<line33>{\n<line34>p->name = _("standard input");\n<line35>p->fp = stdin;\n<line36>have_read_stdin = true;\n<line37>p->status = OPEN;\n<line38>p->full_page_printed = false;\n<line39>++total_files;\n<line40>init_header ("", -1);\n<line41>p->lines_stored = 0;\n<line42>}\n<line43>char const *firstname = p->name;\n<line44>FILE *firstfp = p->fp;\n<line45>int i;\n<line46>for (i = columns - 1, ++p; i; --i, ++p)\n<line47>{\n<line48>p->name = firstname;\n<line49>p->fp = firstfp;\n<line50>p->status = OPEN;\n<line51>p->full_page_printed = false;\n<line52>p->lines_stored = 0;\n<line53>}\n<line54>}\n<line55>files_ready_to_read = total_files;\n<line56>return true;\n<line57>}
----------------------------------------
Function: init_funcs
Content: <line0>static void\n<line1>init_funcs (void)\n<line2>{\n<line3>int i, h, h_next;\n<line4>COLUMN *p;\n<line5>h = chars_per_margin;\n<line6>if (!truncate_lines)\n<line7>h_next = ANYWHERE;\n<line8>else\n<line9>{\n<line10>/* When numbering lines of parallel files, we enlarge the\n<line11>first column to accommodate the number.  Looks better than\n<line12>the Sys V approach. */\n<line13>if (parallel_files && numbered_lines)\n<line14>h_next = h + chars_per_column + number_width;\n<line15>else\n<line16>h_next = h + chars_per_column;\n<line17>}\n<line18>/* Enlarge p->start_position of first column to use the same form of\n<line19>padding_not_printed with all columns. */\n<line20>h = h + col_sep_length;\n<line21>/* This loop takes care of all but the rightmost column. */\n<line22>for (p = column_vector, i = 1; i < columns; ++p, ++i)\n<line23>{\n<line24>if (storing_columns)	/* One file, multi columns down. */\n<line25>{\n<line26>p->char_func = store_char;\n<line27>p->print_func = print_stored;\n<line28>}\n<line29>else\n<line30>/* One file, multi columns across; or parallel files.  */\n<line31>{\n<line32>p->char_func = print_char;\n<line33>p->print_func = read_line;\n<line34>}\n<line35>/* Number only the first column when printing files in\n<line36>parallel. */\n<line37>p->numbered = numbered_lines && (!parallel_files || i == 1);\n<line38>p->start_position = h;\n<line39>/* If we don't truncate lines, all start_positions are\n<line40>ANYWHERE, except the first column's start_position when\n<line41>using a margin. */\n<line42>if (!truncate_lines)\n<line43>{\n<line44>h = ANYWHERE;\n<line45>h_next = ANYWHERE;\n<line46>}\n<line47>else\n<line48>{\n<line49>h = h_next + col_sep_length;\n<line50>h_next = h + chars_per_column;\n<line51>}\n<line52>}\n<line53>/* The rightmost column.\n<line54>Doesn't need to be stored unless we intend to balance\n<line55>columns on the last page. */\n<line56>if (storing_columns && balance_columns)\n<line57>{\n<line58>p->char_func = store_char;\n<line59>p->print_func = print_stored;\n<line60>}\n<line61>else\n<line62>{\n<line63>p->char_func = print_char;\n<line64>p->print_func = read_line;\n<line65>}\n<line66>p->numbered = numbered_lines && (!parallel_files || i == 1);\n<line67>p->start_position = h;\n<line68>}
----------------------------------------
Function: open_file
Content: <line0>static bool\n<line1>open_file (char *name, COLUMN *p)\n<line2>{\n<line3>if (STREQ (name, "-"))\n<line4>{\n<line5>p->name = _("standard input");\n<line6>p->fp = stdin;\n<line7>have_read_stdin = true;\n<line8>}\n<line9>else\n<line10>{\n<line11>p->name = name;\n<line12>p->fp = fopen (name, "r");\n<line13>}\n<line14>if (p->fp == nullptr)\n<line15>{\n<line16>failed_opens = true;\n<line17>if (!ignore_failed_opens)\n<line18>error (0, errno, "%s", quotef (name));\n<line19>return false;\n<line20>}\n<line21>fadvise (p->fp, FADVISE_SEQUENTIAL);\n<line22>p->status = OPEN;\n<line23>p->full_page_printed = false;\n<line24>++total_files;\n<line25>return true;\n<line26>}
----------------------------------------
Function: close_file
Content: <line0>static void\n<line1>close_file (COLUMN *p)\n<line2>{\n<line3>COLUMN *q;\n<line4>int i;\n<line5>if (p->status == CLOSED)\n<line6>return;\n<line7>int err = errno;\n<line8>if (!ferror (p->fp))\n<line9>err = 0;\n<line10>if (fileno (p->fp) == STDIN_FILENO)\n<line11>clearerr (p->fp);\n<line12>else if (fclose (p->fp) != 0 && !err)\n<line13>err = errno;\n<line14>if (err)\n<line15>error (EXIT_FAILURE, err, "%s", quotef (p->name));\n<line16>if (!parallel_files)\n<line17>{\n<line18>for (q = column_vector, i = columns; i; ++q, --i)\n<line19>{\n<line20>q->status = CLOSED;\n<line21>if (q->lines_stored == 0)\n<line22>{\n<line23>q->lines_to_print = 0;\n<line24>}\n<line25>}\n<line26>}\n<line27>else\n<line28>{\n<line29>p->status = CLOSED;\n<line30>p->lines_to_print = 0;\n<line31>}\n<line32>--files_ready_to_read;\n<line33>}
----------------------------------------
Function: hold_file
Content: <line0>static void\n<line1>hold_file (COLUMN *p)\n<line2>{\n<line3>COLUMN *q;\n<line4>int i;\n<line5>if (!parallel_files)\n<line6>for (q = column_vector, i = columns; i; ++q, --i)\n<line7>{\n<line8>if (storing_columns)\n<line9>q->status = FF_FOUND;\n<line10>else\n<line11>q->status = ON_HOLD;\n<line12>}\n<line13>else\n<line14>p->status = ON_HOLD;\n<line15>p->lines_to_print = 0;\n<line16>--files_ready_to_read;\n<line17>}
----------------------------------------
Function: reset_status
Content: <line0>static void\n<line1>reset_status (void)\n<line2>{\n<line3>int i = columns;\n<line4>COLUMN *p;\n<line5>for (p = column_vector; i; --i, ++p)\n<line6>if (p->status == ON_HOLD)\n<line7>{\n<line8>p->status = OPEN;\n<line9>files_ready_to_read++;\n<line10>}\n<line11>if (storing_columns)\n<line12>{\n<line13>if (column_vector->status == CLOSED)\n<line14>/* We use the info to output an error message in  skip_to_page. */\n<line15>files_ready_to_read = 0;\n<line16>else\n<line17>files_ready_to_read = 1;\n<line18>}\n<line19>}
----------------------------------------
Function: print_files
Content: <line0>static void\n<line1>print_files (int number_of_files, char **av)\n<line2>{\n<line3>init_parameters (number_of_files);\n<line4>if (! init_fps (number_of_files, av))\n<line5>return;\n<line6>if (storing_columns)\n<line7>init_store_cols ();\n<line8>if (first_page_number > 1)\n<line9>{\n<line10>if (!skip_to_page (first_page_number))\n<line11>return;\n<line12>else\n<line13>page_number = first_page_number;\n<line14>}\n<line15>else\n<line16>page_number = 1;\n<line17>init_funcs ();\n<line18>line_number = line_count;\n<line19>while (print_page ())\n<line20>;\n<line21>}
----------------------------------------
Function: init_header
Content: <line0>static void\n<line1>init_header (char const *filename, int desc)\n<line2>{\n<line3>char *buf = nullptr;\n<line4>struct stat st;\n<line5>struct timespec t;\n<line6>int ns;\n<line7>struct tm tm;\n<line8>/* If parallel files or standard input, use current date. */\n<line9>if (STREQ (filename, "-"))\n<line10>desc = -1;\n<line11>if (0 <= desc && fstat (desc, &st) == 0)\n<line12>t = get_stat_mtime (&st);\n<line13>else\n<line14>{\n<line15>static struct timespec timespec;\n<line16>if (! timespec.tv_sec)\n<line17>gettime (&timespec);\n<line18>t = timespec;\n<line19>}\n<line20>ns = t.tv_nsec;\n<line21>if (localtime_rz (localtz, &t.tv_sec, &tm))\n<line22>{\n<line23>size_t bufsize\n<line24>= nstrftime (nullptr, SIZE_MAX, date_format, &tm, localtz, ns) + 1;\n<line25>buf = xmalloc (bufsize);\n<line26>nstrftime (buf, bufsize, date_format, &tm, localtz, ns);\n<line27>}\n<line28>else\n<line29>{\n<line30>char secbuf[INT_BUFSIZE_BOUND (intmax_t)];\n<line31>buf = xmalloc (sizeof secbuf + MAX (10, INT_BUFSIZE_BOUND (int)));\n<line32>sprintf (buf, "%s.%09d", timetostr (t.tv_sec, secbuf), ns);\n<line33>}\n<line34>free (date_text);\n<line35>date_text = buf;\n<line36>file_text = custom_header ? custom_header : desc < 0 ? "" : filename;\n<line37>header_width_available = (chars_per_line\n<line38>- mbswidth (date_text, 0)\n<line39>- mbswidth (file_text, 0));\n<line40>}
----------------------------------------
Function: init_page
Content: <line0>static void\n<line1>init_page (void)\n<line2>{\n<line3>int j;\n<line4>COLUMN *p;\n<line5>if (storing_columns)\n<line6>{\n<line7>store_columns ();\n<line8>for (j = columns - 1, p = column_vector; j; --j, ++p)\n<line9>{\n<line10>p->lines_to_print = p->lines_stored;\n<line11>}\n<line12>/* Last column. */\n<line13>if (balance_columns)\n<line14>{\n<line15>p->lines_to_print = p->lines_stored;\n<line16>}\n<line17>/* Since we're not balancing columns, we don't need to store\n<line18>the rightmost column.   Read it straight from the file. */\n<line19>else\n<line20>{\n<line21>if (p->status == OPEN)\n<line22>{\n<line23>p->lines_to_print = lines_per_body;\n<line24>}\n<line25>else\n<line26>p->lines_to_print = 0;\n<line27>}\n<line28>}\n<line29>else\n<line30>for (j = columns, p = column_vector; j; --j, ++p)\n<line31>if (p->status == OPEN)\n<line32>{\n<line33>p->lines_to_print = lines_per_body;\n<line34>}\n<line35>else\n<line36>p->lines_to_print = 0;\n<line37>}
----------------------------------------
Function: align_column
Content: <line0>static void\n<line1>align_column (COLUMN *p)\n<line2>{\n<line3>padding_not_printed = p->start_position;\n<line4>if (col_sep_length < padding_not_printed)\n<line5>{\n<line6>pad_across_to (padding_not_printed - col_sep_length);\n<line7>padding_not_printed = ANYWHERE;\n<line8>}\n<line9>if (use_col_separator)\n<line10>print_sep_string ();\n<line11>if (p->numbered)\n<line12>add_line_number (p);\n<line13>}
----------------------------------------
Function: print_page
Content: <line0>static bool\n<line1>print_page (void)\n<line2>{\n<line3>int j;\n<line4>int lines_left_on_page;\n<line5>COLUMN *p;\n<line6>/* Used as an accumulator (with | operator) of successive values of\n<line7>pad_vertically.  The trick is to set pad_vertically\n<line8>to false before each run through the inner loop, then after that\n<line9>loop, it tells us whether a line was actually printed (whether a\n<line10>newline needs to be output -- or two for double spacing).  But those\n<line11>values have to be accumulated (in pv) so we can invoke pad_down\n<line12>properly after the outer loop completes. */\n<line13>bool pv;\n<line14>init_page ();\n<line15>if (cols_ready_to_print () == 0)\n<line16>return false;\n<line17>if (extremities)\n<line18>print_a_header = true;\n<line19>/* Don't pad unless we know a page was printed. */\n<line20>pad_vertically = false;\n<line21>pv = false;\n<line22>lines_left_on_page = lines_per_body;\n<line23>if (double_space)\n<line24>lines_left_on_page *= 2;\n<line25>while (lines_left_on_page > 0 && cols_ready_to_print () > 0)\n<line26>{\n<line27>output_position = 0;\n<line28>spaces_not_printed = 0;\n<line29>separators_not_printed = 0;\n<line30>pad_vertically = false;\n<line31>align_empty_cols = false;\n<line32>empty_line = true;\n<line33>for (j = 1, p = column_vector; j <= columns; ++j, ++p)\n<line34>{\n<line35>input_position = 0;\n<line36>if (p->lines_to_print > 0 || p->status == FF_FOUND)\n<line37>{\n<line38>FF_only = false;\n<line39>padding_not_printed = p->start_position;\n<line40>if (!(p->print_func) (p))\n<line41>read_rest_of_line (p);\n<line42>pv |= pad_vertically;\n<line43>--p->lines_to_print;\n<line44>if (p->lines_to_print <= 0)\n<line45>{\n<line46>if (cols_ready_to_print () == 0)\n<line47>break;\n<line48>}\n<line49>/* File p changed its status to ON_HOLD or CLOSED */\n<line50>if (parallel_files && p->status != OPEN)\n<line51>{\n<line52>if (empty_line)\n<line53>align_empty_cols = true;\n<line54>else if (p->status == CLOSED\n<line55>|| (p->status == ON_HOLD && FF_only))\n<line56>align_column (p);\n<line57>}\n<line58>}\n<line59>else if (parallel_files)\n<line60>{\n<line61>/* File status ON_HOLD or CLOSED */\n<line62>if (empty_line)\n<line63>align_empty_cols = true;\n<line64>else\n<line65>align_column (p);\n<line66>}\n<line67>/* We need it also with an empty column */\n<line68>if (use_col_separator)\n<line69>++separators_not_printed;\n<line70>}\n<line71>if (pad_vertically)\n<line72>{\n<line73>putchar ('\n');\n<line74>--lines_left_on_page;\n<line75>}\n<line76>if (cols_ready_to_print () == 0 && !extremities)\n<line77>break;\n<line78>if (double_space && pv)\n<line79>{\n<line80>putchar ('\n');\n<line81>--lines_left_on_page;\n<line82>}\n<line83>}\n<line84>if (lines_left_on_page == 0)\n<line85>for (j = 1, p = column_vector; j <= columns; ++j, ++p)\n<line86>if (p->status == OPEN)\n<line87>p->full_page_printed = true;\n<line88>pad_vertically = pv;\n<line89>if (pad_vertically && extremities)\n<line90>pad_down (lines_left_on_page + lines_per_footer);\n<line91>else if (keep_FF && print_a_FF)\n<line92>{\n<line93>putchar ('\f');\n<line94>print_a_FF = false;\n<line95>}\n<line96>if (last_page_number < ++page_number)\n<line97>return false;		/* Stop printing with LAST_PAGE */\n<line98>reset_status ();		/* Change ON_HOLD to OPEN. */\n<line99>return true;			/* More pages to go. */\n<line100>}
----------------------------------------
Function: init_store_cols
Content: <line0>static void\n<line1>init_store_cols (void)\n<line2>{\n<line3>int total_lines, total_lines_1, chars_per_column_1, chars_if_truncate;\n<line4>if (ckd_mul (&total_lines, lines_per_body, columns)\n<line5>|| ckd_add (&total_lines_1, total_lines, 1)\n<line6>|| ckd_add (&chars_per_column_1, chars_per_column, 1)\n<line7>|| ckd_mul (&chars_if_truncate, total_lines, chars_per_column_1))\n<line8>integer_overflow ();\n<line9>free (line_vector);\n<line10>/* FIXME: here's where it was allocated.  */\n<line11>line_vector = xnmalloc (total_lines_1, sizeof *line_vector);\n<line12>free (end_vector);\n<line13>end_vector = xnmalloc (total_lines, sizeof *end_vector);\n<line14>free (buff);\n<line15>buff = xnmalloc (chars_if_truncate, use_col_separator + 1);\n<line16>buff_allocated = chars_if_truncate;  /* Tune this. */\n<line17>buff_allocated *= use_col_separator + 1;\n<line18>}
----------------------------------------
Function: store_columns
Content: <line0>static void\n<line1>store_columns (void)\n<line2>{\n<line3>int i, j;\n<line4>unsigned int line = 0;\n<line5>unsigned int buff_start;\n<line6>int last_col;		/* The rightmost column which will be saved in buff */\n<line7>COLUMN *p;\n<line8>buff_current = 0;\n<line9>buff_start = 0;\n<line10>if (balance_columns)\n<line11>last_col = columns;\n<line12>else\n<line13>last_col = columns - 1;\n<line14>for (i = 1, p = column_vector; i <= last_col; ++i, ++p)\n<line15>p->lines_stored = 0;\n<line16>for (i = 1, p = column_vector; i <= last_col && files_ready_to_read;\n<line17>++i, ++p)\n<line18>{\n<line19>p->current_line = line;\n<line20>for (j = lines_per_body; j && files_ready_to_read; --j)\n<line21>if (p->status == OPEN)	/* Redundant.  Clean up. */\n<line22>{\n<line23>input_position = 0;\n<line24>if (!read_line (p))\n<line25>read_rest_of_line (p);\n<line26>if (p->status == OPEN\n<line27>|| buff_start != buff_current)\n<line28>{\n<line29>++p->lines_stored;\n<line30>line_vector[line] = buff_start;\n<line31>end_vector[line++] = input_position;\n<line32>buff_start = buff_current;\n<line33>}\n<line34>}\n<line35>}\n<line36>/* Keep track of the location of the last char in buff. */\n<line37>line_vector[line] = buff_start;\n<line38>if (balance_columns)\n<line39>balance (line);\n<line40>}
----------------------------------------
Function: balance
Content: <line0>static void\n<line1>balance (int total_stored)\n<line2>{\n<line3>COLUMN *p;\n<line4>int i, lines;\n<line5>int first_line = 0;\n<line6>for (i = 1, p = column_vector; i <= columns; ++i, ++p)\n<line7>{\n<line8>lines = total_stored / columns;\n<line9>if (i <= total_stored % columns)\n<line10>++lines;\n<line11>p->lines_stored = lines;\n<line12>p->current_line = first_line;\n<line13>first_line += lines;\n<line14>}\n<line15>}
----------------------------------------
Function: store_char
Content: <line0>static void\n<line1>store_char (char c)\n<line2>{\n<line3>if (buff_current >= buff_allocated)\n<line4>{\n<line5>/* May be too generous. */\n<line6>buff = X2REALLOC (buff, &buff_allocated);\n<line7>}\n<line8>buff[buff_current++] = c;\n<line9>}
----------------------------------------
Function: add_line_number
Content: <line0>static void\n<line1>add_line_number (COLUMN *p)\n<line2>{\n<line3>int i;\n<line4>char *s;\n<line5>int num_width;\n<line6>/* Cutting off the higher-order digits is more informative than\n<line7>lower-order cut off. */\n<line8>num_width = sprintf (number_buff, "%*d", chars_per_number, line_number);\n<line9>line_number++;\n<line10>s = number_buff + (num_width - chars_per_number);\n<line11>for (i = chars_per_number; i > 0; i--)\n<line12>(p->char_func) (*s++);\n<line13>if (columns > 1)\n<line14>{\n<line15>/* Tabification is assumed for multiple columns, also for n-separators,\n<line16>but 'default n-separator = TAB' hasn't been given priority over\n<line17>equal column_width also specified by POSIX. */\n<line18>if (number_separator == '\t')\n<line19>{\n<line20>i = number_width - chars_per_number;\n<line21>while (i-- > 0)\n<line22>(p->char_func) (' ');\n<line23>}\n<line24>else\n<line25>(p->char_func) (number_separator);\n<line26>}\n<line27>else\n<line28>/* To comply with POSIX, we avoid any expansion of default TAB\n<line29>separator with a single column output. No column_width requirement\n<line30>has to be considered. */\n<line31>{\n<line32>(p->char_func) (number_separator);\n<line33>if (number_separator == '\t')\n<line34>output_position = POS_AFTER_TAB (chars_per_output_tab,\n<line35>output_position);\n<line36>}\n<line37>if (truncate_lines && !parallel_files)\n<line38>input_position += number_width;\n<line39>}
----------------------------------------
Function: pad_across_to
Content: <line0>static void\n<line1>pad_across_to (int position)\n<line2>{\n<line3>int h = output_position;\n<line4>if (tabify_output)\n<line5>spaces_not_printed = position - output_position;\n<line6>else\n<line7>{\n<line8>while (++h <= position)\n<line9>putchar (' ');\n<line10>output_position = position;\n<line11>}\n<line12>}
----------------------------------------
Function: pad_down
Content: <line0>static void\n<line1>pad_down (unsigned int lines)\n<line2>{\n<line3>if (use_form_feed)\n<line4>putchar ('\f');\n<line5>else\n<line6>for (unsigned int i = lines; i; --i)\n<line7>putchar ('\n');\n<line8>}
----------------------------------------
Function: read_rest_of_line
Content: <line0>static void\n<line1>read_rest_of_line (COLUMN *p)\n<line2>{\n<line3>int c;\n<line4>FILE *f = p->fp;\n<line5>while ((c = getc (f)) != '\n')\n<line6>{\n<line7>if (c == '\f')\n<line8>{\n<line9>if ((c = getc (f)) != '\n')\n<line10>ungetc (c, f);\n<line11>if (keep_FF)\n<line12>print_a_FF = true;\n<line13>hold_file (p);\n<line14>break;\n<line15>}\n<line16>else if (c == EOF)\n<line17>{\n<line18>close_file (p);\n<line19>break;\n<line20>}\n<line21>}\n<line22>}
----------------------------------------
Function: skip_read
Content: <line0>static void\n<line1>skip_read (COLUMN *p, int column_number)\n<line2>{\n<line3>int c;\n<line4>FILE *f = p->fp;\n<line5>int i;\n<line6>bool single_ff = false;\n<line7>COLUMN *q;\n<line8>/* Read 1st character in a line or any character succeeding a FF */\n<line9>if ((c = getc (f)) == '\f' && p->full_page_printed)\n<line10>/* A FF-coincidence with a previous full_page_printed.\n<line11>To avoid an additional empty page, eliminate the FF */\n<line12>if ((c = getc (f)) == '\n')\n<line13>c = getc (f);\n<line14>p->full_page_printed = false;\n<line15>/* 1st character a FF means a single FF without any printable\n<line16>characters. Don't count it as a line with -n option. */\n<line17>if (c == '\f')\n<line18>single_ff = true;\n<line19>/* Preparing for a FF-coincidence: Maybe we finish that page\n<line20>without a FF found */\n<line21>if (last_line)\n<line22>p->full_page_printed = true;\n<line23>while (c != '\n')\n<line24>{\n<line25>if (c == '\f')\n<line26>{\n<line27>/* No FF-coincidence possible,\n<line28>no catching up of a FF-coincidence with next page */\n<line29>if (last_line)\n<line30>{\n<line31>if (!parallel_files)\n<line32>for (q = column_vector, i = columns; i; ++q, --i)\n<line33>q->full_page_printed = false;\n<line34>else\n<line35>p->full_page_printed = false;\n<line36>}\n<line37>if ((c = getc (f)) != '\n')\n<line38>ungetc (c, f);\n<line39>hold_file (p);\n<line40>break;\n<line41>}\n<line42>else if (c == EOF)\n<line43>{\n<line44>close_file (p);\n<line45>break;\n<line46>}\n<line47>c = getc (f);\n<line48>}\n<line49>if (skip_count)\n<line50>if ((!parallel_files || column_number == 1) && !single_ff)\n<line51>++line_count;\n<line52>}
----------------------------------------
Function: print_white_space
Content: <line0>static void\n<line1>print_white_space (void)\n<line2>{\n<line3>int h_new;\n<line4>int h_old = output_position;\n<line5>int goal = h_old + spaces_not_printed;\n<line6>while (goal - h_old > 1\n<line7>&& (h_new = POS_AFTER_TAB (chars_per_output_tab, h_old)) <= goal)\n<line8>{\n<line9>putchar (output_tab_char);\n<line10>h_old = h_new;\n<line11>}\n<line12>while (++h_old <= goal)\n<line13>putchar (' ');\n<line14>output_position = goal;\n<line15>spaces_not_printed = 0;\n<line16>}
----------------------------------------
Function: print_sep_string
Content: <line0>static void\n<line1>print_sep_string (void)\n<line2>{\n<line3>char const *s = col_sep_string;\n<line4>int l = col_sep_length;\n<line5>if (separators_not_printed <= 0)\n<line6>{\n<line7>/* We'll be starting a line with chars_per_margin, anything else? */\n<line8>if (spaces_not_printed > 0)\n<line9>print_white_space ();\n<line10>}\n<line11>else\n<line12>{\n<line13>for (; separators_not_printed > 0; --separators_not_printed)\n<line14>{\n<line15>while (l-- > 0)\n<line16>{\n<line17>/* 3 types of sep_strings: spaces only, spaces and chars,\n<line18>chars only */\n<line19>if (*s == ' ')\n<line20>{\n<line21>/* We're tabifying output; consecutive spaces in\n<line22>sep_string may have to be converted to tabs */\n<line23>s++;\n<line24>++spaces_not_printed;\n<line25>}\n<line26>else\n<line27>{\n<line28>if (spaces_not_printed > 0)\n<line29>print_white_space ();\n<line30>putchar (*s++);\n<line31>++output_position;\n<line32>}\n<line33>}\n<line34>/* sep_string ends with some spaces */\n<line35>if (spaces_not_printed > 0)\n<line36>print_white_space ();\n<line37>}\n<line38>}\n<line39>}
----------------------------------------
Function: print_clump
Content: <line0>static void\n<line1>print_clump (COLUMN *p, int n, char *clump)\n<line2>{\n<line3>while (n--)\n<line4>(p->char_func) (*clump++);\n<line5>}
----------------------------------------
Function: print_char
Content: <line0>static void\n<line1>print_char (char c)\n<line2>{\n<line3>if (tabify_output)\n<line4>{\n<line5>if (c == ' ')\n<line6>{\n<line7>++spaces_not_printed;\n<line8>return;\n<line9>}\n<line10>else if (spaces_not_printed > 0)\n<line11>print_white_space ();\n<line12>/* Nonprintables are assumed to have width 0, except '\b'. */\n<line13>if (! isprint (to_uchar (c)))\n<line14>{\n<line15>if (c == '\b')\n<line16>--output_position;\n<line17>}\n<line18>else\n<line19>++output_position;\n<line20>}\n<line21>putchar (c);\n<line22>}
----------------------------------------
Function: skip_to_page
Content: <line0>static bool\n<line1>skip_to_page (uintmax_t page)\n<line2>{\n<line3>for (uintmax_t n = 1; n < page; ++n)\n<line4>{\n<line5>COLUMN *p;\n<line6>int j;\n<line7>for (int i = 1; i < lines_per_body; ++i)\n<line8>{\n<line9>for (j = 1, p = column_vector; j <= columns; ++j, ++p)\n<line10>if (p->status == OPEN)\n<line11>skip_read (p, j);\n<line12>}\n<line13>last_line = true;\n<line14>for (j = 1, p = column_vector; j <= columns; ++j, ++p)\n<line15>if (p->status == OPEN)\n<line16>skip_read (p, j);\n<line17>if (storing_columns)	/* change FF_FOUND to ON_HOLD */\n<line18>for (j = 1, p = column_vector; j <= columns; ++j, ++p)\n<line19>if (p->status != CLOSED)\n<line20>p->status = ON_HOLD;\n<line21>reset_status ();\n<line22>last_line = false;\n<line23>if (files_ready_to_read < 1)\n<line24>{\n<line25>/* It's very helpful, normally the total number of pages is\n<line26>not known in advance.  */\n<line27>error (0, 0,\n<line28>_("starting page number %"PRIuMAX\n<line29>" exceeds page count %"PRIuMAX),\n<line30>page, n);\n<line31>break;\n<line32>}\n<line33>}\n<line34>return files_ready_to_read > 0;\n<line35>}
----------------------------------------
Function: print_header
Content: <line0>static void\n<line1>print_header (void)\n<line2>{\n<line3>char page_text[256 + INT_STRLEN_BOUND (page_number)];\n<line4>int available_width;\n<line5>int lhs_spaces;\n<line6>int rhs_spaces;\n<line7>output_position = 0;\n<line8>pad_across_to (chars_per_margin);\n<line9>print_white_space ();\n<line10>if (page_number == 0)\n<line11>error (EXIT_FAILURE, 0, _("page number overflow"));\n<line12>/* The translator must ensure that formatting the translation of\n<line13>"Page %"PRIuMAX does not generate more than (sizeof page_text - 1)\n<line14>bytes.  */\n<line15>sprintf (page_text, _("Page %"PRIuMAX), page_number);\n<line16>available_width = header_width_available - mbswidth (page_text, 0);\n<line17>available_width = MAX (0, available_width);\n<line18>lhs_spaces = available_width >> 1;\n<line19>rhs_spaces = available_width - lhs_spaces;\n<line20>printf ("\n\n%*s%s%*s%s%*s%s\n\n\n",\n<line21>chars_per_margin, "",\n<line22>date_text, lhs_spaces, " ",\n<line23>file_text, rhs_spaces, " ", page_text);\n<line24>print_a_header = false;\n<line25>output_position = 0;\n<line26>}
----------------------------------------
Function: read_line
Content: <line0>static bool\n<line1>read_line (COLUMN *p)\n<line2>{\n<line3>int c;\n<line4>int chars;\n<line5>int last_input_position;\n<line6>int j, k;\n<line7>COLUMN *q;\n<line8>/* read 1st character in each line or any character succeeding a FF: */\n<line9>c = getc (p->fp);\n<line10>last_input_position = input_position;\n<line11>if (c == '\f' && p->full_page_printed)\n<line12>if ((c = getc (p->fp)) == '\n')\n<line13>c = getc (p->fp);\n<line14>p->full_page_printed = false;\n<line15>switch (c)\n<line16>{\n<line17>case '\f':\n<line18>if ((c = getc (p->fp)) != '\n')\n<line19>ungetc (c, p->fp);\n<line20>FF_only = true;\n<line21>if (print_a_header && !storing_columns)\n<line22>{\n<line23>pad_vertically = true;\n<line24>print_header ();\n<line25>}\n<line26>else if (keep_FF)\n<line27>print_a_FF = true;\n<line28>hold_file (p);\n<line29>return true;\n<line30>case EOF:\n<line31>close_file (p);\n<line32>return true;\n<line33>case '\n':\n<line34>break;\n<line35>default:\n<line36>chars = char_to_clump (c);\n<line37>}\n<line38>if (truncate_lines && input_position > chars_per_column)\n<line39>{\n<line40>input_position = last_input_position;\n<line41>return false;\n<line42>}\n<line43>if (p->char_func != store_char)\n<line44>{\n<line45>pad_vertically = true;\n<line46>if (print_a_header && !storing_columns)\n<line47>print_header ();\n<line48>if (parallel_files && align_empty_cols)\n<line49>{\n<line50>/* We have to align empty columns at the beginning of a line. */\n<line51>k = separators_not_printed;\n<line52>separators_not_printed = 0;\n<line53>for (j = 1, q = column_vector; j <= k; ++j, ++q)\n<line54>{\n<line55>align_column (q);\n<line56>separators_not_printed += 1;\n<line57>}\n<line58>padding_not_printed = p->start_position;\n<line59>if (truncate_lines)\n<line60>spaces_not_printed = chars_per_column;\n<line61>else\n<line62>spaces_not_printed = 0;\n<line63>align_empty_cols = false;\n<line64>}\n<line65>if (col_sep_length < padding_not_printed)\n<line66>{\n<line67>pad_across_to (padding_not_printed - col_sep_length);\n<line68>padding_not_printed = ANYWHERE;\n<line69>}\n<line70>if (use_col_separator)\n<line71>print_sep_string ();\n<line72>}\n<line73>if (p->numbered)\n<line74>add_line_number (p);\n<line75>empty_line = false;\n<line76>if (c == '\n')\n<line77>return true;\n<line78>print_clump (p, chars, clump_buff);\n<line79>while (true)\n<line80>{\n<line81>c = getc (p->fp);\n<line82>switch (c)\n<line83>{\n<line84>case '\n':\n<line85>return true;\n<line86>case '\f':\n<line87>if ((c = getc (p->fp)) != '\n')\n<line88>ungetc (c, p->fp);\n<line89>if (keep_FF)\n<line90>print_a_FF = true;\n<line91>hold_file (p);\n<line92>return true;\n<line93>case EOF:\n<line94>close_file (p);\n<line95>return true;\n<line96>}\n<line97>last_input_position = input_position;\n<line98>chars = char_to_clump (c);\n<line99>if (truncate_lines && input_position > chars_per_column)\n<line100>{\n<line101>input_position = last_input_position;\n<line102>return false;\n<line103>}\n<line104>print_clump (p, chars, clump_buff);\n<line105>}\n<line106>}
----------------------------------------
Function: print_stored
Content: <line0>static bool\n<line1>print_stored (COLUMN *p)\n<line2>{\n<line3>COLUMN *q;\n<line4>int line = p->current_line++;\n<line5>char *first = &buff[line_vector[line]];\n<line6>/* FIXME\n<line7>UMR: Uninitialized memory read:\n<line8>* This is occurring while in:\n<line9>print_stored   [pr.c:2239]\n<line10>* Reading 4 bytes from 0x5148c in the heap.\n<line11>* Address 0x5148c is 4 bytes into a malloc'd block at 0x51488 of 676 bytes\n<line12>* This block was allocated from:\n<line13>malloc         [rtlib.o]\n<line14>xmalloc        [xmalloc.c:94]\n<line15>init_store_cols [pr.c:1648]\n<line16>*/\n<line17>char *last = &buff[line_vector[line + 1]];\n<line18>pad_vertically = true;\n<line19>if (print_a_header)\n<line20>print_header ();\n<line21>if (p->status == FF_FOUND)\n<line22>{\n<line23>int i;\n<line24>for (i = 1, q = column_vector; i <= columns; ++i, ++q)\n<line25>q->status = ON_HOLD;\n<line26>if (column_vector->lines_to_print <= 0)\n<line27>{\n<line28>if (!extremities)\n<line29>pad_vertically = false;\n<line30>return true;		/* print a header only */\n<line31>}\n<line32>}\n<line33>if (col_sep_length < padding_not_printed)\n<line34>{\n<line35>pad_across_to (padding_not_printed - col_sep_length);\n<line36>padding_not_printed = ANYWHERE;\n<line37>}\n<line38>if (use_col_separator)\n<line39>print_sep_string ();\n<line40>while (first != last)\n<line41>print_char (*first++);\n<line42>if (spaces_not_printed == 0)\n<line43>{\n<line44>output_position = p->start_position + end_vector[line];\n<line45>if (p->start_position - col_sep_length == chars_per_margin)\n<line46>output_position -= col_sep_length;\n<line47>}\n<line48>return true;\n<line49>}
----------------------------------------
Function: char_to_clump
Content: <line0>static int\n<line1>char_to_clump (char c)\n<line2>{\n<line3>unsigned char uc = c;\n<line4>char *s = clump_buff;\n<line5>int i;\n<line6>char esc_buff[4];\n<line7>int width;\n<line8>int chars;\n<line9>int chars_per_c = 8;\n<line10>if (c == input_tab_char)\n<line11>chars_per_c = chars_per_input_tab;\n<line12>if (c == input_tab_char || c == '\t')\n<line13>{\n<line14>width = TAB_WIDTH (chars_per_c, input_position);\n<line15>if (untabify_input)\n<line16>{\n<line17>for (i = width; i; --i)\n<line18>*s++ = ' ';\n<line19>chars = width;\n<line20>}\n<line21>else\n<line22>{\n<line23>*s = c;\n<line24>chars = 1;\n<line25>}\n<line26>}\n<line27>else if (! isprint (uc))\n<line28>{\n<line29>if (use_esc_sequence)\n<line30>{\n<line31>width = 4;\n<line32>chars = 4;\n<line33>*s++ = '\\';\n<line34>sprintf (esc_buff, "%03o", uc);\n<line35>for (i = 0; i <= 2; ++i)\n<line36>*s++ = esc_buff[i];\n<line37>}\n<line38>else if (use_cntrl_prefix)\n<line39>{\n<line40>if (uc < 0200)\n<line41>{\n<line42>width = 2;\n<line43>chars = 2;\n<line44>*s++ = '^';\n<line45>*s = c ^ 0100;\n<line46>}\n<line47>else\n<line48>{\n<line49>width = 4;\n<line50>chars = 4;\n<line51>*s++ = '\\';\n<line52>sprintf (esc_buff, "%03o", uc);\n<line53>for (i = 0; i <= 2; ++i)\n<line54>*s++ = esc_buff[i];\n<line55>}\n<line56>}\n<line57>else if (c == '\b')\n<line58>{\n<line59>width = -1;\n<line60>chars = 1;\n<line61>*s = c;\n<line62>}\n<line63>else\n<line64>{\n<line65>width = 0;\n<line66>chars = 1;\n<line67>*s = c;\n<line68>}\n<line69>}\n<line70>else\n<line71>{\n<line72>width = 1;\n<line73>chars = 1;\n<line74>*s = c;\n<line75>}\n<line76>/* Too many backspaces must put us in position 0 -- never negative.  */\n<line77>if (width < 0 && input_position == 0)\n<line78>{\n<line79>chars = 0;\n<line80>input_position = 0;\n<line81>}\n<line82>else if (width < 0 && input_position <= -width)\n<line83>input_position = 0;\n<line84>else\n<line85>input_position += width;\n<line86>return chars;\n<line87>}
----------------------------------------
Function: cleanup
Content: <line0>static void\n<line1>cleanup (void)\n<line2>{\n<line3>free (number_buff);\n<line4>free (clump_buff);\n<line5>free (column_vector);\n<line6>free (line_vector);\n<line7>free (end_vector);\n<line8>free (buff);\n<line9>}
----------------------------------------
Function: usage
Content: <line0>void\n<line1>usage (int status)\n<line2>{\n<line3>if (status != EXIT_SUCCESS)\n<line4>emit_try_help ();\n<line5>else\n<line6>{\n<line7>printf (_("\\n<line8>Usage: %s [OPTION]... [FILE]...\n\\n<line9>"),\n<line10>program_name);\n<line11>fputs (_("\\n<line12>Paginate or columnate FILE(s) for printing.\n\\n<line13>"), stdout);\n<line14>emit_stdin_note ();\n<line15>emit_mandatory_arg_note ();\n<line16>fputs (_("\\n<line17>+FIRST_PAGE[:LAST_PAGE], --pages=FIRST_PAGE[:LAST_PAGE]\n\\n<line18>begin [stop] printing with page FIRST_[LAST_]PAGE\n\\n<line19>-COLUMN, --columns=COLUMN\n\\n<line20>output COLUMN columns and print columns down,\n\\n<line21>unless -a is used. Balance number of lines in the\n\\n<line22>columns on each page\n\\n<line23>"), stdout);\n<line24>fputs (_("\\n<line25>-a, --across      print columns across rather than down, used together\n\\n<line26>with -COLUMN\n\\n<line27>-c, --show-control-chars\n\\n<line28>use hat notation (^G) and octal backslash notation\n\\n<line29>-d, --double-space\n\\n<line30>double space the output\n\\n<line31>"), stdout);\n<line32>fputs (_("\\n<line33>-D, --date-format=FORMAT\n\\n<line34>use FORMAT for the header date\n\\n<line35>-e[CHAR[WIDTH]], --expand-tabs[=CHAR[WIDTH]]\n\\n<line36>expand input CHARs (TABs) to tab WIDTH (8)\n\\n<line37>-F, -f, --form-feed\n\\n<line38>use form feeds instead of newlines to separate pages\n\\n<line39>(by a 3-line page header with -F or a 5-line header\n\\n<line40>and trailer without -F)\n\\n<line41>"), stdout);\n<line42>fputs (_("\\n<line43>-h, --header=HEADER\n\\n<line44>use a centered HEADER instead of filename in page header,\n\\n<line45>-h \"\" prints a blank line, don't use -h\"\"\n\\n<line46>-i[CHAR[WIDTH]], --output-tabs[=CHAR[WIDTH]]\n\\n<line47>replace spaces with CHARs (TABs) to tab WIDTH (8)\n\\n<line48>-J, --join-lines  merge full lines, turns off -W line truncation, no column\n\\n<line49>alignment, --sep-string[=STRING] sets separators\n\\n<line50>"), stdout);\n<line51>fputs (_("\\n<line52>-l, --length=PAGE_LENGTH\n\\n<line53>set the page length to PAGE_LENGTH (66) lines\n\\n<line54>(default number of lines of text 56, and with -F 63).\n\\n<line55>implies -t if PAGE_LENGTH <= 10\n\\n<line56>"), stdout);\n<line57>fputs (_("\\n<line58>-m, --merge       print all files in parallel, one in each column,\n\\n<line59>truncate lines, but join lines of full length with -J\n\\n<line60>"), stdout);\n<line61>fputs (_("\\n<line62>-n[SEP[DIGITS]], --number-lines[=SEP[DIGITS]]\n\\n<line63>number lines, use DIGITS (5) digits, then SEP (TAB),\n\\n<line64>default counting starts with 1st line of input file\n\\n<line65>-N, --first-line-number=NUMBER\n\\n<line66>start counting with NUMBER at 1st line of first\n\\n<line67>page printed (see +FIRST_PAGE)\n\\n<line68>"), stdout);\n<line69>fputs (_("\\n<line70>-o, --indent=MARGIN\n\\n<line71>offset each line with MARGIN (zero) spaces, do not\n\\n<line72>affect -w or -W, MARGIN will be added to PAGE_WIDTH\n\\n<line73>-r, --no-file-warnings\n\\n<line74>omit warning when a file cannot be opened\n\\n<line75>"), stdout);\n<line76>fputs (_("\\n<line77>-s[CHAR], --separator[=CHAR]\n\\n<line78>separate columns by a single character, default for CHAR\n\\n<line79>is the <TAB> character without -w and \'no char\' with -w.\\n<line80>\n\\n<line81>-s[CHAR] turns off line truncation of all 3 column\n\\n<line82>options (-COLUMN|-a -COLUMN|-m) except -w is set\n\\n<line83>"), stdout);\n<line84>fputs (_("\\n<line85>-S[STRING], --sep-string[=STRING]\n\\n<line86>separate columns by STRING,\n\\n<line87>without -S: Default separator <TAB> with -J and <space>\n\\n<line88>otherwise (same as -S\" \"), no effect on column options\n\\n<line89>"), stdout);\n<line90>fputs (_("\\n<line91>-t, --omit-header  omit page headers and trailers;\n\\n<line92>implied if PAGE_LENGTH <= 10\n\\n<line93>"), stdout);\n<line94>fputs (_("\\n<line95>-T, --omit-pagination\n\\n<line96>omit page headers and trailers, eliminate any pagination\n\\n<line97>by form feeds set in input files\n\\n<line98>-v, --show-nonprinting\n\\n<line99>use octal backslash notation\n\\n<line100>-w, --width=PAGE_WIDTH\n\\n<line101>set page width to PAGE_WIDTH (72) characters for\n\\n<line102>multiple text-column output only, -s[char] turns off (72)\n\\n<line103>"), stdout);\n<line104>fputs (_("\\n<line105>-W, --page-width=PAGE_WIDTH\n\\n<line106>set page width to PAGE_WIDTH (72) characters always,\n\\n<line107>truncate lines, except -J option is set, no interference\n\\n<line108>with -S or -s\n\\n<line109>"), stdout);\n<line110>fputs (HELP_OPTION_DESCRIPTION, stdout);\n<line111>fputs (VERSION_OPTION_DESCRIPTION, stdout);\n<line112>emit_ancillary_info (PROGRAM_NAME);\n<line113>}\n<line114>exit (status);\n<line115>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/src/printenv.c
========================================
Function: usage
Content: <line0>void\n<line1>usage (int status)\n<line2>{\n<line3>if (status != EXIT_SUCCESS)\n<line4>emit_try_help ();\n<line5>else\n<line6>{\n<line7>printf (_("\\n<line8>Usage: %s [OPTION]... [VARIABLE]...\n\\n<line9>Print the values of the specified environment VARIABLE(s).\n\\n<line10>If no VARIABLE is specified, print name and value pairs for them all.\n\\n<line11>\n\\n<line12>"),\n<line13>program_name);\n<line14>fputs (_("\\n<line15>-0, --null     end each output line with NUL, not newline\n\\n<line16>"), stdout);\n<line17>fputs (HELP_OPTION_DESCRIPTION, stdout);\n<line18>fputs (VERSION_OPTION_DESCRIPTION, stdout);\n<line19>printf (USAGE_BUILTIN_WARNING, PROGRAM_NAME);\n<line20>emit_ancillary_info (PROGRAM_NAME);\n<line21>}\n<line22>exit (status);\n<line23>}
----------------------------------------
Function: main
Content: <line0>int\n<line1>main (int argc, char **argv)\n<line2>{\n<line3>char **env;\n<line4>char *ep, *ap;\n<line5>int i;\n<line6>bool ok;\n<line7>int optc;\n<line8>bool opt_nul_terminate_output = false;\n<line9>initialize_main (&argc, &argv);\n<line10>set_program_name (argv[0]);\n<line11>setlocale (LC_ALL, "");\n<line12>bindtextdomain (PACKAGE, LOCALEDIR);\n<line13>textdomain (PACKAGE);\n<line14>initialize_exit_failure (PRINTENV_FAILURE);\n<line15>atexit (close_stdout);\n<line16>while ((optc = getopt_long (argc, argv, "+iu:0", longopts, nullptr)) != -1)\n<line17>{\n<line18>switch (optc)\n<line19>{\n<line20>case '0':\n<line21>opt_nul_terminate_output = true;\n<line22>break;\n<line23>case_GETOPT_HELP_CHAR;\n<line24>case_GETOPT_VERSION_CHAR (PROGRAM_NAME, AUTHORS);\n<line25>default:\n<line26>usage (PRINTENV_FAILURE);\n<line27>}\n<line28>}\n<line29>if (optind >= argc)\n<line30>{\n<line31>for (env = environ; *env != nullptr; ++env)\n<line32>printf ("%s%c", *env, opt_nul_terminate_output ? '\0' : '\n');\n<line33>ok = true;\n<line34>}\n<line35>else\n<line36>{\n<line37>int matches = 0;\n<line38>for (i = optind; i < argc; ++i)\n<line39>{\n<line40>bool matched = false;\n<line41>/* 'printenv a=b' is silent, even if 'a=b=c' is in environ.  */\n<line42>if (strchr (argv[i], '='))\n<line43>continue;\n<line44>for (env = environ; *env; ++env)\n<line45>{\n<line46>ep = *env;\n<line47>ap = argv[i];\n<line48>while (*ep != '\0' && *ap != '\0' && *ep++ == *ap++)\n<line49>{\n<line50>if (*ep == '=' && *ap == '\0')\n<line51>{\n<line52>printf ("%s%c", ep + 1,\n<line53>opt_nul_terminate_output ? '\0' : '\n');\n<line54>matched = true;\n<line55>break;\n<line56>}\n<line57>}\n<line58>}\n<line59>matches += matched;\n<line60>}\n<line61>ok = (matches == argc - optind);\n<line62>}\n<line63>return ok ? EXIT_SUCCESS : EXIT_FAILURE;\n<line64>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/src/printf.c
========================================
Function: usage
Content: <line0>void\n<line1>usage (int status)\n<line2>{\n<line3>if (status != EXIT_SUCCESS)\n<line4>emit_try_help ();\n<line5>else\n<line6>{\n<line7>printf (_("\\n<line8>Usage: %s FORMAT [ARGUMENT]...\n\\n<line9>or:  %s OPTION\n\\n<line10>"),\n<line11>program_name, program_name);\n<line12>fputs (_("\\n<line13>Print ARGUMENT(s) according to FORMAT, or execute according to OPTION:\n\\n<line14>\n\\n<line15>"), stdout);\n<line16>fputs (HELP_OPTION_DESCRIPTION, stdout);\n<line17>fputs (VERSION_OPTION_DESCRIPTION, stdout);\n<line18>fputs (_("\\n<line19>\n\\n<line20>FORMAT controls the output as in C printf.  Interpreted sequences are:\n\\n<line21>\n\\n<line22>\\\"      double quote\n\\n<line23>"), stdout);\n<line24>fputs (_("\\n<line25>\\\\      backslash\n\\n<line26>\\a      alert (BEL)\n\\n<line27>\\b      backspace\n\\n<line28>\\c      produce no further output\n\\n<line29>\\e      escape\n\\n<line30>\\f      form feed\n\\n<line31>\\n      new line\n\\n<line32>\\r      carriage return\n\\n<line33>\\t      horizontal tab\n\\n<line34>\\v      vertical tab\n\\n<line35>"), stdout);\n<line36>fputs (_("\\n<line37>\\NNN    byte with octal value NNN (1 to 3 digits)\n\\n<line38>\\xHH    byte with hexadecimal value HH (1 to 2 digits)\n\\n<line39>\\uHHHH  Unicode (ISO/IEC 10646) character with hex value HHHH (4 digits)\n\\n<line40>\\UHHHHHHHH  Unicode character with hex value HHHHHHHH (8 digits)\n\\n<line41>"), stdout);\n<line42>fputs (_("\\n<line43>%%      a single %\n\\n<line44>%b      ARGUMENT as a string with '\\' escapes interpreted,\n\\n<line45>except that octal escapes are of the form \\0 or \\0NNN\n\\n<line46>%q      ARGUMENT is printed in a format that can be reused as shell input,\n\\n<line47>escaping non-printable characters with the proposed POSIX $'' syntax.\\n<line48>\n\n\\n<line49>and all C format specifications ending with one of diouxXfeEgGcs, with\n\\n<line50>ARGUMENTs converted to proper type first.  Variable widths are handled.\n\\n<line51>"), stdout);\n<line52>printf (USAGE_BUILTIN_WARNING, PROGRAM_NAME);\n<line53>emit_ancillary_info (PROGRAM_NAME);\n<line54>}\n<line55>exit (status);\n<line56>}
----------------------------------------
Function: verify_numeric
Content: <line0>static void\n<line1>verify_numeric (char const *s, char const *end)\n<line2>{\n<line3>if (errno)\n<line4>{\n<line5>error (0, errno, "%s", quote (s));\n<line6>exit_status = EXIT_FAILURE;\n<line7>}\n<line8>else if (*end)\n<line9>{\n<line10>if (s == end)\n<line11>error (0, 0, _("%s: expected a numeric value"), quote (s));\n<line12>else\n<line13>error (0, 0, _("%s: value not completely converted"), quote (s));\n<line14>exit_status = EXIT_FAILURE;\n<line15>}\n<line16>}
----------------------------------------
Function: print_esc_char
Content: <line0>static void\n<line1>print_esc_char (char c)\n<line2>{\n<line3>switch (c)\n<line4>{\n<line5>case 'a':			/* Alert. */\n<line6>putchar ('\a');\n<line7>break;\n<line8>case 'b':			/* Backspace. */\n<line9>putchar ('\b');\n<line10>break;\n<line11>case 'c':			/* Cancel the rest of the output. */\n<line12>exit (EXIT_SUCCESS);\n<line13>break;\n<line14>case 'e':			/* Escape. */\n<line15>putchar ('\x1B');\n<line16>break;\n<line17>case 'f':			/* Form feed. */\n<line18>putchar ('\f');\n<line19>break;\n<line20>case 'n':			/* New line. */\n<line21>putchar ('\n');\n<line22>break;\n<line23>case 'r':			/* Carriage return. */\n<line24>putchar ('\r');\n<line25>break;\n<line26>case 't':			/* Horizontal tab. */\n<line27>putchar ('\t');\n<line28>break;\n<line29>case 'v':			/* Vertical tab. */\n<line30>putchar ('\v');\n<line31>break;\n<line32>default:\n<line33>putchar (c);\n<line34>break;\n<line35>}\n<line36>}
----------------------------------------
Function: print_esc
Content: <line0>static int\n<line1>print_esc (char const *escstart, bool octal_0)\n<line2>{\n<line3>char const *p = escstart + 1;\n<line4>int esc_value = 0;		/* Value of \nnn escape. */\n<line5>int esc_length;		/* Length of \nnn escape. */\n<line6>if (*p == 'x')\n<line7>{\n<line8>/* A hexadecimal \xhh escape sequence must have 1 or 2 hex. digits.  */\n<line9>for (esc_length = 0, ++p;\n<line10>esc_length < 2 && isxdigit (to_uchar (*p));\n<line11>++esc_length, ++p)\n<line12>esc_value = esc_value * 16 + hextobin (*p);\n<line13>if (esc_length == 0)\n<line14>error (EXIT_FAILURE, 0, _("missing hexadecimal number in escape"));\n<line15>putchar (esc_value);\n<line16>}\n<line17>else if (isodigit (*p))\n<line18>{\n<line19>/* Parse \0ooo (if octal_0 && *p == '0') or \ooo (otherwise).\n<line20>Allow \ooo if octal_0 && *p != '0'; this is an undocumented\n<line21>extension to POSIX that is compatible with Bash 2.05b.  */\n<line22>for (esc_length = 0, p += octal_0 && *p == '0';\n<line23>esc_length < 3 && isodigit (*p);\n<line24>++esc_length, ++p)\n<line25>esc_value = esc_value * 8 + octtobin (*p);\n<line26>putchar (esc_value);\n<line27>}\n<line28>else if (*p && strchr ("\"\\abcefnrtv", *p))\n<line29>print_esc_char (*p++);\n<line30>else if (*p == 'u' || *p == 'U')\n<line31>{\n<line32>char esc_char = *p;\n<line33>unsigned int uni_value;\n<line34>uni_value = 0;\n<line35>for (esc_length = (esc_char == 'u' ? 4 : 8), ++p;\n<line36>esc_length > 0;\n<line37>--esc_length, ++p)\n<line38>{\n<line39>if (! isxdigit (to_uchar (*p)))\n<line40>error (EXIT_FAILURE, 0, _("missing hexadecimal number in escape"));\n<line41>uni_value = uni_value * 16 + hextobin (*p);\n<line42>}\n<line43>/* Error for invalid code points 0000D800 through 0000DFFF inclusive.\n<line44>Note print_unicode_char() would print the literal \u.. in this case. */\n<line45>if (uni_value >= 0xd800 && uni_value <= 0xdfff)\n<line46>error (EXIT_FAILURE, 0, _("invalid universal character name \\%c%0*x"),\n<line47>esc_char, (esc_char == 'u' ? 4 : 8), uni_value);\n<line48>print_unicode_char (stdout, uni_value, 0);\n<line49>}\n<line50>else\n<line51>{\n<line52>putchar ('\\');\n<line53>if (*p)\n<line54>{\n<line55>putchar (*p);\n<line56>p++;\n<line57>}\n<line58>}\n<line59>return p - escstart - 1;\n<line60>}
----------------------------------------
Function: print_esc_string
Content: <line0>static void\n<line1>print_esc_string (char const *str)\n<line2>{\n<line3>for (; *str; str++)\n<line4>if (*str == '\\')\n<line5>str += print_esc (str, true);\n<line6>else\n<line7>putchar (*str);\n<line8>}
----------------------------------------
Function: print_direc
Content: <line0>static void\n<line1>print_direc (char const *start, size_t length, char conversion,\n<line2>bool have_field_width, int field_width,\n<line3>bool have_precision, int precision,\n<line4>char const *argument)\n<line5>{\n<line6>char *p;		/* Null-terminated copy of % directive. */\n<line7>/* Create a null-terminated copy of the % directive, with an\n<line8>intmax_t-wide length modifier substituted for any existing\n<line9>integer length modifier.  */\n<line10>{\n<line11>char *q;\n<line12>char const *length_modifier;\n<line13>size_t length_modifier_len;\n<line14>switch (conversion)\n<line15>{\n<line16>case 'd': case 'i': case 'o': case 'u': case 'x': case 'X':\n<line17>length_modifier = PRIdMAX;\n<line18>length_modifier_len = sizeof PRIdMAX - 2;\n<line19>break;\n<line20>case 'a': case 'e': case 'f': case 'g':\n<line21>case 'A': case 'E': case 'F': case 'G':\n<line22>length_modifier = "L";\n<line23>length_modifier_len = 1;\n<line24>break;\n<line25>default:\n<line26>length_modifier = start;  /* Any valid pointer will do.  */\n<line27>length_modifier_len = 0;\n<line28>break;\n<line29>}\n<line30>p = xmalloc (length + length_modifier_len + 2);\n<line31>q = mempcpy (p, start, length);\n<line32>q = mempcpy (q, length_modifier, length_modifier_len);\n<line33>*q++ = conversion;\n<line34>*q = '\0';\n<line35>}\n<line36>switch (conversion)\n<line37>{\n<line38>case 'd':\n<line39>case 'i':\n<line40>{\n<line41>intmax_t arg = vstrtoimax (argument);\n<line42>if (!have_field_width)\n<line43>{\n<line44>if (!have_precision)\n<line45>xprintf (p, arg);\n<line46>else\n<line47>xprintf (p, precision, arg);\n<line48>}\n<line49>else\n<line50>{\n<line51>if (!have_precision)\n<line52>xprintf (p, field_width, arg);\n<line53>else\n<line54>xprintf (p, field_width, precision, arg);\n<line55>}\n<line56>}\n<line57>break;\n<line58>case 'o':\n<line59>case 'u':\n<line60>case 'x':\n<line61>case 'X':\n<line62>{\n<line63>uintmax_t arg = vstrtoumax (argument);\n<line64>if (!have_field_width)\n<line65>{\n<line66>if (!have_precision)\n<line67>xprintf (p, arg);\n<line68>else\n<line69>xprintf (p, precision, arg);\n<line70>}\n<line71>else\n<line72>{\n<line73>if (!have_precision)\n<line74>xprintf (p, field_width, arg);\n<line75>else\n<line76>xprintf (p, field_width, precision, arg);\n<line77>}\n<line78>}\n<line79>break;\n<line80>case 'a':\n<line81>case 'A':\n<line82>case 'e':\n<line83>case 'E':\n<line84>case 'f':\n<line85>case 'F':\n<line86>case 'g':\n<line87>case 'G':\n<line88>{\n<line89>long double arg = vstrtold (argument);\n<line90>if (!have_field_width)\n<line91>{\n<line92>if (!have_precision)\n<line93>xprintf (p, arg);\n<line94>else\n<line95>xprintf (p, precision, arg);\n<line96>}\n<line97>else\n<line98>{\n<line99>if (!have_precision)\n<line100>xprintf (p, field_width, arg);\n<line101>else\n<line102>xprintf (p, field_width, precision, arg);\n<line103>}\n<line104>}\n<line105>break;\n<line106>case 'c':\n<line107>if (!have_field_width)\n<line108>xprintf (p, *argument);\n<line109>else\n<line110>xprintf (p, field_width, *argument);\n<line111>break;\n<line112>case 's':\n<line113>if (!have_field_width)\n<line114>{\n<line115>if (!have_precision)\n<line116>xprintf (p, argument);\n<line117>else\n<line118>xprintf (p, precision, argument);\n<line119>}\n<line120>else\n<line121>{\n<line122>if (!have_precision)\n<line123>xprintf (p, field_width, argument);\n<line124>else\n<line125>xprintf (p, field_width, precision, argument);\n<line126>}\n<line127>break;\n<line128>}\n<line129>free (p);\n<line130>}
----------------------------------------
Function: print_formatted
Content: <line0>static int\n<line1>print_formatted (char const *format, int argc, char **argv)\n<line2>{\n<line3>int save_argc = argc;		/* Preserve original value.  */\n<line4>char const *f;		/* Pointer into 'format'.  */\n<line5>char const *direc_start;	/* Start of % directive.  */\n<line6>size_t direc_length;		/* Length of % directive.  */\n<line7>bool have_field_width;	/* True if FIELD_WIDTH is valid.  */\n<line8>int field_width = 0;		/* Arg to first '*'.  */\n<line9>bool have_precision;		/* True if PRECISION is valid.  */\n<line10>int precision = 0;		/* Arg to second '*'.  */\n<line11>char ok[UCHAR_MAX + 1];	/* ok['x'] is true if %x is allowed.  */\n<line12>for (f = format; *f; ++f)\n<line13>{\n<line14>switch (*f)\n<line15>{\n<line16>case '%':\n<line17>direc_start = f++;\n<line18>direc_length = 1;\n<line19>have_field_width = have_precision = false;\n<line20>if (*f == '%')\n<line21>{\n<line22>putchar ('%');\n<line23>break;\n<line24>}\n<line25>if (*f == 'b')\n<line26>{\n<line27>/* FIXME: Field width and precision are not supported\n<line28>for %b, even though POSIX requires it.  */\n<line29>if (argc > 0)\n<line30>{\n<line31>print_esc_string (*argv);\n<line32>++argv;\n<line33>--argc;\n<line34>}\n<line35>break;\n<line36>}\n<line37>if (*f == 'q')\n<line38>{\n<line39>if (argc > 0)\n<line40>{\n<line41>fputs (quotearg_style (shell_escape_quoting_style, *argv),\n<line42>stdout);\n<line43>++argv;\n<line44>--argc;\n<line45>}\n<line46>break;\n<line47>}\n<line48>memset (ok, 0, sizeof ok);\n<line49>ok['a'] = ok['A'] = ok['c'] = ok['d'] = ok['e'] = ok['E'] =\n<line50>ok['f'] = ok['F'] = ok['g'] = ok['G'] = ok['i'] = ok['o'] =\n<line51>ok['s'] = ok['u'] = ok['x'] = ok['X'] = 1;\n<line52>for (;; f++, direc_length++)\n<line53>switch (*f)\n<line54>{\n<line55>#if (__GLIBC__ == 2 && 2 <= __GLIBC_MINOR__) || 3 <= __GLIBC__\n<line56>case 'I':\n<line57>#endif\n<line58>case '\'':\n<line59>ok['a'] = ok['A'] = ok['c'] = ok['e'] = ok['E'] =\n<line60>ok['o'] = ok['s'] = ok['x'] = ok['X'] = 0;\n<line61>break;\n<line62>case '-': case '+': case ' ':\n<line63>break;\n<line64>case '#':\n<line65>ok['c'] = ok['d'] = ok['i'] = ok['s'] = ok['u'] = 0;\n<line66>break;\n<line67>case '0':\n<line68>ok['c'] = ok['s'] = 0;\n<line69>break;\n<line70>default:\n<line71>goto no_more_flag_characters;\n<line72>}\n<line73>no_more_flag_characters:\n<line74>if (*f == '*')\n<line75>{\n<line76>++f;\n<line77>++direc_length;\n<line78>if (argc > 0)\n<line79>{\n<line80>intmax_t width = vstrtoimax (*argv);\n<line81>if (INT_MIN <= width && width <= INT_MAX)\n<line82>field_width = width;\n<line83>else\n<line84>error (EXIT_FAILURE, 0, _("invalid field width: %s"),\n<line85>quote (*argv));\n<line86>++argv;\n<line87>--argc;\n<line88>}\n<line89>else\n<line90>field_width = 0;\n<line91>have_field_width = true;\n<line92>}\n<line93>else\n<line94>while (ISDIGIT (*f))\n<line95>{\n<line96>++f;\n<line97>++direc_length;\n<line98>}\n<line99>if (*f == '.')\n<line100>{\n<line101>++f;\n<line102>++direc_length;\n<line103>ok['c'] = 0;\n<line104>if (*f == '*')\n<line105>{\n<line106>++f;\n<line107>++direc_length;\n<line108>if (argc > 0)\n<line109>{\n<line110>intmax_t prec = vstrtoimax (*argv);\n<line111>if (prec < 0)\n<line112>{\n<line113>/* A negative precision is taken as if the\n<line114>precision were omitted, so -1 is safe\n<line115>here even if prec < INT_MIN.  */\n<line116>precision = -1;\n<line117>}\n<line118>else if (INT_MAX < prec)\n<line119>error (EXIT_FAILURE, 0, _("invalid precision: %s"),\n<line120>quote (*argv));\n<line121>else\n<line122>precision = prec;\n<line123>++argv;\n<line124>--argc;\n<line125>}\n<line126>else\n<line127>precision = 0;\n<line128>have_precision = true;\n<line129>}\n<line130>else\n<line131>while (ISDIGIT (*f))\n<line132>{\n<line133>++f;\n<line134>++direc_length;\n<line135>}\n<line136>}\n<line137>while (*f == 'l' || *f == 'L' || *f == 'h'\n<line138>|| *f == 'j' || *f == 't' || *f == 'z')\n<line139>++f;\n<line140>{\n<line141>unsigned char conversion = *f;\n<line142>int speclen = MIN (f + 1 - direc_start, INT_MAX);\n<line143>if (! ok[conversion])\n<line144>error (EXIT_FAILURE, 0,\n<line145>_("%.*s: invalid conversion specification"),\n<line146>speclen, direc_start);\n<line147>}\n<line148>print_direc (direc_start, direc_length, *f,\n<line149>have_field_width, field_width,\n<line150>have_precision, precision,\n<line151>(argc <= 0 ? "" : (argc--, *argv++)));\n<line152>break;\n<line153>case '\\':\n<line154>f += print_esc (f, false);\n<line155>break;\n<line156>default:\n<line157>putchar (*f);\n<line158>}\n<line159>}\n<line160>return save_argc - argc;\n<line161>}
----------------------------------------
Function: main
Content: <line0>int\n<line1>main (int argc, char **argv)\n<line2>{\n<line3>char *format;\n<line4>int args_used;\n<line5>initialize_main (&argc, &argv);\n<line6>set_program_name (argv[0]);\n<line7>setlocale (LC_ALL, "");\n<line8>bindtextdomain (PACKAGE, LOCALEDIR);\n<line9>textdomain (PACKAGE);\n<line10>atexit (close_stdout);\n<line11>exit_status = EXIT_SUCCESS;\n<line12>posixly_correct = (getenv ("POSIXLY_CORRECT") != nullptr);\n<line13>/* We directly parse options, rather than use parse_long_options, in\n<line14>order to avoid accepting abbreviations.  */\n<line15>if (argc == 2)\n<line16>{\n<line17>if (STREQ (argv[1], "--help"))\n<line18>usage (EXIT_SUCCESS);\n<line19>if (STREQ (argv[1], "--version"))\n<line20>{\n<line21>version_etc (stdout, PROGRAM_NAME, PACKAGE_NAME, Version, AUTHORS,\n<line22>(char *) nullptr);\n<line23>return EXIT_SUCCESS;\n<line24>}\n<line25>}\n<line26>/* The above handles --help and --version.\n<line27>Since there is no other invocation of getopt, handle '--' here.  */\n<line28>if (1 < argc && STREQ (argv[1], "--"))\n<line29>{\n<line30>--argc;\n<line31>++argv;\n<line32>}\n<line33>if (argc <= 1)\n<line34>{\n<line35>error (0, 0, _("missing operand"));\n<line36>usage (EXIT_FAILURE);\n<line37>}\n<line38>format = argv[1];\n<line39>argc -= 2;\n<line40>argv += 2;\n<line41>do\n<line42>{\n<line43>args_used = print_formatted (format, argc, argv);\n<line44>argc -= args_used;\n<line45>argv += args_used;\n<line46>}\n<line47>while (args_used > 0 && argc > 0);\n<line48>if (argc > 0)\n<line49>error (0, 0,\n<line50>_("warning: ignoring excess arguments, starting with %s"),\n<line51>quote (argv[0]));\n<line52>return exit_status;\n<line53>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/src/ptx.c
========================================
Function: matcher_error
Content: <line0>static void\n<line1>matcher_error (void)\n<line2>{\n<line3>error (EXIT_FAILURE, errno, _("error in regular expression matcher"));\n<line4>}
----------------------------------------
Function: unescape_string
Content: <line0>static void\n<line1>unescape_string (char *string)\n<line2>{\n<line3>char *cursor;			/* cursor in result */\n<line4>int value;			/* value of \nnn escape */\n<line5>int length;			/* length of \nnn escape */\n<line6>cursor = string;\n<line7>while (*string)\n<line8>{\n<line9>if (*string == '\\')\n<line10>{\n<line11>string++;\n<line12>switch (*string)\n<line13>{\n<line14>case 'x':		/* \xhhh escape, 3 chars maximum */\n<line15>value = 0;\n<line16>for (length = 0, string++;\n<line17>length < 3 && isxdigit (to_uchar (*string));\n<line18>length++, string++)\n<line19>value = value * 16 + HEXTOBIN (*string);\n<line20>if (length == 0)\n<line21>{\n<line22>*cursor++ = '\\';\n<line23>*cursor++ = 'x';\n<line24>}\n<line25>else\n<line26>*cursor++ = value;\n<line27>break;\n<line28>case '0':		/* \0ooo escape, 3 chars maximum */\n<line29>value = 0;\n<line30>for (length = 0, string++;\n<line31>length < 3 && ISODIGIT (*string);\n<line32>length++, string++)\n<line33>value = value * 8 + OCTTOBIN (*string);\n<line34>*cursor++ = value;\n<line35>break;\n<line36>case 'a':		/* alert */\n<line37>#if __STDC__\n<line38>*cursor++ = '\a';\n<line39>#else\n<line40>*cursor++ = 7;\n<line41>#endif\n<line42>string++;\n<line43>break;\n<line44>case 'b':		/* backspace */\n<line45>*cursor++ = '\b';\n<line46>string++;\n<line47>break;\n<line48>case 'c':		/* cancel the rest of the output */\n<line49>while (*string)\n<line50>string++;\n<line51>break;\n<line52>case 'f':		/* form feed */\n<line53>*cursor++ = '\f';\n<line54>string++;\n<line55>break;\n<line56>case 'n':		/* new line */\n<line57>*cursor++ = '\n';\n<line58>string++;\n<line59>break;\n<line60>case 'r':		/* carriage return */\n<line61>*cursor++ = '\r';\n<line62>string++;\n<line63>break;\n<line64>case 't':		/* horizontal tab */\n<line65>*cursor++ = '\t';\n<line66>string++;\n<line67>break;\n<line68>case 'v':		/* vertical tab */\n<line69>#if __STDC__\n<line70>*cursor++ = '\v';\n<line71>#else\n<line72>*cursor++ = 11;\n<line73>#endif\n<line74>string++;\n<line75>break;\n<line76>case '\0':		/* lone backslash at end of string */\n<line77>/* ignore it */\n<line78>break;\n<line79>default:\n<line80>*cursor++ = '\\';\n<line81>*cursor++ = *string++;\n<line82>break;\n<line83>}\n<line84>}\n<line85>else\n<line86>*cursor++ = *string++;\n<line87>}\n<line88>*cursor = '\0';\n<line89>}
----------------------------------------
Function: compile_regex
Content: <line0>static void\n<line1>compile_regex (struct regex_data *regex)\n<line2>{\n<line3>struct re_pattern_buffer *pattern = &regex->pattern;\n<line4>char const *string = regex->string;\n<line5>char const *message;\n<line6>pattern->buffer = nullptr;\n<line7>pattern->allocated = 0;\n<line8>pattern->fastmap = regex->fastmap;\n<line9>pattern->translate = ignore_case ? folded_chars : nullptr;\n<line10>message = re_compile_pattern (string, strlen (string), pattern);\n<line11>if (message)\n<line12>error (EXIT_FAILURE, 0, _("%s (for regexp %s)"), message, quote (string));\n<line13>/* The fastmap should be compiled before 're_match'.  The following\n<line14>call is not mandatory, because 're_search' is always called sooner,\n<line15>and it compiles the fastmap if this has not been done yet.  */\n<line16>re_compile_fastmap (pattern);\n<line17>}
----------------------------------------
Function: initialize_regex
Content: <line0>static void\n<line1>initialize_regex (void)\n<line2>{\n<line3>int character;		/* character value */\n<line4>/* Initialize the case folding table.  */\n<line5>if (ignore_case)\n<line6>for (character = 0; character < CHAR_SET_SIZE; character++)\n<line7>folded_chars[character] = toupper (character);\n<line8>/* Unless the user already provided a description of the end of line or\n<line9>end of sentence sequence, select an end of line sequence to compile.\n<line10>If the user provided an empty definition, thus disabling end of line\n<line11>or sentence feature, make it null to speed up tests.  If GNU\n<line12>extensions are enabled, use end of sentence like in GNU emacs.  If\n<line13>disabled, use end of lines.  */\n<line14>if (context_regex.string)\n<line15>{\n<line16>if (!*context_regex.string)\n<line17>context_regex.string = nullptr;\n<line18>}\n<line19>else if (gnu_extensions && !input_reference)\n<line20>context_regex.string = "[.?!][]\"')}]*\\($\\|\t\\|  \\)[ \t\n]*";\n<line21>else\n<line22>context_regex.string = "\n";\n<line23>if (context_regex.string)\n<line24>compile_regex (&context_regex);\n<line25>/* If the user has already provided a non-empty regexp to describe\n<line26>words, compile it.  Else, unless this has already been done through\n<line27>a user provided Break character file, construct a fastmap of\n<line28>characters that may appear in a word.  If GNU extensions enabled,\n<line29>include only letters of the underlying character set.  If disabled,\n<line30>include almost everything, even punctuation; stop only on white\n<line31>space.  */\n<line32>if (word_regex.string)\n<line33>compile_regex (&word_regex);\n<line34>else if (!break_file)\n<line35>{\n<line36>if (gnu_extensions)\n<line37>{\n<line38>/* Simulate \w+.  */\n<line39>for (character = 0; character < CHAR_SET_SIZE; character++)\n<line40>word_fastmap[character] = !! isalpha (character);\n<line41>}\n<line42>else\n<line43>{\n<line44>/* Simulate [^ \t\n]+.  */\n<line45>memset (word_fastmap, 1, CHAR_SET_SIZE);\n<line46>word_fastmap[' '] = 0;\n<line47>word_fastmap['\t'] = 0;\n<line48>word_fastmap['\n'] = 0;\n<line49>}\n<line50>}\n<line51>}
----------------------------------------
Function: swallow_file_in_memory
Content: <line0>static void\n<line1>swallow_file_in_memory (char const *file_name, BLOCK *block)\n<line2>{\n<line3>size_t used_length;		/* used length in memory buffer */\n<line4>/* As special cases, a file name which is null or "-" indicates standard\n<line5>input, which is already opened.  In all other cases, open the file from\n<line6>its name.  */\n<line7>bool using_stdin = !file_name || !*file_name || STREQ (file_name, "-");\n<line8>if (using_stdin)\n<line9>block->start = fread_file (stdin, 0, &used_length);\n<line10>else\n<line11>block->start = read_file (file_name, 0, &used_length);\n<line12>if (!block->start)\n<line13>error (EXIT_FAILURE, errno, "%s", quotef (using_stdin ? "-" : file_name));\n<line14>if (using_stdin)\n<line15>clearerr (stdin);\n<line16>block->end = block->start + used_length;\n<line17>}
----------------------------------------
Function: compare_words
Content: <line0>static int\n<line1>compare_words (const void *void_first, const void *void_second)\n<line2>{\n<line3>#define first ((const WORD *) void_first)\n<line4>#define second ((const WORD *) void_second)\n<line5>ptrdiff_t length;		/* minimum of two lengths */\n<line6>ptrdiff_t counter;		/* cursor in words */\n<line7>int value;			/* value of comparison */\n<line8>length = first->size < second->size ? first->size : second->size;\n<line9>if (ignore_case)\n<line10>{\n<line11>for (counter = 0; counter < length; counter++)\n<line12>{\n<line13>value = (folded_chars [to_uchar (first->start[counter])]\n<line14>- folded_chars [to_uchar (second->start[counter])]);\n<line15>if (value != 0)\n<line16>return value;\n<line17>}\n<line18>}\n<line19>else\n<line20>{\n<line21>for (counter = 0; counter < length; counter++)\n<line22>{\n<line23>value = (to_uchar (first->start[counter])\n<line24>- to_uchar (second->start[counter]));\n<line25>if (value != 0)\n<line26>return value;\n<line27>}\n<line28>}\n<line29>return (first->size > second->size) - (first->size < second->size);\n<line30>#undef first\n<line31>#undef second\n<line32>}
----------------------------------------
Function: compare_occurs
Content: <line0>static int\n<line1>compare_occurs (const void *void_first, const void *void_second)\n<line2>{\n<line3>#define first ((const OCCURS *) void_first)\n<line4>#define second ((const OCCURS *) void_second)\n<line5>int value;\n<line6>value = compare_words (&first->key, &second->key);\n<line7>return (value ? value\n<line8>: ((first->key.start > second->key.start)\n<line9>- (first->key.start < second->key.start)));\n<line10>#undef first\n<line11>#undef second\n<line12>}
----------------------------------------
Function: sort_found_occurs
Content: <line0>static void\n<line1>sort_found_occurs (void)\n<line2>{\n<line3>/* Only one language for the time being.  */\n<line4>if (number_of_occurs[0])\n<line5>qsort (occurs_table[0], number_of_occurs[0], sizeof **occurs_table,\n<line6>compare_occurs);\n<line7>}
----------------------------------------
Function: digest_break_file
Content: <line0>static void\n<line1>digest_break_file (char const *file_name)\n<line2>{\n<line3>BLOCK file_contents;		/* to receive a copy of the file */\n<line4>char *cursor;			/* cursor in file copy */\n<line5>swallow_file_in_memory (file_name, &file_contents);\n<line6>/* Make the fastmap and record the file contents in it.  */\n<line7>memset (word_fastmap, 1, CHAR_SET_SIZE);\n<line8>for (cursor = file_contents.start; cursor < file_contents.end; cursor++)\n<line9>word_fastmap[to_uchar (*cursor)] = 0;\n<line10>if (!gnu_extensions)\n<line11>{\n<line12>/* If GNU extensions are enabled, the only way to avoid newline as\n<line13>a break character is to write all the break characters in the\n<line14>file with no newline at all, not even at the end of the file.\n<line15>If disabled, spaces, tabs and newlines are always considered as\n<line16>break characters even if not included in the break file.  */\n<line17>word_fastmap[' '] = 0;\n<line18>word_fastmap['\t'] = 0;\n<line19>word_fastmap['\n'] = 0;\n<line20>}\n<line21>/* Return the space of the file, which is no more required.  */\n<line22>free (file_contents.start);\n<line23>}
----------------------------------------
Function: digest_word_file
Content: <line0>static void\n<line1>digest_word_file (char const *file_name, WORD_TABLE *table)\n<line2>{\n<line3>BLOCK file_contents;		/* to receive a copy of the file */\n<line4>char *cursor;			/* cursor in file copy */\n<line5>char *word_start;		/* start of the current word */\n<line6>swallow_file_in_memory (file_name, &file_contents);\n<line7>table->start = nullptr;\n<line8>table->alloc = 0;\n<line9>table->length = 0;\n<line10>/* Read the whole file.  */\n<line11>cursor = file_contents.start;\n<line12>while (cursor < file_contents.end)\n<line13>{\n<line14>/* Read one line, and save the word in contains.  */\n<line15>word_start = cursor;\n<line16>while (cursor < file_contents.end && *cursor != '\n')\n<line17>cursor++;\n<line18>/* Record the word in table if it is not empty.  */\n<line19>if (cursor > word_start)\n<line20>{\n<line21>if (table->length == table->alloc)\n<line22>table->start = x2nrealloc (table->start, &table->alloc,\n<line23>sizeof *table->start);\n<line24>table->start[table->length].start = word_start;\n<line25>table->start[table->length].size = cursor - word_start;\n<line26>table->length++;\n<line27>}\n<line28>/* This test allows for an incomplete line at end of file.  */\n<line29>if (cursor < file_contents.end)\n<line30>cursor++;\n<line31>}\n<line32>/* Finally, sort all the words read.  */\n<line33>qsort (table->start, table->length, sizeof table->start[0], compare_words);\n<line34>}
----------------------------------------
Function: find_occurs_in_text
Content: <line0>static void\n<line1>find_occurs_in_text (int file_index)\n<line2>{\n<line3>char *cursor;			/* for scanning the source text */\n<line4>char *scan;			/* for scanning the source text also */\n<line5>char *line_start;		/* start of the current input line */\n<line6>char *line_scan;		/* newlines scanned until this point */\n<line7>ptrdiff_t reference_length;	/* length of reference in input mode */\n<line8>WORD possible_key;		/* possible key, to ease searches */\n<line9>OCCURS *occurs_cursor;	/* current OCCURS under construction */\n<line10>char *context_start;		/* start of left context */\n<line11>char *context_end;		/* end of right context */\n<line12>char *word_start;		/* start of word */\n<line13>char *word_end;		/* end of word */\n<line14>char *next_context_start;	/* next start of left context */\n<line15>const BLOCK *text_buffer = &text_buffers[file_index];\n<line16>/* reference_length is always used within 'if (input_reference)'.\n<line17>However, GNU C diagnoses that it may be used uninitialized.  The\n<line18>following assignment is merely to shut it up.  */\n<line19>reference_length = 0;\n<line20>/* Tracking where lines start is helpful for reference processing.  In\n<line21>auto reference mode, this allows counting lines.  In input reference\n<line22>mode, this permits finding the beginning of the references.\n<line23>The first line begins with the file, skip immediately this very first\n<line24>reference in input reference mode, to help further rejection any word\n<line25>found inside it.  Also, unconditionally assigning these variable has\n<line26>the happy effect of shutting up lint.  */\n<line27>line_start = text_buffer->start;\n<line28>line_scan = line_start;\n<line29>if (input_reference)\n<line30>{\n<line31>SKIP_NON_WHITE (line_scan, text_buffer->end);\n<line32>reference_length = line_scan - line_start;\n<line33>SKIP_WHITE (line_scan, text_buffer->end);\n<line34>}\n<line35>/* Process the whole buffer, one line or one sentence at a time.  */\n<line36>for (cursor = text_buffer->start;\n<line37>cursor < text_buffer->end;\n<line38>cursor = next_context_start)\n<line39>{\n<line40>/* 'context_start' gets initialized before the processing of each\n<line41>line, or once for the whole buffer if no end of line or sentence\n<line42>sequence separator.  */\n<line43>context_start = cursor;\n<line44>/* If an end of line or end of sentence sequence is defined and\n<line45>non-empty, 'next_context_start' will be recomputed to be the end of\n<line46>each line or sentence, before each one is processed.  If no such\n<line47>sequence, then 'next_context_start' is set at the end of the whole\n<line48>buffer, which is then considered to be a single line or sentence.\n<line49>This test also accounts for the case of an incomplete line or\n<line50>sentence at the end of the buffer.  */\n<line51>next_context_start = text_buffer->end;\n<line52>if (context_regex.string)\n<line53>switch (re_search (&context_regex.pattern, cursor,\n<line54>text_buffer->end - cursor,\n<line55>0, text_buffer->end - cursor, &context_regs))\n<line56>{\n<line57>case -2:\n<line58>matcher_error ();\n<line59>case -1:\n<line60>break;\n<line61>case 0:\n<line62>error (EXIT_FAILURE, 0,\n<line63>_("error: regular expression has a match of length zero:"\n<line64>" %s"),\n<line65>quote (context_regex.string));\n<line66>default:\n<line67>next_context_start = cursor + context_regs.end[0];\n<line68>break;\n<line69>}\n<line70>/* Include the separator into the right context, but not any suffix\n<line71>white space in this separator; this insures it will be seen in\n<line72>output and will not take more space than necessary.  */\n<line73>context_end = next_context_start;\n<line74>SKIP_WHITE_BACKWARDS (context_end, context_start);\n<line75>/* Read and process a single input line or sentence, one word at a\n<line76>time.  */\n<line77>while (true)\n<line78>{\n<line79>if (word_regex.string)\n<line80>/* If a word regexp has been compiled, use it to skip at the\n<line81>beginning of the next word.  If there is no such word, exit\n<line82>the loop.  */\n<line83>{\n<line84>regoff_t r = re_search (&word_regex.pattern, cursor,\n<line85>context_end - cursor,\n<line86>0, context_end - cursor, &word_regs);\n<line87>if (r == -2)\n<line88>matcher_error ();\n<line89>if (r == -1)\n<line90>break;\n<line91>word_start = cursor + word_regs.start[0];\n<line92>word_end = cursor + word_regs.end[0];\n<line93>}\n<line94>else\n<line95>/* Avoid re_search and use the fastmap to skip to the\n<line96>beginning of the next word.  If there is no more word in\n<line97>the buffer, exit the loop.  */\n<line98>{\n<line99>scan = cursor;\n<line100>while (scan < context_end\n<line101>&& !word_fastmap[to_uchar (*scan)])\n<line102>scan++;\n<line103>if (scan == context_end)\n<line104>break;\n<line105>word_start = scan;\n<line106>while (scan < context_end\n<line107>&& word_fastmap[to_uchar (*scan)])\n<line108>scan++;\n<line109>word_end = scan;\n<line110>}\n<line111>/* Skip right to the beginning of the found word.  */\n<line112>cursor = word_start;\n<line113>/* Skip any zero length word.  Just advance a single position,\n<line114>then go fetch the next word.  */\n<line115>if (word_end == word_start)\n<line116>{\n<line117>cursor++;\n<line118>continue;\n<line119>}\n<line120>/* This is a genuine, non empty word, so save it as a possible\n<line121>key.  Then skip over it.  Also, maintain the maximum length of\n<line122>all words read so far.  It is mandatory to take the maximum\n<line123>length of all words in the file, without considering if they\n<line124>are actually kept or rejected, because backward jumps at output\n<line125>generation time may fall in *any* word.  */\n<line126>possible_key.start = cursor;\n<line127>possible_key.size = word_end - word_start;\n<line128>cursor += possible_key.size;\n<line129>if (possible_key.size > maximum_word_length)\n<line130>maximum_word_length = possible_key.size;\n<line131>/* In input reference mode, update 'line_start' from its previous\n<line132>value.  Count the lines just in case auto reference mode is\n<line133>also selected. If it happens that the word just matched is\n<line134>indeed part of a reference; just ignore it.  */\n<line135>if (input_reference)\n<line136>{\n<line137>while (line_scan < possible_key.start)\n<line138>if (*line_scan == '\n')\n<line139>{\n<line140>total_line_count++;\n<line141>line_scan++;\n<line142>line_start = line_scan;\n<line143>SKIP_NON_WHITE (line_scan, text_buffer->end);\n<line144>reference_length = line_scan - line_start;\n<line145>}\n<line146>else\n<line147>line_scan++;\n<line148>if (line_scan > possible_key.start)\n<line149>continue;\n<line150>}\n<line151>/* Ignore the word if an 'Ignore words' table exists and if it is\n<line152>part of it.  Also ignore the word if an 'Only words' table and\n<line153>if it is *not* part of it.\n<line154>It is allowed that both tables be used at once, even if this\n<line155>may look strange for now.  Just ignore a word that would appear\n<line156>in both.  If regexps are eventually implemented for these\n<line157>tables, the Ignore table could then reject words that would\n<line158>have been previously accepted by the Only table.  */\n<line159>if (ignore_file && search_table (&possible_key, &ignore_table))\n<line160>continue;\n<line161>if (only_file && !search_table (&possible_key, &only_table))\n<line162>continue;\n<line163>/* A non-empty word has been found.  First of all, insure\n<line164>proper allocation of the next OCCURS, and make a pointer to\n<line165>where it will be constructed.  */\n<line166>if (number_of_occurs[0] == occurs_alloc[0])\n<line167>occurs_table[0] = x2nrealloc (occurs_table[0],\n<line168>&occurs_alloc[0],\n<line169>sizeof *occurs_table[0]);\n<line170>occurs_cursor = occurs_table[0] + number_of_occurs[0];\n<line171>/* Define the reference field, if any.  */\n<line172>if (auto_reference)\n<line173>{\n<line174>/* While auto referencing, update 'line_start' from its\n<line175>previous value, counting lines as we go.  If input\n<line176>referencing at the same time, 'line_start' has been\n<line177>advanced earlier, and the following loop is never really\n<line178>executed.  */\n<line179>while (line_scan < possible_key.start)\n<line180>if (*line_scan == '\n')\n<line181>{\n<line182>total_line_count++;\n<line183>line_scan++;\n<line184>line_start = line_scan;\n<line185>SKIP_NON_WHITE (line_scan, text_buffer->end);\n<line186>}\n<line187>else\n<line188>line_scan++;\n<line189>occurs_cursor->reference = total_line_count;\n<line190>}\n<line191>else if (input_reference)\n<line192>{\n<line193>/* If only input referencing, 'line_start' has been computed\n<line194>earlier to detect the case the word matched would be part\n<line195>of the reference.  The reference position is simply the\n<line196>value of 'line_start'.  */\n<line197>occurs_cursor->reference = line_start - possible_key.start;\n<line198>if (reference_length > reference_max_width)\n<line199>reference_max_width = reference_length;\n<line200>}\n<line201>/* Exclude the reference from the context in simple cases.  */\n<line202>if (input_reference && line_start == context_start)\n<line203>{\n<line204>SKIP_NON_WHITE (context_start, context_end);\n<line205>SKIP_WHITE (context_start, context_end);\n<line206>}\n<line207>/* Completes the OCCURS structure.  */\n<line208>occurs_cursor->key = possible_key;\n<line209>occurs_cursor->left = context_start - possible_key.start;\n<line210>occurs_cursor->right = context_end - possible_key.start;\n<line211>occurs_cursor->file_index = file_index;\n<line212>number_of_occurs[0]++;\n<line213>}\n<line214>}\n<line215>}
----------------------------------------
Function: print_spaces
Content: <line0>static void\n<line1>print_spaces (ptrdiff_t number)\n<line2>{\n<line3>for (ptrdiff_t counter = number; counter > 0; counter--)\n<line4>putchar (' ');\n<line5>}
----------------------------------------
Function: print_field
Content: <line0>static void\n<line1>print_field (BLOCK field)\n<line2>{\n<line3>char *cursor;			/* Cursor in field to print */\n<line4>/* Whitespace is not really compressed.  Instead, each white space\n<line5>character (tab, vt, ht etc.) is printed as one single space.  */\n<line6>for (cursor = field.start; cursor < field.end; cursor++)\n<line7>{\n<line8>unsigned char character = *cursor;\n<line9>if (edited_flag[character])\n<line10>{\n<line11>/* Handle cases which are specific to 'roff' or TeX.  All\n<line12>white space processing is done as the default case of\n<line13>this switch.  */\n<line14>switch (character)\n<line15>{\n<line16>case '"':\n<line17>/* In roff output format, double any quote.  */\n<line18>putchar ('"');\n<line19>putchar ('"');\n<line20>break;\n<line21>case '$':\n<line22>case '%':\n<line23>case '&':\n<line24>case '#':\n<line25>case '_':\n<line26>/* In TeX output format, precede these with a backslash.  */\n<line27>putchar ('\\');\n<line28>putchar (character);\n<line29>break;\n<line30>case '{':\n<line31>case '}':\n<line32>/* In TeX output format, precede these with a backslash and\n<line33>force mathematical mode.  */\n<line34>printf ("$\\%c$", character);\n<line35>break;\n<line36>case '\\':\n<line37>/* In TeX output mode, request production of a backslash.  */\n<line38>fputs ("\\backslash{}", stdout);\n<line39>break;\n<line40>default:\n<line41>/* Any other flagged character produces a single space.  */\n<line42>putchar (' ');\n<line43>}\n<line44>}\n<line45>else\n<line46>putchar (*cursor);\n<line47>}\n<line48>}
----------------------------------------
Function: fix_output_parameters
Content: <line0>static void\n<line1>fix_output_parameters (void)\n<line2>{\n<line3>size_t file_index;		/* index in text input file arrays */\n<line4>intmax_t line_ordinal;	/* line ordinal value for reference */\n<line5>ptrdiff_t reference_width;	/* width for the whole reference */\n<line6>int character;		/* character ordinal */\n<line7>char const *cursor;		/* cursor in some constant strings */\n<line8>/* In auto reference mode, the maximum width of this field is\n<line9>precomputed and subtracted from the overall line width.  Add one for\n<line10>the column which separate the file name from the line number.  */\n<line11>if (auto_reference)\n<line12>{\n<line13>reference_max_width = 0;\n<line14>for (file_index = 0; file_index < number_input_files; file_index++)\n<line15>{\n<line16>line_ordinal = file_line_count[file_index] + 1;\n<line17>if (file_index > 0)\n<line18>line_ordinal -= file_line_count[file_index - 1];\n<line19>char ordinal_string[INT_BUFSIZE_BOUND (intmax_t)];\n<line20>reference_width = sprintf (ordinal_string, "%"PRIdMAX, line_ordinal);\n<line21>if (input_file_name[file_index])\n<line22>reference_width += strlen (input_file_name[file_index]);\n<line23>if (reference_width > reference_max_width)\n<line24>reference_max_width = reference_width;\n<line25>}\n<line26>reference_max_width++;\n<line27>reference.start = xmalloc (reference_max_width + 1);\n<line28>}\n<line29>/* If the reference appears to the left of the output line, reserve some\n<line30>space for it right away, including one gap size.  */\n<line31>if ((auto_reference || input_reference) && !right_reference)\n<line32>line_width -= reference_max_width + gap_size;\n<line33>if (line_width < 0)\n<line34>line_width = 0;\n<line35>/* The output lines, minimally, will contain from left to right a left\n<line36>context, a gap, and a keyword followed by the right context with no\n<line37>special intervening gap.  Half of the line width is dedicated to the\n<line38>left context and the gap, the other half is dedicated to the keyword\n<line39>and the right context; these values are computed once and for all here.\n<line40>There also are tail and head wrap around fields, used when the keyword\n<line41>is near the beginning or the end of the line, or when some long word\n<line42>cannot fit in, but leave place from wrapped around shorter words.  The\n<line43>maximum width of these fields are recomputed separately for each line,\n<line44>on a case by case basis.  It is worth noting that it cannot happen that\n<line45>both the tail and head fields are used at once.  */\n<line46>half_line_width = line_width / 2;\n<line47>before_max_width = half_line_width - gap_size;\n<line48>keyafter_max_width = half_line_width;\n<line49>/* If truncation_string is the empty string, make it null to speed up\n<line50>tests.  In this case, truncation_string_length will never get used, so\n<line51>there is no need to set it.  */\n<line52>if (truncation_string && *truncation_string)\n<line53>truncation_string_length = strlen (truncation_string);\n<line54>else\n<line55>truncation_string = nullptr;\n<line56>if (gnu_extensions)\n<line57>{\n<line58>/* When flagging truncation at the left of the keyword, the\n<line59>truncation mark goes at the beginning of the before field,\n<line60>unless there is a head field, in which case the mark goes at the\n<line61>left of the head field.  When flagging truncation at the right\n<line62>of the keyword, the mark goes at the end of the keyafter field,\n<line63>unless there is a tail field, in which case the mark goes at the\n<line64>end of the tail field.  Only eight combination cases could arise\n<line65>for truncation marks:\n<line66>. None.\n<line67>. One beginning the before field.\n<line68>. One beginning the head field.\n<line69>. One ending the keyafter field.\n<line70>. One ending the tail field.\n<line71>. One beginning the before field, another ending the keyafter field.\n<line72>. One ending the tail field, another beginning the before field.\n<line73>. One ending the keyafter field, another beginning the head field.\n<line74>So, there is at most two truncation marks, which could appear both\n<line75>on the left side of the center of the output line, both on the\n<line76>right side, or one on either side.  */\n<line77>before_max_width -= 2 * truncation_string_length;\n<line78>if (before_max_width < 0)\n<line79>before_max_width = 0;\n<line80>keyafter_max_width -= 2 * truncation_string_length;\n<line81>}\n<line82>else\n<line83>{\n<line84>/* I never figured out exactly how UNIX' ptx plans the output width\n<line85>of its various fields.  If GNU extensions are disabled, do not\n<line86>try computing the field widths correctly; instead, use the\n<line87>following formula, which does not completely imitate UNIX' ptx,\n<line88>but almost.  */\n<line89>keyafter_max_width -= 2 * truncation_string_length + 1;\n<line90>}\n<line91>/* Compute which characters need special output processing.  Initialize\n<line92>by flagging any white space character.  Some systems do not consider\n<line93>form feed as a space character, but we do.  */\n<line94>for (character = 0; character < CHAR_SET_SIZE; character++)\n<line95>edited_flag[character] = !! isspace (character);\n<line96>edited_flag['\f'] = 1;\n<line97>/* Complete the special character flagging according to selected output\n<line98>format.  */\n<line99>switch (output_format)\n<line100>{\n<line101>case UNKNOWN_FORMAT:\n<line102>/* Should never happen.  */\n<line103>case DUMB_FORMAT:\n<line104>break;\n<line105>case ROFF_FORMAT:\n<line106>/* 'Quote' characters should be doubled.  */\n<line107>edited_flag['"'] = 1;\n<line108>break;\n<line109>case TEX_FORMAT:\n<line110>/* Various characters need special processing.  */\n<line111>for (cursor = "$%&#_{}\\"; *cursor; cursor++)\n<line112>edited_flag[to_uchar (*cursor)] = 1;\n<line113>break;\n<line114>}\n<line115>}
----------------------------------------
Function: define_all_fields
Content: <line0>static void\n<line1>define_all_fields (OCCURS *occurs)\n<line2>{\n<line3>ptrdiff_t tail_max_width;	/* allowable width of tail field */\n<line4>ptrdiff_t head_max_width;	/* allowable width of head field */\n<line5>char *cursor;			/* running cursor in source text */\n<line6>char *left_context_start;	/* start of left context */\n<line7>char *right_context_end;	/* end of right context */\n<line8>char *left_field_start;	/* conservative start for 'head'/'before' */\n<line9>char const *file_name;	/* file name for reference */\n<line10>intmax_t line_ordinal;	/* line ordinal for reference */\n<line11>char const *buffer_start;	/* start of buffered file for this occurs */\n<line12>char const *buffer_end;	/* end of buffered file for this occurs */\n<line13>/* Define 'keyafter', start of left context and end of right context.\n<line14>'keyafter' starts at the saved position for keyword and extend to the\n<line15>right from the end of the keyword, eating separators or full words, but\n<line16>not beyond maximum allowed width for 'keyafter' field or limit for the\n<line17>right context.  Suffix spaces will be removed afterwards.  */\n<line18>keyafter.start = occurs->key.start;\n<line19>keyafter.end = keyafter.start + occurs->key.size;\n<line20>left_context_start = keyafter.start + occurs->left;\n<line21>right_context_end = keyafter.start + occurs->right;\n<line22>buffer_start = text_buffers[occurs->file_index].start;\n<line23>buffer_end = text_buffers[occurs->file_index].end;\n<line24>cursor = keyafter.end;\n<line25>while (cursor < right_context_end\n<line26>&& cursor <= keyafter.start + keyafter_max_width)\n<line27>{\n<line28>keyafter.end = cursor;\n<line29>SKIP_SOMETHING (cursor, right_context_end);\n<line30>}\n<line31>if (cursor <= keyafter.start + keyafter_max_width)\n<line32>keyafter.end = cursor;\n<line33>keyafter_truncation = truncation_string && keyafter.end < right_context_end;\n<line34>SKIP_WHITE_BACKWARDS (keyafter.end, keyafter.start);\n<line35>/* When the left context is wide, it might take some time to catch up from\n<line36>the left context boundary to the beginning of the 'head' or 'before'\n<line37>fields.  So, in this case, to speed the catchup, we jump back from the\n<line38>keyword, using some secure distance, possibly falling in the middle of\n<line39>a word.  A secure backward jump would be at least half the maximum\n<line40>width of a line, plus the size of the longest word met in the whole\n<line41>input.  We conclude this backward jump by a skip forward of at least\n<line42>one word.  In this manner, we should not inadvertently accept only part\n<line43>of a word.  From the reached point, when it will be time to fix the\n<line44>beginning of 'head' or 'before' fields, we will skip forward words or\n<line45>delimiters until we get sufficiently near.  */\n<line46>if (-occurs->left > half_line_width + maximum_word_length)\n<line47>{\n<line48>left_field_start\n<line49>= keyafter.start - (half_line_width + maximum_word_length);\n<line50>SKIP_SOMETHING (left_field_start, keyafter.start);\n<line51>}\n<line52>else\n<line53>left_field_start = keyafter.start + occurs->left;\n<line54>/* 'before' certainly ends at the keyword, but not including separating\n<line55>spaces.  It starts after than the saved value for the left context, by\n<line56>advancing it until it falls inside the maximum allowed width for the\n<line57>before field.  There will be no prefix spaces either.  'before' only\n<line58>advances by skipping single separators or whole words. */\n<line59>before.start = left_field_start;\n<line60>before.end = keyafter.start;\n<line61>SKIP_WHITE_BACKWARDS (before.end, before.start);\n<line62>while (before.start + before_max_width < before.end)\n<line63>SKIP_SOMETHING (before.start, before.end);\n<line64>if (truncation_string)\n<line65>{\n<line66>cursor = before.start;\n<line67>SKIP_WHITE_BACKWARDS (cursor, buffer_start);\n<line68>before_truncation = cursor > left_context_start;\n<line69>}\n<line70>else\n<line71>before_truncation = false;\n<line72>SKIP_WHITE (before.start, buffer_end);\n<line73>/* The tail could not take more columns than what has been left in the\n<line74>left context field, and a gap is mandatory.  It starts after the\n<line75>right context, and does not contain prefixed spaces.  It ends at\n<line76>the end of line, the end of buffer or when the tail field is full,\n<line77>whichever comes first.  It cannot contain only part of a word, and\n<line78>has no suffixed spaces.  */\n<line79>tail_max_width\n<line80>= before_max_width - (before.end - before.start) - gap_size;\n<line81>if (tail_max_width > 0)\n<line82>{\n<line83>tail.start = keyafter.end;\n<line84>SKIP_WHITE (tail.start, buffer_end);\n<line85>tail.end = tail.start;\n<line86>cursor = tail.end;\n<line87>while (cursor < right_context_end\n<line88>&& cursor < tail.start + tail_max_width)\n<line89>{\n<line90>tail.end = cursor;\n<line91>SKIP_SOMETHING (cursor, right_context_end);\n<line92>}\n<line93>if (cursor < tail.start + tail_max_width)\n<line94>tail.end = cursor;\n<line95>if (tail.end > tail.start)\n<line96>{\n<line97>keyafter_truncation = false;\n<line98>tail_truncation = truncation_string && tail.end < right_context_end;\n<line99>}\n<line100>else\n<line101>tail_truncation = false;\n<line102>SKIP_WHITE_BACKWARDS (tail.end, tail.start);\n<line103>}\n<line104>else\n<line105>{\n<line106>/* No place left for a tail field.  */\n<line107>tail.start = nullptr;\n<line108>tail.end = nullptr;\n<line109>tail_truncation = false;\n<line110>}\n<line111>/* 'head' could not take more columns than what has been left in the right\n<line112>context field, and a gap is mandatory.  It ends before the left\n<line113>context, and does not contain suffixed spaces.  Its pointer is advanced\n<line114>until the head field has shrunk to its allowed width.  It cannot\n<line115>contain only part of a word, and has no suffixed spaces.  */\n<line116>head_max_width\n<line117>= keyafter_max_width - (keyafter.end - keyafter.start) - gap_size;\n<line118>if (head_max_width > 0)\n<line119>{\n<line120>head.end = before.start;\n<line121>SKIP_WHITE_BACKWARDS (head.end, buffer_start);\n<line122>head.start = left_field_start;\n<line123>while (head.start + head_max_width < head.end)\n<line124>SKIP_SOMETHING (head.start, head.end);\n<line125>if (head.end > head.start)\n<line126>{\n<line127>before_truncation = false;\n<line128>head_truncation = (truncation_string\n<line129>&& head.start > left_context_start);\n<line130>}\n<line131>else\n<line132>head_truncation = false;\n<line133>SKIP_WHITE (head.start, head.end);\n<line134>}\n<line135>else\n<line136>{\n<line137>/* No place left for a head field.  */\n<line138>head.start = nullptr;\n<line139>head.end = nullptr;\n<line140>head_truncation = false;\n<line141>}\n<line142>if (auto_reference)\n<line143>{\n<line144>/* Construct the reference text in preallocated space from the file\n<line145>name and the line number.  Standard input yields an empty file name.\n<line146>Ensure line numbers are 1 based, even if they are computed 0 based.  */\n<line147>file_name = input_file_name[occurs->file_index];\n<line148>if (!file_name)\n<line149>file_name = "";\n<line150>line_ordinal = occurs->reference + 1;\n<line151>if (occurs->file_index > 0)\n<line152>line_ordinal -= file_line_count[occurs->file_index - 1];\n<line153>char *file_end = stpcpy (reference.start, file_name);\n<line154>reference.end = file_end + sprintf (file_end, ":%"PRIdMAX, line_ordinal);\n<line155>}\n<line156>else if (input_reference)\n<line157>{\n<line158>/* Reference starts at saved position for reference and extends right\n<line159>until some white space is met.  */\n<line160>reference.start = keyafter.start + occurs->reference;\n<line161>reference.end = reference.start;\n<line162>SKIP_NON_WHITE (reference.end, right_context_end);\n<line163>}\n<line164>}
----------------------------------------
Function: output_one_roff_line
Content: <line0>static void\n<line1>output_one_roff_line (void)\n<line2>{\n<line3>/* Output the 'tail' field.  */\n<line4>printf (".%s \"", macro_name);\n<line5>print_field (tail);\n<line6>if (tail_truncation)\n<line7>fputs (truncation_string, stdout);\n<line8>putchar ('"');\n<line9>/* Output the 'before' field.  */\n<line10>fputs (" \"", stdout);\n<line11>if (before_truncation)\n<line12>fputs (truncation_string, stdout);\n<line13>print_field (before);\n<line14>putchar ('"');\n<line15>/* Output the 'keyafter' field.  */\n<line16>fputs (" \"", stdout);\n<line17>print_field (keyafter);\n<line18>if (keyafter_truncation)\n<line19>fputs (truncation_string, stdout);\n<line20>putchar ('"');\n<line21>/* Output the 'head' field.  */\n<line22>fputs (" \"", stdout);\n<line23>if (head_truncation)\n<line24>fputs (truncation_string, stdout);\n<line25>print_field (head);\n<line26>putchar ('"');\n<line27>/* Conditionally output the 'reference' field.  */\n<line28>if (auto_reference || input_reference)\n<line29>{\n<line30>fputs (" \"", stdout);\n<line31>print_field (reference);\n<line32>putchar ('"');\n<line33>}\n<line34>putchar ('\n');\n<line35>}
----------------------------------------
Function: output_one_tex_line
Content: <line0>static void\n<line1>output_one_tex_line (void)\n<line2>{\n<line3>BLOCK key;			/* key field, isolated */\n<line4>BLOCK after;			/* after field, isolated */\n<line5>char *cursor;			/* running cursor in source text */\n<line6>printf ("\\%s ", macro_name);\n<line7>putchar ('{');\n<line8>print_field (tail);\n<line9>fputs ("}{", stdout);\n<line10>print_field (before);\n<line11>fputs ("}{", stdout);\n<line12>key.start = keyafter.start;\n<line13>after.end = keyafter.end;\n<line14>cursor = keyafter.start;\n<line15>SKIP_SOMETHING (cursor, keyafter.end);\n<line16>key.end = cursor;\n<line17>after.start = cursor;\n<line18>print_field (key);\n<line19>fputs ("}{", stdout);\n<line20>print_field (after);\n<line21>fputs ("}{", stdout);\n<line22>print_field (head);\n<line23>putchar ('}');\n<line24>if (auto_reference || input_reference)\n<line25>{\n<line26>putchar ('{');\n<line27>print_field (reference);\n<line28>putchar ('}');\n<line29>}\n<line30>putchar ('\n');\n<line31>}
----------------------------------------
Function: output_one_dumb_line
Content: <line0>static void\n<line1>output_one_dumb_line (void)\n<line2>{\n<line3>if (!right_reference)\n<line4>{\n<line5>if (auto_reference)\n<line6>{\n<line7>/* Output the 'reference' field, in such a way that GNU emacs\n<line8>next-error will handle it.  The ending colon is taken from the\n<line9>gap which follows.  */\n<line10>print_field (reference);\n<line11>putchar (':');\n<line12>print_spaces (reference_max_width\n<line13>+ gap_size\n<line14>- (reference.end - reference.start)\n<line15>- 1);\n<line16>}\n<line17>else\n<line18>{\n<line19>/* Output the 'reference' field and its following gap.  */\n<line20>print_field (reference);\n<line21>print_spaces (reference_max_width\n<line22>+ gap_size\n<line23>- (reference.end - reference.start));\n<line24>}\n<line25>}\n<line26>if (tail.start < tail.end)\n<line27>{\n<line28>/* Output the 'tail' field.  */\n<line29>print_field (tail);\n<line30>if (tail_truncation)\n<line31>fputs (truncation_string, stdout);\n<line32>print_spaces (half_line_width - gap_size\n<line33>- (before.end - before.start)\n<line34>- (before_truncation ? truncation_string_length : 0)\n<line35>- (tail.end - tail.start)\n<line36>- (tail_truncation ? truncation_string_length : 0));\n<line37>}\n<line38>else\n<line39>print_spaces (half_line_width - gap_size\n<line40>- (before.end - before.start)\n<line41>- (before_truncation ? truncation_string_length : 0));\n<line42>/* Output the 'before' field.  */\n<line43>if (before_truncation)\n<line44>fputs (truncation_string, stdout);\n<line45>print_field (before);\n<line46>print_spaces (gap_size);\n<line47>/* Output the 'keyafter' field.  */\n<line48>print_field (keyafter);\n<line49>if (keyafter_truncation)\n<line50>fputs (truncation_string, stdout);\n<line51>if (head.start < head.end)\n<line52>{\n<line53>/* Output the 'head' field.  */\n<line54>print_spaces (half_line_width\n<line55>- (keyafter.end - keyafter.start)\n<line56>- (keyafter_truncation ? truncation_string_length : 0)\n<line57>- (head.end - head.start)\n<line58>- (head_truncation ? truncation_string_length : 0));\n<line59>if (head_truncation)\n<line60>fputs (truncation_string, stdout);\n<line61>print_field (head);\n<line62>}\n<line63>else\n<line64>if ((auto_reference || input_reference) && right_reference)\n<line65>print_spaces (half_line_width\n<line66>- (keyafter.end - keyafter.start)\n<line67>- (keyafter_truncation ? truncation_string_length : 0));\n<line68>if ((auto_reference || input_reference) && right_reference)\n<line69>{\n<line70>/* Output the 'reference' field.  */\n<line71>print_spaces (gap_size);\n<line72>print_field (reference);\n<line73>}\n<line74>putchar ('\n');\n<line75>}
----------------------------------------
Function: generate_all_output
Content: <line0>static void\n<line1>generate_all_output (void)\n<line2>{\n<line3>ptrdiff_t occurs_index;	/* index of keyword entry being processed */\n<line4>OCCURS *occurs_cursor;	/* current keyword entry being processed */\n<line5>/* The following assignments are useful to provide default values in case\n<line6>line contexts or references are not used, in which case these variables\n<line7>would never be computed.  */\n<line8>tail.start = nullptr;\n<line9>tail.end = nullptr;\n<line10>tail_truncation = false;\n<line11>head.start = nullptr;\n<line12>head.end = nullptr;\n<line13>head_truncation = false;\n<line14>/* Loop over all keyword occurrences.  */\n<line15>occurs_cursor = occurs_table[0];\n<line16>for (occurs_index = 0; occurs_index < number_of_occurs[0]; occurs_index++)\n<line17>{\n<line18>/* Compute the exact size of every field and whenever truncation flags\n<line19>are present or not.  */\n<line20>define_all_fields (occurs_cursor);\n<line21>/* Produce one output line according to selected format.  */\n<line22>switch (output_format)\n<line23>{\n<line24>case UNKNOWN_FORMAT:\n<line25>/* Should never happen.  */\n<line26>case DUMB_FORMAT:\n<line27>output_one_dumb_line ();\n<line28>break;\n<line29>case ROFF_FORMAT:\n<line30>output_one_roff_line ();\n<line31>break;\n<line32>case TEX_FORMAT:\n<line33>output_one_tex_line ();\n<line34>break;\n<line35>}\n<line36>/* Advance the cursor into the occurs table.  */\n<line37>occurs_cursor++;\n<line38>}\n<line39>}
----------------------------------------
Function: usage
Content: <line0>void\n<line1>usage (int status)\n<line2>{\n<line3>if (status != EXIT_SUCCESS)\n<line4>emit_try_help ();\n<line5>else\n<line6>{\n<line7>printf (_("\\n<line8>Usage: %s [OPTION]... [INPUT]...   (without -G)\n\\n<line9>or:  %s -G [OPTION]... [INPUT [OUTPUT]]\n"),\n<line10>program_name, program_name);\n<line11>fputs (_("\\n<line12>Output a permuted index, including context, of the words in the input files.\n\\n<line13>"), stdout);\n<line14>emit_stdin_note ();\n<line15>emit_mandatory_arg_note ();\n<line16>fputs (_("\\n<line17>-A, --auto-reference           output automatically generated references\n\\n<line18>-G, --traditional              behave more like System V 'ptx'\n\\n<line19>"), stdout);\n<line20>fputs (_("\\n<line21>-F, --flag-truncation=STRING   use STRING for flagging line truncations.\n\\n<line22>The default is '/'\n\\n<line23>"), stdout);\n<line24>fputs (_("\\n<line25>-M, --macro-name=STRING        macro name to use instead of 'xx'\n\\n<line26>-O, --format=roff              generate output as roff directives\n\\n<line27>-R, --right-side-refs          put references at right, not counted in -w\n\\n<line28>-S, --sentence-regexp=REGEXP   for end of lines or end of sentences\n\\n<line29>-T, --format=tex               generate output as TeX directives\n\\n<line30>"), stdout);\n<line31>fputs (_("\\n<line32>-W, --word-regexp=REGEXP       use REGEXP to match each keyword\n\\n<line33>-b, --break-file=FILE          word break characters in this FILE\n\\n<line34>-f, --ignore-case              fold lower case to upper case for sorting\n\\n<line35>-g, --gap-size=NUMBER          gap size in columns between output fields\n\\n<line36>-i, --ignore-file=FILE         read ignore word list from FILE\n\\n<line37>-o, --only-file=FILE           read only word list from this FILE\n\\n<line38>"), stdout);\n<line39>fputs (_("\\n<line40>-r, --references               first field of each line is a reference\n\\n<line41>-t, --typeset-mode               - not implemented -\n\\n<line42>-w, --width=NUMBER             output width in columns, reference excluded\n\\n<line43>"), stdout);\n<line44>fputs (HELP_OPTION_DESCRIPTION, stdout);\n<line45>fputs (VERSION_OPTION_DESCRIPTION, stdout);\n<line46>emit_ancillary_info (PROGRAM_NAME);\n<line47>}\n<line48>exit (status);\n<line49>}
----------------------------------------
Function: main
Content: <line0>int\n<line1>main (int argc, char **argv)\n<line2>{\n<line3>int optchar;			/* argument character */\n<line4>int file_index;		/* index in text input file arrays */\n<line5>/* Decode program options.  */\n<line6>initialize_main (&argc, &argv);\n<line7>set_program_name (argv[0]);\n<line8>setlocale (LC_ALL, "");\n<line9>bindtextdomain (PACKAGE, LOCALEDIR);\n<line10>textdomain (PACKAGE);\n<line11>atexit (close_stdout);\n<line12>#if HAVE_SETCHRCLASS\n<line13>setchrclass (nullptr);\n<line14>#endif\n<line15>while (optchar = getopt_long (argc, argv, "AF:GM:ORS:TW:b:i:fg:o:trw:",\n<line16>long_options, nullptr),\n<line17>optchar != EOF)\n<line18>{\n<line19>switch (optchar)\n<line20>{\n<line21>default:\n<line22>usage (EXIT_FAILURE);\n<line23>case 'G':\n<line24>gnu_extensions = false;\n<line25>break;\n<line26>case 'b':\n<line27>break_file = optarg;\n<line28>break;\n<line29>case 'f':\n<line30>ignore_case = true;\n<line31>break;\n<line32>case 'g':\n<line33>{\n<line34>intmax_t tmp;\n<line35>if (! (xstrtoimax (optarg, nullptr, 0, &tmp, "") == LONGINT_OK\n<line36>&& 0 < tmp && tmp <= PTRDIFF_MAX))\n<line37>error (EXIT_FAILURE, 0, _("invalid gap width: %s"),\n<line38>quote (optarg));\n<line39>gap_size = tmp;\n<line40>break;\n<line41>}\n<line42>case 'i':\n<line43>ignore_file = optarg;\n<line44>break;\n<line45>case 'o':\n<line46>only_file = optarg;\n<line47>break;\n<line48>case 'r':\n<line49>input_reference = true;\n<line50>break;\n<line51>case 't':\n<line52>/* Yet to understand...  */\n<line53>break;\n<line54>case 'w':\n<line55>{\n<line56>intmax_t tmp;\n<line57>if (! (xstrtoimax (optarg, nullptr, 0, &tmp, "") == LONGINT_OK\n<line58>&& 0 < tmp && tmp <= PTRDIFF_MAX))\n<line59>error (EXIT_FAILURE, 0, _("invalid line width: %s"),\n<line60>quote (optarg));\n<line61>line_width = tmp;\n<line62>break;\n<line63>}\n<line64>case 'A':\n<line65>auto_reference = true;\n<line66>break;\n<line67>case 'F':\n<line68>truncation_string = optarg;\n<line69>unescape_string (optarg);\n<line70>break;\n<line71>case 'M':\n<line72>macro_name = optarg;\n<line73>break;\n<line74>case 'O':\n<line75>output_format = ROFF_FORMAT;\n<line76>break;\n<line77>case 'R':\n<line78>right_reference = true;\n<line79>break;\n<line80>case 'S':\n<line81>context_regex.string = optarg;\n<line82>unescape_string (optarg);\n<line83>break;\n<line84>case 'T':\n<line85>output_format = TEX_FORMAT;\n<line86>break;\n<line87>case 'W':\n<line88>word_regex.string = optarg;\n<line89>unescape_string (optarg);\n<line90>if (!*word_regex.string)\n<line91>word_regex.string = nullptr;\n<line92>break;\n<line93>case 10:\n<line94>output_format = XARGMATCH ("--format", optarg,\n<line95>format_args, format_vals);\n<line96>break;\n<line97>case_GETOPT_HELP_CHAR;\n<line98>case_GETOPT_VERSION_CHAR (PROGRAM_NAME, AUTHORS);\n<line99>}\n<line100>}\n<line101>/* Process remaining arguments.  If GNU extensions are enabled, process\n<line102>all arguments as input parameters.  If disabled, accept at most two\n<line103>arguments, the second of which is an output parameter.  */\n<line104>if (optind == argc)\n<line105>{\n<line106>/* No more argument simply means: read standard input.  */\n<line107>input_file_name = xmalloc (sizeof *input_file_name);\n<line108>file_line_count = xmalloc (sizeof *file_line_count);\n<line109>text_buffers =    xmalloc (sizeof *text_buffers);\n<line110>number_input_files = 1;\n<line111>input_file_name[0] = nullptr;\n<line112>}\n<line113>else if (gnu_extensions)\n<line114>{\n<line115>number_input_files = argc - optind;\n<line116>input_file_name = xnmalloc (number_input_files, sizeof *input_file_name);\n<line117>file_line_count = xnmalloc (number_input_files, sizeof *file_line_count);\n<line118>text_buffers    = xnmalloc (number_input_files, sizeof *text_buffers);\n<line119>for (file_index = 0; file_index < number_input_files; file_index++)\n<line120>{\n<line121>if (!*argv[optind] || STREQ (argv[optind], "-"))\n<line122>input_file_name[file_index] = nullptr;\n<line123>else\n<line124>input_file_name[file_index] = argv[optind];\n<line125>optind++;\n<line126>}\n<line127>}\n<line128>else\n<line129>{\n<line130>/* There is one necessary input file.  */\n<line131>number_input_files = 1;\n<line132>input_file_name = xmalloc (sizeof *input_file_name);\n<line133>file_line_count = xmalloc (sizeof *file_line_count);\n<line134>text_buffers    = xmalloc (sizeof *text_buffers);\n<line135>if (!*argv[optind] || STREQ (argv[optind], "-"))\n<line136>input_file_name[0] = nullptr;\n<line137>else\n<line138>input_file_name[0] = argv[optind];\n<line139>optind++;\n<line140>/* Redirect standard output, only if requested.  */\n<line141>if (optind < argc)\n<line142>{\n<line143>if (! freopen (argv[optind], "w", stdout))\n<line144>error (EXIT_FAILURE, errno, "%s", quotef (argv[optind]));\n<line145>optind++;\n<line146>}\n<line147>/* Diagnose any other argument as an error.  */\n<line148>if (optind < argc)\n<line149>{\n<line150>error (0, 0, _("extra operand %s"), quote (argv[optind]));\n<line151>usage (EXIT_FAILURE);\n<line152>}\n<line153>}\n<line154>/* If the output format has not been explicitly selected, choose dumb\n<line155>terminal format if GNU extensions are enabled, else 'roff' format.  */\n<line156>if (output_format == UNKNOWN_FORMAT)\n<line157>output_format = gnu_extensions ? DUMB_FORMAT : ROFF_FORMAT;\n<line158>/* Initialize the main tables.  */\n<line159>initialize_regex ();\n<line160>/* Read 'Break character' file, if any.  */\n<line161>if (break_file)\n<line162>digest_break_file (break_file);\n<line163>/* Read 'Ignore words' file and 'Only words' files, if any.  If any of\n<line164>these files is empty, reset the name of the file to null, to avoid\n<line165>unnecessary calls to search_table. */\n<line166>if (ignore_file)\n<line167>{\n<line168>digest_word_file (ignore_file, &ignore_table);\n<line169>if (ignore_table.length == 0)\n<line170>ignore_file = nullptr;\n<line171>}\n<line172>if (only_file)\n<line173>{\n<line174>digest_word_file (only_file, &only_table);\n<line175>if (only_table.length == 0)\n<line176>only_file = nullptr;\n<line177>}\n<line178>/* Prepare to study all the input files.  */\n<line179>number_of_occurs[0] = 0;\n<line180>total_line_count = 0;\n<line181>maximum_word_length = 0;\n<line182>reference_max_width = 0;\n<line183>for (file_index = 0; file_index < number_input_files; file_index++)\n<line184>{\n<line185>BLOCK *text_buffer = text_buffers + file_index;\n<line186>/* Read the file contents into memory, then study it.  */\n<line187>swallow_file_in_memory (input_file_name[file_index], text_buffer);\n<line188>find_occurs_in_text (file_index);\n<line189>/* Maintain for each file how many lines has been read so far when its\n<line190>end is reached.  Incrementing the count first is a simple kludge to\n<line191>handle a possible incomplete line at end of file.  */\n<line192>total_line_count++;\n<line193>file_line_count[file_index] = total_line_count;\n<line194>}\n<line195>/* Do the output process phase.  */\n<line196>sort_found_occurs ();\n<line197>fix_output_parameters ();\n<line198>generate_all_output ();\n<line199>/* All done.  */\n<line200>return EXIT_SUCCESS;\n<line201>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/src/pwd.c
========================================
Function: usage
Content: <line0>void\n<line1>usage (int status)\n<line2>{\n<line3>if (status != EXIT_SUCCESS)\n<line4>emit_try_help ();\n<line5>else\n<line6>{\n<line7>printf (_("Usage: %s [OPTION]...\n"), program_name);\n<line8>fputs (_("\\n<line9>Print the full filename of the current working directory.\n\\n<line10>\n\\n<line11>"), stdout);\n<line12>fputs (_("\\n<line13>-L, --logical   use PWD from environment, even if it contains symlinks\n\\n<line14>-P, --physical  avoid all symlinks\n\\n<line15>"), stdout);\n<line16>fputs (HELP_OPTION_DESCRIPTION, stdout);\n<line17>fputs (VERSION_OPTION_DESCRIPTION, stdout);\n<line18>fputs (_("\n\\n<line19>If no option is specified, -P is assumed.\n\\n<line20>"), stdout);\n<line21>printf (USAGE_BUILTIN_WARNING, PROGRAM_NAME);\n<line22>emit_ancillary_info (PROGRAM_NAME);\n<line23>}\n<line24>exit (status);\n<line25>}
----------------------------------------
Function: file_name_free
Content: <line0>static void\n<line1>file_name_free (struct file_name *p)\n<line2>{\n<line3>free (p->buf);\n<line4>free (p);\n<line5>}
----------------------------------------
Function: file_name_init
Content: <line0>static struct file_name *\n<line1>file_name_init (void)\n<line2>{\n<line3>struct file_name *p = xmalloc (sizeof *p);\n<line4>/* Start with a buffer larger than PATH_MAX, but beware of systems\n<line5>on which PATH_MAX is very large -- e.g., INT_MAX.  */\n<line6>p->n_alloc = MIN (2 * PATH_MAX, 32 * 1024);\n<line7>p->buf = xmalloc (p->n_alloc);\n<line8>p->start = p->buf + (p->n_alloc - 1);\n<line9>p->start[0] = '\0';\n<line10>return p;\n<line11>}
----------------------------------------
Function: file_name_prepend
Content: <line0>static void\n<line1>file_name_prepend (struct file_name *p, char const *s, size_t s_len)\n<line2>{\n<line3>size_t n_free = p->start - p->buf;\n<line4>if (n_free < 1 + s_len)\n<line5>{\n<line6>size_t half = p->n_alloc + 1 + s_len;\n<line7>/* Use xnmalloc+free rather than xnrealloc, since with the latter\n<line8>we'd end up copying the data twice: once via realloc, then again\n<line9>to align it with the end of the new buffer.  With xnmalloc, we\n<line10>copy it only once.  */\n<line11>char *q = xnmalloc (2, half);\n<line12>size_t n_used = p->n_alloc - n_free;\n<line13>p->start = q + 2 * half - n_used;\n<line14>memcpy (p->start, p->buf + n_free, n_used);\n<line15>free (p->buf);\n<line16>p->buf = q;\n<line17>p->n_alloc = 2 * half;\n<line18>}\n<line19>p->start -= 1 + s_len;\n<line20>p->start[0] = '/';\n<line21>memcpy (p->start + 1, s, s_len);\n<line22>}
----------------------------------------
Function: nth_parent
Content: <line0>static char *\n<line1>nth_parent (size_t n)\n<line2>{\n<line3>char *buf = xnmalloc (3, n);\n<line4>char *p = buf;\n<line5>for (size_t i = 0; i < n; i++)\n<line6>{\n<line7>memcpy (p, "../", 3);\n<line8>p += 3;\n<line9>}\n<line10>p[-1] = '\0';\n<line11>return buf;\n<line12>}
----------------------------------------
Function: find_dir_entry
Content: <line0>static void\n<line1>find_dir_entry (struct stat *dot_sb, struct file_name *file_name,\n<line2>size_t parent_height)\n<line3>{\n<line4>DIR *dirp;\n<line5>int fd;\n<line6>struct stat parent_sb;\n<line7>bool use_lstat;\n<line8>bool found;\n<line9>dirp = opendir ("..");\n<line10>if (dirp == nullptr)\n<line11>error (EXIT_FAILURE, errno, _("cannot open directory %s"),\n<line12>quote (nth_parent (parent_height)));\n<line13>fd = dirfd (dirp);\n<line14>if ((0 <= fd ? fchdir (fd) : chdir ("..")) < 0)\n<line15>error (EXIT_FAILURE, errno, _("failed to chdir to %s"),\n<line16>quote (nth_parent (parent_height)));\n<line17>if ((0 <= fd ? fstat (fd, &parent_sb) : stat (".", &parent_sb)) < 0)\n<line18>error (EXIT_FAILURE, errno, _("failed to stat %s"),\n<line19>quote (nth_parent (parent_height)));\n<line20>/* If parent and child directory are on different devices, then we\n<line21>can't rely on d_ino for useful i-node numbers; use lstat instead.  */\n<line22>use_lstat = (parent_sb.st_dev != dot_sb->st_dev);\n<line23>found = false;\n<line24>while (true)\n<line25>{\n<line26>struct dirent const *dp;\n<line27>struct stat ent_sb;\n<line28>ino_t ino;\n<line29>errno = 0;\n<line30>if ((dp = readdir_ignoring_dot_and_dotdot (dirp)) == nullptr)\n<line31>{\n<line32>if (errno)\n<line33>{\n<line34>/* Save/restore errno across closedir call.  */\n<line35>int e = errno;\n<line36>closedir (dirp);\n<line37>errno = e;\n<line38>/* Arrange to give a diagnostic after exiting this loop.  */\n<line39>dirp = nullptr;\n<line40>}\n<line41>break;\n<line42>}\n<line43>ino = D_INO (dp);\n<line44>if (ino == NOT_AN_INODE_NUMBER || use_lstat)\n<line45>{\n<line46>if (lstat (dp->d_name, &ent_sb) < 0)\n<line47>{\n<line48>/* Skip any entry we can't stat.  */\n<line49>continue;\n<line50>}\n<line51>ino = ent_sb.st_ino;\n<line52>}\n<line53>if (ino != dot_sb->st_ino)\n<line54>continue;\n<line55>/* If we're not crossing a device boundary, then a simple i-node\n<line56>match is enough.  */\n<line57>if ( ! use_lstat || ent_sb.st_dev == dot_sb->st_dev)\n<line58>{\n<line59>file_name_prepend (file_name, dp->d_name, _D_EXACT_NAMLEN (dp));\n<line60>found = true;\n<line61>break;\n<line62>}\n<line63>}\n<line64>if (dirp == nullptr || closedir (dirp) != 0)\n<line65>{\n<line66>/* Note that this diagnostic serves for both readdir\n<line67>and closedir failures.  */\n<line68>error (EXIT_FAILURE, errno, _("reading directory %s"),\n<line69>quote (nth_parent (parent_height)));\n<line70>}\n<line71>if ( ! found)\n<line72>error (EXIT_FAILURE, 0,\n<line73>_("couldn't find directory entry in %s with matching i-node"),\n<line74>quote (nth_parent (parent_height)));\n<line75>*dot_sb = parent_sb;\n<line76>}
----------------------------------------
Function: robust_getcwd
Content: <line0>static void\n<line1>robust_getcwd (struct file_name *file_name)\n<line2>{\n<line3>size_t height = 1;\n<line4>struct dev_ino dev_ino_buf;\n<line5>struct dev_ino *root_dev_ino = get_root_dev_ino (&dev_ino_buf);\n<line6>struct stat dot_sb;\n<line7>if (root_dev_ino == nullptr)\n<line8>error (EXIT_FAILURE, errno, _("failed to get attributes of %s"),\n<line9>quoteaf ("/"));\n<line10>if (stat (".", &dot_sb) < 0)\n<line11>error (EXIT_FAILURE, errno, _("failed to stat %s"), quoteaf ("."));\n<line12>while (true)\n<line13>{\n<line14>/* If we've reached the root, we're done.  */\n<line15>if (SAME_INODE (dot_sb, *root_dev_ino))\n<line16>break;\n<line17>find_dir_entry (&dot_sb, file_name, height++);\n<line18>}\n<line19>/* See if a leading slash is needed; file_name_prepend adds one.  */\n<line20>if (file_name->start[0] == '\0')\n<line21>file_name_prepend (file_name, "", 0);\n<line22>}
----------------------------------------
Function: logical_getcwd
Content: <line0>static char *\n<line1>logical_getcwd (void)\n<line2>{\n<line3>struct stat st1;\n<line4>struct stat st2;\n<line5>char *wd = getenv ("PWD");\n<line6>char *p;\n<line7>/* Textual validation first.  */\n<line8>if (!wd || wd[0] != '/')\n<line9>return nullptr;\n<line10>p = wd;\n<line11>while ((p = strstr (p, "/.")))\n<line12>{\n<line13>if (!p[2] || p[2] == '/'\n<line14>|| (p[2] == '.' && (!p[3] || p[3] == '/')))\n<line15>return nullptr;\n<line16>p++;\n<line17>}\n<line18>/* System call validation.  */\n<line19>if (stat (wd, &st1) == 0 && stat (".", &st2) == 0 && SAME_INODE (st1, st2))\n<line20>return wd;\n<line21>return nullptr;\n<line22>}
----------------------------------------
Function: main
Content: <line0>int\n<line1>main (int argc, char **argv)\n<line2>{\n<line3>char *wd;\n<line4>/* POSIX requires a default of -L, but most scripts expect -P.\n<line5>Currently shells default to -L, while stand-alone\n<line6>pwd implementations default to -P.  */\n<line7>bool logical = (getenv ("POSIXLY_CORRECT") != nullptr);\n<line8>initialize_main (&argc, &argv);\n<line9>set_program_name (argv[0]);\n<line10>setlocale (LC_ALL, "");\n<line11>bindtextdomain (PACKAGE, LOCALEDIR);\n<line12>textdomain (PACKAGE);\n<line13>atexit (close_stdout);\n<line14>while (true)\n<line15>{\n<line16>int c = getopt_long (argc, argv, "LP", longopts, nullptr);\n<line17>if (c == -1)\n<line18>break;\n<line19>switch (c)\n<line20>{\n<line21>case 'L':\n<line22>logical = true;\n<line23>break;\n<line24>case 'P':\n<line25>logical = false;\n<line26>break;\n<line27>case_GETOPT_HELP_CHAR;\n<line28>case_GETOPT_VERSION_CHAR (PROGRAM_NAME, AUTHORS);\n<line29>default:\n<line30>usage (EXIT_FAILURE);\n<line31>}\n<line32>}\n<line33>if (optind < argc)\n<line34>error (0, 0, _("ignoring non-option arguments"));\n<line35>if (logical)\n<line36>{\n<line37>wd = logical_getcwd ();\n<line38>if (wd)\n<line39>{\n<line40>puts (wd);\n<line41>return EXIT_SUCCESS;\n<line42>}\n<line43>}\n<line44>wd = xgetcwd ();\n<line45>if (wd != nullptr)\n<line46>{\n<line47>puts (wd);\n<line48>free (wd);\n<line49>}\n<line50>else\n<line51>{\n<line52>struct file_name *file_name = file_name_init ();\n<line53>robust_getcwd (file_name);\n<line54>puts (file_name->start);\n<line55>file_name_free (file_name);\n<line56>}\n<line57>return EXIT_SUCCESS;\n<line58>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/src/readlink.c
========================================
Function: usage
Content: <line0>void\n<line1>usage (int status)\n<line2>{\n<line3>if (status != EXIT_SUCCESS)\n<line4>emit_try_help ();\n<line5>else\n<line6>{\n<line7>printf (_("Usage: %s [OPTION]... FILE...\n"), program_name);\n<line8>fputs (_("Print value of a symbolic link or canonical file name\n\n"),\n<line9>stdout);\n<line10>fputs (_("\\n<line11>-f, --canonicalize            canonicalize by following every symlink in\n\\n<line12>every component of the given name recursively;\\n<line13>\n\\n<line14>all but the last component must exist\n\\n<line15>-e, --canonicalize-existing   canonicalize by following every symlink in\n\\n<line16>every component of the given name recursively,\\n<line17>\n\\n<line18>all components must exist\n\\n<line19>"), stdout);\n<line20>fputs (_("\\n<line21>-m, --canonicalize-missing    canonicalize by following every symlink in\n\\n<line22>every component of the given name recursively,\\n<line23>\n\\n<line24>without requirements on components existence\n\\n<line25>-n, --no-newline              do not output the trailing delimiter\n\\n<line26>-q, --quiet\n\\n<line27>-s, --silent                  suppress most error messages (on by default)\n\\n<line28>-v, --verbose                 report error messages\n\\n<line29>-z, --zero                    end each output line with NUL, not newline\n\\n<line30>"), stdout);\n<line31>fputs (HELP_OPTION_DESCRIPTION, stdout);\n<line32>fputs (VERSION_OPTION_DESCRIPTION, stdout);\n<line33>emit_ancillary_info (PROGRAM_NAME);\n<line34>}\n<line35>exit (status);\n<line36>}
----------------------------------------
Function: main
Content: <line0>int\n<line1>main (int argc, char **argv)\n<line2>{\n<line3>/* If not -1, use this method to canonicalize.  */\n<line4>int can_mode = -1;\n<line5>int status = EXIT_SUCCESS;\n<line6>int optc;\n<line7>bool use_nuls = false;\n<line8>initialize_main (&argc, &argv);\n<line9>set_program_name (argv[0]);\n<line10>setlocale (LC_ALL, "");\n<line11>bindtextdomain (PACKAGE, LOCALEDIR);\n<line12>textdomain (PACKAGE);\n<line13>atexit (close_stdout);\n<line14>while ((optc = getopt_long (argc, argv, "efmnqsvz", longopts, nullptr)) != -1)\n<line15>{\n<line16>switch (optc)\n<line17>{\n<line18>case 'e':\n<line19>can_mode = CAN_EXISTING;\n<line20>break;\n<line21>case 'f':\n<line22>can_mode = CAN_ALL_BUT_LAST;\n<line23>break;\n<line24>case 'm':\n<line25>can_mode = CAN_MISSING;\n<line26>break;\n<line27>case 'n':\n<line28>no_newline = true;\n<line29>break;\n<line30>case 'q':\n<line31>case 's':\n<line32>verbose = false;\n<line33>break;\n<line34>case 'v':\n<line35>verbose = true;\n<line36>break;\n<line37>case 'z':\n<line38>use_nuls = true;\n<line39>break;\n<line40>case_GETOPT_HELP_CHAR;\n<line41>case_GETOPT_VERSION_CHAR (PROGRAM_NAME, AUTHORS);\n<line42>default:\n<line43>usage (EXIT_FAILURE);\n<line44>}\n<line45>}\n<line46>if (optind >= argc)\n<line47>{\n<line48>error (0, 0, _("missing operand"));\n<line49>usage (EXIT_FAILURE);\n<line50>}\n<line51>if (argc - optind > 1)\n<line52>{\n<line53>if (no_newline)\n<line54>error (0, 0, _("ignoring --no-newline with multiple arguments"));\n<line55>no_newline = false;\n<line56>}\n<line57>for (; optind < argc; ++optind)\n<line58>{\n<line59>char const *fname = argv[optind];\n<line60>char *value = (can_mode != -1\n<line61>? canonicalize_filename_mode (fname, can_mode)\n<line62>: areadlink_with_size (fname, 63));\n<line63>if (value)\n<line64>{\n<line65>fputs (value, stdout);\n<line66>if (! no_newline)\n<line67>putchar (use_nuls ? '\0' : '\n');\n<line68>free (value);\n<line69>}\n<line70>else\n<line71>{\n<line72>status = EXIT_FAILURE;\n<line73>if (verbose)\n<line74>error (0, errno, "%s", quotef (fname));\n<line75>}\n<line76>}\n<line77>return status;\n<line78>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/src/realpath.c
========================================
Function: usage
Content: <line0>void\n<line1>usage (int status)\n<line2>{\n<line3>if (status != EXIT_SUCCESS)\n<line4>emit_try_help ();\n<line5>else\n<line6>{\n<line7>printf (_("Usage: %s [OPTION]... FILE...\n"), program_name);\n<line8>fputs (_("\\n<line9>Print the resolved absolute file name;\n\\n<line10>all but the last component must exist\n\\n<line11>\n\\n<line12>"), stdout);\n<line13>fputs (_("\\n<line14>-e, --canonicalize-existing  all components of the path must exist\n\\n<line15>-m, --canonicalize-missing   no path components need exist or be a directory\\n<line16>\n\\n<line17>-L, --logical                resolve '..' components before symlinks\n\\n<line18>-P, --physical               resolve symlinks as encountered (default)\n\\n<line19>-q, --quiet                  suppress most error messages\n\\n<line20>--relative-to=DIR        print the resolved path relative to DIR\n\\n<line21>--relative-base=DIR      print absolute paths unless paths below DIR\n\\n<line22>-s, --strip, --no-symlinks   don't expand symlinks\n\\n<line23>-z, --zero                   end each output line with NUL, not newline\n\\n<line24>"), stdout);\n<line25>fputs (HELP_OPTION_DESCRIPTION, stdout);\n<line26>fputs (VERSION_OPTION_DESCRIPTION, stdout);\n<line27>emit_ancillary_info (PROGRAM_NAME);\n<line28>}\n<line29>exit (status);\n<line30>}
----------------------------------------
Function: realpath_canon
Content: <line0>static char *\n<line1>realpath_canon (char const *fname, int can_mode)\n<line2>{\n<line3>char *can_fname = canonicalize_filename_mode (fname, can_mode);\n<line4>if (logical && can_fname)  /* canonicalize again to resolve symlinks.  */\n<line5>{\n<line6>can_mode &= ~CAN_NOLINKS;\n<line7>char *can_fname2 = canonicalize_filename_mode (can_fname, can_mode);\n<line8>free (can_fname);\n<line9>return can_fname2;\n<line10>}\n<line11>return can_fname;\n<line12>}
----------------------------------------
Function: isdir
Content: <line0>static bool\n<line1>isdir (char const *path)\n<line2>{\n<line3>struct stat sb;\n<line4>if (stat (path, &sb) != 0)\n<line5>error (EXIT_FAILURE, errno, _("cannot stat %s"), quoteaf (path));\n<line6>return S_ISDIR (sb.st_mode);\n<line7>}
----------------------------------------
Function: process_path
Content: <line0>static bool\n<line1>process_path (char const *fname, int can_mode)\n<line2>{\n<line3>char *can_fname = realpath_canon (fname, can_mode);\n<line4>if (!can_fname)\n<line5>{\n<line6>if (verbose)\n<line7>error (0, errno, "%s", quotef (fname));\n<line8>return false;\n<line9>}\n<line10>if (!can_relative_to\n<line11>|| (can_relative_base && !path_prefix (can_relative_base, can_fname))\n<line12>|| (can_relative_to && !relpath (can_fname, can_relative_to, nullptr, 0)))\n<line13>fputs (can_fname, stdout);\n<line14>putchar (use_nuls ? '\0' : '\n');\n<line15>free (can_fname);\n<line16>return true;\n<line17>}
----------------------------------------
Function: main
Content: <line0>int\n<line1>main (int argc, char **argv)\n<line2>{\n<line3>bool ok = true;\n<line4>int can_mode = CAN_ALL_BUT_LAST;\n<line5>char const *relative_to = nullptr;\n<line6>char const *relative_base = nullptr;\n<line7>initialize_main (&argc, &argv);\n<line8>set_program_name (argv[0]);\n<line9>setlocale (LC_ALL, "");\n<line10>bindtextdomain (PACKAGE, LOCALEDIR);\n<line11>textdomain (PACKAGE);\n<line12>atexit (close_stdout);\n<line13>while (true)\n<line14>{\n<line15>int c = getopt_long (argc, argv, "eLmPqsz", longopts, nullptr);\n<line16>if (c == -1)\n<line17>break;\n<line18>switch (c)\n<line19>{\n<line20>case 'e':\n<line21>can_mode &= ~CAN_MODE_MASK;\n<line22>can_mode |= CAN_EXISTING;\n<line23>break;\n<line24>case 'm':\n<line25>can_mode &= ~CAN_MODE_MASK;\n<line26>can_mode |= CAN_MISSING;\n<line27>break;\n<line28>case 'L':\n<line29>can_mode |= CAN_NOLINKS;\n<line30>logical = true;\n<line31>break;\n<line32>case 's':\n<line33>can_mode |= CAN_NOLINKS;\n<line34>logical = false;\n<line35>break;\n<line36>case 'P':\n<line37>can_mode &= ~CAN_NOLINKS;\n<line38>logical = false;\n<line39>break;\n<line40>case 'q':\n<line41>verbose = false;\n<line42>break;\n<line43>case 'z':\n<line44>use_nuls = true;\n<line45>break;\n<line46>case RELATIVE_TO_OPTION:\n<line47>relative_to = optarg;\n<line48>break;\n<line49>case RELATIVE_BASE_OPTION:\n<line50>relative_base = optarg;\n<line51>break;\n<line52>case_GETOPT_HELP_CHAR;\n<line53>case_GETOPT_VERSION_CHAR (PROGRAM_NAME, AUTHORS);\n<line54>default:\n<line55>usage (EXIT_FAILURE);\n<line56>}\n<line57>}\n<line58>if (optind >= argc)\n<line59>{\n<line60>error (0, 0, _("missing operand"));\n<line61>usage (EXIT_FAILURE);\n<line62>}\n<line63>if (relative_base && !relative_to)\n<line64>relative_to = relative_base;\n<line65>bool need_dir = (can_mode & CAN_MODE_MASK) == CAN_EXISTING;\n<line66>if (relative_to)\n<line67>{\n<line68>can_relative_to = realpath_canon (relative_to, can_mode);\n<line69>if (!can_relative_to)\n<line70>error (EXIT_FAILURE, errno, "%s", quotef (relative_to));\n<line71>if (need_dir && !isdir (can_relative_to))\n<line72>error (EXIT_FAILURE, ENOTDIR, "%s", quotef (relative_to));\n<line73>}\n<line74>if (relative_base == relative_to)\n<line75>can_relative_base = can_relative_to;\n<line76>else if (relative_base)\n<line77>{\n<line78>char *base = realpath_canon (relative_base, can_mode);\n<line79>if (!base)\n<line80>error (EXIT_FAILURE, errno, "%s", quotef (relative_base));\n<line81>if (need_dir && !isdir (base))\n<line82>error (EXIT_FAILURE, ENOTDIR, "%s", quotef (relative_base));\n<line83>/* --relative-to is a no-op if it does not have --relative-base\n<line84>as a prefix */\n<line85>if (path_prefix (base, can_relative_to))\n<line86>can_relative_base = base;\n<line87>else\n<line88>{\n<line89>free (base);\n<line90>can_relative_base = can_relative_to;\n<line91>can_relative_to = nullptr;\n<line92>}\n<line93>}\n<line94>for (; optind < argc; ++optind)\n<line95>ok &= process_path (argv[optind], can_mode);\n<line96>return ok ? EXIT_SUCCESS : EXIT_FAILURE;\n<line97>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/src/rm.c
========================================
/home/huihui/Downloads/coreutils-9.4/src/rm.c:96:1: warning: '_Static_assert' with no message is a C2x extension [-Wc2x-extensions]
ARGMATCH_VERIFY (interactive_args, interactive_types);
^
./lib/argmatch.h:49:54: note: expanded from macro 'ARGMATCH_VERIFY'
                   == ARRAY_CARDINALITY (Vallist) + 1)
                                                     ^
1 warning generated.
Function: diagnose_leading_hyphen
Content: <line0>static void\n<line1>diagnose_leading_hyphen (int argc, char **argv)\n<line2>{\n<line3>/* OPTIND is unreliable, so iterate through the arguments looking\n<line4>for a file name that looks like an option.  */\n<line5>for (int i = 1; i < argc; i++)\n<line6>{\n<line7>char const *arg = argv[i];\n<line8>struct stat st;\n<line9>if (arg[0] == '-' && arg[1] && lstat (arg, &st) == 0)\n<line10>{\n<line11>fprintf (stderr,\n<line12>_("Try '%s ./%s' to remove the file %s.\n"),\n<line13>argv[0],\n<line14>quotearg_n_style (1, shell_escape_quoting_style, arg),\n<line15>quoteaf (arg));\n<line16>break;\n<line17>}\n<line18>}\n<line19>}
----------------------------------------
Function: usage
Content: <line0>void\n<line1>usage (int status)\n<line2>{\n<line3>if (status != EXIT_SUCCESS)\n<line4>emit_try_help ();\n<line5>else\n<line6>{\n<line7>printf (_("Usage: %s [OPTION]... [FILE]...\n"), program_name);\n<line8>fputs (_("\\n<line9>Remove (unlink) the FILE(s).\n\\n<line10>\n\\n<line11>-f, --force           ignore nonexistent files and arguments, never prompt\n\\n<line12>-i                    prompt before every removal\n\\n<line13>"), stdout);\n<line14>fputs (_("\\n<line15>-I                    prompt once before removing more than three files, or\n\\n<line16>when removing recursively; less intrusive than -i,\n\\n<line17>while still giving protection against most mistakes\n\\n<line18>--interactive[=WHEN]  prompt according to WHEN: never, once (-I), or\n\\n<line19>always (-i); without WHEN, prompt always\n\\n<line20>"), stdout);\n<line21>fputs (_("\\n<line22>--one-file-system  when removing a hierarchy recursively, skip any\n\\n<line23>directory that is on a file system different from\n\\n<line24>that of the corresponding command line argument\n\\n<line25>"), stdout);\n<line26>fputs (_("\\n<line27>--no-preserve-root  do not treat '/' specially\n\\n<line28>--preserve-root[=all]  do not remove '/' (default);\n\\n<line29>with 'all', reject any command line argument\n\\n<line30>on a separate device from its parent\n\\n<line31>"), stdout);\n<line32>fputs (_("\\n<line33>-r, -R, --recursive   remove directories and their contents recursively\n\\n<line34>-d, --dir             remove empty directories\n\\n<line35>-v, --verbose         explain what is being done\n\\n<line36>"), stdout);\n<line37>fputs (HELP_OPTION_DESCRIPTION, stdout);\n<line38>fputs (VERSION_OPTION_DESCRIPTION, stdout);\n<line39>fputs (_("\\n<line40>\n\\n<line41>By default, rm does not remove directories.  Use the --recursive (-r or -R)\n\\n<line42>option to remove each listed directory, too, along with all of its contents.\n\\n<line43>"), stdout);\n<line44>printf (_("\\n<line45>\n\\n<line46>To remove a file whose name starts with a '-', for example '-foo',\n\\n<line47>use one of these commands:\n\\n<line48>%s -- -foo\n\\n<line49>\n\\n<line50>%s ./-foo\n\\n<line51>"),\n<line52>program_name, program_name);\n<line53>fputs (_("\\n<line54>\n\\n<line55>Note that if you use rm to remove a file, it might be possible to recover\n\\n<line56>some of its contents, given sufficient expertise and/or time.  For greater\n\\n<line57>assurance that the contents are truly unrecoverable, consider using shred(1).\n\\n<line58>"), stdout);\n<line59>emit_ancillary_info (PROGRAM_NAME);\n<line60>}\n<line61>exit (status);\n<line62>}
----------------------------------------
Function: rm_option_init
Content: <line0>static void\n<line1>rm_option_init (struct rm_options *x)\n<line2>{\n<line3>x->ignore_missing_files = false;\n<line4>x->interactive = RMI_SOMETIMES;\n<line5>x->one_file_system = false;\n<line6>x->remove_empty_directories = false;\n<line7>x->recursive = false;\n<line8>x->root_dev_ino = nullptr;\n<line9>x->preserve_all_root = false;\n<line10>x->stdin_tty = isatty (STDIN_FILENO);\n<line11>x->verbose = false;\n<line12>/* Since this program exits immediately after calling 'rm', rm need not\n<line13>expend unnecessary effort to preserve the initial working directory.  */\n<line14>x->require_restore_cwd = false;\n<line15>}
----------------------------------------
Function: main
Content: <line0>int\n<line1>main (int argc, char **argv)\n<line2>{\n<line3>bool preserve_root = true;\n<line4>struct rm_options x;\n<line5>bool prompt_once = false;\n<line6>int c;\n<line7>initialize_main (&argc, &argv);\n<line8>set_program_name (argv[0]);\n<line9>setlocale (LC_ALL, "");\n<line10>bindtextdomain (PACKAGE, LOCALEDIR);\n<line11>textdomain (PACKAGE);\n<line12>atexit (close_stdin);\n<line13>rm_option_init (&x);\n<line14>/* Try to disable the ability to unlink a directory.  */\n<line15>priv_set_remove_linkdir ();\n<line16>while ((c = getopt_long (argc, argv, "dfirvIR", long_opts, nullptr)) != -1)\n<line17>{\n<line18>switch (c)\n<line19>{\n<line20>case 'd':\n<line21>x.remove_empty_directories = true;\n<line22>break;\n<line23>case 'f':\n<line24>x.interactive = RMI_NEVER;\n<line25>x.ignore_missing_files = true;\n<line26>prompt_once = false;\n<line27>break;\n<line28>case 'i':\n<line29>x.interactive = RMI_ALWAYS;\n<line30>x.ignore_missing_files = false;\n<line31>prompt_once = false;\n<line32>break;\n<line33>case 'I':\n<line34>x.interactive = RMI_SOMETIMES;\n<line35>x.ignore_missing_files = false;\n<line36>prompt_once = true;\n<line37>break;\n<line38>case 'r':\n<line39>case 'R':\n<line40>x.recursive = true;\n<line41>break;\n<line42>case INTERACTIVE_OPTION:\n<line43>{\n<line44>int i;\n<line45>if (optarg)\n<line46>i = XARGMATCH ("--interactive", optarg, interactive_args,\n<line47>interactive_types);\n<line48>else\n<line49>i = interactive_always;\n<line50>switch (i)\n<line51>{\n<line52>case interactive_never:\n<line53>x.interactive = RMI_NEVER;\n<line54>prompt_once = false;\n<line55>break;\n<line56>case interactive_once:\n<line57>x.interactive = RMI_SOMETIMES;\n<line58>x.ignore_missing_files = false;\n<line59>prompt_once = true;\n<line60>break;\n<line61>case interactive_always:\n<line62>x.interactive = RMI_ALWAYS;\n<line63>x.ignore_missing_files = false;\n<line64>prompt_once = false;\n<line65>break;\n<line66>}\n<line67>break;\n<line68>}\n<line69>case ONE_FILE_SYSTEM:\n<line70>x.one_file_system = true;\n<line71>break;\n<line72>case NO_PRESERVE_ROOT:\n<line73>if (! STREQ (argv[optind - 1], "--no-preserve-root"))\n<line74>error (EXIT_FAILURE, 0,\n<line75>_("you may not abbreviate the --no-preserve-root option"));\n<line76>preserve_root = false;\n<line77>break;\n<line78>case PRESERVE_ROOT:\n<line79>if (optarg)\n<line80>{\n<line81>if STREQ (optarg, "all")\n<line82>x.preserve_all_root = true;\n<line83>else\n<line84>error (EXIT_FAILURE, 0,\n<line85>_("unrecognized --preserve-root argument: %s"),\n<line86>quoteaf (optarg));\n<line87>}\n<line88>preserve_root = true;\n<line89>break;\n<line90>case PRESUME_INPUT_TTY_OPTION:\n<line91>x.stdin_tty = true;\n<line92>break;\n<line93>case 'v':\n<line94>x.verbose = true;\n<line95>break;\n<line96>case_GETOPT_HELP_CHAR;\n<line97>case_GETOPT_VERSION_CHAR (PROGRAM_NAME, AUTHORS);\n<line98>default:\n<line99>diagnose_leading_hyphen (argc, argv);\n<line100>usage (EXIT_FAILURE);\n<line101>}\n<line102>}\n<line103>if (argc <= optind)\n<line104>{\n<line105>if (x.ignore_missing_files)\n<line106>return EXIT_SUCCESS;\n<line107>else\n<line108>{\n<line109>error (0, 0, _("missing operand"));\n<line110>usage (EXIT_FAILURE);\n<line111>}\n<line112>}\n<line113>if (x.recursive && preserve_root)\n<line114>{\n<line115>static struct dev_ino dev_ino_buf;\n<line116>x.root_dev_ino = get_root_dev_ino (&dev_ino_buf);\n<line117>if (x.root_dev_ino == nullptr)\n<line118>error (EXIT_FAILURE, errno, _("failed to get attributes of %s"),\n<line119>quoteaf ("/"));\n<line120>}\n<line121>uintmax_t n_files = argc - optind;\n<line122>char **file =  argv + optind;\n<line123>if (prompt_once && (x.recursive || 3 < n_files))\n<line124>{\n<line125>fprintf (stderr,\n<line126>(x.recursive\n<line127>? ngettext ("%s: remove %"PRIuMAX" argument recursively? ",\n<line128>"%s: remove %"PRIuMAX" arguments recursively? ",\n<line129>select_plural (n_files))\n<line130>: ngettext ("%s: remove %"PRIuMAX" argument? ",\n<line131>"%s: remove %"PRIuMAX" arguments? ",\n<line132>select_plural (n_files))),\n<line133>program_name, n_files);\n<line134>if (!yesno ())\n<line135>return EXIT_SUCCESS;\n<line136>}\n<line137>enum RM_status status = rm (file, &x);\n<line138>affirm (VALID_STATUS (status));\n<line139>return status == RM_ERROR ? EXIT_FAILURE : EXIT_SUCCESS;\n<line140>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/src/rmdir.c
========================================
Function: errno_rmdir_non_empty
Content: <line0>static bool\n<line1>errno_rmdir_non_empty (int error_number)\n<line2>{\n<line3>return error_number == ENOTEMPTY || error_number == EEXIST;\n<line4>}
----------------------------------------
Function: errno_may_be_non_empty
Content: <line0>static bool\n<line1>errno_may_be_non_empty (int error_number)\n<line2>{\n<line3>switch (error_number)\n<line4>{\n<line5>case EACCES:\n<line6>case EPERM:\n<line7>case EROFS:\n<line8>case EBUSY:\n<line9>return true;\n<line10>default:\n<line11>return false;\n<line12>}\n<line13>}
----------------------------------------
Function: ignorable_failure
Content: <line0>static bool\n<line1>ignorable_failure (int error_number, char const *dir)\n<line2>{\n<line3>return (ignore_fail_on_non_empty\n<line4>&& (errno_rmdir_non_empty (error_number)\n<line5>|| (errno_may_be_non_empty (error_number)\n<line6>&& directory_status (AT_FDCWD, dir) == DS_NONEMPTY)));\n<line7>}
----------------------------------------
Function: remove_parents
Content: <line0>static bool\n<line1>remove_parents (char *dir)\n<line2>{\n<line3>char *slash;\n<line4>bool ok = true;\n<line5>strip_trailing_slashes (dir);\n<line6>while (true)\n<line7>{\n<line8>slash = strrchr (dir, '/');\n<line9>if (slash == nullptr)\n<line10>break;\n<line11>/* Remove any characters after the slash, skipping any extra\n<line12>slashes in a row. */\n<line13>while (slash > dir && *slash == '/')\n<line14>--slash;\n<line15>slash[1] = 0;\n<line16>/* Give a diagnostic for each attempted removal if --verbose.  */\n<line17>if (verbose)\n<line18>prog_fprintf (stdout, _("removing directory, %s"), quoteaf (dir));\n<line19>ok = (rmdir (dir) == 0);\n<line20>int rmdir_errno = errno;\n<line21>if (! ok)\n<line22>{\n<line23>/* Stop quietly if --ignore-fail-on-non-empty. */\n<line24>if (ignorable_failure (rmdir_errno, dir))\n<line25>{\n<line26>ok = true;\n<line27>}\n<line28>else\n<line29>{\n<line30>char const *error_msg;\n<line31>if (rmdir_errno != ENOTDIR)\n<line32>{\n<line33>/* Barring race conditions,\n<line34>DIR is expected to be a directory.  */\n<line35>error_msg = N_("failed to remove directory %s");\n<line36>}\n<line37>else\n<line38>{\n<line39>/* A path component could be a symbolic link */\n<line40>error_msg = N_("failed to remove %s");\n<line41>}\n<line42>error (0, rmdir_errno, _(error_msg), quoteaf (dir));\n<line43>}\n<line44>break;\n<line45>}\n<line46>}\n<line47>return ok;\n<line48>}
----------------------------------------
Function: usage
Content: <line0>void\n<line1>usage (int status)\n<line2>{\n<line3>if (status != EXIT_SUCCESS)\n<line4>emit_try_help ();\n<line5>else\n<line6>{\n<line7>printf (_("Usage: %s [OPTION]... DIRECTORY...\n"), program_name);\n<line8>fputs (_("\\n<line9>Remove the DIRECTORY(ies), if they are empty.\n\\n<line10>\n\\n<line11>"), stdout);\n<line12>fputs (_("\\n<line13>--ignore-fail-on-non-empty\n\\n<line14>ignore each failure to remove a non-empty directory\n\\n<line15>"), stdout);\n<line16>fputs (_("\\n<line17>-p, --parents     remove DIRECTORY and its ancestors;\n\\n<line18>e.g., 'rmdir -p a/b' is similar to 'rmdir a/b a'\n\\n<line19>\n\\n<line20>"), stdout);\n<line21>fputs (_("\\n<line22>-v, --verbose     output a diagnostic for every directory processed\n\\n<line23>"), stdout);\n<line24>fputs (HELP_OPTION_DESCRIPTION, stdout);\n<line25>fputs (VERSION_OPTION_DESCRIPTION, stdout);\n<line26>emit_ancillary_info (PROGRAM_NAME);\n<line27>}\n<line28>exit (status);\n<line29>}
----------------------------------------
Function: main
Content: <line0>int\n<line1>main (int argc, char **argv)\n<line2>{\n<line3>bool ok = true;\n<line4>int optc;\n<line5>initialize_main (&argc, &argv);\n<line6>set_program_name (argv[0]);\n<line7>setlocale (LC_ALL, "");\n<line8>bindtextdomain (PACKAGE, LOCALEDIR);\n<line9>textdomain (PACKAGE);\n<line10>atexit (close_stdout);\n<line11>remove_empty_parents = false;\n<line12>while ((optc = getopt_long (argc, argv, "pv", longopts, nullptr)) != -1)\n<line13>{\n<line14>switch (optc)\n<line15>{\n<line16>case 'p':\n<line17>remove_empty_parents = true;\n<line18>break;\n<line19>case IGNORE_FAIL_ON_NON_EMPTY_OPTION:\n<line20>ignore_fail_on_non_empty = true;\n<line21>break;\n<line22>case 'v':\n<line23>verbose = true;\n<line24>break;\n<line25>case_GETOPT_HELP_CHAR;\n<line26>case_GETOPT_VERSION_CHAR (PROGRAM_NAME, AUTHORS);\n<line27>default:\n<line28>usage (EXIT_FAILURE);\n<line29>}\n<line30>}\n<line31>if (optind == argc)\n<line32>{\n<line33>error (0, 0, _("missing operand"));\n<line34>usage (EXIT_FAILURE);\n<line35>}\n<line36>for (; optind < argc; ++optind)\n<line37>{\n<line38>char *dir = argv[optind];\n<line39>/* Give a diagnostic for each attempted removal if --verbose.  */\n<line40>if (verbose)\n<line41>prog_fprintf (stdout, _("removing directory, %s"), quoteaf (dir));\n<line42>if (rmdir (dir) != 0)\n<line43>{\n<line44>int rmdir_errno = errno;\n<line45>if (ignorable_failure (rmdir_errno, dir))\n<line46>continue;\n<line47>/* Distinguish the case for a symlink with trailing slash.\n<line48>On Linux, rmdir(2) confusingly does not follow the symlink,\n<line49>thus giving the errno ENOTDIR, while on other systems the symlink\n<line50>is followed.  We don't provide consistent behavior here,\n<line51>but at least we provide a more accurate error message.  */\n<line52>bool custom_error = false;\n<line53>if (rmdir_errno == ENOTDIR)\n<line54>{\n<line55>char const *last_unix_slash = strrchr (dir, '/');\n<line56>if (last_unix_slash && (*(last_unix_slash + 1) == '\0'))\n<line57>{\n<line58>struct stat st;\n<line59>int ret = stat (dir, &st);\n<line60>/* Some other issue following, or is actually a directory. */\n<line61>if ((ret != 0 && errno != ENOTDIR)\n<line62>|| (ret == 0 && S_ISDIR (st.st_mode)))\n<line63>{\n<line64>/* Ensure the last component was a symlink.  */\n<line65>char *dir_arg = xstrdup (dir);\n<line66>strip_trailing_slashes (dir);\n<line67>ret = lstat (dir, &st);\n<line68>if (ret == 0 && S_ISLNK (st.st_mode))\n<line69>{\n<line70>error (0, 0,\n<line71>_("failed to remove %s:"\n<line72>" Symbolic link not followed"),\n<line73>quoteaf (dir_arg));\n<line74>custom_error = true;\n<line75>}\n<line76>free (dir_arg);\n<line77>}\n<line78>}\n<line79>}\n<line80>if (! custom_error)\n<line81>error (0, rmdir_errno, _("failed to remove %s"), quoteaf (dir));\n<line82>ok = false;\n<line83>}\n<line84>else if (remove_empty_parents)\n<line85>{\n<line86>ok &= remove_parents (dir);\n<line87>}\n<line88>}\n<line89>return ok ? EXIT_SUCCESS : EXIT_FAILURE;\n<line90>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/src/runcon.c
========================================
Function: usage
Content: <line0>void\n<line1>usage (int status)\n<line2>{\n<line3>if (status != EXIT_SUCCESS)\n<line4>emit_try_help ();\n<line5>else\n<line6>{\n<line7>printf (_("\\n<line8>Usage: %s CONTEXT COMMAND [args]\n\\n<line9>or:  %s [ -c ] [-u USER] [-r ROLE] [-t TYPE] [-l RANGE] COMMAND [args]\n\\n<line10>"), program_name, program_name);\n<line11>fputs (_("\\n<line12>Run a program in a different SELinux security context.\n\\n<line13>With neither CONTEXT nor COMMAND, print the current security context.\n\\n<line14>"), stdout);\n<line15>emit_mandatory_arg_note ();\n<line16>fputs (_("\\n<line17>CONTEXT            Complete security context\n\\n<line18>-c, --compute      compute process transition context before modifying\n\\n<line19>-t, --type=TYPE    type (for same role as parent)\n\\n<line20>-u, --user=USER    user identity\n\\n<line21>-r, --role=ROLE    role\n\\n<line22>-l, --range=RANGE  levelrange\n\\n<line23>"), stdout);\n<line24>fputs (HELP_OPTION_DESCRIPTION, stdout);\n<line25>fputs (VERSION_OPTION_DESCRIPTION, stdout);\n<line26>emit_exec_status (PROGRAM_NAME);\n<line27>emit_ancillary_info (PROGRAM_NAME);\n<line28>}\n<line29>exit (status);\n<line30>}
----------------------------------------
Function: main
Content: <line0>int\n<line1>main (int argc, char **argv)\n<line2>{\n<line3>char *role = nullptr;\n<line4>char *range = nullptr;\n<line5>char *user = nullptr;\n<line6>char *type = nullptr;\n<line7>char *context = nullptr;\n<line8>char *cur_context = nullptr;\n<line9>char *file_context = nullptr;\n<line10>char *new_context = nullptr;\n<line11>bool compute_trans = false;\n<line12>context_t con;\n<line13>initialize_main (&argc, &argv);\n<line14>set_program_name (argv[0]);\n<line15>setlocale (LC_ALL, "");\n<line16>bindtextdomain (PACKAGE, LOCALEDIR);\n<line17>textdomain (PACKAGE);\n<line18>initialize_exit_failure (EXIT_CANCELED);\n<line19>atexit (close_stdout);\n<line20>while (true)\n<line21>{\n<line22>int option_index = 0;\n<line23>int c = getopt_long (argc, argv, "+r:t:u:l:c", long_options,\n<line24>&option_index);\n<line25>if (c == -1)\n<line26>break;\n<line27>switch (c)\n<line28>{\n<line29>case 'r':\n<line30>if (role)\n<line31>error (EXIT_CANCELED, 0, _("multiple roles"));\n<line32>role = optarg;\n<line33>break;\n<line34>case 't':\n<line35>if (type)\n<line36>error (EXIT_CANCELED, 0, _("multiple types"));\n<line37>type = optarg;\n<line38>break;\n<line39>case 'u':\n<line40>if (user)\n<line41>error (EXIT_CANCELED, 0, _("multiple users"));\n<line42>user = optarg;\n<line43>break;\n<line44>case 'l':\n<line45>if (range)\n<line46>error (EXIT_CANCELED, 0, _("multiple levelranges"));\n<line47>range = optarg;\n<line48>break;\n<line49>case 'c':\n<line50>compute_trans = true;\n<line51>break;\n<line52>case_GETOPT_HELP_CHAR;\n<line53>case_GETOPT_VERSION_CHAR (PROGRAM_NAME, AUTHORS);\n<line54>default:\n<line55>usage (EXIT_CANCELED);\n<line56>break;\n<line57>}\n<line58>}\n<line59>if (argc - optind == 0)\n<line60>{\n<line61>if (getcon (&cur_context) < 0)\n<line62>error (EXIT_CANCELED, errno, _("failed to get current context"));\n<line63>fputs (cur_context, stdout);\n<line64>fputc ('\n', stdout);\n<line65>return EXIT_SUCCESS;\n<line66>}\n<line67>if (!(user || role || type || range || compute_trans))\n<line68>{\n<line69>if (optind >= argc)\n<line70>{\n<line71>error (0, 0, _("you must specify -c, -t, -u, -l, -r, or context"));\n<line72>usage (EXIT_CANCELED);\n<line73>}\n<line74>context = argv[optind++];\n<line75>}\n<line76>if (optind >= argc)\n<line77>{\n<line78>error (0, 0, _("no command specified"));\n<line79>usage (EXIT_CANCELED);\n<line80>}\n<line81>if (is_selinux_enabled () != 1)\n<line82>error (EXIT_CANCELED, 0, _("%s may be used only on a SELinux kernel"),\n<line83>program_name);\n<line84>if (context)\n<line85>{\n<line86>con = context_new (context);\n<line87>if (!con)\n<line88>error (EXIT_CANCELED, errno, _("failed to create security context: %s"),\n<line89>quote (context));\n<line90>}\n<line91>else\n<line92>{\n<line93>if (getcon (&cur_context) < 0)\n<line94>error (EXIT_CANCELED, errno, _("failed to get current context"));\n<line95>/* We will generate context based on process transition */\n<line96>if (compute_trans)\n<line97>{\n<line98>/* Get context of file to be executed */\n<line99>if (getfilecon (argv[optind], &file_context) == -1)\n<line100>error (EXIT_CANCELED, errno,\n<line101>_("failed to get security context of %s"),\n<line102>quoteaf (argv[optind]));\n<line103>/* compute result of process transition */\n<line104>if (security_compute_create (cur_context, file_context,\n<line105>string_to_security_class ("process"),\n<line106>&new_context) != 0)\n<line107>error (EXIT_CANCELED, errno, _("failed to compute a new context"));\n<line108>/* free contexts */\n<line109>freecon (file_context);\n<line110>freecon (cur_context);\n<line111>/* set cur_context equal to new_context */\n<line112>cur_context = new_context;\n<line113>}\n<line114>con = context_new (cur_context);\n<line115>if (!con)\n<line116>error (EXIT_CANCELED, errno, _("failed to create security context: %s"),\n<line117>quote (cur_context));\n<line118>if (user && context_user_set (con, user))\n<line119>error (EXIT_CANCELED, errno, _("failed to set new user: %s"),\n<line120>quote (user));\n<line121>if (type && context_type_set (con, type))\n<line122>error (EXIT_CANCELED, errno, _("failed to set new type: %s"),\n<line123>quote (type));\n<line124>if (range && context_range_set (con, range))\n<line125>error (EXIT_CANCELED, errno, _("failed to set new range: %s"),\n<line126>quote (range));\n<line127>if (role && context_role_set (con, role))\n<line128>error (EXIT_CANCELED, errno, _("failed to set new role: %s"),\n<line129>quote (role));\n<line130>}\n<line131>if (security_check_context (context_str (con)) < 0)\n<line132>error (EXIT_CANCELED, errno, _("invalid context: %s"),\n<line133>quote (context_str (con)));\n<line134>if (setexeccon (context_str (con)) != 0)\n<line135>error (EXIT_CANCELED, errno, _("unable to set security context %s"),\n<line136>quote (context_str (con)));\n<line137>if (cur_context != nullptr)\n<line138>freecon (cur_context);\n<line139>(compute_trans ? execv : execvp) (argv[optind], argv + optind);\n<line140>int exit_status = errno == ENOENT ? EXIT_ENOENT : EXIT_CANNOT_INVOKE;\n<line141>error (0, errno, "%s", quote (argv[optind]));\n<line142>return exit_status;\n<line143>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/src/seq.c
========================================
/home/huihui/Downloads/coreutils-9.4/src/seq.c:470:71: warning: '_Static_assert' with no message is a C2x extension [-Wc2x-extensions]
  static_assert (SEQ_FAST_STEP_LIMIT_DIGITS < INITIAL_ALLOC_DIGITS - 1);
                                                                      ^
                                                                      , ""
1 warning generated.
Function: usage
Content: <line0>void\n<line1>usage (int status)\n<line2>{\n<line3>if (status != EXIT_SUCCESS)\n<line4>emit_try_help ();\n<line5>else\n<line6>{\n<line7>printf (_("\\n<line8>Usage: %s [OPTION]... LAST\n\\n<line9>or:  %s [OPTION]... FIRST LAST\n\\n<line10>or:  %s [OPTION]... FIRST INCREMENT LAST\n\\n<line11>"), program_name, program_name, program_name);\n<line12>fputs (_("\\n<line13>Print numbers from FIRST to LAST, in steps of INCREMENT.\n\\n<line14>"), stdout);\n<line15>emit_mandatory_arg_note ();\n<line16>fputs (_("\\n<line17>-f, --format=FORMAT      use printf style floating-point FORMAT\n\\n<line18>-s, --separator=STRING   use STRING to separate numbers (default: \\n)\n\\n<line19>-w, --equal-width        equalize width by padding with leading zeroes\n\\n<line20>"), stdout);\n<line21>fputs (HELP_OPTION_DESCRIPTION, stdout);\n<line22>fputs (VERSION_OPTION_DESCRIPTION, stdout);\n<line23>fputs (_("\\n<line24>\n\\n<line25>If FIRST or INCREMENT is omitted, it defaults to 1.  That is, an\n\\n<line26>omitted INCREMENT defaults to 1 even when LAST is smaller than FIRST.\n\\n<line27>The sequence of numbers ends when the sum of the current number and\n\\n<line28>INCREMENT would become greater than LAST.\n\\n<line29>FIRST, INCREMENT, and LAST are interpreted as floating point values.\n\\n<line30>INCREMENT is usually positive if FIRST is smaller than LAST, and\n\\n<line31>INCREMENT is usually negative if FIRST is greater than LAST.\n\\n<line32>INCREMENT must not be 0; none of FIRST, INCREMENT and LAST may be NaN.\n\\n<line33>"), stdout);\n<line34>fputs (_("\\n<line35>FORMAT must be suitable for printing one argument of type 'double';\n\\n<line36>it defaults to %.PRECf if FIRST, INCREMENT, and LAST are all fixed point\n\\n<line37>decimal numbers with maximum precision PREC, and to %g otherwise.\n\\n<line38>"), stdout);\n<line39>emit_ancillary_info (PROGRAM_NAME);\n<line40>}\n<line41>exit (status);\n<line42>}
----------------------------------------
Function: scan_arg
Content: <line0>static operand\n<line1>scan_arg (char const *arg)\n<line2>{\n<line3>operand ret;\n<line4>if (! xstrtold (arg, nullptr, &ret.value, cl_strtold))\n<line5>{\n<line6>error (0, 0, _("invalid floating point argument: %s"), quote (arg));\n<line7>usage (EXIT_FAILURE);\n<line8>}\n<line9>if (isnan (ret.value))\n<line10>{\n<line11>error (0, 0, _("invalid %s argument: %s"), quote_n (0, "not-a-number"),\n<line12>quote_n (1, arg));\n<line13>usage (EXIT_FAILURE);\n<line14>}\n<line15>/* We don't output spaces or '+' so don't include in width */\n<line16>while (isspace (to_uchar (*arg)) || *arg == '+')\n<line17>arg++;\n<line18>/* Default to auto width and precision.  */\n<line19>ret.width = 0;\n<line20>ret.precision = INT_MAX;\n<line21>/* Use no precision (and possibly fast generation) for integers.  */\n<line22>char const *decimal_point = strchr (arg, '.');\n<line23>if (! decimal_point && ! strchr (arg, 'p') /* not a hex float */)\n<line24>ret.precision = 0;\n<line25>/* auto set width and precision for decimal inputs.  */\n<line26>if (! arg[strcspn (arg, "xX")] && isfinite (ret.value))\n<line27>{\n<line28>size_t fraction_len = 0;\n<line29>ret.width = strlen (arg);\n<line30>if (decimal_point)\n<line31>{\n<line32>fraction_len = strcspn (decimal_point + 1, "eE");\n<line33>if (fraction_len <= INT_MAX)\n<line34>ret.precision = fraction_len;\n<line35>ret.width += (fraction_len == 0                      /* #.  -> #   */\n<line36>? -1\n<line37>: (decimal_point == arg                /* .#  -> 0.# */\n<line38>|| ! ISDIGIT (decimal_point[-1]))); /* -.# -> 0.# */\n<line39>}\n<line40>char const *e = strchr (arg, 'e');\n<line41>if (! e)\n<line42>e = strchr (arg, 'E');\n<line43>if (e)\n<line44>{\n<line45>long exponent = MAX (strtol (e + 1, nullptr, 10), -LONG_MAX);\n<line46>ret.precision += exponent < 0 ? -exponent\n<line47>: - MIN (ret.precision, exponent);\n<line48>/* Don't account for e.... in the width since this is not output.  */\n<line49>ret.width -= strlen (arg) - (e - arg);\n<line50>/* Adjust the width as per the exponent.  */\n<line51>if (exponent < 0)\n<line52>{\n<line53>if (decimal_point)\n<line54>{\n<line55>if (e == decimal_point + 1) /* undo #. -> # above  */\n<line56>ret.width++;\n<line57>}\n<line58>else\n<line59>ret.width++;\n<line60>exponent = -exponent;\n<line61>}\n<line62>else\n<line63>{\n<line64>if (decimal_point && ret.precision == 0 && fraction_len)\n<line65>ret.width--; /* discount space for '.'  */\n<line66>exponent -= MIN (fraction_len, exponent);\n<line67>}\n<line68>ret.width += exponent;\n<line69>}\n<line70>}\n<line71>return ret;\n<line72>}
----------------------------------------
Function: long_double_format
Content: <line0>static char const *\n<line1>long_double_format (char const *fmt, struct layout *layout)\n<line2>{\n<line3>size_t i;\n<line4>size_t prefix_len = 0;\n<line5>size_t suffix_len = 0;\n<line6>size_t length_modifier_offset;\n<line7>bool has_L;\n<line8>for (i = 0; ! (fmt[i] == '%' && fmt[i + 1] != '%'); i += (fmt[i] == '%') + 1)\n<line9>{\n<line10>if (!fmt[i])\n<line11>error (EXIT_FAILURE, 0,\n<line12>_("format %s has no %% directive"), quote (fmt));\n<line13>prefix_len++;\n<line14>}\n<line15>i++;\n<line16>i += strspn (fmt + i, "-+#0 '");\n<line17>i += strspn (fmt + i, "0123456789");\n<line18>if (fmt[i] == '.')\n<line19>{\n<line20>i++;\n<line21>i += strspn (fmt + i, "0123456789");\n<line22>}\n<line23>length_modifier_offset = i;\n<line24>has_L = (fmt[i] == 'L');\n<line25>i += has_L;\n<line26>if (fmt[i] == '\0')\n<line27>error (EXIT_FAILURE, 0, _("format %s ends in %%"), quote (fmt));\n<line28>if (! strchr ("efgaEFGA", fmt[i]))\n<line29>error (EXIT_FAILURE, 0,\n<line30>_("format %s has unknown %%%c directive"), quote (fmt), fmt[i]);\n<line31>for (i++; ; i += (fmt[i] == '%') + 1)\n<line32>if (fmt[i] == '%' && fmt[i + 1] != '%')\n<line33>error (EXIT_FAILURE, 0, _("format %s has too many %% directives"),\n<line34>quote (fmt));\n<line35>else if (fmt[i])\n<line36>suffix_len++;\n<line37>else\n<line38>{\n<line39>size_t format_size = i + 1;\n<line40>char *ldfmt = xmalloc (format_size + 1);\n<line41>memcpy (ldfmt, fmt, length_modifier_offset);\n<line42>ldfmt[length_modifier_offset] = 'L';\n<line43>strcpy (ldfmt + length_modifier_offset + 1,\n<line44>fmt + length_modifier_offset + has_L);\n<line45>layout->prefix_len = prefix_len;\n<line46>layout->suffix_len = suffix_len;\n<line47>return ldfmt;\n<line48>}\n<line49>}
----------------------------------------
Function: print_numbers
Content: <line0>static void\n<line1>print_numbers (char const *fmt, struct layout layout,\n<line2>long double first, long double step, long double last)\n<line3>{\n<line4>bool out_of_range = (step < 0 ? first < last : last < first);\n<line5>if (! out_of_range)\n<line6>{\n<line7>long double x = first;\n<line8>long double i;\n<line9>for (i = 1; ; i++)\n<line10>{\n<line11>long double x0 = x;\n<line12>if (printf (fmt, x) < 0)\n<line13>write_error ();\n<line14>if (out_of_range)\n<line15>break;\n<line16>x = first + i * step;\n<line17>out_of_range = (step < 0 ? x < last : last < x);\n<line18>if (out_of_range)\n<line19>{\n<line20>/* If the number just past LAST prints as a value equal\n<line21>to LAST, and prints differently from the previous\n<line22>number, then print the number.  This avoids problems\n<line23>with rounding.  For example, with the x86 it causes\n<line24>"seq 0 0.000001 0.000003" to print 0.000003 instead\n<line25>of stopping at 0.000002.  */\n<line26>bool print_extra_number = false;\n<line27>long double x_val;\n<line28>char *x_str;\n<line29>int x_strlen;\n<line30>if (locale_ok)\n<line31>setlocale (LC_NUMERIC, "C");\n<line32>x_strlen = asprintf (&x_str, fmt, x);\n<line33>if (locale_ok)\n<line34>setlocale (LC_NUMERIC, "");\n<line35>if (x_strlen < 0)\n<line36>xalloc_die ();\n<line37>x_str[x_strlen - layout.suffix_len] = '\0';\n<line38>if (xstrtold (x_str + layout.prefix_len, nullptr,\n<line39>&x_val, cl_strtold)\n<line40>&& x_val == last)\n<line41>{\n<line42>char *x0_str = nullptr;\n<line43>int x0_strlen = asprintf (&x0_str, fmt, x0);\n<line44>if (x0_strlen < 0)\n<line45>xalloc_die ();\n<line46>x0_str[x0_strlen - layout.suffix_len] = '\0';\n<line47>print_extra_number = !STREQ (x0_str, x_str);\n<line48>free (x0_str);\n<line49>}\n<line50>free (x_str);\n<line51>if (! print_extra_number)\n<line52>break;\n<line53>}\n<line54>if (fputs (separator, stdout) == EOF)\n<line55>write_error ();\n<line56>}\n<line57>if (fputs (terminator, stdout) == EOF)\n<line58>write_error ();\n<line59>}\n<line60>}
----------------------------------------
Function: get_default_format
Content: <line0>static char const *\n<line1>get_default_format (operand first, operand step, operand last)\n<line2>{\n<line3>static char format_buf[sizeof "%0.Lf" + 2 * INT_STRLEN_BOUND (int)];\n<line4>int prec = MAX (first.precision, step.precision);\n<line5>if (prec != INT_MAX && last.precision != INT_MAX)\n<line6>{\n<line7>if (equal_width)\n<line8>{\n<line9>/* increase first_width by any increased precision in step */\n<line10>size_t first_width = first.width + (prec - first.precision);\n<line11>/* adjust last_width to use precision from first/step */\n<line12>size_t last_width = last.width + (prec - last.precision);\n<line13>if (last.precision && prec == 0)\n<line14>last_width--;  /* don't include space for '.' */\n<line15>if (last.precision == 0 && prec)\n<line16>last_width++;  /* include space for '.' */\n<line17>if (first.precision == 0 && prec)\n<line18>first_width++;  /* include space for '.' */\n<line19>size_t width = MAX (first_width, last_width);\n<line20>if (width <= INT_MAX)\n<line21>{\n<line22>int w = width;\n<line23>sprintf (format_buf, "%%0%d.%dLf", w, prec);\n<line24>return format_buf;\n<line25>}\n<line26>}\n<line27>else\n<line28>{\n<line29>sprintf (format_buf, "%%.%dLf", prec);\n<line30>return format_buf;\n<line31>}\n<line32>}\n<line33>return "%Lg";\n<line34>}
----------------------------------------
Function: incr
Content: <line0>static void\n<line1>incr (char **s0, size_t *s_len)\n<line2>{\n<line3>char *s = *s0;\n<line4>char *endp = s + *s_len - 1;\n<line5>do\n<line6>{\n<line7>if ((*endp)++ < '9')\n<line8>return;\n<line9>*endp-- = '0';\n<line10>}\n<line11>while (endp >= s);\n<line12>*--(*s0) = '1';\n<line13>++*s_len;\n<line14>}
----------------------------------------
Function: cmp
Content: <line0>static int\n<line1>cmp (char const *a, size_t a_len, char const *b, size_t b_len)\n<line2>{\n<line3>if (a_len < b_len)\n<line4>return -1;\n<line5>if (b_len < a_len)\n<line6>return 1;\n<line7>return (memcmp (a, b, a_len));\n<line8>}
----------------------------------------
Function: seq_fast
Content: <line0>static void\n<line1>seq_fast (char const *a, char const *b, uintmax_t step)\n<line2>{\n<line3>bool inf = STREQ (b, "inf");\n<line4>/* Skip past any leading 0's.  Without this, our naive cmp\n<line5>function would declare 000 to be larger than 99.  */\n<line6>a = trim_leading_zeros (a);\n<line7>b = trim_leading_zeros (b);\n<line8>size_t p_len = strlen (a);\n<line9>size_t q_len = inf ? 0 : strlen (b);\n<line10>/* Allow for at least 31 digits without realloc.\n<line11>1 more than p_len is needed for the inf case.  */\n<line12>#define INITIAL_ALLOC_DIGITS 31\n<line13>size_t inc_size = MAX (MAX (p_len + 1, q_len), INITIAL_ALLOC_DIGITS);\n<line14>/* Ensure we only increase by at most 1 digit at buffer boundaries.  */\n<line15>static_assert (SEQ_FAST_STEP_LIMIT_DIGITS < INITIAL_ALLOC_DIGITS - 1);\n<line16>/* Copy input strings (incl NUL) to end of new buffers.  */\n<line17>char *p0 = xmalloc (inc_size + 1);\n<line18>char *p = memcpy (p0 + inc_size - p_len, a, p_len + 1);\n<line19>char *q;\n<line20>char *q0;\n<line21>if (! inf)\n<line22>{\n<line23>q0 = xmalloc (inc_size + 1);\n<line24>q = memcpy (q0 + inc_size - q_len, b, q_len + 1);\n<line25>}\n<line26>else\n<line27>q = q0 = nullptr;\n<line28>bool ok = inf || cmp (p, p_len, q, q_len) <= 0;\n<line29>if (ok)\n<line30>{\n<line31>/* Reduce number of fwrite calls which is seen to\n<line32>give a speed-up of more than 2x over the unbuffered code\n<line33>when printing the first 10^9 integers.  */\n<line34>size_t buf_size = MAX (BUFSIZ, (inc_size + 1) * 2);\n<line35>char *buf = xmalloc (buf_size);\n<line36>char const *buf_end = buf + buf_size;\n<line37>char *bufp = buf;\n<line38>/* Write first number to buffer.  */\n<line39>bufp = mempcpy (bufp, p, p_len);\n<line40>/* Append separator then number.  */\n<line41>while (true)\n<line42>{\n<line43>for (uintmax_t n_incr = step; n_incr; n_incr--)\n<line44>incr (&p, &p_len);\n<line45>if (! inf && 0 < cmp (p, p_len, q, q_len))\n<line46>break;\n<line47>*bufp++ = *separator;\n<line48>/* Double up the buffers when needed for the inf case.  */\n<line49>if (p_len == inc_size)\n<line50>{\n<line51>inc_size *= 2;\n<line52>p0 = xrealloc (p0, inc_size + 1);\n<line53>p = memmove (p0 + p_len, p0, p_len + 1);\n<line54>if (buf_size < (inc_size + 1) * 2)\n<line55>{\n<line56>size_t buf_offset = bufp - buf;\n<line57>buf_size = (inc_size + 1) * 2;\n<line58>buf = xrealloc (buf, buf_size);\n<line59>buf_end = buf + buf_size;\n<line60>bufp = buf + buf_offset;\n<line61>}\n<line62>}\n<line63>bufp = mempcpy (bufp, p, p_len);\n<line64>/* If no place for another separator + number then\n<line65>output buffer so far, and reset to start of buffer.  */\n<line66>if (buf_end - (p_len + 1) < bufp)\n<line67>{\n<line68>if (fwrite (buf, bufp - buf, 1, stdout) != 1)\n<line69>write_error ();\n<line70>bufp = buf;\n<line71>}\n<line72>}\n<line73>/* Write any remaining buffered output, and the terminator.  */\n<line74>*bufp++ = *terminator;\n<line75>if (fwrite (buf, bufp - buf, 1, stdout) != 1)\n<line76>write_error ();\n<line77>}\n<line78>if (ok)\n<line79>exit (EXIT_SUCCESS);\n<line80>free (p0);\n<line81>free (q0);\n<line82>}
----------------------------------------
Function: main
Content: <line0>int\n<line1>main (int argc, char **argv)\n<line2>{\n<line3>int optc;\n<line4>operand first = { 1, 1, 0 };\n<line5>operand step = { 1, 1, 0 };\n<line6>operand last;\n<line7>struct layout layout = { 0, 0 };\n<line8>/* The printf(3) format used for output.  */\n<line9>char const *format_str = nullptr;\n<line10>initialize_main (&argc, &argv);\n<line11>set_program_name (argv[0]);\n<line12>locale_ok = !!setlocale (LC_ALL, "");\n<line13>bindtextdomain (PACKAGE, LOCALEDIR);\n<line14>textdomain (PACKAGE);\n<line15>atexit (close_stdout);\n<line16>equal_width = false;\n<line17>separator = "\n";\n<line18>/* We have to handle negative numbers in the command line but this\n<line19>conflicts with the command line arguments.  So explicitly check first\n<line20>whether the next argument looks like a negative number.  */\n<line21>while (optind < argc)\n<line22>{\n<line23>if (argv[optind][0] == '-'\n<line24>&& ((optc = argv[optind][1]) == '.' || ISDIGIT (optc)))\n<line25>{\n<line26>/* means negative number */\n<line27>break;\n<line28>}\n<line29>optc = getopt_long (argc, argv, "+f:s:w", long_options, nullptr);\n<line30>if (optc == -1)\n<line31>break;\n<line32>switch (optc)\n<line33>{\n<line34>case 'f':\n<line35>format_str = optarg;\n<line36>break;\n<line37>case 's':\n<line38>separator = optarg;\n<line39>break;\n<line40>case 'w':\n<line41>equal_width = true;\n<line42>break;\n<line43>case_GETOPT_HELP_CHAR;\n<line44>case_GETOPT_VERSION_CHAR (PROGRAM_NAME, AUTHORS);\n<line45>default:\n<line46>usage (EXIT_FAILURE);\n<line47>}\n<line48>}\n<line49>int n_args = argc - optind;\n<line50>if (n_args < 1)\n<line51>{\n<line52>error (0, 0, _("missing operand"));\n<line53>usage (EXIT_FAILURE);\n<line54>}\n<line55>if (3 < n_args)\n<line56>{\n<line57>error (0, 0, _("extra operand %s"), quote (argv[optind + 3]));\n<line58>usage (EXIT_FAILURE);\n<line59>}\n<line60>if (format_str)\n<line61>format_str = long_double_format (format_str, &layout);\n<line62>if (format_str != nullptr && equal_width)\n<line63>{\n<line64>error (0, 0, _("format string may not be specified"\n<line65>" when printing equal width strings"));\n<line66>usage (EXIT_FAILURE);\n<line67>}\n<line68>/* If the following hold:\n<line69>- no format string, [FIXME: relax this, eventually]\n<line70>- integer start (or no start)\n<line71>- integer end\n<line72>- integer increment <= SEQ_FAST_STEP_LIMIT\n<line73>then use the much more efficient integer-only code,\n<line74>operating on arbitrarily large numbers.  */\n<line75>bool fast_step_ok = false;\n<line76>if (n_args != 3\n<line77>|| (all_digits_p (argv[optind + 1])\n<line78>&& xstrtold (argv[optind + 1], nullptr, &step.value, cl_strtold)\n<line79>&& 0 < step.value && step.value <= SEQ_FAST_STEP_LIMIT))\n<line80>fast_step_ok = true;\n<line81>if (all_digits_p (argv[optind])\n<line82>&& (n_args == 1 || all_digits_p (argv[optind + 1]))\n<line83>&& (n_args < 3 || (fast_step_ok\n<line84>&& all_digits_p (argv[optind + 2])))\n<line85>&& !equal_width && !format_str && strlen (separator) == 1)\n<line86>{\n<line87>char const *s1 = n_args == 1 ? "1" : argv[optind];\n<line88>char const *s2 = argv[optind + (n_args - 1)];\n<line89>seq_fast (s1, s2, step.value);\n<line90>/* Upon any failure, let the more general code deal with it.  */\n<line91>}\n<line92>last = scan_arg (argv[optind++]);\n<line93>if (optind < argc)\n<line94>{\n<line95>first = last;\n<line96>last = scan_arg (argv[optind++]);\n<line97>if (optind < argc)\n<line98>{\n<line99>step = last;\n<line100>if (step.value == 0)\n<line101>{\n<line102>error (0, 0, _("invalid Zero increment value: %s"),\n<line103>quote (argv[optind - 1]));\n<line104>usage (EXIT_FAILURE);\n<line105>}\n<line106>last = scan_arg (argv[optind++]);\n<line107>}\n<line108>}\n<line109>/* Try the fast method again, for integers of the form 1e1 etc.,\n<line110>or "inf" end value.  */\n<line111>if (first.precision == 0 && step.precision == 0 && last.precision == 0\n<line112>&& isfinite (first.value) && 0 <= first.value && 0 <= last.value\n<line113>&& 0 < step.value && step.value <= SEQ_FAST_STEP_LIMIT\n<line114>&& !equal_width && !format_str && strlen (separator) == 1)\n<line115>{\n<line116>char *s1;\n<line117>char *s2;\n<line118>if (asprintf (&s1, "%0.Lf", first.value) < 0)\n<line119>xalloc_die ();\n<line120>if (! isfinite (last.value))\n<line121>s2 = xstrdup ("inf"); /* Ensure "inf" is used.  */\n<line122>else if (asprintf (&s2, "%0.Lf", last.value) < 0)\n<line123>xalloc_die ();\n<line124>if (*s1 != '-' && *s2 != '-')\n<line125>seq_fast (s1, s2, step.value);\n<line126>free (s1);\n<line127>free (s2);\n<line128>/* Upon any failure, let the more general code deal with it.  */\n<line129>}\n<line130>if (format_str == nullptr)\n<line131>format_str = get_default_format (first, step, last);\n<line132>print_numbers (format_str, layout, first.value, step.value, last.value);\n<line133>main_exit (EXIT_SUCCESS);\n<line134>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/src/digest.c
========================================
Function: usage
Content: <line0>void\n<line1>usage (int status)\n<line2>{\n<line3>if (status != EXIT_SUCCESS)\n<line4>emit_try_help ();\n<line5>else\n<line6>{\n<line7>printf (_("\\n<line8>Usage: %s [OPTION]... [FILE]...\n\\n<line9>"), program_name);\n<line10>#if HASH_ALGO_CKSUM\n<line11>fputs (_("\\n<line12>Print or verify checksums.\n\\n<line13>By default use the 32 bit CRC algorithm.\n\\n<line14>"), stdout);\n<line15>#else\n<line16>printf (_("\\n<line17>Print or check %s (%d-bit) checksums.\n\\n<line18>"),\n<line19>DIGEST_TYPE_STRING,\n<line20>DIGEST_BITS);\n<line21>#endif\n<line22>emit_stdin_note ();\n<line23>#if HASH_ALGO_SUM\n<line24>fputs (_("\\n<line25>\n\\n<line26>-r              use BSD sum algorithm (the default), use 1K blocks\n\\n<line27>-s, --sysv      use System V sum algorithm, use 512 bytes blocks\n\\n<line28>"), stdout);\n<line29>#endif\n<line30>#if HASH_ALGO_BLAKE2 || HASH_ALGO_CKSUM\n<line31>emit_mandatory_arg_note ();\n<line32>#endif\n<line33>#if HASH_ALGO_CKSUM\n<line34>fputs (_("\\n<line35>-a, --algorithm=TYPE  select the digest type to use.  See DIGEST below.\\n<line36>\n\\n<line37>"), stdout);\n<line38>fputs (_("\\n<line39>--base64          emit base64-encoded digests, not hexadecimal\\n<line40>\n\\n<line41>"), stdout);\n<line42>#endif\n<line43>#if !HASH_ALGO_SUM\n<line44># if !HASH_ALGO_CKSUM\n<line45>if (O_BINARY)\n<line46>fputs (_("\\n<line47>-b, --binary          read in binary mode (default unless reading tty stdin)\\n<line48>\n\\n<line49>"), stdout);\n<line50>else\n<line51>fputs (_("\\n<line52>-b, --binary          read in binary mode\n\\n<line53>"), stdout);\n<line54># endif\n<line55>fputs (_("\\n<line56>-c, --check           read checksums from the FILEs and check them\n\\n<line57>"), stdout);\n<line58># if HASH_ALGO_BLAKE2 || HASH_ALGO_CKSUM\n<line59>fputs (_("\\n<line60>-l, --length=BITS     digest length in bits; must not exceed the max for\n\\n<line61>the blake2 algorithm and must be a multiple of 8\n\\n<line62>"), stdout);\n<line63># endif\n<line64># if HASH_ALGO_CKSUM\n<line65>fputs (_("\\n<line66>--raw             emit a raw binary digest, not hexadecimal\\n<line67>\n\\n<line68>"), stdout);\n<line69>fputs (_("\\n<line70>--tag             create a BSD-style checksum (the default)\n\\n<line71>"), stdout);\n<line72>fputs (_("\\n<line73>--untagged        create a reversed style checksum, without digest type\n\\n<line74>"), stdout);\n<line75># else\n<line76>fputs (_("\\n<line77>--tag             create a BSD-style checksum\n\\n<line78>"), stdout);\n<line79># endif\n<line80># if !HASH_ALGO_CKSUM\n<line81>if (O_BINARY)\n<line82>fputs (_("\\n<line83>-t, --text            read in text mode (default if reading tty stdin)\n\\n<line84>"), stdout);\n<line85>else\n<line86>fputs (_("\\n<line87>-t, --text            read in text mode (default)\n\\n<line88>"), stdout);\n<line89># endif\n<line90>fputs (_("\\n<line91>-z, --zero            end each output line with NUL, not newline,\n\\n<line92>and disable file name escaping\n\\n<line93>"), stdout);\n<line94>fputs (_("\\n<line95>\n\\n<line96>The following five options are useful only when verifying checksums:\n\\n<line97>--ignore-missing  don't fail or report status for missing files\n\\n<line98>--quiet           don't print OK for each successfully verified file\n\\n<line99>--status          don't output anything, status code shows success\n\\n<line100>--strict          exit non-zero for improperly formatted checksum lines\n\\n<line101>-w, --warn            warn about improperly formatted checksum lines\n\\n<line102>\n\\n<line103>"), stdout);\n<line104>#endif\n<line105>#if HASH_ALGO_CKSUM\n<line106>fputs (_("\\n<line107>--debug           indicate which implementation used\n\\n<line108>"), stdout);\n<line109>#endif\n<line110>fputs (HELP_OPTION_DESCRIPTION, stdout);\n<line111>fputs (VERSION_OPTION_DESCRIPTION, stdout);\n<line112>#if HASH_ALGO_CKSUM\n<line113>fputs (_("\\n<line114>\n\\n<line115>DIGEST determines the digest algorithm and default output format:\n\\n<line116>sysv      (equivalent to sum -s)\n\\n<line117>bsd       (equivalent to sum -r)\n\\n<line118>crc       (equivalent to cksum)\n\\n<line119>md5       (equivalent to md5sum)\n\\n<line120>sha1      (equivalent to sha1sum)\n\\n<line121>sha224    (equivalent to sha224sum)\n\\n<line122>sha256    (equivalent to sha256sum)\n\\n<line123>sha384    (equivalent to sha384sum)\n\\n<line124>sha512    (equivalent to sha512sum)\n\\n<line125>blake2b   (equivalent to b2sum)\n\\n<line126>sm3       (only available through cksum)\n\\n<line127>\n"), stdout);\n<line128>#endif\n<line129>#if !HASH_ALGO_SUM && !HASH_ALGO_CKSUM\n<line130>printf (_("\\n<line131>\n\\n<line132>The sums are computed as described in %s.\n"), DIGEST_REFERENCE);\n<line133>fputs (_("\\n<line134>When checking, the input should be a former output of this program.\n\\n<line135>The default mode is to print a line with: checksum, a space,\n\\n<line136>a character indicating input mode ('*' for binary, ' ' for text\n\\n<line137>or where binary is insignificant), and name for each FILE.\n\\n<line138>\n\\n<line139>Note: There is no difference between binary mode and text mode on GNU systems.\\n<line140>\n"), stdout);\n<line141>#endif\n<line142>#if HASH_ALGO_CKSUM\n<line143>fputs (_("\\n<line144>When checking, the input should be a former output of this program,\n\\n<line145>or equivalent standalone program.\\n<line146>\n"), stdout);\n<line147>#endif\n<line148>emit_ancillary_info (PROGRAM_NAME);\n<line149>}\n<line150>exit (status);\n<line151>}
----------------------------------------
Function: filename_unescape
Content: <line0>static char *\n<line1>filename_unescape (char *s, size_t s_len)\n<line2>{\n<line3>char *dst = s;\n<line4>for (size_t i = 0; i < s_len; i++)\n<line5>{\n<line6>switch (s[i])\n<line7>{\n<line8>case '\\':\n<line9>if (i == s_len - 1)\n<line10>{\n<line11>/* File name ends with an unescaped backslash: invalid.  */\n<line12>return nullptr;\n<line13>}\n<line14>++i;\n<line15>switch (s[i])\n<line16>{\n<line17>case 'n':\n<line18>*dst++ = '\n';\n<line19>break;\n<line20>case 'r':\n<line21>*dst++ = '\r';\n<line22>break;\n<line23>case '\\':\n<line24>*dst++ = '\\';\n<line25>break;\n<line26>default:\n<line27>/* Only '\', 'n' or 'r' may follow a backslash.  */\n<line28>return nullptr;\n<line29>}\n<line30>break;\n<line31>case '\0':\n<line32>/* The file name may not contain a NUL.  */\n<line33>return nullptr;\n<line34>default:\n<line35>*dst++ = s[i];\n<line36>break;\n<line37>}\n<line38>}\n<line39>if (dst < s + s_len)\n<line40>*dst = '\0';\n<line41>return s;\n<line42>}
----------------------------------------
Function: bsd_split_3
Content: <line0>static bool\n<line1>bsd_split_3 (char *s, size_t s_len,\n<line2>unsigned char **digest, size_t *d_len,\n<line3>char **file_name, bool escaped_filename)\n<line4>{\n<line5>if (s_len == 0)\n<line6>return false;\n<line7>/* Find end of filename.  */\n<line8>size_t i = s_len - 1;\n<line9>while (i && s[i] != ')')\n<line10>i--;\n<line11>if (s[i] != ')')\n<line12>return false;\n<line13>*file_name = s;\n<line14>if (escaped_filename && filename_unescape (s, i) == nullptr)\n<line15>return false;\n<line16>s[i++] = '\0';\n<line17>while (ISWHITE (s[i]))\n<line18>i++;\n<line19>if (s[i] != '=')\n<line20>return false;\n<line21>i++;\n<line22>while (ISWHITE (s[i]))\n<line23>i++;\n<line24>*digest = (unsigned char *) &s[i];\n<line25>*d_len = s_len - i;\n<line26>return valid_digits (*digest, *d_len);\n<line27>}
----------------------------------------
Function: split_3
Content: <line0>static bool\n<line1>split_3 (char *s, size_t s_len,\n<line2>unsigned char **digest, size_t *d_len, int *binary, char **file_name)\n<line3>{\n<line4>bool escaped_filename = false;\n<line5>size_t algo_name_len;\n<line6>size_t i = 0;\n<line7>while (ISWHITE (s[i]))\n<line8>++i;\n<line9>if (s[i] == '\\')\n<line10>{\n<line11>++i;\n<line12>escaped_filename = true;\n<line13>}\n<line14>/* Check for BSD-style checksum line. */\n<line15>#if HASH_ALGO_CKSUM\n<line16>if (! algorithm_specified)\n<line17>{\n<line18>ptrdiff_t algo_tag = algorithm_from_tag (s + i);\n<line19>if (algo_tag >= 0)\n<line20>{\n<line21>if (algo_tag <= crc)\n<line22>return false;  /* We don't support checking these older formats.  */\n<line23>cksum_algorithm = algo_tag;\n<line24>}\n<line25>else\n<line26>return false;  /* We only support tagged format without -a.  */\n<line27>}\n<line28>#endif\n<line29>algo_name_len = strlen (DIGEST_TYPE_STRING);\n<line30>if (STREQ_LEN (s + i, DIGEST_TYPE_STRING, algo_name_len))\n<line31>{\n<line32>i += algo_name_len;\n<line33>#if HASH_ALGO_BLAKE2 || HASH_ALGO_CKSUM\n<line34>/* Terminate and match algorithm name.  */\n<line35>char const *algo_name = &s[i - algo_name_len];\n<line36>bool length_specified = s[i] == '-';\n<line37>bool openssl_format = s[i] == '('; /* and no length_specified */\n<line38>s[i++] = '\0';\n<line39>if (!STREQ (algo_name, DIGEST_TYPE_STRING))\n<line40>return false;\n<line41>if (openssl_format)\n<line42>s[--i] = '(';\n<line43># if HASH_ALGO_BLAKE2\n<line44>digest_length = BLAKE2B_MAX_LEN * 8;\n<line45># else\n<line46>digest_length = algorithm_bits[cksum_algorithm];\n<line47># endif\n<line48>if (length_specified)\n<line49>{\n<line50>uintmax_t length;\n<line51>char *siend;\n<line52>if (! (xstrtoumax (s + i, &siend, 0, &length, nullptr) == LONGINT_OK\n<line53>&& 0 < length && length <= digest_length\n<line54>&& length % 8 == 0))\n<line55>return false;\n<line56>i = siend - s;\n<line57>digest_length = length;\n<line58>}\n<line59>digest_hex_bytes = digest_length / 4;\n<line60>#endif\n<line61>if (s[i] == ' ')\n<line62>++i;\n<line63>if (s[i] == '(')\n<line64>{\n<line65>++i;\n<line66>*binary = 0;\n<line67>return bsd_split_3 (s + i, s_len - i,\n<line68>digest, d_len, file_name, escaped_filename);\n<line69>}\n<line70>return false;\n<line71>}\n<line72>/* Ignore this line if it is too short.\n<line73>Each line must have at least 'min_digest_line_length - 1' (or one more, if\n<line74>the first is a backslash) more characters to contain correct message digest\n<line75>information.  */\n<line76>if (s_len - i < min_digest_line_length + (s[i] == '\\'))\n<line77>return false;\n<line78>*digest = (unsigned char *) &s[i];\n<line79>#if HASH_ALGO_BLAKE2 || HASH_ALGO_CKSUM\n<line80>/* Auto determine length.  */\n<line81># if HASH_ALGO_CKSUM\n<line82>if (cksum_algorithm == blake2b) {\n<line83># endif\n<line84>unsigned char const *hp = *digest;\n<line85>digest_hex_bytes = 0;\n<line86>while (isxdigit (*hp++))\n<line87>digest_hex_bytes++;\n<line88>if (digest_hex_bytes < 2 || digest_hex_bytes % 2\n<line89>|| BLAKE2B_MAX_LEN * 2 < digest_hex_bytes)\n<line90>return false;\n<line91>digest_length = digest_hex_bytes * 4;\n<line92># if HASH_ALGO_CKSUM\n<line93>}\n<line94># endif\n<line95>#endif\n<line96>/* This field must be the hexadecimal or base64 representation\n<line97>of the message digest.  */\n<line98>while (s[i] && !ISWHITE (s[i]))\n<line99>i++;\n<line100>/* The digest must be followed by at least one whitespace character.  */\n<line101>if (i == s_len)\n<line102>return false;\n<line103>*d_len = &s[i] - (char *) *digest;\n<line104>s[i++] = '\0';\n<line105>if (! valid_digits (*digest, *d_len))\n<line106>return false;\n<line107>/* If "bsd reversed" format detected.  */\n<line108>if ((s_len - i == 1) || (s[i] != ' ' && s[i] != '*'))\n<line109>{\n<line110>/* Don't allow mixing bsd and standard formats,\n<line111>to minimize security issues with attackers\n<line112>renaming files with leading spaces.\n<line113>This assumes that with bsd format checksums\n<line114>that the first file name does not have\n<line115>a leading ' ' or '*'.  */\n<line116>if (bsd_reversed == 0)\n<line117>return false;\n<line118>bsd_reversed = 1;\n<line119>}\n<line120>else if (bsd_reversed != 1)\n<line121>{\n<line122>bsd_reversed = 0;\n<line123>*binary = (s[i++] == '*');\n<line124>}\n<line125>/* All characters between the type indicator and end of line are\n<line126>significant -- that includes leading and trailing white space.  */\n<line127>*file_name = &s[i];\n<line128>if (escaped_filename)\n<line129>return filename_unescape (&s[i], s_len - i) != nullptr;\n<line130>return true;\n<line131>}
----------------------------------------
Function: print_filename
Content: <line0>static void\n<line1>print_filename (char const *file, bool escape)\n<line2>{\n<line3>if (! escape)\n<line4>{\n<line5>fputs (file, stdout);\n<line6>return;\n<line7>}\n<line8>while (*file)\n<line9>{\n<line10>switch (*file)\n<line11>{\n<line12>case '\n':\n<line13>fputs ("\\n", stdout);\n<line14>break;\n<line15>case '\r':\n<line16>fputs ("\\r", stdout);\n<line17>break;\n<line18>case '\\':\n<line19>fputs ("\\\\", stdout);\n<line20>break;\n<line21>default:\n<line22>putchar (*file);\n<line23>break;\n<line24>}\n<line25>file++;\n<line26>}\n<line27>}
----------------------------------------
Function: digest_file
Content: <line0>static bool\n<line1>digest_file (char const *filename, int *binary, unsigned char *bin_result,\n<line2>bool *missing, MAYBE_UNUSED uintmax_t *length)\n<line3>{\n<line4>FILE *fp;\n<line5>int err;\n<line6>bool is_stdin = STREQ (filename, "-");\n<line7>*missing = false;\n<line8>if (is_stdin)\n<line9>{\n<line10>have_read_stdin = true;\n<line11>fp = stdin;\n<line12>if (O_BINARY && *binary)\n<line13>{\n<line14>if (*binary < 0)\n<line15>*binary = ! isatty (STDIN_FILENO);\n<line16>if (*binary)\n<line17>xset_binary_mode (STDIN_FILENO, O_BINARY);\n<line18>}\n<line19>}\n<line20>else\n<line21>{\n<line22>fp = fopen (filename, (O_BINARY && *binary ? "rb" : "r"));\n<line23>if (fp == nullptr)\n<line24>{\n<line25>if (ignore_missing && errno == ENOENT)\n<line26>{\n<line27>*missing = true;\n<line28>return true;\n<line29>}\n<line30>error (0, errno, "%s", quotef (filename));\n<line31>return false;\n<line32>}\n<line33>}\n<line34>fadvise (fp, FADVISE_SEQUENTIAL);\n<line35>#if HASH_ALGO_CKSUM\n<line36>if (cksum_algorithm == blake2b)\n<line37>*length = digest_length / 8;\n<line38>err = DIGEST_STREAM (fp, bin_result, length);\n<line39>#elif HASH_ALGO_SUM\n<line40>err = DIGEST_STREAM (fp, bin_result, length);\n<line41>#elif HASH_ALGO_BLAKE2\n<line42>err = DIGEST_STREAM (fp, bin_result, digest_length / 8);\n<line43>#else\n<line44>err = DIGEST_STREAM (fp, bin_result);\n<line45>#endif\n<line46>err = err ? errno : 0;\n<line47>if (is_stdin)\n<line48>clearerr (fp);\n<line49>else if (fclose (fp) != 0 && !err)\n<line50>err = errno;\n<line51>if (err)\n<line52>{\n<line53>error (0, err, "%s", quotef (filename));\n<line54>return false;\n<line55>}\n<line56>return true;\n<line57>}
----------------------------------------
Function: output_file
Content: <line0>static void\n<line1>output_file (char const *file, int binary_file, void const *digest,\n<line2>bool raw, bool tagged, unsigned char delim, MAYBE_UNUSED bool args,\n<line3>MAYBE_UNUSED uintmax_t length)\n<line4>{\n<line5># if HASH_ALGO_CKSUM\n<line6>if (raw)\n<line7>{\n<line8>fwrite (digest, 1, digest_length / 8, stdout);\n<line9>return;\n<line10>}\n<line11># endif\n<line12>unsigned char const *bin_buffer = digest;\n<line13>/* Output a leading backslash if the file name contains problematic chars.  */\n<line14>bool needs_escape = delim == '\n' && problematic_chars (file);\n<line15>if (needs_escape)\n<line16>putchar ('\\');\n<line17>if (tagged)\n<line18>{\n<line19>fputs (DIGEST_TYPE_STRING, stdout);\n<line20># if HASH_ALGO_BLAKE2\n<line21>if (digest_length < BLAKE2B_MAX_LEN * 8)\n<line22>printf ("-%"PRIuMAX, digest_length);\n<line23># elif HASH_ALGO_CKSUM\n<line24>if (cksum_algorithm == blake2b)\n<line25>{\n<line26>if (digest_length < BLAKE2B_MAX_LEN * 8)\n<line27>printf ("-%"PRIuMAX, digest_length);\n<line28>}\n<line29># endif\n<line30>fputs (" (", stdout);\n<line31>print_filename (file, needs_escape);\n<line32>fputs (") = ", stdout);\n<line33>}\n<line34># if HASH_ALGO_CKSUM\n<line35>if (base64_digest)\n<line36>{\n<line37>char b64[BASE64_LENGTH (DIGEST_BIN_BYTES) + 1];\n<line38>base64_encode ((char const *) bin_buffer, digest_length / 8,\n<line39>b64, sizeof b64);\n<line40>fputs (b64, stdout);\n<line41>}\n<line42>else\n<line43># endif\n<line44>{\n<line45>for (size_t i = 0; i < (digest_hex_bytes / 2); ++i)\n<line46>printf ("%02x", bin_buffer[i]);\n<line47>}\n<line48>if (!tagged)\n<line49>{\n<line50>putchar (' ');\n<line51>putchar (binary_file ? '*' : ' ');\n<line52>print_filename (file, needs_escape);\n<line53>}\n<line54>putchar (delim);\n<line55>}
----------------------------------------
Function: hex_equal
Content: <line0>static bool\n<line1>hex_equal (unsigned char const *hex_digest, unsigned char const *bin_buffer)\n<line2>{\n<line3>static const char bin2hex[] = { '0', '1', '2', '3',\n<line4>'4', '5', '6', '7',\n<line5>'8', '9', 'a', 'b',\n<line6>'c', 'd', 'e', 'f' };\n<line7>size_t digest_bin_bytes = digest_hex_bytes / 2;\n<line8>/* Compare generated binary number with text representation\n<line9>in check file.  Ignore case of hex digits.  */\n<line10>size_t cnt;\n<line11>for (cnt = 0; cnt < digest_bin_bytes; ++cnt)\n<line12>{\n<line13>if (tolower (hex_digest[2 * cnt])\n<line14>!= bin2hex[bin_buffer[cnt] >> 4]\n<line15>|| (tolower (hex_digest[2 * cnt + 1])\n<line16>!= (bin2hex[bin_buffer[cnt] & 0xf])))\n<line17>break;\n<line18>}\n<line19>return cnt == digest_bin_bytes;\n<line20>}
----------------------------------------
Function: digest_check
Content: <line0>static bool\n<line1>digest_check (char const *checkfile_name)\n<line2>{\n<line3>FILE *checkfile_stream;\n<line4>uintmax_t n_misformatted_lines = 0;\n<line5>uintmax_t n_mismatched_checksums = 0;\n<line6>uintmax_t n_open_or_read_failures = 0;\n<line7>bool properly_formatted_lines = false;\n<line8>bool matched_checksums = false;\n<line9>unsigned char bin_buffer_unaligned[DIGEST_BIN_BYTES + DIGEST_ALIGN];\n<line10>/* Make sure bin_buffer is properly aligned. */\n<line11>unsigned char *bin_buffer = ptr_align (bin_buffer_unaligned, DIGEST_ALIGN);\n<line12>uintmax_t line_number;\n<line13>char *line;\n<line14>size_t line_chars_allocated;\n<line15>bool is_stdin = STREQ (checkfile_name, "-");\n<line16>if (is_stdin)\n<line17>{\n<line18>have_read_stdin = true;\n<line19>checkfile_name = _("standard input");\n<line20>checkfile_stream = stdin;\n<line21>}\n<line22>else\n<line23>{\n<line24>checkfile_stream = fopen (checkfile_name, "r");\n<line25>if (checkfile_stream == nullptr)\n<line26>{\n<line27>error (0, errno, "%s", quotef (checkfile_name));\n<line28>return false;\n<line29>}\n<line30>}\n<line31>line_number = 0;\n<line32>line = nullptr;\n<line33>line_chars_allocated = 0;\n<line34>do\n<line35>{\n<line36>char *filename;\n<line37>int binary;\n<line38>unsigned char *digest;\n<line39>ssize_t line_length;\n<line40>++line_number;\n<line41>if (line_number == 0)\n<line42>error (EXIT_FAILURE, 0, _("%s: too many checksum lines"),\n<line43>quotef (checkfile_name));\n<line44>line_length = getline (&line, &line_chars_allocated, checkfile_stream);\n<line45>if (line_length <= 0)\n<line46>break;\n<line47>/* Ignore comment lines, which begin with a '#' character.  */\n<line48>if (line[0] == '#')\n<line49>continue;\n<line50>/* Remove any trailing newline.  */\n<line51>line_length -= line[line_length - 1] == '\n';\n<line52>/* Remove any trailing carriage return.  */\n<line53>line_length -= line[line_length - (0 < line_length)] == '\r';\n<line54>/* Ignore empty lines.  */\n<line55>if (line_length == 0)\n<line56>continue;\n<line57>line[line_length] = '\0';\n<line58>size_t d_len;\n<line59>if (! (split_3 (line, line_length, &digest, &d_len, &binary, &filename)\n<line60>&& ! (is_stdin && STREQ (filename, "-"))))\n<line61>{\n<line62>++n_misformatted_lines;\n<line63>if (warn)\n<line64>{\n<line65>error (0, 0,\n<line66>_("%s: %" PRIuMAX\n<line67>": improperly formatted %s checksum line"),\n<line68>quotef (checkfile_name), line_number,\n<line69>DIGEST_TYPE_STRING);\n<line70>}\n<line71>}\n<line72>else\n<line73>{\n<line74>bool ok;\n<line75>bool missing;\n<line76>bool needs_escape = ! status_only && problematic_chars (filename);\n<line77>properly_formatted_lines = true;\n<line78>uintmax_t length;\n<line79>ok = digest_file (filename, &binary, bin_buffer, &missing, &length);\n<line80>if (!ok)\n<line81>{\n<line82>++n_open_or_read_failures;\n<line83>if (!status_only)\n<line84>{\n<line85>if (needs_escape)\n<line86>putchar ('\\');\n<line87>print_filename (filename, needs_escape);\n<line88>printf (": %s\n", _("FAILED open or read"));\n<line89>}\n<line90>}\n<line91>else if (ignore_missing && missing)\n<line92>{\n<line93>/* Ignore missing files with --ignore-missing.  */\n<line94>;\n<line95>}\n<line96>else\n<line97>{\n<line98>bool match = false;\n<line99>#if HASH_ALGO_CKSUM\n<line100>if (d_len < digest_hex_bytes)\n<line101>match = b64_equal (digest, bin_buffer);\n<line102>else\n<line103>#endif\n<line104>if (d_len == digest_hex_bytes)\n<line105>match = hex_equal (digest, bin_buffer);\n<line106>if (match)\n<line107>matched_checksums = true;\n<line108>else\n<line109>++n_mismatched_checksums;\n<line110>if (!status_only)\n<line111>{\n<line112>if (! match || ! quiet)\n<line113>{\n<line114>if (needs_escape)\n<line115>putchar ('\\');\n<line116>print_filename (filename, needs_escape);\n<line117>}\n<line118>if (! match)\n<line119>printf (": %s\n", _("FAILED"));\n<line120>else if (!quiet)\n<line121>printf (": %s\n", _("OK"));\n<line122>}\n<line123>}\n<line124>}\n<line125>}\n<line126>while (!feof (checkfile_stream) && !ferror (checkfile_stream));\n<line127>free (line);\n<line128>int err = ferror (checkfile_stream) ? 0 : -1;\n<line129>if (is_stdin)\n<line130>clearerr (checkfile_stream);\n<line131>else if (fclose (checkfile_stream) != 0 && err < 0)\n<line132>err = errno;\n<line133>if (0 <= err)\n<line134>{\n<line135>error (0, err, err ? "%s" : _("%s: read error"),\n<line136>quotef (checkfile_name));\n<line137>return false;\n<line138>}\n<line139>if (! properly_formatted_lines)\n<line140>{\n<line141>/* Warn if no tests are found.  */\n<line142>error (0, 0, _("%s: no properly formatted checksum lines found"),\n<line143>quotef (checkfile_name));\n<line144>}\n<line145>else\n<line146>{\n<line147>if (!status_only)\n<line148>{\n<line149>if (n_misformatted_lines != 0)\n<line150>error (0, 0,\n<line151>(ngettext\n<line152>("WARNING: %" PRIuMAX " line is improperly formatted",\n<line153>"WARNING: %" PRIuMAX " lines are improperly formatted",\n<line154>select_plural (n_misformatted_lines))),\n<line155>n_misformatted_lines);\n<line156>if (n_open_or_read_failures != 0)\n<line157>error (0, 0,\n<line158>(ngettext\n<line159>("WARNING: %" PRIuMAX " listed file could not be read",\n<line160>"WARNING: %" PRIuMAX " listed files could not be read",\n<line161>select_plural (n_open_or_read_failures))),\n<line162>n_open_or_read_failures);\n<line163>if (n_mismatched_checksums != 0)\n<line164>error (0, 0,\n<line165>(ngettext\n<line166>("WARNING: %" PRIuMAX " computed checksum did NOT match",\n<line167>"WARNING: %" PRIuMAX " computed checksums did NOT match",\n<line168>select_plural (n_mismatched_checksums))),\n<line169>n_mismatched_checksums);\n<line170>if (ignore_missing && ! matched_checksums)\n<line171>error (0, 0, _("%s: no file was verified"),\n<line172>quotef (checkfile_name));\n<line173>}\n<line174>}\n<line175>return (properly_formatted_lines\n<line176>&& matched_checksums\n<line177>&& n_mismatched_checksums == 0\n<line178>&& n_open_or_read_failures == 0\n<line179>&& (!strict || n_misformatted_lines == 0));\n<line180>}
----------------------------------------
Function: main
Content: <line0>int\n<line1>main (int argc, char **argv)\n<line2>{\n<line3>unsigned char bin_buffer_unaligned[DIGEST_BIN_BYTES + DIGEST_ALIGN];\n<line4>/* Make sure bin_buffer is properly aligned. */\n<line5>unsigned char *bin_buffer = ptr_align (bin_buffer_unaligned, DIGEST_ALIGN);\n<line6>bool do_check = false;\n<line7>int opt;\n<line8>bool ok = true;\n<line9>int binary = -1;\n<line10>#if HASH_ALGO_CKSUM\n<line11>bool prefix_tag = true;\n<line12>#else\n<line13>bool prefix_tag = false;\n<line14>#endif\n<line15>/* Setting values of global variables.  */\n<line16>initialize_main (&argc, &argv);\n<line17>set_program_name (argv[0]);\n<line18>setlocale (LC_ALL, "");\n<line19>bindtextdomain (PACKAGE, LOCALEDIR);\n<line20>textdomain (PACKAGE);\n<line21>atexit (close_stdout);\n<line22>/* Line buffer stdout to ensure lines are written atomically and immediately\n<line23>so that processes running in parallel do not intersperse their output.  */\n<line24>setvbuf (stdout, nullptr, _IOLBF, 0);\n<line25>#if HASH_ALGO_SUM\n<line26>char const *short_opts = "rs";\n<line27>#elif HASH_ALGO_CKSUM\n<line28>char const *short_opts = "a:l:bctwz";\n<line29>char const *digest_length_str = "";\n<line30>#elif HASH_ALGO_BLAKE2\n<line31>char const *short_opts = "l:bctwz";\n<line32>char const *digest_length_str = "";\n<line33>#else\n<line34>char const *short_opts = "bctwz";\n<line35>#endif\n<line36>while ((opt = getopt_long (argc, argv, short_opts, long_options, nullptr))\n<line37>!= -1)\n<line38>switch (opt)\n<line39>{\n<line40>#if HASH_ALGO_CKSUM\n<line41>case 'a':\n<line42>cksum_algorithm = XARGMATCH_EXACT ("--algorithm", optarg,\n<line43>algorithm_args, algorithm_types);\n<line44>algorithm_specified = true;\n<line45>break;\n<line46>case DEBUG_PROGRAM_OPTION:\n<line47>cksum_debug = true;\n<line48>break;\n<line49>#endif\n<line50>#if HASH_ALGO_BLAKE2 || HASH_ALGO_CKSUM\n<line51>case 'l':\n<line52>digest_length = xdectoumax (optarg, 0, UINTMAX_MAX, "",\n<line53>_("invalid length"), 0);\n<line54>digest_length_str = optarg;\n<line55>if (digest_length % 8 != 0)\n<line56>{\n<line57>error (0, 0, _("invalid length: %s"), quote (digest_length_str));\n<line58>error (EXIT_FAILURE, 0, _("length is not a multiple of 8"));\n<line59>}\n<line60>break;\n<line61>#endif\n<line62>#if !HASH_ALGO_SUM\n<line63>case 'c':\n<line64>do_check = true;\n<line65>break;\n<line66>case STATUS_OPTION:\n<line67>status_only = true;\n<line68>warn = false;\n<line69>quiet = false;\n<line70>break;\n<line71>case 'b':\n<line72>binary = 1;\n<line73>break;\n<line74>case 't':\n<line75>binary = 0;\n<line76>break;\n<line77>case 'w':\n<line78>status_only = false;\n<line79>warn = true;\n<line80>quiet = false;\n<line81>break;\n<line82>case IGNORE_MISSING_OPTION:\n<line83>ignore_missing = true;\n<line84>break;\n<line85>case QUIET_OPTION:\n<line86>status_only = false;\n<line87>warn = false;\n<line88>quiet = true;\n<line89>break;\n<line90>case STRICT_OPTION:\n<line91>strict = true;\n<line92>break;\n<line93># if HASH_ALGO_CKSUM\n<line94>case BASE64_OPTION:\n<line95>base64_digest = true;\n<line96>break;\n<line97>case RAW_OPTION:\n<line98>raw_digest = true;\n<line99>break;\n<line100>case UNTAG_OPTION:\n<line101>prefix_tag = false;\n<line102>break;\n<line103># endif\n<line104>case TAG_OPTION:\n<line105>prefix_tag = true;\n<line106>binary = 1;\n<line107>break;\n<line108>case 'z':\n<line109>digest_delim = '\0';\n<line110>break;\n<line111>#endif\n<line112>#if HASH_ALGO_SUM\n<line113>case 'r':		/* For SysV compatibility. */\n<line114>sum_algorithm = bsd;\n<line115>break;\n<line116>case 's':\n<line117>sum_algorithm = sysv;\n<line118>break;\n<line119>#endif\n<line120>case_GETOPT_HELP_CHAR;\n<line121>case_GETOPT_VERSION_CHAR (PROGRAM_NAME, AUTHORS);\n<line122>default:\n<line123>usage (EXIT_FAILURE);\n<line124>}\n<line125>min_digest_line_length = MIN_DIGEST_LINE_LENGTH;\n<line126>#if HASH_ALGO_BLAKE2 || HASH_ALGO_CKSUM\n<line127># if HASH_ALGO_CKSUM\n<line128>if (digest_length && cksum_algorithm != blake2b)\n<line129>error (EXIT_FAILURE, 0,\n<line130>_("--length is only supported with --algorithm=blake2b"));\n<line131># endif\n<line132>if (digest_length > BLAKE2B_MAX_LEN * 8)\n<line133>{\n<line134>error (0, 0, _("invalid length: %s"), quote (digest_length_str));\n<line135>error (EXIT_FAILURE, 0,\n<line136>_("maximum digest length for %s is %d bits"),\n<line137>quote (DIGEST_TYPE_STRING),\n<line138>BLAKE2B_MAX_LEN * 8);\n<line139>}\n<line140>if (digest_length == 0)\n<line141>{\n<line142># if HASH_ALGO_BLAKE2\n<line143>digest_length = BLAKE2B_MAX_LEN * 8;\n<line144># else\n<line145>digest_length = algorithm_bits[cksum_algorithm];\n<line146># endif\n<line147>}\n<line148>digest_hex_bytes = digest_length / 4;\n<line149>#else\n<line150>digest_hex_bytes = DIGEST_HEX_BYTES;\n<line151>#endif\n<line152>#if HASH_ALGO_CKSUM\n<line153>switch (cksum_algorithm)\n<line154>{\n<line155>case bsd:\n<line156>case sysv:\n<line157>case crc:\n<line158>if (do_check && algorithm_specified)\n<line159>error (EXIT_FAILURE, 0,\n<line160>_("--check is not supported with --algorithm={bsd,sysv,crc}"));\n<line161>break;\n<line162>default:\n<line163>break;\n<line164>}\n<line165>if (base64_digest && raw_digest)\n<line166>{\n<line167>error (0, 0, _("--base64 and --raw are mutually exclusive"));\n<line168>usage (EXIT_FAILURE);\n<line169>}\n<line170>#endif\n<line171>if (prefix_tag && !binary)\n<line172>{\n<line173>/* This could be supported in a backwards compatible way\n<line174>by prefixing the output line with a space in text mode.\n<line175>However that's invasive enough that it was agreed to\n<line176>not support this mode with --tag, as --text use cases\n<line177>are adequately supported by the default output format.  */\n<line178>#if !HASH_ALGO_CKSUM\n<line179>error (0, 0, _("--tag does not support --text mode"));\n<line180>#else\n<line181>error (0, 0, _("--text mode is only supported with --untagged"));\n<line182>#endif\n<line183>usage (EXIT_FAILURE);\n<line184>}\n<line185>if (digest_delim != '\n' && do_check)\n<line186>{\n<line187>error (0, 0, _("the --zero option is not supported when "\n<line188>"verifying checksums"));\n<line189>usage (EXIT_FAILURE);\n<line190>}\n<line191>#if !HASH_ALGO_CKSUM\n<line192>if (prefix_tag && do_check)\n<line193>{\n<line194>error (0, 0, _("the --tag option is meaningless when "\n<line195>"verifying checksums"));\n<line196>usage (EXIT_FAILURE);\n<line197>}\n<line198>#endif\n<line199>if (0 <= binary && do_check)\n<line200>{\n<line201>error (0, 0, _("the --binary and --text options are meaningless when "\n<line202>"verifying checksums"));\n<line203>usage (EXIT_FAILURE);\n<line204>}\n<line205>if (ignore_missing && !do_check)\n<line206>{\n<line207>error (0, 0,\n<line208>_("the --ignore-missing option is meaningful only when "\n<line209>"verifying checksums"));\n<line210>usage (EXIT_FAILURE);\n<line211>}\n<line212>if (status_only && !do_check)\n<line213>{\n<line214>error (0, 0,\n<line215>_("the --status option is meaningful only when verifying checksums"));\n<line216>usage (EXIT_FAILURE);\n<line217>}\n<line218>if (warn && !do_check)\n<line219>{\n<line220>error (0, 0,\n<line221>_("the --warn option is meaningful only when verifying checksums"));\n<line222>usage (EXIT_FAILURE);\n<line223>}\n<line224>if (quiet && !do_check)\n<line225>{\n<line226>error (0, 0,\n<line227>_("the --quiet option is meaningful only when verifying checksums"));\n<line228>usage (EXIT_FAILURE);\n<line229>}\n<line230>if (strict & !do_check)\n<line231>{\n<line232>error (0, 0,\n<line233>_("the --strict option is meaningful only when verifying checksums"));\n<line234>usage (EXIT_FAILURE);\n<line235>}\n<line236>if (!O_BINARY && binary < 0)\n<line237>binary = 0;\n<line238>char **operand_lim = argv + argc;\n<line239>if (optind == argc)\n<line240>*operand_lim++ = bad_cast ("-");\n<line241>else if (1 < argc - optind && raw_digest)\n<line242>error (EXIT_FAILURE, 0,\n<line243>_("the --raw option is not supported with multiple files"));\n<line244>for (char **operandp = argv + optind; operandp < operand_lim; operandp++)\n<line245>{\n<line246>char *file = *operandp;\n<line247>if (do_check)\n<line248>ok &= digest_check (file);\n<line249>else\n<line250>{\n<line251>int binary_file = binary;\n<line252>bool missing;\n<line253>uintmax_t length;\n<line254>if (! digest_file (file, &binary_file, bin_buffer, &missing, &length))\n<line255>ok = false;\n<line256>else\n<line257>{\n<line258>DIGEST_OUT (file, binary_file, bin_buffer, raw_digest, prefix_tag,\n<line259>digest_delim, optind != argc, length);\n<line260>}\n<line261>}\n<line262>}\n<line263>if (have_read_stdin && fclose (stdin) == EOF)\n<line264>error (EXIT_FAILURE, errno, _("standard input"));\n<line265>return ok ? EXIT_SUCCESS : EXIT_FAILURE;\n<line266>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/src/digest.c
========================================
Function: usage
Content: <line0>void\n<line1>usage (int status)\n<line2>{\n<line3>if (status != EXIT_SUCCESS)\n<line4>emit_try_help ();\n<line5>else\n<line6>{\n<line7>printf (_("\\n<line8>Usage: %s [OPTION]... [FILE]...\n\\n<line9>"), program_name);\n<line10>#if HASH_ALGO_CKSUM\n<line11>fputs (_("\\n<line12>Print or verify checksums.\n\\n<line13>By default use the 32 bit CRC algorithm.\n\\n<line14>"), stdout);\n<line15>#else\n<line16>printf (_("\\n<line17>Print or check %s (%d-bit) checksums.\n\\n<line18>"),\n<line19>DIGEST_TYPE_STRING,\n<line20>DIGEST_BITS);\n<line21>#endif\n<line22>emit_stdin_note ();\n<line23>#if HASH_ALGO_SUM\n<line24>fputs (_("\\n<line25>\n\\n<line26>-r              use BSD sum algorithm (the default), use 1K blocks\n\\n<line27>-s, --sysv      use System V sum algorithm, use 512 bytes blocks\n\\n<line28>"), stdout);\n<line29>#endif\n<line30>#if HASH_ALGO_BLAKE2 || HASH_ALGO_CKSUM\n<line31>emit_mandatory_arg_note ();\n<line32>#endif\n<line33>#if HASH_ALGO_CKSUM\n<line34>fputs (_("\\n<line35>-a, --algorithm=TYPE  select the digest type to use.  See DIGEST below.\\n<line36>\n\\n<line37>"), stdout);\n<line38>fputs (_("\\n<line39>--base64          emit base64-encoded digests, not hexadecimal\\n<line40>\n\\n<line41>"), stdout);\n<line42>#endif\n<line43>#if !HASH_ALGO_SUM\n<line44># if !HASH_ALGO_CKSUM\n<line45>if (O_BINARY)\n<line46>fputs (_("\\n<line47>-b, --binary          read in binary mode (default unless reading tty stdin)\\n<line48>\n\\n<line49>"), stdout);\n<line50>else\n<line51>fputs (_("\\n<line52>-b, --binary          read in binary mode\n\\n<line53>"), stdout);\n<line54># endif\n<line55>fputs (_("\\n<line56>-c, --check           read checksums from the FILEs and check them\n\\n<line57>"), stdout);\n<line58># if HASH_ALGO_BLAKE2 || HASH_ALGO_CKSUM\n<line59>fputs (_("\\n<line60>-l, --length=BITS     digest length in bits; must not exceed the max for\n\\n<line61>the blake2 algorithm and must be a multiple of 8\n\\n<line62>"), stdout);\n<line63># endif\n<line64># if HASH_ALGO_CKSUM\n<line65>fputs (_("\\n<line66>--raw             emit a raw binary digest, not hexadecimal\\n<line67>\n\\n<line68>"), stdout);\n<line69>fputs (_("\\n<line70>--tag             create a BSD-style checksum (the default)\n\\n<line71>"), stdout);\n<line72>fputs (_("\\n<line73>--untagged        create a reversed style checksum, without digest type\n\\n<line74>"), stdout);\n<line75># else\n<line76>fputs (_("\\n<line77>--tag             create a BSD-style checksum\n\\n<line78>"), stdout);\n<line79># endif\n<line80># if !HASH_ALGO_CKSUM\n<line81>if (O_BINARY)\n<line82>fputs (_("\\n<line83>-t, --text            read in text mode (default if reading tty stdin)\n\\n<line84>"), stdout);\n<line85>else\n<line86>fputs (_("\\n<line87>-t, --text            read in text mode (default)\n\\n<line88>"), stdout);\n<line89># endif\n<line90>fputs (_("\\n<line91>-z, --zero            end each output line with NUL, not newline,\n\\n<line92>and disable file name escaping\n\\n<line93>"), stdout);\n<line94>fputs (_("\\n<line95>\n\\n<line96>The following five options are useful only when verifying checksums:\n\\n<line97>--ignore-missing  don't fail or report status for missing files\n\\n<line98>--quiet           don't print OK for each successfully verified file\n\\n<line99>--status          don't output anything, status code shows success\n\\n<line100>--strict          exit non-zero for improperly formatted checksum lines\n\\n<line101>-w, --warn            warn about improperly formatted checksum lines\n\\n<line102>\n\\n<line103>"), stdout);\n<line104>#endif\n<line105>#if HASH_ALGO_CKSUM\n<line106>fputs (_("\\n<line107>--debug           indicate which implementation used\n\\n<line108>"), stdout);\n<line109>#endif\n<line110>fputs (HELP_OPTION_DESCRIPTION, stdout);\n<line111>fputs (VERSION_OPTION_DESCRIPTION, stdout);\n<line112>#if HASH_ALGO_CKSUM\n<line113>fputs (_("\\n<line114>\n\\n<line115>DIGEST determines the digest algorithm and default output format:\n\\n<line116>sysv      (equivalent to sum -s)\n\\n<line117>bsd       (equivalent to sum -r)\n\\n<line118>crc       (equivalent to cksum)\n\\n<line119>md5       (equivalent to md5sum)\n\\n<line120>sha1      (equivalent to sha1sum)\n\\n<line121>sha224    (equivalent to sha224sum)\n\\n<line122>sha256    (equivalent to sha256sum)\n\\n<line123>sha384    (equivalent to sha384sum)\n\\n<line124>sha512    (equivalent to sha512sum)\n\\n<line125>blake2b   (equivalent to b2sum)\n\\n<line126>sm3       (only available through cksum)\n\\n<line127>\n"), stdout);\n<line128>#endif\n<line129>#if !HASH_ALGO_SUM && !HASH_ALGO_CKSUM\n<line130>printf (_("\\n<line131>\n\\n<line132>The sums are computed as described in %s.\n"), DIGEST_REFERENCE);\n<line133>fputs (_("\\n<line134>When checking, the input should be a former output of this program.\n\\n<line135>The default mode is to print a line with: checksum, a space,\n\\n<line136>a character indicating input mode ('*' for binary, ' ' for text\n\\n<line137>or where binary is insignificant), and name for each FILE.\n\\n<line138>\n\\n<line139>Note: There is no difference between binary mode and text mode on GNU systems.\\n<line140>\n"), stdout);\n<line141>#endif\n<line142>#if HASH_ALGO_CKSUM\n<line143>fputs (_("\\n<line144>When checking, the input should be a former output of this program,\n\\n<line145>or equivalent standalone program.\\n<line146>\n"), stdout);\n<line147>#endif\n<line148>emit_ancillary_info (PROGRAM_NAME);\n<line149>}\n<line150>exit (status);\n<line151>}
----------------------------------------
Function: filename_unescape
Content: <line0>static char *\n<line1>filename_unescape (char *s, size_t s_len)\n<line2>{\n<line3>char *dst = s;\n<line4>for (size_t i = 0; i < s_len; i++)\n<line5>{\n<line6>switch (s[i])\n<line7>{\n<line8>case '\\':\n<line9>if (i == s_len - 1)\n<line10>{\n<line11>/* File name ends with an unescaped backslash: invalid.  */\n<line12>return nullptr;\n<line13>}\n<line14>++i;\n<line15>switch (s[i])\n<line16>{\n<line17>case 'n':\n<line18>*dst++ = '\n';\n<line19>break;\n<line20>case 'r':\n<line21>*dst++ = '\r';\n<line22>break;\n<line23>case '\\':\n<line24>*dst++ = '\\';\n<line25>break;\n<line26>default:\n<line27>/* Only '\', 'n' or 'r' may follow a backslash.  */\n<line28>return nullptr;\n<line29>}\n<line30>break;\n<line31>case '\0':\n<line32>/* The file name may not contain a NUL.  */\n<line33>return nullptr;\n<line34>default:\n<line35>*dst++ = s[i];\n<line36>break;\n<line37>}\n<line38>}\n<line39>if (dst < s + s_len)\n<line40>*dst = '\0';\n<line41>return s;\n<line42>}
----------------------------------------
Function: bsd_split_3
Content: <line0>static bool\n<line1>bsd_split_3 (char *s, size_t s_len,\n<line2>unsigned char **digest, size_t *d_len,\n<line3>char **file_name, bool escaped_filename)\n<line4>{\n<line5>if (s_len == 0)\n<line6>return false;\n<line7>/* Find end of filename.  */\n<line8>size_t i = s_len - 1;\n<line9>while (i && s[i] != ')')\n<line10>i--;\n<line11>if (s[i] != ')')\n<line12>return false;\n<line13>*file_name = s;\n<line14>if (escaped_filename && filename_unescape (s, i) == nullptr)\n<line15>return false;\n<line16>s[i++] = '\0';\n<line17>while (ISWHITE (s[i]))\n<line18>i++;\n<line19>if (s[i] != '=')\n<line20>return false;\n<line21>i++;\n<line22>while (ISWHITE (s[i]))\n<line23>i++;\n<line24>*digest = (unsigned char *) &s[i];\n<line25>*d_len = s_len - i;\n<line26>return valid_digits (*digest, *d_len);\n<line27>}
----------------------------------------
Function: split_3
Content: <line0>static bool\n<line1>split_3 (char *s, size_t s_len,\n<line2>unsigned char **digest, size_t *d_len, int *binary, char **file_name)\n<line3>{\n<line4>bool escaped_filename = false;\n<line5>size_t algo_name_len;\n<line6>size_t i = 0;\n<line7>while (ISWHITE (s[i]))\n<line8>++i;\n<line9>if (s[i] == '\\')\n<line10>{\n<line11>++i;\n<line12>escaped_filename = true;\n<line13>}\n<line14>/* Check for BSD-style checksum line. */\n<line15>#if HASH_ALGO_CKSUM\n<line16>if (! algorithm_specified)\n<line17>{\n<line18>ptrdiff_t algo_tag = algorithm_from_tag (s + i);\n<line19>if (algo_tag >= 0)\n<line20>{\n<line21>if (algo_tag <= crc)\n<line22>return false;  /* We don't support checking these older formats.  */\n<line23>cksum_algorithm = algo_tag;\n<line24>}\n<line25>else\n<line26>return false;  /* We only support tagged format without -a.  */\n<line27>}\n<line28>#endif\n<line29>algo_name_len = strlen (DIGEST_TYPE_STRING);\n<line30>if (STREQ_LEN (s + i, DIGEST_TYPE_STRING, algo_name_len))\n<line31>{\n<line32>i += algo_name_len;\n<line33>#if HASH_ALGO_BLAKE2 || HASH_ALGO_CKSUM\n<line34>/* Terminate and match algorithm name.  */\n<line35>char const *algo_name = &s[i - algo_name_len];\n<line36>bool length_specified = s[i] == '-';\n<line37>bool openssl_format = s[i] == '('; /* and no length_specified */\n<line38>s[i++] = '\0';\n<line39>if (!STREQ (algo_name, DIGEST_TYPE_STRING))\n<line40>return false;\n<line41>if (openssl_format)\n<line42>s[--i] = '(';\n<line43># if HASH_ALGO_BLAKE2\n<line44>digest_length = BLAKE2B_MAX_LEN * 8;\n<line45># else\n<line46>digest_length = algorithm_bits[cksum_algorithm];\n<line47># endif\n<line48>if (length_specified)\n<line49>{\n<line50>uintmax_t length;\n<line51>char *siend;\n<line52>if (! (xstrtoumax (s + i, &siend, 0, &length, nullptr) == LONGINT_OK\n<line53>&& 0 < length && length <= digest_length\n<line54>&& length % 8 == 0))\n<line55>return false;\n<line56>i = siend - s;\n<line57>digest_length = length;\n<line58>}\n<line59>digest_hex_bytes = digest_length / 4;\n<line60>#endif\n<line61>if (s[i] == ' ')\n<line62>++i;\n<line63>if (s[i] == '(')\n<line64>{\n<line65>++i;\n<line66>*binary = 0;\n<line67>return bsd_split_3 (s + i, s_len - i,\n<line68>digest, d_len, file_name, escaped_filename);\n<line69>}\n<line70>return false;\n<line71>}\n<line72>/* Ignore this line if it is too short.\n<line73>Each line must have at least 'min_digest_line_length - 1' (or one more, if\n<line74>the first is a backslash) more characters to contain correct message digest\n<line75>information.  */\n<line76>if (s_len - i < min_digest_line_length + (s[i] == '\\'))\n<line77>return false;\n<line78>*digest = (unsigned char *) &s[i];\n<line79>#if HASH_ALGO_BLAKE2 || HASH_ALGO_CKSUM\n<line80>/* Auto determine length.  */\n<line81># if HASH_ALGO_CKSUM\n<line82>if (cksum_algorithm == blake2b) {\n<line83># endif\n<line84>unsigned char const *hp = *digest;\n<line85>digest_hex_bytes = 0;\n<line86>while (isxdigit (*hp++))\n<line87>digest_hex_bytes++;\n<line88>if (digest_hex_bytes < 2 || digest_hex_bytes % 2\n<line89>|| BLAKE2B_MAX_LEN * 2 < digest_hex_bytes)\n<line90>return false;\n<line91>digest_length = digest_hex_bytes * 4;\n<line92># if HASH_ALGO_CKSUM\n<line93>}\n<line94># endif\n<line95>#endif\n<line96>/* This field must be the hexadecimal or base64 representation\n<line97>of the message digest.  */\n<line98>while (s[i] && !ISWHITE (s[i]))\n<line99>i++;\n<line100>/* The digest must be followed by at least one whitespace character.  */\n<line101>if (i == s_len)\n<line102>return false;\n<line103>*d_len = &s[i] - (char *) *digest;\n<line104>s[i++] = '\0';\n<line105>if (! valid_digits (*digest, *d_len))\n<line106>return false;\n<line107>/* If "bsd reversed" format detected.  */\n<line108>if ((s_len - i == 1) || (s[i] != ' ' && s[i] != '*'))\n<line109>{\n<line110>/* Don't allow mixing bsd and standard formats,\n<line111>to minimize security issues with attackers\n<line112>renaming files with leading spaces.\n<line113>This assumes that with bsd format checksums\n<line114>that the first file name does not have\n<line115>a leading ' ' or '*'.  */\n<line116>if (bsd_reversed == 0)\n<line117>return false;\n<line118>bsd_reversed = 1;\n<line119>}\n<line120>else if (bsd_reversed != 1)\n<line121>{\n<line122>bsd_reversed = 0;\n<line123>*binary = (s[i++] == '*');\n<line124>}\n<line125>/* All characters between the type indicator and end of line are\n<line126>significant -- that includes leading and trailing white space.  */\n<line127>*file_name = &s[i];\n<line128>if (escaped_filename)\n<line129>return filename_unescape (&s[i], s_len - i) != nullptr;\n<line130>return true;\n<line131>}
----------------------------------------
Function: print_filename
Content: <line0>static void\n<line1>print_filename (char const *file, bool escape)\n<line2>{\n<line3>if (! escape)\n<line4>{\n<line5>fputs (file, stdout);\n<line6>return;\n<line7>}\n<line8>while (*file)\n<line9>{\n<line10>switch (*file)\n<line11>{\n<line12>case '\n':\n<line13>fputs ("\\n", stdout);\n<line14>break;\n<line15>case '\r':\n<line16>fputs ("\\r", stdout);\n<line17>break;\n<line18>case '\\':\n<line19>fputs ("\\\\", stdout);\n<line20>break;\n<line21>default:\n<line22>putchar (*file);\n<line23>break;\n<line24>}\n<line25>file++;\n<line26>}\n<line27>}
----------------------------------------
Function: digest_file
Content: <line0>static bool\n<line1>digest_file (char const *filename, int *binary, unsigned char *bin_result,\n<line2>bool *missing, MAYBE_UNUSED uintmax_t *length)\n<line3>{\n<line4>FILE *fp;\n<line5>int err;\n<line6>bool is_stdin = STREQ (filename, "-");\n<line7>*missing = false;\n<line8>if (is_stdin)\n<line9>{\n<line10>have_read_stdin = true;\n<line11>fp = stdin;\n<line12>if (O_BINARY && *binary)\n<line13>{\n<line14>if (*binary < 0)\n<line15>*binary = ! isatty (STDIN_FILENO);\n<line16>if (*binary)\n<line17>xset_binary_mode (STDIN_FILENO, O_BINARY);\n<line18>}\n<line19>}\n<line20>else\n<line21>{\n<line22>fp = fopen (filename, (O_BINARY && *binary ? "rb" : "r"));\n<line23>if (fp == nullptr)\n<line24>{\n<line25>if (ignore_missing && errno == ENOENT)\n<line26>{\n<line27>*missing = true;\n<line28>return true;\n<line29>}\n<line30>error (0, errno, "%s", quotef (filename));\n<line31>return false;\n<line32>}\n<line33>}\n<line34>fadvise (fp, FADVISE_SEQUENTIAL);\n<line35>#if HASH_ALGO_CKSUM\n<line36>if (cksum_algorithm == blake2b)\n<line37>*length = digest_length / 8;\n<line38>err = DIGEST_STREAM (fp, bin_result, length);\n<line39>#elif HASH_ALGO_SUM\n<line40>err = DIGEST_STREAM (fp, bin_result, length);\n<line41>#elif HASH_ALGO_BLAKE2\n<line42>err = DIGEST_STREAM (fp, bin_result, digest_length / 8);\n<line43>#else\n<line44>err = DIGEST_STREAM (fp, bin_result);\n<line45>#endif\n<line46>err = err ? errno : 0;\n<line47>if (is_stdin)\n<line48>clearerr (fp);\n<line49>else if (fclose (fp) != 0 && !err)\n<line50>err = errno;\n<line51>if (err)\n<line52>{\n<line53>error (0, err, "%s", quotef (filename));\n<line54>return false;\n<line55>}\n<line56>return true;\n<line57>}
----------------------------------------
Function: output_file
Content: <line0>static void\n<line1>output_file (char const *file, int binary_file, void const *digest,\n<line2>bool raw, bool tagged, unsigned char delim, MAYBE_UNUSED bool args,\n<line3>MAYBE_UNUSED uintmax_t length)\n<line4>{\n<line5># if HASH_ALGO_CKSUM\n<line6>if (raw)\n<line7>{\n<line8>fwrite (digest, 1, digest_length / 8, stdout);\n<line9>return;\n<line10>}\n<line11># endif\n<line12>unsigned char const *bin_buffer = digest;\n<line13>/* Output a leading backslash if the file name contains problematic chars.  */\n<line14>bool needs_escape = delim == '\n' && problematic_chars (file);\n<line15>if (needs_escape)\n<line16>putchar ('\\');\n<line17>if (tagged)\n<line18>{\n<line19>fputs (DIGEST_TYPE_STRING, stdout);\n<line20># if HASH_ALGO_BLAKE2\n<line21>if (digest_length < BLAKE2B_MAX_LEN * 8)\n<line22>printf ("-%"PRIuMAX, digest_length);\n<line23># elif HASH_ALGO_CKSUM\n<line24>if (cksum_algorithm == blake2b)\n<line25>{\n<line26>if (digest_length < BLAKE2B_MAX_LEN * 8)\n<line27>printf ("-%"PRIuMAX, digest_length);\n<line28>}\n<line29># endif\n<line30>fputs (" (", stdout);\n<line31>print_filename (file, needs_escape);\n<line32>fputs (") = ", stdout);\n<line33>}\n<line34># if HASH_ALGO_CKSUM\n<line35>if (base64_digest)\n<line36>{\n<line37>char b64[BASE64_LENGTH (DIGEST_BIN_BYTES) + 1];\n<line38>base64_encode ((char const *) bin_buffer, digest_length / 8,\n<line39>b64, sizeof b64);\n<line40>fputs (b64, stdout);\n<line41>}\n<line42>else\n<line43># endif\n<line44>{\n<line45>for (size_t i = 0; i < (digest_hex_bytes / 2); ++i)\n<line46>printf ("%02x", bin_buffer[i]);\n<line47>}\n<line48>if (!tagged)\n<line49>{\n<line50>putchar (' ');\n<line51>putchar (binary_file ? '*' : ' ');\n<line52>print_filename (file, needs_escape);\n<line53>}\n<line54>putchar (delim);\n<line55>}
----------------------------------------
Function: hex_equal
Content: <line0>static bool\n<line1>hex_equal (unsigned char const *hex_digest, unsigned char const *bin_buffer)\n<line2>{\n<line3>static const char bin2hex[] = { '0', '1', '2', '3',\n<line4>'4', '5', '6', '7',\n<line5>'8', '9', 'a', 'b',\n<line6>'c', 'd', 'e', 'f' };\n<line7>size_t digest_bin_bytes = digest_hex_bytes / 2;\n<line8>/* Compare generated binary number with text representation\n<line9>in check file.  Ignore case of hex digits.  */\n<line10>size_t cnt;\n<line11>for (cnt = 0; cnt < digest_bin_bytes; ++cnt)\n<line12>{\n<line13>if (tolower (hex_digest[2 * cnt])\n<line14>!= bin2hex[bin_buffer[cnt] >> 4]\n<line15>|| (tolower (hex_digest[2 * cnt + 1])\n<line16>!= (bin2hex[bin_buffer[cnt] & 0xf])))\n<line17>break;\n<line18>}\n<line19>return cnt == digest_bin_bytes;\n<line20>}
----------------------------------------
Function: digest_check
Content: <line0>static bool\n<line1>digest_check (char const *checkfile_name)\n<line2>{\n<line3>FILE *checkfile_stream;\n<line4>uintmax_t n_misformatted_lines = 0;\n<line5>uintmax_t n_mismatched_checksums = 0;\n<line6>uintmax_t n_open_or_read_failures = 0;\n<line7>bool properly_formatted_lines = false;\n<line8>bool matched_checksums = false;\n<line9>unsigned char bin_buffer_unaligned[DIGEST_BIN_BYTES + DIGEST_ALIGN];\n<line10>/* Make sure bin_buffer is properly aligned. */\n<line11>unsigned char *bin_buffer = ptr_align (bin_buffer_unaligned, DIGEST_ALIGN);\n<line12>uintmax_t line_number;\n<line13>char *line;\n<line14>size_t line_chars_allocated;\n<line15>bool is_stdin = STREQ (checkfile_name, "-");\n<line16>if (is_stdin)\n<line17>{\n<line18>have_read_stdin = true;\n<line19>checkfile_name = _("standard input");\n<line20>checkfile_stream = stdin;\n<line21>}\n<line22>else\n<line23>{\n<line24>checkfile_stream = fopen (checkfile_name, "r");\n<line25>if (checkfile_stream == nullptr)\n<line26>{\n<line27>error (0, errno, "%s", quotef (checkfile_name));\n<line28>return false;\n<line29>}\n<line30>}\n<line31>line_number = 0;\n<line32>line = nullptr;\n<line33>line_chars_allocated = 0;\n<line34>do\n<line35>{\n<line36>char *filename;\n<line37>int binary;\n<line38>unsigned char *digest;\n<line39>ssize_t line_length;\n<line40>++line_number;\n<line41>if (line_number == 0)\n<line42>error (EXIT_FAILURE, 0, _("%s: too many checksum lines"),\n<line43>quotef (checkfile_name));\n<line44>line_length = getline (&line, &line_chars_allocated, checkfile_stream);\n<line45>if (line_length <= 0)\n<line46>break;\n<line47>/* Ignore comment lines, which begin with a '#' character.  */\n<line48>if (line[0] == '#')\n<line49>continue;\n<line50>/* Remove any trailing newline.  */\n<line51>line_length -= line[line_length - 1] == '\n';\n<line52>/* Remove any trailing carriage return.  */\n<line53>line_length -= line[line_length - (0 < line_length)] == '\r';\n<line54>/* Ignore empty lines.  */\n<line55>if (line_length == 0)\n<line56>continue;\n<line57>line[line_length] = '\0';\n<line58>size_t d_len;\n<line59>if (! (split_3 (line, line_length, &digest, &d_len, &binary, &filename)\n<line60>&& ! (is_stdin && STREQ (filename, "-"))))\n<line61>{\n<line62>++n_misformatted_lines;\n<line63>if (warn)\n<line64>{\n<line65>error (0, 0,\n<line66>_("%s: %" PRIuMAX\n<line67>": improperly formatted %s checksum line"),\n<line68>quotef (checkfile_name), line_number,\n<line69>DIGEST_TYPE_STRING);\n<line70>}\n<line71>}\n<line72>else\n<line73>{\n<line74>bool ok;\n<line75>bool missing;\n<line76>bool needs_escape = ! status_only && problematic_chars (filename);\n<line77>properly_formatted_lines = true;\n<line78>uintmax_t length;\n<line79>ok = digest_file (filename, &binary, bin_buffer, &missing, &length);\n<line80>if (!ok)\n<line81>{\n<line82>++n_open_or_read_failures;\n<line83>if (!status_only)\n<line84>{\n<line85>if (needs_escape)\n<line86>putchar ('\\');\n<line87>print_filename (filename, needs_escape);\n<line88>printf (": %s\n", _("FAILED open or read"));\n<line89>}\n<line90>}\n<line91>else if (ignore_missing && missing)\n<line92>{\n<line93>/* Ignore missing files with --ignore-missing.  */\n<line94>;\n<line95>}\n<line96>else\n<line97>{\n<line98>bool match = false;\n<line99>#if HASH_ALGO_CKSUM\n<line100>if (d_len < digest_hex_bytes)\n<line101>match = b64_equal (digest, bin_buffer);\n<line102>else\n<line103>#endif\n<line104>if (d_len == digest_hex_bytes)\n<line105>match = hex_equal (digest, bin_buffer);\n<line106>if (match)\n<line107>matched_checksums = true;\n<line108>else\n<line109>++n_mismatched_checksums;\n<line110>if (!status_only)\n<line111>{\n<line112>if (! match || ! quiet)\n<line113>{\n<line114>if (needs_escape)\n<line115>putchar ('\\');\n<line116>print_filename (filename, needs_escape);\n<line117>}\n<line118>if (! match)\n<line119>printf (": %s\n", _("FAILED"));\n<line120>else if (!quiet)\n<line121>printf (": %s\n", _("OK"));\n<line122>}\n<line123>}\n<line124>}\n<line125>}\n<line126>while (!feof (checkfile_stream) && !ferror (checkfile_stream));\n<line127>free (line);\n<line128>int err = ferror (checkfile_stream) ? 0 : -1;\n<line129>if (is_stdin)\n<line130>clearerr (checkfile_stream);\n<line131>else if (fclose (checkfile_stream) != 0 && err < 0)\n<line132>err = errno;\n<line133>if (0 <= err)\n<line134>{\n<line135>error (0, err, err ? "%s" : _("%s: read error"),\n<line136>quotef (checkfile_name));\n<line137>return false;\n<line138>}\n<line139>if (! properly_formatted_lines)\n<line140>{\n<line141>/* Warn if no tests are found.  */\n<line142>error (0, 0, _("%s: no properly formatted checksum lines found"),\n<line143>quotef (checkfile_name));\n<line144>}\n<line145>else\n<line146>{\n<line147>if (!status_only)\n<line148>{\n<line149>if (n_misformatted_lines != 0)\n<line150>error (0, 0,\n<line151>(ngettext\n<line152>("WARNING: %" PRIuMAX " line is improperly formatted",\n<line153>"WARNING: %" PRIuMAX " lines are improperly formatted",\n<line154>select_plural (n_misformatted_lines))),\n<line155>n_misformatted_lines);\n<line156>if (n_open_or_read_failures != 0)\n<line157>error (0, 0,\n<line158>(ngettext\n<line159>("WARNING: %" PRIuMAX " listed file could not be read",\n<line160>"WARNING: %" PRIuMAX " listed files could not be read",\n<line161>select_plural (n_open_or_read_failures))),\n<line162>n_open_or_read_failures);\n<line163>if (n_mismatched_checksums != 0)\n<line164>error (0, 0,\n<line165>(ngettext\n<line166>("WARNING: %" PRIuMAX " computed checksum did NOT match",\n<line167>"WARNING: %" PRIuMAX " computed checksums did NOT match",\n<line168>select_plural (n_mismatched_checksums))),\n<line169>n_mismatched_checksums);\n<line170>if (ignore_missing && ! matched_checksums)\n<line171>error (0, 0, _("%s: no file was verified"),\n<line172>quotef (checkfile_name));\n<line173>}\n<line174>}\n<line175>return (properly_formatted_lines\n<line176>&& matched_checksums\n<line177>&& n_mismatched_checksums == 0\n<line178>&& n_open_or_read_failures == 0\n<line179>&& (!strict || n_misformatted_lines == 0));\n<line180>}
----------------------------------------
Function: main
Content: <line0>int\n<line1>main (int argc, char **argv)\n<line2>{\n<line3>unsigned char bin_buffer_unaligned[DIGEST_BIN_BYTES + DIGEST_ALIGN];\n<line4>/* Make sure bin_buffer is properly aligned. */\n<line5>unsigned char *bin_buffer = ptr_align (bin_buffer_unaligned, DIGEST_ALIGN);\n<line6>bool do_check = false;\n<line7>int opt;\n<line8>bool ok = true;\n<line9>int binary = -1;\n<line10>#if HASH_ALGO_CKSUM\n<line11>bool prefix_tag = true;\n<line12>#else\n<line13>bool prefix_tag = false;\n<line14>#endif\n<line15>/* Setting values of global variables.  */\n<line16>initialize_main (&argc, &argv);\n<line17>set_program_name (argv[0]);\n<line18>setlocale (LC_ALL, "");\n<line19>bindtextdomain (PACKAGE, LOCALEDIR);\n<line20>textdomain (PACKAGE);\n<line21>atexit (close_stdout);\n<line22>/* Line buffer stdout to ensure lines are written atomically and immediately\n<line23>so that processes running in parallel do not intersperse their output.  */\n<line24>setvbuf (stdout, nullptr, _IOLBF, 0);\n<line25>#if HASH_ALGO_SUM\n<line26>char const *short_opts = "rs";\n<line27>#elif HASH_ALGO_CKSUM\n<line28>char const *short_opts = "a:l:bctwz";\n<line29>char const *digest_length_str = "";\n<line30>#elif HASH_ALGO_BLAKE2\n<line31>char const *short_opts = "l:bctwz";\n<line32>char const *digest_length_str = "";\n<line33>#else\n<line34>char const *short_opts = "bctwz";\n<line35>#endif\n<line36>while ((opt = getopt_long (argc, argv, short_opts, long_options, nullptr))\n<line37>!= -1)\n<line38>switch (opt)\n<line39>{\n<line40>#if HASH_ALGO_CKSUM\n<line41>case 'a':\n<line42>cksum_algorithm = XARGMATCH_EXACT ("--algorithm", optarg,\n<line43>algorithm_args, algorithm_types);\n<line44>algorithm_specified = true;\n<line45>break;\n<line46>case DEBUG_PROGRAM_OPTION:\n<line47>cksum_debug = true;\n<line48>break;\n<line49>#endif\n<line50>#if HASH_ALGO_BLAKE2 || HASH_ALGO_CKSUM\n<line51>case 'l':\n<line52>digest_length = xdectoumax (optarg, 0, UINTMAX_MAX, "",\n<line53>_("invalid length"), 0);\n<line54>digest_length_str = optarg;\n<line55>if (digest_length % 8 != 0)\n<line56>{\n<line57>error (0, 0, _("invalid length: %s"), quote (digest_length_str));\n<line58>error (EXIT_FAILURE, 0, _("length is not a multiple of 8"));\n<line59>}\n<line60>break;\n<line61>#endif\n<line62>#if !HASH_ALGO_SUM\n<line63>case 'c':\n<line64>do_check = true;\n<line65>break;\n<line66>case STATUS_OPTION:\n<line67>status_only = true;\n<line68>warn = false;\n<line69>quiet = false;\n<line70>break;\n<line71>case 'b':\n<line72>binary = 1;\n<line73>break;\n<line74>case 't':\n<line75>binary = 0;\n<line76>break;\n<line77>case 'w':\n<line78>status_only = false;\n<line79>warn = true;\n<line80>quiet = false;\n<line81>break;\n<line82>case IGNORE_MISSING_OPTION:\n<line83>ignore_missing = true;\n<line84>break;\n<line85>case QUIET_OPTION:\n<line86>status_only = false;\n<line87>warn = false;\n<line88>quiet = true;\n<line89>break;\n<line90>case STRICT_OPTION:\n<line91>strict = true;\n<line92>break;\n<line93># if HASH_ALGO_CKSUM\n<line94>case BASE64_OPTION:\n<line95>base64_digest = true;\n<line96>break;\n<line97>case RAW_OPTION:\n<line98>raw_digest = true;\n<line99>break;\n<line100>case UNTAG_OPTION:\n<line101>prefix_tag = false;\n<line102>break;\n<line103># endif\n<line104>case TAG_OPTION:\n<line105>prefix_tag = true;\n<line106>binary = 1;\n<line107>break;\n<line108>case 'z':\n<line109>digest_delim = '\0';\n<line110>break;\n<line111>#endif\n<line112>#if HASH_ALGO_SUM\n<line113>case 'r':		/* For SysV compatibility. */\n<line114>sum_algorithm = bsd;\n<line115>break;\n<line116>case 's':\n<line117>sum_algorithm = sysv;\n<line118>break;\n<line119>#endif\n<line120>case_GETOPT_HELP_CHAR;\n<line121>case_GETOPT_VERSION_CHAR (PROGRAM_NAME, AUTHORS);\n<line122>default:\n<line123>usage (EXIT_FAILURE);\n<line124>}\n<line125>min_digest_line_length = MIN_DIGEST_LINE_LENGTH;\n<line126>#if HASH_ALGO_BLAKE2 || HASH_ALGO_CKSUM\n<line127># if HASH_ALGO_CKSUM\n<line128>if (digest_length && cksum_algorithm != blake2b)\n<line129>error (EXIT_FAILURE, 0,\n<line130>_("--length is only supported with --algorithm=blake2b"));\n<line131># endif\n<line132>if (digest_length > BLAKE2B_MAX_LEN * 8)\n<line133>{\n<line134>error (0, 0, _("invalid length: %s"), quote (digest_length_str));\n<line135>error (EXIT_FAILURE, 0,\n<line136>_("maximum digest length for %s is %d bits"),\n<line137>quote (DIGEST_TYPE_STRING),\n<line138>BLAKE2B_MAX_LEN * 8);\n<line139>}\n<line140>if (digest_length == 0)\n<line141>{\n<line142># if HASH_ALGO_BLAKE2\n<line143>digest_length = BLAKE2B_MAX_LEN * 8;\n<line144># else\n<line145>digest_length = algorithm_bits[cksum_algorithm];\n<line146># endif\n<line147>}\n<line148>digest_hex_bytes = digest_length / 4;\n<line149>#else\n<line150>digest_hex_bytes = DIGEST_HEX_BYTES;\n<line151>#endif\n<line152>#if HASH_ALGO_CKSUM\n<line153>switch (cksum_algorithm)\n<line154>{\n<line155>case bsd:\n<line156>case sysv:\n<line157>case crc:\n<line158>if (do_check && algorithm_specified)\n<line159>error (EXIT_FAILURE, 0,\n<line160>_("--check is not supported with --algorithm={bsd,sysv,crc}"));\n<line161>break;\n<line162>default:\n<line163>break;\n<line164>}\n<line165>if (base64_digest && raw_digest)\n<line166>{\n<line167>error (0, 0, _("--base64 and --raw are mutually exclusive"));\n<line168>usage (EXIT_FAILURE);\n<line169>}\n<line170>#endif\n<line171>if (prefix_tag && !binary)\n<line172>{\n<line173>/* This could be supported in a backwards compatible way\n<line174>by prefixing the output line with a space in text mode.\n<line175>However that's invasive enough that it was agreed to\n<line176>not support this mode with --tag, as --text use cases\n<line177>are adequately supported by the default output format.  */\n<line178>#if !HASH_ALGO_CKSUM\n<line179>error (0, 0, _("--tag does not support --text mode"));\n<line180>#else\n<line181>error (0, 0, _("--text mode is only supported with --untagged"));\n<line182>#endif\n<line183>usage (EXIT_FAILURE);\n<line184>}\n<line185>if (digest_delim != '\n' && do_check)\n<line186>{\n<line187>error (0, 0, _("the --zero option is not supported when "\n<line188>"verifying checksums"));\n<line189>usage (EXIT_FAILURE);\n<line190>}\n<line191>#if !HASH_ALGO_CKSUM\n<line192>if (prefix_tag && do_check)\n<line193>{\n<line194>error (0, 0, _("the --tag option is meaningless when "\n<line195>"verifying checksums"));\n<line196>usage (EXIT_FAILURE);\n<line197>}\n<line198>#endif\n<line199>if (0 <= binary && do_check)\n<line200>{\n<line201>error (0, 0, _("the --binary and --text options are meaningless when "\n<line202>"verifying checksums"));\n<line203>usage (EXIT_FAILURE);\n<line204>}\n<line205>if (ignore_missing && !do_check)\n<line206>{\n<line207>error (0, 0,\n<line208>_("the --ignore-missing option is meaningful only when "\n<line209>"verifying checksums"));\n<line210>usage (EXIT_FAILURE);\n<line211>}\n<line212>if (status_only && !do_check)\n<line213>{\n<line214>error (0, 0,\n<line215>_("the --status option is meaningful only when verifying checksums"));\n<line216>usage (EXIT_FAILURE);\n<line217>}\n<line218>if (warn && !do_check)\n<line219>{\n<line220>error (0, 0,\n<line221>_("the --warn option is meaningful only when verifying checksums"));\n<line222>usage (EXIT_FAILURE);\n<line223>}\n<line224>if (quiet && !do_check)\n<line225>{\n<line226>error (0, 0,\n<line227>_("the --quiet option is meaningful only when verifying checksums"));\n<line228>usage (EXIT_FAILURE);\n<line229>}\n<line230>if (strict & !do_check)\n<line231>{\n<line232>error (0, 0,\n<line233>_("the --strict option is meaningful only when verifying checksums"));\n<line234>usage (EXIT_FAILURE);\n<line235>}\n<line236>if (!O_BINARY && binary < 0)\n<line237>binary = 0;\n<line238>char **operand_lim = argv + argc;\n<line239>if (optind == argc)\n<line240>*operand_lim++ = bad_cast ("-");\n<line241>else if (1 < argc - optind && raw_digest)\n<line242>error (EXIT_FAILURE, 0,\n<line243>_("the --raw option is not supported with multiple files"));\n<line244>for (char **operandp = argv + optind; operandp < operand_lim; operandp++)\n<line245>{\n<line246>char *file = *operandp;\n<line247>if (do_check)\n<line248>ok &= digest_check (file);\n<line249>else\n<line250>{\n<line251>int binary_file = binary;\n<line252>bool missing;\n<line253>uintmax_t length;\n<line254>if (! digest_file (file, &binary_file, bin_buffer, &missing, &length))\n<line255>ok = false;\n<line256>else\n<line257>{\n<line258>DIGEST_OUT (file, binary_file, bin_buffer, raw_digest, prefix_tag,\n<line259>digest_delim, optind != argc, length);\n<line260>}\n<line261>}\n<line262>}\n<line263>if (have_read_stdin && fclose (stdin) == EOF)\n<line264>error (EXIT_FAILURE, errno, _("standard input"));\n<line265>return ok ? EXIT_SUCCESS : EXIT_FAILURE;\n<line266>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/src/digest.c
========================================
Function: usage
Content: <line0>void\n<line1>usage (int status)\n<line2>{\n<line3>if (status != EXIT_SUCCESS)\n<line4>emit_try_help ();\n<line5>else\n<line6>{\n<line7>printf (_("\\n<line8>Usage: %s [OPTION]... [FILE]...\n\\n<line9>"), program_name);\n<line10>#if HASH_ALGO_CKSUM\n<line11>fputs (_("\\n<line12>Print or verify checksums.\n\\n<line13>By default use the 32 bit CRC algorithm.\n\\n<line14>"), stdout);\n<line15>#else\n<line16>printf (_("\\n<line17>Print or check %s (%d-bit) checksums.\n\\n<line18>"),\n<line19>DIGEST_TYPE_STRING,\n<line20>DIGEST_BITS);\n<line21>#endif\n<line22>emit_stdin_note ();\n<line23>#if HASH_ALGO_SUM\n<line24>fputs (_("\\n<line25>\n\\n<line26>-r              use BSD sum algorithm (the default), use 1K blocks\n\\n<line27>-s, --sysv      use System V sum algorithm, use 512 bytes blocks\n\\n<line28>"), stdout);\n<line29>#endif\n<line30>#if HASH_ALGO_BLAKE2 || HASH_ALGO_CKSUM\n<line31>emit_mandatory_arg_note ();\n<line32>#endif\n<line33>#if HASH_ALGO_CKSUM\n<line34>fputs (_("\\n<line35>-a, --algorithm=TYPE  select the digest type to use.  See DIGEST below.\\n<line36>\n\\n<line37>"), stdout);\n<line38>fputs (_("\\n<line39>--base64          emit base64-encoded digests, not hexadecimal\\n<line40>\n\\n<line41>"), stdout);\n<line42>#endif\n<line43>#if !HASH_ALGO_SUM\n<line44># if !HASH_ALGO_CKSUM\n<line45>if (O_BINARY)\n<line46>fputs (_("\\n<line47>-b, --binary          read in binary mode (default unless reading tty stdin)\\n<line48>\n\\n<line49>"), stdout);\n<line50>else\n<line51>fputs (_("\\n<line52>-b, --binary          read in binary mode\n\\n<line53>"), stdout);\n<line54># endif\n<line55>fputs (_("\\n<line56>-c, --check           read checksums from the FILEs and check them\n\\n<line57>"), stdout);\n<line58># if HASH_ALGO_BLAKE2 || HASH_ALGO_CKSUM\n<line59>fputs (_("\\n<line60>-l, --length=BITS     digest length in bits; must not exceed the max for\n\\n<line61>the blake2 algorithm and must be a multiple of 8\n\\n<line62>"), stdout);\n<line63># endif\n<line64># if HASH_ALGO_CKSUM\n<line65>fputs (_("\\n<line66>--raw             emit a raw binary digest, not hexadecimal\\n<line67>\n\\n<line68>"), stdout);\n<line69>fputs (_("\\n<line70>--tag             create a BSD-style checksum (the default)\n\\n<line71>"), stdout);\n<line72>fputs (_("\\n<line73>--untagged        create a reversed style checksum, without digest type\n\\n<line74>"), stdout);\n<line75># else\n<line76>fputs (_("\\n<line77>--tag             create a BSD-style checksum\n\\n<line78>"), stdout);\n<line79># endif\n<line80># if !HASH_ALGO_CKSUM\n<line81>if (O_BINARY)\n<line82>fputs (_("\\n<line83>-t, --text            read in text mode (default if reading tty stdin)\n\\n<line84>"), stdout);\n<line85>else\n<line86>fputs (_("\\n<line87>-t, --text            read in text mode (default)\n\\n<line88>"), stdout);\n<line89># endif\n<line90>fputs (_("\\n<line91>-z, --zero            end each output line with NUL, not newline,\n\\n<line92>and disable file name escaping\n\\n<line93>"), stdout);\n<line94>fputs (_("\\n<line95>\n\\n<line96>The following five options are useful only when verifying checksums:\n\\n<line97>--ignore-missing  don't fail or report status for missing files\n\\n<line98>--quiet           don't print OK for each successfully verified file\n\\n<line99>--status          don't output anything, status code shows success\n\\n<line100>--strict          exit non-zero for improperly formatted checksum lines\n\\n<line101>-w, --warn            warn about improperly formatted checksum lines\n\\n<line102>\n\\n<line103>"), stdout);\n<line104>#endif\n<line105>#if HASH_ALGO_CKSUM\n<line106>fputs (_("\\n<line107>--debug           indicate which implementation used\n\\n<line108>"), stdout);\n<line109>#endif\n<line110>fputs (HELP_OPTION_DESCRIPTION, stdout);\n<line111>fputs (VERSION_OPTION_DESCRIPTION, stdout);\n<line112>#if HASH_ALGO_CKSUM\n<line113>fputs (_("\\n<line114>\n\\n<line115>DIGEST determines the digest algorithm and default output format:\n\\n<line116>sysv      (equivalent to sum -s)\n\\n<line117>bsd       (equivalent to sum -r)\n\\n<line118>crc       (equivalent to cksum)\n\\n<line119>md5       (equivalent to md5sum)\n\\n<line120>sha1      (equivalent to sha1sum)\n\\n<line121>sha224    (equivalent to sha224sum)\n\\n<line122>sha256    (equivalent to sha256sum)\n\\n<line123>sha384    (equivalent to sha384sum)\n\\n<line124>sha512    (equivalent to sha512sum)\n\\n<line125>blake2b   (equivalent to b2sum)\n\\n<line126>sm3       (only available through cksum)\n\\n<line127>\n"), stdout);\n<line128>#endif\n<line129>#if !HASH_ALGO_SUM && !HASH_ALGO_CKSUM\n<line130>printf (_("\\n<line131>\n\\n<line132>The sums are computed as described in %s.\n"), DIGEST_REFERENCE);\n<line133>fputs (_("\\n<line134>When checking, the input should be a former output of this program.\n\\n<line135>The default mode is to print a line with: checksum, a space,\n\\n<line136>a character indicating input mode ('*' for binary, ' ' for text\n\\n<line137>or where binary is insignificant), and name for each FILE.\n\\n<line138>\n\\n<line139>Note: There is no difference between binary mode and text mode on GNU systems.\\n<line140>\n"), stdout);\n<line141>#endif\n<line142>#if HASH_ALGO_CKSUM\n<line143>fputs (_("\\n<line144>When checking, the input should be a former output of this program,\n\\n<line145>or equivalent standalone program.\\n<line146>\n"), stdout);\n<line147>#endif\n<line148>emit_ancillary_info (PROGRAM_NAME);\n<line149>}\n<line150>exit (status);\n<line151>}
----------------------------------------
Function: filename_unescape
Content: <line0>static char *\n<line1>filename_unescape (char *s, size_t s_len)\n<line2>{\n<line3>char *dst = s;\n<line4>for (size_t i = 0; i < s_len; i++)\n<line5>{\n<line6>switch (s[i])\n<line7>{\n<line8>case '\\':\n<line9>if (i == s_len - 1)\n<line10>{\n<line11>/* File name ends with an unescaped backslash: invalid.  */\n<line12>return nullptr;\n<line13>}\n<line14>++i;\n<line15>switch (s[i])\n<line16>{\n<line17>case 'n':\n<line18>*dst++ = '\n';\n<line19>break;\n<line20>case 'r':\n<line21>*dst++ = '\r';\n<line22>break;\n<line23>case '\\':\n<line24>*dst++ = '\\';\n<line25>break;\n<line26>default:\n<line27>/* Only '\', 'n' or 'r' may follow a backslash.  */\n<line28>return nullptr;\n<line29>}\n<line30>break;\n<line31>case '\0':\n<line32>/* The file name may not contain a NUL.  */\n<line33>return nullptr;\n<line34>default:\n<line35>*dst++ = s[i];\n<line36>break;\n<line37>}\n<line38>}\n<line39>if (dst < s + s_len)\n<line40>*dst = '\0';\n<line41>return s;\n<line42>}
----------------------------------------
Function: bsd_split_3
Content: <line0>static bool\n<line1>bsd_split_3 (char *s, size_t s_len,\n<line2>unsigned char **digest, size_t *d_len,\n<line3>char **file_name, bool escaped_filename)\n<line4>{\n<line5>if (s_len == 0)\n<line6>return false;\n<line7>/* Find end of filename.  */\n<line8>size_t i = s_len - 1;\n<line9>while (i && s[i] != ')')\n<line10>i--;\n<line11>if (s[i] != ')')\n<line12>return false;\n<line13>*file_name = s;\n<line14>if (escaped_filename && filename_unescape (s, i) == nullptr)\n<line15>return false;\n<line16>s[i++] = '\0';\n<line17>while (ISWHITE (s[i]))\n<line18>i++;\n<line19>if (s[i] != '=')\n<line20>return false;\n<line21>i++;\n<line22>while (ISWHITE (s[i]))\n<line23>i++;\n<line24>*digest = (unsigned char *) &s[i];\n<line25>*d_len = s_len - i;\n<line26>return valid_digits (*digest, *d_len);\n<line27>}
----------------------------------------
Function: split_3
Content: <line0>static bool\n<line1>split_3 (char *s, size_t s_len,\n<line2>unsigned char **digest, size_t *d_len, int *binary, char **file_name)\n<line3>{\n<line4>bool escaped_filename = false;\n<line5>size_t algo_name_len;\n<line6>size_t i = 0;\n<line7>while (ISWHITE (s[i]))\n<line8>++i;\n<line9>if (s[i] == '\\')\n<line10>{\n<line11>++i;\n<line12>escaped_filename = true;\n<line13>}\n<line14>/* Check for BSD-style checksum line. */\n<line15>#if HASH_ALGO_CKSUM\n<line16>if (! algorithm_specified)\n<line17>{\n<line18>ptrdiff_t algo_tag = algorithm_from_tag (s + i);\n<line19>if (algo_tag >= 0)\n<line20>{\n<line21>if (algo_tag <= crc)\n<line22>return false;  /* We don't support checking these older formats.  */\n<line23>cksum_algorithm = algo_tag;\n<line24>}\n<line25>else\n<line26>return false;  /* We only support tagged format without -a.  */\n<line27>}\n<line28>#endif\n<line29>algo_name_len = strlen (DIGEST_TYPE_STRING);\n<line30>if (STREQ_LEN (s + i, DIGEST_TYPE_STRING, algo_name_len))\n<line31>{\n<line32>i += algo_name_len;\n<line33>#if HASH_ALGO_BLAKE2 || HASH_ALGO_CKSUM\n<line34>/* Terminate and match algorithm name.  */\n<line35>char const *algo_name = &s[i - algo_name_len];\n<line36>bool length_specified = s[i] == '-';\n<line37>bool openssl_format = s[i] == '('; /* and no length_specified */\n<line38>s[i++] = '\0';\n<line39>if (!STREQ (algo_name, DIGEST_TYPE_STRING))\n<line40>return false;\n<line41>if (openssl_format)\n<line42>s[--i] = '(';\n<line43># if HASH_ALGO_BLAKE2\n<line44>digest_length = BLAKE2B_MAX_LEN * 8;\n<line45># else\n<line46>digest_length = algorithm_bits[cksum_algorithm];\n<line47># endif\n<line48>if (length_specified)\n<line49>{\n<line50>uintmax_t length;\n<line51>char *siend;\n<line52>if (! (xstrtoumax (s + i, &siend, 0, &length, nullptr) == LONGINT_OK\n<line53>&& 0 < length && length <= digest_length\n<line54>&& length % 8 == 0))\n<line55>return false;\n<line56>i = siend - s;\n<line57>digest_length = length;\n<line58>}\n<line59>digest_hex_bytes = digest_length / 4;\n<line60>#endif\n<line61>if (s[i] == ' ')\n<line62>++i;\n<line63>if (s[i] == '(')\n<line64>{\n<line65>++i;\n<line66>*binary = 0;\n<line67>return bsd_split_3 (s + i, s_len - i,\n<line68>digest, d_len, file_name, escaped_filename);\n<line69>}\n<line70>return false;\n<line71>}\n<line72>/* Ignore this line if it is too short.\n<line73>Each line must have at least 'min_digest_line_length - 1' (or one more, if\n<line74>the first is a backslash) more characters to contain correct message digest\n<line75>information.  */\n<line76>if (s_len - i < min_digest_line_length + (s[i] == '\\'))\n<line77>return false;\n<line78>*digest = (unsigned char *) &s[i];\n<line79>#if HASH_ALGO_BLAKE2 || HASH_ALGO_CKSUM\n<line80>/* Auto determine length.  */\n<line81># if HASH_ALGO_CKSUM\n<line82>if (cksum_algorithm == blake2b) {\n<line83># endif\n<line84>unsigned char const *hp = *digest;\n<line85>digest_hex_bytes = 0;\n<line86>while (isxdigit (*hp++))\n<line87>digest_hex_bytes++;\n<line88>if (digest_hex_bytes < 2 || digest_hex_bytes % 2\n<line89>|| BLAKE2B_MAX_LEN * 2 < digest_hex_bytes)\n<line90>return false;\n<line91>digest_length = digest_hex_bytes * 4;\n<line92># if HASH_ALGO_CKSUM\n<line93>}\n<line94># endif\n<line95>#endif\n<line96>/* This field must be the hexadecimal or base64 representation\n<line97>of the message digest.  */\n<line98>while (s[i] && !ISWHITE (s[i]))\n<line99>i++;\n<line100>/* The digest must be followed by at least one whitespace character.  */\n<line101>if (i == s_len)\n<line102>return false;\n<line103>*d_len = &s[i] - (char *) *digest;\n<line104>s[i++] = '\0';\n<line105>if (! valid_digits (*digest, *d_len))\n<line106>return false;\n<line107>/* If "bsd reversed" format detected.  */\n<line108>if ((s_len - i == 1) || (s[i] != ' ' && s[i] != '*'))\n<line109>{\n<line110>/* Don't allow mixing bsd and standard formats,\n<line111>to minimize security issues with attackers\n<line112>renaming files with leading spaces.\n<line113>This assumes that with bsd format checksums\n<line114>that the first file name does not have\n<line115>a leading ' ' or '*'.  */\n<line116>if (bsd_reversed == 0)\n<line117>return false;\n<line118>bsd_reversed = 1;\n<line119>}\n<line120>else if (bsd_reversed != 1)\n<line121>{\n<line122>bsd_reversed = 0;\n<line123>*binary = (s[i++] == '*');\n<line124>}\n<line125>/* All characters between the type indicator and end of line are\n<line126>significant -- that includes leading and trailing white space.  */\n<line127>*file_name = &s[i];\n<line128>if (escaped_filename)\n<line129>return filename_unescape (&s[i], s_len - i) != nullptr;\n<line130>return true;\n<line131>}
----------------------------------------
Function: print_filename
Content: <line0>static void\n<line1>print_filename (char const *file, bool escape)\n<line2>{\n<line3>if (! escape)\n<line4>{\n<line5>fputs (file, stdout);\n<line6>return;\n<line7>}\n<line8>while (*file)\n<line9>{\n<line10>switch (*file)\n<line11>{\n<line12>case '\n':\n<line13>fputs ("\\n", stdout);\n<line14>break;\n<line15>case '\r':\n<line16>fputs ("\\r", stdout);\n<line17>break;\n<line18>case '\\':\n<line19>fputs ("\\\\", stdout);\n<line20>break;\n<line21>default:\n<line22>putchar (*file);\n<line23>break;\n<line24>}\n<line25>file++;\n<line26>}\n<line27>}
----------------------------------------
Function: digest_file
Content: <line0>static bool\n<line1>digest_file (char const *filename, int *binary, unsigned char *bin_result,\n<line2>bool *missing, MAYBE_UNUSED uintmax_t *length)\n<line3>{\n<line4>FILE *fp;\n<line5>int err;\n<line6>bool is_stdin = STREQ (filename, "-");\n<line7>*missing = false;\n<line8>if (is_stdin)\n<line9>{\n<line10>have_read_stdin = true;\n<line11>fp = stdin;\n<line12>if (O_BINARY && *binary)\n<line13>{\n<line14>if (*binary < 0)\n<line15>*binary = ! isatty (STDIN_FILENO);\n<line16>if (*binary)\n<line17>xset_binary_mode (STDIN_FILENO, O_BINARY);\n<line18>}\n<line19>}\n<line20>else\n<line21>{\n<line22>fp = fopen (filename, (O_BINARY && *binary ? "rb" : "r"));\n<line23>if (fp == nullptr)\n<line24>{\n<line25>if (ignore_missing && errno == ENOENT)\n<line26>{\n<line27>*missing = true;\n<line28>return true;\n<line29>}\n<line30>error (0, errno, "%s", quotef (filename));\n<line31>return false;\n<line32>}\n<line33>}\n<line34>fadvise (fp, FADVISE_SEQUENTIAL);\n<line35>#if HASH_ALGO_CKSUM\n<line36>if (cksum_algorithm == blake2b)\n<line37>*length = digest_length / 8;\n<line38>err = DIGEST_STREAM (fp, bin_result, length);\n<line39>#elif HASH_ALGO_SUM\n<line40>err = DIGEST_STREAM (fp, bin_result, length);\n<line41>#elif HASH_ALGO_BLAKE2\n<line42>err = DIGEST_STREAM (fp, bin_result, digest_length / 8);\n<line43>#else\n<line44>err = DIGEST_STREAM (fp, bin_result);\n<line45>#endif\n<line46>err = err ? errno : 0;\n<line47>if (is_stdin)\n<line48>clearerr (fp);\n<line49>else if (fclose (fp) != 0 && !err)\n<line50>err = errno;\n<line51>if (err)\n<line52>{\n<line53>error (0, err, "%s", quotef (filename));\n<line54>return false;\n<line55>}\n<line56>return true;\n<line57>}
----------------------------------------
Function: output_file
Content: <line0>static void\n<line1>output_file (char const *file, int binary_file, void const *digest,\n<line2>bool raw, bool tagged, unsigned char delim, MAYBE_UNUSED bool args,\n<line3>MAYBE_UNUSED uintmax_t length)\n<line4>{\n<line5># if HASH_ALGO_CKSUM\n<line6>if (raw)\n<line7>{\n<line8>fwrite (digest, 1, digest_length / 8, stdout);\n<line9>return;\n<line10>}\n<line11># endif\n<line12>unsigned char const *bin_buffer = digest;\n<line13>/* Output a leading backslash if the file name contains problematic chars.  */\n<line14>bool needs_escape = delim == '\n' && problematic_chars (file);\n<line15>if (needs_escape)\n<line16>putchar ('\\');\n<line17>if (tagged)\n<line18>{\n<line19>fputs (DIGEST_TYPE_STRING, stdout);\n<line20># if HASH_ALGO_BLAKE2\n<line21>if (digest_length < BLAKE2B_MAX_LEN * 8)\n<line22>printf ("-%"PRIuMAX, digest_length);\n<line23># elif HASH_ALGO_CKSUM\n<line24>if (cksum_algorithm == blake2b)\n<line25>{\n<line26>if (digest_length < BLAKE2B_MAX_LEN * 8)\n<line27>printf ("-%"PRIuMAX, digest_length);\n<line28>}\n<line29># endif\n<line30>fputs (" (", stdout);\n<line31>print_filename (file, needs_escape);\n<line32>fputs (") = ", stdout);\n<line33>}\n<line34># if HASH_ALGO_CKSUM\n<line35>if (base64_digest)\n<line36>{\n<line37>char b64[BASE64_LENGTH (DIGEST_BIN_BYTES) + 1];\n<line38>base64_encode ((char const *) bin_buffer, digest_length / 8,\n<line39>b64, sizeof b64);\n<line40>fputs (b64, stdout);\n<line41>}\n<line42>else\n<line43># endif\n<line44>{\n<line45>for (size_t i = 0; i < (digest_hex_bytes / 2); ++i)\n<line46>printf ("%02x", bin_buffer[i]);\n<line47>}\n<line48>if (!tagged)\n<line49>{\n<line50>putchar (' ');\n<line51>putchar (binary_file ? '*' : ' ');\n<line52>print_filename (file, needs_escape);\n<line53>}\n<line54>putchar (delim);\n<line55>}
----------------------------------------
Function: hex_equal
Content: <line0>static bool\n<line1>hex_equal (unsigned char const *hex_digest, unsigned char const *bin_buffer)\n<line2>{\n<line3>static const char bin2hex[] = { '0', '1', '2', '3',\n<line4>'4', '5', '6', '7',\n<line5>'8', '9', 'a', 'b',\n<line6>'c', 'd', 'e', 'f' };\n<line7>size_t digest_bin_bytes = digest_hex_bytes / 2;\n<line8>/* Compare generated binary number with text representation\n<line9>in check file.  Ignore case of hex digits.  */\n<line10>size_t cnt;\n<line11>for (cnt = 0; cnt < digest_bin_bytes; ++cnt)\n<line12>{\n<line13>if (tolower (hex_digest[2 * cnt])\n<line14>!= bin2hex[bin_buffer[cnt] >> 4]\n<line15>|| (tolower (hex_digest[2 * cnt + 1])\n<line16>!= (bin2hex[bin_buffer[cnt] & 0xf])))\n<line17>break;\n<line18>}\n<line19>return cnt == digest_bin_bytes;\n<line20>}
----------------------------------------
Function: digest_check
Content: <line0>static bool\n<line1>digest_check (char const *checkfile_name)\n<line2>{\n<line3>FILE *checkfile_stream;\n<line4>uintmax_t n_misformatted_lines = 0;\n<line5>uintmax_t n_mismatched_checksums = 0;\n<line6>uintmax_t n_open_or_read_failures = 0;\n<line7>bool properly_formatted_lines = false;\n<line8>bool matched_checksums = false;\n<line9>unsigned char bin_buffer_unaligned[DIGEST_BIN_BYTES + DIGEST_ALIGN];\n<line10>/* Make sure bin_buffer is properly aligned. */\n<line11>unsigned char *bin_buffer = ptr_align (bin_buffer_unaligned, DIGEST_ALIGN);\n<line12>uintmax_t line_number;\n<line13>char *line;\n<line14>size_t line_chars_allocated;\n<line15>bool is_stdin = STREQ (checkfile_name, "-");\n<line16>if (is_stdin)\n<line17>{\n<line18>have_read_stdin = true;\n<line19>checkfile_name = _("standard input");\n<line20>checkfile_stream = stdin;\n<line21>}\n<line22>else\n<line23>{\n<line24>checkfile_stream = fopen (checkfile_name, "r");\n<line25>if (checkfile_stream == nullptr)\n<line26>{\n<line27>error (0, errno, "%s", quotef (checkfile_name));\n<line28>return false;\n<line29>}\n<line30>}\n<line31>line_number = 0;\n<line32>line = nullptr;\n<line33>line_chars_allocated = 0;\n<line34>do\n<line35>{\n<line36>char *filename;\n<line37>int binary;\n<line38>unsigned char *digest;\n<line39>ssize_t line_length;\n<line40>++line_number;\n<line41>if (line_number == 0)\n<line42>error (EXIT_FAILURE, 0, _("%s: too many checksum lines"),\n<line43>quotef (checkfile_name));\n<line44>line_length = getline (&line, &line_chars_allocated, checkfile_stream);\n<line45>if (line_length <= 0)\n<line46>break;\n<line47>/* Ignore comment lines, which begin with a '#' character.  */\n<line48>if (line[0] == '#')\n<line49>continue;\n<line50>/* Remove any trailing newline.  */\n<line51>line_length -= line[line_length - 1] == '\n';\n<line52>/* Remove any trailing carriage return.  */\n<line53>line_length -= line[line_length - (0 < line_length)] == '\r';\n<line54>/* Ignore empty lines.  */\n<line55>if (line_length == 0)\n<line56>continue;\n<line57>line[line_length] = '\0';\n<line58>size_t d_len;\n<line59>if (! (split_3 (line, line_length, &digest, &d_len, &binary, &filename)\n<line60>&& ! (is_stdin && STREQ (filename, "-"))))\n<line61>{\n<line62>++n_misformatted_lines;\n<line63>if (warn)\n<line64>{\n<line65>error (0, 0,\n<line66>_("%s: %" PRIuMAX\n<line67>": improperly formatted %s checksum line"),\n<line68>quotef (checkfile_name), line_number,\n<line69>DIGEST_TYPE_STRING);\n<line70>}\n<line71>}\n<line72>else\n<line73>{\n<line74>bool ok;\n<line75>bool missing;\n<line76>bool needs_escape = ! status_only && problematic_chars (filename);\n<line77>properly_formatted_lines = true;\n<line78>uintmax_t length;\n<line79>ok = digest_file (filename, &binary, bin_buffer, &missing, &length);\n<line80>if (!ok)\n<line81>{\n<line82>++n_open_or_read_failures;\n<line83>if (!status_only)\n<line84>{\n<line85>if (needs_escape)\n<line86>putchar ('\\');\n<line87>print_filename (filename, needs_escape);\n<line88>printf (": %s\n", _("FAILED open or read"));\n<line89>}\n<line90>}\n<line91>else if (ignore_missing && missing)\n<line92>{\n<line93>/* Ignore missing files with --ignore-missing.  */\n<line94>;\n<line95>}\n<line96>else\n<line97>{\n<line98>bool match = false;\n<line99>#if HASH_ALGO_CKSUM\n<line100>if (d_len < digest_hex_bytes)\n<line101>match = b64_equal (digest, bin_buffer);\n<line102>else\n<line103>#endif\n<line104>if (d_len == digest_hex_bytes)\n<line105>match = hex_equal (digest, bin_buffer);\n<line106>if (match)\n<line107>matched_checksums = true;\n<line108>else\n<line109>++n_mismatched_checksums;\n<line110>if (!status_only)\n<line111>{\n<line112>if (! match || ! quiet)\n<line113>{\n<line114>if (needs_escape)\n<line115>putchar ('\\');\n<line116>print_filename (filename, needs_escape);\n<line117>}\n<line118>if (! match)\n<line119>printf (": %s\n", _("FAILED"));\n<line120>else if (!quiet)\n<line121>printf (": %s\n", _("OK"));\n<line122>}\n<line123>}\n<line124>}\n<line125>}\n<line126>while (!feof (checkfile_stream) && !ferror (checkfile_stream));\n<line127>free (line);\n<line128>int err = ferror (checkfile_stream) ? 0 : -1;\n<line129>if (is_stdin)\n<line130>clearerr (checkfile_stream);\n<line131>else if (fclose (checkfile_stream) != 0 && err < 0)\n<line132>err = errno;\n<line133>if (0 <= err)\n<line134>{\n<line135>error (0, err, err ? "%s" : _("%s: read error"),\n<line136>quotef (checkfile_name));\n<line137>return false;\n<line138>}\n<line139>if (! properly_formatted_lines)\n<line140>{\n<line141>/* Warn if no tests are found.  */\n<line142>error (0, 0, _("%s: no properly formatted checksum lines found"),\n<line143>quotef (checkfile_name));\n<line144>}\n<line145>else\n<line146>{\n<line147>if (!status_only)\n<line148>{\n<line149>if (n_misformatted_lines != 0)\n<line150>error (0, 0,\n<line151>(ngettext\n<line152>("WARNING: %" PRIuMAX " line is improperly formatted",\n<line153>"WARNING: %" PRIuMAX " lines are improperly formatted",\n<line154>select_plural (n_misformatted_lines))),\n<line155>n_misformatted_lines);\n<line156>if (n_open_or_read_failures != 0)\n<line157>error (0, 0,\n<line158>(ngettext\n<line159>("WARNING: %" PRIuMAX " listed file could not be read",\n<line160>"WARNING: %" PRIuMAX " listed files could not be read",\n<line161>select_plural (n_open_or_read_failures))),\n<line162>n_open_or_read_failures);\n<line163>if (n_mismatched_checksums != 0)\n<line164>error (0, 0,\n<line165>(ngettext\n<line166>("WARNING: %" PRIuMAX " computed checksum did NOT match",\n<line167>"WARNING: %" PRIuMAX " computed checksums did NOT match",\n<line168>select_plural (n_mismatched_checksums))),\n<line169>n_mismatched_checksums);\n<line170>if (ignore_missing && ! matched_checksums)\n<line171>error (0, 0, _("%s: no file was verified"),\n<line172>quotef (checkfile_name));\n<line173>}\n<line174>}\n<line175>return (properly_formatted_lines\n<line176>&& matched_checksums\n<line177>&& n_mismatched_checksums == 0\n<line178>&& n_open_or_read_failures == 0\n<line179>&& (!strict || n_misformatted_lines == 0));\n<line180>}
----------------------------------------
Function: main
Content: <line0>int\n<line1>main (int argc, char **argv)\n<line2>{\n<line3>unsigned char bin_buffer_unaligned[DIGEST_BIN_BYTES + DIGEST_ALIGN];\n<line4>/* Make sure bin_buffer is properly aligned. */\n<line5>unsigned char *bin_buffer = ptr_align (bin_buffer_unaligned, DIGEST_ALIGN);\n<line6>bool do_check = false;\n<line7>int opt;\n<line8>bool ok = true;\n<line9>int binary = -1;\n<line10>#if HASH_ALGO_CKSUM\n<line11>bool prefix_tag = true;\n<line12>#else\n<line13>bool prefix_tag = false;\n<line14>#endif\n<line15>/* Setting values of global variables.  */\n<line16>initialize_main (&argc, &argv);\n<line17>set_program_name (argv[0]);\n<line18>setlocale (LC_ALL, "");\n<line19>bindtextdomain (PACKAGE, LOCALEDIR);\n<line20>textdomain (PACKAGE);\n<line21>atexit (close_stdout);\n<line22>/* Line buffer stdout to ensure lines are written atomically and immediately\n<line23>so that processes running in parallel do not intersperse their output.  */\n<line24>setvbuf (stdout, nullptr, _IOLBF, 0);\n<line25>#if HASH_ALGO_SUM\n<line26>char const *short_opts = "rs";\n<line27>#elif HASH_ALGO_CKSUM\n<line28>char const *short_opts = "a:l:bctwz";\n<line29>char const *digest_length_str = "";\n<line30>#elif HASH_ALGO_BLAKE2\n<line31>char const *short_opts = "l:bctwz";\n<line32>char const *digest_length_str = "";\n<line33>#else\n<line34>char const *short_opts = "bctwz";\n<line35>#endif\n<line36>while ((opt = getopt_long (argc, argv, short_opts, long_options, nullptr))\n<line37>!= -1)\n<line38>switch (opt)\n<line39>{\n<line40>#if HASH_ALGO_CKSUM\n<line41>case 'a':\n<line42>cksum_algorithm = XARGMATCH_EXACT ("--algorithm", optarg,\n<line43>algorithm_args, algorithm_types);\n<line44>algorithm_specified = true;\n<line45>break;\n<line46>case DEBUG_PROGRAM_OPTION:\n<line47>cksum_debug = true;\n<line48>break;\n<line49>#endif\n<line50>#if HASH_ALGO_BLAKE2 || HASH_ALGO_CKSUM\n<line51>case 'l':\n<line52>digest_length = xdectoumax (optarg, 0, UINTMAX_MAX, "",\n<line53>_("invalid length"), 0);\n<line54>digest_length_str = optarg;\n<line55>if (digest_length % 8 != 0)\n<line56>{\n<line57>error (0, 0, _("invalid length: %s"), quote (digest_length_str));\n<line58>error (EXIT_FAILURE, 0, _("length is not a multiple of 8"));\n<line59>}\n<line60>break;\n<line61>#endif\n<line62>#if !HASH_ALGO_SUM\n<line63>case 'c':\n<line64>do_check = true;\n<line65>break;\n<line66>case STATUS_OPTION:\n<line67>status_only = true;\n<line68>warn = false;\n<line69>quiet = false;\n<line70>break;\n<line71>case 'b':\n<line72>binary = 1;\n<line73>break;\n<line74>case 't':\n<line75>binary = 0;\n<line76>break;\n<line77>case 'w':\n<line78>status_only = false;\n<line79>warn = true;\n<line80>quiet = false;\n<line81>break;\n<line82>case IGNORE_MISSING_OPTION:\n<line83>ignore_missing = true;\n<line84>break;\n<line85>case QUIET_OPTION:\n<line86>status_only = false;\n<line87>warn = false;\n<line88>quiet = true;\n<line89>break;\n<line90>case STRICT_OPTION:\n<line91>strict = true;\n<line92>break;\n<line93># if HASH_ALGO_CKSUM\n<line94>case BASE64_OPTION:\n<line95>base64_digest = true;\n<line96>break;\n<line97>case RAW_OPTION:\n<line98>raw_digest = true;\n<line99>break;\n<line100>case UNTAG_OPTION:\n<line101>prefix_tag = false;\n<line102>break;\n<line103># endif\n<line104>case TAG_OPTION:\n<line105>prefix_tag = true;\n<line106>binary = 1;\n<line107>break;\n<line108>case 'z':\n<line109>digest_delim = '\0';\n<line110>break;\n<line111>#endif\n<line112>#if HASH_ALGO_SUM\n<line113>case 'r':		/* For SysV compatibility. */\n<line114>sum_algorithm = bsd;\n<line115>break;\n<line116>case 's':\n<line117>sum_algorithm = sysv;\n<line118>break;\n<line119>#endif\n<line120>case_GETOPT_HELP_CHAR;\n<line121>case_GETOPT_VERSION_CHAR (PROGRAM_NAME, AUTHORS);\n<line122>default:\n<line123>usage (EXIT_FAILURE);\n<line124>}\n<line125>min_digest_line_length = MIN_DIGEST_LINE_LENGTH;\n<line126>#if HASH_ALGO_BLAKE2 || HASH_ALGO_CKSUM\n<line127># if HASH_ALGO_CKSUM\n<line128>if (digest_length && cksum_algorithm != blake2b)\n<line129>error (EXIT_FAILURE, 0,\n<line130>_("--length is only supported with --algorithm=blake2b"));\n<line131># endif\n<line132>if (digest_length > BLAKE2B_MAX_LEN * 8)\n<line133>{\n<line134>error (0, 0, _("invalid length: %s"), quote (digest_length_str));\n<line135>error (EXIT_FAILURE, 0,\n<line136>_("maximum digest length for %s is %d bits"),\n<line137>quote (DIGEST_TYPE_STRING),\n<line138>BLAKE2B_MAX_LEN * 8);\n<line139>}\n<line140>if (digest_length == 0)\n<line141>{\n<line142># if HASH_ALGO_BLAKE2\n<line143>digest_length = BLAKE2B_MAX_LEN * 8;\n<line144># else\n<line145>digest_length = algorithm_bits[cksum_algorithm];\n<line146># endif\n<line147>}\n<line148>digest_hex_bytes = digest_length / 4;\n<line149>#else\n<line150>digest_hex_bytes = DIGEST_HEX_BYTES;\n<line151>#endif\n<line152>#if HASH_ALGO_CKSUM\n<line153>switch (cksum_algorithm)\n<line154>{\n<line155>case bsd:\n<line156>case sysv:\n<line157>case crc:\n<line158>if (do_check && algorithm_specified)\n<line159>error (EXIT_FAILURE, 0,\n<line160>_("--check is not supported with --algorithm={bsd,sysv,crc}"));\n<line161>break;\n<line162>default:\n<line163>break;\n<line164>}\n<line165>if (base64_digest && raw_digest)\n<line166>{\n<line167>error (0, 0, _("--base64 and --raw are mutually exclusive"));\n<line168>usage (EXIT_FAILURE);\n<line169>}\n<line170>#endif\n<line171>if (prefix_tag && !binary)\n<line172>{\n<line173>/* This could be supported in a backwards compatible way\n<line174>by prefixing the output line with a space in text mode.\n<line175>However that's invasive enough that it was agreed to\n<line176>not support this mode with --tag, as --text use cases\n<line177>are adequately supported by the default output format.  */\n<line178>#if !HASH_ALGO_CKSUM\n<line179>error (0, 0, _("--tag does not support --text mode"));\n<line180>#else\n<line181>error (0, 0, _("--text mode is only supported with --untagged"));\n<line182>#endif\n<line183>usage (EXIT_FAILURE);\n<line184>}\n<line185>if (digest_delim != '\n' && do_check)\n<line186>{\n<line187>error (0, 0, _("the --zero option is not supported when "\n<line188>"verifying checksums"));\n<line189>usage (EXIT_FAILURE);\n<line190>}\n<line191>#if !HASH_ALGO_CKSUM\n<line192>if (prefix_tag && do_check)\n<line193>{\n<line194>error (0, 0, _("the --tag option is meaningless when "\n<line195>"verifying checksums"));\n<line196>usage (EXIT_FAILURE);\n<line197>}\n<line198>#endif\n<line199>if (0 <= binary && do_check)\n<line200>{\n<line201>error (0, 0, _("the --binary and --text options are meaningless when "\n<line202>"verifying checksums"));\n<line203>usage (EXIT_FAILURE);\n<line204>}\n<line205>if (ignore_missing && !do_check)\n<line206>{\n<line207>error (0, 0,\n<line208>_("the --ignore-missing option is meaningful only when "\n<line209>"verifying checksums"));\n<line210>usage (EXIT_FAILURE);\n<line211>}\n<line212>if (status_only && !do_check)\n<line213>{\n<line214>error (0, 0,\n<line215>_("the --status option is meaningful only when verifying checksums"));\n<line216>usage (EXIT_FAILURE);\n<line217>}\n<line218>if (warn && !do_check)\n<line219>{\n<line220>error (0, 0,\n<line221>_("the --warn option is meaningful only when verifying checksums"));\n<line222>usage (EXIT_FAILURE);\n<line223>}\n<line224>if (quiet && !do_check)\n<line225>{\n<line226>error (0, 0,\n<line227>_("the --quiet option is meaningful only when verifying checksums"));\n<line228>usage (EXIT_FAILURE);\n<line229>}\n<line230>if (strict & !do_check)\n<line231>{\n<line232>error (0, 0,\n<line233>_("the --strict option is meaningful only when verifying checksums"));\n<line234>usage (EXIT_FAILURE);\n<line235>}\n<line236>if (!O_BINARY && binary < 0)\n<line237>binary = 0;\n<line238>char **operand_lim = argv + argc;\n<line239>if (optind == argc)\n<line240>*operand_lim++ = bad_cast ("-");\n<line241>else if (1 < argc - optind && raw_digest)\n<line242>error (EXIT_FAILURE, 0,\n<line243>_("the --raw option is not supported with multiple files"));\n<line244>for (char **operandp = argv + optind; operandp < operand_lim; operandp++)\n<line245>{\n<line246>char *file = *operandp;\n<line247>if (do_check)\n<line248>ok &= digest_check (file);\n<line249>else\n<line250>{\n<line251>int binary_file = binary;\n<line252>bool missing;\n<line253>uintmax_t length;\n<line254>if (! digest_file (file, &binary_file, bin_buffer, &missing, &length))\n<line255>ok = false;\n<line256>else\n<line257>{\n<line258>DIGEST_OUT (file, binary_file, bin_buffer, raw_digest, prefix_tag,\n<line259>digest_delim, optind != argc, length);\n<line260>}\n<line261>}\n<line262>}\n<line263>if (have_read_stdin && fclose (stdin) == EOF)\n<line264>error (EXIT_FAILURE, errno, _("standard input"));\n<line265>return ok ? EXIT_SUCCESS : EXIT_FAILURE;\n<line266>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/src/digest.c
========================================
Function: usage
Content: <line0>void\n<line1>usage (int status)\n<line2>{\n<line3>if (status != EXIT_SUCCESS)\n<line4>emit_try_help ();\n<line5>else\n<line6>{\n<line7>printf (_("\\n<line8>Usage: %s [OPTION]... [FILE]...\n\\n<line9>"), program_name);\n<line10>#if HASH_ALGO_CKSUM\n<line11>fputs (_("\\n<line12>Print or verify checksums.\n\\n<line13>By default use the 32 bit CRC algorithm.\n\\n<line14>"), stdout);\n<line15>#else\n<line16>printf (_("\\n<line17>Print or check %s (%d-bit) checksums.\n\\n<line18>"),\n<line19>DIGEST_TYPE_STRING,\n<line20>DIGEST_BITS);\n<line21>#endif\n<line22>emit_stdin_note ();\n<line23>#if HASH_ALGO_SUM\n<line24>fputs (_("\\n<line25>\n\\n<line26>-r              use BSD sum algorithm (the default), use 1K blocks\n\\n<line27>-s, --sysv      use System V sum algorithm, use 512 bytes blocks\n\\n<line28>"), stdout);\n<line29>#endif\n<line30>#if HASH_ALGO_BLAKE2 || HASH_ALGO_CKSUM\n<line31>emit_mandatory_arg_note ();\n<line32>#endif\n<line33>#if HASH_ALGO_CKSUM\n<line34>fputs (_("\\n<line35>-a, --algorithm=TYPE  select the digest type to use.  See DIGEST below.\\n<line36>\n\\n<line37>"), stdout);\n<line38>fputs (_("\\n<line39>--base64          emit base64-encoded digests, not hexadecimal\\n<line40>\n\\n<line41>"), stdout);\n<line42>#endif\n<line43>#if !HASH_ALGO_SUM\n<line44># if !HASH_ALGO_CKSUM\n<line45>if (O_BINARY)\n<line46>fputs (_("\\n<line47>-b, --binary          read in binary mode (default unless reading tty stdin)\\n<line48>\n\\n<line49>"), stdout);\n<line50>else\n<line51>fputs (_("\\n<line52>-b, --binary          read in binary mode\n\\n<line53>"), stdout);\n<line54># endif\n<line55>fputs (_("\\n<line56>-c, --check           read checksums from the FILEs and check them\n\\n<line57>"), stdout);\n<line58># if HASH_ALGO_BLAKE2 || HASH_ALGO_CKSUM\n<line59>fputs (_("\\n<line60>-l, --length=BITS     digest length in bits; must not exceed the max for\n\\n<line61>the blake2 algorithm and must be a multiple of 8\n\\n<line62>"), stdout);\n<line63># endif\n<line64># if HASH_ALGO_CKSUM\n<line65>fputs (_("\\n<line66>--raw             emit a raw binary digest, not hexadecimal\\n<line67>\n\\n<line68>"), stdout);\n<line69>fputs (_("\\n<line70>--tag             create a BSD-style checksum (the default)\n\\n<line71>"), stdout);\n<line72>fputs (_("\\n<line73>--untagged        create a reversed style checksum, without digest type\n\\n<line74>"), stdout);\n<line75># else\n<line76>fputs (_("\\n<line77>--tag             create a BSD-style checksum\n\\n<line78>"), stdout);\n<line79># endif\n<line80># if !HASH_ALGO_CKSUM\n<line81>if (O_BINARY)\n<line82>fputs (_("\\n<line83>-t, --text            read in text mode (default if reading tty stdin)\n\\n<line84>"), stdout);\n<line85>else\n<line86>fputs (_("\\n<line87>-t, --text            read in text mode (default)\n\\n<line88>"), stdout);\n<line89># endif\n<line90>fputs (_("\\n<line91>-z, --zero            end each output line with NUL, not newline,\n\\n<line92>and disable file name escaping\n\\n<line93>"), stdout);\n<line94>fputs (_("\\n<line95>\n\\n<line96>The following five options are useful only when verifying checksums:\n\\n<line97>--ignore-missing  don't fail or report status for missing files\n\\n<line98>--quiet           don't print OK for each successfully verified file\n\\n<line99>--status          don't output anything, status code shows success\n\\n<line100>--strict          exit non-zero for improperly formatted checksum lines\n\\n<line101>-w, --warn            warn about improperly formatted checksum lines\n\\n<line102>\n\\n<line103>"), stdout);\n<line104>#endif\n<line105>#if HASH_ALGO_CKSUM\n<line106>fputs (_("\\n<line107>--debug           indicate which implementation used\n\\n<line108>"), stdout);\n<line109>#endif\n<line110>fputs (HELP_OPTION_DESCRIPTION, stdout);\n<line111>fputs (VERSION_OPTION_DESCRIPTION, stdout);\n<line112>#if HASH_ALGO_CKSUM\n<line113>fputs (_("\\n<line114>\n\\n<line115>DIGEST determines the digest algorithm and default output format:\n\\n<line116>sysv      (equivalent to sum -s)\n\\n<line117>bsd       (equivalent to sum -r)\n\\n<line118>crc       (equivalent to cksum)\n\\n<line119>md5       (equivalent to md5sum)\n\\n<line120>sha1      (equivalent to sha1sum)\n\\n<line121>sha224    (equivalent to sha224sum)\n\\n<line122>sha256    (equivalent to sha256sum)\n\\n<line123>sha384    (equivalent to sha384sum)\n\\n<line124>sha512    (equivalent to sha512sum)\n\\n<line125>blake2b   (equivalent to b2sum)\n\\n<line126>sm3       (only available through cksum)\n\\n<line127>\n"), stdout);\n<line128>#endif\n<line129>#if !HASH_ALGO_SUM && !HASH_ALGO_CKSUM\n<line130>printf (_("\\n<line131>\n\\n<line132>The sums are computed as described in %s.\n"), DIGEST_REFERENCE);\n<line133>fputs (_("\\n<line134>When checking, the input should be a former output of this program.\n\\n<line135>The default mode is to print a line with: checksum, a space,\n\\n<line136>a character indicating input mode ('*' for binary, ' ' for text\n\\n<line137>or where binary is insignificant), and name for each FILE.\n\\n<line138>\n\\n<line139>Note: There is no difference between binary mode and text mode on GNU systems.\\n<line140>\n"), stdout);\n<line141>#endif\n<line142>#if HASH_ALGO_CKSUM\n<line143>fputs (_("\\n<line144>When checking, the input should be a former output of this program,\n\\n<line145>or equivalent standalone program.\\n<line146>\n"), stdout);\n<line147>#endif\n<line148>emit_ancillary_info (PROGRAM_NAME);\n<line149>}\n<line150>exit (status);\n<line151>}
----------------------------------------
Function: filename_unescape
Content: <line0>static char *\n<line1>filename_unescape (char *s, size_t s_len)\n<line2>{\n<line3>char *dst = s;\n<line4>for (size_t i = 0; i < s_len; i++)\n<line5>{\n<line6>switch (s[i])\n<line7>{\n<line8>case '\\':\n<line9>if (i == s_len - 1)\n<line10>{\n<line11>/* File name ends with an unescaped backslash: invalid.  */\n<line12>return nullptr;\n<line13>}\n<line14>++i;\n<line15>switch (s[i])\n<line16>{\n<line17>case 'n':\n<line18>*dst++ = '\n';\n<line19>break;\n<line20>case 'r':\n<line21>*dst++ = '\r';\n<line22>break;\n<line23>case '\\':\n<line24>*dst++ = '\\';\n<line25>break;\n<line26>default:\n<line27>/* Only '\', 'n' or 'r' may follow a backslash.  */\n<line28>return nullptr;\n<line29>}\n<line30>break;\n<line31>case '\0':\n<line32>/* The file name may not contain a NUL.  */\n<line33>return nullptr;\n<line34>default:\n<line35>*dst++ = s[i];\n<line36>break;\n<line37>}\n<line38>}\n<line39>if (dst < s + s_len)\n<line40>*dst = '\0';\n<line41>return s;\n<line42>}
----------------------------------------
Function: bsd_split_3
Content: <line0>static bool\n<line1>bsd_split_3 (char *s, size_t s_len,\n<line2>unsigned char **digest, size_t *d_len,\n<line3>char **file_name, bool escaped_filename)\n<line4>{\n<line5>if (s_len == 0)\n<line6>return false;\n<line7>/* Find end of filename.  */\n<line8>size_t i = s_len - 1;\n<line9>while (i && s[i] != ')')\n<line10>i--;\n<line11>if (s[i] != ')')\n<line12>return false;\n<line13>*file_name = s;\n<line14>if (escaped_filename && filename_unescape (s, i) == nullptr)\n<line15>return false;\n<line16>s[i++] = '\0';\n<line17>while (ISWHITE (s[i]))\n<line18>i++;\n<line19>if (s[i] != '=')\n<line20>return false;\n<line21>i++;\n<line22>while (ISWHITE (s[i]))\n<line23>i++;\n<line24>*digest = (unsigned char *) &s[i];\n<line25>*d_len = s_len - i;\n<line26>return valid_digits (*digest, *d_len);\n<line27>}
----------------------------------------
Function: split_3
Content: <line0>static bool\n<line1>split_3 (char *s, size_t s_len,\n<line2>unsigned char **digest, size_t *d_len, int *binary, char **file_name)\n<line3>{\n<line4>bool escaped_filename = false;\n<line5>size_t algo_name_len;\n<line6>size_t i = 0;\n<line7>while (ISWHITE (s[i]))\n<line8>++i;\n<line9>if (s[i] == '\\')\n<line10>{\n<line11>++i;\n<line12>escaped_filename = true;\n<line13>}\n<line14>/* Check for BSD-style checksum line. */\n<line15>#if HASH_ALGO_CKSUM\n<line16>if (! algorithm_specified)\n<line17>{\n<line18>ptrdiff_t algo_tag = algorithm_from_tag (s + i);\n<line19>if (algo_tag >= 0)\n<line20>{\n<line21>if (algo_tag <= crc)\n<line22>return false;  /* We don't support checking these older formats.  */\n<line23>cksum_algorithm = algo_tag;\n<line24>}\n<line25>else\n<line26>return false;  /* We only support tagged format without -a.  */\n<line27>}\n<line28>#endif\n<line29>algo_name_len = strlen (DIGEST_TYPE_STRING);\n<line30>if (STREQ_LEN (s + i, DIGEST_TYPE_STRING, algo_name_len))\n<line31>{\n<line32>i += algo_name_len;\n<line33>#if HASH_ALGO_BLAKE2 || HASH_ALGO_CKSUM\n<line34>/* Terminate and match algorithm name.  */\n<line35>char const *algo_name = &s[i - algo_name_len];\n<line36>bool length_specified = s[i] == '-';\n<line37>bool openssl_format = s[i] == '('; /* and no length_specified */\n<line38>s[i++] = '\0';\n<line39>if (!STREQ (algo_name, DIGEST_TYPE_STRING))\n<line40>return false;\n<line41>if (openssl_format)\n<line42>s[--i] = '(';\n<line43># if HASH_ALGO_BLAKE2\n<line44>digest_length = BLAKE2B_MAX_LEN * 8;\n<line45># else\n<line46>digest_length = algorithm_bits[cksum_algorithm];\n<line47># endif\n<line48>if (length_specified)\n<line49>{\n<line50>uintmax_t length;\n<line51>char *siend;\n<line52>if (! (xstrtoumax (s + i, &siend, 0, &length, nullptr) == LONGINT_OK\n<line53>&& 0 < length && length <= digest_length\n<line54>&& length % 8 == 0))\n<line55>return false;\n<line56>i = siend - s;\n<line57>digest_length = length;\n<line58>}\n<line59>digest_hex_bytes = digest_length / 4;\n<line60>#endif\n<line61>if (s[i] == ' ')\n<line62>++i;\n<line63>if (s[i] == '(')\n<line64>{\n<line65>++i;\n<line66>*binary = 0;\n<line67>return bsd_split_3 (s + i, s_len - i,\n<line68>digest, d_len, file_name, escaped_filename);\n<line69>}\n<line70>return false;\n<line71>}\n<line72>/* Ignore this line if it is too short.\n<line73>Each line must have at least 'min_digest_line_length - 1' (or one more, if\n<line74>the first is a backslash) more characters to contain correct message digest\n<line75>information.  */\n<line76>if (s_len - i < min_digest_line_length + (s[i] == '\\'))\n<line77>return false;\n<line78>*digest = (unsigned char *) &s[i];\n<line79>#if HASH_ALGO_BLAKE2 || HASH_ALGO_CKSUM\n<line80>/* Auto determine length.  */\n<line81># if HASH_ALGO_CKSUM\n<line82>if (cksum_algorithm == blake2b) {\n<line83># endif\n<line84>unsigned char const *hp = *digest;\n<line85>digest_hex_bytes = 0;\n<line86>while (isxdigit (*hp++))\n<line87>digest_hex_bytes++;\n<line88>if (digest_hex_bytes < 2 || digest_hex_bytes % 2\n<line89>|| BLAKE2B_MAX_LEN * 2 < digest_hex_bytes)\n<line90>return false;\n<line91>digest_length = digest_hex_bytes * 4;\n<line92># if HASH_ALGO_CKSUM\n<line93>}\n<line94># endif\n<line95>#endif\n<line96>/* This field must be the hexadecimal or base64 representation\n<line97>of the message digest.  */\n<line98>while (s[i] && !ISWHITE (s[i]))\n<line99>i++;\n<line100>/* The digest must be followed by at least one whitespace character.  */\n<line101>if (i == s_len)\n<line102>return false;\n<line103>*d_len = &s[i] - (char *) *digest;\n<line104>s[i++] = '\0';\n<line105>if (! valid_digits (*digest, *d_len))\n<line106>return false;\n<line107>/* If "bsd reversed" format detected.  */\n<line108>if ((s_len - i == 1) || (s[i] != ' ' && s[i] != '*'))\n<line109>{\n<line110>/* Don't allow mixing bsd and standard formats,\n<line111>to minimize security issues with attackers\n<line112>renaming files with leading spaces.\n<line113>This assumes that with bsd format checksums\n<line114>that the first file name does not have\n<line115>a leading ' ' or '*'.  */\n<line116>if (bsd_reversed == 0)\n<line117>return false;\n<line118>bsd_reversed = 1;\n<line119>}\n<line120>else if (bsd_reversed != 1)\n<line121>{\n<line122>bsd_reversed = 0;\n<line123>*binary = (s[i++] == '*');\n<line124>}\n<line125>/* All characters between the type indicator and end of line are\n<line126>significant -- that includes leading and trailing white space.  */\n<line127>*file_name = &s[i];\n<line128>if (escaped_filename)\n<line129>return filename_unescape (&s[i], s_len - i) != nullptr;\n<line130>return true;\n<line131>}
----------------------------------------
Function: print_filename
Content: <line0>static void\n<line1>print_filename (char const *file, bool escape)\n<line2>{\n<line3>if (! escape)\n<line4>{\n<line5>fputs (file, stdout);\n<line6>return;\n<line7>}\n<line8>while (*file)\n<line9>{\n<line10>switch (*file)\n<line11>{\n<line12>case '\n':\n<line13>fputs ("\\n", stdout);\n<line14>break;\n<line15>case '\r':\n<line16>fputs ("\\r", stdout);\n<line17>break;\n<line18>case '\\':\n<line19>fputs ("\\\\", stdout);\n<line20>break;\n<line21>default:\n<line22>putchar (*file);\n<line23>break;\n<line24>}\n<line25>file++;\n<line26>}\n<line27>}
----------------------------------------
Function: digest_file
Content: <line0>static bool\n<line1>digest_file (char const *filename, int *binary, unsigned char *bin_result,\n<line2>bool *missing, MAYBE_UNUSED uintmax_t *length)\n<line3>{\n<line4>FILE *fp;\n<line5>int err;\n<line6>bool is_stdin = STREQ (filename, "-");\n<line7>*missing = false;\n<line8>if (is_stdin)\n<line9>{\n<line10>have_read_stdin = true;\n<line11>fp = stdin;\n<line12>if (O_BINARY && *binary)\n<line13>{\n<line14>if (*binary < 0)\n<line15>*binary = ! isatty (STDIN_FILENO);\n<line16>if (*binary)\n<line17>xset_binary_mode (STDIN_FILENO, O_BINARY);\n<line18>}\n<line19>}\n<line20>else\n<line21>{\n<line22>fp = fopen (filename, (O_BINARY && *binary ? "rb" : "r"));\n<line23>if (fp == nullptr)\n<line24>{\n<line25>if (ignore_missing && errno == ENOENT)\n<line26>{\n<line27>*missing = true;\n<line28>return true;\n<line29>}\n<line30>error (0, errno, "%s", quotef (filename));\n<line31>return false;\n<line32>}\n<line33>}\n<line34>fadvise (fp, FADVISE_SEQUENTIAL);\n<line35>#if HASH_ALGO_CKSUM\n<line36>if (cksum_algorithm == blake2b)\n<line37>*length = digest_length / 8;\n<line38>err = DIGEST_STREAM (fp, bin_result, length);\n<line39>#elif HASH_ALGO_SUM\n<line40>err = DIGEST_STREAM (fp, bin_result, length);\n<line41>#elif HASH_ALGO_BLAKE2\n<line42>err = DIGEST_STREAM (fp, bin_result, digest_length / 8);\n<line43>#else\n<line44>err = DIGEST_STREAM (fp, bin_result);\n<line45>#endif\n<line46>err = err ? errno : 0;\n<line47>if (is_stdin)\n<line48>clearerr (fp);\n<line49>else if (fclose (fp) != 0 && !err)\n<line50>err = errno;\n<line51>if (err)\n<line52>{\n<line53>error (0, err, "%s", quotef (filename));\n<line54>return false;\n<line55>}\n<line56>return true;\n<line57>}
----------------------------------------
Function: output_file
Content: <line0>static void\n<line1>output_file (char const *file, int binary_file, void const *digest,\n<line2>bool raw, bool tagged, unsigned char delim, MAYBE_UNUSED bool args,\n<line3>MAYBE_UNUSED uintmax_t length)\n<line4>{\n<line5># if HASH_ALGO_CKSUM\n<line6>if (raw)\n<line7>{\n<line8>fwrite (digest, 1, digest_length / 8, stdout);\n<line9>return;\n<line10>}\n<line11># endif\n<line12>unsigned char const *bin_buffer = digest;\n<line13>/* Output a leading backslash if the file name contains problematic chars.  */\n<line14>bool needs_escape = delim == '\n' && problematic_chars (file);\n<line15>if (needs_escape)\n<line16>putchar ('\\');\n<line17>if (tagged)\n<line18>{\n<line19>fputs (DIGEST_TYPE_STRING, stdout);\n<line20># if HASH_ALGO_BLAKE2\n<line21>if (digest_length < BLAKE2B_MAX_LEN * 8)\n<line22>printf ("-%"PRIuMAX, digest_length);\n<line23># elif HASH_ALGO_CKSUM\n<line24>if (cksum_algorithm == blake2b)\n<line25>{\n<line26>if (digest_length < BLAKE2B_MAX_LEN * 8)\n<line27>printf ("-%"PRIuMAX, digest_length);\n<line28>}\n<line29># endif\n<line30>fputs (" (", stdout);\n<line31>print_filename (file, needs_escape);\n<line32>fputs (") = ", stdout);\n<line33>}\n<line34># if HASH_ALGO_CKSUM\n<line35>if (base64_digest)\n<line36>{\n<line37>char b64[BASE64_LENGTH (DIGEST_BIN_BYTES) + 1];\n<line38>base64_encode ((char const *) bin_buffer, digest_length / 8,\n<line39>b64, sizeof b64);\n<line40>fputs (b64, stdout);\n<line41>}\n<line42>else\n<line43># endif\n<line44>{\n<line45>for (size_t i = 0; i < (digest_hex_bytes / 2); ++i)\n<line46>printf ("%02x", bin_buffer[i]);\n<line47>}\n<line48>if (!tagged)\n<line49>{\n<line50>putchar (' ');\n<line51>putchar (binary_file ? '*' : ' ');\n<line52>print_filename (file, needs_escape);\n<line53>}\n<line54>putchar (delim);\n<line55>}
----------------------------------------
Function: hex_equal
Content: <line0>static bool\n<line1>hex_equal (unsigned char const *hex_digest, unsigned char const *bin_buffer)\n<line2>{\n<line3>static const char bin2hex[] = { '0', '1', '2', '3',\n<line4>'4', '5', '6', '7',\n<line5>'8', '9', 'a', 'b',\n<line6>'c', 'd', 'e', 'f' };\n<line7>size_t digest_bin_bytes = digest_hex_bytes / 2;\n<line8>/* Compare generated binary number with text representation\n<line9>in check file.  Ignore case of hex digits.  */\n<line10>size_t cnt;\n<line11>for (cnt = 0; cnt < digest_bin_bytes; ++cnt)\n<line12>{\n<line13>if (tolower (hex_digest[2 * cnt])\n<line14>!= bin2hex[bin_buffer[cnt] >> 4]\n<line15>|| (tolower (hex_digest[2 * cnt + 1])\n<line16>!= (bin2hex[bin_buffer[cnt] & 0xf])))\n<line17>break;\n<line18>}\n<line19>return cnt == digest_bin_bytes;\n<line20>}
----------------------------------------
Function: digest_check
Content: <line0>static bool\n<line1>digest_check (char const *checkfile_name)\n<line2>{\n<line3>FILE *checkfile_stream;\n<line4>uintmax_t n_misformatted_lines = 0;\n<line5>uintmax_t n_mismatched_checksums = 0;\n<line6>uintmax_t n_open_or_read_failures = 0;\n<line7>bool properly_formatted_lines = false;\n<line8>bool matched_checksums = false;\n<line9>unsigned char bin_buffer_unaligned[DIGEST_BIN_BYTES + DIGEST_ALIGN];\n<line10>/* Make sure bin_buffer is properly aligned. */\n<line11>unsigned char *bin_buffer = ptr_align (bin_buffer_unaligned, DIGEST_ALIGN);\n<line12>uintmax_t line_number;\n<line13>char *line;\n<line14>size_t line_chars_allocated;\n<line15>bool is_stdin = STREQ (checkfile_name, "-");\n<line16>if (is_stdin)\n<line17>{\n<line18>have_read_stdin = true;\n<line19>checkfile_name = _("standard input");\n<line20>checkfile_stream = stdin;\n<line21>}\n<line22>else\n<line23>{\n<line24>checkfile_stream = fopen (checkfile_name, "r");\n<line25>if (checkfile_stream == nullptr)\n<line26>{\n<line27>error (0, errno, "%s", quotef (checkfile_name));\n<line28>return false;\n<line29>}\n<line30>}\n<line31>line_number = 0;\n<line32>line = nullptr;\n<line33>line_chars_allocated = 0;\n<line34>do\n<line35>{\n<line36>char *filename;\n<line37>int binary;\n<line38>unsigned char *digest;\n<line39>ssize_t line_length;\n<line40>++line_number;\n<line41>if (line_number == 0)\n<line42>error (EXIT_FAILURE, 0, _("%s: too many checksum lines"),\n<line43>quotef (checkfile_name));\n<line44>line_length = getline (&line, &line_chars_allocated, checkfile_stream);\n<line45>if (line_length <= 0)\n<line46>break;\n<line47>/* Ignore comment lines, which begin with a '#' character.  */\n<line48>if (line[0] == '#')\n<line49>continue;\n<line50>/* Remove any trailing newline.  */\n<line51>line_length -= line[line_length - 1] == '\n';\n<line52>/* Remove any trailing carriage return.  */\n<line53>line_length -= line[line_length - (0 < line_length)] == '\r';\n<line54>/* Ignore empty lines.  */\n<line55>if (line_length == 0)\n<line56>continue;\n<line57>line[line_length] = '\0';\n<line58>size_t d_len;\n<line59>if (! (split_3 (line, line_length, &digest, &d_len, &binary, &filename)\n<line60>&& ! (is_stdin && STREQ (filename, "-"))))\n<line61>{\n<line62>++n_misformatted_lines;\n<line63>if (warn)\n<line64>{\n<line65>error (0, 0,\n<line66>_("%s: %" PRIuMAX\n<line67>": improperly formatted %s checksum line"),\n<line68>quotef (checkfile_name), line_number,\n<line69>DIGEST_TYPE_STRING);\n<line70>}\n<line71>}\n<line72>else\n<line73>{\n<line74>bool ok;\n<line75>bool missing;\n<line76>bool needs_escape = ! status_only && problematic_chars (filename);\n<line77>properly_formatted_lines = true;\n<line78>uintmax_t length;\n<line79>ok = digest_file (filename, &binary, bin_buffer, &missing, &length);\n<line80>if (!ok)\n<line81>{\n<line82>++n_open_or_read_failures;\n<line83>if (!status_only)\n<line84>{\n<line85>if (needs_escape)\n<line86>putchar ('\\');\n<line87>print_filename (filename, needs_escape);\n<line88>printf (": %s\n", _("FAILED open or read"));\n<line89>}\n<line90>}\n<line91>else if (ignore_missing && missing)\n<line92>{\n<line93>/* Ignore missing files with --ignore-missing.  */\n<line94>;\n<line95>}\n<line96>else\n<line97>{\n<line98>bool match = false;\n<line99>#if HASH_ALGO_CKSUM\n<line100>if (d_len < digest_hex_bytes)\n<line101>match = b64_equal (digest, bin_buffer);\n<line102>else\n<line103>#endif\n<line104>if (d_len == digest_hex_bytes)\n<line105>match = hex_equal (digest, bin_buffer);\n<line106>if (match)\n<line107>matched_checksums = true;\n<line108>else\n<line109>++n_mismatched_checksums;\n<line110>if (!status_only)\n<line111>{\n<line112>if (! match || ! quiet)\n<line113>{\n<line114>if (needs_escape)\n<line115>putchar ('\\');\n<line116>print_filename (filename, needs_escape);\n<line117>}\n<line118>if (! match)\n<line119>printf (": %s\n", _("FAILED"));\n<line120>else if (!quiet)\n<line121>printf (": %s\n", _("OK"));\n<line122>}\n<line123>}\n<line124>}\n<line125>}\n<line126>while (!feof (checkfile_stream) && !ferror (checkfile_stream));\n<line127>free (line);\n<line128>int err = ferror (checkfile_stream) ? 0 : -1;\n<line129>if (is_stdin)\n<line130>clearerr (checkfile_stream);\n<line131>else if (fclose (checkfile_stream) != 0 && err < 0)\n<line132>err = errno;\n<line133>if (0 <= err)\n<line134>{\n<line135>error (0, err, err ? "%s" : _("%s: read error"),\n<line136>quotef (checkfile_name));\n<line137>return false;\n<line138>}\n<line139>if (! properly_formatted_lines)\n<line140>{\n<line141>/* Warn if no tests are found.  */\n<line142>error (0, 0, _("%s: no properly formatted checksum lines found"),\n<line143>quotef (checkfile_name));\n<line144>}\n<line145>else\n<line146>{\n<line147>if (!status_only)\n<line148>{\n<line149>if (n_misformatted_lines != 0)\n<line150>error (0, 0,\n<line151>(ngettext\n<line152>("WARNING: %" PRIuMAX " line is improperly formatted",\n<line153>"WARNING: %" PRIuMAX " lines are improperly formatted",\n<line154>select_plural (n_misformatted_lines))),\n<line155>n_misformatted_lines);\n<line156>if (n_open_or_read_failures != 0)\n<line157>error (0, 0,\n<line158>(ngettext\n<line159>("WARNING: %" PRIuMAX " listed file could not be read",\n<line160>"WARNING: %" PRIuMAX " listed files could not be read",\n<line161>select_plural (n_open_or_read_failures))),\n<line162>n_open_or_read_failures);\n<line163>if (n_mismatched_checksums != 0)\n<line164>error (0, 0,\n<line165>(ngettext\n<line166>("WARNING: %" PRIuMAX " computed checksum did NOT match",\n<line167>"WARNING: %" PRIuMAX " computed checksums did NOT match",\n<line168>select_plural (n_mismatched_checksums))),\n<line169>n_mismatched_checksums);\n<line170>if (ignore_missing && ! matched_checksums)\n<line171>error (0, 0, _("%s: no file was verified"),\n<line172>quotef (checkfile_name));\n<line173>}\n<line174>}\n<line175>return (properly_formatted_lines\n<line176>&& matched_checksums\n<line177>&& n_mismatched_checksums == 0\n<line178>&& n_open_or_read_failures == 0\n<line179>&& (!strict || n_misformatted_lines == 0));\n<line180>}
----------------------------------------
Function: main
Content: <line0>int\n<line1>main (int argc, char **argv)\n<line2>{\n<line3>unsigned char bin_buffer_unaligned[DIGEST_BIN_BYTES + DIGEST_ALIGN];\n<line4>/* Make sure bin_buffer is properly aligned. */\n<line5>unsigned char *bin_buffer = ptr_align (bin_buffer_unaligned, DIGEST_ALIGN);\n<line6>bool do_check = false;\n<line7>int opt;\n<line8>bool ok = true;\n<line9>int binary = -1;\n<line10>#if HASH_ALGO_CKSUM\n<line11>bool prefix_tag = true;\n<line12>#else\n<line13>bool prefix_tag = false;\n<line14>#endif\n<line15>/* Setting values of global variables.  */\n<line16>initialize_main (&argc, &argv);\n<line17>set_program_name (argv[0]);\n<line18>setlocale (LC_ALL, "");\n<line19>bindtextdomain (PACKAGE, LOCALEDIR);\n<line20>textdomain (PACKAGE);\n<line21>atexit (close_stdout);\n<line22>/* Line buffer stdout to ensure lines are written atomically and immediately\n<line23>so that processes running in parallel do not intersperse their output.  */\n<line24>setvbuf (stdout, nullptr, _IOLBF, 0);\n<line25>#if HASH_ALGO_SUM\n<line26>char const *short_opts = "rs";\n<line27>#elif HASH_ALGO_CKSUM\n<line28>char const *short_opts = "a:l:bctwz";\n<line29>char const *digest_length_str = "";\n<line30>#elif HASH_ALGO_BLAKE2\n<line31>char const *short_opts = "l:bctwz";\n<line32>char const *digest_length_str = "";\n<line33>#else\n<line34>char const *short_opts = "bctwz";\n<line35>#endif\n<line36>while ((opt = getopt_long (argc, argv, short_opts, long_options, nullptr))\n<line37>!= -1)\n<line38>switch (opt)\n<line39>{\n<line40>#if HASH_ALGO_CKSUM\n<line41>case 'a':\n<line42>cksum_algorithm = XARGMATCH_EXACT ("--algorithm", optarg,\n<line43>algorithm_args, algorithm_types);\n<line44>algorithm_specified = true;\n<line45>break;\n<line46>case DEBUG_PROGRAM_OPTION:\n<line47>cksum_debug = true;\n<line48>break;\n<line49>#endif\n<line50>#if HASH_ALGO_BLAKE2 || HASH_ALGO_CKSUM\n<line51>case 'l':\n<line52>digest_length = xdectoumax (optarg, 0, UINTMAX_MAX, "",\n<line53>_("invalid length"), 0);\n<line54>digest_length_str = optarg;\n<line55>if (digest_length % 8 != 0)\n<line56>{\n<line57>error (0, 0, _("invalid length: %s"), quote (digest_length_str));\n<line58>error (EXIT_FAILURE, 0, _("length is not a multiple of 8"));\n<line59>}\n<line60>break;\n<line61>#endif\n<line62>#if !HASH_ALGO_SUM\n<line63>case 'c':\n<line64>do_check = true;\n<line65>break;\n<line66>case STATUS_OPTION:\n<line67>status_only = true;\n<line68>warn = false;\n<line69>quiet = false;\n<line70>break;\n<line71>case 'b':\n<line72>binary = 1;\n<line73>break;\n<line74>case 't':\n<line75>binary = 0;\n<line76>break;\n<line77>case 'w':\n<line78>status_only = false;\n<line79>warn = true;\n<line80>quiet = false;\n<line81>break;\n<line82>case IGNORE_MISSING_OPTION:\n<line83>ignore_missing = true;\n<line84>break;\n<line85>case QUIET_OPTION:\n<line86>status_only = false;\n<line87>warn = false;\n<line88>quiet = true;\n<line89>break;\n<line90>case STRICT_OPTION:\n<line91>strict = true;\n<line92>break;\n<line93># if HASH_ALGO_CKSUM\n<line94>case BASE64_OPTION:\n<line95>base64_digest = true;\n<line96>break;\n<line97>case RAW_OPTION:\n<line98>raw_digest = true;\n<line99>break;\n<line100>case UNTAG_OPTION:\n<line101>prefix_tag = false;\n<line102>break;\n<line103># endif\n<line104>case TAG_OPTION:\n<line105>prefix_tag = true;\n<line106>binary = 1;\n<line107>break;\n<line108>case 'z':\n<line109>digest_delim = '\0';\n<line110>break;\n<line111>#endif\n<line112>#if HASH_ALGO_SUM\n<line113>case 'r':		/* For SysV compatibility. */\n<line114>sum_algorithm = bsd;\n<line115>break;\n<line116>case 's':\n<line117>sum_algorithm = sysv;\n<line118>break;\n<line119>#endif\n<line120>case_GETOPT_HELP_CHAR;\n<line121>case_GETOPT_VERSION_CHAR (PROGRAM_NAME, AUTHORS);\n<line122>default:\n<line123>usage (EXIT_FAILURE);\n<line124>}\n<line125>min_digest_line_length = MIN_DIGEST_LINE_LENGTH;\n<line126>#if HASH_ALGO_BLAKE2 || HASH_ALGO_CKSUM\n<line127># if HASH_ALGO_CKSUM\n<line128>if (digest_length && cksum_algorithm != blake2b)\n<line129>error (EXIT_FAILURE, 0,\n<line130>_("--length is only supported with --algorithm=blake2b"));\n<line131># endif\n<line132>if (digest_length > BLAKE2B_MAX_LEN * 8)\n<line133>{\n<line134>error (0, 0, _("invalid length: %s"), quote (digest_length_str));\n<line135>error (EXIT_FAILURE, 0,\n<line136>_("maximum digest length for %s is %d bits"),\n<line137>quote (DIGEST_TYPE_STRING),\n<line138>BLAKE2B_MAX_LEN * 8);\n<line139>}\n<line140>if (digest_length == 0)\n<line141>{\n<line142># if HASH_ALGO_BLAKE2\n<line143>digest_length = BLAKE2B_MAX_LEN * 8;\n<line144># else\n<line145>digest_length = algorithm_bits[cksum_algorithm];\n<line146># endif\n<line147>}\n<line148>digest_hex_bytes = digest_length / 4;\n<line149>#else\n<line150>digest_hex_bytes = DIGEST_HEX_BYTES;\n<line151>#endif\n<line152>#if HASH_ALGO_CKSUM\n<line153>switch (cksum_algorithm)\n<line154>{\n<line155>case bsd:\n<line156>case sysv:\n<line157>case crc:\n<line158>if (do_check && algorithm_specified)\n<line159>error (EXIT_FAILURE, 0,\n<line160>_("--check is not supported with --algorithm={bsd,sysv,crc}"));\n<line161>break;\n<line162>default:\n<line163>break;\n<line164>}\n<line165>if (base64_digest && raw_digest)\n<line166>{\n<line167>error (0, 0, _("--base64 and --raw are mutually exclusive"));\n<line168>usage (EXIT_FAILURE);\n<line169>}\n<line170>#endif\n<line171>if (prefix_tag && !binary)\n<line172>{\n<line173>/* This could be supported in a backwards compatible way\n<line174>by prefixing the output line with a space in text mode.\n<line175>However that's invasive enough that it was agreed to\n<line176>not support this mode with --tag, as --text use cases\n<line177>are adequately supported by the default output format.  */\n<line178>#if !HASH_ALGO_CKSUM\n<line179>error (0, 0, _("--tag does not support --text mode"));\n<line180>#else\n<line181>error (0, 0, _("--text mode is only supported with --untagged"));\n<line182>#endif\n<line183>usage (EXIT_FAILURE);\n<line184>}\n<line185>if (digest_delim != '\n' && do_check)\n<line186>{\n<line187>error (0, 0, _("the --zero option is not supported when "\n<line188>"verifying checksums"));\n<line189>usage (EXIT_FAILURE);\n<line190>}\n<line191>#if !HASH_ALGO_CKSUM\n<line192>if (prefix_tag && do_check)\n<line193>{\n<line194>error (0, 0, _("the --tag option is meaningless when "\n<line195>"verifying checksums"));\n<line196>usage (EXIT_FAILURE);\n<line197>}\n<line198>#endif\n<line199>if (0 <= binary && do_check)\n<line200>{\n<line201>error (0, 0, _("the --binary and --text options are meaningless when "\n<line202>"verifying checksums"));\n<line203>usage (EXIT_FAILURE);\n<line204>}\n<line205>if (ignore_missing && !do_check)\n<line206>{\n<line207>error (0, 0,\n<line208>_("the --ignore-missing option is meaningful only when "\n<line209>"verifying checksums"));\n<line210>usage (EXIT_FAILURE);\n<line211>}\n<line212>if (status_only && !do_check)\n<line213>{\n<line214>error (0, 0,\n<line215>_("the --status option is meaningful only when verifying checksums"));\n<line216>usage (EXIT_FAILURE);\n<line217>}\n<line218>if (warn && !do_check)\n<line219>{\n<line220>error (0, 0,\n<line221>_("the --warn option is meaningful only when verifying checksums"));\n<line222>usage (EXIT_FAILURE);\n<line223>}\n<line224>if (quiet && !do_check)\n<line225>{\n<line226>error (0, 0,\n<line227>_("the --quiet option is meaningful only when verifying checksums"));\n<line228>usage (EXIT_FAILURE);\n<line229>}\n<line230>if (strict & !do_check)\n<line231>{\n<line232>error (0, 0,\n<line233>_("the --strict option is meaningful only when verifying checksums"));\n<line234>usage (EXIT_FAILURE);\n<line235>}\n<line236>if (!O_BINARY && binary < 0)\n<line237>binary = 0;\n<line238>char **operand_lim = argv + argc;\n<line239>if (optind == argc)\n<line240>*operand_lim++ = bad_cast ("-");\n<line241>else if (1 < argc - optind && raw_digest)\n<line242>error (EXIT_FAILURE, 0,\n<line243>_("the --raw option is not supported with multiple files"));\n<line244>for (char **operandp = argv + optind; operandp < operand_lim; operandp++)\n<line245>{\n<line246>char *file = *operandp;\n<line247>if (do_check)\n<line248>ok &= digest_check (file);\n<line249>else\n<line250>{\n<line251>int binary_file = binary;\n<line252>bool missing;\n<line253>uintmax_t length;\n<line254>if (! digest_file (file, &binary_file, bin_buffer, &missing, &length))\n<line255>ok = false;\n<line256>else\n<line257>{\n<line258>DIGEST_OUT (file, binary_file, bin_buffer, raw_digest, prefix_tag,\n<line259>digest_delim, optind != argc, length);\n<line260>}\n<line261>}\n<line262>}\n<line263>if (have_read_stdin && fclose (stdin) == EOF)\n<line264>error (EXIT_FAILURE, errno, _("standard input"));\n<line265>return ok ? EXIT_SUCCESS : EXIT_FAILURE;\n<line266>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/src/digest.c
========================================
Function: usage
Content: <line0>void\n<line1>usage (int status)\n<line2>{\n<line3>if (status != EXIT_SUCCESS)\n<line4>emit_try_help ();\n<line5>else\n<line6>{\n<line7>printf (_("\\n<line8>Usage: %s [OPTION]... [FILE]...\n\\n<line9>"), program_name);\n<line10>#if HASH_ALGO_CKSUM\n<line11>fputs (_("\\n<line12>Print or verify checksums.\n\\n<line13>By default use the 32 bit CRC algorithm.\n\\n<line14>"), stdout);\n<line15>#else\n<line16>printf (_("\\n<line17>Print or check %s (%d-bit) checksums.\n\\n<line18>"),\n<line19>DIGEST_TYPE_STRING,\n<line20>DIGEST_BITS);\n<line21>#endif\n<line22>emit_stdin_note ();\n<line23>#if HASH_ALGO_SUM\n<line24>fputs (_("\\n<line25>\n\\n<line26>-r              use BSD sum algorithm (the default), use 1K blocks\n\\n<line27>-s, --sysv      use System V sum algorithm, use 512 bytes blocks\n\\n<line28>"), stdout);\n<line29>#endif\n<line30>#if HASH_ALGO_BLAKE2 || HASH_ALGO_CKSUM\n<line31>emit_mandatory_arg_note ();\n<line32>#endif\n<line33>#if HASH_ALGO_CKSUM\n<line34>fputs (_("\\n<line35>-a, --algorithm=TYPE  select the digest type to use.  See DIGEST below.\\n<line36>\n\\n<line37>"), stdout);\n<line38>fputs (_("\\n<line39>--base64          emit base64-encoded digests, not hexadecimal\\n<line40>\n\\n<line41>"), stdout);\n<line42>#endif\n<line43>#if !HASH_ALGO_SUM\n<line44># if !HASH_ALGO_CKSUM\n<line45>if (O_BINARY)\n<line46>fputs (_("\\n<line47>-b, --binary          read in binary mode (default unless reading tty stdin)\\n<line48>\n\\n<line49>"), stdout);\n<line50>else\n<line51>fputs (_("\\n<line52>-b, --binary          read in binary mode\n\\n<line53>"), stdout);\n<line54># endif\n<line55>fputs (_("\\n<line56>-c, --check           read checksums from the FILEs and check them\n\\n<line57>"), stdout);\n<line58># if HASH_ALGO_BLAKE2 || HASH_ALGO_CKSUM\n<line59>fputs (_("\\n<line60>-l, --length=BITS     digest length in bits; must not exceed the max for\n\\n<line61>the blake2 algorithm and must be a multiple of 8\n\\n<line62>"), stdout);\n<line63># endif\n<line64># if HASH_ALGO_CKSUM\n<line65>fputs (_("\\n<line66>--raw             emit a raw binary digest, not hexadecimal\\n<line67>\n\\n<line68>"), stdout);\n<line69>fputs (_("\\n<line70>--tag             create a BSD-style checksum (the default)\n\\n<line71>"), stdout);\n<line72>fputs (_("\\n<line73>--untagged        create a reversed style checksum, without digest type\n\\n<line74>"), stdout);\n<line75># else\n<line76>fputs (_("\\n<line77>--tag             create a BSD-style checksum\n\\n<line78>"), stdout);\n<line79># endif\n<line80># if !HASH_ALGO_CKSUM\n<line81>if (O_BINARY)\n<line82>fputs (_("\\n<line83>-t, --text            read in text mode (default if reading tty stdin)\n\\n<line84>"), stdout);\n<line85>else\n<line86>fputs (_("\\n<line87>-t, --text            read in text mode (default)\n\\n<line88>"), stdout);\n<line89># endif\n<line90>fputs (_("\\n<line91>-z, --zero            end each output line with NUL, not newline,\n\\n<line92>and disable file name escaping\n\\n<line93>"), stdout);\n<line94>fputs (_("\\n<line95>\n\\n<line96>The following five options are useful only when verifying checksums:\n\\n<line97>--ignore-missing  don't fail or report status for missing files\n\\n<line98>--quiet           don't print OK for each successfully verified file\n\\n<line99>--status          don't output anything, status code shows success\n\\n<line100>--strict          exit non-zero for improperly formatted checksum lines\n\\n<line101>-w, --warn            warn about improperly formatted checksum lines\n\\n<line102>\n\\n<line103>"), stdout);\n<line104>#endif\n<line105>#if HASH_ALGO_CKSUM\n<line106>fputs (_("\\n<line107>--debug           indicate which implementation used\n\\n<line108>"), stdout);\n<line109>#endif\n<line110>fputs (HELP_OPTION_DESCRIPTION, stdout);\n<line111>fputs (VERSION_OPTION_DESCRIPTION, stdout);\n<line112>#if HASH_ALGO_CKSUM\n<line113>fputs (_("\\n<line114>\n\\n<line115>DIGEST determines the digest algorithm and default output format:\n\\n<line116>sysv      (equivalent to sum -s)\n\\n<line117>bsd       (equivalent to sum -r)\n\\n<line118>crc       (equivalent to cksum)\n\\n<line119>md5       (equivalent to md5sum)\n\\n<line120>sha1      (equivalent to sha1sum)\n\\n<line121>sha224    (equivalent to sha224sum)\n\\n<line122>sha256    (equivalent to sha256sum)\n\\n<line123>sha384    (equivalent to sha384sum)\n\\n<line124>sha512    (equivalent to sha512sum)\n\\n<line125>blake2b   (equivalent to b2sum)\n\\n<line126>sm3       (only available through cksum)\n\\n<line127>\n"), stdout);\n<line128>#endif\n<line129>#if !HASH_ALGO_SUM && !HASH_ALGO_CKSUM\n<line130>printf (_("\\n<line131>\n\\n<line132>The sums are computed as described in %s.\n"), DIGEST_REFERENCE);\n<line133>fputs (_("\\n<line134>When checking, the input should be a former output of this program.\n\\n<line135>The default mode is to print a line with: checksum, a space,\n\\n<line136>a character indicating input mode ('*' for binary, ' ' for text\n\\n<line137>or where binary is insignificant), and name for each FILE.\n\\n<line138>\n\\n<line139>Note: There is no difference between binary mode and text mode on GNU systems.\\n<line140>\n"), stdout);\n<line141>#endif\n<line142>#if HASH_ALGO_CKSUM\n<line143>fputs (_("\\n<line144>When checking, the input should be a former output of this program,\n\\n<line145>or equivalent standalone program.\\n<line146>\n"), stdout);\n<line147>#endif\n<line148>emit_ancillary_info (PROGRAM_NAME);\n<line149>}\n<line150>exit (status);\n<line151>}
----------------------------------------
Function: filename_unescape
Content: <line0>static char *\n<line1>filename_unescape (char *s, size_t s_len)\n<line2>{\n<line3>char *dst = s;\n<line4>for (size_t i = 0; i < s_len; i++)\n<line5>{\n<line6>switch (s[i])\n<line7>{\n<line8>case '\\':\n<line9>if (i == s_len - 1)\n<line10>{\n<line11>/* File name ends with an unescaped backslash: invalid.  */\n<line12>return nullptr;\n<line13>}\n<line14>++i;\n<line15>switch (s[i])\n<line16>{\n<line17>case 'n':\n<line18>*dst++ = '\n';\n<line19>break;\n<line20>case 'r':\n<line21>*dst++ = '\r';\n<line22>break;\n<line23>case '\\':\n<line24>*dst++ = '\\';\n<line25>break;\n<line26>default:\n<line27>/* Only '\', 'n' or 'r' may follow a backslash.  */\n<line28>return nullptr;\n<line29>}\n<line30>break;\n<line31>case '\0':\n<line32>/* The file name may not contain a NUL.  */\n<line33>return nullptr;\n<line34>default:\n<line35>*dst++ = s[i];\n<line36>break;\n<line37>}\n<line38>}\n<line39>if (dst < s + s_len)\n<line40>*dst = '\0';\n<line41>return s;\n<line42>}
----------------------------------------
Function: bsd_split_3
Content: <line0>static bool\n<line1>bsd_split_3 (char *s, size_t s_len,\n<line2>unsigned char **digest, size_t *d_len,\n<line3>char **file_name, bool escaped_filename)\n<line4>{\n<line5>if (s_len == 0)\n<line6>return false;\n<line7>/* Find end of filename.  */\n<line8>size_t i = s_len - 1;\n<line9>while (i && s[i] != ')')\n<line10>i--;\n<line11>if (s[i] != ')')\n<line12>return false;\n<line13>*file_name = s;\n<line14>if (escaped_filename && filename_unescape (s, i) == nullptr)\n<line15>return false;\n<line16>s[i++] = '\0';\n<line17>while (ISWHITE (s[i]))\n<line18>i++;\n<line19>if (s[i] != '=')\n<line20>return false;\n<line21>i++;\n<line22>while (ISWHITE (s[i]))\n<line23>i++;\n<line24>*digest = (unsigned char *) &s[i];\n<line25>*d_len = s_len - i;\n<line26>return valid_digits (*digest, *d_len);\n<line27>}
----------------------------------------
Function: split_3
Content: <line0>static bool\n<line1>split_3 (char *s, size_t s_len,\n<line2>unsigned char **digest, size_t *d_len, int *binary, char **file_name)\n<line3>{\n<line4>bool escaped_filename = false;\n<line5>size_t algo_name_len;\n<line6>size_t i = 0;\n<line7>while (ISWHITE (s[i]))\n<line8>++i;\n<line9>if (s[i] == '\\')\n<line10>{\n<line11>++i;\n<line12>escaped_filename = true;\n<line13>}\n<line14>/* Check for BSD-style checksum line. */\n<line15>#if HASH_ALGO_CKSUM\n<line16>if (! algorithm_specified)\n<line17>{\n<line18>ptrdiff_t algo_tag = algorithm_from_tag (s + i);\n<line19>if (algo_tag >= 0)\n<line20>{\n<line21>if (algo_tag <= crc)\n<line22>return false;  /* We don't support checking these older formats.  */\n<line23>cksum_algorithm = algo_tag;\n<line24>}\n<line25>else\n<line26>return false;  /* We only support tagged format without -a.  */\n<line27>}\n<line28>#endif\n<line29>algo_name_len = strlen (DIGEST_TYPE_STRING);\n<line30>if (STREQ_LEN (s + i, DIGEST_TYPE_STRING, algo_name_len))\n<line31>{\n<line32>i += algo_name_len;\n<line33>#if HASH_ALGO_BLAKE2 || HASH_ALGO_CKSUM\n<line34>/* Terminate and match algorithm name.  */\n<line35>char const *algo_name = &s[i - algo_name_len];\n<line36>bool length_specified = s[i] == '-';\n<line37>bool openssl_format = s[i] == '('; /* and no length_specified */\n<line38>s[i++] = '\0';\n<line39>if (!STREQ (algo_name, DIGEST_TYPE_STRING))\n<line40>return false;\n<line41>if (openssl_format)\n<line42>s[--i] = '(';\n<line43># if HASH_ALGO_BLAKE2\n<line44>digest_length = BLAKE2B_MAX_LEN * 8;\n<line45># else\n<line46>digest_length = algorithm_bits[cksum_algorithm];\n<line47># endif\n<line48>if (length_specified)\n<line49>{\n<line50>uintmax_t length;\n<line51>char *siend;\n<line52>if (! (xstrtoumax (s + i, &siend, 0, &length, nullptr) == LONGINT_OK\n<line53>&& 0 < length && length <= digest_length\n<line54>&& length % 8 == 0))\n<line55>return false;\n<line56>i = siend - s;\n<line57>digest_length = length;\n<line58>}\n<line59>digest_hex_bytes = digest_length / 4;\n<line60>#endif\n<line61>if (s[i] == ' ')\n<line62>++i;\n<line63>if (s[i] == '(')\n<line64>{\n<line65>++i;\n<line66>*binary = 0;\n<line67>return bsd_split_3 (s + i, s_len - i,\n<line68>digest, d_len, file_name, escaped_filename);\n<line69>}\n<line70>return false;\n<line71>}\n<line72>/* Ignore this line if it is too short.\n<line73>Each line must have at least 'min_digest_line_length - 1' (or one more, if\n<line74>the first is a backslash) more characters to contain correct message digest\n<line75>information.  */\n<line76>if (s_len - i < min_digest_line_length + (s[i] == '\\'))\n<line77>return false;\n<line78>*digest = (unsigned char *) &s[i];\n<line79>#if HASH_ALGO_BLAKE2 || HASH_ALGO_CKSUM\n<line80>/* Auto determine length.  */\n<line81># if HASH_ALGO_CKSUM\n<line82>if (cksum_algorithm == blake2b) {\n<line83># endif\n<line84>unsigned char const *hp = *digest;\n<line85>digest_hex_bytes = 0;\n<line86>while (isxdigit (*hp++))\n<line87>digest_hex_bytes++;\n<line88>if (digest_hex_bytes < 2 || digest_hex_bytes % 2\n<line89>|| BLAKE2B_MAX_LEN * 2 < digest_hex_bytes)\n<line90>return false;\n<line91>digest_length = digest_hex_bytes * 4;\n<line92># if HASH_ALGO_CKSUM\n<line93>}\n<line94># endif\n<line95>#endif\n<line96>/* This field must be the hexadecimal or base64 representation\n<line97>of the message digest.  */\n<line98>while (s[i] && !ISWHITE (s[i]))\n<line99>i++;\n<line100>/* The digest must be followed by at least one whitespace character.  */\n<line101>if (i == s_len)\n<line102>return false;\n<line103>*d_len = &s[i] - (char *) *digest;\n<line104>s[i++] = '\0';\n<line105>if (! valid_digits (*digest, *d_len))\n<line106>return false;\n<line107>/* If "bsd reversed" format detected.  */\n<line108>if ((s_len - i == 1) || (s[i] != ' ' && s[i] != '*'))\n<line109>{\n<line110>/* Don't allow mixing bsd and standard formats,\n<line111>to minimize security issues with attackers\n<line112>renaming files with leading spaces.\n<line113>This assumes that with bsd format checksums\n<line114>that the first file name does not have\n<line115>a leading ' ' or '*'.  */\n<line116>if (bsd_reversed == 0)\n<line117>return false;\n<line118>bsd_reversed = 1;\n<line119>}\n<line120>else if (bsd_reversed != 1)\n<line121>{\n<line122>bsd_reversed = 0;\n<line123>*binary = (s[i++] == '*');\n<line124>}\n<line125>/* All characters between the type indicator and end of line are\n<line126>significant -- that includes leading and trailing white space.  */\n<line127>*file_name = &s[i];\n<line128>if (escaped_filename)\n<line129>return filename_unescape (&s[i], s_len - i) != nullptr;\n<line130>return true;\n<line131>}
----------------------------------------
Function: print_filename
Content: <line0>static void\n<line1>print_filename (char const *file, bool escape)\n<line2>{\n<line3>if (! escape)\n<line4>{\n<line5>fputs (file, stdout);\n<line6>return;\n<line7>}\n<line8>while (*file)\n<line9>{\n<line10>switch (*file)\n<line11>{\n<line12>case '\n':\n<line13>fputs ("\\n", stdout);\n<line14>break;\n<line15>case '\r':\n<line16>fputs ("\\r", stdout);\n<line17>break;\n<line18>case '\\':\n<line19>fputs ("\\\\", stdout);\n<line20>break;\n<line21>default:\n<line22>putchar (*file);\n<line23>break;\n<line24>}\n<line25>file++;\n<line26>}\n<line27>}
----------------------------------------
Function: digest_file
Content: <line0>static bool\n<line1>digest_file (char const *filename, int *binary, unsigned char *bin_result,\n<line2>bool *missing, MAYBE_UNUSED uintmax_t *length)\n<line3>{\n<line4>FILE *fp;\n<line5>int err;\n<line6>bool is_stdin = STREQ (filename, "-");\n<line7>*missing = false;\n<line8>if (is_stdin)\n<line9>{\n<line10>have_read_stdin = true;\n<line11>fp = stdin;\n<line12>if (O_BINARY && *binary)\n<line13>{\n<line14>if (*binary < 0)\n<line15>*binary = ! isatty (STDIN_FILENO);\n<line16>if (*binary)\n<line17>xset_binary_mode (STDIN_FILENO, O_BINARY);\n<line18>}\n<line19>}\n<line20>else\n<line21>{\n<line22>fp = fopen (filename, (O_BINARY && *binary ? "rb" : "r"));\n<line23>if (fp == nullptr)\n<line24>{\n<line25>if (ignore_missing && errno == ENOENT)\n<line26>{\n<line27>*missing = true;\n<line28>return true;\n<line29>}\n<line30>error (0, errno, "%s", quotef (filename));\n<line31>return false;\n<line32>}\n<line33>}\n<line34>fadvise (fp, FADVISE_SEQUENTIAL);\n<line35>#if HASH_ALGO_CKSUM\n<line36>if (cksum_algorithm == blake2b)\n<line37>*length = digest_length / 8;\n<line38>err = DIGEST_STREAM (fp, bin_result, length);\n<line39>#elif HASH_ALGO_SUM\n<line40>err = DIGEST_STREAM (fp, bin_result, length);\n<line41>#elif HASH_ALGO_BLAKE2\n<line42>err = DIGEST_STREAM (fp, bin_result, digest_length / 8);\n<line43>#else\n<line44>err = DIGEST_STREAM (fp, bin_result);\n<line45>#endif\n<line46>err = err ? errno : 0;\n<line47>if (is_stdin)\n<line48>clearerr (fp);\n<line49>else if (fclose (fp) != 0 && !err)\n<line50>err = errno;\n<line51>if (err)\n<line52>{\n<line53>error (0, err, "%s", quotef (filename));\n<line54>return false;\n<line55>}\n<line56>return true;\n<line57>}
----------------------------------------
Function: output_file
Content: <line0>static void\n<line1>output_file (char const *file, int binary_file, void const *digest,\n<line2>bool raw, bool tagged, unsigned char delim, MAYBE_UNUSED bool args,\n<line3>MAYBE_UNUSED uintmax_t length)\n<line4>{\n<line5># if HASH_ALGO_CKSUM\n<line6>if (raw)\n<line7>{\n<line8>fwrite (digest, 1, digest_length / 8, stdout);\n<line9>return;\n<line10>}\n<line11># endif\n<line12>unsigned char const *bin_buffer = digest;\n<line13>/* Output a leading backslash if the file name contains problematic chars.  */\n<line14>bool needs_escape = delim == '\n' && problematic_chars (file);\n<line15>if (needs_escape)\n<line16>putchar ('\\');\n<line17>if (tagged)\n<line18>{\n<line19>fputs (DIGEST_TYPE_STRING, stdout);\n<line20># if HASH_ALGO_BLAKE2\n<line21>if (digest_length < BLAKE2B_MAX_LEN * 8)\n<line22>printf ("-%"PRIuMAX, digest_length);\n<line23># elif HASH_ALGO_CKSUM\n<line24>if (cksum_algorithm == blake2b)\n<line25>{\n<line26>if (digest_length < BLAKE2B_MAX_LEN * 8)\n<line27>printf ("-%"PRIuMAX, digest_length);\n<line28>}\n<line29># endif\n<line30>fputs (" (", stdout);\n<line31>print_filename (file, needs_escape);\n<line32>fputs (") = ", stdout);\n<line33>}\n<line34># if HASH_ALGO_CKSUM\n<line35>if (base64_digest)\n<line36>{\n<line37>char b64[BASE64_LENGTH (DIGEST_BIN_BYTES) + 1];\n<line38>base64_encode ((char const *) bin_buffer, digest_length / 8,\n<line39>b64, sizeof b64);\n<line40>fputs (b64, stdout);\n<line41>}\n<line42>else\n<line43># endif\n<line44>{\n<line45>for (size_t i = 0; i < (digest_hex_bytes / 2); ++i)\n<line46>printf ("%02x", bin_buffer[i]);\n<line47>}\n<line48>if (!tagged)\n<line49>{\n<line50>putchar (' ');\n<line51>putchar (binary_file ? '*' : ' ');\n<line52>print_filename (file, needs_escape);\n<line53>}\n<line54>putchar (delim);\n<line55>}
----------------------------------------
Function: hex_equal
Content: <line0>static bool\n<line1>hex_equal (unsigned char const *hex_digest, unsigned char const *bin_buffer)\n<line2>{\n<line3>static const char bin2hex[] = { '0', '1', '2', '3',\n<line4>'4', '5', '6', '7',\n<line5>'8', '9', 'a', 'b',\n<line6>'c', 'd', 'e', 'f' };\n<line7>size_t digest_bin_bytes = digest_hex_bytes / 2;\n<line8>/* Compare generated binary number with text representation\n<line9>in check file.  Ignore case of hex digits.  */\n<line10>size_t cnt;\n<line11>for (cnt = 0; cnt < digest_bin_bytes; ++cnt)\n<line12>{\n<line13>if (tolower (hex_digest[2 * cnt])\n<line14>!= bin2hex[bin_buffer[cnt] >> 4]\n<line15>|| (tolower (hex_digest[2 * cnt + 1])\n<line16>!= (bin2hex[bin_buffer[cnt] & 0xf])))\n<line17>break;\n<line18>}\n<line19>return cnt == digest_bin_bytes;\n<line20>}
----------------------------------------
Function: digest_check
Content: <line0>static bool\n<line1>digest_check (char const *checkfile_name)\n<line2>{\n<line3>FILE *checkfile_stream;\n<line4>uintmax_t n_misformatted_lines = 0;\n<line5>uintmax_t n_mismatched_checksums = 0;\n<line6>uintmax_t n_open_or_read_failures = 0;\n<line7>bool properly_formatted_lines = false;\n<line8>bool matched_checksums = false;\n<line9>unsigned char bin_buffer_unaligned[DIGEST_BIN_BYTES + DIGEST_ALIGN];\n<line10>/* Make sure bin_buffer is properly aligned. */\n<line11>unsigned char *bin_buffer = ptr_align (bin_buffer_unaligned, DIGEST_ALIGN);\n<line12>uintmax_t line_number;\n<line13>char *line;\n<line14>size_t line_chars_allocated;\n<line15>bool is_stdin = STREQ (checkfile_name, "-");\n<line16>if (is_stdin)\n<line17>{\n<line18>have_read_stdin = true;\n<line19>checkfile_name = _("standard input");\n<line20>checkfile_stream = stdin;\n<line21>}\n<line22>else\n<line23>{\n<line24>checkfile_stream = fopen (checkfile_name, "r");\n<line25>if (checkfile_stream == nullptr)\n<line26>{\n<line27>error (0, errno, "%s", quotef (checkfile_name));\n<line28>return false;\n<line29>}\n<line30>}\n<line31>line_number = 0;\n<line32>line = nullptr;\n<line33>line_chars_allocated = 0;\n<line34>do\n<line35>{\n<line36>char *filename;\n<line37>int binary;\n<line38>unsigned char *digest;\n<line39>ssize_t line_length;\n<line40>++line_number;\n<line41>if (line_number == 0)\n<line42>error (EXIT_FAILURE, 0, _("%s: too many checksum lines"),\n<line43>quotef (checkfile_name));\n<line44>line_length = getline (&line, &line_chars_allocated, checkfile_stream);\n<line45>if (line_length <= 0)\n<line46>break;\n<line47>/* Ignore comment lines, which begin with a '#' character.  */\n<line48>if (line[0] == '#')\n<line49>continue;\n<line50>/* Remove any trailing newline.  */\n<line51>line_length -= line[line_length - 1] == '\n';\n<line52>/* Remove any trailing carriage return.  */\n<line53>line_length -= line[line_length - (0 < line_length)] == '\r';\n<line54>/* Ignore empty lines.  */\n<line55>if (line_length == 0)\n<line56>continue;\n<line57>line[line_length] = '\0';\n<line58>size_t d_len;\n<line59>if (! (split_3 (line, line_length, &digest, &d_len, &binary, &filename)\n<line60>&& ! (is_stdin && STREQ (filename, "-"))))\n<line61>{\n<line62>++n_misformatted_lines;\n<line63>if (warn)\n<line64>{\n<line65>error (0, 0,\n<line66>_("%s: %" PRIuMAX\n<line67>": improperly formatted %s checksum line"),\n<line68>quotef (checkfile_name), line_number,\n<line69>DIGEST_TYPE_STRING);\n<line70>}\n<line71>}\n<line72>else\n<line73>{\n<line74>bool ok;\n<line75>bool missing;\n<line76>bool needs_escape = ! status_only && problematic_chars (filename);\n<line77>properly_formatted_lines = true;\n<line78>uintmax_t length;\n<line79>ok = digest_file (filename, &binary, bin_buffer, &missing, &length);\n<line80>if (!ok)\n<line81>{\n<line82>++n_open_or_read_failures;\n<line83>if (!status_only)\n<line84>{\n<line85>if (needs_escape)\n<line86>putchar ('\\');\n<line87>print_filename (filename, needs_escape);\n<line88>printf (": %s\n", _("FAILED open or read"));\n<line89>}\n<line90>}\n<line91>else if (ignore_missing && missing)\n<line92>{\n<line93>/* Ignore missing files with --ignore-missing.  */\n<line94>;\n<line95>}\n<line96>else\n<line97>{\n<line98>bool match = false;\n<line99>#if HASH_ALGO_CKSUM\n<line100>if (d_len < digest_hex_bytes)\n<line101>match = b64_equal (digest, bin_buffer);\n<line102>else\n<line103>#endif\n<line104>if (d_len == digest_hex_bytes)\n<line105>match = hex_equal (digest, bin_buffer);\n<line106>if (match)\n<line107>matched_checksums = true;\n<line108>else\n<line109>++n_mismatched_checksums;\n<line110>if (!status_only)\n<line111>{\n<line112>if (! match || ! quiet)\n<line113>{\n<line114>if (needs_escape)\n<line115>putchar ('\\');\n<line116>print_filename (filename, needs_escape);\n<line117>}\n<line118>if (! match)\n<line119>printf (": %s\n", _("FAILED"));\n<line120>else if (!quiet)\n<line121>printf (": %s\n", _("OK"));\n<line122>}\n<line123>}\n<line124>}\n<line125>}\n<line126>while (!feof (checkfile_stream) && !ferror (checkfile_stream));\n<line127>free (line);\n<line128>int err = ferror (checkfile_stream) ? 0 : -1;\n<line129>if (is_stdin)\n<line130>clearerr (checkfile_stream);\n<line131>else if (fclose (checkfile_stream) != 0 && err < 0)\n<line132>err = errno;\n<line133>if (0 <= err)\n<line134>{\n<line135>error (0, err, err ? "%s" : _("%s: read error"),\n<line136>quotef (checkfile_name));\n<line137>return false;\n<line138>}\n<line139>if (! properly_formatted_lines)\n<line140>{\n<line141>/* Warn if no tests are found.  */\n<line142>error (0, 0, _("%s: no properly formatted checksum lines found"),\n<line143>quotef (checkfile_name));\n<line144>}\n<line145>else\n<line146>{\n<line147>if (!status_only)\n<line148>{\n<line149>if (n_misformatted_lines != 0)\n<line150>error (0, 0,\n<line151>(ngettext\n<line152>("WARNING: %" PRIuMAX " line is improperly formatted",\n<line153>"WARNING: %" PRIuMAX " lines are improperly formatted",\n<line154>select_plural (n_misformatted_lines))),\n<line155>n_misformatted_lines);\n<line156>if (n_open_or_read_failures != 0)\n<line157>error (0, 0,\n<line158>(ngettext\n<line159>("WARNING: %" PRIuMAX " listed file could not be read",\n<line160>"WARNING: %" PRIuMAX " listed files could not be read",\n<line161>select_plural (n_open_or_read_failures))),\n<line162>n_open_or_read_failures);\n<line163>if (n_mismatched_checksums != 0)\n<line164>error (0, 0,\n<line165>(ngettext\n<line166>("WARNING: %" PRIuMAX " computed checksum did NOT match",\n<line167>"WARNING: %" PRIuMAX " computed checksums did NOT match",\n<line168>select_plural (n_mismatched_checksums))),\n<line169>n_mismatched_checksums);\n<line170>if (ignore_missing && ! matched_checksums)\n<line171>error (0, 0, _("%s: no file was verified"),\n<line172>quotef (checkfile_name));\n<line173>}\n<line174>}\n<line175>return (properly_formatted_lines\n<line176>&& matched_checksums\n<line177>&& n_mismatched_checksums == 0\n<line178>&& n_open_or_read_failures == 0\n<line179>&& (!strict || n_misformatted_lines == 0));\n<line180>}
----------------------------------------
Function: main
Content: <line0>int\n<line1>main (int argc, char **argv)\n<line2>{\n<line3>unsigned char bin_buffer_unaligned[DIGEST_BIN_BYTES + DIGEST_ALIGN];\n<line4>/* Make sure bin_buffer is properly aligned. */\n<line5>unsigned char *bin_buffer = ptr_align (bin_buffer_unaligned, DIGEST_ALIGN);\n<line6>bool do_check = false;\n<line7>int opt;\n<line8>bool ok = true;\n<line9>int binary = -1;\n<line10>#if HASH_ALGO_CKSUM\n<line11>bool prefix_tag = true;\n<line12>#else\n<line13>bool prefix_tag = false;\n<line14>#endif\n<line15>/* Setting values of global variables.  */\n<line16>initialize_main (&argc, &argv);\n<line17>set_program_name (argv[0]);\n<line18>setlocale (LC_ALL, "");\n<line19>bindtextdomain (PACKAGE, LOCALEDIR);\n<line20>textdomain (PACKAGE);\n<line21>atexit (close_stdout);\n<line22>/* Line buffer stdout to ensure lines are written atomically and immediately\n<line23>so that processes running in parallel do not intersperse their output.  */\n<line24>setvbuf (stdout, nullptr, _IOLBF, 0);\n<line25>#if HASH_ALGO_SUM\n<line26>char const *short_opts = "rs";\n<line27>#elif HASH_ALGO_CKSUM\n<line28>char const *short_opts = "a:l:bctwz";\n<line29>char const *digest_length_str = "";\n<line30>#elif HASH_ALGO_BLAKE2\n<line31>char const *short_opts = "l:bctwz";\n<line32>char const *digest_length_str = "";\n<line33>#else\n<line34>char const *short_opts = "bctwz";\n<line35>#endif\n<line36>while ((opt = getopt_long (argc, argv, short_opts, long_options, nullptr))\n<line37>!= -1)\n<line38>switch (opt)\n<line39>{\n<line40>#if HASH_ALGO_CKSUM\n<line41>case 'a':\n<line42>cksum_algorithm = XARGMATCH_EXACT ("--algorithm", optarg,\n<line43>algorithm_args, algorithm_types);\n<line44>algorithm_specified = true;\n<line45>break;\n<line46>case DEBUG_PROGRAM_OPTION:\n<line47>cksum_debug = true;\n<line48>break;\n<line49>#endif\n<line50>#if HASH_ALGO_BLAKE2 || HASH_ALGO_CKSUM\n<line51>case 'l':\n<line52>digest_length = xdectoumax (optarg, 0, UINTMAX_MAX, "",\n<line53>_("invalid length"), 0);\n<line54>digest_length_str = optarg;\n<line55>if (digest_length % 8 != 0)\n<line56>{\n<line57>error (0, 0, _("invalid length: %s"), quote (digest_length_str));\n<line58>error (EXIT_FAILURE, 0, _("length is not a multiple of 8"));\n<line59>}\n<line60>break;\n<line61>#endif\n<line62>#if !HASH_ALGO_SUM\n<line63>case 'c':\n<line64>do_check = true;\n<line65>break;\n<line66>case STATUS_OPTION:\n<line67>status_only = true;\n<line68>warn = false;\n<line69>quiet = false;\n<line70>break;\n<line71>case 'b':\n<line72>binary = 1;\n<line73>break;\n<line74>case 't':\n<line75>binary = 0;\n<line76>break;\n<line77>case 'w':\n<line78>status_only = false;\n<line79>warn = true;\n<line80>quiet = false;\n<line81>break;\n<line82>case IGNORE_MISSING_OPTION:\n<line83>ignore_missing = true;\n<line84>break;\n<line85>case QUIET_OPTION:\n<line86>status_only = false;\n<line87>warn = false;\n<line88>quiet = true;\n<line89>break;\n<line90>case STRICT_OPTION:\n<line91>strict = true;\n<line92>break;\n<line93># if HASH_ALGO_CKSUM\n<line94>case BASE64_OPTION:\n<line95>base64_digest = true;\n<line96>break;\n<line97>case RAW_OPTION:\n<line98>raw_digest = true;\n<line99>break;\n<line100>case UNTAG_OPTION:\n<line101>prefix_tag = false;\n<line102>break;\n<line103># endif\n<line104>case TAG_OPTION:\n<line105>prefix_tag = true;\n<line106>binary = 1;\n<line107>break;\n<line108>case 'z':\n<line109>digest_delim = '\0';\n<line110>break;\n<line111>#endif\n<line112>#if HASH_ALGO_SUM\n<line113>case 'r':		/* For SysV compatibility. */\n<line114>sum_algorithm = bsd;\n<line115>break;\n<line116>case 's':\n<line117>sum_algorithm = sysv;\n<line118>break;\n<line119>#endif\n<line120>case_GETOPT_HELP_CHAR;\n<line121>case_GETOPT_VERSION_CHAR (PROGRAM_NAME, AUTHORS);\n<line122>default:\n<line123>usage (EXIT_FAILURE);\n<line124>}\n<line125>min_digest_line_length = MIN_DIGEST_LINE_LENGTH;\n<line126>#if HASH_ALGO_BLAKE2 || HASH_ALGO_CKSUM\n<line127># if HASH_ALGO_CKSUM\n<line128>if (digest_length && cksum_algorithm != blake2b)\n<line129>error (EXIT_FAILURE, 0,\n<line130>_("--length is only supported with --algorithm=blake2b"));\n<line131># endif\n<line132>if (digest_length > BLAKE2B_MAX_LEN * 8)\n<line133>{\n<line134>error (0, 0, _("invalid length: %s"), quote (digest_length_str));\n<line135>error (EXIT_FAILURE, 0,\n<line136>_("maximum digest length for %s is %d bits"),\n<line137>quote (DIGEST_TYPE_STRING),\n<line138>BLAKE2B_MAX_LEN * 8);\n<line139>}\n<line140>if (digest_length == 0)\n<line141>{\n<line142># if HASH_ALGO_BLAKE2\n<line143>digest_length = BLAKE2B_MAX_LEN * 8;\n<line144># else\n<line145>digest_length = algorithm_bits[cksum_algorithm];\n<line146># endif\n<line147>}\n<line148>digest_hex_bytes = digest_length / 4;\n<line149>#else\n<line150>digest_hex_bytes = DIGEST_HEX_BYTES;\n<line151>#endif\n<line152>#if HASH_ALGO_CKSUM\n<line153>switch (cksum_algorithm)\n<line154>{\n<line155>case bsd:\n<line156>case sysv:\n<line157>case crc:\n<line158>if (do_check && algorithm_specified)\n<line159>error (EXIT_FAILURE, 0,\n<line160>_("--check is not supported with --algorithm={bsd,sysv,crc}"));\n<line161>break;\n<line162>default:\n<line163>break;\n<line164>}\n<line165>if (base64_digest && raw_digest)\n<line166>{\n<line167>error (0, 0, _("--base64 and --raw are mutually exclusive"));\n<line168>usage (EXIT_FAILURE);\n<line169>}\n<line170>#endif\n<line171>if (prefix_tag && !binary)\n<line172>{\n<line173>/* This could be supported in a backwards compatible way\n<line174>by prefixing the output line with a space in text mode.\n<line175>However that's invasive enough that it was agreed to\n<line176>not support this mode with --tag, as --text use cases\n<line177>are adequately supported by the default output format.  */\n<line178>#if !HASH_ALGO_CKSUM\n<line179>error (0, 0, _("--tag does not support --text mode"));\n<line180>#else\n<line181>error (0, 0, _("--text mode is only supported with --untagged"));\n<line182>#endif\n<line183>usage (EXIT_FAILURE);\n<line184>}\n<line185>if (digest_delim != '\n' && do_check)\n<line186>{\n<line187>error (0, 0, _("the --zero option is not supported when "\n<line188>"verifying checksums"));\n<line189>usage (EXIT_FAILURE);\n<line190>}\n<line191>#if !HASH_ALGO_CKSUM\n<line192>if (prefix_tag && do_check)\n<line193>{\n<line194>error (0, 0, _("the --tag option is meaningless when "\n<line195>"verifying checksums"));\n<line196>usage (EXIT_FAILURE);\n<line197>}\n<line198>#endif\n<line199>if (0 <= binary && do_check)\n<line200>{\n<line201>error (0, 0, _("the --binary and --text options are meaningless when "\n<line202>"verifying checksums"));\n<line203>usage (EXIT_FAILURE);\n<line204>}\n<line205>if (ignore_missing && !do_check)\n<line206>{\n<line207>error (0, 0,\n<line208>_("the --ignore-missing option is meaningful only when "\n<line209>"verifying checksums"));\n<line210>usage (EXIT_FAILURE);\n<line211>}\n<line212>if (status_only && !do_check)\n<line213>{\n<line214>error (0, 0,\n<line215>_("the --status option is meaningful only when verifying checksums"));\n<line216>usage (EXIT_FAILURE);\n<line217>}\n<line218>if (warn && !do_check)\n<line219>{\n<line220>error (0, 0,\n<line221>_("the --warn option is meaningful only when verifying checksums"));\n<line222>usage (EXIT_FAILURE);\n<line223>}\n<line224>if (quiet && !do_check)\n<line225>{\n<line226>error (0, 0,\n<line227>_("the --quiet option is meaningful only when verifying checksums"));\n<line228>usage (EXIT_FAILURE);\n<line229>}\n<line230>if (strict & !do_check)\n<line231>{\n<line232>error (0, 0,\n<line233>_("the --strict option is meaningful only when verifying checksums"));\n<line234>usage (EXIT_FAILURE);\n<line235>}\n<line236>if (!O_BINARY && binary < 0)\n<line237>binary = 0;\n<line238>char **operand_lim = argv + argc;\n<line239>if (optind == argc)\n<line240>*operand_lim++ = bad_cast ("-");\n<line241>else if (1 < argc - optind && raw_digest)\n<line242>error (EXIT_FAILURE, 0,\n<line243>_("the --raw option is not supported with multiple files"));\n<line244>for (char **operandp = argv + optind; operandp < operand_lim; operandp++)\n<line245>{\n<line246>char *file = *operandp;\n<line247>if (do_check)\n<line248>ok &= digest_check (file);\n<line249>else\n<line250>{\n<line251>int binary_file = binary;\n<line252>bool missing;\n<line253>uintmax_t length;\n<line254>if (! digest_file (file, &binary_file, bin_buffer, &missing, &length))\n<line255>ok = false;\n<line256>else\n<line257>{\n<line258>DIGEST_OUT (file, binary_file, bin_buffer, raw_digest, prefix_tag,\n<line259>digest_delim, optind != argc, length);\n<line260>}\n<line261>}\n<line262>}\n<line263>if (have_read_stdin && fclose (stdin) == EOF)\n<line264>error (EXIT_FAILURE, errno, _("standard input"));\n<line265>return ok ? EXIT_SUCCESS : EXIT_FAILURE;\n<line266>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/src/shred.c
========================================
/home/huihui/Downloads/coreutils-9.4/src/shred.c:109:67: warning: '_Static_assert' with no message is a C2x extension [-Wc2x-extensions]
static_assert (0 < SECTOR_SIZE && (SECTOR_SIZE & SECTOR_MASK) == 0);
                                                                  ^
                                                                  , ""
/home/huihui/Downloads/coreutils-9.4/src/shred.c:411:47: warning: '_Static_assert' with no message is a C2x extension [-Wc2x-extensions]
  static_assert (PERIODIC_OUTPUT_SIZE % 3 == 0);
                                              ^
                                              , ""
/home/huihui/Downloads/coreutils-9.4/src/shred.c:511:73: warning: '_Static_assert' with no message is a C2x extension [-Wc2x-extensions]
                  static_assert (PERIODIC_OUTPUT_SIZE % SECTOR_SIZE == 0);
                                                                        ^
                                                                        , ""
/home/huihui/Downloads/coreutils-9.4/src/shred.c:512:76: warning: '_Static_assert' with no message is a C2x extension [-Wc2x-extensions]
                  static_assert (NONPERIODIC_OUTPUT_SIZE % SECTOR_SIZE == 0);
                                                                           ^
                                                                           , ""
4 warnings generated.
Function: usage
Content: <line0>void\n<line1>usage (int status)\n<line2>{\n<line3>if (status != EXIT_SUCCESS)\n<line4>emit_try_help ();\n<line5>else\n<line6>{\n<line7>printf (_("Usage: %s [OPTION]... FILE...\n"), program_name);\n<line8>fputs (_("\\n<line9>Overwrite the specified FILE(s) repeatedly, in order to make it harder\n\\n<line10>for even very expensive hardware probing to recover the data.\n\\n<line11>"), stdout);\n<line12>fputs (_("\\n<line13>\n\\n<line14>If FILE is -, shred standard output.\n\\n<line15>"), stdout);\n<line16>emit_mandatory_arg_note ();\n<line17>printf (_("\\n<line18>-f, --force    change permissions to allow writing if necessary\n\\n<line19>-n, --iterations=N  overwrite N times instead of the default (%d)\n\\n<line20>--random-source=FILE  get random bytes from FILE\n\\n<line21>-s, --size=N   shred this many bytes (suffixes like K, M, G accepted)\n\\n<line22>"), DEFAULT_PASSES);\n<line23>fputs (_("\\n<line24>-u             deallocate and remove file after overwriting\n\\n<line25>--remove[=HOW]  like -u but give control on HOW to delete;  See below\n\\n<line26>-v, --verbose  show progress\n\\n<line27>-x, --exact    do not round file sizes up to the next full block;\n\\n<line28>this is the default for non-regular files\n\\n<line29>-z, --zero     add a final overwrite with zeros to hide shredding\n\\n<line30>"), stdout);\n<line31>fputs (HELP_OPTION_DESCRIPTION, stdout);\n<line32>fputs (VERSION_OPTION_DESCRIPTION, stdout);\n<line33>fputs (_("\\n<line34>\n\\n<line35>Delete FILE(s) if --remove (-u) is specified.  The default is not to remove\n\\n<line36>the files because it is common to operate on device files like /dev/hda,\n\\n<line37>and those files usually should not be removed.\n\\n<line38>The optional HOW parameter indicates how to remove a directory entry:\n\\n<line39>'unlink' => use a standard unlink call.\n\\n<line40>'wipe' => also first obfuscate bytes in the name.\n\\n<line41>'wipesync' => also sync each obfuscated byte to the device.\n\\n<line42>The default mode is 'wipesync', but note it can be expensive.\n\\n<line43>\n\\n<line44>"), stdout);\n<line45>fputs (_("\\n<line46>CAUTION: shred assumes the file system and hardware overwrite data in place.\n\\n<line47>Although this is common, many platforms operate otherwise.  Also, backups\n\\n<line48>and mirrors may contain unremovable copies that will let a shredded file\n\\n<line49>be recovered later.  See the GNU coreutils manual for details.\n\\n<line50>"), stdout);\n<line51>emit_ancillary_info (PROGRAM_NAME);\n<line52>}\n<line53>exit (status);\n<line54>}
----------------------------------------
Function: periodic_pattern
Content: <line0>static bool\n<line1>periodic_pattern (int type)\n<line2>{\n<line3>if (type <= 0)\n<line4>return false;\n<line5>unsigned char r[3];\n<line6>unsigned int bits = type & 0xfff;\n<line7>bits |= bits << 12;\n<line8>r[0] = (bits >> 4) & 255;\n<line9>r[1] = (bits >> 8) & 255;\n<line10>r[2] = bits & 255;\n<line11>return (r[0] != r[1]) || (r[0] != r[2]);\n<line12>}
----------------------------------------
Function: fillpattern
Content: <line0>static void\n<line1>fillpattern (int type, unsigned char *r, size_t size)\n<line2>{\n<line3>size_t i;\n<line4>unsigned int bits = type & 0xfff;\n<line5>bits |= bits << 12;\n<line6>r[0] = (bits >> 4) & 255;\n<line7>r[1] = (bits >> 8) & 255;\n<line8>r[2] = bits & 255;\n<line9>for (i = 3; i <= size / 2; i *= 2)\n<line10>memcpy (r + i, r, i);\n<line11>if (i < size)\n<line12>memcpy (r + i, r, size - i);\n<line13>/* Invert the first bit of every sector. */\n<line14>if (type & 0x1000)\n<line15>for (i = 0; i < size; i += SECTOR_SIZE)\n<line16>r[i] ^= 0x80;\n<line17>}
----------------------------------------
Function: passname
Content: <line0>static void\n<line1>passname (unsigned char const *data, char name[PASS_NAME_SIZE])\n<line2>{\n<line3>if (data)\n<line4>sprintf (name, "%02x%02x%02x", data[0], data[1], data[2]);\n<line5>else\n<line6>memcpy (name, "random", PASS_NAME_SIZE);\n<line7>}
----------------------------------------
Function: ignorable_sync_errno
Content: <line0>static bool\n<line1>ignorable_sync_errno (int errno_val)\n<line2>{\n<line3>return (errno_val == EINVAL\n<line4>|| errno_val == EBADF\n<line5>/* HP-UX does this */\n<line6>|| errno_val == EISDIR);\n<line7>}
----------------------------------------
Function: dosync
Content: <line0>static int\n<line1>dosync (int fd, char const *qname)\n<line2>{\n<line3>int err;\n<line4>#if HAVE_FDATASYNC\n<line5>if (fdatasync (fd) == 0)\n<line6>return 0;\n<line7>err = errno;\n<line8>if ( ! ignorable_sync_errno (err))\n<line9>{\n<line10>error (0, err, _("%s: fdatasync failed"), qname);\n<line11>errno = err;\n<line12>return -1;\n<line13>}\n<line14>#endif\n<line15>if (fsync (fd) == 0)\n<line16>return 0;\n<line17>err = errno;\n<line18>if ( ! ignorable_sync_errno (err))\n<line19>{\n<line20>error (0, err, _("%s: fsync failed"), qname);\n<line21>errno = err;\n<line22>return -1;\n<line23>}\n<line24>sync ();\n<line25>return 0;\n<line26>}
----------------------------------------
Function: direct_mode
Content: <line0>static void\n<line1>direct_mode (int fd, bool enable)\n<line2>{\n<line3>if (O_DIRECT)\n<line4>{\n<line5>int fd_flags = fcntl (fd, F_GETFL);\n<line6>if (0 < fd_flags)\n<line7>{\n<line8>int new_flags = (enable\n<line9>? (fd_flags | O_DIRECT)\n<line10>: (fd_flags & ~O_DIRECT));\n<line11>if (new_flags != fd_flags)\n<line12>fcntl (fd, F_SETFL, new_flags);\n<line13>}\n<line14>}\n<line15>#if HAVE_DIRECTIO && defined DIRECTIO_ON && defined DIRECTIO_OFF\n<line16>/* This is Solaris-specific.  */\n<line17>directio (fd, enable ? DIRECTIO_ON : DIRECTIO_OFF);\n<line18>#endif\n<line19>}
----------------------------------------
Function: dorewind
Content: <line0>static bool\n<line1>dorewind (int fd, struct stat const *st)\n<line2>{\n<line3>if (S_ISCHR (st->st_mode))\n<line4>{\n<line5>#if defined __linux__ && HAVE_SYS_MTIO_H\n<line6>/* In the Linux kernel, lseek does not work on tape devices; it\n<line7>returns a randomish value instead.  Try the low-level tape\n<line8>rewind operation first.  */\n<line9>struct mtop op;\n<line10>op.mt_op = MTREW;\n<line11>op.mt_count = 1;\n<line12>if (ioctl (fd, MTIOCTOP, &op) == 0)\n<line13>return true;\n<line14>#endif\n<line15>}\n<line16>off_t offset = lseek (fd, 0, SEEK_SET);\n<line17>if (0 < offset)\n<line18>errno = EINVAL;\n<line19>return offset == 0;\n<line20>}
----------------------------------------
Function: known
Content: <line0>static bool\n<line1>known (off_t size)\n<line2>{\n<line3>return 0 <= size;\n<line4>}
----------------------------------------
Function: dopass
Content: <line0>static int\n<line1>dopass (int fd, struct stat const *st, char const *qname, off_t *sizep,\n<line2>int type, struct randread_source *s,\n<line3>unsigned long int k, unsigned long int n)\n<line4>{\n<line5>off_t size = *sizep;\n<line6>off_t offset;			/* Current file position */\n<line7>time_t thresh IF_LINT ( = 0);	/* Time to maybe print next status update */\n<line8>time_t now = 0;		/* Current time */\n<line9>size_t lim;			/* Amount of data to try writing */\n<line10>size_t soff;			/* Offset into buffer for next write */\n<line11>ssize_t ssize;		/* Return value from write */\n<line12>/* Fill pattern buffer.  Aligning it to a page so we can do direct I/O.  */\n<line13>size_t page_size = getpagesize ();\n<line14>#define PERIODIC_OUTPUT_SIZE (60 * 1024)\n<line15>#define NONPERIODIC_OUTPUT_SIZE (64 * 1024)\n<line16>static_assert (PERIODIC_OUTPUT_SIZE % 3 == 0);\n<line17>size_t output_size = periodic_pattern (type)\n<line18>? PERIODIC_OUTPUT_SIZE : NONPERIODIC_OUTPUT_SIZE;\n<line19>#define FILLPATTERN_SIZE (((output_size + 2) / 3) * 3) /* Multiple of 3 */\n<line20>unsigned char *pbuf = xalignalloc (page_size, FILLPATTERN_SIZE);\n<line21>char pass_string[PASS_NAME_SIZE];	/* Name of current pass */\n<line22>bool write_error = false;\n<line23>bool other_error = false;\n<line24>/* Printable previous offset into the file */\n<line25>char previous_offset_buf[LONGEST_HUMAN_READABLE + 1];\n<line26>char const *previous_human_offset;\n<line27>/* As a performance tweak, avoid direct I/O for small sizes,\n<line28>as it's just a performance rather then security consideration,\n<line29>and direct I/O can often be unsupported for small non aligned sizes.  */\n<line30>bool try_without_directio = 0 < size && size < output_size;\n<line31>if (! try_without_directio)\n<line32>direct_mode (fd, true);\n<line33>if (! dorewind (fd, st))\n<line34>{\n<line35>error (0, errno, _("%s: cannot rewind"), qname);\n<line36>other_error = true;\n<line37>goto free_pattern_mem;\n<line38>}\n<line39>/* Constant fill patterns need only be set up once. */\n<line40>if (type >= 0)\n<line41>{\n<line42>lim = known (size) && size < FILLPATTERN_SIZE ? size : FILLPATTERN_SIZE;\n<line43>fillpattern (type, pbuf, lim);\n<line44>passname (pbuf, pass_string);\n<line45>}\n<line46>else\n<line47>{\n<line48>passname (0, pass_string);\n<line49>}\n<line50>/* Set position if first status update */\n<line51>if (n)\n<line52>{\n<line53>error (0, 0, _("%s: pass %lu/%lu (%s)..."), qname, k, n, pass_string);\n<line54>thresh = time (nullptr) + VERBOSE_UPDATE;\n<line55>previous_human_offset = "";\n<line56>}\n<line57>offset = 0;\n<line58>while (true)\n<line59>{\n<line60>/* How much to write this time? */\n<line61>lim = output_size;\n<line62>if (known (size) && size - offset < output_size)\n<line63>{\n<line64>if (size < offset)\n<line65>break;\n<line66>lim = size - offset;\n<line67>if (!lim)\n<line68>break;\n<line69>}\n<line70>if (type < 0)\n<line71>randread (s, pbuf, lim);\n<line72>/* Loop to retry partial writes. */\n<line73>for (soff = 0; soff < lim; soff += ssize)\n<line74>{\n<line75>ssize = write (fd, pbuf + soff, lim - soff);\n<line76>if (ssize <= 0)\n<line77>{\n<line78>if (! known (size) && (ssize == 0 || errno == ENOSPC))\n<line79>{\n<line80>/* We have found the end of the file.  */\n<line81>if (soff <= OFF_T_MAX - offset)\n<line82>*sizep = size = offset + soff;\n<line83>break;\n<line84>}\n<line85>else\n<line86>{\n<line87>int errnum = errno;\n<line88>char buf[INT_BUFSIZE_BOUND (uintmax_t)];\n<line89>/* Retry without direct I/O since this may not be supported\n<line90>at all on some (file) systems, or with the current size.\n<line91>I.e., a specified --size that is not aligned, or when\n<line92>dealing with slop at the end of a file with --exact.  */\n<line93>if (! try_without_directio && errno == EINVAL)\n<line94>{\n<line95>direct_mode (fd, false);\n<line96>ssize = 0;\n<line97>try_without_directio = true;\n<line98>continue;\n<line99>}\n<line100>error (0, errnum, _("%s: error writing at offset %s"),\n<line101>qname, umaxtostr (offset + soff, buf));\n<line102>/* 'shred' is often used on bad media, before throwing it\n<line103>out.  Thus, it shouldn't give up on bad blocks.  This\n<line104>code works because lim is always a multiple of\n<line105>SECTOR_SIZE, except at the end.  This size constraint\n<line106>also enables direct I/O on some (file) systems.  */\n<line107>static_assert (PERIODIC_OUTPUT_SIZE % SECTOR_SIZE == 0);\n<line108>static_assert (NONPERIODIC_OUTPUT_SIZE % SECTOR_SIZE == 0);\n<line109>if (errnum == EIO && known (size)\n<line110>&& (soff | SECTOR_MASK) < lim)\n<line111>{\n<line112>size_t soff1 = (soff | SECTOR_MASK) + 1;\n<line113>if (lseek (fd, offset + soff1, SEEK_SET) != -1)\n<line114>{\n<line115>/* Arrange to skip this block. */\n<line116>ssize = soff1 - soff;\n<line117>write_error = true;\n<line118>continue;\n<line119>}\n<line120>error (0, errno, _("%s: lseek failed"), qname);\n<line121>}\n<line122>other_error = true;\n<line123>goto free_pattern_mem;\n<line124>}\n<line125>}\n<line126>}\n<line127>/* Okay, we have written "soff" bytes. */\n<line128>if (OFF_T_MAX - offset < soff)\n<line129>{\n<line130>error (0, 0, _("%s: file too large"), qname);\n<line131>other_error = true;\n<line132>goto free_pattern_mem;\n<line133>}\n<line134>offset += soff;\n<line135>bool done = offset == size;\n<line136>/* Time to print progress? */\n<line137>if (n && ((done && *previous_human_offset)\n<line138>|| thresh <= (now = time (nullptr))))\n<line139>{\n<line140>char offset_buf[LONGEST_HUMAN_READABLE + 1];\n<line141>char size_buf[LONGEST_HUMAN_READABLE + 1];\n<line142>int human_progress_opts = (human_autoscale | human_SI\n<line143>| human_base_1024 | human_B);\n<line144>char const *human_offset\n<line145>= human_readable (offset, offset_buf,\n<line146>human_floor | human_progress_opts, 1, 1);\n<line147>if (done || !STREQ (previous_human_offset, human_offset))\n<line148>{\n<line149>if (! known (size))\n<line150>error (0, 0, _("%s: pass %lu/%lu (%s)...%s"),\n<line151>qname, k, n, pass_string, human_offset);\n<line152>else\n<line153>{\n<line154>uintmax_t off = offset;\n<line155>int percent = (size == 0\n<line156>? 100\n<line157>: (off <= TYPE_MAXIMUM (uintmax_t) / 100\n<line158>? off * 100 / size\n<line159>: off / (size / 100)));\n<line160>char const *human_size\n<line161>= human_readable (size, size_buf,\n<line162>human_ceiling | human_progress_opts,\n<line163>1, 1);\n<line164>if (done)\n<line165>human_offset = human_size;\n<line166>error (0, 0, _("%s: pass %lu/%lu (%s)...%s/%s %d%%"),\n<line167>qname, k, n, pass_string, human_offset, human_size,\n<line168>percent);\n<line169>}\n<line170>strcpy (previous_offset_buf, human_offset);\n<line171>previous_human_offset = previous_offset_buf;\n<line172>thresh = now + VERBOSE_UPDATE;\n<line173>/*\n<line174>* Force periodic syncs to keep displayed progress accurate\n<line175>* FIXME: Should these be present even if -v is not enabled,\n<line176>* to keep the buffer cache from filling with dirty pages?\n<line177>* It's a common problem with programs that do lots of writes,\n<line178>* like mkfs.\n<line179>*/\n<line180>if (dosync (fd, qname) != 0)\n<line181>{\n<line182>if (errno != EIO)\n<line183>{\n<line184>other_error = true;\n<line185>goto free_pattern_mem;\n<line186>}\n<line187>write_error = true;\n<line188>}\n<line189>}\n<line190>}\n<line191>}\n<line192>/* Force what we just wrote to hit the media. */\n<line193>if (dosync (fd, qname) != 0)\n<line194>{\n<line195>if (errno != EIO)\n<line196>{\n<line197>other_error = true;\n<line198>goto free_pattern_mem;\n<line199>}\n<line200>write_error = true;\n<line201>}\n<line202>free_pattern_mem:\n<line203>alignfree (pbuf);\n<line204>return other_error ? -1 : write_error;\n<line205>}
----------------------------------------
Function: genpattern
Content: <line0>static void\n<line1>genpattern (int *dest, size_t num, struct randint_source *s)\n<line2>{\n<line3>size_t randpasses;\n<line4>int const *p;\n<line5>int *d;\n<line6>size_t n;\n<line7>size_t accum, top, swap;\n<line8>int k;\n<line9>if (!num)\n<line10>return;\n<line11>/* Stage 1: choose the passes to use */\n<line12>p = patterns;\n<line13>randpasses = 0;\n<line14>d = dest;			/* Destination for generated pass list */\n<line15>n = num;			/* Passes remaining to fill */\n<line16>while (true)\n<line17>{\n<line18>k = *p++;			/* Block descriptor word */\n<line19>if (!k)\n<line20>{			/* Loop back to the beginning */\n<line21>p = patterns;\n<line22>}\n<line23>else if (k < 0)\n<line24>{			/* -k random passes */\n<line25>k = -k;\n<line26>if ((size_t) k >= n)\n<line27>{\n<line28>randpasses += n;\n<line29>break;\n<line30>}\n<line31>randpasses += k;\n<line32>n -= k;\n<line33>}\n<line34>else if ((size_t) k <= n)\n<line35>{			/* Full block of patterns */\n<line36>memcpy (d, p, k * sizeof (int));\n<line37>p += k;\n<line38>d += k;\n<line39>n -= k;\n<line40>}\n<line41>else if (n < 2 || 3 * n < (size_t) k)\n<line42>{			/* Finish with random */\n<line43>randpasses += n;\n<line44>break;\n<line45>}\n<line46>else\n<line47>{			/* Pad out with n of the k available */\n<line48>do\n<line49>{\n<line50>if (n == (size_t) k || randint_choose (s, k) < n)\n<line51>{\n<line52>*d++ = *p;\n<line53>n--;\n<line54>}\n<line55>p++;\n<line56>k--;\n<line57>}\n<line58>while (n);\n<line59>break;\n<line60>}\n<line61>}\n<line62>top = num - randpasses;	/* Top of initialized data */\n<line63>/* affirm (d == dest + top); */\n<line64>/*\n<line65>* We now have fixed patterns in the dest buffer up to\n<line66>* "top", and we need to scramble them, with "randpasses"\n<line67>* random passes evenly spaced among them.\n<line68>*\n<line69>* We want one at the beginning, one at the end, and\n<line70>* evenly spaced in between.  To do this, we basically\n<line71>* use Bresenham's line draw (a.k.a DDA) algorithm\n<line72>* to draw a line with slope (randpasses-1)/(num-1).\n<line73>* (We use a positive accumulator and count down to\n<line74>* do this.)\n<line75>*\n<line76>* So for each desired output value, we do the following:\n<line77>* - If it should be a random pass, copy the pass type\n<line78>*   to top++, out of the way of the other passes, and\n<line79>*   set the current pass to -1 (random).\n<line80>* - If it should be a normal pattern pass, choose an\n<line81>*   entry at random between here and top-1 (inclusive)\n<line82>*   and swap the current entry with that one.\n<line83>*/\n<line84>randpasses--;			/* To speed up later math */\n<line85>accum = randpasses;		/* Bresenham DDA accumulator */\n<line86>for (n = 0; n < num; n++)\n<line87>{\n<line88>if (accum <= randpasses)\n<line89>{\n<line90>accum += num - 1;\n<line91>dest[top++] = dest[n];\n<line92>dest[n] = -1;\n<line93>}\n<line94>else\n<line95>{\n<line96>swap = n + randint_choose (s, top - n);\n<line97>k = dest[n];\n<line98>dest[n] = dest[swap];\n<line99>dest[swap] = k;\n<line100>}\n<line101>accum -= randpasses;\n<line102>}\n<line103>/* affirm (top == num); */\n<line104>}
----------------------------------------
Function: do_wipefd
Content: <line0>static bool\n<line1>do_wipefd (int fd, char const *qname, struct randint_source *s,\n<line2>struct Options const *flags)\n<line3>{\n<line4>size_t i;\n<line5>struct stat st;\n<line6>off_t size;		/* Size to write, size to read */\n<line7>off_t i_size = 0;	/* For small files, initial size to overwrite inode */\n<line8>unsigned long int n;	/* Number of passes for printing purposes */\n<line9>int *passarray;\n<line10>bool ok = true;\n<line11>struct randread_source *rs;\n<line12>n = 0;		/* dopass takes n == 0 to mean "don't print progress" */\n<line13>if (flags->verbose)\n<line14>n = flags->n_iterations + flags->zero_fill;\n<line15>if (fstat (fd, &st))\n<line16>{\n<line17>error (0, errno, _("%s: fstat failed"), qname);\n<line18>return false;\n<line19>}\n<line20>/* If we know that we can't possibly shred the file, give up now.\n<line21>Otherwise, we may go into an infinite loop writing data before we\n<line22>find that we can't rewind the device.  */\n<line23>if ((S_ISCHR (st.st_mode) && isatty (fd))\n<line24>|| S_ISFIFO (st.st_mode)\n<line25>|| S_ISSOCK (st.st_mode))\n<line26>{\n<line27>error (0, 0, _("%s: invalid file type"), qname);\n<line28>return false;\n<line29>}\n<line30>else if (S_ISREG (st.st_mode) && st.st_size < 0)\n<line31>{\n<line32>error (0, 0, _("%s: file has negative size"), qname);\n<line33>return false;\n<line34>}\n<line35>/* Allocate pass array */\n<line36>passarray = xnmalloc (flags->n_iterations, sizeof *passarray);\n<line37>size = flags->size;\n<line38>if (size == -1)\n<line39>{\n<line40>if (S_ISREG (st.st_mode))\n<line41>{\n<line42>size = st.st_size;\n<line43>if (! flags->exact)\n<line44>{\n<line45>/* Round up to the nearest block size to clear slack space.  */\n<line46>off_t remainder = size % ST_BLKSIZE (st);\n<line47>if (size && size < ST_BLKSIZE (st))\n<line48>i_size = size;\n<line49>if (remainder != 0)\n<line50>{\n<line51>off_t size_incr = ST_BLKSIZE (st) - remainder;\n<line52>size += MIN (size_incr, OFF_T_MAX - size);\n<line53>}\n<line54>}\n<line55>}\n<line56>else\n<line57>{\n<line58>/* The behavior of lseek is unspecified, but in practice if\n<line59>it returns a positive number that's the size of this\n<line60>device.  */\n<line61>size = lseek (fd, 0, SEEK_END);\n<line62>if (size <= 0)\n<line63>{\n<line64>/* We are unable to determine the length, up front.\n<line65>Let dopass do that as part of its first iteration.  */\n<line66>size = -1;\n<line67>}\n<line68>}\n<line69>}\n<line70>else if (S_ISREG (st.st_mode)\n<line71>&& st.st_size < MIN (ST_BLKSIZE (st), size))\n<line72>i_size = st.st_size;\n<line73>/* Schedule the passes in random order. */\n<line74>genpattern (passarray, flags->n_iterations, s);\n<line75>rs = randint_get_source (s);\n<line76>while (true)\n<line77>{\n<line78>off_t pass_size;\n<line79>unsigned long int pn = n;\n<line80>if (i_size)\n<line81>{\n<line82>pass_size = i_size;\n<line83>i_size = 0;\n<line84>pn = 0;\n<line85>}\n<line86>else if (size)\n<line87>{\n<line88>pass_size = size;\n<line89>size = 0;\n<line90>}\n<line91>/* TODO: consider handling tail packing by\n<line92>writing the tail padding as a separate pass,\n<line93>(that would not rewind).  */\n<line94>else\n<line95>break;\n<line96>for (i = 0; i < flags->n_iterations + flags->zero_fill; i++)\n<line97>{\n<line98>int err = 0;\n<line99>int type = i < flags->n_iterations ? passarray[i] : 0;\n<line100>err = dopass (fd, &st, qname, &pass_size, type, rs, i + 1, pn);\n<line101>if (err)\n<line102>{\n<line103>ok = false;\n<line104>if (err < 0)\n<line105>goto wipefd_out;\n<line106>}\n<line107>}\n<line108>}\n<line109>/* Now deallocate the data.  The effect of ftruncate is specified\n<line110>on regular files and shared memory objects (also directories, but\n<line111>they are not possible here); don't worry about errors reported\n<line112>for other file types.  */\n<line113>if (flags->remove_file && ftruncate (fd, 0) != 0\n<line114>&& (S_ISREG (st.st_mode) || S_TYPEISSHM (&st)))\n<line115>{\n<line116>error (0, errno, _("%s: error truncating"), qname);\n<line117>ok = false;\n<line118>goto wipefd_out;\n<line119>}\n<line120>wipefd_out:\n<line121>free (passarray);\n<line122>return ok;\n<line123>}
----------------------------------------
Function: wipefd
Content: <line0>static bool\n<line1>wipefd (int fd, char const *qname, struct randint_source *s,\n<line2>struct Options const *flags)\n<line3>{\n<line4>int fd_flags = fcntl (fd, F_GETFL);\n<line5>if (fd_flags < 0)\n<line6>{\n<line7>error (0, errno, _("%s: fcntl failed"), qname);\n<line8>return false;\n<line9>}\n<line10>if (fd_flags & O_APPEND)\n<line11>{\n<line12>error (0, 0, _("%s: cannot shred append-only file descriptor"), qname);\n<line13>return false;\n<line14>}\n<line15>return do_wipefd (fd, qname, s, flags);\n<line16>}
----------------------------------------
Function: incname
Content: <line0>static bool\n<line1>incname (char *name, size_t len)\n<line2>{\n<line3>while (len--)\n<line4>{\n<line5>char const *p = strchr (nameset, name[len]);\n<line6>/* Given that NAME is composed of bytes from NAMESET,\n<line7>P will never be null here.  */\n<line8>/* If this character has a successor, use it.  */\n<line9>if (p[1])\n<line10>{\n<line11>name[len] = p[1];\n<line12>return true;\n<line13>}\n<line14>/* Otherwise, set this digit to 0 and increment the prefix.  */\n<line15>name[len] = nameset[0];\n<line16>}\n<line17>return false;\n<line18>}
----------------------------------------
Function: wipename
Content: <line0>static bool\n<line1>wipename (char *oldname, char const *qoldname, struct Options const *flags)\n<line2>{\n<line3>char *newname = xstrdup (oldname);\n<line4>char *base = last_component (newname);\n<line5>char *dir = dir_name (newname);\n<line6>char *qdir = xstrdup (quotef (dir));\n<line7>bool first = true;\n<line8>bool ok = true;\n<line9>int dir_fd = -1;\n<line10>if (flags->remove_file == remove_wipesync)\n<line11>dir_fd = open (dir, O_RDONLY | O_DIRECTORY | O_NOCTTY | O_NONBLOCK);\n<line12>if (flags->verbose)\n<line13>error (0, 0, _("%s: removing"), qoldname);\n<line14>if (flags->remove_file != remove_unlink)\n<line15>for (size_t len = base_len (base); len != 0; len--)\n<line16>{\n<line17>memset (base, nameset[0], len);\n<line18>base[len] = 0;\n<line19>bool rename_ok;\n<line20>while (! (rename_ok = (renameatu (AT_FDCWD, oldname, AT_FDCWD, newname,\n<line21>RENAME_NOREPLACE)\n<line22>== 0))\n<line23>&& errno == EEXIST && incname (base, len))\n<line24>continue;\n<line25>if (rename_ok)\n<line26>{\n<line27>if (0 <= dir_fd && dosync (dir_fd, qdir) != 0)\n<line28>ok = false;\n<line29>if (flags->verbose)\n<line30>{\n<line31>/* People seem to understand this better than talking\n<line32>about renaming OLDNAME.  NEWNAME doesn't need\n<line33>quoting because we picked it.  OLDNAME needs to be\n<line34>quoted only the first time.  */\n<line35>char const *old = first ? qoldname : oldname;\n<line36>error (0, 0,\n<line37>_("%s: renamed to %s"), old, newname);\n<line38>first = false;\n<line39>}\n<line40>memcpy (oldname + (base - newname), base, len + 1);\n<line41>}\n<line42>}\n<line43>if (unlink (oldname) != 0)\n<line44>{\n<line45>error (0, errno, _("%s: failed to remove"), qoldname);\n<line46>ok = false;\n<line47>}\n<line48>else if (flags->verbose)\n<line49>error (0, 0, _("%s: removed"), qoldname);\n<line50>if (0 <= dir_fd)\n<line51>{\n<line52>if (dosync (dir_fd, qdir) != 0)\n<line53>ok = false;\n<line54>if (close (dir_fd) != 0)\n<line55>{\n<line56>error (0, errno, _("%s: failed to close"), qdir);\n<line57>ok = false;\n<line58>}\n<line59>}\n<line60>free (newname);\n<line61>free (dir);\n<line62>free (qdir);\n<line63>return ok;\n<line64>}
----------------------------------------
Function: wipefile
Content: <line0>static bool\n<line1>wipefile (char *name, char const *qname,\n<line2>struct randint_source *s, struct Options const *flags)\n<line3>{\n<line4>bool ok;\n<line5>int fd;\n<line6>fd = open (name, O_WRONLY | O_NOCTTY | O_BINARY);\n<line7>if (fd < 0\n<line8>&& (errno == EACCES && flags->force)\n<line9>&& chmod (name, S_IWUSR) == 0)\n<line10>fd = open (name, O_WRONLY | O_NOCTTY | O_BINARY);\n<line11>if (fd < 0)\n<line12>{\n<line13>error (0, errno, _("%s: failed to open for writing"), qname);\n<line14>return false;\n<line15>}\n<line16>ok = do_wipefd (fd, qname, s, flags);\n<line17>if (close (fd) != 0)\n<line18>{\n<line19>error (0, errno, _("%s: failed to close"), qname);\n<line20>ok = false;\n<line21>}\n<line22>if (ok && flags->remove_file)\n<line23>ok = wipename (name, qname, flags);\n<line24>return ok;\n<line25>}
----------------------------------------
Function: clear_random_data
Content: <line0>static void\n<line1>clear_random_data (void)\n<line2>{\n<line3>randint_all_free (randint_source);\n<line4>}
----------------------------------------
Function: main
Content: <line0>int\n<line1>main (int argc, char **argv)\n<line2>{\n<line3>bool ok = true;\n<line4>struct Options flags = { 0, };\n<line5>char **file;\n<line6>int n_files;\n<line7>int c;\n<line8>int i;\n<line9>char const *random_source = nullptr;\n<line10>initialize_main (&argc, &argv);\n<line11>set_program_name (argv[0]);\n<line12>setlocale (LC_ALL, "");\n<line13>bindtextdomain (PACKAGE, LOCALEDIR);\n<line14>textdomain (PACKAGE);\n<line15>atexit (close_stdout);\n<line16>flags.n_iterations = DEFAULT_PASSES;\n<line17>flags.size = -1;\n<line18>while ((c = getopt_long (argc, argv, "fn:s:uvxz", long_opts, nullptr)) != -1)\n<line19>{\n<line20>switch (c)\n<line21>{\n<line22>case 'f':\n<line23>flags.force = true;\n<line24>break;\n<line25>case 'n':\n<line26>flags.n_iterations = xdectoumax (optarg, 0,\n<line27>MIN (ULONG_MAX,\n<line28>SIZE_MAX / sizeof (int)), "",\n<line29>_("invalid number of passes"), 0);\n<line30>break;\n<line31>case RANDOM_SOURCE_OPTION:\n<line32>if (random_source && !STREQ (random_source, optarg))\n<line33>error (EXIT_FAILURE, 0, _("multiple random sources specified"));\n<line34>random_source = optarg;\n<line35>break;\n<line36>case 'u':\n<line37>if (optarg == nullptr)\n<line38>flags.remove_file = remove_wipesync;\n<line39>else\n<line40>flags.remove_file = XARGMATCH ("--remove", optarg,\n<line41>remove_args, remove_methods);\n<line42>break;\n<line43>case 's':\n<line44>flags.size = xnumtoumax (optarg, 0, 0, OFF_T_MAX, "cbBkKMGTPEZYRQ0",\n<line45>_("invalid file size"), 0);\n<line46>break;\n<line47>case 'v':\n<line48>flags.verbose = true;\n<line49>break;\n<line50>case 'x':\n<line51>flags.exact = true;\n<line52>break;\n<line53>case 'z':\n<line54>flags.zero_fill = true;\n<line55>break;\n<line56>case_GETOPT_HELP_CHAR;\n<line57>case_GETOPT_VERSION_CHAR (PROGRAM_NAME, AUTHORS);\n<line58>default:\n<line59>usage (EXIT_FAILURE);\n<line60>}\n<line61>}\n<line62>file = argv + optind;\n<line63>n_files = argc - optind;\n<line64>if (n_files == 0)\n<line65>{\n<line66>error (0, 0, _("missing file operand"));\n<line67>usage (EXIT_FAILURE);\n<line68>}\n<line69>randint_source = randint_all_new (random_source, SIZE_MAX);\n<line70>if (! randint_source)\n<line71>error (EXIT_FAILURE, errno, "%s",\n<line72>quotef (random_source ? random_source : "getrandom"));\n<line73>atexit (clear_random_data);\n<line74>for (i = 0; i < n_files; i++)\n<line75>{\n<line76>char *qname = xstrdup (quotef (file[i]));\n<line77>if (STREQ (file[i], "-"))\n<line78>{\n<line79>ok &= wipefd (STDOUT_FILENO, qname, randint_source, &flags);\n<line80>}\n<line81>else\n<line82>{\n<line83>/* Plain filename - Note that this overwrites *argv! */\n<line84>ok &= wipefile (file[i], qname, randint_source, &flags);\n<line85>}\n<line86>free (qname);\n<line87>}\n<line88>return ok ? EXIT_SUCCESS : EXIT_FAILURE;\n<line89>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/src/shuf.c
========================================
Function: usage
Content: <line0>void\n<line1>usage (int status)\n<line2>{\n<line3>if (status != EXIT_SUCCESS)\n<line4>emit_try_help ();\n<line5>else\n<line6>{\n<line7>printf (_("\\n<line8>Usage: %s [OPTION]... [FILE]\n\\n<line9>or:  %s -e [OPTION]... [ARG]...\n\\n<line10>or:  %s -i LO-HI [OPTION]...\n\\n<line11>"),\n<line12>program_name, program_name, program_name);\n<line13>fputs (_("\\n<line14>Write a random permutation of the input lines to standard output.\n\\n<line15>"), stdout);\n<line16>emit_stdin_note ();\n<line17>emit_mandatory_arg_note ();\n<line18>fputs (_("\\n<line19>-e, --echo                treat each ARG as an input line\n\\n<line20>-i, --input-range=LO-HI   treat each number LO through HI as an input line\n\\n<line21>-n, --head-count=COUNT    output at most COUNT lines\n\\n<line22>-o, --output=FILE         write result to FILE instead of standard output\n\\n<line23>--random-source=FILE  get random bytes from FILE\n\\n<line24>-r, --repeat              output lines can be repeated\n\\n<line25>"), stdout);\n<line26>fputs (_("\\n<line27>-z, --zero-terminated     line delimiter is NUL, not newline\n\\n<line28>"), stdout);\n<line29>fputs (HELP_OPTION_DESCRIPTION, stdout);\n<line30>fputs (VERSION_OPTION_DESCRIPTION, stdout);\n<line31>emit_ancillary_info (PROGRAM_NAME);\n<line32>}\n<line33>exit (status);\n<line34>}
----------------------------------------
Function: input_from_argv
Content: <line0>static void\n<line1>input_from_argv (char **operand, int n_operands, char eolbyte)\n<line2>{\n<line3>char *p;\n<line4>size_t size = n_operands;\n<line5>int i;\n<line6>for (i = 0; i < n_operands; i++)\n<line7>size += strlen (operand[i]);\n<line8>p = xmalloc (size);\n<line9>for (i = 0; i < n_operands; i++)\n<line10>{\n<line11>char *p1 = stpcpy (p, operand[i]);\n<line12>operand[i] = p;\n<line13>p = p1;\n<line14>*p++ = eolbyte;\n<line15>}\n<line16>operand[n_operands] = p;\n<line17>}
----------------------------------------
Function: next_line
Content: <line0>static char *\n<line1>next_line (char *line, char eolbyte)\n<line2>{\n<line3>char *p = rawmemchr (line, eolbyte);\n<line4>return p + 1;\n<line5>}
----------------------------------------
Function: input_size
Content: <line0>static off_t\n<line1>input_size (void)\n<line2>{\n<line3>off_t file_size;\n<line4>struct stat stat_buf;\n<line5>if (fstat (STDIN_FILENO, &stat_buf) != 0)\n<line6>return OFF_T_MAX;\n<line7>if (usable_st_size (&stat_buf))\n<line8>file_size = stat_buf.st_size;\n<line9>else\n<line10>return OFF_T_MAX;\n<line11>off_t input_offset = lseek (STDIN_FILENO, 0, SEEK_CUR);\n<line12>if (input_offset < 0)\n<line13>return OFF_T_MAX;\n<line14>file_size -= input_offset;\n<line15>return file_size;\n<line16>}
----------------------------------------
Function: read_input_reservoir_sampling
Content: <line0>static size_t\n<line1>read_input_reservoir_sampling (FILE *in, char eolbyte, size_t k,\n<line2>struct randint_source *s,\n<line3>struct linebuffer **out_rsrv)\n<line4>{\n<line5>randint n_lines = 0;\n<line6>size_t n_alloc_lines = MIN (k, RESERVOIR_LINES_INCREMENT);\n<line7>struct linebuffer *line = nullptr;\n<line8>struct linebuffer *rsrv;\n<line9>rsrv = xcalloc (n_alloc_lines, sizeof (struct linebuffer));\n<line10>/* Fill the first K lines, directly into the reservoir.  */\n<line11>while (n_lines < k\n<line12>&& (line =\n<line13>readlinebuffer_delim (&rsrv[n_lines], in, eolbyte)) != nullptr)\n<line14>{\n<line15>n_lines++;\n<line16>/* Enlarge reservoir.  */\n<line17>if (n_lines >= n_alloc_lines)\n<line18>{\n<line19>n_alloc_lines += RESERVOIR_LINES_INCREMENT;\n<line20>rsrv = xnrealloc (rsrv, n_alloc_lines, sizeof (struct linebuffer));\n<line21>memset (&rsrv[n_lines], 0,\n<line22>RESERVOIR_LINES_INCREMENT * sizeof (struct linebuffer));\n<line23>}\n<line24>}\n<line25>/* last line wasn't null - so there may be more lines to read.  */\n<line26>if (line != nullptr)\n<line27>{\n<line28>struct linebuffer dummy;\n<line29>initbuffer (&dummy);  /* space for lines not put in reservoir.  */\n<line30>/* Choose the fate of the next line, with decreasing probability (as\n<line31>n_lines increases in size).\n<line32>If the line will be used, store it directly in the reservoir.\n<line33>Otherwise, store it in dummy space.\n<line34>With 'struct linebuffer', storing into existing buffer will reduce\n<line35>re-allocations (will only re-allocate if the new line is longer than\n<line36>the currently allocated space).  */\n<line37>do\n<line38>{\n<line39>randint j = randint_choose (s, n_lines + 1);  /* 0 .. n_lines.  */\n<line40>line = (j < k) ? (&rsrv[j]) : (&dummy);\n<line41>}\n<line42>while (readlinebuffer_delim (line, in, eolbyte) != nullptr && n_lines++);\n<line43>if (! n_lines)\n<line44>error (EXIT_FAILURE, EOVERFLOW, _("too many input lines"));\n<line45>freebuffer (&dummy);\n<line46>}\n<line47>/* no more input lines, or an input error.  */\n<line48>if (ferror (in))\n<line49>error (EXIT_FAILURE, errno, _("read error"));\n<line50>*out_rsrv = rsrv;\n<line51>return MIN (k, n_lines);\n<line52>}
----------------------------------------
Function: write_permuted_output_reservoir
Content: <line0>static int\n<line1>write_permuted_output_reservoir (size_t n_lines, struct linebuffer *lines,\n<line2>size_t const *permutation)\n<line3>{\n<line4>for (size_t i = 0; i < n_lines; i++)\n<line5>{\n<line6>const struct linebuffer *p = &lines[permutation[i]];\n<line7>if (fwrite (p->buffer, sizeof (char), p->length, stdout) != p->length)\n<line8>return -1;\n<line9>}\n<line10>return 0;\n<line11>}
----------------------------------------
Function: read_input
Content: <line0>static size_t\n<line1>read_input (FILE *in, char eolbyte, char ***pline)\n<line2>{\n<line3>char *p;\n<line4>char *buf = nullptr;\n<line5>size_t used;\n<line6>char *lim;\n<line7>char **line;\n<line8>size_t n_lines;\n<line9>/* TODO: We should limit the amount of data read here,\n<line10>to less than RESERVOIR_MIN_INPUT.  I.e., adjust fread_file() to support\n<line11>taking a byte limit.  We'd then need to ensure we handle a line spanning\n<line12>this boundary.  With that in place we could set use_reservoir_sampling\n<line13>when used==RESERVOIR_MIN_INPUT, and have read_input_reservoir_sampling()\n<line14>call a wrapper function to populate a linebuffer from the internal pline\n<line15>or if none left, stdin.  Doing that would give better performance by\n<line16>avoiding the reservoir CPU overhead when reading < RESERVOIR_MIN_INPUT\n<line17>from a pipe, and allow us to dispense with the input_size() function.  */\n<line18>if (!(buf = fread_file (in, 0, &used)))\n<line19>error (EXIT_FAILURE, errno, _("read error"));\n<line20>if (used && buf[used - 1] != eolbyte)\n<line21>buf[used++] = eolbyte;\n<line22>lim = buf + used;\n<line23>n_lines = 0;\n<line24>for (p = buf; p < lim; p = next_line (p, eolbyte))\n<line25>n_lines++;\n<line26>*pline = line = xnmalloc (n_lines + 1, sizeof *line);\n<line27>line[0] = p = buf;\n<line28>for (size_t i = 1; i <= n_lines; i++)\n<line29>line[i] = p = next_line (p, eolbyte);\n<line30>return n_lines;\n<line31>}
----------------------------------------
Function: write_permuted_lines
Content: <line0>static int\n<line1>write_permuted_lines (size_t n_lines, char *const *line,\n<line2>size_t const *permutation)\n<line3>{\n<line4>for (size_t i = 0; i < n_lines; i++)\n<line5>{\n<line6>char *const *p = line + permutation[i];\n<line7>size_t len = p[1] - p[0];\n<line8>if (fwrite (p[0], sizeof *p[0], len, stdout) != len)\n<line9>return -1;\n<line10>}\n<line11>return 0;\n<line12>}
----------------------------------------
Function: write_permuted_numbers
Content: <line0>static int\n<line1>write_permuted_numbers (size_t n_lines, size_t lo_input,\n<line2>size_t const *permutation, char eolbyte)\n<line3>{\n<line4>for (size_t i = 0; i < n_lines; i++)\n<line5>{\n<line6>unsigned long int n = lo_input + permutation[i];\n<line7>if (printf ("%lu%c", n, eolbyte) < 0)\n<line8>return -1;\n<line9>}\n<line10>return 0;\n<line11>}
----------------------------------------
Function: write_random_numbers
Content: <line0>static int\n<line1>write_random_numbers (struct randint_source *s, size_t count,\n<line2>size_t lo_input, size_t hi_input, char eolbyte)\n<line3>{\n<line4>const randint range = hi_input - lo_input + 1;\n<line5>for (size_t i = 0; i < count; i++)\n<line6>{\n<line7>unsigned long int j = lo_input + randint_choose (s, range);\n<line8>if (printf ("%lu%c", j, eolbyte) < 0)\n<line9>return -1;\n<line10>}\n<line11>return 0;\n<line12>}
----------------------------------------
Function: write_random_lines
Content: <line0>static int\n<line1>write_random_lines (struct randint_source *s, size_t count,\n<line2>char *const *lines, size_t n_lines)\n<line3>{\n<line4>for (size_t i = 0; i < count; i++)\n<line5>{\n<line6>const randint j = randint_choose (s, n_lines);\n<line7>char *const *p = lines + j;\n<line8>size_t len = p[1] - p[0];\n<line9>if (fwrite (p[0], sizeof *p[0], len, stdout) != len)\n<line10>return -1;\n<line11>}\n<line12>return 0;\n<line13>}
----------------------------------------
Function: main
Content: <line0>int\n<line1>main (int argc, char **argv)\n<line2>{\n<line3>bool echo = false;\n<line4>bool input_range = false;\n<line5>size_t lo_input = SIZE_MAX;\n<line6>size_t hi_input = 0;\n<line7>size_t head_lines = SIZE_MAX;\n<line8>char const *outfile = nullptr;\n<line9>char *random_source = nullptr;\n<line10>char eolbyte = '\n';\n<line11>char **input_lines = nullptr;\n<line12>bool use_reservoir_sampling = false;\n<line13>bool repeat = false;\n<line14>int optc;\n<line15>int n_operands;\n<line16>char **operand;\n<line17>size_t n_lines;\n<line18>char **line = nullptr;\n<line19>struct linebuffer *reservoir = nullptr;\n<line20>struct randint_source *randint_source;\n<line21>size_t *permutation = nullptr;\n<line22>int i;\n<line23>initialize_main (&argc, &argv);\n<line24>set_program_name (argv[0]);\n<line25>setlocale (LC_ALL, "");\n<line26>bindtextdomain (PACKAGE, LOCALEDIR);\n<line27>textdomain (PACKAGE);\n<line28>atexit (close_stdout);\n<line29>while ((optc = getopt_long (argc, argv, "ei:n:o:rz", long_opts, nullptr))\n<line30>!= -1)\n<line31>switch (optc)\n<line32>{\n<line33>case 'e':\n<line34>echo = true;\n<line35>break;\n<line36>case 'i':\n<line37>{\n<line38>if (input_range)\n<line39>error (EXIT_FAILURE, 0, _("multiple -i options specified"));\n<line40>input_range = true;\n<line41>uintmax_t u;\n<line42>char *lo_end;\n<line43>strtol_error err = xstrtoumax (optarg, &lo_end, 10, &u, nullptr);\n<line44>if (err == LONGINT_OK)\n<line45>{\n<line46>lo_input = u;\n<line47>if (lo_input != u)\n<line48>err = LONGINT_OVERFLOW;\n<line49>else if (*lo_end != '-')\n<line50>err = LONGINT_INVALID;\n<line51>else\n<line52>{\n<line53>err = xstrtoumax (lo_end + 1, nullptr, 10, &u, "");\n<line54>if (err == LONGINT_OK)\n<line55>{\n<line56>hi_input = u;\n<line57>if (hi_input != u)\n<line58>err = LONGINT_OVERFLOW;\n<line59>}\n<line60>}\n<line61>}\n<line62>n_lines = hi_input - lo_input + 1;\n<line63>if (err != LONGINT_OK || (lo_input <= hi_input) == (n_lines == 0))\n<line64>error (EXIT_FAILURE, err == LONGINT_OVERFLOW ? EOVERFLOW : 0,\n<line65>"%s: %s", _("invalid input range"), quote (optarg));\n<line66>}\n<line67>break;\n<line68>case 'n':\n<line69>{\n<line70>uintmax_t argval;\n<line71>strtol_error e = xstrtoumax (optarg, nullptr, 10, &argval, "");\n<line72>if (e == LONGINT_OK)\n<line73>head_lines = MIN (head_lines, argval);\n<line74>else if (e != LONGINT_OVERFLOW)\n<line75>error (EXIT_FAILURE, 0, _("invalid line count: %s"),\n<line76>quote (optarg));\n<line77>}\n<line78>break;\n<line79>case 'o':\n<line80>if (outfile && !STREQ (outfile, optarg))\n<line81>error (EXIT_FAILURE, 0, _("multiple output files specified"));\n<line82>outfile = optarg;\n<line83>break;\n<line84>case RANDOM_SOURCE_OPTION:\n<line85>if (random_source && !STREQ (random_source, optarg))\n<line86>error (EXIT_FAILURE, 0, _("multiple random sources specified"));\n<line87>random_source = optarg;\n<line88>break;\n<line89>case 'r':\n<line90>repeat = true;\n<line91>break;\n<line92>case 'z':\n<line93>eolbyte = '\0';\n<line94>break;\n<line95>case_GETOPT_HELP_CHAR;\n<line96>case_GETOPT_VERSION_CHAR (PROGRAM_NAME, AUTHORS);\n<line97>default:\n<line98>usage (EXIT_FAILURE);\n<line99>}\n<line100>n_operands = argc - optind;\n<line101>operand = argv + optind;\n<line102>/* Check invalid usage.  */\n<line103>if (echo && input_range)\n<line104>{\n<line105>error (0, 0, _("cannot combine -e and -i options"));\n<line106>usage (EXIT_FAILURE);\n<line107>}\n<line108>if (input_range ? 0 < n_operands : !echo && 1 < n_operands)\n<line109>{\n<line110>error (0, 0, _("extra operand %s"), quote (operand[!input_range]));\n<line111>usage (EXIT_FAILURE);\n<line112>}\n<line113>/* Prepare input.  */\n<line114>if (head_lines == 0)\n<line115>{\n<line116>n_lines = 0;\n<line117>line = nullptr;\n<line118>}\n<line119>else if (echo)\n<line120>{\n<line121>input_from_argv (operand, n_operands, eolbyte);\n<line122>n_lines = n_operands;\n<line123>line = operand;\n<line124>}\n<line125>else if (input_range)\n<line126>{\n<line127>n_lines = hi_input - lo_input + 1;\n<line128>line = nullptr;\n<line129>}\n<line130>else\n<line131>{\n<line132>/* If an input file is specified, re-open it as stdin.  */\n<line133>if (n_operands == 1\n<line134>&& ! (STREQ (operand[0], "-")\n<line135>|| freopen (operand[0], "r", stdin)))\n<line136>error (EXIT_FAILURE, errno, "%s", quotef (operand[0]));\n<line137>fadvise (stdin, FADVISE_SEQUENTIAL);\n<line138>if (repeat || head_lines == SIZE_MAX\n<line139>|| input_size () <= RESERVOIR_MIN_INPUT)\n<line140>{\n<line141>n_lines = read_input (stdin, eolbyte, &input_lines);\n<line142>line = input_lines;\n<line143>}\n<line144>else\n<line145>{\n<line146>use_reservoir_sampling = true;\n<line147>n_lines = SIZE_MAX;   /* unknown number of input lines, for now.  */\n<line148>}\n<line149>}\n<line150>/* The adjusted head line count; can be less than HEAD_LINES if the\n<line151>input is small and if not repeating.  */\n<line152>size_t ahead_lines = repeat || head_lines < n_lines ? head_lines : n_lines;\n<line153>randint_source = randint_all_new (random_source,\n<line154>(use_reservoir_sampling || repeat\n<line155>? SIZE_MAX\n<line156>: randperm_bound (ahead_lines, n_lines)));\n<line157>if (! randint_source)\n<line158>error (EXIT_FAILURE, errno, "%s",\n<line159>quotef (random_source ? random_source : "getrandom"));\n<line160>if (use_reservoir_sampling)\n<line161>{\n<line162>/* Instead of reading the entire file into 'line',\n<line163>use reservoir-sampling to store just AHEAD_LINES random lines.  */\n<line164>n_lines = read_input_reservoir_sampling (stdin, eolbyte, ahead_lines,\n<line165>randint_source, &reservoir);\n<line166>ahead_lines = n_lines;\n<line167>}\n<line168>/* Close stdin now, rather than earlier, so that randint_all_new\n<line169>doesn't have to worry about opening something other than\n<line170>stdin.  */\n<line171>if (! (head_lines == 0 || echo || input_range || fclose (stdin) == 0))\n<line172>error (EXIT_FAILURE, errno, _("read error"));\n<line173>if (!repeat)\n<line174>permutation = randperm_new (randint_source, ahead_lines, n_lines);\n<line175>if (outfile && ! freopen (outfile, "w", stdout))\n<line176>error (EXIT_FAILURE, errno, "%s", quotef (outfile));\n<line177>/* Generate output according to requested method */\n<line178>if (repeat)\n<line179>{\n<line180>if (head_lines == 0)\n<line181>i = 0;\n<line182>else\n<line183>{\n<line184>if (n_lines == 0)\n<line185>error (EXIT_FAILURE, 0, _("no lines to repeat"));\n<line186>if (input_range)\n<line187>i = write_random_numbers (randint_source, ahead_lines,\n<line188>lo_input, hi_input, eolbyte);\n<line189>else\n<line190>i = write_random_lines (randint_source, ahead_lines, line, n_lines);\n<line191>}\n<line192>}\n<line193>else\n<line194>{\n<line195>if (use_reservoir_sampling)\n<line196>i = write_permuted_output_reservoir (n_lines, reservoir, permutation);\n<line197>else if (input_range)\n<line198>i = write_permuted_numbers (ahead_lines, lo_input,\n<line199>permutation, eolbyte);\n<line200>else\n<line201>i = write_permuted_lines (ahead_lines, line, permutation);\n<line202>}\n<line203>if (i != 0)\n<line204>write_error ();\n<line205>main_exit (EXIT_SUCCESS);\n<line206>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/src/sleep.c
========================================
Function: usage
Content: <line0>void\n<line1>usage (int status)\n<line2>{\n<line3>if (status != EXIT_SUCCESS)\n<line4>emit_try_help ();\n<line5>else\n<line6>{\n<line7>printf (_("\\n<line8>Usage: %s NUMBER[SUFFIX]...\n\\n<line9>or:  %s OPTION\n\\n<line10>Pause for NUMBER seconds.  SUFFIX may be 's' for seconds (the default),\n\\n<line11>'m' for minutes, 'h' for hours or 'd' for days.  NUMBER need not be an\n\\n<line12>integer.  Given two or more arguments, pause for the amount of time\n\\n<line13>specified by the sum of their values.\n\\n<line14>\n\\n<line15>"),\n<line16>program_name, program_name);\n<line17>fputs (HELP_OPTION_DESCRIPTION, stdout);\n<line18>fputs (VERSION_OPTION_DESCRIPTION, stdout);\n<line19>emit_ancillary_info (PROGRAM_NAME);\n<line20>}\n<line21>exit (status);\n<line22>}
----------------------------------------
Function: apply_suffix
Content: <line0>static bool\n<line1>apply_suffix (double *x, char suffix_char)\n<line2>{\n<line3>int multiplier;\n<line4>switch (suffix_char)\n<line5>{\n<line6>case 0:\n<line7>case 's':\n<line8>multiplier = 1;\n<line9>break;\n<line10>case 'm':\n<line11>multiplier = 60;\n<line12>break;\n<line13>case 'h':\n<line14>multiplier = 60 * 60;\n<line15>break;\n<line16>case 'd':\n<line17>multiplier = 60 * 60 * 24;\n<line18>break;\n<line19>default:\n<line20>return false;\n<line21>}\n<line22>*x *= multiplier;\n<line23>return true;\n<line24>}
----------------------------------------
Function: main
Content: <line0>int\n<line1>main (int argc, char **argv)\n<line2>{\n<line3>double seconds = 0.0;\n<line4>bool ok = true;\n<line5>initialize_main (&argc, &argv);\n<line6>set_program_name (argv[0]);\n<line7>setlocale (LC_ALL, "");\n<line8>bindtextdomain (PACKAGE, LOCALEDIR);\n<line9>textdomain (PACKAGE);\n<line10>atexit (close_stdout);\n<line11>parse_gnu_standard_options_only (argc, argv, PROGRAM_NAME, PACKAGE_NAME,\n<line12>Version, true, usage, AUTHORS,\n<line13>(char const *) nullptr);\n<line14>if (argc == 1)\n<line15>{\n<line16>error (0, 0, _("missing operand"));\n<line17>usage (EXIT_FAILURE);\n<line18>}\n<line19>for (int i = optind; i < argc; i++)\n<line20>{\n<line21>double s;\n<line22>char const *p;\n<line23>if (! (xstrtod (argv[i], &p, &s, cl_strtod) || errno == ERANGE)\n<line24>/* Nonnegative interval.  */\n<line25>|| ! (0 <= s)\n<line26>/* No extra chars after the number and an optional s,m,h,d char.  */\n<line27>|| (*p && *(p + 1))\n<line28>/* Check any suffix char and update S based on the suffix.  */\n<line29>|| ! apply_suffix (&s, *p))\n<line30>{\n<line31>error (0, 0, _("invalid time interval %s"), quote (argv[i]));\n<line32>ok = false;\n<line33>}\n<line34>seconds += s;\n<line35>}\n<line36>if (!ok)\n<line37>usage (EXIT_FAILURE);\n<line38>if (xnanosleep (seconds))\n<line39>error (EXIT_FAILURE, errno, _("cannot read realtime clock"));\n<line40>return EXIT_SUCCESS;\n<line41>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/src/sort.c
========================================
/home/huihui/Downloads/coreutils-9.4/src/sort.c:111:46: warning: '_Static_assert' with no message is a C2x extension [-Wc2x-extensions]
static_assert (4 <= SUBTHREAD_LINES_HEURISTIC);
                                             ^
                                             , ""
/home/huihui/Downloads/coreutils-9.4/src/sort.c:1412:21: warning: implicit conversion from 'unsigned long' to 'double' changes value from 18446744073709551615 to 18446744073709551616 [-Wimplicit-const-int-float-conversion]
          if (mem < UINTMAX_MAX)
                  ~ ^~~~~~~~~~~
/usr/include/stdint.h:191:24: note: expanded from macro 'UINTMAX_MAX'
# define UINTMAX_MAX            (__UINT64_C(18446744073709551615))
                                 ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/usr/include/stdint.h:96:25: note: expanded from macro '__UINT64_C'
#  define __UINT64_C(c) c ## UL
                        ^~~~~~~
<scratch space>:137:1: note: expanded from here
18446744073709551615UL
^~~~~~~~~~~~~~~~~~~~~~
2 warnings generated.
Function: async_safe_die
Content: <line0>static _Noreturn void\n<line1>async_safe_die (int errnum, char const *errstr)\n<line2>{\n<line3>ignore_value (write (STDERR_FILENO, errstr, strlen (errstr)));\n<line4>/* Even if defined HAVE_STRERROR_R, we can't use it,\n<line5>as it may return a translated string etc. and even if not\n<line6>may call malloc which is unsafe.  We might improve this\n<line7>by testing for sys_errlist and using that if available.\n<line8>For now just report the error number.  */\n<line9>if (errnum)\n<line10>{\n<line11>char errbuf[INT_BUFSIZE_BOUND (errnum)];\n<line12>char *p = inttostr (errnum, errbuf);\n<line13>ignore_value (write (STDERR_FILENO, ": errno ", 8));\n<line14>ignore_value (write (STDERR_FILENO, p, strlen (p)));\n<line15>}\n<line16>ignore_value (write (STDERR_FILENO, "\n", 1));\n<line17>_exit (SORT_FAILURE);\n<line18>}
----------------------------------------
Function: sort_die
Content: <line0>static void\n<line1>sort_die (char const *message, char const *file)\n<line2>{\n<line3>error (SORT_FAILURE, errno, "%s: %s", message,\n<line4>quotef (file ? file : _("standard output")));\n<line5>}
----------------------------------------
Function: usage
Content: <line0>void\n<line1>usage (int status)\n<line2>{\n<line3>if (status != EXIT_SUCCESS)\n<line4>emit_try_help ();\n<line5>else\n<line6>{\n<line7>printf (_("\\n<line8>Usage: %s [OPTION]... [FILE]...\n\\n<line9>or:  %s [OPTION]... --files0-from=F\n\\n<line10>"),\n<line11>program_name, program_name);\n<line12>fputs (_("\\n<line13>Write sorted concatenation of all FILE(s) to standard output.\n\\n<line14>"), stdout);\n<line15>emit_stdin_note ();\n<line16>emit_mandatory_arg_note ();\n<line17>fputs (_("\\n<line18>Ordering options:\n\\n<line19>\n\\n<line20>"), stdout);\n<line21>fputs (_("\\n<line22>-b, --ignore-leading-blanks  ignore leading blanks\n\\n<line23>-d, --dictionary-order      consider only blanks and alphanumeric characters\\n<line24>\n\\n<line25>-f, --ignore-case           fold lower case to upper case characters\n\\n<line26>"), stdout);\n<line27>fputs (_("\\n<line28>-g, --general-numeric-sort  compare according to general numerical value\n\\n<line29>-i, --ignore-nonprinting    consider only printable characters\n\\n<line30>-M, --month-sort            compare (unknown) < 'JAN' < ... < 'DEC'\n\\n<line31>"), stdout);\n<line32>fputs (_("\\n<line33>-h, --human-numeric-sort    compare human readable numbers (e.g., 2K 1G)\n\\n<line34>"), stdout);\n<line35>fputs (_("\\n<line36>-n, --numeric-sort          compare according to string numerical value\n\\n<line37>-R, --random-sort           shuffle, but group identical keys.  See shuf(1)\n\\n<line38>--random-source=FILE    get random bytes from FILE\n\\n<line39>-r, --reverse               reverse the result of comparisons\n\\n<line40>"), stdout);\n<line41>fputs (_("\\n<line42>--sort=WORD             sort according to WORD:\n\\n<line43>general-numeric -g, human-numeric -h, month -M,\\n<line44>\n\\n<line45>numeric -n, random -R, version -V\n\\n<line46>-V, --version-sort          natural sort of (version) numbers within text\n\\n<line47>\n\\n<line48>"), stdout);\n<line49>fputs (_("\\n<line50>Other options:\n\\n<line51>\n\\n<line52>"), stdout);\n<line53>fputs (_("\\n<line54>--batch-size=NMERGE   merge at most NMERGE inputs at once;\n\\n<line55>for more use temp files\n\\n<line56>"), stdout);\n<line57>fputs (_("\\n<line58>-c, --check, --check=diagnose-first  check for sorted input; do not sort\n\\n<line59>-C, --check=quiet, --check=silent  like -c, but do not report first bad line\\n<line60>\n\\n<line61>--compress-program=PROG  compress temporaries with PROG;\n\\n<line62>decompress them with PROG -d\n\\n<line63>"), stdout);\n<line64>fputs (_("\\n<line65>--debug               annotate the part of the line used to sort,\n\\n<line66>and warn about questionable usage to stderr\n\\n<line67>--files0-from=F       read input from the files specified by\n\\n<line68>NUL-terminated names in file F;\n\\n<line69>If F is - then read names from standard input\n\\n<line70>"), stdout);\n<line71>fputs (_("\\n<line72>-k, --key=KEYDEF          sort via a key; KEYDEF gives location and type\n\\n<line73>-m, --merge               merge already sorted files; do not sort\n\\n<line74>"), stdout);\n<line75>fputs (_("\\n<line76>-o, --output=FILE         write result to FILE instead of standard output\n\\n<line77>-s, --stable              stabilize sort by disabling last-resort comparison\\n<line78>\n\\n<line79>-S, --buffer-size=SIZE    use SIZE for main memory buffer\n\\n<line80>"), stdout);\n<line81>printf (_("\\n<line82>-t, --field-separator=SEP  use SEP instead of non-blank to blank transition\n\\n<line83>-T, --temporary-directory=DIR  use DIR for temporaries, not $TMPDIR or %s;\n\\n<line84>multiple options specify multiple directories\n\\n<line85>--parallel=N          change the number of sorts run concurrently to N\n\\n<line86>-u, --unique              with -c, check for strict ordering;\n\\n<line87>without -c, output only the first of an equal run\\n<line88>\n\\n<line89>"), DEFAULT_TMPDIR);\n<line90>fputs (_("\\n<line91>-z, --zero-terminated     line delimiter is NUL, not newline\n\\n<line92>"), stdout);\n<line93>fputs (HELP_OPTION_DESCRIPTION, stdout);\n<line94>fputs (VERSION_OPTION_DESCRIPTION, stdout);\n<line95>fputs (_("\\n<line96>\n\\n<line97>KEYDEF is F[.C][OPTS][,F[.C][OPTS]] for start and stop position, where F is a\n\\n<line98>field number and C a character position in the field; both are origin 1, and\n\\n<line99>the stop position defaults to the line's end.  If neither -t nor -b is in\n\\n<line100>effect, characters in a field are counted from the beginning of the preceding\n\\n<line101>whitespace.  OPTS is one or more single-letter ordering options [bdfgiMhnRrV],\\n<line102>\n\\n<line103>which override global ordering options for that key.  If no key is given, use\n\\n<line104>the entire line as the key.  Use --debug to diagnose incorrect key usage.\n\\n<line105>\n\\n<line106>SIZE may be followed by the following multiplicative suffixes:\n\\n<line107>"), stdout);\n<line108>fputs (_("\\n<line109>% 1% of memory, b 1, K 1024 (default), and so on for M, G, T, P, E, Z, Y, R, Q.\\n<line110>\n\n\\n<line111>*** WARNING ***\n\\n<line112>The locale specified by the environment affects sort order.\n\\n<line113>Set LC_ALL=C to get the traditional sort order that uses\n\\n<line114>native byte values.\n\\n<line115>"), stdout );\n<line116>emit_ancillary_info (PROGRAM_NAME);\n<line117>}\n<line118>exit (status);\n<line119>}
----------------------------------------
Function: cs_enter
Content: <line0>static void\n<line1>cs_enter (struct cs_status *status)\n<line2>{\n<line3>int ret = pthread_sigmask (SIG_BLOCK, &caught_signals, &status->sigs);\n<line4>status->valid = ret == 0;\n<line5>}
----------------------------------------
Function: cs_leave
Content: <line0>static void\n<line1>cs_leave (struct cs_status const *status)\n<line2>{\n<line3>if (status->valid)\n<line4>{\n<line5>/* Ignore failure when restoring the signal mask. */\n<line6>pthread_sigmask (SIG_SETMASK, &status->sigs, nullptr);\n<line7>}\n<line8>}
----------------------------------------
Function: proctab_hasher
Content: <line0>static size_t\n<line1>proctab_hasher (void const *entry, size_t tabsize)\n<line2>{\n<line3>struct tempnode const *node = entry;\n<line4>return node->pid % tabsize;\n<line5>}
----------------------------------------
Function: proctab_comparator
Content: <line0>static bool\n<line1>proctab_comparator (void const *e1, void const *e2)\n<line2>{\n<line3>struct tempnode const *n1 = e1;\n<line4>struct tempnode const *n2 = e2;\n<line5>return n1->pid == n2->pid;\n<line6>}
----------------------------------------
Function: reap
Content: <line0>static pid_t\n<line1>reap (pid_t pid)\n<line2>{\n<line3>int status;\n<line4>pid_t cpid = waitpid ((pid ? pid : -1), &status, (pid ? 0 : WNOHANG));\n<line5>if (cpid < 0)\n<line6>error (SORT_FAILURE, errno, _("waiting for %s [-d]"),\n<line7>quoteaf (compress_program));\n<line8>else if (0 < cpid && (0 < pid || delete_proc (cpid)))\n<line9>{\n<line10>if (! WIFEXITED (status) || WEXITSTATUS (status))\n<line11>error (SORT_FAILURE, 0, _("%s [-d] terminated abnormally"),\n<line12>quoteaf (compress_program));\n<line13>--nprocs;\n<line14>}\n<line15>return cpid;\n<line16>}
----------------------------------------
Function: register_proc
Content: <line0>static void\n<line1>register_proc (struct tempnode *temp)\n<line2>{\n<line3>if (! proctab)\n<line4>{\n<line5>proctab = hash_initialize (INIT_PROCTAB_SIZE, nullptr,\n<line6>proctab_hasher,\n<line7>proctab_comparator,\n<line8>nullptr);\n<line9>if (! proctab)\n<line10>xalloc_die ();\n<line11>}\n<line12>temp->state = UNREAPED;\n<line13>if (! hash_insert (proctab, temp))\n<line14>xalloc_die ();\n<line15>}
----------------------------------------
Function: delete_proc
Content: <line0>static bool\n<line1>delete_proc (pid_t pid)\n<line2>{\n<line3>struct tempnode test;\n<line4>test.pid = pid;\n<line5>struct tempnode *node = hash_remove (proctab, &test);\n<line6>if (! node)\n<line7>return false;\n<line8>node->state = REAPED;\n<line9>return true;\n<line10>}
----------------------------------------
Function: wait_proc
Content: <line0>static void\n<line1>wait_proc (pid_t pid)\n<line2>{\n<line3>if (delete_proc (pid))\n<line4>reap (pid);\n<line5>}
----------------------------------------
Function: reap_exited
Content: <line0>static void\n<line1>reap_exited (void)\n<line2>{\n<line3>while (0 < nprocs && reap (0))\n<line4>continue;\n<line5>}
----------------------------------------
Function: reap_some
Content: <line0>static void\n<line1>reap_some (void)\n<line2>{\n<line3>reap (-1);\n<line4>reap_exited ();\n<line5>}
----------------------------------------
Function: reap_all
Content: <line0>static void\n<line1>reap_all (void)\n<line2>{\n<line3>while (0 < nprocs)\n<line4>reap (-1);\n<line5>}
----------------------------------------
Function: cleanup
Content: <line0>static void\n<line1>cleanup (void)\n<line2>{\n<line3>struct tempnode const *node;\n<line4>for (node = temphead; node; node = node->next)\n<line5>unlink (node->name);\n<line6>temphead = nullptr;\n<line7>}
----------------------------------------
Function: exit_cleanup
Content: <line0>static void\n<line1>exit_cleanup (void)\n<line2>{\n<line3>if (temphead)\n<line4>{\n<line5>/* Clean up any remaining temporary files in a critical section so\n<line6>that a signal handler does not try to clean them too.  */\n<line7>struct cs_status cs;\n<line8>cs_enter (&cs);\n<line9>cleanup ();\n<line10>cs_leave (&cs);\n<line11>}\n<line12>close_stdout ();\n<line13>}
----------------------------------------
Function: create_temp_file
Content: <line0>static struct tempnode *\n<line1>create_temp_file (int *pfd, bool survive_fd_exhaustion)\n<line2>{\n<line3>static char const slashbase[] = "/sortXXXXXX";\n<line4>static size_t temp_dir_index;\n<line5>int fd;\n<line6>int saved_errno;\n<line7>char const *temp_dir = temp_dirs[temp_dir_index];\n<line8>size_t len = strlen (temp_dir);\n<line9>struct tempnode *node =\n<line10>xmalloc (FLEXSIZEOF (struct tempnode, name, len + sizeof slashbase));\n<line11>char *file = node->name;\n<line12>struct cs_status cs;\n<line13>memcpy (file, temp_dir, len);\n<line14>memcpy (file + len, slashbase, sizeof slashbase);\n<line15>node->next = nullptr;\n<line16>if (++temp_dir_index == temp_dir_count)\n<line17>temp_dir_index = 0;\n<line18>/* Create the temporary file in a critical section, to avoid races.  */\n<line19>cs_enter (&cs);\n<line20>fd = mkostemp (file, O_CLOEXEC);\n<line21>if (0 <= fd)\n<line22>{\n<line23>*temptail = node;\n<line24>temptail = &node->next;\n<line25>}\n<line26>saved_errno = errno;\n<line27>cs_leave (&cs);\n<line28>errno = saved_errno;\n<line29>if (fd < 0)\n<line30>{\n<line31>if (! (survive_fd_exhaustion && errno == EMFILE))\n<line32>error (SORT_FAILURE, errno, _("cannot create temporary file in %s"),\n<line33>quoteaf (temp_dir));\n<line34>free (node);\n<line35>node = nullptr;\n<line36>}\n<line37>*pfd = fd;\n<line38>return node;\n<line39>}
----------------------------------------
Function: get_outstatus
Content: <line0>static struct stat *\n<line1>get_outstatus (void)\n<line2>{\n<line3>static int outstat_errno;\n<line4>static struct stat outstat;\n<line5>if (outstat_errno == 0)\n<line6>outstat_errno = fstat (STDOUT_FILENO, &outstat) == 0 ? -1 : errno;\n<line7>return outstat_errno < 0 ? &outstat : nullptr;\n<line8>}
----------------------------------------
Function: stream_open
Content: <line0>static FILE *\n<line1>stream_open (char const *file, char const *how)\n<line2>{\n<line3>FILE *fp;\n<line4>if (*how == 'r')\n<line5>{\n<line6>if (STREQ (file, "-"))\n<line7>{\n<line8>have_read_stdin = true;\n<line9>fp = stdin;\n<line10>}\n<line11>else\n<line12>{\n<line13>int fd = open (file, O_RDONLY | O_CLOEXEC);\n<line14>fp = fd < 0 ? nullptr : fdopen (fd, how);\n<line15>}\n<line16>fadvise (fp, FADVISE_SEQUENTIAL);\n<line17>}\n<line18>else if (*how == 'w')\n<line19>{\n<line20>if (file && ftruncate (STDOUT_FILENO, 0) != 0)\n<line21>{\n<line22>int ftruncate_errno = errno;\n<line23>struct stat *outst = get_outstatus ();\n<line24>if (!outst || S_ISREG (outst->st_mode) || S_TYPEISSHM (outst))\n<line25>error (SORT_FAILURE, ftruncate_errno, _("%s: error truncating"),\n<line26>quotef (file));\n<line27>}\n<line28>fp = stdout;\n<line29>}\n<line30>else\n<line31>affirm (!"unexpected mode passed to stream_open");\n<line32>return fp;\n<line33>}
----------------------------------------
Function: xfopen
Content: <line0>static FILE *\n<line1>xfopen (char const *file, char const *how)\n<line2>{\n<line3>FILE *fp = stream_open (file, how);\n<line4>if (!fp)\n<line5>sort_die (_("open failed"), file);\n<line6>return fp;\n<line7>}
----------------------------------------
Function: xfclose
Content: <line0>static void\n<line1>xfclose (FILE *fp, char const *file)\n<line2>{\n<line3>switch (fileno (fp))\n<line4>{\n<line5>case STDIN_FILENO:\n<line6>/* Allow reading stdin from tty more than once.  */\n<line7>clearerr (fp);\n<line8>break;\n<line9>case STDOUT_FILENO:\n<line10>/* Don't close stdout just yet.  close_stdout does that.  */\n<line11>if (fflush (fp) != 0)\n<line12>sort_die (_("fflush failed"), file);\n<line13>break;\n<line14>default:\n<line15>if (fclose (fp) != 0)\n<line16>sort_die (_("close failed"), file);\n<line17>break;\n<line18>}\n<line19>}
----------------------------------------
Function: move_fd
Content: <line0>static void\n<line1>move_fd (int oldfd, int newfd)\n<line2>{\n<line3>if (oldfd != newfd)\n<line4>{\n<line5>/* These should never fail for our usage.  */\n<line6>ignore_value (dup2 (oldfd, newfd));\n<line7>ignore_value (close (oldfd));\n<line8>}\n<line9>}
----------------------------------------
Function: pipe_fork
Content: <line0>static pid_t\n<line1>pipe_fork (int pipefds[2], size_t tries)\n<line2>{\n<line3>#if HAVE_WORKING_FORK\n<line4>struct tempnode *saved_temphead;\n<line5>int saved_errno;\n<line6>double wait_retry = 0.25;\n<line7>pid_t pid;\n<line8>struct cs_status cs;\n<line9>if (pipe2 (pipefds, O_CLOEXEC) < 0)\n<line10>return -1;\n<line11>/* At least NMERGE + 1 subprocesses are needed.  More could be created, but\n<line12>uncontrolled subprocess generation can hurt performance significantly.\n<line13>Allow at most NMERGE + 2 subprocesses, on the theory that there\n<line14>may be some useful parallelism by letting compression for the\n<line15>previous merge finish (1 subprocess) in parallel with the current\n<line16>merge (NMERGE + 1 subprocesses).  */\n<line17>if (nmerge + 1 < nprocs)\n<line18>reap_some ();\n<line19>while (tries--)\n<line20>{\n<line21>/* This is so the child process won't delete our temp files\n<line22>if it receives a signal before exec-ing.  */\n<line23>cs_enter (&cs);\n<line24>saved_temphead = temphead;\n<line25>temphead = nullptr;\n<line26>pid = fork ();\n<line27>saved_errno = errno;\n<line28>if (pid)\n<line29>temphead = saved_temphead;\n<line30>cs_leave (&cs);\n<line31>errno = saved_errno;\n<line32>if (0 <= pid || errno != EAGAIN)\n<line33>break;\n<line34>else\n<line35>{\n<line36>xnanosleep (wait_retry);\n<line37>wait_retry *= 2;\n<line38>reap_exited ();\n<line39>}\n<line40>}\n<line41>if (pid < 0)\n<line42>{\n<line43>saved_errno = errno;\n<line44>close (pipefds[0]);\n<line45>close (pipefds[1]);\n<line46>errno = saved_errno;\n<line47>}\n<line48>else if (pid == 0)\n<line49>{\n<line50>close (STDIN_FILENO);\n<line51>close (STDOUT_FILENO);\n<line52>}\n<line53>else\n<line54>++nprocs;\n<line55>return pid;\n<line56>#else  /* ! HAVE_WORKING_FORK */\n<line57>return -1;\n<line58>#endif\n<line59>}
----------------------------------------
Function: maybe_create_temp
Content: <line0>static struct tempnode *\n<line1>maybe_create_temp (FILE **pfp, bool survive_fd_exhaustion)\n<line2>{\n<line3>int tempfd;\n<line4>struct tempnode *node = create_temp_file (&tempfd, survive_fd_exhaustion);\n<line5>if (! node)\n<line6>return nullptr;\n<line7>node->state = UNCOMPRESSED;\n<line8>if (compress_program)\n<line9>{\n<line10>int pipefds[2];\n<line11>node->pid = pipe_fork (pipefds, MAX_FORK_TRIES_COMPRESS);\n<line12>if (0 < node->pid)\n<line13>{\n<line14>close (tempfd);\n<line15>close (pipefds[0]);\n<line16>tempfd = pipefds[1];\n<line17>register_proc (node);\n<line18>}\n<line19>else if (node->pid == 0)\n<line20>{\n<line21>/* Being the child of a multithreaded program before exec,\n<line22>we're restricted to calling async-signal-safe routines here.  */\n<line23>close (pipefds[1]);\n<line24>move_fd (tempfd, STDOUT_FILENO);\n<line25>move_fd (pipefds[0], STDIN_FILENO);\n<line26>execlp (compress_program, compress_program, (char *) nullptr);\n<line27>async_safe_die (errno, "couldn't execute compress program");\n<line28>}\n<line29>}\n<line30>*pfp = fdopen (tempfd, "w");\n<line31>if (! *pfp)\n<line32>sort_die (_("couldn't create temporary file"), node->name);\n<line33>return node;\n<line34>}
----------------------------------------
Function: create_temp
Content: <line0>static struct tempnode *\n<line1>create_temp (FILE **pfp)\n<line2>{\n<line3>return maybe_create_temp (pfp, false);\n<line4>}
----------------------------------------
Function: open_temp
Content: <line0>static FILE *\n<line1>open_temp (struct tempnode *temp)\n<line2>{\n<line3>int tempfd, pipefds[2];\n<line4>FILE *fp = nullptr;\n<line5>if (temp->state == UNREAPED)\n<line6>wait_proc (temp->pid);\n<line7>tempfd = open (temp->name, O_RDONLY);\n<line8>if (tempfd < 0)\n<line9>return nullptr;\n<line10>pid_t child = pipe_fork (pipefds, MAX_FORK_TRIES_DECOMPRESS);\n<line11>switch (child)\n<line12>{\n<line13>case -1:\n<line14>if (errno != EMFILE)\n<line15>error (SORT_FAILURE, errno, _("couldn't create process for %s -d"),\n<line16>quoteaf (compress_program));\n<line17>close (tempfd);\n<line18>errno = EMFILE;\n<line19>break;\n<line20>case 0:\n<line21>/* Being the child of a multithreaded program before exec,\n<line22>we're restricted to calling async-signal-safe routines here.  */\n<line23>close (pipefds[0]);\n<line24>move_fd (tempfd, STDIN_FILENO);\n<line25>move_fd (pipefds[1], STDOUT_FILENO);\n<line26>execlp (compress_program, compress_program, "-d", (char *) nullptr);\n<line27>async_safe_die (errno, "couldn't execute compress program (with -d)");\n<line28>default:\n<line29>temp->pid = child;\n<line30>register_proc (temp);\n<line31>close (tempfd);\n<line32>close (pipefds[1]);\n<line33>fp = fdopen (pipefds[0], "r");\n<line34>if (! fp)\n<line35>{\n<line36>int saved_errno = errno;\n<line37>close (pipefds[0]);\n<line38>errno = saved_errno;\n<line39>}\n<line40>break;\n<line41>}\n<line42>return fp;\n<line43>}
----------------------------------------
Function: add_temp_dir
Content: <line0>static void\n<line1>add_temp_dir (char const *dir)\n<line2>{\n<line3>if (temp_dir_count == temp_dir_alloc)\n<line4>temp_dirs = X2NREALLOC (temp_dirs, &temp_dir_alloc);\n<line5>temp_dirs[temp_dir_count++] = dir;\n<line6>}
----------------------------------------
Function: zaptemp
Content: <line0>static void\n<line1>zaptemp (char const *name)\n<line2>{\n<line3>struct tempnode *volatile *pnode;\n<line4>struct tempnode *node;\n<line5>struct tempnode *next;\n<line6>int unlink_status;\n<line7>int unlink_errno = 0;\n<line8>struct cs_status cs;\n<line9>for (pnode = &temphead; (node = *pnode)->name != name; pnode = &node->next)\n<line10>continue;\n<line11>if (node->state == UNREAPED)\n<line12>wait_proc (node->pid);\n<line13>/* Unlink the temporary file in a critical section to avoid races.  */\n<line14>next = node->next;\n<line15>cs_enter (&cs);\n<line16>unlink_status = unlink (name);\n<line17>unlink_errno = errno;\n<line18>*pnode = next;\n<line19>cs_leave (&cs);\n<line20>if (unlink_status != 0)\n<line21>error (0, unlink_errno, _("warning: cannot remove: %s"), quotef (name));\n<line22>if (! next)\n<line23>temptail = pnode;\n<line24>free (node);\n<line25>}
----------------------------------------
Function: struct_month_cmp
Content: <line0>static int\n<line1>struct_month_cmp (void const *m1, void const *m2)\n<line2>{\n<line3>struct month const *month1 = m1;\n<line4>struct month const *month2 = m2;\n<line5>return strcmp (month1->name, month2->name);\n<line6>}
----------------------------------------
Function: inittables
Content: <line0>static void\n<line1>inittables (void)\n<line2>{\n<line3>size_t i;\n<line4>for (i = 0; i < UCHAR_LIM; ++i)\n<line5>{\n<line6>blanks[i] = field_sep (i);\n<line7>nonprinting[i] = ! isprint (i);\n<line8>nondictionary[i] = ! isalnum (i) && ! field_sep (i);\n<line9>fold_toupper[i] = toupper (i);\n<line10>}\n<line11>#if HAVE_NL_LANGINFO\n<line12>/* If we're not in the "C" locale, read different names for months.  */\n<line13>if (hard_LC_TIME)\n<line14>{\n<line15>for (i = 0; i < MONTHS_PER_YEAR; i++)\n<line16>{\n<line17>char const *s;\n<line18>size_t s_len;\n<line19>size_t j, k;\n<line20>char *name;\n<line21>s = nl_langinfo (ABMON_1 + i);\n<line22>s_len = strlen (s);\n<line23>monthtab[i].name = name = xmalloc (s_len + 1);\n<line24>monthtab[i].val = i + 1;\n<line25>for (j = k = 0; j < s_len; j++)\n<line26>if (! isblank (to_uchar (s[j])))\n<line27>name[k++] = fold_toupper[to_uchar (s[j])];\n<line28>name[k] = '\0';\n<line29>}\n<line30>qsort (monthtab, MONTHS_PER_YEAR, sizeof *monthtab, struct_month_cmp);\n<line31>}\n<line32>#endif\n<line33>}
----------------------------------------
Function: specify_nmerge
Content: <line0>static void\n<line1>specify_nmerge (int oi, char c, char const *s)\n<line2>{\n<line3>uintmax_t n;\n<line4>struct rlimit rlimit;\n<line5>enum strtol_error e = xstrtoumax (s, nullptr, 10, &n, "");\n<line6>/* Try to find out how many file descriptors we'll be able\n<line7>to open.  We need at least nmerge + 3 (STDIN_FILENO,\n<line8>STDOUT_FILENO and STDERR_FILENO). */\n<line9>unsigned int max_nmerge = ((getrlimit (RLIMIT_NOFILE, &rlimit) == 0\n<line10>? rlimit.rlim_cur\n<line11>: OPEN_MAX)\n<line12>- 3);\n<line13>if (e == LONGINT_OK)\n<line14>{\n<line15>nmerge = n;\n<line16>if (nmerge != n)\n<line17>e = LONGINT_OVERFLOW;\n<line18>else\n<line19>{\n<line20>if (nmerge < 2)\n<line21>{\n<line22>error (0, 0, _("invalid --%s argument %s"),\n<line23>long_options[oi].name, quote (s));\n<line24>error (SORT_FAILURE, 0,\n<line25>_("minimum --%s argument is %s"),\n<line26>long_options[oi].name, quote ("2"));\n<line27>}\n<line28>else if (max_nmerge < nmerge)\n<line29>{\n<line30>e = LONGINT_OVERFLOW;\n<line31>}\n<line32>else\n<line33>return;\n<line34>}\n<line35>}\n<line36>if (e == LONGINT_OVERFLOW)\n<line37>{\n<line38>char max_nmerge_buf[INT_BUFSIZE_BOUND (max_nmerge)];\n<line39>error (0, 0, _("--%s argument %s too large"),\n<line40>long_options[oi].name, quote (s));\n<line41>error (SORT_FAILURE, 0,\n<line42>_("maximum --%s argument with current rlimit is %s"),\n<line43>long_options[oi].name,\n<line44>uinttostr (max_nmerge, max_nmerge_buf));\n<line45>}\n<line46>else\n<line47>xstrtol_fatal (e, oi, c, long_options, s);\n<line48>}
----------------------------------------
Function: specify_sort_size
Content: <line0>static void\n<line1>specify_sort_size (int oi, char c, char const *s)\n<line2>{\n<line3>uintmax_t n;\n<line4>char *suffix;\n<line5>enum strtol_error e = xstrtoumax (s, &suffix, 10, &n, "EgGkKmMPQRtTYZ");\n<line6>/* The default unit is KiB.  */\n<line7>if (e == LONGINT_OK && ISDIGIT (suffix[-1]))\n<line8>{\n<line9>if (n <= UINTMAX_MAX / 1024)\n<line10>n *= 1024;\n<line11>else\n<line12>e = LONGINT_OVERFLOW;\n<line13>}\n<line14>/* A 'b' suffix means bytes; a '%' suffix means percent of memory.  */\n<line15>if (e == LONGINT_INVALID_SUFFIX_CHAR && ISDIGIT (suffix[-1]) && ! suffix[1])\n<line16>switch (suffix[0])\n<line17>{\n<line18>case 'b':\n<line19>e = LONGINT_OK;\n<line20>break;\n<line21>case '%':\n<line22>{\n<line23>double mem = physmem_total () * n / 100;\n<line24>/* Use "<", not "<=", to avoid problems with rounding.  */\n<line25>if (mem < UINTMAX_MAX)\n<line26>{\n<line27>n = mem;\n<line28>e = LONGINT_OK;\n<line29>}\n<line30>else\n<line31>e = LONGINT_OVERFLOW;\n<line32>}\n<line33>break;\n<line34>}\n<line35>if (e == LONGINT_OK)\n<line36>{\n<line37>/* If multiple sort sizes are specified, take the maximum, so\n<line38>that option order does not matter.  */\n<line39>if (n < sort_size)\n<line40>return;\n<line41>sort_size = n;\n<line42>if (sort_size == n)\n<line43>{\n<line44>sort_size = MAX (sort_size, MIN_SORT_SIZE);\n<line45>return;\n<line46>}\n<line47>e = LONGINT_OVERFLOW;\n<line48>}\n<line49>xstrtol_fatal (e, oi, c, long_options, s);\n<line50>}
----------------------------------------
Function: specify_nthreads
Content: <line0>static size_t\n<line1>specify_nthreads (int oi, char c, char const *s)\n<line2>{\n<line3>uintmax_t nthreads;\n<line4>enum strtol_error e = xstrtoumax (s, nullptr, 10, &nthreads, "");\n<line5>if (e == LONGINT_OVERFLOW)\n<line6>return SIZE_MAX;\n<line7>if (e != LONGINT_OK)\n<line8>xstrtol_fatal (e, oi, c, long_options, s);\n<line9>if (SIZE_MAX < nthreads)\n<line10>nthreads = SIZE_MAX;\n<line11>if (nthreads == 0)\n<line12>error (SORT_FAILURE, 0, _("number in parallel must be nonzero"));\n<line13>return nthreads;\n<line14>}
----------------------------------------
Function: default_sort_size
Content: <line0>static size_t\n<line1>default_sort_size (void)\n<line2>{\n<line3>/* Let SIZE be MEM, but no more than the maximum object size,\n<line4>total memory, or system resource limits.  Don't bother to check\n<line5>for values like RLIM_INFINITY since in practice they are not much\n<line6>less than SIZE_MAX.  */\n<line7>size_t size = SIZE_MAX;\n<line8>struct rlimit rlimit;\n<line9>if (getrlimit (RLIMIT_DATA, &rlimit) == 0 && rlimit.rlim_cur < size)\n<line10>size = rlimit.rlim_cur;\n<line11>#ifdef RLIMIT_AS\n<line12>if (getrlimit (RLIMIT_AS, &rlimit) == 0 && rlimit.rlim_cur < size)\n<line13>size = rlimit.rlim_cur;\n<line14>#endif\n<line15>/* Leave a large safety margin for the above limits, as failure can\n<line16>occur when they are exceeded.  */\n<line17>size /= 2;\n<line18>#ifdef RLIMIT_RSS\n<line19>/* Leave a 1/16 margin for RSS to leave room for code, stack, etc.\n<line20>Exceeding RSS is not fatal, but can be quite slow.  */\n<line21>if (getrlimit (RLIMIT_RSS, &rlimit) == 0 && rlimit.rlim_cur / 16 * 15 < size)\n<line22>size = rlimit.rlim_cur / 16 * 15;\n<line23>#endif\n<line24>/* Let MEM be available memory or 1/8 of total memory, whichever\n<line25>is greater.  */\n<line26>double avail = physmem_available ();\n<line27>double total = physmem_total ();\n<line28>double mem = MAX (avail, total / 8);\n<line29>/* Leave a 1/4 margin for physical memory.  */\n<line30>if (total * 0.75 < size)\n<line31>size = total * 0.75;\n<line32>/* Return the minimum of MEM and SIZE, but no less than\n<line33>MIN_SORT_SIZE.  Avoid the MIN macro here, as it is not quite\n<line34>right when only one argument is floating point.  */\n<line35>if (mem < size)\n<line36>size = mem;\n<line37>return MAX (size, MIN_SORT_SIZE);\n<line38>}
----------------------------------------
Function: sort_buffer_size
Content: <line0>static size_t\n<line1>sort_buffer_size (FILE *const *fps, size_t nfps,\n<line2>char *const *files, size_t nfiles,\n<line3>size_t line_bytes)\n<line4>{\n<line5>/* A bound on the input size.  If zero, the bound hasn't been\n<line6>determined yet.  */\n<line7>static size_t size_bound;\n<line8>/* In the worst case, each input byte is a newline.  */\n<line9>size_t worst_case_per_input_byte = line_bytes + 1;\n<line10>/* Keep enough room for one extra input line and an extra byte.\n<line11>This extra room might be needed when preparing to read EOF.  */\n<line12>size_t size = worst_case_per_input_byte + 1;\n<line13>for (size_t i = 0; i < nfiles; i++)\n<line14>{\n<line15>struct stat st;\n<line16>off_t file_size;\n<line17>size_t worst_case;\n<line18>if ((i < nfps ? fstat (fileno (fps[i]), &st)\n<line19>: STREQ (files[i], "-") ? fstat (STDIN_FILENO, &st)\n<line20>: stat (files[i], &st))\n<line21>!= 0)\n<line22>sort_die (_("stat failed"), files[i]);\n<line23>if (S_ISREG (st.st_mode))\n<line24>file_size = st.st_size;\n<line25>else\n<line26>{\n<line27>/* The file has unknown size.  If the user specified a sort\n<line28>buffer size, use that; otherwise, guess the size.  */\n<line29>if (sort_size)\n<line30>return sort_size;\n<line31>file_size = INPUT_FILE_SIZE_GUESS;\n<line32>}\n<line33>if (! size_bound)\n<line34>{\n<line35>size_bound = sort_size;\n<line36>if (! size_bound)\n<line37>size_bound = default_sort_size ();\n<line38>}\n<line39>/* Add the amount of memory needed to represent the worst case\n<line40>where the input consists entirely of newlines followed by a\n<line41>single non-newline.  Check for overflow.  */\n<line42>worst_case = file_size * worst_case_per_input_byte + 1;\n<line43>if (file_size != worst_case / worst_case_per_input_byte\n<line44>|| size_bound - size <= worst_case)\n<line45>return size_bound;\n<line46>size += worst_case;\n<line47>}\n<line48>return size;\n<line49>}
----------------------------------------
Function: initbuf
Content: <line0>static void\n<line1>initbuf (struct buffer *buf, size_t line_bytes, size_t alloc)\n<line2>{\n<line3>/* Ensure that the line array is properly aligned.  If the desired\n<line4>size cannot be allocated, repeatedly halve it until allocation\n<line5>succeeds.  The smaller allocation may hurt overall performance,\n<line6>but that's better than failing.  */\n<line7>while (true)\n<line8>{\n<line9>alloc += sizeof (struct line) - alloc % sizeof (struct line);\n<line10>buf->buf = malloc (alloc);\n<line11>if (buf->buf)\n<line12>break;\n<line13>alloc /= 2;\n<line14>if (alloc <= line_bytes + 1)\n<line15>xalloc_die ();\n<line16>}\n<line17>buf->line_bytes = line_bytes;\n<line18>buf->alloc = alloc;\n<line19>buf->used = buf->left = buf->nlines = 0;\n<line20>buf->eof = false;\n<line21>}
----------------------------------------
Function: buffer_linelim
Content: <line0>static inline struct line *\n<line1>buffer_linelim (struct buffer const *buf)\n<line2>{\n<line3>void *linelim = buf->buf + buf->alloc;\n<line4>return linelim;\n<line5>}
----------------------------------------
Function: begfield
Content: <line0>static char *\n<line1>begfield (struct line const *line, struct keyfield const *key)\n<line2>{\n<line3>char *ptr = line->text, *lim = ptr + line->length - 1;\n<line4>size_t sword = key->sword;\n<line5>size_t schar = key->schar;\n<line6>/* The leading field separator itself is included in a field when -t\n<line7>is absent.  */\n<line8>if (tab != TAB_DEFAULT)\n<line9>while (ptr < lim && sword--)\n<line10>{\n<line11>while (ptr < lim && *ptr != tab)\n<line12>++ptr;\n<line13>if (ptr < lim)\n<line14>++ptr;\n<line15>}\n<line16>else\n<line17>while (ptr < lim && sword--)\n<line18>{\n<line19>while (ptr < lim && blanks[to_uchar (*ptr)])\n<line20>++ptr;\n<line21>while (ptr < lim && !blanks[to_uchar (*ptr)])\n<line22>++ptr;\n<line23>}\n<line24>/* If we're ignoring leading blanks when computing the Start\n<line25>of the field, skip past them here.  */\n<line26>if (key->skipsblanks)\n<line27>while (ptr < lim && blanks[to_uchar (*ptr)])\n<line28>++ptr;\n<line29>/* Advance PTR by SCHAR (if possible), but no further than LIM.  */\n<line30>ptr = MIN (lim, ptr + schar);\n<line31>return ptr;\n<line32>}
----------------------------------------
Function: fillbuf
Content: <line0>static bool\n<line1>fillbuf (struct buffer *buf, FILE *fp, char const *file)\n<line2>{\n<line3>struct keyfield const *key = keylist;\n<line4>char eol = eolchar;\n<line5>size_t line_bytes = buf->line_bytes;\n<line6>size_t mergesize = merge_buffer_size - MIN_MERGE_BUFFER_SIZE;\n<line7>if (buf->eof)\n<line8>return false;\n<line9>if (buf->used != buf->left)\n<line10>{\n<line11>memmove (buf->buf, buf->buf + buf->used - buf->left, buf->left);\n<line12>buf->used = buf->left;\n<line13>buf->nlines = 0;\n<line14>}\n<line15>while (true)\n<line16>{\n<line17>char *ptr = buf->buf + buf->used;\n<line18>struct line *linelim = buffer_linelim (buf);\n<line19>struct line *line = linelim - buf->nlines;\n<line20>size_t avail = (char *) linelim - buf->nlines * line_bytes - ptr;\n<line21>char *line_start = buf->nlines ? line->text + line->length : buf->buf;\n<line22>while (line_bytes + 1 < avail)\n<line23>{\n<line24>/* Read as many bytes as possible, but do not read so many\n<line25>bytes that there might not be enough room for the\n<line26>corresponding line array.  The worst case is when the\n<line27>rest of the input file consists entirely of newlines,\n<line28>except that the last byte is not a newline.  */\n<line29>size_t readsize = (avail - 1) / (line_bytes + 1);\n<line30>size_t bytes_read = fread (ptr, 1, readsize, fp);\n<line31>char *ptrlim = ptr + bytes_read;\n<line32>char *p;\n<line33>avail -= bytes_read;\n<line34>if (bytes_read != readsize)\n<line35>{\n<line36>if (ferror (fp))\n<line37>sort_die (_("read failed"), file);\n<line38>if (feof (fp))\n<line39>{\n<line40>buf->eof = true;\n<line41>if (buf->buf == ptrlim)\n<line42>return false;\n<line43>if (line_start != ptrlim && ptrlim[-1] != eol)\n<line44>*ptrlim++ = eol;\n<line45>}\n<line46>}\n<line47>/* Find and record each line in the just-read input.  */\n<line48>while ((p = memchr (ptr, eol, ptrlim - ptr)))\n<line49>{\n<line50>/* Delimit the line with NUL. This eliminates the need to\n<line51>temporarily replace the last byte with NUL when calling\n<line52>xmemcoll, which increases performance.  */\n<line53>*p = '\0';\n<line54>ptr = p + 1;\n<line55>line--;\n<line56>line->text = line_start;\n<line57>line->length = ptr - line_start;\n<line58>mergesize = MAX (mergesize, line->length);\n<line59>avail -= line_bytes;\n<line60>if (key)\n<line61>{\n<line62>/* Precompute the position of the first key for\n<line63>efficiency.  */\n<line64>line->keylim = (key->eword == SIZE_MAX\n<line65>? p\n<line66>: limfield (line, key));\n<line67>if (key->sword != SIZE_MAX)\n<line68>line->keybeg = begfield (line, key);\n<line69>else\n<line70>{\n<line71>if (key->skipsblanks)\n<line72>while (blanks[to_uchar (*line_start)])\n<line73>line_start++;\n<line74>line->keybeg = line_start;\n<line75>}\n<line76>}\n<line77>line_start = ptr;\n<line78>}\n<line79>ptr = ptrlim;\n<line80>if (buf->eof)\n<line81>break;\n<line82>}\n<line83>buf->used = ptr - buf->buf;\n<line84>buf->nlines = buffer_linelim (buf) - line;\n<line85>if (buf->nlines != 0)\n<line86>{\n<line87>buf->left = ptr - line_start;\n<line88>merge_buffer_size = mergesize + MIN_MERGE_BUFFER_SIZE;\n<line89>return true;\n<line90>}\n<line91>{\n<line92>/* The current input line is too long to fit in the buffer.\n<line93>Increase the buffer size and try again, keeping it properly\n<line94>aligned.  */\n<line95>size_t line_alloc = buf->alloc / sizeof (struct line);\n<line96>buf->buf = x2nrealloc (buf->buf, &line_alloc, sizeof (struct line));\n<line97>buf->alloc = line_alloc * sizeof (struct line);\n<line98>}\n<line99>}\n<line100>}
----------------------------------------
Function: traverse_raw_number
Content: <line0>static char\n<line1>traverse_raw_number (char const **number)\n<line2>{\n<line3>char const *p = *number;\n<line4>char ch;\n<line5>char max_digit = '\0';\n<line6>bool ends_with_thousands_sep = false;\n<line7>/* Scan to end of number.\n<line8>Decimals or separators not followed by digits stop the scan.\n<line9>Numbers ending in decimals or separators are thus considered\n<line10>to be lacking in units.\n<line11>FIXME: add support for multibyte thousands_sep and decimal_point.  */\n<line12>while (ISDIGIT (ch = *p++))\n<line13>{\n<line14>if (max_digit < ch)\n<line15>max_digit = ch;\n<line16>/* Allow to skip only one occurrence of thousands_sep to avoid finding\n<line17>the unit in the next column in case thousands_sep matches as blank\n<line18>and is used as column delimiter.  */\n<line19>ends_with_thousands_sep = (*p == thousands_sep);\n<line20>if (ends_with_thousands_sep)\n<line21>++p;\n<line22>}\n<line23>if (ends_with_thousands_sep)\n<line24>{\n<line25>/* thousands_sep not followed by digit is not allowed.  */\n<line26>*number = p - 2;\n<line27>return max_digit;\n<line28>}\n<line29>if (ch == decimal_point)\n<line30>while (ISDIGIT (ch = *p++))\n<line31>if (max_digit < ch)\n<line32>max_digit = ch;\n<line33>*number = p - 1;\n<line34>return max_digit;\n<line35>}
----------------------------------------
Function: nan_compare
Content: <line0>static int\n<line1>nan_compare (long double a, long double b)\n<line2>{\n<line3>char buf[2][sizeof "-nan""()" + CHAR_BIT * sizeof a];\n<line4>snprintf (buf[0], sizeof buf[0], "%Lf", a);\n<line5>snprintf (buf[1], sizeof buf[1], "%Lf", b);\n<line6>return strcmp (buf[0], buf[1]);\n<line7>}
----------------------------------------
Function: general_numcompare
Content: <line0>static int\n<line1>general_numcompare (char const *sa, char const *sb)\n<line2>{\n<line3>/* FIXME: maybe add option to try expensive FP conversion\n<line4>only if A and B can't be compared more cheaply/accurately.  */\n<line5>char *ea;\n<line6>char *eb;\n<line7>long double a = strtold (sa, &ea);\n<line8>long double b = strtold (sb, &eb);\n<line9>/* Put conversion errors at the start of the collating sequence.  */\n<line10>if (sa == ea)\n<line11>return sb == eb ? 0 : -1;\n<line12>if (sb == eb)\n<line13>return 1;\n<line14>/* Sort numbers in the usual way, where -0 == +0.  Put NaNs after\n<line15>conversion errors but before numbers; sort them by internal\n<line16>bit-pattern, for lack of a more portable alternative.  */\n<line17>return (a < b ? -1\n<line18>: a > b ? 1\n<line19>: a == b ? 0\n<line20>: b == b ? -1\n<line21>: a == a ? 1\n<line22>: nan_compare (a, b));\n<line23>}
----------------------------------------
Function: getmonth
Content: <line0>static int\n<line1>getmonth (char const *month, char **ea)\n<line2>{\n<line3>size_t lo = 0;\n<line4>size_t hi = MONTHS_PER_YEAR;\n<line5>while (blanks[to_uchar (*month)])\n<line6>month++;\n<line7>do\n<line8>{\n<line9>size_t ix = (lo + hi) / 2;\n<line10>char const *m = month;\n<line11>char const *n = monthtab[ix].name;\n<line12>for (;; m++, n++)\n<line13>{\n<line14>if (!*n)\n<line15>{\n<line16>if (ea)\n<line17>*ea = (char *) m;\n<line18>return monthtab[ix].val;\n<line19>}\n<line20>if (to_uchar (fold_toupper[to_uchar (*m)]) < to_uchar (*n))\n<line21>{\n<line22>hi = ix;\n<line23>break;\n<line24>}\n<line25>else if (to_uchar (fold_toupper[to_uchar (*m)]) > to_uchar (*n))\n<line26>{\n<line27>lo = ix + 1;\n<line28>break;\n<line29>}\n<line30>}\n<line31>}\n<line32>while (lo < hi);\n<line33>return 0;\n<line34>}
----------------------------------------
Function: random_md5_state_init
Content: <line0>static void\n<line1>random_md5_state_init (char const *random_source)\n<line2>{\n<line3>unsigned char buf[MD5_DIGEST_SIZE];\n<line4>struct randread_source *r = randread_new (random_source, sizeof buf);\n<line5>if (! r)\n<line6>sort_die (_("open failed"), random_source ? random_source : "getrandom");\n<line7>randread (r, buf, sizeof buf);\n<line8>if (randread_free (r) != 0)\n<line9>sort_die (_("close failed"), random_source);\n<line10>md5_init_ctx (&random_md5_state);\n<line11>md5_process_bytes (buf, sizeof buf, &random_md5_state);\n<line12>}
----------------------------------------
Function: xstrxfrm
Content: <line0>static size_t\n<line1>xstrxfrm (char *restrict dest, char const *restrict src, size_t destsize)\n<line2>{\n<line3>errno = 0;\n<line4>size_t translated_size = strxfrm (dest, src, destsize);\n<line5>if (errno)\n<line6>{\n<line7>error (0, errno, _("string transformation failed"));\n<line8>error (0, 0, _("set LC_ALL='C' to work around the problem"));\n<line9>error (SORT_FAILURE, 0,\n<line10>_("the original string was %s"),\n<line11>quotearg_n_style (0, locale_quoting_style, src));\n<line12>}\n<line13>return translated_size;\n<line14>}
----------------------------------------
Function: compare_random
Content: <line0>static int\n<line1>compare_random (char *restrict texta, size_t lena,\n<line2>char *restrict textb, size_t lenb)\n<line3>{\n<line4>/* XFRM_DIFF records the equivalent of memcmp on the transformed\n<line5>data.  This is used to break ties if there is a checksum\n<line6>collision, and this is good enough given the astronomically low\n<line7>probability of a collision.  */\n<line8>int xfrm_diff = 0;\n<line9>char stackbuf[4000];\n<line10>char *buf = stackbuf;\n<line11>size_t bufsize = sizeof stackbuf;\n<line12>void *allocated = nullptr;\n<line13>uint32_t dig[2][MD5_DIGEST_SIZE / sizeof (uint32_t)];\n<line14>struct md5_ctx s[2];\n<line15>s[0] = s[1] = random_md5_state;\n<line16>if (hard_LC_COLLATE)\n<line17>{\n<line18>char const *lima = texta + lena;\n<line19>char const *limb = textb + lenb;\n<line20>while (true)\n<line21>{\n<line22>/* Transform the text into the basis of comparison, so that byte\n<line23>strings that would otherwise considered to be equal are\n<line24>considered equal here even if their bytes differ.\n<line25>Each time through this loop, transform one\n<line26>null-terminated string's worth from TEXTA or from TEXTB\n<line27>or both.  That way, there's no need to store the\n<line28>transformation of the whole line, if it contains many\n<line29>null-terminated strings.  */\n<line30>/* Store the transformed data into a big-enough buffer.  */\n<line31>/* A 3X size guess avoids the overhead of calling strxfrm\n<line32>twice on typical implementations.  Don't worry about\n<line33>size_t overflow, as the guess need not be correct.  */\n<line34>size_t guess_bufsize = 3 * (lena + lenb) + 2;\n<line35>if (bufsize < guess_bufsize)\n<line36>{\n<line37>bufsize = MAX (guess_bufsize, bufsize * 3 / 2);\n<line38>free (allocated);\n<line39>buf = allocated = malloc (bufsize);\n<line40>if (! buf)\n<line41>{\n<line42>buf = stackbuf;\n<line43>bufsize = sizeof stackbuf;\n<line44>}\n<line45>}\n<line46>size_t sizea =\n<line47>(texta < lima ? xstrxfrm (buf, texta, bufsize) + 1 : 0);\n<line48>bool a_fits = sizea <= bufsize;\n<line49>size_t sizeb =\n<line50>(textb < limb\n<line51>? (xstrxfrm ((a_fits ? buf + sizea : nullptr), textb,\n<line52>(a_fits ? bufsize - sizea : 0))\n<line53>+ 1)\n<line54>: 0);\n<line55>if (! (a_fits && sizea + sizeb <= bufsize))\n<line56>{\n<line57>bufsize = sizea + sizeb;\n<line58>if (bufsize < SIZE_MAX / 3)\n<line59>bufsize = bufsize * 3 / 2;\n<line60>free (allocated);\n<line61>buf = allocated = xmalloc (bufsize);\n<line62>if (texta < lima)\n<line63>strxfrm (buf, texta, sizea);\n<line64>if (textb < limb)\n<line65>strxfrm (buf + sizea, textb, sizeb);\n<line66>}\n<line67>/* Advance past NULs to the next part of each input string,\n<line68>exiting the loop if both strings are exhausted.  When\n<line69>exiting the loop, prepare to finish off the tiebreaker\n<line70>comparison properly.  */\n<line71>if (texta < lima)\n<line72>texta += strlen (texta) + 1;\n<line73>if (textb < limb)\n<line74>textb += strlen (textb) + 1;\n<line75>if (! (texta < lima || textb < limb))\n<line76>{\n<line77>lena = sizea; texta = buf;\n<line78>lenb = sizeb; textb = buf + sizea;\n<line79>break;\n<line80>}\n<line81>/* Accumulate the transformed data in the corresponding\n<line82>checksums.  */\n<line83>md5_process_bytes (buf, sizea, &s[0]);\n<line84>md5_process_bytes (buf + sizea, sizeb, &s[1]);\n<line85>/* Update the tiebreaker comparison of the transformed data.  */\n<line86>if (! xfrm_diff)\n<line87>{\n<line88>xfrm_diff = memcmp (buf, buf + sizea, MIN (sizea, sizeb));\n<line89>if (! xfrm_diff)\n<line90>xfrm_diff = (sizea > sizeb) - (sizea < sizeb);\n<line91>}\n<line92>}\n<line93>}\n<line94>/* Compute and compare the checksums.  */\n<line95>md5_process_bytes (texta, lena, &s[0]); md5_finish_ctx (&s[0], dig[0]);\n<line96>md5_process_bytes (textb, lenb, &s[1]); md5_finish_ctx (&s[1], dig[1]);\n<line97>int diff = memcmp (dig[0], dig[1], sizeof dig[0]);\n<line98>/* Fall back on the tiebreaker if the checksums collide.  */\n<line99>if (! diff)\n<line100>{\n<line101>if (! xfrm_diff)\n<line102>{\n<line103>xfrm_diff = memcmp (texta, textb, MIN (lena, lenb));\n<line104>if (! xfrm_diff)\n<line105>xfrm_diff = (lena > lenb) - (lena < lenb);\n<line106>}\n<line107>diff = xfrm_diff;\n<line108>}\n<line109>free (allocated);\n<line110>return diff;\n<line111>}
----------------------------------------
Function: debug_width
Content: <line0>static size_t\n<line1>debug_width (char const *text, char const *lim)\n<line2>{\n<line3>size_t width = mbsnwidth (text, lim - text, 0);\n<line4>while (text < lim)\n<line5>width += (*text++ == '\t');\n<line6>return width;\n<line7>}
----------------------------------------
Function: mark_key
Content: <line0>static void\n<line1>mark_key (size_t offset, size_t width)\n<line2>{\n<line3>while (offset--)\n<line4>putchar (' ');\n<line5>if (!width)\n<line6>printf (_("^ no match for key\n"));\n<line7>else\n<line8>{\n<line9>do\n<line10>putchar ('_');\n<line11>while (--width);\n<line12>putchar ('\n');\n<line13>}\n<line14>}
----------------------------------------
Function: key_numeric
Content: <line0>static inline bool\n<line1>key_numeric (struct keyfield const *key)\n<line2>{\n<line3>return key->numeric || key->general_numeric || key->human_numeric;\n<line4>}
----------------------------------------
Function: debug_key
Content: <line0>static void\n<line1>debug_key (struct line const *line, struct keyfield const *key)\n<line2>{\n<line3>char *text = line->text;\n<line4>char *beg = text;\n<line5>char *lim = text + line->length - 1;\n<line6>if (key)\n<line7>{\n<line8>if (key->sword != SIZE_MAX)\n<line9>beg = begfield (line, key);\n<line10>if (key->eword != SIZE_MAX)\n<line11>lim = limfield (line, key);\n<line12>if ((key->skipsblanks && key->sword == SIZE_MAX)\n<line13>|| key->month || key_numeric (key))\n<line14>{\n<line15>char saved = *lim;\n<line16>*lim = '\0';\n<line17>while (blanks[to_uchar (*beg)])\n<line18>beg++;\n<line19>char *tighter_lim = beg;\n<line20>if (lim < beg)\n<line21>tighter_lim = lim;\n<line22>else if (key->month)\n<line23>getmonth (beg, &tighter_lim);\n<line24>else if (key->general_numeric)\n<line25>ignore_value (strtold (beg, &tighter_lim));\n<line26>else if (key->numeric || key->human_numeric)\n<line27>{\n<line28>char const *p = beg + (beg < lim && *beg == '-');\n<line29>char max_digit = traverse_raw_number (&p);\n<line30>if ('0' <= max_digit)\n<line31>{\n<line32>unsigned char ch = *p;\n<line33>tighter_lim = (char *) p\n<line34>+ (key->human_numeric && unit_order[ch]);\n<line35>}\n<line36>}\n<line37>else\n<line38>tighter_lim = lim;\n<line39>*lim = saved;\n<line40>lim = tighter_lim;\n<line41>}\n<line42>}\n<line43>size_t offset = debug_width (text, beg);\n<line44>size_t width = debug_width (beg, lim);\n<line45>mark_key (offset, width);\n<line46>}
----------------------------------------
Function: debug_line
Content: <line0>static void\n<line1>debug_line (struct line const *line)\n<line2>{\n<line3>struct keyfield const *key = keylist;\n<line4>do\n<line5>debug_key (line, key);\n<line6>while (key && ((key = key->next) || ! (unique || stable)));\n<line7>}
----------------------------------------
Function: default_key_compare
Content: <line0>static bool\n<line1>default_key_compare (struct keyfield const *key)\n<line2>{\n<line3>return ! (key->ignore\n<line4>|| key->translate\n<line5>|| key->skipsblanks\n<line6>|| key->skipeblanks\n<line7>|| key_numeric (key)\n<line8>|| key->month\n<line9>|| key->version\n<line10>|| key->random\n<line11>/* || key->reverse */\n<line12>);\n<line13>}
----------------------------------------
Function: key_to_opts
Content: <line0>static void\n<line1>key_to_opts (struct keyfield const *key, char *opts)\n<line2>{\n<line3>if (key->skipsblanks || key->skipeblanks)\n<line4>*opts++ = 'b';/* either disables global -b  */\n<line5>if (key->ignore == nondictionary)\n<line6>*opts++ = 'd';\n<line7>if (key->translate)\n<line8>*opts++ = 'f';\n<line9>if (key->general_numeric)\n<line10>*opts++ = 'g';\n<line11>if (key->human_numeric)\n<line12>*opts++ = 'h';\n<line13>if (key->ignore == nonprinting)\n<line14>*opts++ = 'i';\n<line15>if (key->month)\n<line16>*opts++ = 'M';\n<line17>if (key->numeric)\n<line18>*opts++ = 'n';\n<line19>if (key->random)\n<line20>*opts++ = 'R';\n<line21>if (key->reverse)\n<line22>*opts++ = 'r';\n<line23>if (key->version)\n<line24>*opts++ = 'V';\n<line25>*opts = '\0';\n<line26>}
----------------------------------------
Function: key_warnings
Content: <line0>static void\n<line1>key_warnings (struct keyfield const *gkey, bool gkey_only)\n<line2>{\n<line3>struct keyfield const *key;\n<line4>struct keyfield ugkey = *gkey;\n<line5>unsigned long keynum = 1;\n<line6>bool basic_numeric_field = false;\n<line7>bool general_numeric_field = false;\n<line8>bool basic_numeric_field_span = false;\n<line9>bool general_numeric_field_span = false;\n<line10>for (key = keylist; key; key = key->next, keynum++)\n<line11>{\n<line12>if (key_numeric (key))\n<line13>{\n<line14>if (key->general_numeric)\n<line15>general_numeric_field = true;\n<line16>else\n<line17>basic_numeric_field = true;\n<line18>}\n<line19>if (key->traditional_used)\n<line20>{\n<line21>size_t sword = key->sword;\n<line22>size_t eword = key->eword;\n<line23>char tmp[INT_BUFSIZE_BOUND (uintmax_t)];\n<line24>/* obsolescent syntax +A.x -B.y is equivalent to:\n<line25>-k A+1.x+1,B.y   (when y = 0)\n<line26>-k A+1.x+1,B+1.y (when y > 0)  */\n<line27>char obuf[INT_BUFSIZE_BOUND (sword) * 2 + 4]; /* +# -#  */\n<line28>char nbuf[INT_BUFSIZE_BOUND (sword) * 2 + 5]; /* -k #,#  */\n<line29>char *po = obuf;\n<line30>char *pn = nbuf;\n<line31>if (sword == SIZE_MAX)\n<line32>sword++;\n<line33>po = stpcpy (stpcpy (po, "+"), umaxtostr (sword, tmp));\n<line34>pn = stpcpy (stpcpy (pn, "-k "), umaxtostr (sword + 1, tmp));\n<line35>if (key->eword != SIZE_MAX)\n<line36>{\n<line37>stpcpy (stpcpy (po, " -"), umaxtostr (eword + 1, tmp));\n<line38>stpcpy (stpcpy (pn, ","),\n<line39>umaxtostr (eword + 1\n<line40>+ (key->echar == SIZE_MAX), tmp));\n<line41>}\n<line42>error (0, 0, _("obsolescent key %s used; consider %s instead"),\n<line43>quote_n (0, obuf), quote_n (1, nbuf));\n<line44>}\n<line45>/* Warn about field specs that will never match.  */\n<line46>bool zero_width = key->sword != SIZE_MAX && key->eword < key->sword;\n<line47>if (zero_width)\n<line48>error (0, 0, _("key %lu has zero width and will be ignored"), keynum);\n<line49>/* Warn about significant leading blanks.  */\n<line50>bool implicit_skip = key_numeric (key) || key->month;\n<line51>bool line_offset = key->eword == 0 && key->echar != 0; /* -k1.x,1.y  */\n<line52>if (!zero_width && !gkey_only && tab == TAB_DEFAULT && !line_offset\n<line53>&& ((!key->skipsblanks && !implicit_skip)\n<line54>|| (!key->skipsblanks && key->schar)\n<line55>|| (!key->skipeblanks && key->echar)))\n<line56>error (0, 0, _("leading blanks are significant in key %lu; "\n<line57>"consider also specifying 'b'"), keynum);\n<line58>/* Warn about numeric comparisons spanning fields,\n<line59>as field delimiters could be interpreted as part\n<line60>of the number (maybe only in other locales).  */\n<line61>if (!gkey_only && key_numeric (key))\n<line62>{\n<line63>size_t sword = key->sword + 1;\n<line64>size_t eword = key->eword + 1;\n<line65>if (!sword)\n<line66>sword++;\n<line67>if (!eword || sword < eword)\n<line68>{\n<line69>error (0, 0, _("key %lu is numeric and spans multiple fields"),\n<line70>keynum);\n<line71>if (key->general_numeric)\n<line72>general_numeric_field_span = true;\n<line73>else\n<line74>basic_numeric_field_span = true;\n<line75>}\n<line76>}\n<line77>/* Flag global options not copied or specified in any key.  */\n<line78>if (ugkey.ignore && (ugkey.ignore == key->ignore))\n<line79>ugkey.ignore = nullptr;\n<line80>if (ugkey.translate && (ugkey.translate == key->translate))\n<line81>ugkey.translate = nullptr;\n<line82>ugkey.skipsblanks &= !key->skipsblanks;\n<line83>ugkey.skipeblanks &= !key->skipeblanks;\n<line84>ugkey.month &= !key->month;\n<line85>ugkey.numeric &= !key->numeric;\n<line86>ugkey.general_numeric &= !key->general_numeric;\n<line87>ugkey.human_numeric &= !key->human_numeric;\n<line88>ugkey.random &= !key->random;\n<line89>ugkey.version &= !key->version;\n<line90>ugkey.reverse &= !key->reverse;\n<line91>}\n<line92>/* Explicitly warn if field delimiters in this locale\n<line93>don't constrain numbers.  */\n<line94>bool number_locale_warned = false;\n<line95>if (basic_numeric_field_span)\n<line96>{\n<line97>if (tab == TAB_DEFAULT\n<line98>? thousands_sep != NON_CHAR && (isblank (to_uchar (thousands_sep)))\n<line99>: tab == thousands_sep)\n<line100>{\n<line101>error (0, 0,\n<line102>_("field separator %s is treated as a "\n<line103>"group separator in numbers"),\n<line104>quote (((char []) {thousands_sep, 0})));\n<line105>number_locale_warned = true;\n<line106>}\n<line107>}\n<line108>if (basic_numeric_field_span || general_numeric_field_span)\n<line109>{\n<line110>if (tab == TAB_DEFAULT\n<line111>? thousands_sep != NON_CHAR && (isblank (to_uchar (decimal_point)))\n<line112>: tab == decimal_point)\n<line113>{\n<line114>error (0, 0,\n<line115>_("field separator %s is treated as a "\n<line116>"decimal point in numbers"),\n<line117>quote (((char []) {decimal_point, 0})));\n<line118>number_locale_warned = true;\n<line119>}\n<line120>else if (tab == '-')\n<line121>{\n<line122>error (0, 0,\n<line123>_("field separator %s is treated as a "\n<line124>"minus sign in numbers"),\n<line125>quote (((char []) {tab, 0})));\n<line126>}\n<line127>else if (general_numeric_field_span && tab == '+')\n<line128>{\n<line129>error (0, 0,\n<line130>_("field separator %s is treated as a "\n<line131>"plus sign in numbers"),\n<line132>quote (((char []) {tab, 0})));\n<line133>}\n<line134>}\n<line135>/* Explicitly indicate the decimal point used in this locale,\n<line136>as it suggests that robust scripts need to consider\n<line137>setting the locale when comparing numbers.  */\n<line138>if ((basic_numeric_field || general_numeric_field) && ! number_locale_warned)\n<line139>{\n<line140>error (0, 0,\n<line141>_("%snumbers use %s as a decimal point in this locale"),\n<line142>tab == decimal_point ? "" : _("note "),\n<line143>quote (((char []) {decimal_point, 0})));\n<line144>}\n<line145>if (basic_numeric_field && thousands_sep_ignored)\n<line146>{\n<line147>error (0, 0,\n<line148>_("the multi-byte number group separator "\n<line149>"in this locale is not supported"));\n<line150>}\n<line151>/* Warn about ignored global options flagged above.\n<line152>This clears all flags if UGKEY is the only one in the list.  */\n<line153>if (!default_key_compare (&ugkey)\n<line154>|| (ugkey.reverse && (stable || unique) && keylist))\n<line155>{\n<line156>bool ugkey_reverse = ugkey.reverse;\n<line157>if (!(stable || unique))\n<line158>ugkey.reverse = false;\n<line159>/* The following is too big, but guaranteed to be "big enough".  */\n<line160>char opts[sizeof short_options];\n<line161>key_to_opts (&ugkey, opts);\n<line162>error (0, 0,\n<line163>ngettext ("option '-%s' is ignored",\n<line164>"options '-%s' are ignored",\n<line165>select_plural (strlen (opts))), opts);\n<line166>ugkey.reverse = ugkey_reverse;\n<line167>}\n<line168>if (ugkey.reverse && !(stable || unique) && keylist)\n<line169>error (0, 0, _("option '-r' only applies to last-resort comparison"));\n<line170>}
----------------------------------------
Function: diff_reversed
Content: <line0>static int\n<line1>diff_reversed (int diff, bool reversed)\n<line2>{\n<line3>return reversed ? (diff < 0) - (diff > 0) : diff;\n<line4>}
----------------------------------------
Function: keycompare
Content: <line0>static int\n<line1>keycompare (struct line const *a, struct line const *b)\n<line2>{\n<line3>struct keyfield *key = keylist;\n<line4>/* For the first iteration only, the key positions have been\n<line5>precomputed for us. */\n<line6>char *texta = a->keybeg;\n<line7>char *textb = b->keybeg;\n<line8>char *lima = a->keylim;\n<line9>char *limb = b->keylim;\n<line10>int diff;\n<line11>while (true)\n<line12>{\n<line13>char const *translate = key->translate;\n<line14>bool const *ignore = key->ignore;\n<line15>/* Treat field ends before field starts as empty fields.  */\n<line16>lima = MAX (texta, lima);\n<line17>limb = MAX (textb, limb);\n<line18>/* Find the lengths. */\n<line19>size_t lena = lima - texta;\n<line20>size_t lenb = limb - textb;\n<line21>if (hard_LC_COLLATE || key_numeric (key)\n<line22>|| key->month || key->random || key->version)\n<line23>{\n<line24>/* Ordinarily use the keys in-place, temporarily null-terminated.  */\n<line25>char *ta = texta;\n<line26>char *tb = textb;\n<line27>size_t tlena = lena;\n<line28>size_t tlenb = lenb;\n<line29>char enda = ta[tlena];\n<line30>char endb = tb[tlenb];\n<line31>void *allocated = nullptr;\n<line32>char stackbuf[4000];\n<line33>if (ignore || translate)\n<line34>{\n<line35>/* Compute with copies of the keys, which are the result of\n<line36>translating or ignoring characters, and which need their\n<line37>own storage.  */\n<line38>size_t i;\n<line39>/* Allocate space for copies.  */\n<line40>size_t size = lena + 1 + lenb + 1;\n<line41>if (size <= sizeof stackbuf)\n<line42>ta = stackbuf;\n<line43>else\n<line44>ta = allocated = xmalloc (size);\n<line45>tb = ta + lena + 1;\n<line46>/* Put into each copy a version of the key in which the\n<line47>requested characters are ignored or translated.  */\n<line48>for (tlena = i = 0; i < lena; i++)\n<line49>if (! (ignore && ignore[to_uchar (texta[i])]))\n<line50>ta[tlena++] = (translate\n<line51>? translate[to_uchar (texta[i])]\n<line52>: texta[i]);\n<line53>for (tlenb = i = 0; i < lenb; i++)\n<line54>if (! (ignore && ignore[to_uchar (textb[i])]))\n<line55>tb[tlenb++] = (translate\n<line56>? translate[to_uchar (textb[i])]\n<line57>: textb[i]);\n<line58>}\n<line59>ta[tlena] = '\0';\n<line60>tb[tlenb] = '\0';\n<line61>if (key->numeric)\n<line62>diff = numcompare (ta, tb);\n<line63>else if (key->general_numeric)\n<line64>diff = general_numcompare (ta, tb);\n<line65>else if (key->human_numeric)\n<line66>diff = human_numcompare (ta, tb);\n<line67>else if (key->month)\n<line68>diff = getmonth (ta, nullptr) - getmonth (tb, nullptr);\n<line69>else if (key->random)\n<line70>diff = compare_random (ta, tlena, tb, tlenb);\n<line71>else if (key->version)\n<line72>diff = filenvercmp (ta, tlena, tb, tlenb);\n<line73>else\n<line74>{\n<line75>/* Locale-dependent string sorting.  This is slower than\n<line76>C-locale sorting, which is implemented below.  */\n<line77>if (tlena == 0)\n<line78>diff = - NONZERO (tlenb);\n<line79>else if (tlenb == 0)\n<line80>diff = 1;\n<line81>else\n<line82>diff = xmemcoll0 (ta, tlena + 1, tb, tlenb + 1);\n<line83>}\n<line84>ta[tlena] = enda;\n<line85>tb[tlenb] = endb;\n<line86>free (allocated);\n<line87>}\n<line88>else if (ignore)\n<line89>{\n<line90>#define CMP_WITH_IGNORE(A, B)						\\n<line91>do									\\n<line92>{									\\n<line93>while (true)							\\n<line94>{								\\n<line95>while (texta < lima && ignore[to_uchar (*texta)])		\\n<line96>++texta;						\\n<line97>while (textb < limb && ignore[to_uchar (*textb)])		\\n<line98>++textb;						\\n<line99>if (! (texta < lima && textb < limb))			\\n<line100>{							\\n<line101>diff = (texta < lima) - (textb < limb);		\\n<line102>break;						\\n<line103>}							\\n<line104>diff = to_uchar (A) - to_uchar (B);			\\n<line105>if (diff)							\\n<line106>break;							\\n<line107>++texta;							\\n<line108>++textb;							\\n<line109>}								\\n<line110>\\n<line111>}									\\n<line112>while (0)\n<line113>if (translate)\n<line114>CMP_WITH_IGNORE (translate[to_uchar (*texta)],\n<line115>translate[to_uchar (*textb)]);\n<line116>else\n<line117>CMP_WITH_IGNORE (*texta, *textb);\n<line118>}\n<line119>else\n<line120>{\n<line121>size_t lenmin = MIN (lena, lenb);\n<line122>if (lenmin == 0)\n<line123>diff = 0;\n<line124>else if (translate)\n<line125>{\n<line126>size_t i = 0;\n<line127>do\n<line128>{\n<line129>diff = (to_uchar (translate[to_uchar (texta[i])])\n<line130>- to_uchar (translate[to_uchar (textb[i])]));\n<line131>if (diff)\n<line132>break;\n<line133>i++;\n<line134>}\n<line135>while (i < lenmin);\n<line136>}\n<line137>else\n<line138>diff = memcmp (texta, textb, lenmin);\n<line139>if (! diff)\n<line140>diff = (lena > lenb) - (lena < lenb);\n<line141>}\n<line142>if (diff)\n<line143>break;\n<line144>key = key->next;\n<line145>if (! key)\n<line146>return 0;\n<line147>/* Find the beginning and limit of the next field.  */\n<line148>if (key->eword != SIZE_MAX)\n<line149>lima = limfield (a, key), limb = limfield (b, key);\n<line150>else\n<line151>lima = a->text + a->length - 1, limb = b->text + b->length - 1;\n<line152>if (key->sword != SIZE_MAX)\n<line153>texta = begfield (a, key), textb = begfield (b, key);\n<line154>else\n<line155>{\n<line156>texta = a->text, textb = b->text;\n<line157>if (key->skipsblanks)\n<line158>{\n<line159>while (texta < lima && blanks[to_uchar (*texta)])\n<line160>++texta;\n<line161>while (textb < limb && blanks[to_uchar (*textb)])\n<line162>++textb;\n<line163>}\n<line164>}\n<line165>}\n<line166>return diff_reversed (diff, key->reverse);\n<line167>}
----------------------------------------
Function: compare
Content: <line0>static int\n<line1>compare (struct line const *a, struct line const *b)\n<line2>{\n<line3>int diff;\n<line4>size_t alen, blen;\n<line5>/* First try to compare on the specified keys (if any).\n<line6>The only two cases with no key at all are unadorned sort,\n<line7>and unadorned sort -r. */\n<line8>if (keylist)\n<line9>{\n<line10>diff = keycompare (a, b);\n<line11>if (diff || unique || stable)\n<line12>return diff;\n<line13>}\n<line14>/* If the keys all compare equal (or no keys were specified)\n<line15>fall through to the default comparison.  */\n<line16>alen = a->length - 1, blen = b->length - 1;\n<line17>if (alen == 0)\n<line18>diff = - NONZERO (blen);\n<line19>else if (blen == 0)\n<line20>diff = 1;\n<line21>else if (hard_LC_COLLATE)\n<line22>{\n<line23>/* xmemcoll0 is a performance enhancement as\n<line24>it will not unconditionally write '\0' after the\n<line25>passed in buffers, which was seen to give around\n<line26>a 3% increase in performance for short lines.  */\n<line27>diff = xmemcoll0 (a->text, alen + 1, b->text, blen + 1);\n<line28>}\n<line29>else\n<line30>{\n<line31>diff = memcmp (a->text, b->text, MIN (alen, blen));\n<line32>if (!diff)\n<line33>diff = (alen > blen) - (alen < blen);\n<line34>}\n<line35>return diff_reversed (diff, reverse);\n<line36>}
----------------------------------------
Function: write_line
Content: <line0>static void\n<line1>write_line (struct line const *line, FILE *fp, char const *output_file)\n<line2>{\n<line3>char *buf = line->text;\n<line4>size_t n_bytes = line->length;\n<line5>char *ebuf = buf + n_bytes;\n<line6>if (!output_file && debug)\n<line7>{\n<line8>/* Convert TAB to '>' and EOL to \n, and then output debugging info.  */\n<line9>char const *c = buf;\n<line10>while (c < ebuf)\n<line11>{\n<line12>char wc = *c++;\n<line13>if (wc == '\t')\n<line14>wc = '>';\n<line15>else if (c == ebuf)\n<line16>wc = '\n';\n<line17>if (fputc (wc, fp) == EOF)\n<line18>sort_die (_("write failed"), output_file);\n<line19>}\n<line20>debug_line (line);\n<line21>}\n<line22>else\n<line23>{\n<line24>ebuf[-1] = eolchar;\n<line25>if (fwrite (buf, 1, n_bytes, fp) != n_bytes)\n<line26>sort_die (_("write failed"), output_file);\n<line27>ebuf[-1] = '\0';\n<line28>}\n<line29>}
----------------------------------------
Function: check
Content: <line0>static bool\n<line1>check (char const *file_name, char checkonly)\n<line2>{\n<line3>FILE *fp = xfopen (file_name, "r");\n<line4>struct buffer buf;		/* Input buffer. */\n<line5>struct line temp;		/* Copy of previous line. */\n<line6>size_t alloc = 0;\n<line7>uintmax_t line_number = 0;\n<line8>struct keyfield const *key = keylist;\n<line9>bool nonunique = ! unique;\n<line10>bool ordered = true;\n<line11>initbuf (&buf, sizeof (struct line),\n<line12>MAX (merge_buffer_size, sort_size));\n<line13>temp.text = nullptr;\n<line14>while (fillbuf (&buf, fp, file_name))\n<line15>{\n<line16>struct line const *line = buffer_linelim (&buf);\n<line17>struct line const *linebase = line - buf.nlines;\n<line18>/* Make sure the line saved from the old buffer contents is\n<line19>less than or equal to the first line of the new buffer. */\n<line20>if (alloc && nonunique <= compare (&temp, line - 1))\n<line21>{\n<line22>found_disorder:\n<line23>{\n<line24>if (checkonly == 'c')\n<line25>{\n<line26>struct line const *disorder_line = line - 1;\n<line27>uintmax_t disorder_line_number =\n<line28>buffer_linelim (&buf) - disorder_line + line_number;\n<line29>char hr_buf[INT_BUFSIZE_BOUND (disorder_line_number)];\n<line30>fprintf (stderr, _("%s: %s:%s: disorder: "),\n<line31>program_name, file_name,\n<line32>umaxtostr (disorder_line_number, hr_buf));\n<line33>write_line (disorder_line, stderr, _("standard error"));\n<line34>}\n<line35>ordered = false;\n<line36>break;\n<line37>}\n<line38>}\n<line39>/* Compare each line in the buffer with its successor.  */\n<line40>while (linebase < --line)\n<line41>if (nonunique <= compare (line, line - 1))\n<line42>goto found_disorder;\n<line43>line_number += buf.nlines;\n<line44>/* Save the last line of the buffer.  */\n<line45>if (alloc < line->length)\n<line46>{\n<line47>do\n<line48>{\n<line49>alloc *= 2;\n<line50>if (! alloc)\n<line51>{\n<line52>alloc = line->length;\n<line53>break;\n<line54>}\n<line55>}\n<line56>while (alloc < line->length);\n<line57>free (temp.text);\n<line58>temp.text = xmalloc (alloc);\n<line59>}\n<line60>memcpy (temp.text, line->text, line->length);\n<line61>temp.length = line->length;\n<line62>if (key)\n<line63>{\n<line64>temp.keybeg = temp.text + (line->keybeg - line->text);\n<line65>temp.keylim = temp.text + (line->keylim - line->text);\n<line66>}\n<line67>}\n<line68>xfclose (fp, file_name);\n<line69>free (buf.buf);\n<line70>free (temp.text);\n<line71>return ordered;\n<line72>}
----------------------------------------
Function: open_input_files
Content: <line0>static size_t\n<line1>open_input_files (struct sortfile *files, size_t nfiles, FILE ***pfps)\n<line2>{\n<line3>FILE **fps = *pfps = xnmalloc (nfiles, sizeof *fps);\n<line4>int i;\n<line5>/* Open as many input files as we can.  */\n<line6>for (i = 0; i < nfiles; i++)\n<line7>{\n<line8>fps[i] = (files[i].temp && files[i].temp->state != UNCOMPRESSED\n<line9>? open_temp (files[i].temp)\n<line10>: stream_open (files[i].name, "r"));\n<line11>if (!fps[i])\n<line12>break;\n<line13>}\n<line14>return i;\n<line15>}
----------------------------------------
Function: mergefps
Content: <line0>static void\n<line1>mergefps (struct sortfile *files, size_t ntemps, size_t nfiles,\n<line2>FILE *ofp, char const *output_file, FILE **fps)\n<line3>{\n<line4>struct buffer *buffer = xnmalloc (nfiles, sizeof *buffer);\n<line5>/* Input buffers for each file. */\n<line6>struct line saved;		/* Saved line storage for unique check. */\n<line7>struct line const *savedline = nullptr;\n<line8>/* &saved if there is a saved line. */\n<line9>size_t savealloc = 0;		/* Size allocated for the saved line. */\n<line10>struct line const **cur = xnmalloc (nfiles, sizeof *cur);\n<line11>/* Current line in each line table. */\n<line12>struct line const **base = xnmalloc (nfiles, sizeof *base);\n<line13>/* Base of each line table.  */\n<line14>size_t *ord = xnmalloc (nfiles, sizeof *ord);\n<line15>/* Table representing a permutation of fps,\n<line16>such that cur[ord[0]] is the smallest line\n<line17>and will be next output. */\n<line18>size_t i;\n<line19>size_t j;\n<line20>size_t t;\n<line21>struct keyfield const *key = keylist;\n<line22>saved.text = nullptr;\n<line23>/* Read initial lines from each input file. */\n<line24>for (i = 0; i < nfiles; )\n<line25>{\n<line26>initbuf (&buffer[i], sizeof (struct line),\n<line27>MAX (merge_buffer_size, sort_size / nfiles));\n<line28>if (fillbuf (&buffer[i], fps[i], files[i].name))\n<line29>{\n<line30>struct line const *linelim = buffer_linelim (&buffer[i]);\n<line31>cur[i] = linelim - 1;\n<line32>base[i] = linelim - buffer[i].nlines;\n<line33>i++;\n<line34>}\n<line35>else\n<line36>{\n<line37>/* fps[i] is empty; eliminate it from future consideration.  */\n<line38>xfclose (fps[i], files[i].name);\n<line39>if (i < ntemps)\n<line40>{\n<line41>ntemps--;\n<line42>zaptemp (files[i].name);\n<line43>}\n<line44>free (buffer[i].buf);\n<line45>--nfiles;\n<line46>for (j = i; j < nfiles; ++j)\n<line47>{\n<line48>files[j] = files[j + 1];\n<line49>fps[j] = fps[j + 1];\n<line50>}\n<line51>}\n<line52>}\n<line53>/* Set up the ord table according to comparisons among input lines.\n<line54>Since this only reorders two items if one is strictly greater than\n<line55>the other, it is stable. */\n<line56>for (i = 0; i < nfiles; ++i)\n<line57>ord[i] = i;\n<line58>for (i = 1; i < nfiles; ++i)\n<line59>if (0 < compare (cur[ord[i - 1]], cur[ord[i]]))\n<line60>t = ord[i - 1], ord[i - 1] = ord[i], ord[i] = t, i = 0;\n<line61>/* Repeatedly output the smallest line until no input remains. */\n<line62>while (nfiles)\n<line63>{\n<line64>struct line const *smallest = cur[ord[0]];\n<line65>/* If uniquified output is turned on, output only the first of\n<line66>an identical series of lines. */\n<line67>if (unique)\n<line68>{\n<line69>if (savedline && compare (savedline, smallest))\n<line70>{\n<line71>savedline = nullptr;\n<line72>write_line (&saved, ofp, output_file);\n<line73>}\n<line74>if (!savedline)\n<line75>{\n<line76>savedline = &saved;\n<line77>if (savealloc < smallest->length)\n<line78>{\n<line79>do\n<line80>if (! savealloc)\n<line81>{\n<line82>savealloc = smallest->length;\n<line83>break;\n<line84>}\n<line85>while ((savealloc *= 2) < smallest->length);\n<line86>free (saved.text);\n<line87>saved.text = xmalloc (savealloc);\n<line88>}\n<line89>saved.length = smallest->length;\n<line90>memcpy (saved.text, smallest->text, saved.length);\n<line91>if (key)\n<line92>{\n<line93>saved.keybeg =\n<line94>saved.text + (smallest->keybeg - smallest->text);\n<line95>saved.keylim =\n<line96>saved.text + (smallest->keylim - smallest->text);\n<line97>}\n<line98>}\n<line99>}\n<line100>else\n<line101>write_line (smallest, ofp, output_file);\n<line102>/* Check if we need to read more lines into memory. */\n<line103>if (base[ord[0]] < smallest)\n<line104>cur[ord[0]] = smallest - 1;\n<line105>else\n<line106>{\n<line107>if (fillbuf (&buffer[ord[0]], fps[ord[0]], files[ord[0]].name))\n<line108>{\n<line109>struct line const *linelim = buffer_linelim (&buffer[ord[0]]);\n<line110>cur[ord[0]] = linelim - 1;\n<line111>base[ord[0]] = linelim - buffer[ord[0]].nlines;\n<line112>}\n<line113>else\n<line114>{\n<line115>/* We reached EOF on fps[ord[0]].  */\n<line116>for (i = 1; i < nfiles; ++i)\n<line117>if (ord[i] > ord[0])\n<line118>--ord[i];\n<line119>--nfiles;\n<line120>xfclose (fps[ord[0]], files[ord[0]].name);\n<line121>if (ord[0] < ntemps)\n<line122>{\n<line123>ntemps--;\n<line124>zaptemp (files[ord[0]].name);\n<line125>}\n<line126>free (buffer[ord[0]].buf);\n<line127>for (i = ord[0]; i < nfiles; ++i)\n<line128>{\n<line129>fps[i] = fps[i + 1];\n<line130>files[i] = files[i + 1];\n<line131>buffer[i] = buffer[i + 1];\n<line132>cur[i] = cur[i + 1];\n<line133>base[i] = base[i + 1];\n<line134>}\n<line135>for (i = 0; i < nfiles; ++i)\n<line136>ord[i] = ord[i + 1];\n<line137>continue;\n<line138>}\n<line139>}\n<line140>/* The new line just read in may be larger than other lines\n<line141>already in main memory; push it back in the queue until we\n<line142>encounter a line larger than it.  Optimize for the common\n<line143>case where the new line is smallest.  */\n<line144>{\n<line145>size_t lo = 1;\n<line146>size_t hi = nfiles;\n<line147>size_t probe = lo;\n<line148>size_t ord0 = ord[0];\n<line149>size_t count_of_smaller_lines;\n<line150>while (lo < hi)\n<line151>{\n<line152>int cmp = compare (cur[ord0], cur[ord[probe]]);\n<line153>if (cmp < 0 || (cmp == 0 && ord0 < ord[probe]))\n<line154>hi = probe;\n<line155>else\n<line156>lo = probe + 1;\n<line157>probe = (lo + hi) / 2;\n<line158>}\n<line159>count_of_smaller_lines = lo - 1;\n<line160>for (j = 0; j < count_of_smaller_lines; j++)\n<line161>ord[j] = ord[j + 1];\n<line162>ord[count_of_smaller_lines] = ord0;\n<line163>}\n<line164>}\n<line165>if (unique && savedline)\n<line166>{\n<line167>write_line (&saved, ofp, output_file);\n<line168>free (saved.text);\n<line169>}\n<line170>xfclose (ofp, output_file);\n<line171>free (fps);\n<line172>free (buffer);\n<line173>free (ord);\n<line174>free (base);\n<line175>free (cur);\n<line176>}
----------------------------------------
Function: mergefiles
Content: <line0>static size_t\n<line1>mergefiles (struct sortfile *files, size_t ntemps, size_t nfiles,\n<line2>FILE *ofp, char const *output_file)\n<line3>{\n<line4>FILE **fps;\n<line5>size_t nopened = open_input_files (files, nfiles, &fps);\n<line6>if (nopened < nfiles && nopened < 2)\n<line7>sort_die (_("open failed"), files[nopened].name);\n<line8>mergefps (files, ntemps, nopened, ofp, output_file, fps);\n<line9>return nopened;\n<line10>}
----------------------------------------
Function: mergelines
Content: <line0>static void\n<line1>mergelines (struct line *restrict t, size_t nlines,\n<line2>struct line const *restrict lo)\n<line3>{\n<line4>size_t nlo = nlines / 2;\n<line5>size_t nhi = nlines - nlo;\n<line6>struct line *hi = t - nlo;\n<line7>while (true)\n<line8>if (compare (lo - 1, hi - 1) <= 0)\n<line9>{\n<line10>*--t = *--lo;\n<line11>if (! --nlo)\n<line12>{\n<line13>/* HI must equal T now, and there is no need to copy from\n<line14>HI to T. */\n<line15>return;\n<line16>}\n<line17>}\n<line18>else\n<line19>{\n<line20>*--t = *--hi;\n<line21>if (! --nhi)\n<line22>{\n<line23>do\n<line24>*--t = *--lo;\n<line25>while (--nlo);\n<line26>return;\n<line27>}\n<line28>}\n<line29>}
----------------------------------------
Function: sequential_sort
Content: <line0>static void\n<line1>sequential_sort (struct line *restrict lines, size_t nlines,\n<line2>struct line *restrict temp, bool to_temp)\n<line3>{\n<line4>if (nlines == 2)\n<line5>{\n<line6>/* Declare 'swap' as int, not bool, to work around a bug\n<line7><https://lists.gnu.org/r/bug-coreutils/2005-10/msg00086.html>\n<line8>in the IBM xlc 6.0.0.0 compiler in 64-bit mode.  */\n<line9>int swap = (0 < compare (&lines[-1], &lines[-2]));\n<line10>if (to_temp)\n<line11>{\n<line12>temp[-1] = lines[-1 - swap];\n<line13>temp[-2] = lines[-2 + swap];\n<line14>}\n<line15>else if (swap)\n<line16>{\n<line17>temp[-1] = lines[-1];\n<line18>lines[-1] = lines[-2];\n<line19>lines[-2] = temp[-1];\n<line20>}\n<line21>}\n<line22>else\n<line23>{\n<line24>size_t nlo = nlines / 2;\n<line25>size_t nhi = nlines - nlo;\n<line26>struct line *lo = lines;\n<line27>struct line *hi = lines - nlo;\n<line28>sequential_sort (hi, nhi, temp - (to_temp ? nlo : 0), to_temp);\n<line29>if (1 < nlo)\n<line30>sequential_sort (lo, nlo, temp, !to_temp);\n<line31>else if (!to_temp)\n<line32>temp[-1] = lo[-1];\n<line33>struct line *dest;\n<line34>struct line const *sorted_lo;\n<line35>if (to_temp)\n<line36>{\n<line37>dest = temp;\n<line38>sorted_lo = lines;\n<line39>}\n<line40>else\n<line41>{\n<line42>dest = lines;\n<line43>sorted_lo = temp;\n<line44>}\n<line45>mergelines (dest, nlines, sorted_lo);\n<line46>}\n<line47>}
----------------------------------------
Function: merge_tree_init
Content: <line0>static struct merge_node *\n<line1>merge_tree_init (size_t nthreads, size_t nlines, struct line *dest)\n<line2>{\n<line3>struct merge_node *merge_tree = xmalloc (2 * sizeof *merge_tree * nthreads);\n<line4>struct merge_node *root = merge_tree;\n<line5>root->lo = root->hi = root->end_lo = root->end_hi = nullptr;\n<line6>root->dest = nullptr;\n<line7>root->nlo = root->nhi = nlines;\n<line8>root->parent = nullptr;\n<line9>root->level = MERGE_END;\n<line10>root->queued = false;\n<line11>pthread_mutex_init (&root->lock, nullptr);\n<line12>init_node (root, root + 1, dest, nthreads, nlines, false);\n<line13>return merge_tree;\n<line14>}
----------------------------------------
Function: merge_tree_destroy
Content: <line0>static void\n<line1>merge_tree_destroy (size_t nthreads, struct merge_node *merge_tree)\n<line2>{\n<line3>size_t n_nodes = nthreads * 2;\n<line4>struct merge_node *node = merge_tree;\n<line5>while (n_nodes--)\n<line6>{\n<line7>pthread_mutex_destroy (&node->lock);\n<line8>node++;\n<line9>}\n<line10>free (merge_tree);\n<line11>}
----------------------------------------
Function: init_node
Content: <line0>static struct merge_node *\n<line1>init_node (struct merge_node *restrict parent,\n<line2>struct merge_node *restrict node_pool,\n<line3>struct line *dest, size_t nthreads,\n<line4>size_t total_lines, bool is_lo_child)\n<line5>{\n<line6>size_t nlines = (is_lo_child ? parent->nlo : parent->nhi);\n<line7>size_t nlo = nlines / 2;\n<line8>size_t nhi = nlines - nlo;\n<line9>struct line *lo = dest - total_lines;\n<line10>struct line *hi = lo - nlo;\n<line11>struct line **parent_end = (is_lo_child ? &parent->end_lo : &parent->end_hi);\n<line12>struct merge_node *node = node_pool++;\n<line13>node->lo = node->end_lo = lo;\n<line14>node->hi = node->end_hi = hi;\n<line15>node->dest = parent_end;\n<line16>node->nlo = nlo;\n<line17>node->nhi = nhi;\n<line18>node->parent = parent;\n<line19>node->level = parent->level + 1;\n<line20>node->queued = false;\n<line21>pthread_mutex_init (&node->lock, nullptr);\n<line22>if (nthreads > 1)\n<line23>{\n<line24>size_t lo_threads = nthreads / 2;\n<line25>size_t hi_threads = nthreads - lo_threads;\n<line26>node->lo_child = node_pool;\n<line27>node_pool = init_node (node, node_pool, lo, lo_threads,\n<line28>total_lines, true);\n<line29>node->hi_child = node_pool;\n<line30>node_pool = init_node (node, node_pool, hi, hi_threads,\n<line31>total_lines, false);\n<line32>}\n<line33>else\n<line34>{\n<line35>node->lo_child = nullptr;\n<line36>node->hi_child = nullptr;\n<line37>}\n<line38>return node_pool;\n<line39>}
----------------------------------------
Function: compare_nodes
Content: <line0>static int\n<line1>compare_nodes (void const *a, void const *b)\n<line2>{\n<line3>struct merge_node const *nodea = a;\n<line4>struct merge_node const *nodeb = b;\n<line5>if (nodea->level == nodeb->level)\n<line6>return (nodea->nlo + nodea->nhi) < (nodeb->nlo + nodeb->nhi);\n<line7>return nodea->level < nodeb->level;\n<line8>}
----------------------------------------
Function: lock_node
Content: <line0>static inline void\n<line1>lock_node (struct merge_node *node)\n<line2>{\n<line3>pthread_mutex_lock (&node->lock);\n<line4>}
----------------------------------------
Function: unlock_node
Content: <line0>static inline void\n<line1>unlock_node (struct merge_node *node)\n<line2>{\n<line3>pthread_mutex_unlock (&node->lock);\n<line4>}
----------------------------------------
Function: queue_destroy
Content: <line0>static void\n<line1>queue_destroy (struct merge_node_queue *queue)\n<line2>{\n<line3>heap_free (queue->priority_queue);\n<line4>pthread_cond_destroy (&queue->cond);\n<line5>pthread_mutex_destroy (&queue->mutex);\n<line6>}
----------------------------------------
Function: queue_init
Content: <line0>static void\n<line1>queue_init (struct merge_node_queue *queue, size_t nthreads)\n<line2>{\n<line3>/* Though it's highly unlikely all nodes are in the heap at the same\n<line4>time, the heap should accommodate all of them.  Counting a null\n<line5>dummy head for the heap, reserve 2 * NTHREADS nodes.  */\n<line6>queue->priority_queue = heap_alloc (compare_nodes, 2 * nthreads);\n<line7>pthread_mutex_init (&queue->mutex, nullptr);\n<line8>pthread_cond_init (&queue->cond, nullptr);\n<line9>}
----------------------------------------
Function: queue_insert
Content: <line0>static void\n<line1>queue_insert (struct merge_node_queue *queue, struct merge_node *node)\n<line2>{\n<line3>pthread_mutex_lock (&queue->mutex);\n<line4>heap_insert (queue->priority_queue, node);\n<line5>node->queued = true;\n<line6>pthread_cond_signal (&queue->cond);\n<line7>pthread_mutex_unlock (&queue->mutex);\n<line8>}
----------------------------------------
Function: queue_pop
Content: <line0>static struct merge_node *\n<line1>queue_pop (struct merge_node_queue *queue)\n<line2>{\n<line3>struct merge_node *node;\n<line4>pthread_mutex_lock (&queue->mutex);\n<line5>while (! (node = heap_remove_top (queue->priority_queue)))\n<line6>pthread_cond_wait (&queue->cond, &queue->mutex);\n<line7>pthread_mutex_unlock (&queue->mutex);\n<line8>lock_node (node);\n<line9>node->queued = false;\n<line10>return node;\n<line11>}
----------------------------------------
Function: write_unique
Content: <line0>static void\n<line1>write_unique (struct line const *line, FILE *tfp, char const *temp_output)\n<line2>{\n<line3>if (unique)\n<line4>{\n<line5>if (saved_line.text && ! compare (line, &saved_line))\n<line6>return;\n<line7>saved_line = *line;\n<line8>}\n<line9>write_line (line, tfp, temp_output);\n<line10>}
----------------------------------------
Function: mergelines_node
Content: <line0>static void\n<line1>mergelines_node (struct merge_node *restrict node, size_t total_lines,\n<line2>FILE *tfp, char const *temp_output)\n<line3>{\n<line4>struct line *lo_orig = node->lo;\n<line5>struct line *hi_orig = node->hi;\n<line6>size_t to_merge = MAX_MERGE (total_lines, node->level);\n<line7>size_t merged_lo;\n<line8>size_t merged_hi;\n<line9>if (node->level > MERGE_ROOT)\n<line10>{\n<line11>/* Merge to destination buffer. */\n<line12>struct line *dest = *node->dest;\n<line13>while (node->lo != node->end_lo && node->hi != node->end_hi && to_merge--)\n<line14>if (compare (node->lo - 1, node->hi - 1) <= 0)\n<line15>*--dest = *--node->lo;\n<line16>else\n<line17>*--dest = *--node->hi;\n<line18>merged_lo = lo_orig - node->lo;\n<line19>merged_hi = hi_orig - node->hi;\n<line20>if (node->nhi == merged_hi)\n<line21>while (node->lo != node->end_lo && to_merge--)\n<line22>*--dest = *--node->lo;\n<line23>else if (node->nlo == merged_lo)\n<line24>while (node->hi != node->end_hi && to_merge--)\n<line25>*--dest = *--node->hi;\n<line26>*node->dest = dest;\n<line27>}\n<line28>else\n<line29>{\n<line30>/* Merge directly to output. */\n<line31>while (node->lo != node->end_lo && node->hi != node->end_hi && to_merge--)\n<line32>{\n<line33>if (compare (node->lo - 1, node->hi - 1) <= 0)\n<line34>write_unique (--node->lo, tfp, temp_output);\n<line35>else\n<line36>write_unique (--node->hi, tfp, temp_output);\n<line37>}\n<line38>merged_lo = lo_orig - node->lo;\n<line39>merged_hi = hi_orig - node->hi;\n<line40>if (node->nhi == merged_hi)\n<line41>{\n<line42>while (node->lo != node->end_lo && to_merge--)\n<line43>write_unique (--node->lo, tfp, temp_output);\n<line44>}\n<line45>else if (node->nlo == merged_lo)\n<line46>{\n<line47>while (node->hi != node->end_hi && to_merge--)\n<line48>write_unique (--node->hi, tfp, temp_output);\n<line49>}\n<line50>}\n<line51>/* Update NODE. */\n<line52>merged_lo = lo_orig - node->lo;\n<line53>merged_hi = hi_orig - node->hi;\n<line54>node->nlo -= merged_lo;\n<line55>node->nhi -= merged_hi;\n<line56>}
----------------------------------------
Function: queue_check_insert
Content: <line0>static void\n<line1>queue_check_insert (struct merge_node_queue *queue, struct merge_node *node)\n<line2>{\n<line3>if (! node->queued)\n<line4>{\n<line5>bool lo_avail = (node->lo - node->end_lo) != 0;\n<line6>bool hi_avail = (node->hi - node->end_hi) != 0;\n<line7>if (lo_avail ? hi_avail || ! node->nhi : hi_avail && ! node->nlo)\n<line8>queue_insert (queue, node);\n<line9>}\n<line10>}
----------------------------------------
Function: queue_check_insert_parent
Content: <line0>static void\n<line1>queue_check_insert_parent (struct merge_node_queue *queue,\n<line2>struct merge_node *node)\n<line3>{\n<line4>if (node->level > MERGE_ROOT)\n<line5>{\n<line6>lock_node (node->parent);\n<line7>queue_check_insert (queue, node->parent);\n<line8>unlock_node (node->parent);\n<line9>}\n<line10>else if (node->nlo + node->nhi == 0)\n<line11>{\n<line12>/* If the MERGE_ROOT NODE has finished merging, insert the\n<line13>MERGE_END node.  */\n<line14>queue_insert (queue, node->parent);\n<line15>}\n<line16>}
----------------------------------------
Function: merge_loop
Content: <line0>static void\n<line1>merge_loop (struct merge_node_queue *queue,\n<line2>size_t total_lines, FILE *tfp, char const *temp_output)\n<line3>{\n<line4>while (true)\n<line5>{\n<line6>struct merge_node *node = queue_pop (queue);\n<line7>if (node->level == MERGE_END)\n<line8>{\n<line9>unlock_node (node);\n<line10>/* Reinsert so other threads can pop it. */\n<line11>queue_insert (queue, node);\n<line12>break;\n<line13>}\n<line14>mergelines_node (node, total_lines, tfp, temp_output);\n<line15>queue_check_insert (queue, node);\n<line16>queue_check_insert_parent (queue, node);\n<line17>unlock_node (node);\n<line18>}\n<line19>}
----------------------------------------
Function: sortlines_thread
Content: <line0>static void *\n<line1>sortlines_thread (void *data)\n<line2>{\n<line3>struct thread_args const *args = data;\n<line4>sortlines (args->lines, args->nthreads, args->total_lines,\n<line5>args->node, args->queue, args->tfp,\n<line6>args->output_temp);\n<line7>return nullptr;\n<line8>}
----------------------------------------
Function: sortlines
Content: <line0>static void\n<line1>sortlines (struct line *restrict lines, size_t nthreads,\n<line2>size_t total_lines, struct merge_node *node,\n<line3>struct merge_node_queue *queue, FILE *tfp, char const *temp_output)\n<line4>{\n<line5>size_t nlines = node->nlo + node->nhi;\n<line6>/* Calculate thread arguments. */\n<line7>size_t lo_threads = nthreads / 2;\n<line8>size_t hi_threads = nthreads - lo_threads;\n<line9>pthread_t thread;\n<line10>struct thread_args args = {lines, lo_threads, total_lines,\n<line11>node->lo_child, queue, tfp, temp_output};\n<line12>if (nthreads > 1 && SUBTHREAD_LINES_HEURISTIC <= nlines\n<line13>&& pthread_create (&thread, nullptr, sortlines_thread, &args) == 0)\n<line14>{\n<line15>sortlines (lines - node->nlo, hi_threads, total_lines,\n<line16>node->hi_child, queue, tfp, temp_output);\n<line17>pthread_join (thread, nullptr);\n<line18>}\n<line19>else\n<line20>{\n<line21>/* Nthreads = 1, this is a leaf NODE, or pthread_create failed.\n<line22>Sort with 1 thread. */\n<line23>size_t nlo = node->nlo;\n<line24>size_t nhi = node->nhi;\n<line25>struct line *temp = lines - total_lines;\n<line26>if (1 < nhi)\n<line27>sequential_sort (lines - nlo, nhi, temp - nlo / 2, false);\n<line28>if (1 < nlo)\n<line29>sequential_sort (lines, nlo, temp, false);\n<line30>/* Update merge NODE. No need to lock yet. */\n<line31>node->lo = lines;\n<line32>node->hi = lines - nlo;\n<line33>node->end_lo = lines - nlo;\n<line34>node->end_hi = lines - nlo - nhi;\n<line35>queue_insert (queue, node);\n<line36>merge_loop (queue, total_lines, tfp, temp_output);\n<line37>}\n<line38>}
----------------------------------------
Function: avoid_trashing_input
Content: <line0>static void\n<line1>avoid_trashing_input (struct sortfile *files, size_t ntemps,\n<line2>size_t nfiles, char const *outfile)\n<line3>{\n<line4>struct tempnode *tempcopy = nullptr;\n<line5>for (size_t i = ntemps; i < nfiles; i++)\n<line6>{\n<line7>bool is_stdin = STREQ (files[i].name, "-");\n<line8>bool same;\n<line9>struct stat instat;\n<line10>if (outfile && STREQ (outfile, files[i].name) && !is_stdin)\n<line11>same = true;\n<line12>else\n<line13>{\n<line14>struct stat *outst = get_outstatus ();\n<line15>if (!outst)\n<line16>break;\n<line17>same = (((is_stdin\n<line18>? fstat (STDIN_FILENO, &instat)\n<line19>: stat (files[i].name, &instat))\n<line20>== 0)\n<line21>&& SAME_INODE (instat, *outst));\n<line22>}\n<line23>if (same)\n<line24>{\n<line25>if (! tempcopy)\n<line26>{\n<line27>FILE *tftp;\n<line28>tempcopy = create_temp (&tftp);\n<line29>mergefiles (&files[i], 0, 1, tftp, tempcopy->name);\n<line30>}\n<line31>files[i].name = tempcopy->name;\n<line32>files[i].temp = tempcopy;\n<line33>}\n<line34>}\n<line35>}
----------------------------------------
Function: check_inputs
Content: <line0>static void\n<line1>check_inputs (char *const *files, size_t nfiles)\n<line2>{\n<line3>for (size_t i = 0; i < nfiles; i++)\n<line4>{\n<line5>if (STREQ (files[i], "-"))\n<line6>continue;\n<line7>if (euidaccess (files[i], R_OK) != 0)\n<line8>sort_die (_("cannot read"), files[i]);\n<line9>}\n<line10>}
----------------------------------------
Function: check_output
Content: <line0>static void\n<line1>check_output (char const *outfile)\n<line2>{\n<line3>if (outfile)\n<line4>{\n<line5>int oflags = O_WRONLY | O_BINARY | O_CLOEXEC | O_CREAT;\n<line6>int outfd = open (outfile, oflags, MODE_RW_UGO);\n<line7>if (outfd < 0)\n<line8>sort_die (_("open failed"), outfile);\n<line9>move_fd (outfd, STDOUT_FILENO);\n<line10>}\n<line11>}
----------------------------------------
Function: merge
Content: <line0>static void\n<line1>merge (struct sortfile *files, size_t ntemps, size_t nfiles,\n<line2>char const *output_file)\n<line3>{\n<line4>while (nmerge < nfiles)\n<line5>{\n<line6>/* Number of input files processed so far.  */\n<line7>size_t in;\n<line8>/* Number of output files generated so far.  */\n<line9>size_t out;\n<line10>/* nfiles % NMERGE; this counts input files that are left over\n<line11>after all full-sized merges have been done.  */\n<line12>size_t remainder;\n<line13>/* Number of easily-available slots at the next loop iteration.  */\n<line14>size_t cheap_slots;\n<line15>/* Do as many NMERGE-size merges as possible. In the case that\n<line16>nmerge is bogus, increment by the maximum number of file\n<line17>descriptors allowed.  */\n<line18>for (out = in = 0; nmerge <= nfiles - in; out++)\n<line19>{\n<line20>FILE *tfp;\n<line21>struct tempnode *temp = create_temp (&tfp);\n<line22>size_t num_merged = mergefiles (&files[in], MIN (ntemps, nmerge),\n<line23>nmerge, tfp, temp->name);\n<line24>ntemps -= MIN (ntemps, num_merged);\n<line25>files[out].name = temp->name;\n<line26>files[out].temp = temp;\n<line27>in += num_merged;\n<line28>}\n<line29>remainder = nfiles - in;\n<line30>cheap_slots = nmerge - out % nmerge;\n<line31>if (cheap_slots < remainder)\n<line32>{\n<line33>/* So many files remain that they can't all be put into the last\n<line34>NMERGE-sized output window.  Do one more merge.  Merge as few\n<line35>files as possible, to avoid needless I/O.  */\n<line36>size_t nshortmerge = remainder - cheap_slots + 1;\n<line37>FILE *tfp;\n<line38>struct tempnode *temp = create_temp (&tfp);\n<line39>size_t num_merged = mergefiles (&files[in], MIN (ntemps, nshortmerge),\n<line40>nshortmerge, tfp, temp->name);\n<line41>ntemps -= MIN (ntemps, num_merged);\n<line42>files[out].name = temp->name;\n<line43>files[out++].temp = temp;\n<line44>in += num_merged;\n<line45>}\n<line46>/* Put the remaining input files into the last NMERGE-sized output\n<line47>window, so they will be merged in the next pass.  */\n<line48>memmove (&files[out], &files[in], (nfiles - in) * sizeof *files);\n<line49>ntemps += out;\n<line50>nfiles -= in - out;\n<line51>}\n<line52>avoid_trashing_input (files, ntemps, nfiles, output_file);\n<line53>/* We aren't guaranteed that this final mergefiles will work, therefore we\n<line54>try to merge into the output, and then merge as much as we can into a\n<line55>temp file if we can't. Repeat.  */\n<line56>while (true)\n<line57>{\n<line58>/* Merge directly into the output file if possible.  */\n<line59>FILE **fps;\n<line60>size_t nopened = open_input_files (files, nfiles, &fps);\n<line61>if (nopened == nfiles)\n<line62>{\n<line63>FILE *ofp = stream_open (output_file, "w");\n<line64>if (ofp)\n<line65>{\n<line66>mergefps (files, ntemps, nfiles, ofp, output_file, fps);\n<line67>break;\n<line68>}\n<line69>if (errno != EMFILE || nopened <= 2)\n<line70>sort_die (_("open failed"), output_file);\n<line71>}\n<line72>else if (nopened <= 2)\n<line73>sort_die (_("open failed"), files[nopened].name);\n<line74>/* We ran out of file descriptors.  Close one of the input\n<line75>files, to gain a file descriptor.  Then create a temporary\n<line76>file with our spare file descriptor.  Retry if that failed\n<line77>(e.g., some other process could open a file between the time\n<line78>we closed and tried to create).  */\n<line79>FILE *tfp;\n<line80>struct tempnode *temp;\n<line81>do\n<line82>{\n<line83>nopened--;\n<line84>xfclose (fps[nopened], files[nopened].name);\n<line85>temp = maybe_create_temp (&tfp, ! (nopened <= 2));\n<line86>}\n<line87>while (!temp);\n<line88>/* Merge into the newly allocated temporary.  */\n<line89>mergefps (&files[0], MIN (ntemps, nopened), nopened, tfp, temp->name,\n<line90>fps);\n<line91>ntemps -= MIN (ntemps, nopened);\n<line92>files[0].name = temp->name;\n<line93>files[0].temp = temp;\n<line94>memmove (&files[1], &files[nopened], (nfiles - nopened) * sizeof *files);\n<line95>ntemps++;\n<line96>nfiles -= nopened - 1;\n<line97>}\n<line98>}
----------------------------------------
Function: sort
Content: <line0>static void\n<line1>sort (char *const *files, size_t nfiles, char const *output_file,\n<line2>size_t nthreads)\n<line3>{\n<line4>struct buffer buf;\n<line5>size_t ntemps = 0;\n<line6>bool output_file_created = false;\n<line7>buf.alloc = 0;\n<line8>while (nfiles)\n<line9>{\n<line10>char const *temp_output;\n<line11>char const *file = *files;\n<line12>FILE *fp = xfopen (file, "r");\n<line13>FILE *tfp;\n<line14>size_t bytes_per_line;\n<line15>if (nthreads > 1)\n<line16>{\n<line17>/* Get log P. */\n<line18>size_t tmp = 1;\n<line19>size_t mult = 1;\n<line20>while (tmp < nthreads)\n<line21>{\n<line22>tmp *= 2;\n<line23>mult++;\n<line24>}\n<line25>bytes_per_line = (mult * sizeof (struct line));\n<line26>}\n<line27>else\n<line28>bytes_per_line = sizeof (struct line) * 3 / 2;\n<line29>if (! buf.alloc)\n<line30>initbuf (&buf, bytes_per_line,\n<line31>sort_buffer_size (&fp, 1, files, nfiles, bytes_per_line));\n<line32>buf.eof = false;\n<line33>files++;\n<line34>nfiles--;\n<line35>while (fillbuf (&buf, fp, file))\n<line36>{\n<line37>struct line *line;\n<line38>if (buf.eof && nfiles\n<line39>&& (bytes_per_line + 1\n<line40>< (buf.alloc - buf.used - bytes_per_line * buf.nlines)))\n<line41>{\n<line42>/* End of file, but there is more input and buffer room.\n<line43>Concatenate the next input file; this is faster in\n<line44>the usual case.  */\n<line45>buf.left = buf.used;\n<line46>break;\n<line47>}\n<line48>saved_line.text = nullptr;\n<line49>line = buffer_linelim (&buf);\n<line50>if (buf.eof && !nfiles && !ntemps && !buf.left)\n<line51>{\n<line52>xfclose (fp, file);\n<line53>tfp = xfopen (output_file, "w");\n<line54>temp_output = output_file;\n<line55>output_file_created = true;\n<line56>}\n<line57>else\n<line58>{\n<line59>++ntemps;\n<line60>temp_output = create_temp (&tfp)->name;\n<line61>}\n<line62>if (1 < buf.nlines)\n<line63>{\n<line64>struct merge_node_queue queue;\n<line65>queue_init (&queue, nthreads);\n<line66>struct merge_node *merge_tree =\n<line67>merge_tree_init (nthreads, buf.nlines, line);\n<line68>sortlines (line, nthreads, buf.nlines, merge_tree + 1,\n<line69>&queue, tfp, temp_output);\n<line70>merge_tree_destroy (nthreads, merge_tree);\n<line71>queue_destroy (&queue);\n<line72>}\n<line73>else\n<line74>write_unique (line - 1, tfp, temp_output);\n<line75>xfclose (tfp, temp_output);\n<line76>if (output_file_created)\n<line77>goto finish;\n<line78>}\n<line79>xfclose (fp, file);\n<line80>}\n<line81>finish:\n<line82>free (buf.buf);\n<line83>if (! output_file_created)\n<line84>{\n<line85>struct tempnode *node = temphead;\n<line86>struct sortfile *tempfiles = xnmalloc (ntemps, sizeof *tempfiles);\n<line87>for (size_t i = 0; node; i++)\n<line88>{\n<line89>tempfiles[i].name = node->name;\n<line90>tempfiles[i].temp = node;\n<line91>node = node->next;\n<line92>}\n<line93>merge (tempfiles, ntemps, ntemps, output_file);\n<line94>free (tempfiles);\n<line95>}\n<line96>reap_all ();\n<line97>}
----------------------------------------
Function: insertkey
Content: <line0>static void\n<line1>insertkey (struct keyfield *key_arg)\n<line2>{\n<line3>struct keyfield **p;\n<line4>struct keyfield *key = xmemdup (key_arg, sizeof *key);\n<line5>for (p = &keylist; *p; p = &(*p)->next)\n<line6>continue;\n<line7>*p = key;\n<line8>key->next = nullptr;\n<line9>}
----------------------------------------
Function: badfieldspec
Content: <line0>static void\n<line1>badfieldspec (char const *spec, char const *msgid)\n<line2>{\n<line3>error (SORT_FAILURE, 0, _("%s: invalid field specification %s"),\n<line4>_(msgid), quote (spec));\n<line5>}
----------------------------------------
Function: incompatible_options
Content: <line0>static void\n<line1>incompatible_options (char const *opts)\n<line2>{\n<line3>error (SORT_FAILURE, 0, _("options '-%s' are incompatible"), (opts));\n<line4>}
----------------------------------------
Function: check_ordering_compatibility
Content: <line0>static void\n<line1>check_ordering_compatibility (void)\n<line2>{\n<line3>struct keyfield *key;\n<line4>for (key = keylist; key; key = key->next)\n<line5>if (1 < (key->numeric + key->general_numeric + key->human_numeric\n<line6>+ key->month + (key->version | key->random | !!key->ignore)))\n<line7>{\n<line8>/* The following is too big, but guaranteed to be "big enough".  */\n<line9>char opts[sizeof short_options];\n<line10>/* Clear flags we're not interested in.  */\n<line11>key->skipsblanks = key->skipeblanks = key->reverse = false;\n<line12>key_to_opts (key, opts);\n<line13>incompatible_options (opts);\n<line14>}\n<line15>}
----------------------------------------
Function: parse_field_count
Content: <line0>static char const *\n<line1>parse_field_count (char const *string, size_t *val, char const *msgid)\n<line2>{\n<line3>char *suffix;\n<line4>uintmax_t n;\n<line5>switch (xstrtoumax (string, &suffix, 10, &n, ""))\n<line6>{\n<line7>case LONGINT_OK:\n<line8>case LONGINT_INVALID_SUFFIX_CHAR:\n<line9>*val = n;\n<line10>if (*val == n)\n<line11>break;\n<line12>FALLTHROUGH;\n<line13>case LONGINT_OVERFLOW:\n<line14>case LONGINT_OVERFLOW | LONGINT_INVALID_SUFFIX_CHAR:\n<line15>*val = SIZE_MAX;\n<line16>break;\n<line17>case LONGINT_INVALID:\n<line18>if (msgid)\n<line19>error (SORT_FAILURE, 0, _("%s: invalid count at start of %s"),\n<line20>_(msgid), quote (string));\n<line21>return nullptr;\n<line22>}\n<line23>return suffix;\n<line24>}
----------------------------------------
Function: sighandler
Content: <line0>static void\n<line1>sighandler (int sig)\n<line2>{\n<line3>if (! SA_NOCLDSTOP)\n<line4>signal (sig, SIG_IGN);\n<line5>cleanup ();\n<line6>signal (sig, SIG_DFL);\n<line7>raise (sig);\n<line8>}
----------------------------------------
Function: set_ordering
Content: <line0>static char *\n<line1>set_ordering (char const *s, struct keyfield *key, enum blanktype blanktype)\n<line2>{\n<line3>while (*s)\n<line4>{\n<line5>switch (*s)\n<line6>{\n<line7>case 'b':\n<line8>if (blanktype == bl_start || blanktype == bl_both)\n<line9>key->skipsblanks = true;\n<line10>if (blanktype == bl_end || blanktype == bl_both)\n<line11>key->skipeblanks = true;\n<line12>break;\n<line13>case 'd':\n<line14>key->ignore = nondictionary;\n<line15>break;\n<line16>case 'f':\n<line17>key->translate = fold_toupper;\n<line18>break;\n<line19>case 'g':\n<line20>key->general_numeric = true;\n<line21>break;\n<line22>case 'h':\n<line23>key->human_numeric = true;\n<line24>break;\n<line25>case 'i':\n<line26>/* Option order should not matter, so don't let -i override\n<line27>-d.  -d implies -i, but -i does not imply -d.  */\n<line28>if (! key->ignore)\n<line29>key->ignore = nonprinting;\n<line30>break;\n<line31>case 'M':\n<line32>key->month = true;\n<line33>break;\n<line34>case 'n':\n<line35>key->numeric = true;\n<line36>break;\n<line37>case 'R':\n<line38>key->random = true;\n<line39>break;\n<line40>case 'r':\n<line41>key->reverse = true;\n<line42>break;\n<line43>case 'V':\n<line44>key->version = true;\n<line45>break;\n<line46>default:\n<line47>return (char *) s;\n<line48>}\n<line49>++s;\n<line50>}\n<line51>return (char *) s;\n<line52>}
----------------------------------------
Function: key_init
Content: <line0>static struct keyfield *\n<line1>key_init (struct keyfield *key)\n<line2>{\n<line3>memset (key, 0, sizeof *key);\n<line4>key->eword = SIZE_MAX;\n<line5>return key;\n<line6>}
----------------------------------------
Function: main
Content: <line0>int\n<line1>main (int argc, char **argv)\n<line2>{\n<line3>struct keyfield *key;\n<line4>struct keyfield key_buf;\n<line5>struct keyfield gkey;\n<line6>bool gkey_only = false;\n<line7>char const *s;\n<line8>int c = 0;\n<line9>char checkonly = 0;\n<line10>bool mergeonly = false;\n<line11>char *random_source = nullptr;\n<line12>bool need_random = false;\n<line13>size_t nthreads = 0;\n<line14>size_t nfiles = 0;\n<line15>bool posixly_correct = (getenv ("POSIXLY_CORRECT") != nullptr);\n<line16>int posix_ver = posix2_version ();\n<line17>bool traditional_usage = ! (200112 <= posix_ver && posix_ver < 200809);\n<line18>char **files;\n<line19>char *files_from = nullptr;\n<line20>struct Tokens tok;\n<line21>char const *outfile = nullptr;\n<line22>bool locale_ok;\n<line23>initialize_main (&argc, &argv);\n<line24>set_program_name (argv[0]);\n<line25>locale_ok = !! setlocale (LC_ALL, "");\n<line26>bindtextdomain (PACKAGE, LOCALEDIR);\n<line27>textdomain (PACKAGE);\n<line28>initialize_exit_failure (SORT_FAILURE);\n<line29>hard_LC_COLLATE = hard_locale (LC_COLLATE);\n<line30>#if HAVE_NL_LANGINFO\n<line31>hard_LC_TIME = hard_locale (LC_TIME);\n<line32>#endif\n<line33>/* Get locale's representation of the decimal point.  */\n<line34>{\n<line35>struct lconv const *locale = localeconv ();\n<line36>/* If the locale doesn't define a decimal point, or if the decimal\n<line37>point is multibyte, use the C locale's decimal point.  FIXME:\n<line38>add support for multibyte decimal points.  */\n<line39>decimal_point = locale->decimal_point[0];\n<line40>if (! decimal_point || locale->decimal_point[1])\n<line41>decimal_point = '.';\n<line42>/* FIXME: add support for multibyte thousands separators.  */\n<line43>thousands_sep = locale->thousands_sep[0];\n<line44>if (thousands_sep && locale->thousands_sep[1])\n<line45>thousands_sep_ignored = true;\n<line46>if (! thousands_sep || locale->thousands_sep[1])\n<line47>thousands_sep = NON_CHAR;\n<line48>}\n<line49>have_read_stdin = false;\n<line50>inittables ();\n<line51>{\n<line52>size_t i;\n<line53>static int const sig[] =\n<line54>{\n<line55>/* The usual suspects.  */\n<line56>SIGALRM, SIGHUP, SIGINT, SIGPIPE, SIGQUIT, SIGTERM,\n<line57>#ifdef SIGPOLL\n<line58>SIGPOLL,\n<line59>#endif\n<line60>#ifdef SIGPROF\n<line61>SIGPROF,\n<line62>#endif\n<line63>#ifdef SIGVTALRM\n<line64>SIGVTALRM,\n<line65>#endif\n<line66>#ifdef SIGXCPU\n<line67>SIGXCPU,\n<line68>#endif\n<line69>#ifdef SIGXFSZ\n<line70>SIGXFSZ,\n<line71>#endif\n<line72>};\n<line73>enum { nsigs = ARRAY_CARDINALITY (sig) };\n<line74>#if SA_NOCLDSTOP\n<line75>struct sigaction act;\n<line76>sigemptyset (&caught_signals);\n<line77>for (i = 0; i < nsigs; i++)\n<line78>{\n<line79>sigaction (sig[i], nullptr, &act);\n<line80>if (act.sa_handler != SIG_IGN)\n<line81>sigaddset (&caught_signals, sig[i]);\n<line82>}\n<line83>act.sa_handler = sighandler;\n<line84>act.sa_mask = caught_signals;\n<line85>act.sa_flags = 0;\n<line86>for (i = 0; i < nsigs; i++)\n<line87>if (sigismember (&caught_signals, sig[i]))\n<line88>sigaction (sig[i], &act, nullptr);\n<line89>#else\n<line90>for (i = 0; i < nsigs; i++)\n<line91>if (signal (sig[i], SIG_IGN) != SIG_IGN)\n<line92>{\n<line93>signal (sig[i], sighandler);\n<line94>siginterrupt (sig[i], 1);\n<line95>}\n<line96>#endif\n<line97>}\n<line98>signal (SIGCHLD, SIG_DFL); /* Don't inherit CHLD handling from parent.  */\n<line99>/* The signal mask is known, so it is safe to invoke exit_cleanup.  */\n<line100>atexit (exit_cleanup);\n<line101>key_init (&gkey);\n<line102>gkey.sword = SIZE_MAX;\n<line103>files = xnmalloc (argc, sizeof *files);\n<line104>while (true)\n<line105>{\n<line106>/* Parse an operand as a file after "--" was seen; or if\n<line107>pedantic and a file was seen, unless the POSIX version\n<line108>is not 1003.1-2001 and -c was not seen and the operand is\n<line109>"-o FILE" or "-oFILE".  */\n<line110>int oi = -1;\n<line111>if (c == -1\n<line112>|| (posixly_correct && nfiles != 0\n<line113>&& ! (traditional_usage\n<line114>&& ! checkonly\n<line115>&& optind != argc\n<line116>&& argv[optind][0] == '-' && argv[optind][1] == 'o'\n<line117>&& (argv[optind][2] || optind + 1 != argc)))\n<line118>|| ((c = getopt_long (argc, argv, short_options,\n<line119>long_options, &oi))\n<line120>== -1))\n<line121>{\n<line122>if (argc <= optind)\n<line123>break;\n<line124>files[nfiles++] = argv[optind++];\n<line125>}\n<line126>else switch (c)\n<line127>{\n<line128>case 1:\n<line129>key = nullptr;\n<line130>if (optarg[0] == '+')\n<line131>{\n<line132>bool minus_pos_usage = (optind != argc && argv[optind][0] == '-'\n<line133>&& ISDIGIT (argv[optind][1]));\n<line134>traditional_usage |= minus_pos_usage && !posixly_correct;\n<line135>if (traditional_usage)\n<line136>{\n<line137>/* Treat +POS1 [-POS2] as a key if possible; but silently\n<line138>treat an operand as a file if it is not a valid +POS1.  */\n<line139>key = key_init (&key_buf);\n<line140>s = parse_field_count (optarg + 1, &key->sword, nullptr);\n<line141>if (s && *s == '.')\n<line142>s = parse_field_count (s + 1, &key->schar, nullptr);\n<line143>if (! (key->sword || key->schar))\n<line144>key->sword = SIZE_MAX;\n<line145>if (! s || *set_ordering (s, key, bl_start))\n<line146>key = nullptr;\n<line147>else\n<line148>{\n<line149>if (minus_pos_usage)\n<line150>{\n<line151>char const *optarg1 = argv[optind++];\n<line152>s = parse_field_count (optarg1 + 1, &key->eword,\n<line153>N_("invalid number after '-'"));\n<line154>if (*s == '.')\n<line155>s = parse_field_count (s + 1, &key->echar,\n<line156>N_("invalid number after '.'"));\n<line157>if (!key->echar && key->eword)\n<line158>{\n<line159>/* obsolescent syntax +A.x -B.y is equivalent to:\n<line160>-k A+1.x+1,B.y   (when y = 0)\n<line161>-k A+1.x+1,B+1.y (when y > 0)\n<line162>So eword is decremented as in the -k case\n<line163>only when the end field (B) is specified and\n<line164>echar (y) is 0.  */\n<line165>key->eword--;\n<line166>}\n<line167>if (*set_ordering (s, key, bl_end))\n<line168>badfieldspec (optarg1,\n<line169>N_("stray character in field spec"));\n<line170>}\n<line171>key->traditional_used = true;\n<line172>insertkey (key);\n<line173>}\n<line174>}\n<line175>}\n<line176>if (! key)\n<line177>files[nfiles++] = optarg;\n<line178>break;\n<line179>case SORT_OPTION:\n<line180>c = XARGMATCH ("--sort", optarg, sort_args, sort_types);\n<line181>FALLTHROUGH;\n<line182>case 'b':\n<line183>case 'd':\n<line184>case 'f':\n<line185>case 'g':\n<line186>case 'h':\n<line187>case 'i':\n<line188>case 'M':\n<line189>case 'n':\n<line190>case 'r':\n<line191>case 'R':\n<line192>case 'V':\n<line193>{\n<line194>char str[2];\n<line195>str[0] = c;\n<line196>str[1] = '\0';\n<line197>set_ordering (str, &gkey, bl_both);\n<line198>}\n<line199>break;\n<line200>case CHECK_OPTION:\n<line201>c = (optarg\n<line202>? XARGMATCH ("--check", optarg, check_args, check_types)\n<line203>: 'c');\n<line204>FALLTHROUGH;\n<line205>case 'c':\n<line206>case 'C':\n<line207>if (checkonly && checkonly != c)\n<line208>incompatible_options ("cC");\n<line209>checkonly = c;\n<line210>break;\n<line211>case COMPRESS_PROGRAM_OPTION:\n<line212>if (compress_program && !STREQ (compress_program, optarg))\n<line213>error (SORT_FAILURE, 0, _("multiple compress programs specified"));\n<line214>compress_program = optarg;\n<line215>break;\n<line216>case DEBUG_PROGRAM_OPTION:\n<line217>debug = true;\n<line218>break;\n<line219>case FILES0_FROM_OPTION:\n<line220>files_from = optarg;\n<line221>break;\n<line222>case 'k':\n<line223>key = key_init (&key_buf);\n<line224>/* Get POS1. */\n<line225>s = parse_field_count (optarg, &key->sword,\n<line226>N_("invalid number at field start"));\n<line227>if (! key->sword--)\n<line228>{\n<line229>/* Provoke with 'sort -k0' */\n<line230>badfieldspec (optarg, N_("field number is zero"));\n<line231>}\n<line232>if (*s == '.')\n<line233>{\n<line234>s = parse_field_count (s + 1, &key->schar,\n<line235>N_("invalid number after '.'"));\n<line236>if (! key->schar--)\n<line237>{\n<line238>/* Provoke with 'sort -k1.0' */\n<line239>badfieldspec (optarg, N_("character offset is zero"));\n<line240>}\n<line241>}\n<line242>if (! (key->sword || key->schar))\n<line243>key->sword = SIZE_MAX;\n<line244>s = set_ordering (s, key, bl_start);\n<line245>if (*s != ',')\n<line246>{\n<line247>key->eword = SIZE_MAX;\n<line248>key->echar = 0;\n<line249>}\n<line250>else\n<line251>{\n<line252>/* Get POS2. */\n<line253>s = parse_field_count (s + 1, &key->eword,\n<line254>N_("invalid number after ','"));\n<line255>if (! key->eword--)\n<line256>{\n<line257>/* Provoke with 'sort -k1,0' */\n<line258>badfieldspec (optarg, N_("field number is zero"));\n<line259>}\n<line260>if (*s == '.')\n<line261>{\n<line262>s = parse_field_count (s + 1, &key->echar,\n<line263>N_("invalid number after '.'"));\n<line264>}\n<line265>s = set_ordering (s, key, bl_end);\n<line266>}\n<line267>if (*s)\n<line268>badfieldspec (optarg, N_("stray character in field spec"));\n<line269>insertkey (key);\n<line270>break;\n<line271>case 'm':\n<line272>mergeonly = true;\n<line273>break;\n<line274>case NMERGE_OPTION:\n<line275>specify_nmerge (oi, c, optarg);\n<line276>break;\n<line277>case 'o':\n<line278>if (outfile && !STREQ (outfile, optarg))\n<line279>error (SORT_FAILURE, 0, _("multiple output files specified"));\n<line280>outfile = optarg;\n<line281>break;\n<line282>case RANDOM_SOURCE_OPTION:\n<line283>if (random_source && !STREQ (random_source, optarg))\n<line284>error (SORT_FAILURE, 0, _("multiple random sources specified"));\n<line285>random_source = optarg;\n<line286>break;\n<line287>case 's':\n<line288>stable = true;\n<line289>break;\n<line290>case 'S':\n<line291>specify_sort_size (oi, c, optarg);\n<line292>break;\n<line293>case 't':\n<line294>{\n<line295>char newtab = optarg[0];\n<line296>if (! newtab)\n<line297>error (SORT_FAILURE, 0, _("empty tab"));\n<line298>if (optarg[1])\n<line299>{\n<line300>if (STREQ (optarg, "\\0"))\n<line301>newtab = '\0';\n<line302>else\n<line303>{\n<line304>/* Provoke with 'sort -txx'.  Complain about\n<line305>"multi-character tab" instead of "multibyte tab", so\n<line306>that the diagnostic's wording does not need to be\n<line307>changed once multibyte characters are supported.  */\n<line308>error (SORT_FAILURE, 0, _("multi-character tab %s"),\n<line309>quote (optarg));\n<line310>}\n<line311>}\n<line312>if (tab != TAB_DEFAULT && tab != newtab)\n<line313>error (SORT_FAILURE, 0, _("incompatible tabs"));\n<line314>tab = newtab;\n<line315>}\n<line316>break;\n<line317>case 'T':\n<line318>add_temp_dir (optarg);\n<line319>break;\n<line320>case PARALLEL_OPTION:\n<line321>nthreads = specify_nthreads (oi, c, optarg);\n<line322>break;\n<line323>case 'u':\n<line324>unique = true;\n<line325>break;\n<line326>case 'y':\n<line327>/* Accept and ignore e.g. -y0 for compatibility with Solaris 2.x\n<line328>through Solaris 7.  It is also accepted by many non-Solaris\n<line329>"sort" implementations, e.g., AIX 5.2, HP-UX 11i v2, IRIX 6.5.\n<line330>-y is marked as obsolete starting with Solaris 8 (1999), but is\n<line331>still accepted as of Solaris 10 prerelease (2004).\n<line332>Solaris 2.5.1 "sort -y 100" reads the input file "100", but\n<line333>emulate Solaris 8 and 9 "sort -y 100" which ignores the "100",\n<line334>and which in general ignores the argument after "-y" if it\n<line335>consists entirely of digits (it can even be empty).  */\n<line336>if (optarg == argv[optind - 1])\n<line337>{\n<line338>char const *p;\n<line339>for (p = optarg; ISDIGIT (*p); p++)\n<line340>continue;\n<line341>optind -= (*p != '\0');\n<line342>}\n<line343>break;\n<line344>case 'z':\n<line345>eolchar = 0;\n<line346>break;\n<line347>case_GETOPT_HELP_CHAR;\n<line348>case_GETOPT_VERSION_CHAR (PROGRAM_NAME, AUTHORS);\n<line349>default:\n<line350>usage (SORT_FAILURE);\n<line351>}\n<line352>}\n<line353>if (files_from)\n<line354>{\n<line355>/* When using --files0-from=F, you may not specify any files\n<line356>on the command-line.  */\n<line357>if (nfiles)\n<line358>{\n<line359>error (0, 0, _("extra operand %s"), quoteaf (files[0]));\n<line360>fprintf (stderr, "%s\n",\n<line361>_("file operands cannot be combined with --files0-from"));\n<line362>usage (SORT_FAILURE);\n<line363>}\n<line364>FILE *stream = xfopen (files_from, "r");\n<line365>readtokens0_init (&tok);\n<line366>if (! readtokens0 (stream, &tok))\n<line367>error (SORT_FAILURE, 0, _("cannot read file names from %s"),\n<line368>quoteaf (files_from));\n<line369>xfclose (stream, files_from);\n<line370>if (tok.n_tok)\n<line371>{\n<line372>free (files);\n<line373>files = tok.tok;\n<line374>nfiles = tok.n_tok;\n<line375>for (size_t i = 0; i < nfiles; i++)\n<line376>{\n<line377>if (STREQ (files[i], "-"))\n<line378>error (SORT_FAILURE, 0, _("when reading file names from stdin, "\n<line379>"no file name of %s allowed"),\n<line380>quoteaf (files[i]));\n<line381>else if (files[i][0] == '\0')\n<line382>{\n<line383>/* Using the standard 'filename:line-number:' prefix here is\n<line384>not totally appropriate, since NUL is the separator,\n<line385>not NL, but it might be better than nothing.  */\n<line386>unsigned long int file_number = i + 1;\n<line387>error (SORT_FAILURE, 0,\n<line388>_("%s:%lu: invalid zero-length file name"),\n<line389>quotef (files_from), file_number);\n<line390>}\n<line391>}\n<line392>}\n<line393>else\n<line394>error (SORT_FAILURE, 0, _("no input from %s"),\n<line395>quoteaf (files_from));\n<line396>}\n<line397>/* Inheritance of global options to individual keys. */\n<line398>for (key = keylist; key; key = key->next)\n<line399>{\n<line400>if (default_key_compare (key) && !key->reverse)\n<line401>{\n<line402>key->ignore = gkey.ignore;\n<line403>key->translate = gkey.translate;\n<line404>key->skipsblanks = gkey.skipsblanks;\n<line405>key->skipeblanks = gkey.skipeblanks;\n<line406>key->month = gkey.month;\n<line407>key->numeric = gkey.numeric;\n<line408>key->general_numeric = gkey.general_numeric;\n<line409>key->human_numeric = gkey.human_numeric;\n<line410>key->version = gkey.version;\n<line411>key->random = gkey.random;\n<line412>key->reverse = gkey.reverse;\n<line413>}\n<line414>need_random |= key->random;\n<line415>}\n<line416>if (!keylist && !default_key_compare (&gkey))\n<line417>{\n<line418>gkey_only = true;\n<line419>insertkey (&gkey);\n<line420>need_random |= gkey.random;\n<line421>}\n<line422>check_ordering_compatibility ();\n<line423>if (debug)\n<line424>{\n<line425>if (checkonly || outfile)\n<line426>{\n<line427>static char opts[] = "X --debug";\n<line428>opts[0] = (checkonly ? checkonly : 'o');\n<line429>incompatible_options (opts);\n<line430>}\n<line431>/* Always output the locale in debug mode, since this\n<line432>is such a common source of confusion.  */\n<line433>/* OpenBSD can only set some categories with LC_ALL above,\n<line434>so set LC_COLLATE explicitly to flag errors.  */\n<line435>if (locale_ok)\n<line436>locale_ok = !! setlocale (LC_COLLATE, "");\n<line437>if (! locale_ok)\n<line438>error (0, 0, "%s", _("failed to set locale"));\n<line439>if (hard_LC_COLLATE)\n<line440>error (0, 0, _("text ordering performed using %s sorting rules"),\n<line441>quote (setlocale (LC_COLLATE, nullptr)));\n<line442>else\n<line443>error (0, 0, "%s",\n<line444>_("text ordering performed using simple byte comparison"));\n<line445>key_warnings (&gkey, gkey_only);\n<line446>}\n<line447>reverse = gkey.reverse;\n<line448>if (need_random)\n<line449>random_md5_state_init (random_source);\n<line450>if (temp_dir_count == 0)\n<line451>{\n<line452>char const *tmp_dir = getenv ("TMPDIR");\n<line453>add_temp_dir (tmp_dir ? tmp_dir : DEFAULT_TMPDIR);\n<line454>}\n<line455>if (nfiles == 0)\n<line456>{\n<line457>nfiles = 1;\n<line458>free (files);\n<line459>files = xmalloc (sizeof *files);\n<line460>*files = (char *) "-";\n<line461>}\n<line462>/* Need to re-check that we meet the minimum requirement for memory\n<line463>usage with the final value for NMERGE. */\n<line464>if (0 < sort_size)\n<line465>sort_size = MAX (sort_size, MIN_SORT_SIZE);\n<line466>if (checkonly)\n<line467>{\n<line468>if (nfiles > 1)\n<line469>error (SORT_FAILURE, 0, _("extra operand %s not allowed with -%c"),\n<line470>quoteaf (files[1]), checkonly);\n<line471>if (outfile)\n<line472>{\n<line473>static char opts[] = {0, 'o', 0};\n<line474>opts[0] = checkonly;\n<line475>incompatible_options (opts);\n<line476>}\n<line477>/* POSIX requires that sort return 1 IFF invoked with -c or -C and the\n<line478>input is not properly sorted.  */\n<line479>exit (check (files[0], checkonly) ? EXIT_SUCCESS : SORT_OUT_OF_ORDER);\n<line480>}\n<line481>/* Check all inputs are accessible, or exit immediately.  */\n<line482>check_inputs (files, nfiles);\n<line483>/* Check output is writable, or exit immediately.  */\n<line484>check_output (outfile);\n<line485>if (mergeonly)\n<line486>{\n<line487>struct sortfile *sortfiles = xcalloc (nfiles, sizeof *sortfiles);\n<line488>for (size_t i = 0; i < nfiles; ++i)\n<line489>sortfiles[i].name = files[i];\n<line490>merge (sortfiles, 0, nfiles, outfile);\n<line491>}\n<line492>else\n<line493>{\n<line494>if (!nthreads)\n<line495>{\n<line496>unsigned long int np = num_processors (NPROC_CURRENT_OVERRIDABLE);\n<line497>nthreads = MIN (np, DEFAULT_MAX_THREADS);\n<line498>}\n<line499>/* Avoid integer overflow later.  */\n<line500>size_t nthreads_max = SIZE_MAX / (2 * sizeof (struct merge_node));\n<line501>nthreads = MIN (nthreads, nthreads_max);\n<line502>sort (files, nfiles, outfile, nthreads);\n<line503>}\n<line504>if (have_read_stdin && fclose (stdin) == EOF)\n<line505>sort_die (_("close failed"), "-");\n<line506>main_exit (EXIT_SUCCESS);\n<line507>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/src/split.c
========================================
Function: ignorable
Content: <line0>static inline bool\n<line1>ignorable (int err)\n<line2>{\n<line3>return filter_command && err == EPIPE;\n<line4>}
----------------------------------------
Function: set_suffix_length
Content: <line0>static void\n<line1>set_suffix_length (intmax_t n_units, enum Split_type split_type)\n<line2>{\n<line3>#define DEFAULT_SUFFIX_LENGTH 2\n<line4>int suffix_length_needed = 0;\n<line5>/* The suffix auto length feature is incompatible with\n<line6>a user specified start value as the generated suffixes\n<line7>are not all consecutive.  */\n<line8>if (numeric_suffix_start)\n<line9>suffix_auto = false;\n<line10>/* Auto-calculate the suffix length if the number of files is given.  */\n<line11>if (split_type == type_chunk_bytes || split_type == type_chunk_lines\n<line12>|| split_type == type_rr)\n<line13>{\n<line14>intmax_t n_units_end = n_units - 1;\n<line15>if (numeric_suffix_start)\n<line16>{\n<line17>intmax_t n_start;\n<line18>strtol_error e = xstrtoimax (numeric_suffix_start, nullptr, 10,\n<line19>&n_start, "");\n<line20>if (e == LONGINT_OK && n_start < n_units)\n<line21>{\n<line22>/* Restrict auto adjustment so we don't keep\n<line23>incrementing a suffix size arbitrarily,\n<line24>as that would break sort order for files\n<line25>generated from multiple split runs.  */\n<line26>if (ckd_add (&n_units_end, n_units_end, n_start))\n<line27>n_units_end = INTMAX_MAX;\n<line28>}\n<line29>}\n<line30>idx_t alphabet_len = strlen (suffix_alphabet);\n<line31>do\n<line32>suffix_length_needed++;\n<line33>while (n_units_end /= alphabet_len);\n<line34>suffix_auto = false;\n<line35>}\n<line36>if (suffix_length)            /* set by user */\n<line37>{\n<line38>if (suffix_length < suffix_length_needed)\n<line39>error (EXIT_FAILURE, 0,\n<line40>_("the suffix length needs to be at least %d"),\n<line41>suffix_length_needed);\n<line42>suffix_auto = false;\n<line43>return;\n<line44>}\n<line45>else\n<line46>suffix_length = MAX (DEFAULT_SUFFIX_LENGTH, suffix_length_needed);\n<line47>}
----------------------------------------
Function: usage
Content: <line0>void\n<line1>usage (int status)\n<line2>{\n<line3>if (status != EXIT_SUCCESS)\n<line4>emit_try_help ();\n<line5>else\n<line6>{\n<line7>printf (_("\\n<line8>Usage: %s [OPTION]... [FILE [PREFIX]]\n\\n<line9>"),\n<line10>program_name);\n<line11>fputs (_("\\n<line12>Output pieces of FILE to PREFIXaa, PREFIXab, ...;\n\\n<line13>default size is 1000 lines, and default PREFIX is 'x'.\n\\n<line14>"), stdout);\n<line15>emit_stdin_note ();\n<line16>emit_mandatory_arg_note ();\n<line17>fprintf (stdout, _("\\n<line18>-a, --suffix-length=N   generate suffixes of length N (default %d)\n\\n<line19>--additional-suffix=SUFFIX  append an additional SUFFIX to file names\n\\n<line20>-b, --bytes=SIZE        put SIZE bytes per output file\n\\n<line21>-C, --line-bytes=SIZE   put at most SIZE bytes of records per output file\n\\n<line22>-d                      use numeric suffixes starting at 0, not alphabetic\n\\n<line23>--numeric-suffixes[=FROM]  same as -d, but allow setting the start value\\n<line24>\n\\n<line25>-x                      use hex suffixes starting at 0, not alphabetic\n\\n<line26>--hex-suffixes[=FROM]  same as -x, but allow setting the start value\n\\n<line27>-e, --elide-empty-files  do not generate empty output files with '-n'\n\\n<line28>--filter=COMMAND    write to shell COMMAND; file name is $FILE\n\\n<line29>-l, --lines=NUMBER      put NUMBER lines/records per output file\n\\n<line30>-n, --number=CHUNKS     generate CHUNKS output files; see explanation below\n\\n<line31>-t, --separator=SEP     use SEP instead of newline as the record separator;\n\\n<line32>'\\0' (zero) specifies the NUL character\n\\n<line33>-u, --unbuffered        immediately copy input to output with '-n r/...'\n\\n<line34>"), DEFAULT_SUFFIX_LENGTH);\n<line35>fputs (_("\\n<line36>--verbose           print a diagnostic just before each\n\\n<line37>output file is opened\n\\n<line38>"), stdout);\n<line39>fputs (HELP_OPTION_DESCRIPTION, stdout);\n<line40>fputs (VERSION_OPTION_DESCRIPTION, stdout);\n<line41>emit_size_note ();\n<line42>fputs (_("\n\\n<line43>CHUNKS may be:\n\\n<line44>N       split into N files based on size of input\n\\n<line45>K/N     output Kth of N to stdout\n\\n<line46>l/N     split into N files without splitting lines/records\n\\n<line47>l/K/N   output Kth of N to stdout without splitting lines/records\n\\n<line48>r/N     like 'l' but use round robin distribution\n\\n<line49>r/K/N   likewise but only output Kth of N to stdout\n\\n<line50>"), stdout);\n<line51>emit_ancillary_info (PROGRAM_NAME);\n<line52>}\n<line53>exit (status);\n<line54>}
----------------------------------------
Function: copy_to_tmpfile
Content: <line0>static off_t\n<line1>copy_to_tmpfile (int fd, char *buf, idx_t bufsize)\n<line2>{\n<line3>FILE *tmp;\n<line4>if (!temp_stream (&tmp, nullptr))\n<line5>return -1;\n<line6>off_t copied = 0;\n<line7>off_t r;\n<line8>while (0 < (r = read (fd, buf, bufsize)))\n<line9>{\n<line10>if (fwrite (buf, 1, r, tmp) != r)\n<line11>return -1;\n<line12>if (ckd_add (&copied, copied, r))\n<line13>{\n<line14>errno = EOVERFLOW;\n<line15>return -1;\n<line16>}\n<line17>}\n<line18>if (r < 0)\n<line19>return r;\n<line20>r = dup2 (fileno (tmp), fd);\n<line21>if (r < 0)\n<line22>return r;\n<line23>if (fclose (tmp) < 0)\n<line24>return -1;\n<line25>return copied;\n<line26>}
----------------------------------------
Function: input_file_size
Content: <line0>static off_t\n<line1>input_file_size (int fd, struct stat const *st, char *buf, idx_t bufsize)\n<line2>{\n<line3>off_t size = 0;\n<line4>do\n<line5>{\n<line6>ssize_t n_read = read (fd, buf + size, bufsize - size);\n<line7>if (n_read <= 0)\n<line8>return n_read < 0 ? n_read : size;\n<line9>size += n_read;\n<line10>}\n<line11>while (size < bufsize);\n<line12>off_t cur, end;\n<line13>if ((usable_st_size (st) && st->st_size < size)\n<line14>|| (cur = lseek (fd, 0, SEEK_CUR)) < 0\n<line15>|| cur < size /* E.g., /dev/zero on GNU/Linux.  */\n<line16>|| (end = lseek (fd, 0, SEEK_END)) < 0)\n<line17>{\n<line18>char *tmpbuf = xmalloc (bufsize);\n<line19>end = copy_to_tmpfile (fd, tmpbuf, bufsize);\n<line20>free (tmpbuf);\n<line21>if (end < 0)\n<line22>return end;\n<line23>cur = 0;\n<line24>}\n<line25>if (end == OFF_T_MAX /* E.g., /dev/zero on GNU/Hurd.  */\n<line26>|| (cur < end && ckd_add (&size, size, end - cur)))\n<line27>{\n<line28>errno = EOVERFLOW;\n<line29>return -1;\n<line30>}\n<line31>if (cur < end)\n<line32>{\n<line33>off_t r = lseek (fd, cur, SEEK_SET);\n<line34>if (r < 0)\n<line35>return r;\n<line36>}\n<line37>return size;\n<line38>}
----------------------------------------
Function: next_file_name
Content: <line0>static void\n<line1>next_file_name (void)\n<line2>{\n<line3>/* Index in suffix_alphabet of each character in the suffix.  */\n<line4>static idx_t *sufindex;\n<line5>static idx_t outbase_length;\n<line6>static idx_t outfile_length;\n<line7>static idx_t addsuf_length;\n<line8>if (! outfile)\n<line9>{\n<line10>bool overflow, widen;\n<line11>new_name:\n<line12>widen = !! outfile_length;\n<line13>if (! widen)\n<line14>{\n<line15>/* Allocate and initialize the first file name.  */\n<line16>outbase_length = strlen (outbase);\n<line17>addsuf_length = additional_suffix ? strlen (additional_suffix) : 0;\n<line18>overflow = ckd_add (&outfile_length, outbase_length + addsuf_length,\n<line19>suffix_length);\n<line20>}\n<line21>else\n<line22>{\n<line23>/* Reallocate and initialize a new wider file name.\n<line24>We do this by subsuming the unchanging part of\n<line25>the generated suffix into the prefix (base), and\n<line26>reinitializing the now one longer suffix.  */\n<line27>overflow = ckd_add (&outfile_length, outfile_length, 2);\n<line28>suffix_length++;\n<line29>}\n<line30>idx_t outfile_size;\n<line31>overflow |= ckd_add (&outfile_size, outfile_length, 1);\n<line32>if (overflow)\n<line33>xalloc_die ();\n<line34>outfile = xirealloc (outfile, outfile_size);\n<line35>if (! widen)\n<line36>memcpy (outfile, outbase, outbase_length);\n<line37>else\n<line38>{\n<line39>/* Append the last alphabet character to the file name prefix.  */\n<line40>outfile[outbase_length] = suffix_alphabet[sufindex[0]];\n<line41>outbase_length++;\n<line42>}\n<line43>outfile_mid = outfile + outbase_length;\n<line44>memset (outfile_mid, suffix_alphabet[0], suffix_length);\n<line45>if (additional_suffix)\n<line46>memcpy (outfile_mid + suffix_length, additional_suffix, addsuf_length);\n<line47>outfile[outfile_length] = 0;\n<line48>free (sufindex);\n<line49>sufindex = xicalloc (suffix_length, sizeof *sufindex);\n<line50>if (numeric_suffix_start)\n<line51>{\n<line52>affirm (! widen);\n<line53>/* Update the output file name.  */\n<line54>idx_t i = strlen (numeric_suffix_start);\n<line55>memcpy (outfile_mid + suffix_length - i, numeric_suffix_start, i);\n<line56>/* Update the suffix index.  */\n<line57>idx_t *sufindex_end = sufindex + suffix_length;\n<line58>while (i-- != 0)\n<line59>*--sufindex_end = numeric_suffix_start[i] - '0';\n<line60>}\n<line61>#if ! _POSIX_NO_TRUNC && HAVE_PATHCONF && defined _PC_NAME_MAX\n<line62>/* POSIX requires that if the output file name is too long for\n<line63>its directory, 'split' must fail without creating any files.\n<line64>This must be checked for explicitly on operating systems that\n<line65>silently truncate file names.  */\n<line66>{\n<line67>char *dir = dir_name (outfile);\n<line68>long name_max = pathconf (dir, _PC_NAME_MAX);\n<line69>if (0 <= name_max && name_max < base_len (last_component (outfile)))\n<line70>error (EXIT_FAILURE, ENAMETOOLONG, "%s", quotef (outfile));\n<line71>free (dir);\n<line72>}\n<line73>#endif\n<line74>}\n<line75>else\n<line76>{\n<line77>/* Increment the suffix in place, if possible.  */\n<line78>idx_t i = suffix_length;\n<line79>while (i-- != 0)\n<line80>{\n<line81>sufindex[i]++;\n<line82>if (suffix_auto && i == 0 && ! suffix_alphabet[sufindex[0] + 1])\n<line83>goto new_name;\n<line84>outfile_mid[i] = suffix_alphabet[sufindex[i]];\n<line85>if (outfile_mid[i])\n<line86>return;\n<line87>sufindex[i] = 0;\n<line88>outfile_mid[i] = suffix_alphabet[sufindex[i]];\n<line89>}\n<line90>error (EXIT_FAILURE, 0, _("output file suffixes exhausted"));\n<line91>}\n<line92>}
----------------------------------------
Function: create
Content: <line0>static int\n<line1>create (char const *name)\n<line2>{\n<line3>if (!filter_command)\n<line4>{\n<line5>if (verbose)\n<line6>fprintf (stdout, _("creating file %s\n"), quoteaf (name));\n<line7>int oflags = O_WRONLY | O_CREAT | O_BINARY;\n<line8>int fd = open (name, oflags | O_EXCL, MODE_RW_UGO);\n<line9>if (0 <= fd || errno != EEXIST)\n<line10>return fd;\n<line11>fd = open (name, oflags, MODE_RW_UGO);\n<line12>if (fd < 0)\n<line13>return fd;\n<line14>struct stat out_stat_buf;\n<line15>if (fstat (fd, &out_stat_buf) != 0)\n<line16>error (EXIT_FAILURE, errno, _("failed to stat %s"), quoteaf (name));\n<line17>if (SAME_INODE (in_stat_buf, out_stat_buf))\n<line18>error (EXIT_FAILURE, 0, _("%s would overwrite input; aborting"),\n<line19>quoteaf (name));\n<line20>bool regularish\n<line21>= S_ISREG (out_stat_buf.st_mode) || S_TYPEISSHM (&out_stat_buf);\n<line22>if (! (regularish && out_stat_buf.st_size == 0)\n<line23>&& ftruncate (fd, 0) < 0 && regularish)\n<line24>error (EXIT_FAILURE, errno, _("%s: error truncating"), quotef (name));\n<line25>return fd;\n<line26>}\n<line27>else\n<line28>{\n<line29>int fd_pair[2];\n<line30>pid_t child_pid;\n<line31>char const *shell_prog = getenv ("SHELL");\n<line32>if (shell_prog == nullptr)\n<line33>shell_prog = "/bin/sh";\n<line34>if (setenv ("FILE", name, 1) != 0)\n<line35>error (EXIT_FAILURE, errno,\n<line36>_("failed to set FILE environment variable"));\n<line37>if (verbose)\n<line38>fprintf (stdout, _("executing with FILE=%s\n"), quotef (name));\n<line39>if (pipe (fd_pair) != 0)\n<line40>error (EXIT_FAILURE, errno, _("failed to create pipe"));\n<line41>child_pid = fork ();\n<line42>if (child_pid == 0)\n<line43>{\n<line44>/* This is the child process.  If an error occurs here, the\n<line45>parent will eventually learn about it after doing a wait,\n<line46>at which time it will emit its own error message.  */\n<line47>int j;\n<line48>/* We have to close any pipes that were opened during an\n<line49>earlier call, otherwise this process will be holding a\n<line50>write-pipe that will prevent the earlier process from\n<line51>reading an EOF on the corresponding read-pipe.  */\n<line52>for (j = 0; j < n_open_pipes; ++j)\n<line53>if (close (open_pipes[j]) != 0)\n<line54>error (EXIT_FAILURE, errno, _("closing prior pipe"));\n<line55>if (close (fd_pair[1]))\n<line56>error (EXIT_FAILURE, errno, _("closing output pipe"));\n<line57>if (fd_pair[0] != STDIN_FILENO)\n<line58>{\n<line59>if (dup2 (fd_pair[0], STDIN_FILENO) != STDIN_FILENO)\n<line60>error (EXIT_FAILURE, errno, _("moving input pipe"));\n<line61>if (close (fd_pair[0]) != 0)\n<line62>error (EXIT_FAILURE, errno, _("closing input pipe"));\n<line63>}\n<line64>if (default_SIGPIPE)\n<line65>signal (SIGPIPE, SIG_DFL);\n<line66>execl (shell_prog, last_component (shell_prog), "-c",\n<line67>filter_command, (char *) nullptr);\n<line68>error (EXIT_FAILURE, errno, _("failed to run command: \"%s -c %s\""),\n<line69>shell_prog, filter_command);\n<line70>}\n<line71>if (child_pid < 0)\n<line72>error (EXIT_FAILURE, errno, _("fork system call failed"));\n<line73>if (close (fd_pair[0]) != 0)\n<line74>error (EXIT_FAILURE, errno, _("failed to close input pipe"));\n<line75>filter_pid = child_pid;\n<line76>if (n_open_pipes == open_pipes_alloc)\n<line77>open_pipes = xpalloc (open_pipes, &open_pipes_alloc, 1,\n<line78>MIN (INT_MAX, IDX_MAX), sizeof *open_pipes);\n<line79>open_pipes[n_open_pipes++] = fd_pair[1];\n<line80>return fd_pair[1];\n<line81>}\n<line82>}
----------------------------------------
Function: closeout
Content: <line0>static void\n<line1>closeout (FILE *fp, int fd, pid_t pid, char const *name)\n<line2>{\n<line3>if (fp != nullptr && fclose (fp) != 0 && ! ignorable (errno))\n<line4>error (EXIT_FAILURE, errno, "%s", quotef (name));\n<line5>if (fd >= 0)\n<line6>{\n<line7>if (fp == nullptr && close (fd) < 0)\n<line8>error (EXIT_FAILURE, errno, "%s", quotef (name));\n<line9>int j;\n<line10>for (j = 0; j < n_open_pipes; ++j)\n<line11>{\n<line12>if (open_pipes[j] == fd)\n<line13>{\n<line14>open_pipes[j] = open_pipes[--n_open_pipes];\n<line15>break;\n<line16>}\n<line17>}\n<line18>}\n<line19>if (pid > 0)\n<line20>{\n<line21>int wstatus;\n<line22>if (waitpid (pid, &wstatus, 0) < 0)\n<line23>error (EXIT_FAILURE, errno, _("waiting for child process"));\n<line24>else if (WIFSIGNALED (wstatus))\n<line25>{\n<line26>int sig = WTERMSIG (wstatus);\n<line27>if (sig != SIGPIPE)\n<line28>{\n<line29>char signame[MAX (SIG2STR_MAX, INT_BUFSIZE_BOUND (int))];\n<line30>if (sig2str (sig, signame) != 0)\n<line31>sprintf (signame, "%d", sig);\n<line32>error (sig + 128, 0,\n<line33>_("with FILE=%s, signal %s from command: %s"),\n<line34>quotef (name), signame, filter_command);\n<line35>}\n<line36>}\n<line37>else if (WIFEXITED (wstatus))\n<line38>{\n<line39>int ex = WEXITSTATUS (wstatus);\n<line40>if (ex != 0)\n<line41>error (ex, 0, _("with FILE=%s, exit %d from command: %s"),\n<line42>quotef (name), ex, filter_command);\n<line43>}\n<line44>else\n<line45>{\n<line46>/* shouldn't happen.  */\n<line47>error (EXIT_FAILURE, 0,\n<line48>_("unknown status from command (0x%X)"), wstatus + 0u);\n<line49>}\n<line50>}\n<line51>}
----------------------------------------
Function: cwrite
Content: <line0>static bool\n<line1>cwrite (bool new_file_flag, char const *bp, idx_t bytes)\n<line2>{\n<line3>if (new_file_flag)\n<line4>{\n<line5>if (!bp && bytes == 0 && elide_empty_files)\n<line6>return true;\n<line7>closeout (nullptr, output_desc, filter_pid, outfile);\n<line8>next_file_name ();\n<line9>output_desc = create (outfile);\n<line10>if (output_desc < 0)\n<line11>error (EXIT_FAILURE, errno, "%s", quotef (outfile));\n<line12>}\n<line13>if (full_write (output_desc, bp, bytes) == bytes)\n<line14>return true;\n<line15>else\n<line16>{\n<line17>if (! ignorable (errno))\n<line18>error (EXIT_FAILURE, errno, "%s", quotef (outfile));\n<line19>return false;\n<line20>}\n<line21>}
----------------------------------------
Function: bytes_split
Content: <line0>static void\n<line1>bytes_split (intmax_t n_bytes, intmax_t rem_bytes,\n<line2>char *buf, idx_t bufsize, ssize_t initial_read,\n<line3>intmax_t max_files)\n<line4>{\n<line5>bool new_file_flag = true;\n<line6>bool filter_ok = true;\n<line7>intmax_t opened = 0;\n<line8>intmax_t to_write = n_bytes + (0 < rem_bytes);\n<line9>bool eof = ! to_write;\n<line10>while (! eof)\n<line11>{\n<line12>ssize_t n_read;\n<line13>if (0 <= initial_read)\n<line14>{\n<line15>n_read = initial_read;\n<line16>initial_read = -1;\n<line17>eof = n_read < bufsize;\n<line18>}\n<line19>else\n<line20>{\n<line21>if (! filter_ok\n<line22>&& 0 <= lseek (STDIN_FILENO, to_write, SEEK_CUR))\n<line23>{\n<line24>to_write = n_bytes + (opened + 1 < rem_bytes);\n<line25>new_file_flag = true;\n<line26>}\n<line27>n_read = read (STDIN_FILENO, buf, bufsize);\n<line28>if (n_read < 0)\n<line29>error (EXIT_FAILURE, errno, "%s", quotef (infile));\n<line30>eof = n_read == 0;\n<line31>}\n<line32>char *bp_out = buf;\n<line33>while (0 < to_write && to_write <= n_read)\n<line34>{\n<line35>if (filter_ok || new_file_flag)\n<line36>filter_ok = cwrite (new_file_flag, bp_out, to_write);\n<line37>opened += new_file_flag;\n<line38>new_file_flag = !max_files || (opened < max_files);\n<line39>if (! filter_ok && ! new_file_flag)\n<line40>{\n<line41>/* If filters no longer accepting input, stop reading.  */\n<line42>n_read = 0;\n<line43>eof = true;\n<line44>break;\n<line45>}\n<line46>bp_out += to_write;\n<line47>n_read -= to_write;\n<line48>to_write = n_bytes + (opened < rem_bytes);\n<line49>}\n<line50>if (0 < n_read)\n<line51>{\n<line52>if (filter_ok || new_file_flag)\n<line53>filter_ok = cwrite (new_file_flag, bp_out, n_read);\n<line54>opened += new_file_flag;\n<line55>new_file_flag = false;\n<line56>if (! filter_ok && opened == max_files)\n<line57>{\n<line58>/* If filters no longer accepting input, stop reading.  */\n<line59>break;\n<line60>}\n<line61>to_write -= n_read;\n<line62>}\n<line63>}\n<line64>/* Ensure NUMBER files are created, which truncates\n<line65>any existing files or notifies any consumers on fifos.\n<line66>FIXME: Should we do this before EXIT_FAILURE?  */\n<line67>while (opened++ < max_files)\n<line68>cwrite (true, nullptr, 0);\n<line69>}
----------------------------------------
Function: lines_split
Content: <line0>static void\n<line1>lines_split (intmax_t n_lines, char *buf, idx_t bufsize)\n<line2>{\n<line3>ssize_t n_read;\n<line4>char *bp, *bp_out, *eob;\n<line5>bool new_file_flag = true;\n<line6>intmax_t n = 0;\n<line7>do\n<line8>{\n<line9>n_read = read (STDIN_FILENO, buf, bufsize);\n<line10>if (n_read < 0)\n<line11>error (EXIT_FAILURE, errno, "%s", quotef (infile));\n<line12>bp = bp_out = buf;\n<line13>eob = bp + n_read;\n<line14>*eob = eolchar;\n<line15>while (true)\n<line16>{\n<line17>bp = rawmemchr (bp, eolchar);\n<line18>if (bp == eob)\n<line19>{\n<line20>if (eob != bp_out) /* do not write 0 bytes! */\n<line21>{\n<line22>idx_t len = eob - bp_out;\n<line23>cwrite (new_file_flag, bp_out, len);\n<line24>new_file_flag = false;\n<line25>}\n<line26>break;\n<line27>}\n<line28>++bp;\n<line29>if (++n >= n_lines)\n<line30>{\n<line31>cwrite (new_file_flag, bp_out, bp - bp_out);\n<line32>bp_out = bp;\n<line33>new_file_flag = true;\n<line34>n = 0;\n<line35>}\n<line36>}\n<line37>}\n<line38>while (n_read);\n<line39>}
----------------------------------------
Function: line_bytes_split
Content: <line0>static void\n<line1>line_bytes_split (intmax_t n_bytes, char *buf, idx_t bufsize)\n<line2>{\n<line3>ssize_t n_read;\n<line4>intmax_t n_out = 0;      /* for each split.  */\n<line5>idx_t n_hold = 0;\n<line6>char *hold = nullptr;        /* for lines > bufsize.  */\n<line7>idx_t hold_size = 0;\n<line8>bool split_line = false;  /* Whether a \n was output in a split.  */\n<line9>do\n<line10>{\n<line11>n_read = read (STDIN_FILENO, buf, bufsize);\n<line12>if (n_read < 0)\n<line13>error (EXIT_FAILURE, errno, "%s", quotef (infile));\n<line14>idx_t n_left = n_read;\n<line15>char *sob = buf;\n<line16>while (n_left)\n<line17>{\n<line18>idx_t split_rest = 0;\n<line19>char *eoc = nullptr;\n<line20>char *eol;\n<line21>/* Determine End Of Chunk and/or End of Line,\n<line22>which are used below to select what to write or buffer.  */\n<line23>if (n_bytes - n_out - n_hold <= n_left)\n<line24>{\n<line25>/* Have enough for split.  */\n<line26>split_rest = n_bytes - n_out - n_hold;\n<line27>eoc = sob + split_rest - 1;\n<line28>eol = memrchr (sob, eolchar, split_rest);\n<line29>}\n<line30>else\n<line31>eol = memrchr (sob, eolchar, n_left);\n<line32>/* Output hold space if possible.  */\n<line33>if (n_hold && !(!eol && n_out))\n<line34>{\n<line35>cwrite (n_out == 0, hold, n_hold);\n<line36>n_out += n_hold;\n<line37>if (n_hold > bufsize)\n<line38>hold = xirealloc (hold, bufsize);\n<line39>n_hold = 0;\n<line40>hold_size = bufsize;\n<line41>}\n<line42>/* Output to eol if present.  */\n<line43>if (eol)\n<line44>{\n<line45>split_line = true;\n<line46>idx_t n_write = eol - sob + 1;\n<line47>cwrite (n_out == 0, sob, n_write);\n<line48>n_out += n_write;\n<line49>n_left -= n_write;\n<line50>sob += n_write;\n<line51>if (eoc)\n<line52>split_rest -= n_write;\n<line53>}\n<line54>/* Output to eoc or eob if possible.  */\n<line55>if (n_left && !split_line)\n<line56>{\n<line57>idx_t n_write = eoc ? split_rest : n_left;\n<line58>cwrite (n_out == 0, sob, n_write);\n<line59>n_out += n_write;\n<line60>n_left -= n_write;\n<line61>sob += n_write;\n<line62>if (eoc)\n<line63>split_rest -= n_write;\n<line64>}\n<line65>/* Update hold if needed.  */\n<line66>if ((eoc && split_rest) || (!eoc && n_left))\n<line67>{\n<line68>idx_t n_buf = eoc ? split_rest : n_left;\n<line69>if (hold_size - n_hold < n_buf)\n<line70>hold = xpalloc (hold, &hold_size, n_buf - (hold_size - n_hold),\n<line71>-1, sizeof *hold);\n<line72>memcpy (hold + n_hold, sob, n_buf);\n<line73>n_hold += n_buf;\n<line74>n_left -= n_buf;\n<line75>sob += n_buf;\n<line76>}\n<line77>/* Reset for new split.  */\n<line78>if (eoc)\n<line79>{\n<line80>n_out = 0;\n<line81>split_line = false;\n<line82>}\n<line83>}\n<line84>}\n<line85>while (n_read);\n<line86>/* Handle no eol at end of file.  */\n<line87>if (n_hold)\n<line88>cwrite (n_out == 0, hold, n_hold);\n<line89>free (hold);\n<line90>}
----------------------------------------
Function: lines_chunk_split
Content: <line0>static void\n<line1>lines_chunk_split (intmax_t k, intmax_t n, char *buf, idx_t bufsize,\n<line2>ssize_t initial_read, off_t file_size)\n<line3>{\n<line4>affirm (n && k <= n);\n<line5>intmax_t rem_bytes = file_size % n;\n<line6>off_t chunk_size = file_size / n;\n<line7>intmax_t chunk_no = 1;\n<line8>off_t chunk_end = chunk_size + (0 < rem_bytes);\n<line9>off_t n_written = 0;\n<line10>bool new_file_flag = true;\n<line11>bool chunk_truncated = false;\n<line12>if (k > 1 && 0 < file_size)\n<line13>{\n<line14>/* Start reading 1 byte before kth chunk of file.  */\n<line15>off_t start = (k - 1) * chunk_size + MIN (k - 1, rem_bytes) - 1;\n<line16>if (start < initial_read)\n<line17>{\n<line18>memmove (buf, buf + start, initial_read - start);\n<line19>initial_read -= start;\n<line20>}\n<line21>else\n<line22>{\n<line23>if (initial_read < start\n<line24>&& lseek (STDIN_FILENO, start - initial_read, SEEK_CUR) < 0)\n<line25>error (EXIT_FAILURE, errno, "%s", quotef (infile));\n<line26>initial_read = -1;\n<line27>}\n<line28>n_written = start;\n<line29>chunk_no = k - 1;\n<line30>chunk_end = start + 1;\n<line31>}\n<line32>while (n_written < file_size)\n<line33>{\n<line34>char *bp = buf, *eob;\n<line35>ssize_t n_read;\n<line36>if (0 <= initial_read)\n<line37>{\n<line38>n_read = initial_read;\n<line39>initial_read = -1;\n<line40>}\n<line41>else\n<line42>{\n<line43>n_read = read (STDIN_FILENO, buf,\n<line44>MIN (bufsize, file_size - n_written));\n<line45>if (n_read < 0)\n<line46>error (EXIT_FAILURE, errno, "%s", quotef (infile));\n<line47>}\n<line48>if (n_read == 0)\n<line49>break; /* eof.  */\n<line50>chunk_truncated = false;\n<line51>eob = buf + n_read;\n<line52>while (bp != eob)\n<line53>{\n<line54>idx_t to_write;\n<line55>bool next = false;\n<line56>/* Begin looking for '\n' at last byte of chunk.  */\n<line57>off_t skip = MIN (n_read, MAX (0, chunk_end - 1 - n_written));\n<line58>char *bp_out = memchr (bp + skip, eolchar, n_read - skip);\n<line59>if (bp_out)\n<line60>{\n<line61>bp_out++;\n<line62>next = true;\n<line63>}\n<line64>else\n<line65>bp_out = eob;\n<line66>to_write = bp_out - bp;\n<line67>if (k == chunk_no)\n<line68>{\n<line69>/* We don't use the stdout buffer here since we're writing\n<line70>large chunks from an existing file, so it's more efficient\n<line71>to write out directly.  */\n<line72>if (full_write (STDOUT_FILENO, bp, to_write) != to_write)\n<line73>write_error ();\n<line74>}\n<line75>else if (! k)\n<line76>cwrite (new_file_flag, bp, to_write);\n<line77>n_written += to_write;\n<line78>bp += to_write;\n<line79>n_read -= to_write;\n<line80>new_file_flag = next;\n<line81>/* A line could have been so long that it skipped\n<line82>entire chunks. So create empty files in that case.  */\n<line83>while (next || chunk_end <= n_written)\n<line84>{\n<line85>if (!next && bp == eob)\n<line86>{\n<line87>/* replenish buf, before going to next chunk.  */\n<line88>chunk_truncated = true;\n<line89>break;\n<line90>}\n<line91>if (k == chunk_no)\n<line92>return;\n<line93>chunk_end += chunk_size + (chunk_no < rem_bytes);\n<line94>chunk_no++;\n<line95>if (chunk_end <= n_written)\n<line96>{\n<line97>if (! k)\n<line98>cwrite (true, nullptr, 0);\n<line99>}\n<line100>else\n<line101>next = false;\n<line102>}\n<line103>}\n<line104>}\n<line105>if (chunk_truncated)\n<line106>chunk_no++;\n<line107>/* Ensure NUMBER files are created, which truncates\n<line108>any existing files or notifies any consumers on fifos.\n<line109>FIXME: Should we do this before EXIT_FAILURE?  */\n<line110>if (!k)\n<line111>while (chunk_no++ <= n)\n<line112>cwrite (true, nullptr, 0);\n<line113>}
----------------------------------------
Function: bytes_chunk_extract
Content: <line0>static void\n<line1>bytes_chunk_extract (intmax_t k, intmax_t n, char *buf, idx_t bufsize,\n<line2>ssize_t initial_read, off_t file_size)\n<line3>{\n<line4>off_t start;\n<line5>off_t end;\n<line6>assert (0 < k && k <= n);\n<line7>start = (k - 1) * (file_size / n) + MIN (k - 1, file_size % n);\n<line8>end = k == n ? file_size : k * (file_size / n) + MIN (k, file_size % n);\n<line9>if (start < initial_read)\n<line10>{\n<line11>memmove (buf, buf + start, initial_read - start);\n<line12>initial_read -= start;\n<line13>}\n<line14>else\n<line15>{\n<line16>if (initial_read < start\n<line17>&& lseek (STDIN_FILENO, start - initial_read, SEEK_CUR) < 0)\n<line18>error (EXIT_FAILURE, errno, "%s", quotef (infile));\n<line19>initial_read = -1;\n<line20>}\n<line21>while (start < end)\n<line22>{\n<line23>ssize_t n_read;\n<line24>if (0 <= initial_read)\n<line25>{\n<line26>n_read = initial_read;\n<line27>initial_read = -1;\n<line28>}\n<line29>else\n<line30>{\n<line31>n_read = read (STDIN_FILENO, buf, bufsize);\n<line32>if (n_read < 0)\n<line33>error (EXIT_FAILURE, errno, "%s", quotef (infile));\n<line34>}\n<line35>if (n_read == 0)\n<line36>break; /* eof.  */\n<line37>n_read = MIN (n_read, end - start);\n<line38>if (full_write (STDOUT_FILENO, buf, n_read) != n_read\n<line39>&& ! ignorable (errno))\n<line40>error (EXIT_FAILURE, errno, "%s", quotef ("-"));\n<line41>start += n_read;\n<line42>}\n<line43>}
----------------------------------------
Function: ofile_open
Content: <line0>static bool\n<line1>ofile_open (of_t *files, idx_t i_check, idx_t nfiles)\n<line2>{\n<line3>bool file_limit = false;\n<line4>if (files[i_check].ofd <= OFD_NEW)\n<line5>{\n<line6>int fd;\n<line7>idx_t i_reopen = i_check ? i_check - 1 : nfiles - 1;\n<line8>/* Another process could have opened a file in between the calls to\n<line9>close and open, so we should keep trying until open succeeds or\n<line10>we've closed all of our files.  */\n<line11>while (true)\n<line12>{\n<line13>if (files[i_check].ofd == OFD_NEW)\n<line14>fd = create (files[i_check].of_name);\n<line15>else /* OFD_APPEND  */\n<line16>{\n<line17>/* Attempt to append to previously opened file.\n<line18>We use O_NONBLOCK to support writing to fifos,\n<line19>where the other end has closed because of our\n<line20>previous close.  In that case we'll immediately\n<line21>get an error, rather than waiting indefinitely.\n<line22>In specialized cases the consumer can keep reading\n<line23>from the fifo, terminating on conditions in the data\n<line24>itself, or perhaps never in the case of 'tail -f'.\n<line25>I.e., for fifos it is valid to attempt this reopen.\n<line26>We don't handle the filter_command case here, as create()\n<line27>will exit if there are not enough files in that case.\n<line28>I.e., we don't support restarting filters, as that would\n<line29>put too much burden on users specifying --filter commands.  */\n<line30>fd = open (files[i_check].of_name,\n<line31>O_WRONLY | O_BINARY | O_APPEND | O_NONBLOCK);\n<line32>}\n<line33>if (0 <= fd)\n<line34>break;\n<line35>if (!(errno == EMFILE || errno == ENFILE))\n<line36>error (EXIT_FAILURE, errno, "%s", quotef (files[i_check].of_name));\n<line37>file_limit = true;\n<line38>/* Search backwards for an open file to close.  */\n<line39>while (files[i_reopen].ofd < 0)\n<line40>{\n<line41>i_reopen = i_reopen ? i_reopen - 1 : nfiles - 1;\n<line42>/* No more open files to close, exit with E[NM]FILE.  */\n<line43>if (i_reopen == i_check)\n<line44>error (EXIT_FAILURE, errno, "%s",\n<line45>quotef (files[i_check].of_name));\n<line46>}\n<line47>if (fclose (files[i_reopen].ofile) != 0)\n<line48>error (EXIT_FAILURE, errno, "%s", quotef (files[i_reopen].of_name));\n<line49>files[i_reopen].ofile = nullptr;\n<line50>files[i_reopen].ofd = OFD_APPEND;\n<line51>}\n<line52>files[i_check].ofd = fd;\n<line53>FILE *ofile = fdopen (fd, "a");\n<line54>if (!ofile)\n<line55>error (EXIT_FAILURE, errno, "%s", quotef (files[i_check].of_name));\n<line56>files[i_check].ofile = ofile;\n<line57>files[i_check].opid = filter_pid;\n<line58>filter_pid = 0;\n<line59>}\n<line60>return file_limit;\n<line61>}
----------------------------------------
Function: lines_rr
Content: <line0>static void\n<line1>lines_rr (intmax_t k, intmax_t n, char *buf, idx_t bufsize, of_t **filesp)\n<line2>{\n<line3>bool wrapped = false;\n<line4>bool wrote = false;\n<line5>bool file_limit;\n<line6>idx_t i_file;\n<line7>of_t *files IF_LINT (= nullptr);\n<line8>intmax_t line_no;\n<line9>if (k)\n<line10>line_no = 1;\n<line11>else\n<line12>{\n<line13>if (IDX_MAX < n)\n<line14>xalloc_die ();\n<line15>files = *filesp = xinmalloc (n, sizeof *files);\n<line16>/* Generate output file names. */\n<line17>for (i_file = 0; i_file < n; i_file++)\n<line18>{\n<line19>next_file_name ();\n<line20>files[i_file].of_name = xstrdup (outfile);\n<line21>files[i_file].ofd = OFD_NEW;\n<line22>files[i_file].ofile = nullptr;\n<line23>files[i_file].opid = 0;\n<line24>}\n<line25>i_file = 0;\n<line26>file_limit = false;\n<line27>}\n<line28>while (true)\n<line29>{\n<line30>char *bp = buf, *eob;\n<line31>ssize_t n_read = read (STDIN_FILENO, buf, bufsize);\n<line32>if (n_read < 0)\n<line33>error (EXIT_FAILURE, errno, "%s", quotef (infile));\n<line34>else if (n_read == 0)\n<line35>break; /* eof.  */\n<line36>eob = buf + n_read;\n<line37>while (bp != eob)\n<line38>{\n<line39>idx_t to_write;\n<line40>bool next = false;\n<line41>/* Find end of line. */\n<line42>char *bp_out = memchr (bp, eolchar, eob - bp);\n<line43>if (bp_out)\n<line44>{\n<line45>bp_out++;\n<line46>next = true;\n<line47>}\n<line48>else\n<line49>bp_out = eob;\n<line50>to_write = bp_out - bp;\n<line51>if (k)\n<line52>{\n<line53>if (line_no == k && unbuffered)\n<line54>{\n<line55>if (full_write (STDOUT_FILENO, bp, to_write) != to_write)\n<line56>write_error ();\n<line57>}\n<line58>else if (line_no == k && fwrite (bp, to_write, 1, stdout) != 1)\n<line59>{\n<line60>write_error ();\n<line61>}\n<line62>if (next)\n<line63>line_no = (line_no == n) ? 1 : line_no + 1;\n<line64>}\n<line65>else\n<line66>{\n<line67>/* Secure file descriptor. */\n<line68>file_limit |= ofile_open (files, i_file, n);\n<line69>if (unbuffered)\n<line70>{\n<line71>/* Note writing to fd, rather than flushing the FILE gives\n<line72>an 8% performance benefit, due to reduced data copying.  */\n<line73>if (full_write (files[i_file].ofd, bp, to_write) != to_write\n<line74>&& ! ignorable (errno))\n<line75>error (EXIT_FAILURE, errno, "%s",\n<line76>quotef (files[i_file].of_name));\n<line77>}\n<line78>else if (fwrite (bp, to_write, 1, files[i_file].ofile) != 1\n<line79>&& ! ignorable (errno))\n<line80>error (EXIT_FAILURE, errno, "%s",\n<line81>quotef (files[i_file].of_name));\n<line82>if (! ignorable (errno))\n<line83>wrote = true;\n<line84>if (file_limit)\n<line85>{\n<line86>if (fclose (files[i_file].ofile) != 0)\n<line87>error (EXIT_FAILURE, errno, "%s",\n<line88>quotef (files[i_file].of_name));\n<line89>files[i_file].ofile = nullptr;\n<line90>files[i_file].ofd = OFD_APPEND;\n<line91>}\n<line92>if (next && ++i_file == n)\n<line93>{\n<line94>wrapped = true;\n<line95>/* If no filters are accepting input, stop reading.  */\n<line96>if (! wrote)\n<line97>goto no_filters;\n<line98>wrote = false;\n<line99>i_file = 0;\n<line100>}\n<line101>}\n<line102>bp = bp_out;\n<line103>}\n<line104>}\n<line105>no_filters:\n<line106>/* Ensure all files created, so that any existing files are truncated,\n<line107>and to signal any waiting fifo consumers.\n<line108>Also, close any open file descriptors.\n<line109>FIXME: Should we do this before EXIT_FAILURE?  */\n<line110>if (!k)\n<line111>{\n<line112>idx_t ceiling = wrapped ? n : i_file;\n<line113>for (i_file = 0; i_file < n; i_file++)\n<line114>{\n<line115>if (i_file >= ceiling && !elide_empty_files)\n<line116>file_limit |= ofile_open (files, i_file, n);\n<line117>if (files[i_file].ofd >= 0)\n<line118>closeout (files[i_file].ofile, files[i_file].ofd,\n<line119>files[i_file].opid, files[i_file].of_name);\n<line120>files[i_file].ofd = OFD_APPEND;\n<line121>}\n<line122>}\n<line123>}
----------------------------------------
Function: strtoint_die
Content: <line0>static _Noreturn void\n<line1>strtoint_die (char const *msgid, char const *arg)\n<line2>{\n<line3>error (EXIT_FAILURE, errno == EINVAL ? 0 : errno, "%s: %s",\n<line4>gettext (msgid), quote (arg));\n<line5>}
----------------------------------------
Function: parse_n_units
Content: <line0>static intmax_t\n<line1>parse_n_units (char const *arg, char const *multipliers, char const *msgid)\n<line2>{\n<line3>intmax_t n;\n<line4>if (OVERFLOW_OK < xstrtoimax (arg, nullptr, 10, &n, multipliers) || n < 1)\n<line5>strtoint_die (msgid, arg);\n<line6>return n;\n<line7>}
----------------------------------------
Function: parse_chunk
Content: <line0>static void\n<line1>parse_chunk (intmax_t *k_units, intmax_t *n_units, char const *arg)\n<line2>{\n<line3>char *argend;\n<line4>strtol_error e = xstrtoimax (arg, &argend, 10, n_units, "");\n<line5>if (e == LONGINT_INVALID_SUFFIX_CHAR && *argend == '/')\n<line6>{\n<line7>*k_units = *n_units;\n<line8>*n_units = parse_n_units (argend + 1, "",\n<line9>N_("invalid number of chunks"));\n<line10>if (! (0 < *k_units && *k_units <= *n_units))\n<line11>error (EXIT_FAILURE, 0, "%s: %s", _("invalid chunk number"),\n<line12>quote_mem (arg, argend - arg));\n<line13>}\n<line14>else if (! (e <= OVERFLOW_OK && 0 < *n_units))\n<line15>strtoint_die (N_("invalid number of chunks"), arg);\n<line16>}
----------------------------------------
Function: main
Content: <line0>int\n<line1>main (int argc, char **argv)\n<line2>{\n<line3>enum Split_type split_type = type_undef;\n<line4>idx_t in_blk_size = 0;	/* optimal block size of input file device */\n<line5>idx_t page_size = getpagesize ();\n<line6>intmax_t k_units = 0;\n<line7>intmax_t n_units = 0;\n<line8>static char const multipliers[] = "bEGKkMmPQRTYZ0";\n<line9>int c;\n<line10>int digits_optind = 0;\n<line11>off_t file_size = OFF_T_MAX;\n<line12>initialize_main (&argc, &argv);\n<line13>set_program_name (argv[0]);\n<line14>setlocale (LC_ALL, "");\n<line15>bindtextdomain (PACKAGE, LOCALEDIR);\n<line16>textdomain (PACKAGE);\n<line17>atexit (close_stdout);\n<line18>/* Parse command line options.  */\n<line19>infile = bad_cast ("-");\n<line20>outbase = bad_cast ("x");\n<line21>while (true)\n<line22>{\n<line23>/* This is the argv-index of the option we will read next.  */\n<line24>int this_optind = optind ? optind : 1;\n<line25>c = getopt_long (argc, argv, "0123456789C:a:b:del:n:t:ux",\n<line26>longopts, nullptr);\n<line27>if (c == -1)\n<line28>break;\n<line29>switch (c)\n<line30>{\n<line31>case 'a':\n<line32>suffix_length = xdectoimax (optarg, 0, IDX_MAX,\n<line33>"", _("invalid suffix length"), 0);\n<line34>break;\n<line35>case ADDITIONAL_SUFFIX_OPTION:\n<line36>{\n<line37>int suffix_len = strlen (optarg);\n<line38>if (last_component (optarg) != optarg\n<line39>|| (suffix_len && ISSLASH (optarg[suffix_len - 1])))\n<line40>{\n<line41>error (0, 0,\n<line42>_("invalid suffix %s, contains directory separator"),\n<line43>quote (optarg));\n<line44>usage (EXIT_FAILURE);\n<line45>}\n<line46>}\n<line47>additional_suffix = optarg;\n<line48>break;\n<line49>case 'b':\n<line50>if (split_type != type_undef)\n<line51>FAIL_ONLY_ONE_WAY ();\n<line52>split_type = type_bytes;\n<line53>n_units = parse_n_units (optarg, multipliers,\n<line54>N_("invalid number of bytes"));\n<line55>break;\n<line56>case 'l':\n<line57>if (split_type != type_undef)\n<line58>FAIL_ONLY_ONE_WAY ();\n<line59>split_type = type_lines;\n<line60>n_units = parse_n_units (optarg, "", N_("invalid number of lines"));\n<line61>break;\n<line62>case 'C':\n<line63>if (split_type != type_undef)\n<line64>FAIL_ONLY_ONE_WAY ();\n<line65>split_type = type_byteslines;\n<line66>n_units = parse_n_units (optarg, multipliers,\n<line67>N_("invalid number of lines"));\n<line68>break;\n<line69>case 'n':\n<line70>if (split_type != type_undef)\n<line71>FAIL_ONLY_ONE_WAY ();\n<line72>/* skip any whitespace */\n<line73>while (isspace (to_uchar (*optarg)))\n<line74>optarg++;\n<line75>if (STRNCMP_LIT (optarg, "r/") == 0)\n<line76>{\n<line77>split_type = type_rr;\n<line78>optarg += 2;\n<line79>}\n<line80>else if (STRNCMP_LIT (optarg, "l/") == 0)\n<line81>{\n<line82>split_type = type_chunk_lines;\n<line83>optarg += 2;\n<line84>}\n<line85>else\n<line86>split_type = type_chunk_bytes;\n<line87>parse_chunk (&k_units, &n_units, optarg);\n<line88>break;\n<line89>case 'u':\n<line90>unbuffered = true;\n<line91>break;\n<line92>case 't':\n<line93>{\n<line94>char neweol = optarg[0];\n<line95>if (! neweol)\n<line96>error (EXIT_FAILURE, 0, _("empty record separator"));\n<line97>if (optarg[1])\n<line98>{\n<line99>if (STREQ (optarg, "\\0"))\n<line100>neweol = '\0';\n<line101>else\n<line102>{\n<line103>/* Provoke with 'split -txx'.  Complain about\n<line104>"multi-character tab" instead of "multibyte tab", so\n<line105>that the diagnostic's wording does not need to be\n<line106>changed once multibyte characters are supported.  */\n<line107>error (EXIT_FAILURE, 0, _("multi-character separator %s"),\n<line108>quote (optarg));\n<line109>}\n<line110>}\n<line111>/* Make it explicit we don't support multiple separators.  */\n<line112>if (0 <= eolchar && neweol != eolchar)\n<line113>{\n<line114>error (EXIT_FAILURE, 0,\n<line115>_("multiple separator characters specified"));\n<line116>}\n<line117>eolchar = neweol;\n<line118>}\n<line119>break;\n<line120>case '0':\n<line121>case '1':\n<line122>case '2':\n<line123>case '3':\n<line124>case '4':\n<line125>case '5':\n<line126>case '6':\n<line127>case '7':\n<line128>case '8':\n<line129>case '9':\n<line130>if (split_type == type_undef)\n<line131>{\n<line132>split_type = type_digits;\n<line133>n_units = 0;\n<line134>}\n<line135>if (split_type != type_undef && split_type != type_digits)\n<line136>FAIL_ONLY_ONE_WAY ();\n<line137>if (digits_optind != 0 && digits_optind != this_optind)\n<line138>n_units = 0;	/* More than one number given; ignore other. */\n<line139>digits_optind = this_optind;\n<line140>if (ckd_mul (&n_units, n_units, 10)\n<line141>|| ckd_add (&n_units, n_units, c - '0'))\n<line142>n_units = INTMAX_MAX;\n<line143>break;\n<line144>case 'd':\n<line145>case 'x':\n<line146>if (c == 'd')\n<line147>suffix_alphabet = "0123456789";\n<line148>else\n<line149>suffix_alphabet = "0123456789abcdef";\n<line150>if (optarg)\n<line151>{\n<line152>if (strlen (optarg) != strspn (optarg, suffix_alphabet))\n<line153>{\n<line154>error (0, 0,\n<line155>(c == 'd') ?\n<line156>_("%s: invalid start value for numerical suffix") :\n<line157>_("%s: invalid start value for hexadecimal suffix"),\n<line158>quote (optarg));\n<line159>usage (EXIT_FAILURE);\n<line160>}\n<line161>else\n<line162>{\n<line163>/* Skip any leading zero.  */\n<line164>while (*optarg == '0' && *(optarg + 1) != '\0')\n<line165>optarg++;\n<line166>numeric_suffix_start = optarg;\n<line167>}\n<line168>}\n<line169>break;\n<line170>case 'e':\n<line171>elide_empty_files = true;\n<line172>break;\n<line173>case FILTER_OPTION:\n<line174>filter_command = optarg;\n<line175>break;\n<line176>case IO_BLKSIZE_OPTION:\n<line177>in_blk_size = xdectoumax (optarg, 1,\n<line178>MIN (SYS_BUFSIZE_MAX,\n<line179>MIN (IDX_MAX, SIZE_MAX) - 1),\n<line180>multipliers, _("invalid IO block size"), 0);\n<line181>break;\n<line182>case VERBOSE_OPTION:\n<line183>verbose = true;\n<line184>break;\n<line185>case_GETOPT_HELP_CHAR;\n<line186>case_GETOPT_VERSION_CHAR (PROGRAM_NAME, AUTHORS);\n<line187>default:\n<line188>usage (EXIT_FAILURE);\n<line189>}\n<line190>}\n<line191>if (k_units != 0 && filter_command)\n<line192>{\n<line193>error (0, 0, _("--filter does not process a chunk extracted to stdout"));\n<line194>usage (EXIT_FAILURE);\n<line195>}\n<line196>/* Handle default case.  */\n<line197>if (split_type == type_undef)\n<line198>{\n<line199>split_type = type_lines;\n<line200>n_units = 1000;\n<line201>}\n<line202>if (n_units == 0)\n<line203>{\n<line204>error (0, 0, _("invalid number of lines: %s"), quote ("0"));\n<line205>usage (EXIT_FAILURE);\n<line206>}\n<line207>if (eolchar < 0)\n<line208>eolchar = '\n';\n<line209>set_suffix_length (n_units, split_type);\n<line210>/* Get out the filename arguments.  */\n<line211>if (optind < argc)\n<line212>infile = argv[optind++];\n<line213>if (optind < argc)\n<line214>outbase = argv[optind++];\n<line215>if (optind < argc)\n<line216>{\n<line217>error (0, 0, _("extra operand %s"), quote (argv[optind]));\n<line218>usage (EXIT_FAILURE);\n<line219>}\n<line220>/* Check that the suffix length is large enough for the numerical\n<line221>suffix start value.  */\n<line222>if (numeric_suffix_start && strlen (numeric_suffix_start) > suffix_length)\n<line223>{\n<line224>error (0, 0, _("numerical suffix start value is too large "\n<line225>"for the suffix length"));\n<line226>usage (EXIT_FAILURE);\n<line227>}\n<line228>/* Open the input file.  */\n<line229>if (! STREQ (infile, "-")\n<line230>&& fd_reopen (STDIN_FILENO, infile, O_RDONLY, 0) < 0)\n<line231>error (EXIT_FAILURE, errno, _("cannot open %s for reading"),\n<line232>quoteaf (infile));\n<line233>/* Binary I/O is safer when byte counts are used.  */\n<line234>xset_binary_mode (STDIN_FILENO, O_BINARY);\n<line235>/* Advise the kernel of our access pattern.  */\n<line236>fdadvise (STDIN_FILENO, 0, 0, FADVISE_SEQUENTIAL);\n<line237>/* Get the optimal block size of input device and make a buffer.  */\n<line238>if (fstat (STDIN_FILENO, &in_stat_buf) != 0)\n<line239>error (EXIT_FAILURE, errno, "%s", quotef (infile));\n<line240>if (in_blk_size == 0)\n<line241>{\n<line242>in_blk_size = io_blksize (in_stat_buf);\n<line243>if (SYS_BUFSIZE_MAX < in_blk_size)\n<line244>in_blk_size = SYS_BUFSIZE_MAX;\n<line245>}\n<line246>char *buf = xalignalloc (page_size, in_blk_size + 1);\n<line247>ssize_t initial_read = -1;\n<line248>if (split_type == type_chunk_bytes || split_type == type_chunk_lines)\n<line249>{\n<line250>file_size = input_file_size (STDIN_FILENO, &in_stat_buf,\n<line251>buf, in_blk_size);\n<line252>if (file_size < 0)\n<line253>error (EXIT_FAILURE, errno, _("%s: cannot determine file size"),\n<line254>quotef (infile));\n<line255>initial_read = MIN (file_size, in_blk_size);\n<line256>}\n<line257>/* When filtering, closure of one pipe must not terminate the process,\n<line258>as there may still be other streams expecting input from us.  */\n<line259>if (filter_command)\n<line260>default_SIGPIPE = signal (SIGPIPE, SIG_IGN) == SIG_DFL;\n<line261>switch (split_type)\n<line262>{\n<line263>case type_digits:\n<line264>case type_lines:\n<line265>lines_split (n_units, buf, in_blk_size);\n<line266>break;\n<line267>case type_bytes:\n<line268>bytes_split (n_units, 0, buf, in_blk_size, -1, 0);\n<line269>break;\n<line270>case type_byteslines:\n<line271>line_bytes_split (n_units, buf, in_blk_size);\n<line272>break;\n<line273>case type_chunk_bytes:\n<line274>if (k_units == 0)\n<line275>bytes_split (file_size / n_units, file_size % n_units,\n<line276>buf, in_blk_size, initial_read, n_units);\n<line277>else\n<line278>bytes_chunk_extract (k_units, n_units, buf, in_blk_size, initial_read,\n<line279>file_size);\n<line280>break;\n<line281>case type_chunk_lines:\n<line282>lines_chunk_split (k_units, n_units, buf, in_blk_size, initial_read,\n<line283>file_size);\n<line284>break;\n<line285>case type_rr:\n<line286>/* Note, this is like 'sed -n ${k}~${n}p' when k > 0,\n<line287>but the functionality is provided for symmetry.  */\n<line288>{\n<line289>of_t *files;\n<line290>lines_rr (k_units, n_units, buf, in_blk_size, &files);\n<line291>}\n<line292>break;\n<line293>default:\n<line294>affirm (false);\n<line295>}\n<line296>if (close (STDIN_FILENO) != 0)\n<line297>error (EXIT_FAILURE, errno, "%s", quotef (infile));\n<line298>closeout (nullptr, output_desc, filter_pid, outfile);\n<line299>main_exit (EXIT_SUCCESS);\n<line300>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/src/temp-stream.c
========================================
Function: record_or_unlink_tempfile
Content: <line0>static void\n<line1>record_or_unlink_tempfile (char const *fn, MAYBE_UNUSED FILE *fp)\n<line2>{\n<line3>unlink (fn);\n<line4>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/src/stat.c
========================================
/home/huihui/Downloads/coreutils-9.4/src/stat.c:878:75: warning: '_Static_assert' with no message is a C2x extension [-Wc2x-extensions]
        static_assert (alignof (STRUCT_STATVFS) % alignof (fsid_word) == 0);
                                                                          ^
                                                                          , ""
/home/huihui/Downloads/coreutils-9.4/src/stat.c:880:28: warning: '_Static_assert' with no message is a C2x extension [-Wc2x-extensions]
                       == 0);
                           ^
                           , ""
/home/huihui/Downloads/coreutils-9.4/src/stat.c:881:75: warning: '_Static_assert' with no message is a C2x extension [-Wc2x-extensions]
        static_assert (sizeof statfsbuf->f_fsid % alignof (fsid_word) == 0);
                                                                          ^
                                                                          , ""
3 warnings generated.
Function: make_format
Content: <line0>static void\n<line1>make_format (char *pformat, size_t prefix_len, char const *allowed_flags,\n<line2>char const *suffix)\n<line3>{\n<line4>char *dst = pformat + 1;\n<line5>char const *src;\n<line6>char const *srclim = pformat + prefix_len;\n<line7>for (src = dst; src < srclim && strchr (printf_flags, *src); src++)\n<line8>if (strchr (allowed_flags, *src))\n<line9>*dst++ = *src;\n<line10>while (src < srclim)\n<line11>*dst++ = *src++;\n<line12>strcpy (dst, suffix);\n<line13>}
----------------------------------------
Function: out_string
Content: <line0>static void\n<line1>out_string (char *pformat, size_t prefix_len, char const *arg)\n<line2>{\n<line3>make_format (pformat, prefix_len, "-", "s");\n<line4>printf (pformat, arg);\n<line5>}
----------------------------------------
Function: out_int
Content: <line0>static int\n<line1>out_int (char *pformat, size_t prefix_len, intmax_t arg)\n<line2>{\n<line3>make_format (pformat, prefix_len, "'-+ 0", PRIdMAX);\n<line4>return printf (pformat, arg);\n<line5>}
----------------------------------------
Function: out_uint
Content: <line0>static int\n<line1>out_uint (char *pformat, size_t prefix_len, uintmax_t arg)\n<line2>{\n<line3>make_format (pformat, prefix_len, "'-0", PRIuMAX);\n<line4>return printf (pformat, arg);\n<line5>}
----------------------------------------
Function: out_uint_o
Content: <line0>static void\n<line1>out_uint_o (char *pformat, size_t prefix_len, uintmax_t arg)\n<line2>{\n<line3>make_format (pformat, prefix_len, "-#0", PRIoMAX);\n<line4>printf (pformat, arg);\n<line5>}
----------------------------------------
Function: out_uint_x
Content: <line0>static void\n<line1>out_uint_x (char *pformat, size_t prefix_len, uintmax_t arg)\n<line2>{\n<line3>make_format (pformat, prefix_len, "-#0", PRIxMAX);\n<line4>printf (pformat, arg);\n<line5>}
----------------------------------------
Function: out_minus_zero
Content: <line0>static int\n<line1>out_minus_zero (char *pformat, size_t prefix_len)\n<line2>{\n<line3>make_format (pformat, prefix_len, "'-+ 0", ".0f");\n<line4>return printf (pformat, -0.25);\n<line5>}
----------------------------------------
Function: out_epoch_sec
Content: <line0>static void\n<line1>out_epoch_sec (char *pformat, size_t prefix_len,\n<line2>struct timespec arg)\n<line3>{\n<line4>char *dot = memchr (pformat, '.', prefix_len);\n<line5>size_t sec_prefix_len = prefix_len;\n<line6>int width = 0;\n<line7>int precision = 0;\n<line8>bool frac_left_adjust = false;\n<line9>if (dot)\n<line10>{\n<line11>sec_prefix_len = dot - pformat;\n<line12>pformat[prefix_len] = '\0';\n<line13>if (ISDIGIT (dot[1]))\n<line14>{\n<line15>long int lprec = strtol (dot + 1, nullptr, 10);\n<line16>precision = (lprec <= INT_MAX ? lprec : INT_MAX);\n<line17>}\n<line18>else\n<line19>{\n<line20>precision = 9;\n<line21>}\n<line22>if (precision && ISDIGIT (dot[-1]))\n<line23>{\n<line24>/* If a nontrivial width is given, subtract the width of the\n<line25>decimal point and PRECISION digits that will be output\n<line26>later.  */\n<line27>char *p = dot;\n<line28>*dot = '\0';\n<line29>do\n<line30>--p;\n<line31>while (ISDIGIT (p[-1]));\n<line32>long int lwidth = strtol (p, nullptr, 10);\n<line33>width = (lwidth <= INT_MAX ? lwidth : INT_MAX);\n<line34>if (1 < width)\n<line35>{\n<line36>p += (*p == '0');\n<line37>sec_prefix_len = p - pformat;\n<line38>int w_d = (decimal_point_len < width\n<line39>? width - decimal_point_len\n<line40>: 0);\n<line41>if (1 < w_d)\n<line42>{\n<line43>int w = w_d - precision;\n<line44>if (1 < w)\n<line45>{\n<line46>char *dst = pformat;\n<line47>for (char const *src = dst; src < p; src++)\n<line48>{\n<line49>if (*src == '-')\n<line50>frac_left_adjust = true;\n<line51>else\n<line52>*dst++ = *src;\n<line53>}\n<line54>sec_prefix_len =\n<line55>(dst - pformat\n<line56>+ (frac_left_adjust ? 0 : sprintf (dst, "%d", w)));\n<line57>}\n<line58>}\n<line59>}\n<line60>}\n<line61>}\n<line62>int divisor = 1;\n<line63>for (int i = precision; i < 9; i++)\n<line64>divisor *= 10;\n<line65>int frac_sec = arg.tv_nsec / divisor;\n<line66>int int_len;\n<line67>if (TYPE_SIGNED (time_t))\n<line68>{\n<line69>bool minus_zero = false;\n<line70>if (arg.tv_sec < 0 && arg.tv_nsec != 0)\n<line71>{\n<line72>int frac_sec_modulus = 1000000000 / divisor;\n<line73>frac_sec = (frac_sec_modulus - frac_sec\n<line74>- (arg.tv_nsec % divisor != 0));\n<line75>arg.tv_sec += (frac_sec != 0);\n<line76>minus_zero = (arg.tv_sec == 0);\n<line77>}\n<line78>int_len = (minus_zero\n<line79>? out_minus_zero (pformat, sec_prefix_len)\n<line80>: out_int (pformat, sec_prefix_len, arg.tv_sec));\n<line81>}\n<line82>else\n<line83>int_len = out_uint (pformat, sec_prefix_len, arg.tv_sec);\n<line84>if (precision)\n<line85>{\n<line86>int prec = (precision < 9 ? precision : 9);\n<line87>int trailing_prec = precision - prec;\n<line88>int ilen = (int_len < 0 ? 0 : int_len);\n<line89>int trailing_width = (ilen < width && decimal_point_len < width - ilen\n<line90>? width - ilen - decimal_point_len - prec\n<line91>: 0);\n<line92>printf ("%s%.*d%-*.*d", decimal_point, prec, frac_sec,\n<line93>trailing_width, trailing_prec, 0);\n<line94>}\n<line95>}
----------------------------------------
Function: neg_to_zero
Content: <line0>static inline struct timespec\n<line1>neg_to_zero (struct timespec ts)\n<line2>{\n<line3>if (0 <= ts.tv_nsec)\n<line4>return ts;\n<line5>struct timespec z = {0, 0};\n<line6>return z;\n<line7>}
----------------------------------------
Function: getenv_quoting_style
Content: <line0>static void\n<line1>getenv_quoting_style (void)\n<line2>{\n<line3>char const *q_style = getenv ("QUOTING_STYLE");\n<line4>if (q_style)\n<line5>{\n<line6>int i = ARGMATCH (q_style, quoting_style_args, quoting_style_vals);\n<line7>if (0 <= i)\n<line8>set_quoting_style (nullptr, quoting_style_vals[i]);\n<line9>else\n<line10>{\n<line11>set_quoting_style (nullptr, shell_escape_always_quoting_style);\n<line12>error (0, 0, _("ignoring invalid value of environment "\n<line13>"variable QUOTING_STYLE: %s"), quote (q_style));\n<line14>}\n<line15>}\n<line16>else\n<line17>set_quoting_style (nullptr, shell_escape_always_quoting_style);\n<line18>}
----------------------------------------
Function: print_esc_char
Content: <line0>static void\n<line1>print_esc_char (char c)\n<line2>{\n<line3>switch (c)\n<line4>{\n<line5>case 'a':			/* Alert. */\n<line6>c ='\a';\n<line7>break;\n<line8>case 'b':			/* Backspace. */\n<line9>c ='\b';\n<line10>break;\n<line11>case 'e':			/* Escape. */\n<line12>c ='\x1B';\n<line13>break;\n<line14>case 'f':			/* Form feed. */\n<line15>c ='\f';\n<line16>break;\n<line17>case 'n':			/* New line. */\n<line18>c ='\n';\n<line19>break;\n<line20>case 'r':			/* Carriage return. */\n<line21>c ='\r';\n<line22>break;\n<line23>case 't':			/* Horizontal tab. */\n<line24>c ='\t';\n<line25>break;\n<line26>case 'v':			/* Vertical tab. */\n<line27>c ='\v';\n<line28>break;\n<line29>case '"':\n<line30>case '\\':\n<line31>break;\n<line32>default:\n<line33>error (0, 0, _("warning: unrecognized escape '\\%c'"), c);\n<line34>break;\n<line35>}\n<line36>putchar (c);\n<line37>}
----------------------------------------
Function: fmt_to_mask
Content: <line0>static unsigned int\n<line1>fmt_to_mask (char fmt)\n<line2>{\n<line3>switch (fmt)\n<line4>{\n<line5>case 'N':\n<line6>return STATX_MODE;\n<line7>case 'd':\n<line8>case 'D':\n<line9>return STATX_MODE;\n<line10>case 'i':\n<line11>return STATX_INO;\n<line12>case 'a':\n<line13>case 'A':\n<line14>return STATX_MODE;\n<line15>case 'f':\n<line16>return STATX_MODE|STATX_TYPE;\n<line17>case 'F':\n<line18>return STATX_TYPE;\n<line19>case 'h':\n<line20>return STATX_NLINK;\n<line21>case 'u':\n<line22>case 'U':\n<line23>return STATX_UID;\n<line24>case 'g':\n<line25>case 'G':\n<line26>return STATX_GID;\n<line27>case 'm':\n<line28>return STATX_MODE|STATX_INO;\n<line29>case 's':\n<line30>return STATX_SIZE;\n<line31>case 't':\n<line32>case 'T':\n<line33>return STATX_MODE;\n<line34>case 'b':\n<line35>return STATX_BLOCKS;\n<line36>case 'w':\n<line37>case 'W':\n<line38>return STATX_BTIME;\n<line39>case 'x':\n<line40>case 'X':\n<line41>return STATX_ATIME;\n<line42>case 'y':\n<line43>case 'Y':\n<line44>return STATX_MTIME;\n<line45>case 'z':\n<line46>case 'Z':\n<line47>return STATX_CTIME;\n<line48>}\n<line49>return 0;\n<line50>}
----------------------------------------
Function: unsigned_file_size
Content: <line0>static uintmax_t\n<line1>unsigned_file_size (off_t size)\n<line2>{\n<line3>return size + (size < 0) * ((uintmax_t) OFF_T_MAX - OFF_T_MIN + 1);\n<line4>}
----------------------------------------
Function: print_stat
Content: <line0>static bool\n<line1>print_stat (char *pformat, size_t prefix_len, char mod, char m,\n<line2>int fd, char const *filename, void const *data)\n<line3>{\n<line4>struct print_args *parg = (struct print_args *) data;\n<line5>struct stat *statbuf = parg->st;\n<line6>struct timespec btime = parg->btime;\n<line7>struct passwd *pw_ent;\n<line8>struct group *gw_ent;\n<line9>bool fail = false;\n<line10>switch (m)\n<line11>{\n<line12>case 'n':\n<line13>out_string (pformat, prefix_len, filename);\n<line14>break;\n<line15>case 'N':\n<line16>out_string (pformat, prefix_len, quoteN (filename));\n<line17>if (S_ISLNK (statbuf->st_mode))\n<line18>{\n<line19>char *linkname = areadlink_with_size (filename, statbuf->st_size);\n<line20>if (linkname == nullptr)\n<line21>{\n<line22>error (0, errno, _("cannot read symbolic link %s"),\n<line23>quoteaf (filename));\n<line24>return true;\n<line25>}\n<line26>printf (" -> ");\n<line27>out_string (pformat, prefix_len, quoteN (linkname));\n<line28>free (linkname);\n<line29>}\n<line30>break;\n<line31>case 'd':\n<line32>if (mod == 'H')\n<line33>out_uint (pformat, prefix_len, major (statbuf->st_dev));\n<line34>else if (mod == 'L')\n<line35>out_uint (pformat, prefix_len, minor (statbuf->st_dev));\n<line36>else\n<line37>out_uint (pformat, prefix_len, statbuf->st_dev);\n<line38>break;\n<line39>case 'D':\n<line40>out_uint_x (pformat, prefix_len, statbuf->st_dev);\n<line41>break;\n<line42>case 'i':\n<line43>out_uint (pformat, prefix_len, statbuf->st_ino);\n<line44>break;\n<line45>case 'a':\n<line46>out_uint_o (pformat, prefix_len, statbuf->st_mode & CHMOD_MODE_BITS);\n<line47>break;\n<line48>case 'A':\n<line49>out_string (pformat, prefix_len, human_access (statbuf));\n<line50>break;\n<line51>case 'f':\n<line52>out_uint_x (pformat, prefix_len, statbuf->st_mode);\n<line53>break;\n<line54>case 'F':\n<line55>out_string (pformat, prefix_len, file_type (statbuf));\n<line56>break;\n<line57>case 'h':\n<line58>out_uint (pformat, prefix_len, statbuf->st_nlink);\n<line59>break;\n<line60>case 'u':\n<line61>out_uint (pformat, prefix_len, statbuf->st_uid);\n<line62>break;\n<line63>case 'U':\n<line64>pw_ent = getpwuid (statbuf->st_uid);\n<line65>out_string (pformat, prefix_len,\n<line66>pw_ent ? pw_ent->pw_name : "UNKNOWN");\n<line67>break;\n<line68>case 'g':\n<line69>out_uint (pformat, prefix_len, statbuf->st_gid);\n<line70>break;\n<line71>case 'G':\n<line72>gw_ent = getgrgid (statbuf->st_gid);\n<line73>out_string (pformat, prefix_len,\n<line74>gw_ent ? gw_ent->gr_name : "UNKNOWN");\n<line75>break;\n<line76>case 'm':\n<line77>fail |= out_mount_point (filename, pformat, prefix_len, statbuf);\n<line78>break;\n<line79>case 's':\n<line80>out_uint (pformat, prefix_len, unsigned_file_size (statbuf->st_size));\n<line81>break;\n<line82>case 'r':\n<line83>if (mod == 'H')\n<line84>out_uint (pformat, prefix_len, major (statbuf->st_rdev));\n<line85>else if (mod == 'L')\n<line86>out_uint (pformat, prefix_len, minor (statbuf->st_rdev));\n<line87>else\n<line88>out_uint (pformat, prefix_len, statbuf->st_rdev);\n<line89>break;\n<line90>case 'R':\n<line91>out_uint_x (pformat, prefix_len, statbuf->st_rdev);\n<line92>break;\n<line93>case 't':\n<line94>out_uint_x (pformat, prefix_len, major (statbuf->st_rdev));\n<line95>break;\n<line96>case 'T':\n<line97>out_uint_x (pformat, prefix_len, minor (statbuf->st_rdev));\n<line98>break;\n<line99>case 'B':\n<line100>out_uint (pformat, prefix_len, ST_NBLOCKSIZE);\n<line101>break;\n<line102>case 'b':\n<line103>out_uint (pformat, prefix_len, ST_NBLOCKS (*statbuf));\n<line104>break;\n<line105>case 'o':\n<line106>out_uint (pformat, prefix_len, ST_BLKSIZE (*statbuf));\n<line107>break;\n<line108>case 'w':\n<line109>{\n<line110>#if ! USE_STATX\n<line111>btime = get_birthtime (fd, filename, statbuf);\n<line112>#endif\n<line113>if (btime.tv_nsec < 0)\n<line114>out_string (pformat, prefix_len, "-");\n<line115>else\n<line116>out_string (pformat, prefix_len, human_time (btime));\n<line117>}\n<line118>break;\n<line119>case 'W':\n<line120>{\n<line121>#if ! USE_STATX\n<line122>btime = get_birthtime (fd, filename, statbuf);\n<line123>#endif\n<line124>out_epoch_sec (pformat, prefix_len, neg_to_zero (btime));\n<line125>}\n<line126>break;\n<line127>case 'x':\n<line128>out_string (pformat, prefix_len, human_time (get_stat_atime (statbuf)));\n<line129>break;\n<line130>case 'X':\n<line131>out_epoch_sec (pformat, prefix_len, get_stat_atime (statbuf));\n<line132>break;\n<line133>case 'y':\n<line134>out_string (pformat, prefix_len, human_time (get_stat_mtime (statbuf)));\n<line135>break;\n<line136>case 'Y':\n<line137>out_epoch_sec (pformat, prefix_len, get_stat_mtime (statbuf));\n<line138>break;\n<line139>case 'z':\n<line140>out_string (pformat, prefix_len, human_time (get_stat_ctime (statbuf)));\n<line141>break;\n<line142>case 'Z':\n<line143>out_epoch_sec (pformat, prefix_len, get_stat_ctime (statbuf));\n<line144>break;\n<line145>case 'C':\n<line146>fail |= out_file_context (pformat, prefix_len, filename);\n<line147>break;\n<line148>default:\n<line149>fputc ('?', stdout);\n<line150>break;\n<line151>}\n<line152>return fail;\n<line153>}
----------------------------------------
Function: default_format
Content: <line0>static char *\n<line1>default_format (bool fs, bool terse, bool device)\n<line2>{\n<line3>char *format;\n<line4>if (fs)\n<line5>{\n<line6>if (terse)\n<line7>format = xstrdup (fmt_terse_fs);\n<line8>else\n<line9>{\n<line10>/* TRANSLATORS: This string uses format specifiers from\n<line11>'stat --help' with --file-system, and NOT from printf.  */\n<line12>format = xstrdup (_("  File: \"%n\"\n"\n<line13>"    ID: %-8i Namelen: %-7l Type: %T\n"\n<line14>"Block size: %-10s Fundamental block size: %S\n"\n<line15>"Blocks: Total: %-10b Free: %-10f Available: %a\n"\n<line16>"Inodes: Total: %-10c Free: %d\n"));\n<line17>}\n<line18>}\n<line19>else /* ! fs */\n<line20>{\n<line21>if (terse)\n<line22>{\n<line23>if (0 < is_selinux_enabled ())\n<line24>format = xstrdup (fmt_terse_selinux);\n<line25>else\n<line26>format = xstrdup (fmt_terse_regular);\n<line27>}\n<line28>else\n<line29>{\n<line30>char *temp;\n<line31>/* TRANSLATORS: This string uses format specifiers from\n<line32>'stat --help' without --file-system, and NOT from printf.  */\n<line33>format = xstrdup (_("\\n<line34>File: %N\n\\n<line35>Size: %-10s\tBlocks: %-10b IO Block: %-6o %F\n\\n<line36>"));\n<line37>temp = format;\n<line38>if (device)\n<line39>{\n<line40>/* TRANSLATORS: This string uses format specifiers from\n<line41>'stat --help' without --file-system, and NOT from printf.  */\n<line42>format = xasprintf ("%s%s", format, _("\\n<line43>" "Device: %Hd,%Ld\tInode: %-10i  Links: %-5h Device type: %Hr,%Lr\n\\n<line44>"));\n<line45>}\n<line46>else\n<line47>{\n<line48>/* TRANSLATORS: This string uses format specifiers from\n<line49>'stat --help' without --file-system, and NOT from printf.  */\n<line50>format = xasprintf ("%s%s", format, _("\\n<line51>" "Device: %Hd,%Ld\tInode: %-10i  Links: %h\n\\n<line52>"));\n<line53>}\n<line54>free (temp);\n<line55>temp = format;\n<line56>/* TRANSLATORS: This string uses format specifiers from\n<line57>'stat --help' without --file-system, and NOT from printf.  */\n<line58>format = xasprintf ("%s%s", format, _("\\n<line59>" "Access: (%04a/%10.10A)  Uid: (%5u/%8U)   Gid: (%5g/%8G)\n\\n<line60>"));\n<line61>free (temp);\n<line62>if (0 < is_selinux_enabled ())\n<line63>{\n<line64>temp = format;\n<line65>/* TRANSLATORS: This string uses format specifiers from\n<line66>'stat --help' without --file-system, and NOT from printf.  */\n<line67>format = xasprintf ("%s%s", format, _("Context: %C\n"));\n<line68>free (temp);\n<line69>}\n<line70>temp = format;\n<line71>/* TRANSLATORS: This string uses format specifiers from\n<line72>'stat --help' without --file-system, and NOT from printf.  */\n<line73>format = xasprintf ("%s%s", format,\n<line74>_("Access: %x\n"\n<line75>"Modify: %y\n"\n<line76>"Change: %z\n"\n<line77>" Birth: %w\n"));\n<line78>free (temp);\n<line79>}\n<line80>}\n<line81>return format;\n<line82>}
----------------------------------------
Function: usage
Content: <line0>void\n<line1>usage (int status)\n<line2>{\n<line3>if (status != EXIT_SUCCESS)\n<line4>emit_try_help ();\n<line5>else\n<line6>{\n<line7>printf (_("Usage: %s [OPTION]... FILE...\n"), program_name);\n<line8>fputs (_("\\n<line9>Display file or file system status.\n\\n<line10>"), stdout);\n<line11>emit_mandatory_arg_note ();\n<line12>fputs (_("\\n<line13>-L, --dereference     follow links\n\\n<line14>-f, --file-system     display file system status instead of file status\n\\n<line15>"), stdout);\n<line16>fputs (_("\\n<line17>--cached=MODE     specify how to use cached attributes;\n\\n<line18>useful on remote file systems. See MODE below\n\\n<line19>"), stdout);\n<line20>fputs (_("\\n<line21>-c  --format=FORMAT   use the specified FORMAT instead of the default;\n\\n<line22>output a newline after each use of FORMAT\n\\n<line23>--printf=FORMAT   like --format, but interpret backslash escapes,\n\\n<line24>and do not output a mandatory trailing newline;\n\\n<line25>if you want a newline, include \\n in FORMAT\n\\n<line26>-t, --terse           print the information in terse form\n\\n<line27>"), stdout);\n<line28>fputs (HELP_OPTION_DESCRIPTION, stdout);\n<line29>fputs (VERSION_OPTION_DESCRIPTION, stdout);\n<line30>fputs (_("\n\\n<line31>The MODE argument of --cached can be: always, never, or default.\n\\n<line32>'always' will use cached attributes if available, while\n\\n<line33>'never' will try to synchronize with the latest attributes, and\n\\n<line34>'default' will leave it up to the underlying file system.\n\\n<line35>"), stdout);\n<line36>fputs (_("\n\\n<line37>The valid format sequences for files (without --file-system):\n\\n<line38>\n\\n<line39>%a   permission bits in octal (note '#' and '0' printf flags)\n\\n<line40>%A   permission bits and file type in human readable form\n\\n<line41>%b   number of blocks allocated (see %B)\n\\n<line42>%B   the size in bytes of each block reported by %b\n\\n<line43>%C   SELinux security context string\n\\n<line44>"), stdout);\n<line45>fputs (_("\\n<line46>%d   device number in decimal (st_dev)\n\\n<line47>%D   device number in hex (st_dev)\n\\n<line48>%Hd  major device number in decimal\n\\n<line49>%Ld  minor device number in decimal\n\\n<line50>%f   raw mode in hex\n\\n<line51>%F   file type\n\\n<line52>%g   group ID of owner\n\\n<line53>%G   group name of owner\n\\n<line54>"), stdout);\n<line55>fputs (_("\\n<line56>%h   number of hard links\n\\n<line57>%i   inode number\n\\n<line58>%m   mount point\n\\n<line59>%n   file name\n\\n<line60>%N   quoted file name with dereference if symbolic link\n\\n<line61>%o   optimal I/O transfer size hint\n\\n<line62>%s   total size, in bytes\n\\n<line63>%r   device type in decimal (st_rdev)\n\\n<line64>%R   device type in hex (st_rdev)\n\\n<line65>%Hr  major device type in decimal, for character/block device special files\n\\n<line66>%Lr  minor device type in decimal, for character/block device special files\n\\n<line67>%t   major device type in hex, for character/block device special files\n\\n<line68>%T   minor device type in hex, for character/block device special files\n\\n<line69>"), stdout);\n<line70>fputs (_("\\n<line71>%u   user ID of owner\n\\n<line72>%U   user name of owner\n\\n<line73>%w   time of file birth, human-readable; - if unknown\n\\n<line74>%W   time of file birth, seconds since Epoch; 0 if unknown\n\\n<line75>%x   time of last access, human-readable\n\\n<line76>%X   time of last access, seconds since Epoch\n\\n<line77>%y   time of last data modification, human-readable\n\\n<line78>%Y   time of last data modification, seconds since Epoch\n\\n<line79>%z   time of last status change, human-readable\n\\n<line80>%Z   time of last status change, seconds since Epoch\n\\n<line81>\n\\n<line82>"), stdout);\n<line83>fputs (_("\\n<line84>Valid format sequences for file systems:\n\\n<line85>\n\\n<line86>%a   free blocks available to non-superuser\n\\n<line87>%b   total data blocks in file system\n\\n<line88>%c   total file nodes in file system\n\\n<line89>%d   free file nodes in file system\n\\n<line90>%f   free blocks in file system\n\\n<line91>"), stdout);\n<line92>fputs (_("\\n<line93>%i   file system ID in hex\n\\n<line94>%l   maximum length of filenames\n\\n<line95>%n   file name\n\\n<line96>%s   block size (for faster transfers)\n\\n<line97>%S   fundamental block size (for block counts)\n\\n<line98>%t   file system type in hex\n\\n<line99>%T   file system type in human readable form\n\\n<line100>"), stdout);\n<line101>printf (_("\n\\n<line102>--terse is equivalent to the following FORMAT:\n\\n<line103>%s\\n<line104>"),\n<line105>#if HAVE_SELINUX_SELINUX_H\n<line106>fmt_terse_selinux\n<line107>#else\n<line108>fmt_terse_regular\n<line109>#endif\n<line110>);\n<line111>printf (_("\\n<line112>--terse --file-system is equivalent to the following FORMAT:\n\\n<line113>%s\\n<line114>"), fmt_terse_fs);\n<line115>printf (USAGE_BUILTIN_WARNING, PROGRAM_NAME);\n<line116>emit_ancillary_info (PROGRAM_NAME);\n<line117>}\n<line118>exit (status);\n<line119>}
----------------------------------------
Function: main
Content: <line0>int\n<line1>main (int argc, char *argv[])\n<line2>{\n<line3>int c;\n<line4>bool fs = false;\n<line5>bool terse = false;\n<line6>char *format = nullptr;\n<line7>char *format2;\n<line8>bool ok = true;\n<line9>initialize_main (&argc, &argv);\n<line10>set_program_name (argv[0]);\n<line11>setlocale (LC_ALL, "");\n<line12>bindtextdomain (PACKAGE, LOCALEDIR);\n<line13>textdomain (PACKAGE);\n<line14>struct lconv const *locale = localeconv ();\n<line15>decimal_point = (locale->decimal_point[0] ? locale->decimal_point : ".");\n<line16>decimal_point_len = strlen (decimal_point);\n<line17>atexit (close_stdout);\n<line18>while ((c = getopt_long (argc, argv, "c:fLt", long_options, nullptr)) != -1)\n<line19>{\n<line20>switch (c)\n<line21>{\n<line22>case PRINTF_OPTION:\n<line23>format = optarg;\n<line24>interpret_backslash_escapes = true;\n<line25>trailing_delim = "";\n<line26>break;\n<line27>case 'c':\n<line28>format = optarg;\n<line29>interpret_backslash_escapes = false;\n<line30>trailing_delim = "\n";\n<line31>break;\n<line32>case 'L':\n<line33>follow_links = true;\n<line34>break;\n<line35>case 'f':\n<line36>fs = true;\n<line37>break;\n<line38>case 't':\n<line39>terse = true;\n<line40>break;\n<line41>case 0:\n<line42>switch (XARGMATCH ("--cached", optarg, cached_args, cached_modes))\n<line43>{\n<line44>case cached_never:\n<line45>force_sync = true;\n<line46>dont_sync = false;\n<line47>break;\n<line48>case cached_always:\n<line49>force_sync = false;\n<line50>dont_sync = true;\n<line51>break;\n<line52>case cached_default:\n<line53>force_sync = false;\n<line54>dont_sync = false;\n<line55>}\n<line56>break;\n<line57>case_GETOPT_HELP_CHAR;\n<line58>case_GETOPT_VERSION_CHAR (PROGRAM_NAME, AUTHORS);\n<line59>default:\n<line60>usage (EXIT_FAILURE);\n<line61>}\n<line62>}\n<line63>if (argc == optind)\n<line64>{\n<line65>error (0, 0, _("missing operand"));\n<line66>usage (EXIT_FAILURE);\n<line67>}\n<line68>if (format)\n<line69>{\n<line70>if (strstr (format, "%N"))\n<line71>getenv_quoting_style ();\n<line72>format2 = format;\n<line73>}\n<line74>else\n<line75>{\n<line76>format = default_format (fs, terse, /* device= */ false);\n<line77>format2 = default_format (fs, terse, /* device= */ true);\n<line78>}\n<line79>for (int i = optind; i < argc; i++)\n<line80>ok &= (fs\n<line81>? do_statfs (argv[i], format)\n<line82>: do_stat (argv[i], format, format2));\n<line83>main_exit (ok ? EXIT_SUCCESS : EXIT_FAILURE);\n<line84>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/src/sum.c
========================================
Function: bsd_sum_stream
Content: <line0>int\n<line1>bsd_sum_stream (FILE *stream, void *resstream, uintmax_t *length)\n<line2>{\n<line3>int ret = -1;\n<line4>size_t sum, n;\n<line5>int checksum = 0;	/* The checksum mod 2^16. */\n<line6>uintmax_t total_bytes = 0;	/* The number of bytes. */\n<line7>static const size_t buffer_length = 32768;\n<line8>uint8_t *buffer = malloc (buffer_length);\n<line9>if (! buffer)\n<line10>return -1;\n<line11>/* Process file */\n<line12>while (true)\n<line13>{\n<line14>sum = 0;\n<line15>/* Read block */\n<line16>while (true)\n<line17>{\n<line18>n = fread (buffer + sum, 1, buffer_length - sum, stream);\n<line19>sum += n;\n<line20>if (buffer_length == sum)\n<line21>break;\n<line22>if (n == 0)\n<line23>{\n<line24>if (ferror (stream))\n<line25>goto cleanup_buffer;\n<line26>goto final_process;\n<line27>}\n<line28>if (feof (stream))\n<line29>goto final_process;\n<line30>}\n<line31>for (size_t i = 0; i < sum; i++)\n<line32>{\n<line33>checksum = (checksum >> 1) + ((checksum & 1) << 15);\n<line34>checksum += buffer[i];\n<line35>checksum &= 0xffff;	/* Keep it within bounds. */\n<line36>}\n<line37>if (total_bytes + sum < total_bytes)\n<line38>{\n<line39>errno = EOVERFLOW;\n<line40>goto cleanup_buffer;\n<line41>}\n<line42>total_bytes += sum;\n<line43>}\n<line44>final_process:;\n<line45>for (size_t i = 0; i < sum; i++)\n<line46>{\n<line47>checksum = (checksum >> 1) + ((checksum & 1) << 15);\n<line48>checksum += buffer[i];\n<line49>checksum &= 0xffff;	/* Keep it within bounds. */\n<line50>}\n<line51>if (total_bytes + sum < total_bytes)\n<line52>{\n<line53>errno = EOVERFLOW;\n<line54>goto cleanup_buffer;\n<line55>}\n<line56>total_bytes += sum;\n<line57>memcpy (resstream, &checksum, sizeof checksum);\n<line58>*length = total_bytes;\n<line59>ret = 0;\n<line60>cleanup_buffer:\n<line61>free (buffer);\n<line62>return ret;\n<line63>}
----------------------------------------
Function: sysv_sum_stream
Content: <line0>int\n<line1>sysv_sum_stream (FILE *stream, void *resstream, uintmax_t *length)\n<line2>{\n<line3>int ret = -1;\n<line4>size_t sum, n;\n<line5>uintmax_t total_bytes = 0;\n<line6>static const size_t buffer_length = 32768;\n<line7>uint8_t *buffer = malloc (buffer_length);\n<line8>if (! buffer)\n<line9>return -1;\n<line10>/* The sum of all the input bytes, modulo (UINT_MAX + 1).  */\n<line11>unsigned int s = 0;\n<line12>/* Process file */\n<line13>while (true)\n<line14>{\n<line15>sum = 0;\n<line16>/* Read block */\n<line17>while (true)\n<line18>{\n<line19>n = fread (buffer + sum, 1, buffer_length - sum, stream);\n<line20>sum += n;\n<line21>if (buffer_length == sum)\n<line22>break;\n<line23>if (n == 0)\n<line24>{\n<line25>if (ferror (stream))\n<line26>goto cleanup_buffer;\n<line27>goto final_process;\n<line28>}\n<line29>if (feof (stream))\n<line30>goto final_process;\n<line31>}\n<line32>for (size_t i = 0; i < sum; i++)\n<line33>s += buffer[i];\n<line34>if (total_bytes + sum < total_bytes)\n<line35>{\n<line36>errno = EOVERFLOW;\n<line37>goto cleanup_buffer;\n<line38>}\n<line39>total_bytes += sum;\n<line40>}\n<line41>final_process:;\n<line42>for (size_t i = 0; i < sum; i++)\n<line43>s += buffer[i];\n<line44>if (total_bytes + sum < total_bytes)\n<line45>{\n<line46>errno = EOVERFLOW;\n<line47>goto cleanup_buffer;\n<line48>}\n<line49>total_bytes += sum;\n<line50>int r = (s & 0xffff) + ((s & 0xffffffff) >> 16);\n<line51>int checksum = (r & 0xffff) + (r >> 16);\n<line52>memcpy (resstream, &checksum, sizeof checksum);\n<line53>*length = total_bytes;\n<line54>ret = 0;\n<line55>cleanup_buffer:\n<line56>free (buffer);\n<line57>return ret;\n<line58>}
----------------------------------------
Function: output_bsd
Content: <line0>void\n<line1>output_bsd (char const *file, int binary_file, void const *digest,\n<line2>bool raw, bool tagged, unsigned char delim, bool args,\n<line3>uintmax_t length)\n<line4>{\n<line5>if (raw)\n<line6>{\n<line7>/* Output in network byte order (big endian).  */\n<line8>uint16_t out_int = *(int *)digest;\n<line9>out_int = SWAP (out_int);\n<line10>fwrite (&out_int, 1, 16/8, stdout);\n<line11>return;\n<line12>}\n<line13>char hbuf[LONGEST_HUMAN_READABLE + 1];\n<line14>printf ("%05d %5s", *(int *)digest,\n<line15>human_readable (length, hbuf, human_ceiling, 1, 1024));\n<line16>if (args)\n<line17>printf (" %s", file);\n<line18>putchar (delim);\n<line19>}
----------------------------------------
Function: output_sysv
Content: <line0>void\n<line1>output_sysv (char const *file, int binary_file, void const *digest,\n<line2>bool raw, bool tagged, unsigned char delim, bool args,\n<line3>uintmax_t length)\n<line4>{\n<line5>if (raw)\n<line6>{\n<line7>/* Output in network byte order (big endian).  */\n<line8>uint16_t out_int = *(int *)digest;\n<line9>out_int = SWAP (out_int);\n<line10>fwrite (&out_int, 1, 16/8, stdout);\n<line11>return;\n<line12>}\n<line13>char hbuf[LONGEST_HUMAN_READABLE + 1];\n<line14>printf ("%d %s", *(int *)digest,\n<line15>human_readable (length, hbuf, human_ceiling, 1, 512));\n<line16>if (args)\n<line17>printf (" %s", file);\n<line18>putchar (delim);\n<line19>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/src/digest.c
========================================
Function: usage
Content: <line0>void\n<line1>usage (int status)\n<line2>{\n<line3>if (status != EXIT_SUCCESS)\n<line4>emit_try_help ();\n<line5>else\n<line6>{\n<line7>printf (_("\\n<line8>Usage: %s [OPTION]... [FILE]...\n\\n<line9>"), program_name);\n<line10>#if HASH_ALGO_CKSUM\n<line11>fputs (_("\\n<line12>Print or verify checksums.\n\\n<line13>By default use the 32 bit CRC algorithm.\n\\n<line14>"), stdout);\n<line15>#else\n<line16>printf (_("\\n<line17>Print or check %s (%d-bit) checksums.\n\\n<line18>"),\n<line19>DIGEST_TYPE_STRING,\n<line20>DIGEST_BITS);\n<line21>#endif\n<line22>emit_stdin_note ();\n<line23>#if HASH_ALGO_SUM\n<line24>fputs (_("\\n<line25>\n\\n<line26>-r              use BSD sum algorithm (the default), use 1K blocks\n\\n<line27>-s, --sysv      use System V sum algorithm, use 512 bytes blocks\n\\n<line28>"), stdout);\n<line29>#endif\n<line30>#if HASH_ALGO_BLAKE2 || HASH_ALGO_CKSUM\n<line31>emit_mandatory_arg_note ();\n<line32>#endif\n<line33>#if HASH_ALGO_CKSUM\n<line34>fputs (_("\\n<line35>-a, --algorithm=TYPE  select the digest type to use.  See DIGEST below.\\n<line36>\n\\n<line37>"), stdout);\n<line38>fputs (_("\\n<line39>--base64          emit base64-encoded digests, not hexadecimal\\n<line40>\n\\n<line41>"), stdout);\n<line42>#endif\n<line43>#if !HASH_ALGO_SUM\n<line44># if !HASH_ALGO_CKSUM\n<line45>if (O_BINARY)\n<line46>fputs (_("\\n<line47>-b, --binary          read in binary mode (default unless reading tty stdin)\\n<line48>\n\\n<line49>"), stdout);\n<line50>else\n<line51>fputs (_("\\n<line52>-b, --binary          read in binary mode\n\\n<line53>"), stdout);\n<line54># endif\n<line55>fputs (_("\\n<line56>-c, --check           read checksums from the FILEs and check them\n\\n<line57>"), stdout);\n<line58># if HASH_ALGO_BLAKE2 || HASH_ALGO_CKSUM\n<line59>fputs (_("\\n<line60>-l, --length=BITS     digest length in bits; must not exceed the max for\n\\n<line61>the blake2 algorithm and must be a multiple of 8\n\\n<line62>"), stdout);\n<line63># endif\n<line64># if HASH_ALGO_CKSUM\n<line65>fputs (_("\\n<line66>--raw             emit a raw binary digest, not hexadecimal\\n<line67>\n\\n<line68>"), stdout);\n<line69>fputs (_("\\n<line70>--tag             create a BSD-style checksum (the default)\n\\n<line71>"), stdout);\n<line72>fputs (_("\\n<line73>--untagged        create a reversed style checksum, without digest type\n\\n<line74>"), stdout);\n<line75># else\n<line76>fputs (_("\\n<line77>--tag             create a BSD-style checksum\n\\n<line78>"), stdout);\n<line79># endif\n<line80># if !HASH_ALGO_CKSUM\n<line81>if (O_BINARY)\n<line82>fputs (_("\\n<line83>-t, --text            read in text mode (default if reading tty stdin)\n\\n<line84>"), stdout);\n<line85>else\n<line86>fputs (_("\\n<line87>-t, --text            read in text mode (default)\n\\n<line88>"), stdout);\n<line89># endif\n<line90>fputs (_("\\n<line91>-z, --zero            end each output line with NUL, not newline,\n\\n<line92>and disable file name escaping\n\\n<line93>"), stdout);\n<line94>fputs (_("\\n<line95>\n\\n<line96>The following five options are useful only when verifying checksums:\n\\n<line97>--ignore-missing  don't fail or report status for missing files\n\\n<line98>--quiet           don't print OK for each successfully verified file\n\\n<line99>--status          don't output anything, status code shows success\n\\n<line100>--strict          exit non-zero for improperly formatted checksum lines\n\\n<line101>-w, --warn            warn about improperly formatted checksum lines\n\\n<line102>\n\\n<line103>"), stdout);\n<line104>#endif\n<line105>#if HASH_ALGO_CKSUM\n<line106>fputs (_("\\n<line107>--debug           indicate which implementation used\n\\n<line108>"), stdout);\n<line109>#endif\n<line110>fputs (HELP_OPTION_DESCRIPTION, stdout);\n<line111>fputs (VERSION_OPTION_DESCRIPTION, stdout);\n<line112>#if HASH_ALGO_CKSUM\n<line113>fputs (_("\\n<line114>\n\\n<line115>DIGEST determines the digest algorithm and default output format:\n\\n<line116>sysv      (equivalent to sum -s)\n\\n<line117>bsd       (equivalent to sum -r)\n\\n<line118>crc       (equivalent to cksum)\n\\n<line119>md5       (equivalent to md5sum)\n\\n<line120>sha1      (equivalent to sha1sum)\n\\n<line121>sha224    (equivalent to sha224sum)\n\\n<line122>sha256    (equivalent to sha256sum)\n\\n<line123>sha384    (equivalent to sha384sum)\n\\n<line124>sha512    (equivalent to sha512sum)\n\\n<line125>blake2b   (equivalent to b2sum)\n\\n<line126>sm3       (only available through cksum)\n\\n<line127>\n"), stdout);\n<line128>#endif\n<line129>#if !HASH_ALGO_SUM && !HASH_ALGO_CKSUM\n<line130>printf (_("\\n<line131>\n\\n<line132>The sums are computed as described in %s.\n"), DIGEST_REFERENCE);\n<line133>fputs (_("\\n<line134>When checking, the input should be a former output of this program.\n\\n<line135>The default mode is to print a line with: checksum, a space,\n\\n<line136>a character indicating input mode ('*' for binary, ' ' for text\n\\n<line137>or where binary is insignificant), and name for each FILE.\n\\n<line138>\n\\n<line139>Note: There is no difference between binary mode and text mode on GNU systems.\\n<line140>\n"), stdout);\n<line141>#endif\n<line142>#if HASH_ALGO_CKSUM\n<line143>fputs (_("\\n<line144>When checking, the input should be a former output of this program,\n\\n<line145>or equivalent standalone program.\\n<line146>\n"), stdout);\n<line147>#endif\n<line148>emit_ancillary_info (PROGRAM_NAME);\n<line149>}\n<line150>exit (status);\n<line151>}
----------------------------------------
Function: filename_unescape
Content: <line0>static char *\n<line1>filename_unescape (char *s, size_t s_len)\n<line2>{\n<line3>char *dst = s;\n<line4>for (size_t i = 0; i < s_len; i++)\n<line5>{\n<line6>switch (s[i])\n<line7>{\n<line8>case '\\':\n<line9>if (i == s_len - 1)\n<line10>{\n<line11>/* File name ends with an unescaped backslash: invalid.  */\n<line12>return nullptr;\n<line13>}\n<line14>++i;\n<line15>switch (s[i])\n<line16>{\n<line17>case 'n':\n<line18>*dst++ = '\n';\n<line19>break;\n<line20>case 'r':\n<line21>*dst++ = '\r';\n<line22>break;\n<line23>case '\\':\n<line24>*dst++ = '\\';\n<line25>break;\n<line26>default:\n<line27>/* Only '\', 'n' or 'r' may follow a backslash.  */\n<line28>return nullptr;\n<line29>}\n<line30>break;\n<line31>case '\0':\n<line32>/* The file name may not contain a NUL.  */\n<line33>return nullptr;\n<line34>default:\n<line35>*dst++ = s[i];\n<line36>break;\n<line37>}\n<line38>}\n<line39>if (dst < s + s_len)\n<line40>*dst = '\0';\n<line41>return s;\n<line42>}
----------------------------------------
Function: bsd_split_3
Content: <line0>static bool\n<line1>bsd_split_3 (char *s, size_t s_len,\n<line2>unsigned char **digest, size_t *d_len,\n<line3>char **file_name, bool escaped_filename)\n<line4>{\n<line5>if (s_len == 0)\n<line6>return false;\n<line7>/* Find end of filename.  */\n<line8>size_t i = s_len - 1;\n<line9>while (i && s[i] != ')')\n<line10>i--;\n<line11>if (s[i] != ')')\n<line12>return false;\n<line13>*file_name = s;\n<line14>if (escaped_filename && filename_unescape (s, i) == nullptr)\n<line15>return false;\n<line16>s[i++] = '\0';\n<line17>while (ISWHITE (s[i]))\n<line18>i++;\n<line19>if (s[i] != '=')\n<line20>return false;\n<line21>i++;\n<line22>while (ISWHITE (s[i]))\n<line23>i++;\n<line24>*digest = (unsigned char *) &s[i];\n<line25>*d_len = s_len - i;\n<line26>return valid_digits (*digest, *d_len);\n<line27>}
----------------------------------------
Function: split_3
Content: <line0>static bool\n<line1>split_3 (char *s, size_t s_len,\n<line2>unsigned char **digest, size_t *d_len, int *binary, char **file_name)\n<line3>{\n<line4>bool escaped_filename = false;\n<line5>size_t algo_name_len;\n<line6>size_t i = 0;\n<line7>while (ISWHITE (s[i]))\n<line8>++i;\n<line9>if (s[i] == '\\')\n<line10>{\n<line11>++i;\n<line12>escaped_filename = true;\n<line13>}\n<line14>/* Check for BSD-style checksum line. */\n<line15>#if HASH_ALGO_CKSUM\n<line16>if (! algorithm_specified)\n<line17>{\n<line18>ptrdiff_t algo_tag = algorithm_from_tag (s + i);\n<line19>if (algo_tag >= 0)\n<line20>{\n<line21>if (algo_tag <= crc)\n<line22>return false;  /* We don't support checking these older formats.  */\n<line23>cksum_algorithm = algo_tag;\n<line24>}\n<line25>else\n<line26>return false;  /* We only support tagged format without -a.  */\n<line27>}\n<line28>#endif\n<line29>algo_name_len = strlen (DIGEST_TYPE_STRING);\n<line30>if (STREQ_LEN (s + i, DIGEST_TYPE_STRING, algo_name_len))\n<line31>{\n<line32>i += algo_name_len;\n<line33>#if HASH_ALGO_BLAKE2 || HASH_ALGO_CKSUM\n<line34>/* Terminate and match algorithm name.  */\n<line35>char const *algo_name = &s[i - algo_name_len];\n<line36>bool length_specified = s[i] == '-';\n<line37>bool openssl_format = s[i] == '('; /* and no length_specified */\n<line38>s[i++] = '\0';\n<line39>if (!STREQ (algo_name, DIGEST_TYPE_STRING))\n<line40>return false;\n<line41>if (openssl_format)\n<line42>s[--i] = '(';\n<line43># if HASH_ALGO_BLAKE2\n<line44>digest_length = BLAKE2B_MAX_LEN * 8;\n<line45># else\n<line46>digest_length = algorithm_bits[cksum_algorithm];\n<line47># endif\n<line48>if (length_specified)\n<line49>{\n<line50>uintmax_t length;\n<line51>char *siend;\n<line52>if (! (xstrtoumax (s + i, &siend, 0, &length, nullptr) == LONGINT_OK\n<line53>&& 0 < length && length <= digest_length\n<line54>&& length % 8 == 0))\n<line55>return false;\n<line56>i = siend - s;\n<line57>digest_length = length;\n<line58>}\n<line59>digest_hex_bytes = digest_length / 4;\n<line60>#endif\n<line61>if (s[i] == ' ')\n<line62>++i;\n<line63>if (s[i] == '(')\n<line64>{\n<line65>++i;\n<line66>*binary = 0;\n<line67>return bsd_split_3 (s + i, s_len - i,\n<line68>digest, d_len, file_name, escaped_filename);\n<line69>}\n<line70>return false;\n<line71>}\n<line72>/* Ignore this line if it is too short.\n<line73>Each line must have at least 'min_digest_line_length - 1' (or one more, if\n<line74>the first is a backslash) more characters to contain correct message digest\n<line75>information.  */\n<line76>if (s_len - i < min_digest_line_length + (s[i] == '\\'))\n<line77>return false;\n<line78>*digest = (unsigned char *) &s[i];\n<line79>#if HASH_ALGO_BLAKE2 || HASH_ALGO_CKSUM\n<line80>/* Auto determine length.  */\n<line81># if HASH_ALGO_CKSUM\n<line82>if (cksum_algorithm == blake2b) {\n<line83># endif\n<line84>unsigned char const *hp = *digest;\n<line85>digest_hex_bytes = 0;\n<line86>while (isxdigit (*hp++))\n<line87>digest_hex_bytes++;\n<line88>if (digest_hex_bytes < 2 || digest_hex_bytes % 2\n<line89>|| BLAKE2B_MAX_LEN * 2 < digest_hex_bytes)\n<line90>return false;\n<line91>digest_length = digest_hex_bytes * 4;\n<line92># if HASH_ALGO_CKSUM\n<line93>}\n<line94># endif\n<line95>#endif\n<line96>/* This field must be the hexadecimal or base64 representation\n<line97>of the message digest.  */\n<line98>while (s[i] && !ISWHITE (s[i]))\n<line99>i++;\n<line100>/* The digest must be followed by at least one whitespace character.  */\n<line101>if (i == s_len)\n<line102>return false;\n<line103>*d_len = &s[i] - (char *) *digest;\n<line104>s[i++] = '\0';\n<line105>if (! valid_digits (*digest, *d_len))\n<line106>return false;\n<line107>/* If "bsd reversed" format detected.  */\n<line108>if ((s_len - i == 1) || (s[i] != ' ' && s[i] != '*'))\n<line109>{\n<line110>/* Don't allow mixing bsd and standard formats,\n<line111>to minimize security issues with attackers\n<line112>renaming files with leading spaces.\n<line113>This assumes that with bsd format checksums\n<line114>that the first file name does not have\n<line115>a leading ' ' or '*'.  */\n<line116>if (bsd_reversed == 0)\n<line117>return false;\n<line118>bsd_reversed = 1;\n<line119>}\n<line120>else if (bsd_reversed != 1)\n<line121>{\n<line122>bsd_reversed = 0;\n<line123>*binary = (s[i++] == '*');\n<line124>}\n<line125>/* All characters between the type indicator and end of line are\n<line126>significant -- that includes leading and trailing white space.  */\n<line127>*file_name = &s[i];\n<line128>if (escaped_filename)\n<line129>return filename_unescape (&s[i], s_len - i) != nullptr;\n<line130>return true;\n<line131>}
----------------------------------------
Function: print_filename
Content: <line0>static void\n<line1>print_filename (char const *file, bool escape)\n<line2>{\n<line3>if (! escape)\n<line4>{\n<line5>fputs (file, stdout);\n<line6>return;\n<line7>}\n<line8>while (*file)\n<line9>{\n<line10>switch (*file)\n<line11>{\n<line12>case '\n':\n<line13>fputs ("\\n", stdout);\n<line14>break;\n<line15>case '\r':\n<line16>fputs ("\\r", stdout);\n<line17>break;\n<line18>case '\\':\n<line19>fputs ("\\\\", stdout);\n<line20>break;\n<line21>default:\n<line22>putchar (*file);\n<line23>break;\n<line24>}\n<line25>file++;\n<line26>}\n<line27>}
----------------------------------------
Function: digest_file
Content: <line0>static bool\n<line1>digest_file (char const *filename, int *binary, unsigned char *bin_result,\n<line2>bool *missing, MAYBE_UNUSED uintmax_t *length)\n<line3>{\n<line4>FILE *fp;\n<line5>int err;\n<line6>bool is_stdin = STREQ (filename, "-");\n<line7>*missing = false;\n<line8>if (is_stdin)\n<line9>{\n<line10>have_read_stdin = true;\n<line11>fp = stdin;\n<line12>if (O_BINARY && *binary)\n<line13>{\n<line14>if (*binary < 0)\n<line15>*binary = ! isatty (STDIN_FILENO);\n<line16>if (*binary)\n<line17>xset_binary_mode (STDIN_FILENO, O_BINARY);\n<line18>}\n<line19>}\n<line20>else\n<line21>{\n<line22>fp = fopen (filename, (O_BINARY && *binary ? "rb" : "r"));\n<line23>if (fp == nullptr)\n<line24>{\n<line25>if (ignore_missing && errno == ENOENT)\n<line26>{\n<line27>*missing = true;\n<line28>return true;\n<line29>}\n<line30>error (0, errno, "%s", quotef (filename));\n<line31>return false;\n<line32>}\n<line33>}\n<line34>fadvise (fp, FADVISE_SEQUENTIAL);\n<line35>#if HASH_ALGO_CKSUM\n<line36>if (cksum_algorithm == blake2b)\n<line37>*length = digest_length / 8;\n<line38>err = DIGEST_STREAM (fp, bin_result, length);\n<line39>#elif HASH_ALGO_SUM\n<line40>err = DIGEST_STREAM (fp, bin_result, length);\n<line41>#elif HASH_ALGO_BLAKE2\n<line42>err = DIGEST_STREAM (fp, bin_result, digest_length / 8);\n<line43>#else\n<line44>err = DIGEST_STREAM (fp, bin_result);\n<line45>#endif\n<line46>err = err ? errno : 0;\n<line47>if (is_stdin)\n<line48>clearerr (fp);\n<line49>else if (fclose (fp) != 0 && !err)\n<line50>err = errno;\n<line51>if (err)\n<line52>{\n<line53>error (0, err, "%s", quotef (filename));\n<line54>return false;\n<line55>}\n<line56>return true;\n<line57>}
----------------------------------------
Function: hex_equal
Content: <line0>static bool\n<line1>hex_equal (unsigned char const *hex_digest, unsigned char const *bin_buffer)\n<line2>{\n<line3>static const char bin2hex[] = { '0', '1', '2', '3',\n<line4>'4', '5', '6', '7',\n<line5>'8', '9', 'a', 'b',\n<line6>'c', 'd', 'e', 'f' };\n<line7>size_t digest_bin_bytes = digest_hex_bytes / 2;\n<line8>/* Compare generated binary number with text representation\n<line9>in check file.  Ignore case of hex digits.  */\n<line10>size_t cnt;\n<line11>for (cnt = 0; cnt < digest_bin_bytes; ++cnt)\n<line12>{\n<line13>if (tolower (hex_digest[2 * cnt])\n<line14>!= bin2hex[bin_buffer[cnt] >> 4]\n<line15>|| (tolower (hex_digest[2 * cnt + 1])\n<line16>!= (bin2hex[bin_buffer[cnt] & 0xf])))\n<line17>break;\n<line18>}\n<line19>return cnt == digest_bin_bytes;\n<line20>}
----------------------------------------
Function: digest_check
Content: <line0>static bool\n<line1>digest_check (char const *checkfile_name)\n<line2>{\n<line3>FILE *checkfile_stream;\n<line4>uintmax_t n_misformatted_lines = 0;\n<line5>uintmax_t n_mismatched_checksums = 0;\n<line6>uintmax_t n_open_or_read_failures = 0;\n<line7>bool properly_formatted_lines = false;\n<line8>bool matched_checksums = false;\n<line9>unsigned char bin_buffer_unaligned[DIGEST_BIN_BYTES + DIGEST_ALIGN];\n<line10>/* Make sure bin_buffer is properly aligned. */\n<line11>unsigned char *bin_buffer = ptr_align (bin_buffer_unaligned, DIGEST_ALIGN);\n<line12>uintmax_t line_number;\n<line13>char *line;\n<line14>size_t line_chars_allocated;\n<line15>bool is_stdin = STREQ (checkfile_name, "-");\n<line16>if (is_stdin)\n<line17>{\n<line18>have_read_stdin = true;\n<line19>checkfile_name = _("standard input");\n<line20>checkfile_stream = stdin;\n<line21>}\n<line22>else\n<line23>{\n<line24>checkfile_stream = fopen (checkfile_name, "r");\n<line25>if (checkfile_stream == nullptr)\n<line26>{\n<line27>error (0, errno, "%s", quotef (checkfile_name));\n<line28>return false;\n<line29>}\n<line30>}\n<line31>line_number = 0;\n<line32>line = nullptr;\n<line33>line_chars_allocated = 0;\n<line34>do\n<line35>{\n<line36>char *filename;\n<line37>int binary;\n<line38>unsigned char *digest;\n<line39>ssize_t line_length;\n<line40>++line_number;\n<line41>if (line_number == 0)\n<line42>error (EXIT_FAILURE, 0, _("%s: too many checksum lines"),\n<line43>quotef (checkfile_name));\n<line44>line_length = getline (&line, &line_chars_allocated, checkfile_stream);\n<line45>if (line_length <= 0)\n<line46>break;\n<line47>/* Ignore comment lines, which begin with a '#' character.  */\n<line48>if (line[0] == '#')\n<line49>continue;\n<line50>/* Remove any trailing newline.  */\n<line51>line_length -= line[line_length - 1] == '\n';\n<line52>/* Remove any trailing carriage return.  */\n<line53>line_length -= line[line_length - (0 < line_length)] == '\r';\n<line54>/* Ignore empty lines.  */\n<line55>if (line_length == 0)\n<line56>continue;\n<line57>line[line_length] = '\0';\n<line58>size_t d_len;\n<line59>if (! (split_3 (line, line_length, &digest, &d_len, &binary, &filename)\n<line60>&& ! (is_stdin && STREQ (filename, "-"))))\n<line61>{\n<line62>++n_misformatted_lines;\n<line63>if (warn)\n<line64>{\n<line65>error (0, 0,\n<line66>_("%s: %" PRIuMAX\n<line67>": improperly formatted %s checksum line"),\n<line68>quotef (checkfile_name), line_number,\n<line69>DIGEST_TYPE_STRING);\n<line70>}\n<line71>}\n<line72>else\n<line73>{\n<line74>bool ok;\n<line75>bool missing;\n<line76>bool needs_escape = ! status_only && problematic_chars (filename);\n<line77>properly_formatted_lines = true;\n<line78>uintmax_t length;\n<line79>ok = digest_file (filename, &binary, bin_buffer, &missing, &length);\n<line80>if (!ok)\n<line81>{\n<line82>++n_open_or_read_failures;\n<line83>if (!status_only)\n<line84>{\n<line85>if (needs_escape)\n<line86>putchar ('\\');\n<line87>print_filename (filename, needs_escape);\n<line88>printf (": %s\n", _("FAILED open or read"));\n<line89>}\n<line90>}\n<line91>else if (ignore_missing && missing)\n<line92>{\n<line93>/* Ignore missing files with --ignore-missing.  */\n<line94>;\n<line95>}\n<line96>else\n<line97>{\n<line98>bool match = false;\n<line99>#if HASH_ALGO_CKSUM\n<line100>if (d_len < digest_hex_bytes)\n<line101>match = b64_equal (digest, bin_buffer);\n<line102>else\n<line103>#endif\n<line104>if (d_len == digest_hex_bytes)\n<line105>match = hex_equal (digest, bin_buffer);\n<line106>if (match)\n<line107>matched_checksums = true;\n<line108>else\n<line109>++n_mismatched_checksums;\n<line110>if (!status_only)\n<line111>{\n<line112>if (! match || ! quiet)\n<line113>{\n<line114>if (needs_escape)\n<line115>putchar ('\\');\n<line116>print_filename (filename, needs_escape);\n<line117>}\n<line118>if (! match)\n<line119>printf (": %s\n", _("FAILED"));\n<line120>else if (!quiet)\n<line121>printf (": %s\n", _("OK"));\n<line122>}\n<line123>}\n<line124>}\n<line125>}\n<line126>while (!feof (checkfile_stream) && !ferror (checkfile_stream));\n<line127>free (line);\n<line128>int err = ferror (checkfile_stream) ? 0 : -1;\n<line129>if (is_stdin)\n<line130>clearerr (checkfile_stream);\n<line131>else if (fclose (checkfile_stream) != 0 && err < 0)\n<line132>err = errno;\n<line133>if (0 <= err)\n<line134>{\n<line135>error (0, err, err ? "%s" : _("%s: read error"),\n<line136>quotef (checkfile_name));\n<line137>return false;\n<line138>}\n<line139>if (! properly_formatted_lines)\n<line140>{\n<line141>/* Warn if no tests are found.  */\n<line142>error (0, 0, _("%s: no properly formatted checksum lines found"),\n<line143>quotef (checkfile_name));\n<line144>}\n<line145>else\n<line146>{\n<line147>if (!status_only)\n<line148>{\n<line149>if (n_misformatted_lines != 0)\n<line150>error (0, 0,\n<line151>(ngettext\n<line152>("WARNING: %" PRIuMAX " line is improperly formatted",\n<line153>"WARNING: %" PRIuMAX " lines are improperly formatted",\n<line154>select_plural (n_misformatted_lines))),\n<line155>n_misformatted_lines);\n<line156>if (n_open_or_read_failures != 0)\n<line157>error (0, 0,\n<line158>(ngettext\n<line159>("WARNING: %" PRIuMAX " listed file could not be read",\n<line160>"WARNING: %" PRIuMAX " listed files could not be read",\n<line161>select_plural (n_open_or_read_failures))),\n<line162>n_open_or_read_failures);\n<line163>if (n_mismatched_checksums != 0)\n<line164>error (0, 0,\n<line165>(ngettext\n<line166>("WARNING: %" PRIuMAX " computed checksum did NOT match",\n<line167>"WARNING: %" PRIuMAX " computed checksums did NOT match",\n<line168>select_plural (n_mismatched_checksums))),\n<line169>n_mismatched_checksums);\n<line170>if (ignore_missing && ! matched_checksums)\n<line171>error (0, 0, _("%s: no file was verified"),\n<line172>quotef (checkfile_name));\n<line173>}\n<line174>}\n<line175>return (properly_formatted_lines\n<line176>&& matched_checksums\n<line177>&& n_mismatched_checksums == 0\n<line178>&& n_open_or_read_failures == 0\n<line179>&& (!strict || n_misformatted_lines == 0));\n<line180>}
----------------------------------------
Function: main
Content: <line0>int\n<line1>main (int argc, char **argv)\n<line2>{\n<line3>unsigned char bin_buffer_unaligned[DIGEST_BIN_BYTES + DIGEST_ALIGN];\n<line4>/* Make sure bin_buffer is properly aligned. */\n<line5>unsigned char *bin_buffer = ptr_align (bin_buffer_unaligned, DIGEST_ALIGN);\n<line6>bool do_check = false;\n<line7>int opt;\n<line8>bool ok = true;\n<line9>int binary = -1;\n<line10>#if HASH_ALGO_CKSUM\n<line11>bool prefix_tag = true;\n<line12>#else\n<line13>bool prefix_tag = false;\n<line14>#endif\n<line15>/* Setting values of global variables.  */\n<line16>initialize_main (&argc, &argv);\n<line17>set_program_name (argv[0]);\n<line18>setlocale (LC_ALL, "");\n<line19>bindtextdomain (PACKAGE, LOCALEDIR);\n<line20>textdomain (PACKAGE);\n<line21>atexit (close_stdout);\n<line22>/* Line buffer stdout to ensure lines are written atomically and immediately\n<line23>so that processes running in parallel do not intersperse their output.  */\n<line24>setvbuf (stdout, nullptr, _IOLBF, 0);\n<line25>#if HASH_ALGO_SUM\n<line26>char const *short_opts = "rs";\n<line27>#elif HASH_ALGO_CKSUM\n<line28>char const *short_opts = "a:l:bctwz";\n<line29>char const *digest_length_str = "";\n<line30>#elif HASH_ALGO_BLAKE2\n<line31>char const *short_opts = "l:bctwz";\n<line32>char const *digest_length_str = "";\n<line33>#else\n<line34>char const *short_opts = "bctwz";\n<line35>#endif\n<line36>while ((opt = getopt_long (argc, argv, short_opts, long_options, nullptr))\n<line37>!= -1)\n<line38>switch (opt)\n<line39>{\n<line40>#if HASH_ALGO_CKSUM\n<line41>case 'a':\n<line42>cksum_algorithm = XARGMATCH_EXACT ("--algorithm", optarg,\n<line43>algorithm_args, algorithm_types);\n<line44>algorithm_specified = true;\n<line45>break;\n<line46>case DEBUG_PROGRAM_OPTION:\n<line47>cksum_debug = true;\n<line48>break;\n<line49>#endif\n<line50>#if HASH_ALGO_BLAKE2 || HASH_ALGO_CKSUM\n<line51>case 'l':\n<line52>digest_length = xdectoumax (optarg, 0, UINTMAX_MAX, "",\n<line53>_("invalid length"), 0);\n<line54>digest_length_str = optarg;\n<line55>if (digest_length % 8 != 0)\n<line56>{\n<line57>error (0, 0, _("invalid length: %s"), quote (digest_length_str));\n<line58>error (EXIT_FAILURE, 0, _("length is not a multiple of 8"));\n<line59>}\n<line60>break;\n<line61>#endif\n<line62>#if !HASH_ALGO_SUM\n<line63>case 'c':\n<line64>do_check = true;\n<line65>break;\n<line66>case STATUS_OPTION:\n<line67>status_only = true;\n<line68>warn = false;\n<line69>quiet = false;\n<line70>break;\n<line71>case 'b':\n<line72>binary = 1;\n<line73>break;\n<line74>case 't':\n<line75>binary = 0;\n<line76>break;\n<line77>case 'w':\n<line78>status_only = false;\n<line79>warn = true;\n<line80>quiet = false;\n<line81>break;\n<line82>case IGNORE_MISSING_OPTION:\n<line83>ignore_missing = true;\n<line84>break;\n<line85>case QUIET_OPTION:\n<line86>status_only = false;\n<line87>warn = false;\n<line88>quiet = true;\n<line89>break;\n<line90>case STRICT_OPTION:\n<line91>strict = true;\n<line92>break;\n<line93># if HASH_ALGO_CKSUM\n<line94>case BASE64_OPTION:\n<line95>base64_digest = true;\n<line96>break;\n<line97>case RAW_OPTION:\n<line98>raw_digest = true;\n<line99>break;\n<line100>case UNTAG_OPTION:\n<line101>prefix_tag = false;\n<line102>break;\n<line103># endif\n<line104>case TAG_OPTION:\n<line105>prefix_tag = true;\n<line106>binary = 1;\n<line107>break;\n<line108>case 'z':\n<line109>digest_delim = '\0';\n<line110>break;\n<line111>#endif\n<line112>#if HASH_ALGO_SUM\n<line113>case 'r':		/* For SysV compatibility. */\n<line114>sum_algorithm = bsd;\n<line115>break;\n<line116>case 's':\n<line117>sum_algorithm = sysv;\n<line118>break;\n<line119>#endif\n<line120>case_GETOPT_HELP_CHAR;\n<line121>case_GETOPT_VERSION_CHAR (PROGRAM_NAME, AUTHORS);\n<line122>default:\n<line123>usage (EXIT_FAILURE);\n<line124>}\n<line125>min_digest_line_length = MIN_DIGEST_LINE_LENGTH;\n<line126>#if HASH_ALGO_BLAKE2 || HASH_ALGO_CKSUM\n<line127># if HASH_ALGO_CKSUM\n<line128>if (digest_length && cksum_algorithm != blake2b)\n<line129>error (EXIT_FAILURE, 0,\n<line130>_("--length is only supported with --algorithm=blake2b"));\n<line131># endif\n<line132>if (digest_length > BLAKE2B_MAX_LEN * 8)\n<line133>{\n<line134>error (0, 0, _("invalid length: %s"), quote (digest_length_str));\n<line135>error (EXIT_FAILURE, 0,\n<line136>_("maximum digest length for %s is %d bits"),\n<line137>quote (DIGEST_TYPE_STRING),\n<line138>BLAKE2B_MAX_LEN * 8);\n<line139>}\n<line140>if (digest_length == 0)\n<line141>{\n<line142># if HASH_ALGO_BLAKE2\n<line143>digest_length = BLAKE2B_MAX_LEN * 8;\n<line144># else\n<line145>digest_length = algorithm_bits[cksum_algorithm];\n<line146># endif\n<line147>}\n<line148>digest_hex_bytes = digest_length / 4;\n<line149>#else\n<line150>digest_hex_bytes = DIGEST_HEX_BYTES;\n<line151>#endif\n<line152>#if HASH_ALGO_CKSUM\n<line153>switch (cksum_algorithm)\n<line154>{\n<line155>case bsd:\n<line156>case sysv:\n<line157>case crc:\n<line158>if (do_check && algorithm_specified)\n<line159>error (EXIT_FAILURE, 0,\n<line160>_("--check is not supported with --algorithm={bsd,sysv,crc}"));\n<line161>break;\n<line162>default:\n<line163>break;\n<line164>}\n<line165>if (base64_digest && raw_digest)\n<line166>{\n<line167>error (0, 0, _("--base64 and --raw are mutually exclusive"));\n<line168>usage (EXIT_FAILURE);\n<line169>}\n<line170>#endif\n<line171>if (prefix_tag && !binary)\n<line172>{\n<line173>/* This could be supported in a backwards compatible way\n<line174>by prefixing the output line with a space in text mode.\n<line175>However that's invasive enough that it was agreed to\n<line176>not support this mode with --tag, as --text use cases\n<line177>are adequately supported by the default output format.  */\n<line178>#if !HASH_ALGO_CKSUM\n<line179>error (0, 0, _("--tag does not support --text mode"));\n<line180>#else\n<line181>error (0, 0, _("--text mode is only supported with --untagged"));\n<line182>#endif\n<line183>usage (EXIT_FAILURE);\n<line184>}\n<line185>if (digest_delim != '\n' && do_check)\n<line186>{\n<line187>error (0, 0, _("the --zero option is not supported when "\n<line188>"verifying checksums"));\n<line189>usage (EXIT_FAILURE);\n<line190>}\n<line191>#if !HASH_ALGO_CKSUM\n<line192>if (prefix_tag && do_check)\n<line193>{\n<line194>error (0, 0, _("the --tag option is meaningless when "\n<line195>"verifying checksums"));\n<line196>usage (EXIT_FAILURE);\n<line197>}\n<line198>#endif\n<line199>if (0 <= binary && do_check)\n<line200>{\n<line201>error (0, 0, _("the --binary and --text options are meaningless when "\n<line202>"verifying checksums"));\n<line203>usage (EXIT_FAILURE);\n<line204>}\n<line205>if (ignore_missing && !do_check)\n<line206>{\n<line207>error (0, 0,\n<line208>_("the --ignore-missing option is meaningful only when "\n<line209>"verifying checksums"));\n<line210>usage (EXIT_FAILURE);\n<line211>}\n<line212>if (status_only && !do_check)\n<line213>{\n<line214>error (0, 0,\n<line215>_("the --status option is meaningful only when verifying checksums"));\n<line216>usage (EXIT_FAILURE);\n<line217>}\n<line218>if (warn && !do_check)\n<line219>{\n<line220>error (0, 0,\n<line221>_("the --warn option is meaningful only when verifying checksums"));\n<line222>usage (EXIT_FAILURE);\n<line223>}\n<line224>if (quiet && !do_check)\n<line225>{\n<line226>error (0, 0,\n<line227>_("the --quiet option is meaningful only when verifying checksums"));\n<line228>usage (EXIT_FAILURE);\n<line229>}\n<line230>if (strict & !do_check)\n<line231>{\n<line232>error (0, 0,\n<line233>_("the --strict option is meaningful only when verifying checksums"));\n<line234>usage (EXIT_FAILURE);\n<line235>}\n<line236>if (!O_BINARY && binary < 0)\n<line237>binary = 0;\n<line238>char **operand_lim = argv + argc;\n<line239>if (optind == argc)\n<line240>*operand_lim++ = bad_cast ("-");\n<line241>else if (1 < argc - optind && raw_digest)\n<line242>error (EXIT_FAILURE, 0,\n<line243>_("the --raw option is not supported with multiple files"));\n<line244>for (char **operandp = argv + optind; operandp < operand_lim; operandp++)\n<line245>{\n<line246>char *file = *operandp;\n<line247>if (do_check)\n<line248>ok &= digest_check (file);\n<line249>else\n<line250>{\n<line251>int binary_file = binary;\n<line252>bool missing;\n<line253>uintmax_t length;\n<line254>if (! digest_file (file, &binary_file, bin_buffer, &missing, &length))\n<line255>ok = false;\n<line256>else\n<line257>{\n<line258>DIGEST_OUT (file, binary_file, bin_buffer, raw_digest, prefix_tag,\n<line259>digest_delim, optind != argc, length);\n<line260>}\n<line261>}\n<line262>}\n<line263>if (have_read_stdin && fclose (stdin) == EOF)\n<line264>error (EXIT_FAILURE, errno, _("standard input"));\n<line265>return ok ? EXIT_SUCCESS : EXIT_FAILURE;\n<line266>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/src/sync.c
========================================
Function: usage
Content: <line0>void\n<line1>usage (int status)\n<line2>{\n<line3>if (status != EXIT_SUCCESS)\n<line4>emit_try_help ();\n<line5>else\n<line6>{\n<line7>printf (_("Usage: %s [OPTION] [FILE]...\n"), program_name);\n<line8>fputs (_("\\n<line9>Synchronize cached writes to persistent storage\n\\n<line10>\n\\n<line11>If one or more files are specified, sync only them,\n\\n<line12>or their containing file systems.\n\\n<line13>\n\\n<line14>"), stdout);\n<line15>fputs (_("\\n<line16>-d, --data             sync only file data, no unneeded metadata\n\\n<line17>"), stdout);\n<line18>fputs (_("\\n<line19>-f, --file-system      sync the file systems that contain the files\n\\n<line20>"), stdout);\n<line21>fputs (HELP_OPTION_DESCRIPTION, stdout);\n<line22>fputs (VERSION_OPTION_DESCRIPTION, stdout);\n<line23>emit_ancillary_info (PROGRAM_NAME);\n<line24>}\n<line25>exit (status);\n<line26>}
----------------------------------------
Function: sync_arg
Content: <line0>static bool\n<line1>sync_arg (enum sync_mode mode, char const *file)\n<line2>{\n<line3>bool ret = true;\n<line4>int open_flags = O_RDONLY | O_NONBLOCK;\n<line5>int fd;\n<line6>#if defined _AIX || defined __CYGWIN__\n<line7>/* AIX 7.1, CYGWIN 2.9.0, fsync requires write access to file.  */\n<line8>if (mode == MODE_FILE)\n<line9>open_flags = O_WRONLY | O_NONBLOCK;\n<line10>#endif\n<line11>/* Note O_PATH might be supported with syncfs(),\n<line12>though as of Linux 3.18 is not.  */\n<line13>fd = open (file, open_flags);\n<line14>if (fd < 0)\n<line15>{\n<line16>/* Use the O_RDONLY errno, which is significant\n<line17>with directories for example.  */\n<line18>int rd_errno = errno;\n<line19>if (open_flags != (O_WRONLY | O_NONBLOCK))\n<line20>fd = open (file, O_WRONLY | O_NONBLOCK);\n<line21>if (fd < 0)\n<line22>{\n<line23>error (0, rd_errno, _("error opening %s"), quoteaf (file));\n<line24>return false;\n<line25>}\n<line26>}\n<line27>/* We used O_NONBLOCK above to not hang with fifos,\n<line28>so reset that here.  */\n<line29>int fdflags = fcntl (fd, F_GETFL);\n<line30>if (fdflags == -1\n<line31>|| fcntl (fd, F_SETFL, fdflags & ~O_NONBLOCK) < 0)\n<line32>{\n<line33>error (0, errno, _("couldn't reset non-blocking mode %s"),\n<line34>quoteaf (file));\n<line35>ret = false;\n<line36>}\n<line37>if (ret == true)\n<line38>{\n<line39>int sync_status = -1;\n<line40>switch (mode)\n<line41>{\n<line42>case MODE_DATA:\n<line43>sync_status = fdatasync (fd);\n<line44>break;\n<line45>case MODE_FILE:\n<line46>sync_status = fsync (fd);\n<line47>break;\n<line48>#if HAVE_SYNCFS\n<line49>case MODE_FILE_SYSTEM:\n<line50>sync_status = syncfs (fd);\n<line51>break;\n<line52>#endif\n<line53>default:\n<line54>unreachable ();\n<line55>}\n<line56>if (sync_status < 0)\n<line57>{\n<line58>error (0, errno, _("error syncing %s"), quoteaf (file));\n<line59>ret = false;\n<line60>}\n<line61>}\n<line62>if (close (fd) < 0)\n<line63>{\n<line64>error (0, errno, _("failed to close %s"), quoteaf (file));\n<line65>ret = false;\n<line66>}\n<line67>return ret;\n<line68>}
----------------------------------------
Function: main
Content: <line0>int\n<line1>main (int argc, char **argv)\n<line2>{\n<line3>int c;\n<line4>bool args_specified;\n<line5>bool arg_data = false, arg_file_system = false;\n<line6>enum sync_mode mode;\n<line7>bool ok = true;\n<line8>initialize_main (&argc, &argv);\n<line9>set_program_name (argv[0]);\n<line10>setlocale (LC_ALL, "");\n<line11>bindtextdomain (PACKAGE, LOCALEDIR);\n<line12>textdomain (PACKAGE);\n<line13>atexit (close_stdout);\n<line14>while ((c = getopt_long (argc, argv, "df", long_options, nullptr))\n<line15>!= -1)\n<line16>{\n<line17>switch (c)\n<line18>{\n<line19>case 'd':\n<line20>arg_data = true;\n<line21>break;\n<line22>case 'f':\n<line23>arg_file_system = true;\n<line24>break;\n<line25>case_GETOPT_HELP_CHAR;\n<line26>case_GETOPT_VERSION_CHAR (PROGRAM_NAME, AUTHORS);\n<line27>default:\n<line28>usage (EXIT_FAILURE);\n<line29>}\n<line30>}\n<line31>args_specified = optind < argc;\n<line32>if (arg_data && arg_file_system)\n<line33>error (EXIT_FAILURE, 0,\n<line34>_("cannot specify both --data and --file-system"));\n<line35>if (!args_specified && arg_data)\n<line36>error (EXIT_FAILURE, 0, _("--data needs at least one argument"));\n<line37>if (! args_specified || (arg_file_system && ! HAVE_SYNCFS))\n<line38>mode = MODE_SYNC;\n<line39>else if (arg_file_system)\n<line40>mode = MODE_FILE_SYSTEM;\n<line41>else if (! arg_data)\n<line42>mode = MODE_FILE;\n<line43>else\n<line44>mode = MODE_DATA;\n<line45>if (mode == MODE_SYNC)\n<line46>sync ();\n<line47>else\n<line48>{\n<line49>for (; optind < argc; optind++)\n<line50>ok &= sync_arg (mode, argv[optind]);\n<line51>}\n<line52>return ok ? EXIT_SUCCESS : EXIT_FAILURE;\n<line53>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/src/tac.c
========================================
Function: usage
Content: <line0>void\n<line1>usage (int status)\n<line2>{\n<line3>if (status != EXIT_SUCCESS)\n<line4>emit_try_help ();\n<line5>else\n<line6>{\n<line7>printf (_("\\n<line8>Usage: %s [OPTION]... [FILE]...\n\\n<line9>"),\n<line10>program_name);\n<line11>fputs (_("\\n<line12>Write each FILE to standard output, last line first.\n\\n<line13>"), stdout);\n<line14>emit_stdin_note ();\n<line15>emit_mandatory_arg_note ();\n<line16>fputs (_("\\n<line17>-b, --before             attach the separator before instead of after\n\\n<line18>-r, --regex              interpret the separator as a regular expression\n\\n<line19>-s, --separator=STRING   use STRING as the separator instead of newline\n\\n<line20>"), stdout);\n<line21>fputs (HELP_OPTION_DESCRIPTION, stdout);\n<line22>fputs (VERSION_OPTION_DESCRIPTION, stdout);\n<line23>emit_ancillary_info (PROGRAM_NAME);\n<line24>}\n<line25>exit (status);\n<line26>}
----------------------------------------
Function: output
Content: <line0>static void\n<line1>output (char const *start, char const *past_end)\n<line2>{\n<line3>static char buffer[WRITESIZE];\n<line4>static size_t bytes_in_buffer = 0;\n<line5>size_t bytes_to_add = past_end - start;\n<line6>size_t bytes_available = WRITESIZE - bytes_in_buffer;\n<line7>if (start == 0)\n<line8>{\n<line9>fwrite (buffer, 1, bytes_in_buffer, stdout);\n<line10>bytes_in_buffer = 0;\n<line11>return;\n<line12>}\n<line13>/* Write out as many full buffers as possible. */\n<line14>while (bytes_to_add >= bytes_available)\n<line15>{\n<line16>memcpy (buffer + bytes_in_buffer, start, bytes_available);\n<line17>bytes_to_add -= bytes_available;\n<line18>start += bytes_available;\n<line19>fwrite (buffer, 1, WRITESIZE, stdout);\n<line20>bytes_in_buffer = 0;\n<line21>bytes_available = WRITESIZE;\n<line22>}\n<line23>memcpy (buffer + bytes_in_buffer, start, bytes_to_add);\n<line24>bytes_in_buffer += bytes_to_add;\n<line25>}
----------------------------------------
Function: tac_seekable
Content: <line0>static bool\n<line1>tac_seekable (int input_fd, char const *file, off_t file_pos)\n<line2>{\n<line3>/* Pointer to the location in 'G_buffer' where the search for\n<line4>the next separator will begin. */\n<line5>char *match_start;\n<line6>/* Pointer to one past the rightmost character in 'G_buffer' that\n<line7>has not been printed yet. */\n<line8>char *past_end;\n<line9>/* Length of the record growing in 'G_buffer'. */\n<line10>size_t saved_record_size;\n<line11>/* True if 'output' has not been called yet for any file.\n<line12>Only used when the separator is attached to the preceding record. */\n<line13>bool first_time = true;\n<line14>char first_char = *separator;	/* Speed optimization, non-regexp. */\n<line15>char const *separator1 = separator + 1; /* Speed optimization, non-regexp. */\n<line16>size_t match_length1 = match_length - 1; /* Speed optimization, non-regexp. */\n<line17>/* Arrange for the first read to lop off enough to leave the rest of the\n<line18>file a multiple of 'read_size'.  Since 'read_size' can change, this may\n<line19>not always hold during the program run, but since it usually will, leave\n<line20>it here for i/o efficiency (page/sector boundaries and all that).\n<line21>Note: the efficiency gain has not been verified. */\n<line22>size_t remainder = file_pos % read_size;\n<line23>if (remainder != 0)\n<line24>{\n<line25>file_pos -= remainder;\n<line26>if (lseek (input_fd, file_pos, SEEK_SET) < 0)\n<line27>error (0, errno, _("%s: seek failed"), quotef (file));\n<line28>}\n<line29>/* Scan backward, looking for end of file.  This caters to proc-like\n<line30>file systems where the file size is just an estimate.  */\n<line31>while ((saved_record_size = safe_read (input_fd, G_buffer, read_size)) == 0\n<line32>&& file_pos != 0)\n<line33>{\n<line34>off_t rsize = read_size;\n<line35>if (lseek (input_fd, -rsize, SEEK_CUR) < 0)\n<line36>error (0, errno, _("%s: seek failed"), quotef (file));\n<line37>file_pos -= read_size;\n<line38>}\n<line39>/* Now scan forward, looking for end of file.  */\n<line40>while (saved_record_size == read_size)\n<line41>{\n<line42>size_t nread = safe_read (input_fd, G_buffer, read_size);\n<line43>if (nread == 0)\n<line44>break;\n<line45>saved_record_size = nread;\n<line46>if (saved_record_size == SAFE_READ_ERROR)\n<line47>break;\n<line48>file_pos += nread;\n<line49>}\n<line50>if (saved_record_size == SAFE_READ_ERROR)\n<line51>{\n<line52>error (0, errno, _("%s: read error"), quotef (file));\n<line53>return false;\n<line54>}\n<line55>match_start = past_end = G_buffer + saved_record_size;\n<line56>/* For non-regexp search, move past impossible positions for a match. */\n<line57>if (sentinel_length)\n<line58>match_start -= match_length1;\n<line59>while (true)\n<line60>{\n<line61>/* Search backward from 'match_start' - 1 to 'G_buffer' for a match\n<line62>with 'separator'; for speed, use strncmp if 'separator' contains no\n<line63>metacharacters.\n<line64>If the match succeeds, set 'match_start' to point to the start of\n<line65>the match and 'match_length' to the length of the match.\n<line66>Otherwise, make 'match_start' < 'G_buffer'. */\n<line67>if (sentinel_length == 0)\n<line68>{\n<line69>size_t i = match_start - G_buffer;\n<line70>regoff_t ri = i;\n<line71>regoff_t range = 1 - ri;\n<line72>regoff_t ret;\n<line73>if (1 < range)\n<line74>error (EXIT_FAILURE, 0, _("record too large"));\n<line75>if (range == 1\n<line76>|| ((ret = re_search (&compiled_separator, G_buffer,\n<line77>i, i - 1, range, &regs))\n<line78>== -1))\n<line79>match_start = G_buffer - 1;\n<line80>else if (ret == -2)\n<line81>error (EXIT_FAILURE, 0,\n<line82>_("error in regular expression search"));\n<line83>else\n<line84>{\n<line85>match_start = G_buffer + regs.start[0];\n<line86>match_length = regs.end[0] - regs.start[0];\n<line87>}\n<line88>}\n<line89>else\n<line90>{\n<line91>/* 'match_length' is constant for non-regexp boundaries. */\n<line92>while (*--match_start != first_char\n<line93>|| (match_length1 && !STREQ_LEN (match_start + 1, separator1,\n<line94>match_length1)))\n<line95>/* Do nothing. */ ;\n<line96>}\n<line97>/* Check whether we backed off the front of 'G_buffer' without finding\n<line98>a match for 'separator'. */\n<line99>if (match_start < G_buffer)\n<line100>{\n<line101>if (file_pos == 0)\n<line102>{\n<line103>/* Hit the beginning of the file; print the remaining record. */\n<line104>output (G_buffer, past_end);\n<line105>return true;\n<line106>}\n<line107>saved_record_size = past_end - G_buffer;\n<line108>if (saved_record_size > read_size)\n<line109>{\n<line110>/* 'G_buffer_size' is about twice 'read_size', so since\n<line111>we want to read in another 'read_size' bytes before\n<line112>the data already in 'G_buffer', we need to increase\n<line113>'G_buffer_size'. */\n<line114>char *newbuffer;\n<line115>size_t offset = sentinel_length ? sentinel_length : 1;\n<line116>size_t old_G_buffer_size = G_buffer_size;\n<line117>read_size *= 2;\n<line118>G_buffer_size = read_size * 2 + sentinel_length + 2;\n<line119>if (G_buffer_size < old_G_buffer_size)\n<line120>xalloc_die ();\n<line121>newbuffer = xrealloc (G_buffer - offset, G_buffer_size);\n<line122>newbuffer += offset;\n<line123>G_buffer = newbuffer;\n<line124>}\n<line125>/* Back up to the start of the next bufferfull of the file.  */\n<line126>if (file_pos >= read_size)\n<line127>file_pos -= read_size;\n<line128>else\n<line129>{\n<line130>read_size = file_pos;\n<line131>file_pos = 0;\n<line132>}\n<line133>if (lseek (input_fd, file_pos, SEEK_SET) < 0)\n<line134>error (0, errno, _("%s: seek failed"), quotef (file));\n<line135>/* Shift the pending record data right to make room for the new.\n<line136>The source and destination regions probably overlap.  */\n<line137>memmove (G_buffer + read_size, G_buffer, saved_record_size);\n<line138>past_end = G_buffer + read_size + saved_record_size;\n<line139>/* For non-regexp searches, avoid unnecessary scanning. */\n<line140>if (sentinel_length)\n<line141>match_start = G_buffer + read_size;\n<line142>else\n<line143>match_start = past_end;\n<line144>if (full_read (input_fd, G_buffer, read_size) != read_size)\n<line145>{\n<line146>error (0, errno, _("%s: read error"), quotef (file));\n<line147>return false;\n<line148>}\n<line149>}\n<line150>else\n<line151>{\n<line152>/* Found a match of 'separator'. */\n<line153>if (separator_ends_record)\n<line154>{\n<line155>char *match_end = match_start + match_length;\n<line156>/* If this match of 'separator' isn't at the end of the\n<line157>file, print the record. */\n<line158>if (!first_time || match_end != past_end)\n<line159>output (match_end, past_end);\n<line160>past_end = match_end;\n<line161>first_time = false;\n<line162>}\n<line163>else\n<line164>{\n<line165>output (match_start, past_end);\n<line166>past_end = match_start;\n<line167>}\n<line168>/* For non-regex matching, we can back up.  */\n<line169>if (sentinel_length > 0)\n<line170>match_start -= match_length - 1;\n<line171>}\n<line172>}\n<line173>}
----------------------------------------
Function: copy_to_temp
Content: <line0>static off_t\n<line1>copy_to_temp (FILE **g_tmp, char **g_tempfile, int input_fd, char const *file)\n<line2>{\n<line3>FILE *fp;\n<line4>char *file_name;\n<line5>uintmax_t bytes_copied = 0;\n<line6>if (!temp_stream (&fp, &file_name))\n<line7>return -1;\n<line8>while (true)\n<line9>{\n<line10>size_t bytes_read = safe_read (input_fd, G_buffer, read_size);\n<line11>if (bytes_read == 0)\n<line12>break;\n<line13>if (bytes_read == SAFE_READ_ERROR)\n<line14>{\n<line15>error (0, errno, _("%s: read error"), quotef (file));\n<line16>return -1;\n<line17>}\n<line18>if (fwrite (G_buffer, 1, bytes_read, fp) != bytes_read)\n<line19>{\n<line20>error (0, errno, _("%s: write error"), quotef (file_name));\n<line21>return -1;\n<line22>}\n<line23>/* Implicitly <= OFF_T_MAX due to preceding fwrite(),\n<line24>but unsigned type used to avoid compiler warnings\n<line25>not aware of this fact.  */\n<line26>bytes_copied += bytes_read;\n<line27>}\n<line28>if (fflush (fp) != 0)\n<line29>{\n<line30>error (0, errno, _("%s: write error"), quotef (file_name));\n<line31>return -1;\n<line32>}\n<line33>*g_tmp = fp;\n<line34>*g_tempfile = file_name;\n<line35>return bytes_copied;\n<line36>}
----------------------------------------
Function: tac_nonseekable
Content: <line0>static bool\n<line1>tac_nonseekable (int input_fd, char const *file)\n<line2>{\n<line3>FILE *tmp_stream;\n<line4>char *tmp_file;\n<line5>off_t bytes_copied = copy_to_temp (&tmp_stream, &tmp_file, input_fd, file);\n<line6>if (bytes_copied < 0)\n<line7>return false;\n<line8>bool ok = tac_seekable (fileno (tmp_stream), tmp_file, bytes_copied);\n<line9>return ok;\n<line10>}
----------------------------------------
Function: tac_file
Content: <line0>static bool\n<line1>tac_file (char const *filename)\n<line2>{\n<line3>bool ok;\n<line4>off_t file_size;\n<line5>int fd;\n<line6>bool is_stdin = STREQ (filename, "-");\n<line7>if (is_stdin)\n<line8>{\n<line9>have_read_stdin = true;\n<line10>fd = STDIN_FILENO;\n<line11>filename = _("standard input");\n<line12>xset_binary_mode (STDIN_FILENO, O_BINARY);\n<line13>}\n<line14>else\n<line15>{\n<line16>fd = open (filename, O_RDONLY | O_BINARY);\n<line17>if (fd < 0)\n<line18>{\n<line19>error (0, errno, _("failed to open %s for reading"),\n<line20>quoteaf (filename));\n<line21>return false;\n<line22>}\n<line23>}\n<line24>file_size = lseek (fd, 0, SEEK_END);\n<line25>ok = (file_size < 0 || isatty (fd)\n<line26>? tac_nonseekable (fd, filename)\n<line27>: tac_seekable (fd, filename, file_size));\n<line28>if (!is_stdin && close (fd) != 0)\n<line29>{\n<line30>error (0, errno, _("%s: read error"), quotef (filename));\n<line31>ok = false;\n<line32>}\n<line33>return ok;\n<line34>}
----------------------------------------
Function: main
Content: <line0>int\n<line1>main (int argc, char **argv)\n<line2>{\n<line3>char const *error_message;	/* Return value from re_compile_pattern. */\n<line4>int optc;\n<line5>bool ok;\n<line6>size_t half_buffer_size;\n<line7>/* Initializer for file_list if no file-arguments\n<line8>were specified on the command line.  */\n<line9>static char const *const default_file_list[] = {"-", nullptr};\n<line10>char const *const *file;\n<line11>initialize_main (&argc, &argv);\n<line12>set_program_name (argv[0]);\n<line13>setlocale (LC_ALL, "");\n<line14>bindtextdomain (PACKAGE, LOCALEDIR);\n<line15>textdomain (PACKAGE);\n<line16>atexit (close_stdout);\n<line17>separator = "\n";\n<line18>sentinel_length = 1;\n<line19>separator_ends_record = true;\n<line20>while ((optc = getopt_long (argc, argv, "brs:", longopts, nullptr)) != -1)\n<line21>{\n<line22>switch (optc)\n<line23>{\n<line24>case 'b':\n<line25>separator_ends_record = false;\n<line26>break;\n<line27>case 'r':\n<line28>sentinel_length = 0;\n<line29>break;\n<line30>case 's':\n<line31>separator = optarg;\n<line32>break;\n<line33>case_GETOPT_HELP_CHAR;\n<line34>case_GETOPT_VERSION_CHAR (PROGRAM_NAME, AUTHORS);\n<line35>default:\n<line36>usage (EXIT_FAILURE);\n<line37>}\n<line38>}\n<line39>if (sentinel_length == 0)\n<line40>{\n<line41>if (*separator == 0)\n<line42>error (EXIT_FAILURE, 0, _("separator cannot be empty"));\n<line43>compiled_separator.buffer = nullptr;\n<line44>compiled_separator.allocated = 0;\n<line45>compiled_separator.fastmap = compiled_separator_fastmap;\n<line46>compiled_separator.translate = nullptr;\n<line47>error_message = re_compile_pattern (separator, strlen (separator),\n<line48>&compiled_separator);\n<line49>if (error_message)\n<line50>error (EXIT_FAILURE, 0, "%s", (error_message));\n<line51>}\n<line52>else\n<line53>match_length = sentinel_length = *separator ? strlen (separator) : 1;\n<line54>read_size = INITIAL_READSIZE;\n<line55>while (sentinel_length >= read_size / 2)\n<line56>{\n<line57>if (SIZE_MAX / 2 < read_size)\n<line58>xalloc_die ();\n<line59>read_size *= 2;\n<line60>}\n<line61>half_buffer_size = read_size + sentinel_length + 1;\n<line62>G_buffer_size = 2 * half_buffer_size;\n<line63>if (! (read_size < half_buffer_size && half_buffer_size < G_buffer_size))\n<line64>xalloc_die ();\n<line65>G_buffer = xmalloc (G_buffer_size);\n<line66>if (sentinel_length)\n<line67>{\n<line68>memcpy (G_buffer, separator, sentinel_length + 1);\n<line69>G_buffer += sentinel_length;\n<line70>}\n<line71>else\n<line72>{\n<line73>++G_buffer;\n<line74>}\n<line75>file = (optind < argc\n<line76>? (char const *const *) &argv[optind]\n<line77>: default_file_list);\n<line78>xset_binary_mode (STDOUT_FILENO, O_BINARY);\n<line79>{\n<line80>ok = true;\n<line81>for (size_t i = 0; file[i]; ++i)\n<line82>ok &= tac_file (file[i]);\n<line83>}\n<line84>/* Flush the output buffer. */\n<line85>output ((char *) nullptr, (char *) nullptr);\n<line86>if (have_read_stdin && close (STDIN_FILENO) < 0)\n<line87>{\n<line88>error (0, errno, "-");\n<line89>ok = false;\n<line90>}\n<line91>main_exit (ok ? EXIT_SUCCESS : EXIT_FAILURE);\n<line92>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/src/tail.c
========================================
Function: usage
Content: <line0>void\n<line1>usage (int status)\n<line2>{\n<line3>if (status != EXIT_SUCCESS)\n<line4>emit_try_help ();\n<line5>else\n<line6>{\n<line7>printf (_("\\n<line8>Usage: %s [OPTION]... [FILE]...\n\\n<line9>"),\n<line10>program_name);\n<line11>printf (_("\\n<line12>Print the last %d lines of each FILE to standard output.\n\\n<line13>With more than one FILE, precede each with a header giving the file name.\n\\n<line14>"), DEFAULT_N_LINES);\n<line15>emit_stdin_note ();\n<line16>emit_mandatory_arg_note ();\n<line17>fputs (_("\\n<line18>-c, --bytes=[+]NUM       output the last NUM bytes; or use -c +NUM to\n\\n<line19>output starting with byte NUM of each file\n\\n<line20>"), stdout);\n<line21>fputs (_("\\n<line22>-f, --follow[={name|descriptor}]\n\\n<line23>output appended data as the file grows;\n\\n<line24>an absent option argument means 'descriptor'\n\\n<line25>-F                       same as --follow=name --retry\n\\n<line26>"), stdout);\n<line27>printf (_("\\n<line28>-n, --lines=[+]NUM       output the last NUM lines, instead of the last %d;\n\\n<line29>or use -n +NUM to skip NUM-1 lines at the start\n\\n<line30>"),\n<line31>DEFAULT_N_LINES\n<line32>);\n<line33>printf (_("\\n<line34>--max-unchanged-stats=N\n\\n<line35>with --follow=name, reopen a FILE which has not\n\\n<line36>changed size after N (default %d) iterations\n\\n<line37>to see if it has been unlinked or renamed\n\\n<line38>(this is the usual case of rotated log files);\n\\n<line39>with inotify, this option is rarely useful\n\\n<line40>"),\n<line41>DEFAULT_MAX_N_UNCHANGED_STATS_BETWEEN_OPENS\n<line42>);\n<line43>fputs (_("\\n<line44>--pid=PID            with -f, terminate after process ID, PID dies\n\\n<line45>-q, --quiet, --silent    never output headers giving file names\n\\n<line46>--retry              keep trying to open a file if it is inaccessible\n\\n<line47>"), stdout);\n<line48>fputs (_("\\n<line49>-s, --sleep-interval=N   with -f, sleep for approximately N seconds\n\\n<line50>(default 1.0) between iterations;\n\\n<line51>with inotify and --pid=P, check process P at\n\\n<line52>least once every N seconds\n\\n<line53>-v, --verbose            always output headers giving file names\n\\n<line54>"), stdout);\n<line55>fputs (_("\\n<line56>-z, --zero-terminated    line delimiter is NUL, not newline\n\\n<line57>"), stdout);\n<line58>fputs (HELP_OPTION_DESCRIPTION, stdout);\n<line59>fputs (VERSION_OPTION_DESCRIPTION, stdout);\n<line60>fputs (_("\\n<line61>\n\\n<line62>NUM may have a multiplier suffix:\n\\n<line63>b 512, kB 1000, K 1024, MB 1000*1000, M 1024*1024,\n\\n<line64>GB 1000*1000*1000, G 1024*1024*1024, and so on for T, P, E, Z, Y, R, Q.\n\\n<line65>Binary prefixes can be used, too: KiB=K, MiB=M, and so on.\n\\n<line66>\n\\n<line67>"), stdout);\n<line68>fputs (_("\\n<line69>With --follow (-f), tail defaults to following the file descriptor, which\n\\n<line70>means that even if a tail'ed file is renamed, tail will continue to track\n\\n<line71>its end.  This default behavior is not desirable when you really want to\n\\n<line72>track the actual name of the file, not the file descriptor (e.g., log\n\\n<line73>rotation).  Use --follow=name in that case.  That causes tail to track the\n\\n<line74>named file in a way that accommodates renaming, removal and creation.\n\\n<line75>"), stdout);\n<line76>emit_ancillary_info (PROGRAM_NAME);\n<line77>}\n<line78>exit (status);\n<line79>}
----------------------------------------
Function: die_pipe
Content: <line0>static void\n<line1>die_pipe (void)\n<line2>{\n<line3>raise (SIGPIPE);\n<line4>exit (EXIT_FAILURE);\n<line5>}
----------------------------------------
Function: check_output_alive
Content: <line0>static void\n<line1>check_output_alive (void)\n<line2>{\n<line3>if (! monitor_output)\n<line4>return;\n<line5>if (iopoll (-1, STDOUT_FILENO, false) == IOPOLL_BROKEN_OUTPUT)\n<line6>die_pipe ();\n<line7>}
----------------------------------------
Function: pretty_name
Content: <line0>static char const *\n<line1>pretty_name (struct File_spec const *f)\n<line2>{\n<line3>return (STREQ (f->name, "-") ? _("standard input") : f->name);\n<line4>}
----------------------------------------
Function: record_open_fd
Content: <line0>static void\n<line1>record_open_fd (struct File_spec *f, int fd,\n<line2>off_t size, struct stat const *st,\n<line3>int blocking)\n<line4>{\n<line5>f->fd = fd;\n<line6>f->size = size;\n<line7>f->mtime = get_stat_mtime (st);\n<line8>f->dev = st->st_dev;\n<line9>f->ino = st->st_ino;\n<line10>f->mode = st->st_mode;\n<line11>f->blocking = blocking;\n<line12>f->n_unchanged_stats = 0;\n<line13>f->ignore = false;\n<line14>}
----------------------------------------
Function: close_fd
Content: <line0>static void\n<line1>close_fd (int fd, char const *filename)\n<line2>{\n<line3>if (fd != -1 && fd != STDIN_FILENO && close (fd))\n<line4>{\n<line5>error (0, errno, _("closing %s (fd=%d)"), quoteaf (filename), fd);\n<line6>}\n<line7>}
----------------------------------------
Function: write_header
Content: <line0>static void\n<line1>write_header (char const *pretty_filename)\n<line2>{\n<line3>static bool first_file = true;\n<line4>printf ("%s==> %s <==\n", (first_file ? "" : "\n"), pretty_filename);\n<line5>first_file = false;\n<line6>}
----------------------------------------
Function: xwrite_stdout
Content: <line0>static void\n<line1>xwrite_stdout (char const *buffer, size_t n_bytes)\n<line2>{\n<line3>if (n_bytes > 0 && fwrite (buffer, 1, n_bytes, stdout) < n_bytes)\n<line4>{\n<line5>clearerr (stdout); /* To avoid redundant close_stdout diagnostic.  */\n<line6>error (EXIT_FAILURE, errno, _("error writing %s"),\n<line7>quoteaf ("standard output"));\n<line8>}\n<line9>}
----------------------------------------
Function: dump_remainder
Content: <line0>static uintmax_t\n<line1>dump_remainder (bool want_header, char const *pretty_filename, int fd,\n<line2>uintmax_t n_bytes)\n<line3>{\n<line4>uintmax_t n_written;\n<line5>uintmax_t n_remaining = n_bytes;\n<line6>n_written = 0;\n<line7>while (true)\n<line8>{\n<line9>char buffer[BUFSIZ];\n<line10>size_t n = MIN (n_remaining, BUFSIZ);\n<line11>size_t bytes_read = safe_read (fd, buffer, n);\n<line12>if (bytes_read == SAFE_READ_ERROR)\n<line13>{\n<line14>if (errno != EAGAIN)\n<line15>error (EXIT_FAILURE, errno, _("error reading %s"),\n<line16>quoteaf (pretty_filename));\n<line17>break;\n<line18>}\n<line19>if (bytes_read == 0)\n<line20>break;\n<line21>if (want_header)\n<line22>{\n<line23>write_header (pretty_filename);\n<line24>want_header = false;\n<line25>}\n<line26>xwrite_stdout (buffer, bytes_read);\n<line27>n_written += bytes_read;\n<line28>if (n_bytes != COPY_TO_EOF)\n<line29>{\n<line30>n_remaining -= bytes_read;\n<line31>if (n_remaining == 0 || n_bytes == COPY_A_BUFFER)\n<line32>break;\n<line33>}\n<line34>}\n<line35>return n_written;\n<line36>}
----------------------------------------
Function: xlseek
Content: <line0>static off_t\n<line1>xlseek (int fd, off_t offset, int whence, char const *filename)\n<line2>{\n<line3>off_t new_offset = lseek (fd, offset, whence);\n<line4>char buf[INT_BUFSIZE_BOUND (offset)];\n<line5>char *s;\n<line6>if (0 <= new_offset)\n<line7>return new_offset;\n<line8>s = offtostr (offset, buf);\n<line9>switch (whence)\n<line10>{\n<line11>case SEEK_SET:\n<line12>error (EXIT_FAILURE, errno, _("%s: cannot seek to offset %s"),\n<line13>quotef (filename), s);\n<line14>break;\n<line15>case SEEK_CUR:\n<line16>error (EXIT_FAILURE, errno, _("%s: cannot seek to relative offset %s"),\n<line17>quotef (filename), s);\n<line18>break;\n<line19>case SEEK_END:\n<line20>error (EXIT_FAILURE, errno,\n<line21>_("%s: cannot seek to end-relative offset %s"),\n<line22>quotef (filename), s);\n<line23>break;\n<line24>default:\n<line25>unreachable ();\n<line26>}\n<line27>}
----------------------------------------
Function: file_lines
Content: <line0>static bool\n<line1>file_lines (char const *pretty_filename, int fd, uintmax_t n_lines,\n<line2>off_t start_pos, off_t end_pos, uintmax_t *read_pos)\n<line3>{\n<line4>char buffer[BUFSIZ];\n<line5>size_t bytes_read;\n<line6>off_t pos = end_pos;\n<line7>if (n_lines == 0)\n<line8>return true;\n<line9>/* Set 'bytes_read' to the size of the last, probably partial, buffer;\n<line10>0 < 'bytes_read' <= 'BUFSIZ'.  */\n<line11>bytes_read = (pos - start_pos) % BUFSIZ;\n<line12>if (bytes_read == 0)\n<line13>bytes_read = BUFSIZ;\n<line14>/* Make 'pos' a multiple of 'BUFSIZ' (0 if the file is short), so that all\n<line15>reads will be on block boundaries, which might increase efficiency.  */\n<line16>pos -= bytes_read;\n<line17>xlseek (fd, pos, SEEK_SET, pretty_filename);\n<line18>bytes_read = safe_read (fd, buffer, bytes_read);\n<line19>if (bytes_read == SAFE_READ_ERROR)\n<line20>{\n<line21>error (0, errno, _("error reading %s"), quoteaf (pretty_filename));\n<line22>return false;\n<line23>}\n<line24>*read_pos = pos + bytes_read;\n<line25>/* Count the incomplete line on files that don't end with a newline.  */\n<line26>if (bytes_read && buffer[bytes_read - 1] != line_end)\n<line27>--n_lines;\n<line28>do\n<line29>{\n<line30>/* Scan backward, counting the newlines in this bufferfull.  */\n<line31>size_t n = bytes_read;\n<line32>while (n)\n<line33>{\n<line34>char const *nl;\n<line35>nl = memrchr (buffer, line_end, n);\n<line36>if (nl == nullptr)\n<line37>break;\n<line38>n = nl - buffer;\n<line39>if (n_lines-- == 0)\n<line40>{\n<line41>/* If this newline isn't the last character in the buffer,\n<line42>output the part that is after it.  */\n<line43>xwrite_stdout (nl + 1, bytes_read - (n + 1));\n<line44>*read_pos += dump_remainder (false, pretty_filename, fd,\n<line45>end_pos - (pos + bytes_read));\n<line46>return true;\n<line47>}\n<line48>}\n<line49>/* Not enough newlines in that bufferfull.  */\n<line50>if (pos == start_pos)\n<line51>{\n<line52>/* Not enough lines in the file; print everything from\n<line53>start_pos to the end.  */\n<line54>xlseek (fd, start_pos, SEEK_SET, pretty_filename);\n<line55>*read_pos = start_pos + dump_remainder (false, pretty_filename, fd,\n<line56>end_pos);\n<line57>return true;\n<line58>}\n<line59>pos -= BUFSIZ;\n<line60>xlseek (fd, pos, SEEK_SET, pretty_filename);\n<line61>bytes_read = safe_read (fd, buffer, BUFSIZ);\n<line62>if (bytes_read == SAFE_READ_ERROR)\n<line63>{\n<line64>error (0, errno, _("error reading %s"), quoteaf (pretty_filename));\n<line65>return false;\n<line66>}\n<line67>*read_pos = pos + bytes_read;\n<line68>}\n<line69>while (bytes_read > 0);\n<line70>return true;\n<line71>}
----------------------------------------
Function: pipe_lines
Content: <line0>static bool\n<line1>pipe_lines (char const *pretty_filename, int fd, uintmax_t n_lines,\n<line2>uintmax_t *read_pos)\n<line3>{\n<line4>struct linebuffer\n<line5>{\n<line6>char buffer[BUFSIZ];\n<line7>size_t nbytes;\n<line8>size_t nlines;\n<line9>struct linebuffer *next;\n<line10>};\n<line11>typedef struct linebuffer LBUFFER;\n<line12>LBUFFER *first, *last, *tmp;\n<line13>size_t total_lines = 0;	/* Total number of newlines in all buffers.  */\n<line14>bool ok = true;\n<line15>size_t n_read;		/* Size in bytes of most recent read */\n<line16>first = last = xmalloc (sizeof (LBUFFER));\n<line17>first->nbytes = first->nlines = 0;\n<line18>first->next = nullptr;\n<line19>tmp = xmalloc (sizeof (LBUFFER));\n<line20>/* Input is always read into a fresh buffer.  */\n<line21>while (true)\n<line22>{\n<line23>n_read = safe_read (fd, tmp->buffer, BUFSIZ);\n<line24>if (n_read == 0 || n_read == SAFE_READ_ERROR)\n<line25>break;\n<line26>tmp->nbytes = n_read;\n<line27>*read_pos += n_read;\n<line28>tmp->nlines = 0;\n<line29>tmp->next = nullptr;\n<line30>/* Count the number of newlines just read.  */\n<line31>{\n<line32>char const *buffer_end = tmp->buffer + n_read;\n<line33>char const *p = tmp->buffer;\n<line34>while ((p = memchr (p, line_end, buffer_end - p)))\n<line35>{\n<line36>++p;\n<line37>++tmp->nlines;\n<line38>}\n<line39>}\n<line40>total_lines += tmp->nlines;\n<line41>/* If there is enough room in the last buffer read, just append the new\n<line42>one to it.  This is because when reading from a pipe, 'n_read' can\n<line43>often be very small.  */\n<line44>if (tmp->nbytes + last->nbytes < BUFSIZ)\n<line45>{\n<line46>memcpy (&last->buffer[last->nbytes], tmp->buffer, tmp->nbytes);\n<line47>last->nbytes += tmp->nbytes;\n<line48>last->nlines += tmp->nlines;\n<line49>}\n<line50>else\n<line51>{\n<line52>/* If there's not enough room, link the new buffer onto the end of\n<line53>the list, then either free up the oldest buffer for the next\n<line54>read if that would leave enough lines, or else malloc a new one.\n<line55>Some compaction mechanism is possible but probably not\n<line56>worthwhile.  */\n<line57>last = last->next = tmp;\n<line58>if (total_lines - first->nlines > n_lines)\n<line59>{\n<line60>tmp = first;\n<line61>total_lines -= first->nlines;\n<line62>first = first->next;\n<line63>}\n<line64>else\n<line65>tmp = xmalloc (sizeof (LBUFFER));\n<line66>}\n<line67>}\n<line68>free (tmp);\n<line69>if (n_read == SAFE_READ_ERROR)\n<line70>{\n<line71>error (0, errno, _("error reading %s"), quoteaf (pretty_filename));\n<line72>ok = false;\n<line73>goto free_lbuffers;\n<line74>}\n<line75>/* If the file is empty, then bail out.  */\n<line76>if (last->nbytes == 0)\n<line77>goto free_lbuffers;\n<line78>/* This prevents a core dump when the pipe contains no newlines.  */\n<line79>if (n_lines == 0)\n<line80>goto free_lbuffers;\n<line81>/* Count the incomplete line on files that don't end with a newline.  */\n<line82>if (last->buffer[last->nbytes - 1] != line_end)\n<line83>{\n<line84>++last->nlines;\n<line85>++total_lines;\n<line86>}\n<line87>/* Run through the list, printing lines.  First, skip over unneeded\n<line88>buffers.  */\n<line89>for (tmp = first; total_lines - tmp->nlines > n_lines; tmp = tmp->next)\n<line90>total_lines -= tmp->nlines;\n<line91>/* Find the correct beginning, then print the rest of the file.  */\n<line92>{\n<line93>char const *beg = tmp->buffer;\n<line94>char const *buffer_end = tmp->buffer + tmp->nbytes;\n<line95>if (total_lines > n_lines)\n<line96>{\n<line97>/* Skip 'total_lines' - 'n_lines' newlines.  We made sure that\n<line98>'total_lines' - 'n_lines' <= 'tmp->nlines'.  */\n<line99>size_t j;\n<line100>for (j = total_lines - n_lines; j; --j)\n<line101>{\n<line102>beg = rawmemchr (beg, line_end);\n<line103>++beg;\n<line104>}\n<line105>}\n<line106>xwrite_stdout (beg, buffer_end - beg);\n<line107>}\n<line108>for (tmp = tmp->next; tmp; tmp = tmp->next)\n<line109>xwrite_stdout (tmp->buffer, tmp->nbytes);\n<line110>free_lbuffers:\n<line111>while (first)\n<line112>{\n<line113>tmp = first->next;\n<line114>free (first);\n<line115>first = tmp;\n<line116>}\n<line117>return ok;\n<line118>}
----------------------------------------
Function: pipe_bytes
Content: <line0>static bool\n<line1>pipe_bytes (char const *pretty_filename, int fd, uintmax_t n_bytes,\n<line2>uintmax_t *read_pos)\n<line3>{\n<line4>struct charbuffer\n<line5>{\n<line6>char buffer[BUFSIZ];\n<line7>size_t nbytes;\n<line8>struct charbuffer *next;\n<line9>};\n<line10>typedef struct charbuffer CBUFFER;\n<line11>CBUFFER *first, *last, *tmp;\n<line12>size_t i;			/* Index into buffers.  */\n<line13>size_t total_bytes = 0;	/* Total characters in all buffers.  */\n<line14>bool ok = true;\n<line15>size_t n_read;\n<line16>first = last = xmalloc (sizeof (CBUFFER));\n<line17>first->nbytes = 0;\n<line18>first->next = nullptr;\n<line19>tmp = xmalloc (sizeof (CBUFFER));\n<line20>/* Input is always read into a fresh buffer.  */\n<line21>while (true)\n<line22>{\n<line23>n_read = safe_read (fd, tmp->buffer, BUFSIZ);\n<line24>if (n_read == 0 || n_read == SAFE_READ_ERROR)\n<line25>break;\n<line26>*read_pos += n_read;\n<line27>tmp->nbytes = n_read;\n<line28>tmp->next = nullptr;\n<line29>total_bytes += tmp->nbytes;\n<line30>/* If there is enough room in the last buffer read, just append the new\n<line31>one to it.  This is because when reading from a pipe, 'nbytes' can\n<line32>often be very small.  */\n<line33>if (tmp->nbytes + last->nbytes < BUFSIZ)\n<line34>{\n<line35>memcpy (&last->buffer[last->nbytes], tmp->buffer, tmp->nbytes);\n<line36>last->nbytes += tmp->nbytes;\n<line37>}\n<line38>else\n<line39>{\n<line40>/* If there's not enough room, link the new buffer onto the end of\n<line41>the list, then either free up the oldest buffer for the next\n<line42>read if that would leave enough characters, or else malloc a new\n<line43>one.  Some compaction mechanism is possible but probably not\n<line44>worthwhile.  */\n<line45>last = last->next = tmp;\n<line46>if (total_bytes - first->nbytes > n_bytes)\n<line47>{\n<line48>tmp = first;\n<line49>total_bytes -= first->nbytes;\n<line50>first = first->next;\n<line51>}\n<line52>else\n<line53>{\n<line54>tmp = xmalloc (sizeof (CBUFFER));\n<line55>}\n<line56>}\n<line57>}\n<line58>free (tmp);\n<line59>if (n_read == SAFE_READ_ERROR)\n<line60>{\n<line61>error (0, errno, _("error reading %s"), quoteaf (pretty_filename));\n<line62>ok = false;\n<line63>goto free_cbuffers;\n<line64>}\n<line65>/* Run through the list, printing characters.  First, skip over unneeded\n<line66>buffers.  */\n<line67>for (tmp = first; total_bytes - tmp->nbytes > n_bytes; tmp = tmp->next)\n<line68>total_bytes -= tmp->nbytes;\n<line69>/* Find the correct beginning, then print the rest of the file.\n<line70>We made sure that 'total_bytes' - 'n_bytes' <= 'tmp->nbytes'.  */\n<line71>if (total_bytes > n_bytes)\n<line72>i = total_bytes - n_bytes;\n<line73>else\n<line74>i = 0;\n<line75>xwrite_stdout (&tmp->buffer[i], tmp->nbytes - i);\n<line76>for (tmp = tmp->next; tmp; tmp = tmp->next)\n<line77>xwrite_stdout (tmp->buffer, tmp->nbytes);\n<line78>free_cbuffers:\n<line79>while (first)\n<line80>{\n<line81>tmp = first->next;\n<line82>free (first);\n<line83>first = tmp;\n<line84>}\n<line85>return ok;\n<line86>}
----------------------------------------
Function: start_bytes
Content: <line0>static int\n<line1>start_bytes (char const *pretty_filename, int fd, uintmax_t n_bytes,\n<line2>uintmax_t *read_pos)\n<line3>{\n<line4>char buffer[BUFSIZ];\n<line5>while (0 < n_bytes)\n<line6>{\n<line7>size_t bytes_read = safe_read (fd, buffer, BUFSIZ);\n<line8>if (bytes_read == 0)\n<line9>return -1;\n<line10>if (bytes_read == SAFE_READ_ERROR)\n<line11>{\n<line12>error (0, errno, _("error reading %s"), quoteaf (pretty_filename));\n<line13>return 1;\n<line14>}\n<line15>*read_pos += bytes_read;\n<line16>if (bytes_read <= n_bytes)\n<line17>n_bytes -= bytes_read;\n<line18>else\n<line19>{\n<line20>size_t n_remaining = bytes_read - n_bytes;\n<line21>/* Print extra characters if there are any.  */\n<line22>xwrite_stdout (&buffer[n_bytes], n_remaining);\n<line23>break;\n<line24>}\n<line25>}\n<line26>return 0;\n<line27>}
----------------------------------------
Function: start_lines
Content: <line0>static int\n<line1>start_lines (char const *pretty_filename, int fd, uintmax_t n_lines,\n<line2>uintmax_t *read_pos)\n<line3>{\n<line4>if (n_lines == 0)\n<line5>return 0;\n<line6>while (true)\n<line7>{\n<line8>char buffer[BUFSIZ];\n<line9>size_t bytes_read = safe_read (fd, buffer, BUFSIZ);\n<line10>if (bytes_read == 0) /* EOF */\n<line11>return -1;\n<line12>if (bytes_read == SAFE_READ_ERROR) /* error */\n<line13>{\n<line14>error (0, errno, _("error reading %s"), quoteaf (pretty_filename));\n<line15>return 1;\n<line16>}\n<line17>char *buffer_end = buffer + bytes_read;\n<line18>*read_pos += bytes_read;\n<line19>char *p = buffer;\n<line20>while ((p = memchr (p, line_end, buffer_end - p)))\n<line21>{\n<line22>++p;\n<line23>if (--n_lines == 0)\n<line24>{\n<line25>if (p < buffer_end)\n<line26>xwrite_stdout (p, buffer_end - p);\n<line27>return 0;\n<line28>}\n<line29>}\n<line30>}\n<line31>}
----------------------------------------
Function: fremote
Content: <line0>static bool\n<line1>fremote (int fd, char const *name)\n<line2>{\n<line3>bool remote = true;           /* be conservative (poll by default).  */\n<line4>#if HAVE_FSTATFS && HAVE_STRUCT_STATFS_F_TYPE \\n<line5>&& (defined __linux__ || defined __ANDROID__)\n<line6>struct statfs buf;\n<line7>int err = fstatfs (fd, &buf);\n<line8>if (err != 0)\n<line9>{\n<line10>/* On at least linux-2.6.38, fstatfs fails with ENOSYS when FD\n<line11>is open on a pipe.  Treat that like a remote file.  */\n<line12>if (errno != ENOSYS)\n<line13>error (0, errno, _("cannot determine location of %s. "\n<line14>"reverting to polling"), quoteaf (name));\n<line15>}\n<line16>else\n<line17>{\n<line18>/* Treat unrecognized file systems as "remote", so caller polls.\n<line19>Note README-release has instructions for syncing the internal\n<line20>list with the latest Linux kernel file system constants.  */\n<line21>remote = is_local_fs_type (buf.f_type) <= 0;\n<line22>}\n<line23>#endif\n<line24>return remote;\n<line25>}
----------------------------------------
Function: recheck
Content: <line0>static void\n<line1>recheck (struct File_spec *f, bool blocking)\n<line2>{\n<line3>struct stat new_stats;\n<line4>bool ok = true;\n<line5>bool is_stdin = (STREQ (f->name, "-"));\n<line6>bool was_tailable = f->tailable;\n<line7>int prev_errnum = f->errnum;\n<line8>bool new_file;\n<line9>int fd = (is_stdin\n<line10>? STDIN_FILENO\n<line11>: open (f->name, O_RDONLY | (blocking ? 0 : O_NONBLOCK)));\n<line12>affirm (valid_file_spec (f));\n<line13>/* If the open fails because the file doesn't exist,\n<line14>then mark the file as not tailable.  */\n<line15>f->tailable = !(reopen_inaccessible_files && fd == -1);\n<line16>if (! disable_inotify && ! lstat (f->name, &new_stats)\n<line17>&& S_ISLNK (new_stats.st_mode))\n<line18>{\n<line19>/* Diagnose the edge case where a regular file is changed\n<line20>to a symlink.  We avoid inotify with symlinks since\n<line21>it's awkward to match between symlink name and target.  */\n<line22>ok = false;\n<line23>f->errnum = -1;\n<line24>f->ignore = true;\n<line25>error (0, 0, _("%s has been replaced with an untailable symbolic link"),\n<line26>quoteaf (pretty_name (f)));\n<line27>}\n<line28>else if (fd == -1 || fstat (fd, &new_stats) < 0)\n<line29>{\n<line30>ok = false;\n<line31>f->errnum = errno;\n<line32>if (!f->tailable)\n<line33>{\n<line34>if (was_tailable)\n<line35>{\n<line36>/* FIXME-maybe: detect the case in which the file first becomes\n<line37>unreadable (perms), and later becomes readable again and can\n<line38>be seen to be the same file (dev/ino).  Otherwise, tail prints\n<line39>the entire contents of the file when it becomes readable.  */\n<line40>error (0, f->errnum, _("%s has become inaccessible"),\n<line41>quoteaf (pretty_name (f)));\n<line42>}\n<line43>else\n<line44>{\n<line45>/* say nothing... it's still not tailable */\n<line46>}\n<line47>}\n<line48>else if (prev_errnum != errno)\n<line49>error (0, errno, "%s", quotef (pretty_name (f)));\n<line50>}\n<line51>else if (!IS_TAILABLE_FILE_TYPE (new_stats.st_mode))\n<line52>{\n<line53>ok = false;\n<line54>f->errnum = -1;\n<line55>f->tailable = false;\n<line56>f->ignore = ! (reopen_inaccessible_files && follow_mode == Follow_name);\n<line57>if (was_tailable || prev_errnum != f->errnum)\n<line58>error (0, 0, _("%s has been replaced with an untailable file%s"),\n<line59>quoteaf (pretty_name (f)),\n<line60>f->ignore ? _("; giving up on this name") : "");\n<line61>}\n<line62>else if ((f->remote = fremote (fd, pretty_name (f))) && ! disable_inotify)\n<line63>{\n<line64>ok = false;\n<line65>f->errnum = -1;\n<line66>error (0, 0, _("%s has been replaced with an untailable remote file"),\n<line67>quoteaf (pretty_name (f)));\n<line68>f->ignore = true;\n<line69>f->remote = true;\n<line70>}\n<line71>else\n<line72>{\n<line73>f->errnum = 0;\n<line74>}\n<line75>new_file = false;\n<line76>if (!ok)\n<line77>{\n<line78>close_fd (fd, pretty_name (f));\n<line79>close_fd (f->fd, pretty_name (f));\n<line80>f->fd = -1;\n<line81>}\n<line82>else if (prev_errnum && prev_errnum != ENOENT)\n<line83>{\n<line84>new_file = true;\n<line85>affirm (f->fd == -1);\n<line86>error (0, 0, _("%s has become accessible"), quoteaf (pretty_name (f)));\n<line87>}\n<line88>else if (f->fd == -1)\n<line89>{\n<line90>/* A new file even when inodes haven't changed as <dev,inode>\n<line91>pairs can be reused, and we know the file was missing\n<line92>on the previous iteration.  Note this also means the file\n<line93>is redisplayed in --follow=name mode if renamed away from\n<line94>and back to a monitored name.  */\n<line95>new_file = true;\n<line96>error (0, 0,\n<line97>_("%s has appeared;  following new file"),\n<line98>quoteaf (pretty_name (f)));\n<line99>}\n<line100>else if (f->ino != new_stats.st_ino || f->dev != new_stats.st_dev)\n<line101>{\n<line102>/* File has been replaced (e.g., via log rotation) --\n<line103>tail the new one.  */\n<line104>new_file = true;\n<line105>error (0, 0,\n<line106>_("%s has been replaced;  following new file"),\n<line107>quoteaf (pretty_name (f)));\n<line108>/* Close the old one.  */\n<line109>close_fd (f->fd, pretty_name (f));\n<line110>}\n<line111>else\n<line112>{\n<line113>/* No changes detected, so close new fd.  */\n<line114>close_fd (fd, pretty_name (f));\n<line115>}\n<line116>/* FIXME: When a log is rotated, daemons tend to log to the\n<line117>old file descriptor until the new file is present and\n<line118>the daemon is sent a signal.  Therefore tail may miss entries\n<line119>being written to the old file.  Perhaps we should keep\n<line120>the older file open and continue to monitor it until\n<line121>data is written to a new file.  */\n<line122>if (new_file)\n<line123>{\n<line124>/* Start at the beginning of the file.  */\n<line125>record_open_fd (f, fd, 0, &new_stats, (is_stdin ? -1 : blocking));\n<line126>if (S_ISREG (new_stats.st_mode))\n<line127>xlseek (fd, 0, SEEK_SET, pretty_name (f));\n<line128>}\n<line129>}
----------------------------------------
Function: any_live_files
Content: <line0>static bool\n<line1>any_live_files (const struct File_spec *f, size_t n_files)\n<line2>{\n<line3>/* In inotify mode, ignore may be set for files\n<line4>which may later be replaced with new files.\n<line5>So always consider files live in -F mode.  */\n<line6>if (reopen_inaccessible_files && follow_mode == Follow_name)\n<line7>return true;\n<line8>for (size_t i = 0; i < n_files; i++)\n<line9>{\n<line10>if (0 <= f[i].fd)\n<line11>return true;\n<line12>else\n<line13>{\n<line14>if (! f[i].ignore && reopen_inaccessible_files)\n<line15>return true;\n<line16>}\n<line17>}\n<line18>return false;\n<line19>}
----------------------------------------
Function: tail_forever
Content: <line0>static void\n<line1>tail_forever (struct File_spec *f, size_t n_files, double sleep_interval)\n<line2>{\n<line3>/* Use blocking I/O as an optimization, when it's easy.  */\n<line4>bool blocking = (pid == 0 && follow_mode == Follow_descriptor\n<line5>&& n_files == 1 && f[0].fd != -1 && ! S_ISREG (f[0].mode));\n<line6>size_t last;\n<line7>bool writer_is_dead = false;\n<line8>last = n_files - 1;\n<line9>while (true)\n<line10>{\n<line11>size_t i;\n<line12>bool any_input = false;\n<line13>for (i = 0; i < n_files; i++)\n<line14>{\n<line15>int fd;\n<line16>char const *name;\n<line17>mode_t mode;\n<line18>struct stat stats;\n<line19>uintmax_t bytes_read;\n<line20>if (f[i].ignore)\n<line21>continue;\n<line22>if (f[i].fd < 0)\n<line23>{\n<line24>recheck (&f[i], blocking);\n<line25>continue;\n<line26>}\n<line27>fd = f[i].fd;\n<line28>name = pretty_name (&f[i]);\n<line29>mode = f[i].mode;\n<line30>if (f[i].blocking != blocking)\n<line31>{\n<line32>int old_flags = fcntl (fd, F_GETFL);\n<line33>int new_flags = old_flags | (blocking ? 0 : O_NONBLOCK);\n<line34>if (old_flags < 0\n<line35>|| (new_flags != old_flags\n<line36>&& fcntl (fd, F_SETFL, new_flags) == -1))\n<line37>{\n<line38>/* Don't update f[i].blocking if fcntl fails.  */\n<line39>if (S_ISREG (f[i].mode) && errno == EPERM)\n<line40>{\n<line41>/* This happens when using tail -f on a file with\n<line42>the append-only attribute.  */\n<line43>}\n<line44>else\n<line45>error (EXIT_FAILURE, errno,\n<line46>_("%s: cannot change nonblocking mode"),\n<line47>quotef (name));\n<line48>}\n<line49>else\n<line50>f[i].blocking = blocking;\n<line51>}\n<line52>bool read_unchanged = false;\n<line53>if (!f[i].blocking)\n<line54>{\n<line55>if (fstat (fd, &stats) != 0)\n<line56>{\n<line57>f[i].fd = -1;\n<line58>f[i].errnum = errno;\n<line59>error (0, errno, "%s", quotef (name));\n<line60>close (fd); /* ignore failure */\n<line61>continue;\n<line62>}\n<line63>if (f[i].mode == stats.st_mode\n<line64>&& (! S_ISREG (stats.st_mode) || f[i].size == stats.st_size)\n<line65>&& timespec_cmp (f[i].mtime, get_stat_mtime (&stats)) == 0)\n<line66>{\n<line67>if ((max_n_unchanged_stats_between_opens\n<line68><= f[i].n_unchanged_stats++)\n<line69>&& follow_mode == Follow_name)\n<line70>{\n<line71>recheck (&f[i], f[i].blocking);\n<line72>f[i].n_unchanged_stats = 0;\n<line73>}\n<line74>if (fd != f[i].fd || S_ISREG (stats.st_mode) || 1 < n_files)\n<line75>continue;\n<line76>else\n<line77>read_unchanged = true;\n<line78>}\n<line79>affirm (fd == f[i].fd);\n<line80>/* This file has changed.  Print out what we can, and\n<line81>then keep looping.  */\n<line82>f[i].mtime = get_stat_mtime (&stats);\n<line83>f[i].mode = stats.st_mode;\n<line84>/* reset counter */\n<line85>if (! read_unchanged)\n<line86>f[i].n_unchanged_stats = 0;\n<line87>/* XXX: This is only a heuristic, as the file may have also\n<line88>been truncated and written to if st_size >= size\n<line89>(in which case we ignore new data <= size).  */\n<line90>if (S_ISREG (mode) && stats.st_size < f[i].size)\n<line91>{\n<line92>error (0, 0, _("%s: file truncated"), quotef (name));\n<line93>/* Assume the file was truncated to 0,\n<line94>and therefore output all "new" data.  */\n<line95>xlseek (fd, 0, SEEK_SET, name);\n<line96>f[i].size = 0;\n<line97>}\n<line98>if (i != last)\n<line99>{\n<line100>if (print_headers)\n<line101>write_header (name);\n<line102>last = i;\n<line103>}\n<line104>}\n<line105>/* Don't read more than st_size on networked file systems\n<line106>because it was seen on glusterfs at least, that st_size\n<line107>may be smaller than the data read on a _subsequent_ stat call.  */\n<line108>uintmax_t bytes_to_read;\n<line109>if (f[i].blocking)\n<line110>bytes_to_read = COPY_A_BUFFER;\n<line111>else if (S_ISREG (mode) && f[i].remote)\n<line112>bytes_to_read = stats.st_size - f[i].size;\n<line113>else\n<line114>bytes_to_read = COPY_TO_EOF;\n<line115>bytes_read = dump_remainder (false, name, fd, bytes_to_read);\n<line116>if (read_unchanged && bytes_read)\n<line117>f[i].n_unchanged_stats = 0;\n<line118>any_input |= (bytes_read != 0);\n<line119>f[i].size += bytes_read;\n<line120>}\n<line121>if (! any_live_files (f, n_files))\n<line122>{\n<line123>error (0, 0, _("no files remaining"));\n<line124>break;\n<line125>}\n<line126>if ((!any_input || blocking) && fflush (stdout) != 0)\n<line127>write_error ();\n<line128>check_output_alive ();\n<line129>/* If nothing was read, sleep and/or check for dead writers.  */\n<line130>if (!any_input)\n<line131>{\n<line132>if (writer_is_dead)\n<line133>break;\n<line134>/* Once the writer is dead, read the files once more to\n<line135>avoid a race condition.  */\n<line136>writer_is_dead = (pid != 0\n<line137>&& kill (pid, 0) != 0\n<line138>/* Handle the case in which you cannot send a\n<line139>signal to the writer, so kill fails and sets\n<line140>errno to EPERM.  */\n<line141>&& errno != EPERM);\n<line142>if (!writer_is_dead && xnanosleep (sleep_interval))\n<line143>error (EXIT_FAILURE, errno, _("cannot read realtime clock"));\n<line144>}\n<line145>}\n<line146>}
----------------------------------------
Function: any_remote_file
Content: <line0>static bool\n<line1>any_remote_file (const struct File_spec *f, size_t n_files)\n<line2>{\n<line3>for (size_t i = 0; i < n_files; i++)\n<line4>if (0 <= f[i].fd && f[i].remote)\n<line5>return true;\n<line6>return false;\n<line7>}
----------------------------------------
Function: any_non_remote_file
Content: <line0>static bool\n<line1>any_non_remote_file (const struct File_spec *f, size_t n_files)\n<line2>{\n<line3>for (size_t i = 0; i < n_files; i++)\n<line4>if (0 <= f[i].fd && ! f[i].remote)\n<line5>return true;\n<line6>return false;\n<line7>}
----------------------------------------
Function: any_symlinks
Content: <line0>static bool\n<line1>any_symlinks (const struct File_spec *f, size_t n_files)\n<line2>{\n<line3>struct stat st;\n<line4>for (size_t i = 0; i < n_files; i++)\n<line5>if (lstat (f[i].name, &st) == 0 && S_ISLNK (st.st_mode))\n<line6>return true;\n<line7>return false;\n<line8>}
----------------------------------------
Function: any_non_regular_fifo
Content: <line0>static bool\n<line1>any_non_regular_fifo (const struct File_spec *f, size_t n_files)\n<line2>{\n<line3>for (size_t i = 0; i < n_files; i++)\n<line4>if (0 <= f[i].fd && ! S_ISREG (f[i].mode) && ! S_ISFIFO (f[i].mode))\n<line5>return true;\n<line6>return false;\n<line7>}
----------------------------------------
Function: tailable_stdin
Content: <line0>static bool\n<line1>tailable_stdin (const struct File_spec *f, size_t n_files)\n<line2>{\n<line3>for (size_t i = 0; i < n_files; i++)\n<line4>if (!f[i].ignore && STREQ (f[i].name, "-"))\n<line5>return true;\n<line6>return false;\n<line7>}
----------------------------------------
Function: wd_hasher
Content: <line0>static size_t\n<line1>wd_hasher (const void *entry, size_t tabsize)\n<line2>{\n<line3>const struct File_spec *spec = entry;\n<line4>return spec->wd % tabsize;\n<line5>}
----------------------------------------
Function: wd_comparator
Content: <line0>static bool\n<line1>wd_comparator (const void *e1, const void *e2)\n<line2>{\n<line3>const struct File_spec *spec1 = e1;\n<line4>const struct File_spec *spec2 = e2;\n<line5>return spec1->wd == spec2->wd;\n<line6>}
----------------------------------------
Function: check_fspec
Content: <line0>static void\n<line1>check_fspec (struct File_spec *fspec, struct File_spec **prev_fspec)\n<line2>{\n<line3>struct stat stats;\n<line4>char const *name;\n<line5>if (fspec->fd == -1)\n<line6>return;\n<line7>name = pretty_name (fspec);\n<line8>if (fstat (fspec->fd, &stats) != 0)\n<line9>{\n<line10>fspec->errnum = errno;\n<line11>close_fd (fspec->fd, name);\n<line12>fspec->fd = -1;\n<line13>return;\n<line14>}\n<line15>/* XXX: This is only a heuristic, as the file may have also\n<line16>been truncated and written to if st_size >= size\n<line17>(in which case we ignore new data <= size).\n<line18>Though in the inotify case it's more likely we'll get\n<line19>separate events for truncate() and write().  */\n<line20>if (S_ISREG (fspec->mode) && stats.st_size < fspec->size)\n<line21>{\n<line22>error (0, 0, _("%s: file truncated"), quotef (name));\n<line23>xlseek (fspec->fd, 0, SEEK_SET, name);\n<line24>fspec->size = 0;\n<line25>}\n<line26>else if (S_ISREG (fspec->mode) && stats.st_size == fspec->size\n<line27>&& timespec_cmp (fspec->mtime, get_stat_mtime (&stats)) == 0)\n<line28>return;\n<line29>bool want_header = print_headers && (fspec != *prev_fspec);\n<line30>uintmax_t bytes_read = dump_remainder (want_header, name, fspec->fd,\n<line31>COPY_TO_EOF);\n<line32>fspec->size += bytes_read;\n<line33>if (bytes_read)\n<line34>{\n<line35>*prev_fspec = fspec;\n<line36>if (fflush (stdout) != 0)\n<line37>write_error ();\n<line38>}\n<line39>}
----------------------------------------
Function: tail_forever_inotify
Content: <line0>static void\n<line1>tail_forever_inotify (int wd, struct File_spec *f, size_t n_files,\n<line2>double sleep_interval, Hash_table **wd_to_namep)\n<line3>{\n<line4># if TAIL_TEST_SLEEP\n<line5>/* Delay between open() and inotify_add_watch()\n<line6>to help trigger different cases.  */\n<line7>xnanosleep (1000000);\n<line8># endif\n<line9>unsigned int max_realloc = 3;\n<line10>/* Map an inotify watch descriptor to the name of the file it's watching.  */\n<line11>Hash_table *wd_to_name;\n<line12>bool found_watchable_file = false;\n<line13>bool tailed_but_unwatchable = false;\n<line14>bool found_unwatchable_dir = false;\n<line15>bool no_inotify_resources = false;\n<line16>bool writer_is_dead = false;\n<line17>struct File_spec *prev_fspec;\n<line18>size_t evlen = 0;\n<line19>char *evbuf;\n<line20>size_t evbuf_off = 0;\n<line21>size_t len = 0;\n<line22>wd_to_name = hash_initialize (n_files, nullptr, wd_hasher, wd_comparator,\n<line23>nullptr);\n<line24>if (! wd_to_name)\n<line25>xalloc_die ();\n<line26>*wd_to_namep = wd_to_name;\n<line27>/* The events mask used with inotify on files (not directories).  */\n<line28>uint32_t inotify_wd_mask = IN_MODIFY;\n<line29>/* TODO: Perhaps monitor these events in Follow_descriptor mode also,\n<line30>to tag reported file names with "deleted", "moved" etc.  */\n<line31>if (follow_mode == Follow_name)\n<line32>inotify_wd_mask |= (IN_ATTRIB | IN_DELETE_SELF | IN_MOVE_SELF);\n<line33>/* Add an inotify watch for each watched file.  If -F is specified then watch\n<line34>its parent directory too, in this way when they re-appear we can add them\n<line35>again to the watch list.  */\n<line36>size_t i;\n<line37>for (i = 0; i < n_files; i++)\n<line38>{\n<line39>if (!f[i].ignore)\n<line40>{\n<line41>size_t fnlen = strlen (f[i].name);\n<line42>if (evlen < fnlen)\n<line43>evlen = fnlen;\n<line44>f[i].wd = -1;\n<line45>if (follow_mode == Follow_name)\n<line46>{\n<line47>size_t dirlen = dir_len (f[i].name);\n<line48>char prev = f[i].name[dirlen];\n<line49>f[i].basename_start = last_component (f[i].name) - f[i].name;\n<line50>f[i].name[dirlen] = '\0';\n<line51>/* It's fine to add the same directory more than once.\n<line52>In that case the same watch descriptor is returned.  */\n<line53>f[i].parent_wd = inotify_add_watch (wd, dirlen ? f[i].name : ".",\n<line54>(IN_CREATE | IN_DELETE\n<line55>| IN_MOVED_TO | IN_ATTRIB\n<line56>| IN_DELETE_SELF));\n<line57>f[i].name[dirlen] = prev;\n<line58>if (f[i].parent_wd < 0)\n<line59>{\n<line60>if (errno != ENOSPC) /* suppress confusing error.  */\n<line61>error (0, errno, _("cannot watch parent directory of %s"),\n<line62>quoteaf (f[i].name));\n<line63>else\n<line64>error (0, 0, _("inotify resources exhausted"));\n<line65>found_unwatchable_dir = true;\n<line66>/* We revert to polling below.  Note invalid uses\n<line67>of the inotify API will still be diagnosed.  */\n<line68>break;\n<line69>}\n<line70>}\n<line71>f[i].wd = inotify_add_watch (wd, f[i].name, inotify_wd_mask);\n<line72>if (f[i].wd < 0)\n<line73>{\n<line74>if (f[i].fd != -1)  /* already tailed.  */\n<line75>tailed_but_unwatchable = true;\n<line76>if (errno == ENOSPC || errno == ENOMEM)\n<line77>{\n<line78>no_inotify_resources = true;\n<line79>error (0, 0, _("inotify resources exhausted"));\n<line80>break;\n<line81>}\n<line82>else if (errno != f[i].errnum)\n<line83>error (0, errno, _("cannot watch %s"), quoteaf (f[i].name));\n<line84>continue;\n<line85>}\n<line86>if (hash_insert (wd_to_name, &(f[i])) == nullptr)\n<line87>xalloc_die ();\n<line88>found_watchable_file = true;\n<line89>}\n<line90>}\n<line91>/* Linux kernel 2.6.24 at least has a bug where eventually, ENOSPC is always\n<line92>returned by inotify_add_watch.  In any case we should revert to polling\n<line93>when there are no inotify resources.  Also a specified directory may not\n<line94>be currently present or accessible, so revert to polling.  Also an already\n<line95>tailed but unwatchable due rename/unlink race, should also revert.  */\n<line96>if (no_inotify_resources || found_unwatchable_dir\n<line97>|| (follow_mode == Follow_descriptor && tailed_but_unwatchable))\n<line98>return;\n<line99>if (follow_mode == Follow_descriptor && !found_watchable_file)\n<line100>exit (EXIT_FAILURE);\n<line101>prev_fspec = &(f[n_files - 1]);\n<line102>/* Check files again.  New files or data can be available since last time we\n<line103>checked and before they are watched by inotify.  */\n<line104>for (i = 0; i < n_files; i++)\n<line105>{\n<line106>if (! f[i].ignore)\n<line107>{\n<line108>/* check for new files.  */\n<line109>if (follow_mode == Follow_name)\n<line110>recheck (&(f[i]), false);\n<line111>else if (f[i].fd != -1)\n<line112>{\n<line113>/* If the file was replaced in the small window since we tailed,\n<line114>then assume the watch is on the wrong item (different to\n<line115>that we've already produced output for), and so revert to\n<line116>polling the original descriptor.  */\n<line117>struct stat stats;\n<line118>if (stat (f[i].name, &stats) == 0\n<line119>&& (f[i].dev != stats.st_dev || f[i].ino != stats.st_ino))\n<line120>{\n<line121>error (0, errno, _("%s was replaced"),\n<line122>quoteaf (pretty_name (&(f[i]))));\n<line123>return;\n<line124>}\n<line125>}\n<line126>/* check for new data.  */\n<line127>check_fspec (&f[i], &prev_fspec);\n<line128>}\n<line129>}\n<line130>evlen += sizeof (struct inotify_event) + 1;\n<line131>evbuf = xmalloc (evlen);\n<line132>/* Wait for inotify events and handle them.  Events on directories\n<line133>ensure that watched files can be re-added when following by name.\n<line134>This loop blocks on the 'safe_read' call until a new event is notified.\n<line135>But when --pid=P is specified, tail usually waits via poll.  */\n<line136>while (true)\n<line137>{\n<line138>struct File_spec *fspec;\n<line139>struct inotify_event *ev;\n<line140>void *void_ev;\n<line141>/* When following by name without --retry, and the last file has\n<line142>been unlinked or renamed-away, diagnose it and return.  */\n<line143>if (follow_mode == Follow_name\n<line144>&& ! reopen_inaccessible_files\n<line145>&& hash_get_n_entries (wd_to_name) == 0)\n<line146>error (EXIT_FAILURE, 0, _("no files remaining"));\n<line147>if (len <= evbuf_off)\n<line148>{\n<line149>/* Poll for inotify events.  When watching a PID, ensure\n<line150>that a read from WD will not block indefinitely.\n<line151>If MONITOR_OUTPUT, also poll for a broken output pipe.  */\n<line152>int file_change;\n<line153>struct pollfd pfd[2];\n<line154>do\n<line155>{\n<line156>/* How many ms to wait for changes.  -1 means wait forever.  */\n<line157>int delay = -1;\n<line158>if (pid)\n<line159>{\n<line160>if (writer_is_dead)\n<line161>exit (EXIT_SUCCESS);\n<line162>writer_is_dead = (kill (pid, 0) != 0 && errno != EPERM);\n<line163>if (writer_is_dead || sleep_interval <= 0)\n<line164>delay = 0;\n<line165>else if (sleep_interval < INT_MAX / 1000 - 1)\n<line166>{\n<line167>/* delay = ceil (sleep_interval * 1000), sans libm.  */\n<line168>double ddelay = sleep_interval * 1000;\n<line169>delay = ddelay;\n<line170>delay += delay < ddelay;\n<line171>}\n<line172>}\n<line173>pfd[0].fd = wd;\n<line174>pfd[0].events = POLLIN;\n<line175>pfd[1].fd = STDOUT_FILENO;\n<line176>pfd[1].events = pfd[1].revents = 0;\n<line177>file_change = poll (pfd, monitor_output + 1, delay);\n<line178>}\n<line179>while (file_change == 0);\n<line180>if (file_change < 0)\n<line181>error (EXIT_FAILURE, errno,\n<line182>_("error waiting for inotify and output events"));\n<line183>if (pfd[1].revents)\n<line184>die_pipe ();\n<line185>len = safe_read (wd, evbuf, evlen);\n<line186>evbuf_off = 0;\n<line187>/* For kernels prior to 2.6.21, read returns 0 when the buffer\n<line188>is too small.  */\n<line189>if ((len == 0 || (len == SAFE_READ_ERROR && errno == EINVAL))\n<line190>&& max_realloc--)\n<line191>{\n<line192>len = 0;\n<line193>evlen *= 2;\n<line194>evbuf = xrealloc (evbuf, evlen);\n<line195>continue;\n<line196>}\n<line197>if (len == 0 || len == SAFE_READ_ERROR)\n<line198>error (EXIT_FAILURE, errno, _("error reading inotify event"));\n<line199>}\n<line200>void_ev = evbuf + evbuf_off;\n<line201>ev = void_ev;\n<line202>evbuf_off += sizeof (*ev) + ev->len;\n<line203>/* If a directory is deleted, IN_DELETE_SELF is emitted\n<line204>with ev->name of length 0.\n<line205>We need to catch it, otherwise it would wait forever,\n<line206>as wd for directory becomes inactive. Revert to polling now.   */\n<line207>if ((ev->mask & IN_DELETE_SELF) && ! ev->len)\n<line208>{\n<line209>for (i = 0; i < n_files; i++)\n<line210>{\n<line211>if (ev->wd == f[i].parent_wd)\n<line212>{\n<line213>error (0, 0,\n<line214>_("directory containing watched file was removed"));\n<line215>return;\n<line216>}\n<line217>}\n<line218>}\n<line219>if (ev->len) /* event on ev->name in watched directory.  */\n<line220>{\n<line221>size_t j;\n<line222>for (j = 0; j < n_files; j++)\n<line223>{\n<line224>/* With N=hundreds of frequently-changing files, this O(N^2)\n<line225>process might be a problem.  FIXME: use a hash table?  */\n<line226>if (f[j].parent_wd == ev->wd\n<line227>&& STREQ (ev->name, f[j].name + f[j].basename_start))\n<line228>break;\n<line229>}\n<line230>/* It is not a watched file.  */\n<line231>if (j == n_files)\n<line232>continue;\n<line233>fspec = &(f[j]);\n<line234>int new_wd = -1;\n<line235>bool deleting = !! (ev->mask & IN_DELETE);\n<line236>if (! deleting)\n<line237>{\n<line238>/* Adding the same inode again will look up any existing wd.  */\n<line239>new_wd = inotify_add_watch (wd, f[j].name, inotify_wd_mask);\n<line240>}\n<line241>if (! deleting && new_wd < 0)\n<line242>{\n<line243>if (errno == ENOSPC || errno == ENOMEM)\n<line244>{\n<line245>error (0, 0, _("inotify resources exhausted"));\n<line246>return; /* revert to polling.  */\n<line247>}\n<line248>else\n<line249>{\n<line250>/* Can get ENOENT for a dangling symlink for example.  */\n<line251>error (0, errno, _("cannot watch %s"), quoteaf (f[j].name));\n<line252>}\n<line253>/* We'll continue below after removing the existing watch.  */\n<line254>}\n<line255>/* This will be false if only attributes of file change.  */\n<line256>bool new_watch;\n<line257>new_watch = (! deleting) && (fspec->wd < 0 || new_wd != fspec->wd);\n<line258>if (new_watch)\n<line259>{\n<line260>if (0 <= fspec->wd)\n<line261>{\n<line262>inotify_rm_watch (wd, fspec->wd);\n<line263>hash_remove (wd_to_name, fspec);\n<line264>}\n<line265>fspec->wd = new_wd;\n<line266>if (new_wd == -1)\n<line267>continue;\n<line268>/* If the file was moved then inotify will use the source file wd\n<line269>for the destination file.  Make sure the key is not present in\n<line270>the table.  */\n<line271>struct File_spec *prev = hash_remove (wd_to_name, fspec);\n<line272>if (prev && prev != fspec)\n<line273>{\n<line274>if (follow_mode == Follow_name)\n<line275>recheck (prev, false);\n<line276>prev->wd = -1;\n<line277>close_fd (prev->fd, pretty_name (prev));\n<line278>}\n<line279>if (hash_insert (wd_to_name, fspec) == nullptr)\n<line280>xalloc_die ();\n<line281>}\n<line282>if (follow_mode == Follow_name)\n<line283>recheck (fspec, false);\n<line284>}\n<line285>else\n<line286>{\n<line287>struct File_spec key;\n<line288>key.wd = ev->wd;\n<line289>fspec = hash_lookup (wd_to_name, &key);\n<line290>}\n<line291>if (! fspec)\n<line292>continue;\n<line293>if (ev->mask & (IN_ATTRIB | IN_DELETE | IN_DELETE_SELF | IN_MOVE_SELF))\n<line294>{\n<line295>/* Note for IN_MOVE_SELF (the file we're watching has\n<line296>been clobbered via a rename) we leave the watch\n<line297>in place since it may still be part of the set\n<line298>of watched names.  */\n<line299>if (ev->mask & IN_DELETE_SELF)\n<line300>{\n<line301>inotify_rm_watch (wd, fspec->wd);\n<line302>hash_remove (wd_to_name, fspec);\n<line303>}\n<line304>/* Note we get IN_ATTRIB for unlink() as st_nlink decrements.\n<line305>The usual path is a close() done in recheck() triggers\n<line306>an IN_DELETE_SELF event as the inode is removed.\n<line307>However sometimes open() will succeed as even though\n<line308>st_nlink is decremented, the dentry (cache) is not updated.\n<line309>Thus we depend on the IN_DELETE event on the directory\n<line310>to trigger processing for the removed file.  */\n<line311>recheck (fspec, false);\n<line312>continue;\n<line313>}\n<line314>check_fspec (fspec, &prev_fspec);\n<line315>}\n<line316>}
----------------------------------------
Function: tail_bytes
Content: <line0>static bool\n<line1>tail_bytes (char const *pretty_filename, int fd, uintmax_t n_bytes,\n<line2>uintmax_t *read_pos)\n<line3>{\n<line4>struct stat stats;\n<line5>if (fstat (fd, &stats))\n<line6>{\n<line7>error (0, errno, _("cannot fstat %s"), quoteaf (pretty_filename));\n<line8>return false;\n<line9>}\n<line10>if (from_start)\n<line11>{\n<line12>if (! presume_input_pipe && n_bytes <= OFF_T_MAX\n<line13>&& ((S_ISREG (stats.st_mode)\n<line14>&& xlseek (fd, n_bytes, SEEK_CUR, pretty_filename) >= 0)\n<line15>|| lseek (fd, n_bytes, SEEK_CUR) != -1))\n<line16>*read_pos += n_bytes;\n<line17>else\n<line18>{\n<line19>int t = start_bytes (pretty_filename, fd, n_bytes, read_pos);\n<line20>if (t)\n<line21>return t < 0;\n<line22>}\n<line23>n_bytes = COPY_TO_EOF;\n<line24>}\n<line25>else\n<line26>{\n<line27>off_t end_pos = -1;\n<line28>off_t current_pos = -1;\n<line29>if (! presume_input_pipe && n_bytes <= OFF_T_MAX)\n<line30>{\n<line31>if (usable_st_size (&stats))\n<line32>end_pos = stats.st_size;\n<line33>else if ((current_pos = lseek (fd, -n_bytes, SEEK_END)) != -1)\n<line34>end_pos = current_pos + n_bytes;\n<line35>}\n<line36>if (end_pos <= (off_t) ST_BLKSIZE (stats))\n<line37>return pipe_bytes (pretty_filename, fd, n_bytes, read_pos);\n<line38>if (current_pos == -1)\n<line39>current_pos = xlseek (fd, 0, SEEK_CUR, pretty_filename);\n<line40>if (current_pos < end_pos)\n<line41>{\n<line42>off_t bytes_remaining = end_pos - current_pos;\n<line43>if (n_bytes < bytes_remaining)\n<line44>{\n<line45>current_pos = end_pos - n_bytes;\n<line46>xlseek (fd, current_pos, SEEK_SET, pretty_filename);\n<line47>}\n<line48>}\n<line49>*read_pos = current_pos;\n<line50>}\n<line51>*read_pos += dump_remainder (false, pretty_filename, fd, n_bytes);\n<line52>return true;\n<line53>}
----------------------------------------
Function: tail_lines
Content: <line0>static bool\n<line1>tail_lines (char const *pretty_filename, int fd, uintmax_t n_lines,\n<line2>uintmax_t *read_pos)\n<line3>{\n<line4>struct stat stats;\n<line5>if (fstat (fd, &stats))\n<line6>{\n<line7>error (0, errno, _("cannot fstat %s"), quoteaf (pretty_filename));\n<line8>return false;\n<line9>}\n<line10>if (from_start)\n<line11>{\n<line12>int t = start_lines (pretty_filename, fd, n_lines, read_pos);\n<line13>if (t)\n<line14>return t < 0;\n<line15>*read_pos += dump_remainder (false, pretty_filename, fd, COPY_TO_EOF);\n<line16>}\n<line17>else\n<line18>{\n<line19>off_t start_pos = -1;\n<line20>off_t end_pos;\n<line21>/* Use file_lines only if FD refers to a regular file for\n<line22>which lseek (... SEEK_END) works.  */\n<line23>if ( ! presume_input_pipe\n<line24>&& S_ISREG (stats.st_mode)\n<line25>&& (start_pos = lseek (fd, 0, SEEK_CUR)) != -1\n<line26>&& start_pos < (end_pos = lseek (fd, 0, SEEK_END)))\n<line27>{\n<line28>*read_pos = end_pos;\n<line29>if (end_pos != 0\n<line30>&& ! file_lines (pretty_filename, fd, n_lines,\n<line31>start_pos, end_pos, read_pos))\n<line32>return false;\n<line33>}\n<line34>else\n<line35>{\n<line36>/* Under very unlikely circumstances, it is possible to reach\n<line37>this point after positioning the file pointer to end of file\n<line38>via the 'lseek (...SEEK_END)' above.  In that case, reposition\n<line39>the file pointer back to start_pos before calling pipe_lines.  */\n<line40>if (start_pos != -1)\n<line41>xlseek (fd, start_pos, SEEK_SET, pretty_filename);\n<line42>return pipe_lines (pretty_filename, fd, n_lines, read_pos);\n<line43>}\n<line44>}\n<line45>return true;\n<line46>}
----------------------------------------
Function: tail
Content: <line0>static bool\n<line1>tail (char const *filename, int fd, uintmax_t n_units,\n<line2>uintmax_t *read_pos)\n<line3>{\n<line4>*read_pos = 0;\n<line5>if (count_lines)\n<line6>return tail_lines (filename, fd, n_units, read_pos);\n<line7>else\n<line8>return tail_bytes (filename, fd, n_units, read_pos);\n<line9>}
----------------------------------------
Function: tail_file
Content: <line0>static bool\n<line1>tail_file (struct File_spec *f, uintmax_t n_units)\n<line2>{\n<line3>int fd;\n<line4>bool ok;\n<line5>bool is_stdin = (STREQ (f->name, "-"));\n<line6>if (is_stdin)\n<line7>{\n<line8>have_read_stdin = true;\n<line9>fd = STDIN_FILENO;\n<line10>xset_binary_mode (STDIN_FILENO, O_BINARY);\n<line11>}\n<line12>else\n<line13>fd = open (f->name, O_RDONLY | O_BINARY);\n<line14>f->tailable = !(reopen_inaccessible_files && fd == -1);\n<line15>if (fd == -1)\n<line16>{\n<line17>if (forever)\n<line18>{\n<line19>f->fd = -1;\n<line20>f->errnum = errno;\n<line21>f->ignore = ! reopen_inaccessible_files;\n<line22>f->ino = 0;\n<line23>f->dev = 0;\n<line24>}\n<line25>error (0, errno, _("cannot open %s for reading"),\n<line26>quoteaf (pretty_name (f)));\n<line27>ok = false;\n<line28>}\n<line29>else\n<line30>{\n<line31>uintmax_t read_pos;\n<line32>if (print_headers)\n<line33>write_header (pretty_name (f));\n<line34>ok = tail (pretty_name (f), fd, n_units, &read_pos);\n<line35>if (forever)\n<line36>{\n<line37>struct stat stats;\n<line38>#if TAIL_TEST_SLEEP\n<line39>/* Before the tail function provided 'read_pos', there was\n<line40>a race condition described in the URL below.  This sleep\n<line41>call made the window big enough to exercise the problem.  */\n<line42>xnanosleep (1);\n<line43>#endif\n<line44>f->errnum = ok - 1;\n<line45>if (fstat (fd, &stats) < 0)\n<line46>{\n<line47>ok = false;\n<line48>f->errnum = errno;\n<line49>error (0, errno, _("error reading %s"),\n<line50>quoteaf (pretty_name (f)));\n<line51>}\n<line52>else if (!IS_TAILABLE_FILE_TYPE (stats.st_mode))\n<line53>{\n<line54>ok = false;\n<line55>f->errnum = -1;\n<line56>f->tailable = false;\n<line57>f->ignore = ! reopen_inaccessible_files;\n<line58>error (0, 0, _("%s: cannot follow end of this type of file%s"),\n<line59>quotef (pretty_name (f)),\n<line60>f->ignore ? _("; giving up on this name") : "");\n<line61>}\n<line62>if (!ok)\n<line63>{\n<line64>f->ignore = ! reopen_inaccessible_files;\n<line65>close_fd (fd, pretty_name (f));\n<line66>f->fd = -1;\n<line67>}\n<line68>else\n<line69>{\n<line70>/* Note: we must use read_pos here, not stats.st_size,\n<line71>to avoid a race condition described by Ken Raeburn:\n<line72>https://lists.gnu.org/r/bug-textutils/2003-05/msg00007.html */\n<line73>record_open_fd (f, fd, read_pos, &stats, (is_stdin ? -1 : 1));\n<line74>f->remote = fremote (fd, pretty_name (f));\n<line75>}\n<line76>}\n<line77>else\n<line78>{\n<line79>if (!is_stdin && close (fd))\n<line80>{\n<line81>error (0, errno, _("error reading %s"),\n<line82>quoteaf (pretty_name (f)));\n<line83>ok = false;\n<line84>}\n<line85>}\n<line86>}\n<line87>return ok;\n<line88>}
----------------------------------------
Function: parse_obsolete_option
Content: <line0>static bool\n<line1>parse_obsolete_option (int argc, char * const *argv, uintmax_t *n_units)\n<line2>{\n<line3>char const *p;\n<line4>char const *n_string;\n<line5>char const *n_string_end;\n<line6>int default_count = DEFAULT_N_LINES;\n<line7>bool t_from_start;\n<line8>bool t_count_lines = true;\n<line9>bool t_forever = false;\n<line10>/* With the obsolete form, there is one option string and at most\n<line11>one file argument.  Watch out for "-" and "--", though.  */\n<line12>if (! (argc == 2\n<line13>|| (argc == 3 && ! (argv[2][0] == '-' && argv[2][1]))\n<line14>|| (3 <= argc && argc <= 4 && STREQ (argv[2], "--"))))\n<line15>return false;\n<line16>int posix_ver = posix2_version ();\n<line17>bool obsolete_usage = posix_ver < 200112;\n<line18>bool traditional_usage = obsolete_usage || 200809 <= posix_ver;\n<line19>p = argv[1];\n<line20>switch (*p++)\n<line21>{\n<line22>default:\n<line23>return false;\n<line24>case '+':\n<line25>/* Leading "+" is a file name in the standard form.  */\n<line26>if (!traditional_usage)\n<line27>return false;\n<line28>t_from_start = true;\n<line29>break;\n<line30>case '-':\n<line31>/* In the non-obsolete form, "-" is standard input and "-c"\n<line32>requires an option-argument.  The obsolete multidigit options\n<line33>are supported as a GNU extension even when conforming to\n<line34>POSIX 1003.1-2001 or later, so don't complain about them.  */\n<line35>if (!obsolete_usage && !p[p[0] == 'c'])\n<line36>return false;\n<line37>t_from_start = false;\n<line38>break;\n<line39>}\n<line40>n_string = p;\n<line41>while (ISDIGIT (*p))\n<line42>p++;\n<line43>n_string_end = p;\n<line44>switch (*p)\n<line45>{\n<line46>case 'b': default_count *= 512; FALLTHROUGH;\n<line47>case 'c': t_count_lines = false; FALLTHROUGH;\n<line48>case 'l': p++; break;\n<line49>}\n<line50>if (*p == 'f')\n<line51>{\n<line52>t_forever = true;\n<line53>++p;\n<line54>}\n<line55>if (*p)\n<line56>return false;\n<line57>if (n_string == n_string_end)\n<line58>*n_units = default_count;\n<line59>else if ((xstrtoumax (n_string, nullptr, 10, n_units, "b")\n<line60>& ~LONGINT_INVALID_SUFFIX_CHAR)\n<line61>!= LONGINT_OK)\n<line62>error (EXIT_FAILURE, errno, "%s: %s", _("invalid number"),\n<line63>quote (argv[1]));\n<line64>/* Set globals.  */\n<line65>from_start = t_from_start;\n<line66>count_lines = t_count_lines;\n<line67>forever = t_forever;\n<line68>return true;\n<line69>}
----------------------------------------
Function: parse_options
Content: <line0>static void\n<line1>parse_options (int argc, char **argv,\n<line2>uintmax_t *n_units, enum header_mode *header_mode,\n<line3>double *sleep_interval)\n<line4>{\n<line5>int c;\n<line6>while ((c = getopt_long (argc, argv, "c:n:fFqs:vz0123456789",\n<line7>long_options, nullptr))\n<line8>!= -1)\n<line9>{\n<line10>switch (c)\n<line11>{\n<line12>case 'F':\n<line13>forever = true;\n<line14>follow_mode = Follow_name;\n<line15>reopen_inaccessible_files = true;\n<line16>break;\n<line17>case 'c':\n<line18>case 'n':\n<line19>count_lines = (c == 'n');\n<line20>if (*optarg == '+')\n<line21>from_start = true;\n<line22>else if (*optarg == '-')\n<line23>++optarg;\n<line24>*n_units = xdectoumax (optarg, 0, UINTMAX_MAX, "bkKmMGTPEZYRQ0",\n<line25>count_lines\n<line26>? _("invalid number of lines")\n<line27>: _("invalid number of bytes"), 0);\n<line28>break;\n<line29>case 'f':\n<line30>case LONG_FOLLOW_OPTION:\n<line31>forever = true;\n<line32>if (optarg == nullptr)\n<line33>follow_mode = DEFAULT_FOLLOW_MODE;\n<line34>else\n<line35>follow_mode = XARGMATCH ("--follow", optarg,\n<line36>follow_mode_string, follow_mode_map);\n<line37>break;\n<line38>case RETRY_OPTION:\n<line39>reopen_inaccessible_files = true;\n<line40>break;\n<line41>case MAX_UNCHANGED_STATS_OPTION:\n<line42>/* --max-unchanged-stats=N */\n<line43>max_n_unchanged_stats_between_opens =\n<line44>xdectoumax (optarg, 0, UINTMAX_MAX, "",\n<line45>_("invalid maximum number of unchanged stats between opens"), 0);\n<line46>break;\n<line47>case DISABLE_INOTIFY_OPTION:\n<line48>disable_inotify = true;\n<line49>break;\n<line50>case PID_OPTION:\n<line51>pid = xdectoumax (optarg, 0, PID_T_MAX, "", _("invalid PID"), 0);\n<line52>break;\n<line53>case PRESUME_INPUT_PIPE_OPTION:\n<line54>presume_input_pipe = true;\n<line55>break;\n<line56>case 'q':\n<line57>*header_mode = never;\n<line58>break;\n<line59>case 's':\n<line60>{\n<line61>double s;\n<line62>if (! (xstrtod (optarg, nullptr, &s, cl_strtod) && 0 <= s))\n<line63>error (EXIT_FAILURE, 0,\n<line64>_("invalid number of seconds: %s"), quote (optarg));\n<line65>*sleep_interval = s;\n<line66>}\n<line67>break;\n<line68>case 'v':\n<line69>*header_mode = always;\n<line70>break;\n<line71>case 'z':\n<line72>line_end = '\0';\n<line73>break;\n<line74>case_GETOPT_HELP_CHAR;\n<line75>case_GETOPT_VERSION_CHAR (PROGRAM_NAME, AUTHORS);\n<line76>case '0': case '1': case '2': case '3': case '4':\n<line77>case '5': case '6': case '7': case '8': case '9':\n<line78>error (EXIT_FAILURE, 0, _("option used in invalid context -- %c"), c);\n<line79>default:\n<line80>usage (EXIT_FAILURE);\n<line81>}\n<line82>}\n<line83>if (reopen_inaccessible_files)\n<line84>{\n<line85>if (!forever)\n<line86>{\n<line87>reopen_inaccessible_files = false;\n<line88>error (0, 0, _("warning: --retry ignored; --retry is useful"\n<line89>" only when following"));\n<line90>}\n<line91>else if (follow_mode == Follow_descriptor)\n<line92>error (0, 0, _("warning: --retry only effective for the initial open"));\n<line93>}\n<line94>if (pid && !forever)\n<line95>error (0, 0,\n<line96>_("warning: PID ignored; --pid=PID is useful only when following"));\n<line97>else if (pid && kill (pid, 0) != 0 && errno == ENOSYS)\n<line98>{\n<line99>error (0, 0, _("warning: --pid=PID is not supported on this system"));\n<line100>pid = 0;\n<line101>}\n<line102>}
----------------------------------------
Function: ignore_fifo_and_pipe
Content: <line0>static size_t\n<line1>ignore_fifo_and_pipe (struct File_spec *f, size_t n_files)\n<line2>{\n<line3>/* When there is no FILE operand and stdin is a pipe or FIFO\n<line4>POSIX requires that tail ignore the -f option.\n<line5>Since we allow multiple FILE operands, we extend that to say: with -f,\n<line6>ignore any "-" operand that corresponds to a pipe or FIFO.  */\n<line7>size_t n_viable = 0;\n<line8>for (size_t i = 0; i < n_files; i++)\n<line9>{\n<line10>bool is_a_fifo_or_pipe =\n<line11>(STREQ (f[i].name, "-")\n<line12>&& !f[i].ignore\n<line13>&& 0 <= f[i].fd\n<line14>&& (S_ISFIFO (f[i].mode)\n<line15>|| (HAVE_FIFO_PIPES != 1 && isapipe (f[i].fd))));\n<line16>if (is_a_fifo_or_pipe)\n<line17>{\n<line18>f[i].fd = -1;\n<line19>f[i].ignore = true;\n<line20>}\n<line21>else\n<line22>++n_viable;\n<line23>}\n<line24>return n_viable;\n<line25>}
----------------------------------------
Function: main
Content: <line0>int\n<line1>main (int argc, char **argv)\n<line2>{\n<line3>enum header_mode header_mode = multiple_files;\n<line4>bool ok = true;\n<line5>/* If from_start, the number of items to skip before printing; otherwise,\n<line6>the number of items at the end of the file to print.  Although the type\n<line7>is signed, the value is never negative.  */\n<line8>uintmax_t n_units = DEFAULT_N_LINES;\n<line9>size_t n_files;\n<line10>char **file;\n<line11>struct File_spec *F;\n<line12>size_t i;\n<line13>bool obsolete_option;\n<line14>/* The number of seconds to sleep between iterations.\n<line15>During one iteration, every file name or descriptor is checked to\n<line16>see if it has changed.  */\n<line17>double sleep_interval = 1.0;\n<line18>initialize_main (&argc, &argv);\n<line19>set_program_name (argv[0]);\n<line20>setlocale (LC_ALL, "");\n<line21>bindtextdomain (PACKAGE, LOCALEDIR);\n<line22>textdomain (PACKAGE);\n<line23>atexit (close_stdout);\n<line24>have_read_stdin = false;\n<line25>count_lines = true;\n<line26>forever = from_start = print_headers = false;\n<line27>line_end = '\n';\n<line28>obsolete_option = parse_obsolete_option (argc, argv, &n_units);\n<line29>argc -= obsolete_option;\n<line30>argv += obsolete_option;\n<line31>parse_options (argc, argv, &n_units, &header_mode, &sleep_interval);\n<line32>/* To start printing with item N_UNITS from the start of the file, skip\n<line33>N_UNITS - 1 items.  'tail -n +0' is actually meaningless, but for Unix\n<line34>compatibility it's treated the same as 'tail -n +1'.  */\n<line35>if (from_start)\n<line36>{\n<line37>if (n_units)\n<line38>--n_units;\n<line39>}\n<line40>if (optind < argc)\n<line41>{\n<line42>n_files = argc - optind;\n<line43>file = argv + optind;\n<line44>}\n<line45>else\n<line46>{\n<line47>static char *dummy_stdin = (char *) "-";\n<line48>n_files = 1;\n<line49>file = &dummy_stdin;\n<line50>}\n<line51>{\n<line52>bool found_hyphen = false;\n<line53>for (i = 0; i < n_files; i++)\n<line54>if (STREQ (file[i], "-"))\n<line55>found_hyphen = true;\n<line56>/* When following by name, there must be a name.  */\n<line57>if (found_hyphen && follow_mode == Follow_name)\n<line58>error (EXIT_FAILURE, 0, _("cannot follow %s by name"), quoteaf ("-"));\n<line59>/* When following forever, and not using simple blocking, warn if\n<line60>any file is '-' as the stats() used to check for input are ineffective.\n<line61>This is only a warning, since tail's output (before a failing seek,\n<line62>and that from any non-stdin files) might still be useful.  */\n<line63>if (forever && found_hyphen)\n<line64>{\n<line65>struct stat in_stat;\n<line66>bool blocking_stdin;\n<line67>blocking_stdin = (pid == 0 && follow_mode == Follow_descriptor\n<line68>&& n_files == 1 && ! fstat (STDIN_FILENO, &in_stat)\n<line69>&& ! S_ISREG (in_stat.st_mode));\n<line70>if (! blocking_stdin && isatty (STDIN_FILENO))\n<line71>error (0, 0, _("warning: following standard input"\n<line72>" indefinitely is ineffective"));\n<line73>}\n<line74>}\n<line75>/* Don't read anything if we'll never output anything.  */\n<line76>if (! n_units && ! forever && ! from_start)\n<line77>return EXIT_SUCCESS;\n<line78>F = xnmalloc (n_files, sizeof *F);\n<line79>for (i = 0; i < n_files; i++)\n<line80>F[i].name = file[i];\n<line81>if (header_mode == always\n<line82>|| (header_mode == multiple_files && n_files > 1))\n<line83>print_headers = true;\n<line84>xset_binary_mode (STDOUT_FILENO, O_BINARY);\n<line85>for (i = 0; i < n_files; i++)\n<line86>ok &= tail_file (&F[i], n_units);\n<line87>if (forever && ignore_fifo_and_pipe (F, n_files))\n<line88>{\n<line89>/* If stdout is a fifo or pipe, then monitor it\n<line90>so that we exit if the reader goes away.  */\n<line91>struct stat out_stat;\n<line92>if (fstat (STDOUT_FILENO, &out_stat) < 0)\n<line93>error (EXIT_FAILURE, errno, _("standard output"));\n<line94>monitor_output = (S_ISFIFO (out_stat.st_mode)\n<line95>|| (HAVE_FIFO_PIPES != 1 && isapipe (STDOUT_FILENO)));\n<line96>#if HAVE_INOTIFY\n<line97>/* tailable_stdin() checks if the user specifies stdin via  "-",\n<line98>or implicitly by providing no arguments. If so, we won't use inotify.\n<line99>Technically, on systems with a working /dev/stdin, we *could*,\n<line100>but would it be worth it?  Verifying that it's a real device\n<line101>and hooked up to stdin is not trivial, while reverting to\n<line102>non-inotify-based tail_forever is easy and portable.\n<line103>any_remote_file() checks if the user has specified any\n<line104>files that reside on remote file systems.  inotify is not used\n<line105>in this case because it would miss any updates to the file\n<line106>that were not initiated from the local system.\n<line107>any_non_remote_file() checks if the user has specified any\n<line108>files that don't reside on remote file systems.  inotify is not used\n<line109>if there are no open files, as we can't determine if those file\n<line110>will be on a remote file system.\n<line111>any_symlinks() checks if the user has specified any symbolic links.\n<line112>inotify is not used in this case because it returns updated _targets_\n<line113>which would not match the specified names.  If we tried to always\n<line114>use the target names, then we would miss changes to the symlink itself.\n<line115>ok is false when one of the files specified could not be opened for\n<line116>reading.  In this case and when following by descriptor,\n<line117>tail_forever_inotify() cannot be used (in its current implementation).\n<line118>FIXME: inotify doesn't give any notification when a new\n<line119>(remote) file or directory is mounted on top a watched file.\n<line120>When follow_mode == Follow_name we would ideally like to detect that.\n<line121>Note if there is a change to the original file then we'll\n<line122>recheck it and follow the new file, or ignore it if the\n<line123>file has changed to being remote.\n<line124>FIXME-maybe: inotify has a watch descriptor per inode, and hence with\n<line125>our current hash implementation will only --follow data for one\n<line126>of the names when multiple hardlinked files are specified, or\n<line127>for one name when a name is specified multiple times.  */\n<line128>if (!disable_inotify && (tailable_stdin (F, n_files)\n<line129>|| any_remote_file (F, n_files)\n<line130>|| ! any_non_remote_file (F, n_files)\n<line131>|| any_symlinks (F, n_files)\n<line132>|| any_non_regular_fifo (F, n_files)\n<line133>|| (!ok && follow_mode == Follow_descriptor)))\n<line134>disable_inotify = true;\n<line135>if (!disable_inotify)\n<line136>{\n<line137>int wd = inotify_init ();\n<line138>if (0 <= wd)\n<line139>{\n<line140>/* Flush any output from tail_file, now, since\n<line141>tail_forever_inotify flushes only after writing,\n<line142>not before reading.  */\n<line143>if (fflush (stdout) != 0)\n<line144>write_error ();\n<line145>Hash_table *ht;\n<line146>tail_forever_inotify (wd, F, n_files, sleep_interval, &ht);\n<line147>hash_free (ht);\n<line148>close (wd);\n<line149>errno = 0;\n<line150>}\n<line151>error (0, errno, _("inotify cannot be used, reverting to polling"));\n<line152>}\n<line153>#endif\n<line154>disable_inotify = true;\n<line155>tail_forever (F, n_files, sleep_interval);\n<line156>}\n<line157>if (have_read_stdin && close (STDIN_FILENO) < 0)\n<line158>error (EXIT_FAILURE, errno, "-");\n<line159>main_exit (ok ? EXIT_SUCCESS : EXIT_FAILURE);\n<line160>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/src/iopoll.c
========================================
Function: iopoll_internal
Content: <line0>static int\n<line1>iopoll_internal (int fdin, int fdout, bool block, bool broken_output)\n<line2>{\n<line3>affirm (fdin != -1 || fdout != -1);\n<line4>#if IOPOLL_USES_POLL\n<line5>struct pollfd pfds[2] = {  /* POLLRDBAND needed for illumos, macOS.  */\n<line6>{ .fd = fdin,  .events = POLLIN | POLLRDBAND, .revents = 0 },\n<line7>{ .fd = fdout, .events = POLLRDBAND, .revents = 0 },\n<line8>};\n<line9>int check_out_events = POLLERR | POLLHUP | POLLNVAL;\n<line10>int ret = 0;\n<line11>if (! broken_output)\n<line12>{\n<line13>pfds[0].events = pfds[1].events = POLLOUT;\n<line14>check_out_events = POLLOUT;\n<line15>}\n<line16>while (0 <= ret || errno == EINTR)\n<line17>{\n<line18>ret = poll (pfds, 2, block ? -1 : 0);\n<line19>if (ret < 0)\n<line20>continue;\n<line21>if (ret == 0 && ! block)\n<line22>return 0;\n<line23>affirm (0 < ret);\n<line24>if (pfds[0].revents) /* input available or pipe closed indicating EOF; */\n<line25>return 0;          /* should now be able to read() without blocking  */\n<line26>if (pfds[1].revents & check_out_events)\n<line27>return broken_output ? IOPOLL_BROKEN_OUTPUT : 0;\n<line28>}\n<line29>#else  /* fall back to select()-based implementation */\n<line30>int nfds = (fdin > fdout ? fdin : fdout) + 1;\n<line31>int ret = 0;\n<line32>if (FD_SETSIZE < nfds)\n<line33>{\n<line34>errno = EINVAL;\n<line35>ret = -1;\n<line36>}\n<line37>/* If fdout has an error condition (like a broken pipe) it will be seen\n<line38>as ready for reading.  Assumes fdout is not actually readable.  */\n<line39>while (0 <= ret || errno == EINTR)\n<line40>{\n<line41>fd_set fds;\n<line42>FD_ZERO (&fds);\n<line43>if (0 <= fdin)\n<line44>FD_SET (fdin, &fds);\n<line45>if (0 <= fdout)\n<line46>FD_SET (fdout, &fds);\n<line47>struct timeval delay = { .tv_sec = 0, .tv_usec = 0 };\n<line48>ret = select (nfds,\n<line49>broken_output ? &fds : nullptr,\n<line50>broken_output ? nullptr : &fds,\n<line51>nullptr, block ? nullptr : &delay);\n<line52>if (ret < 0)\n<line53>continue;\n<line54>if (ret == 0 && ! block)\n<line55>return 0;\n<line56>affirm (0 < ret);\n<line57>if (0 <= fdin && FD_ISSET (fdin, &fds))    /* input available or EOF; */\n<line58>return 0;          /* should now be able to read() without blocking */\n<line59>if (0 <= fdout && FD_ISSET (fdout, &fds))  /* equiv to POLLERR        */\n<line60>return broken_output ? IOPOLL_BROKEN_OUTPUT : 0;\n<line61>}\n<line62>#endif\n<line63>return IOPOLL_ERROR;\n<line64>}
----------------------------------------
Function: iopoll
Content: <line0>extern int\n<line1>iopoll (int fdin, int fdout, bool block)\n<line2>{\n<line3>return iopoll_internal (fdin, fdout, block, true);\n<line4>}
----------------------------------------
Function: iopoll_input_ok
Content: <line0>extern bool\n<line1>iopoll_input_ok (int fdin)\n<line2>{\n<line3>struct stat st;\n<line4>bool always_ready = fstat (fdin, &st) == 0\n<line5>&& (S_ISREG (st.st_mode)\n<line6>|| S_ISBLK (st.st_mode));\n<line7>return ! always_ready;\n<line8>}
----------------------------------------
Function: iopoll_output_ok
Content: <line0>extern bool\n<line1>iopoll_output_ok (int fdout)\n<line2>{\n<line3>return isapipe (fdout) > 0;\n<line4>}
----------------------------------------
Function: fwait_for_nonblocking_write
Content: <line0>static bool\n<line1>fwait_for_nonblocking_write (FILE *f)\n<line2>{\n<line3>if (! IS_EAGAIN (errno))\n<line4>/* non-recoverable write error */\n<line5>return false;\n<line6>int fd = fileno (f);\n<line7>if (fd == -1)\n<line8>goto fail;\n<line9>/* wait for the file descriptor to become writable */\n<line10>if (iopoll_internal (-1, fd, true, false) != 0)\n<line11>goto fail;\n<line12>/* successfully waited for the descriptor to become writable */\n<line13>clearerr (f);\n<line14>return true;\n<line15>fail:\n<line16>errno = EAGAIN;\n<line17>return false;\n<line18>}
----------------------------------------
Function: fclose_wait
Content: <line0>extern bool\n<line1>fclose_wait (FILE *f)\n<line2>{\n<line3>for (;;)\n<line4>{\n<line5>if (fflush (f) == 0)\n<line6>break;\n<line7>if (! fwait_for_nonblocking_write (f))\n<line8>break;\n<line9>}\n<line10>return fclose (f) == 0;\n<line11>}
----------------------------------------
Function: fwrite_wait
Content: <line0>extern bool\n<line1>fwrite_wait (char const *buf, ssize_t size, FILE *f)\n<line2>{\n<line3>for (;;)\n<line4>{\n<line5>const size_t written = fwrite (buf, 1, size, f);\n<line6>size -= written;\n<line7>affirm (size >= 0);\n<line8>if (size <= 0)  /* everything written */\n<line9>return true;\n<line10>if (! fwait_for_nonblocking_write (f))\n<line11>return false;\n<line12>buf += written;\n<line13>}\n<line14>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/src/tee.c
========================================
/home/huihui/Downloads/coreutils-9.4/src/tee.c:78:1: warning: '_Static_assert' with no message is a C2x extension [-Wc2x-extensions]
ARGMATCH_VERIFY (output_error_args, output_error_types);
^
./lib/argmatch.h:49:54: note: expanded from macro 'ARGMATCH_VERIFY'
                   == ARRAY_CARDINALITY (Vallist) + 1)
                                                     ^
1 warning generated.
Function: usage
Content: <line0>void\n<line1>usage (int status)\n<line2>{\n<line3>if (status != EXIT_SUCCESS)\n<line4>emit_try_help ();\n<line5>else\n<line6>{\n<line7>printf (_("Usage: %s [OPTION]... [FILE]...\n"), program_name);\n<line8>fputs (_("\\n<line9>Copy standard input to each FILE, and also to standard output.\n\\n<line10>\n\\n<line11>-a, --append              append to the given FILEs, do not overwrite\n\\n<line12>-i, --ignore-interrupts   ignore interrupt signals\n\\n<line13>"), stdout);\n<line14>fputs (_("\\n<line15>-p                        operate in a more appropriate MODE with pipes.\n\\n<line16>--output-error[=MODE]   set behavior on write error.  See MODE below\n\\n<line17>"), stdout);\n<line18>fputs (HELP_OPTION_DESCRIPTION, stdout);\n<line19>fputs (VERSION_OPTION_DESCRIPTION, stdout);\n<line20>fputs (_("\\n<line21>\n\\n<line22>MODE determines behavior with write errors on the outputs:\n\\n<line23>warn           diagnose errors writing to any output\n\\n<line24>warn-nopipe    diagnose errors writing to any output not a pipe\n\\n<line25>exit           exit on error writing to any output\n\\n<line26>exit-nopipe    exit on error writing to any output not a pipe\n\\n<line27>The default MODE for the -p option is 'warn-nopipe'.\n\\n<line28>With \"nopipe\" MODEs, exit immediately if all outputs become broken pipes.\n\\n<line29>The default operation when --output-error is not specified, is to\n\\n<line30>exit immediately on error writing to a pipe, and diagnose errors\n\\n<line31>writing to non pipe outputs.\n\\n<line32>"), stdout);\n<line33>emit_ancillary_info (PROGRAM_NAME);\n<line34>}\n<line35>exit (status);\n<line36>}
----------------------------------------
Function: main
Content: <line0>int\n<line1>main (int argc, char **argv)\n<line2>{\n<line3>initialize_main (&argc, &argv);\n<line4>set_program_name (argv[0]);\n<line5>setlocale (LC_ALL, "");\n<line6>bindtextdomain (PACKAGE, LOCALEDIR);\n<line7>textdomain (PACKAGE);\n<line8>atexit (close_stdout);\n<line9>append = false;\n<line10>ignore_interrupts = false;\n<line11>int optc;\n<line12>while ((optc = getopt_long (argc, argv, "aip", long_options, nullptr)) != -1)\n<line13>{\n<line14>switch (optc)\n<line15>{\n<line16>case 'a':\n<line17>append = true;\n<line18>break;\n<line19>case 'i':\n<line20>ignore_interrupts = true;\n<line21>break;\n<line22>case 'p':\n<line23>if (optarg)\n<line24>output_error = XARGMATCH ("--output-error", optarg,\n<line25>output_error_args, output_error_types);\n<line26>else\n<line27>output_error = output_error_warn_nopipe;\n<line28>break;\n<line29>case_GETOPT_HELP_CHAR;\n<line30>case_GETOPT_VERSION_CHAR (PROGRAM_NAME, AUTHORS);\n<line31>default:\n<line32>usage (EXIT_FAILURE);\n<line33>}\n<line34>}\n<line35>if (ignore_interrupts)\n<line36>signal (SIGINT, SIG_IGN);\n<line37>if (output_error != output_error_sigpipe)\n<line38>signal (SIGPIPE, SIG_IGN);\n<line39>/* Whether to detect and close a broken pipe output.\n<line40>There is no need if the input is always ready for reading.  */\n<line41>bool pipe_check = ((output_error == output_error_warn_nopipe\n<line42>|| output_error == output_error_exit_nopipe)\n<line43>&& iopoll_input_ok (STDIN_FILENO));\n<line44>/* Do *not* warn if tee is given no file arguments.\n<line45>POSIX requires that it work when given no arguments.  */\n<line46>bool ok = tee_files (argc - optind, &argv[optind], pipe_check);\n<line47>if (close (STDIN_FILENO) != 0)\n<line48>error (EXIT_FAILURE, errno, "%s", _("standard input"));\n<line49>return ok ? EXIT_SUCCESS : EXIT_FAILURE;\n<line50>}
----------------------------------------
Function: get_next_out
Content: <line0>static int\n<line1>get_next_out (FILE **descriptors, int nfiles, int idx)\n<line2>{\n<line3>for (idx++; idx <= nfiles; idx++)\n<line4>if (descriptors[idx])\n<line5>return idx;\n<line6>return -1;  /* no outputs remaining */\n<line7>}
----------------------------------------
Function: fail_output
Content: <line0>static bool\n<line1>fail_output (FILE **descriptors, char **files, int i)\n<line2>{\n<line3>int w_errno = errno;\n<line4>bool fail = errno != EPIPE\n<line5>|| output_error == output_error_exit\n<line6>|| output_error == output_error_warn;\n<line7>if (descriptors[i] == stdout)\n<line8>clearerr (stdout); /* Avoid redundant close_stdout diagnostic.  */\n<line9>if (fail)\n<line10>{\n<line11>error (output_error == output_error_exit\n<line12>|| output_error == output_error_exit_nopipe,\n<line13>w_errno, "%s", quotef (files[i]));\n<line14>}\n<line15>descriptors[i] = nullptr;\n<line16>return fail;\n<line17>}
----------------------------------------
Function: tee_files
Content: <line0>static bool\n<line1>tee_files (int nfiles, char **files, bool pipe_check)\n<line2>{\n<line3>size_t n_outputs = 0;\n<line4>FILE **descriptors;\n<line5>bool *out_pollable IF_LINT ( = nullptr);\n<line6>char buffer[BUFSIZ];\n<line7>ssize_t bytes_read = 0;\n<line8>int i;\n<line9>int first_out = 0;  /* idx of first non-null output in descriptors */\n<line10>bool ok = true;\n<line11>char const *mode_string =\n<line12>(O_BINARY\n<line13>? (append ? "ab" : "wb")\n<line14>: (append ? "a" : "w"));\n<line15>xset_binary_mode (STDIN_FILENO, O_BINARY);\n<line16>xset_binary_mode (STDOUT_FILENO, O_BINARY);\n<line17>fadvise (stdin, FADVISE_SEQUENTIAL);\n<line18>/* Set up FILES[0 .. NFILES] and DESCRIPTORS[0 .. NFILES].\n<line19>In both arrays, entry 0 corresponds to standard output.  */\n<line20>descriptors = xnmalloc (nfiles + 1, sizeof *descriptors);\n<line21>if (pipe_check)\n<line22>out_pollable = xnmalloc (nfiles + 1, sizeof *out_pollable);\n<line23>files--;\n<line24>descriptors[0] = stdout;\n<line25>if (pipe_check)\n<line26>out_pollable[0] = iopoll_output_ok (fileno (descriptors[0]));\n<line27>files[0] = bad_cast (_("standard output"));\n<line28>setvbuf (stdout, nullptr, _IONBF, 0);\n<line29>n_outputs++;\n<line30>for (i = 1; i <= nfiles; i++)\n<line31>{\n<line32>/* Do not treat "-" specially - as mandated by POSIX.  */\n<line33>descriptors[i] = fopen (files[i], mode_string);\n<line34>if (descriptors[i] == nullptr)\n<line35>{\n<line36>if (pipe_check)\n<line37>out_pollable[i] = false;\n<line38>error (output_error == output_error_exit\n<line39>|| output_error == output_error_exit_nopipe,\n<line40>errno, "%s", quotef (files[i]));\n<line41>ok = false;\n<line42>}\n<line43>else\n<line44>{\n<line45>if (pipe_check)\n<line46>out_pollable[i] = iopoll_output_ok (fileno (descriptors[i]));\n<line47>setvbuf (descriptors[i], nullptr, _IONBF, 0);\n<line48>n_outputs++;\n<line49>}\n<line50>}\n<line51>while (n_outputs)\n<line52>{\n<line53>if (pipe_check && out_pollable[first_out])\n<line54>{\n<line55>/* Monitor for input, or errors on first valid output.  */\n<line56>int err = iopoll (STDIN_FILENO, fileno (descriptors[first_out]),\n<line57>true);\n<line58>/* Close the output if it became a broken pipe.  */\n<line59>if (err == IOPOLL_BROKEN_OUTPUT)\n<line60>{\n<line61>errno = EPIPE;  /* behave like write produced EPIPE */\n<line62>if (fail_output (descriptors, files, first_out))\n<line63>ok = false;\n<line64>n_outputs--;\n<line65>first_out = get_next_out (descriptors, nfiles, first_out);\n<line66>continue;\n<line67>}\n<line68>else if (err == IOPOLL_ERROR)\n<line69>{\n<line70>error (0, errno, _("iopoll error"));\n<line71>ok = false;\n<line72>}\n<line73>}\n<line74>bytes_read = read (STDIN_FILENO, buffer, sizeof buffer);\n<line75>if (bytes_read < 0 && errno == EINTR)\n<line76>continue;\n<line77>if (bytes_read <= 0)\n<line78>break;\n<line79>/* Write to all NFILES + 1 descriptors.\n<line80>Standard output is the first one.  */\n<line81>for (i = 0; i <= nfiles; i++)\n<line82>if (descriptors[i]\n<line83>&& ! fwrite_wait (buffer, bytes_read, descriptors[i]))\n<line84>{\n<line85>if (fail_output (descriptors, files, i))\n<line86>ok = false;\n<line87>n_outputs--;\n<line88>if (i == first_out)\n<line89>first_out = get_next_out (descriptors, nfiles, first_out);\n<line90>}\n<line91>}\n<line92>if (bytes_read == -1)\n<line93>{\n<line94>error (0, errno, _("read error"));\n<line95>ok = false;\n<line96>}\n<line97>/* Close the files, but not standard output.  */\n<line98>for (i = 1; i <= nfiles; i++)\n<line99>if (descriptors[i] && ! fclose_wait (descriptors[i]))\n<line100>{\n<line101>error (0, errno, "%s", quotef (files[i]));\n<line102>ok = false;\n<line103>}\n<line104>free (descriptors);\n<line105>if (pipe_check)\n<line106>free (out_pollable);\n<line107>return ok;\n<line108>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/src/test.c
========================================
Function: advance
Content: <line0>static void\n<line1>advance (bool f)\n<line2>{\n<line3>++pos;\n<line4>if (f && pos >= argc)\n<line5>beyond ();\n<line6>}
----------------------------------------
Function: unary_advance
Content: <line0>static void\n<line1>unary_advance (void)\n<line2>{\n<line3>advance (true);\n<line4>++pos;\n<line5>}
----------------------------------------
Function: beyond
Content: <line0>static _Noreturn void\n<line1>beyond (void)\n<line2>{\n<line3>test_syntax_error (_("missing argument after %s"), quote (argv[argc - 1]));\n<line4>}
----------------------------------------
Function: find_int
Content: <line0>static char const *\n<line1>find_int (char const *string)\n<line2>{\n<line3>char const *p;\n<line4>char const *number_start;\n<line5>for (p = string; isblank (to_uchar (*p)); p++)\n<line6>continue;\n<line7>if (*p == '+')\n<line8>{\n<line9>p++;\n<line10>number_start = p;\n<line11>}\n<line12>else\n<line13>{\n<line14>number_start = p;\n<line15>p += (*p == '-');\n<line16>}\n<line17>if (ISDIGIT (*p++))\n<line18>{\n<line19>while (ISDIGIT (*p))\n<line20>p++;\n<line21>while (isblank (to_uchar (*p)))\n<line22>p++;\n<line23>if (!*p)\n<line24>return number_start;\n<line25>}\n<line26>test_syntax_error (_("invalid integer %s"), quote (string));\n<line27>}
----------------------------------------
Function: get_mtime
Content: <line0>static bool\n<line1>get_mtime (char const *filename, struct timespec *mtime)\n<line2>{\n<line3>struct stat finfo;\n<line4>bool ok = (stat (filename, &finfo) == 0);\n<line5>if (ok)\n<line6>*mtime = get_stat_mtime (&finfo);\n<line7>return ok;\n<line8>}
----------------------------------------
Function: binop
Content: <line0>static bool\n<line1>binop (char const *s)\n<line2>{\n<line3>return ((STREQ (s,   "=")) || (STREQ (s,  "!=")) || (STREQ (s, "==")) ||\n<line4>(STREQ (s,   "-nt")) ||\n<line5>(STREQ (s, "-ot")) || (STREQ (s, "-ef")) || (STREQ (s, "-eq")) ||\n<line6>(STREQ (s, "-ne")) || (STREQ (s, "-lt")) || (STREQ (s, "-le")) ||\n<line7>(STREQ (s, "-gt")) || (STREQ (s, "-ge")));\n<line8>}
----------------------------------------
Function: term
Content: <line0>static bool\n<line1>term (void)\n<line2>{\n<line3>bool value;\n<line4>bool negated = false;\n<line5>/* Deal with leading 'not's.  */\n<line6>while (pos < argc && argv[pos][0] == '!' && argv[pos][1] == '\0')\n<line7>{\n<line8>advance (true);\n<line9>negated = !negated;\n<line10>}\n<line11>if (pos >= argc)\n<line12>beyond ();\n<line13>/* A paren-bracketed argument. */\n<line14>if (argv[pos][0] == '(' && argv[pos][1] == '\0')\n<line15>{\n<line16>int nargs;\n<line17>advance (true);\n<line18>for (nargs = 1;\n<line19>pos + nargs < argc && ! STREQ (argv[pos + nargs], ")");\n<line20>nargs++)\n<line21>if (nargs == 4)\n<line22>{\n<line23>nargs = argc - pos;\n<line24>break;\n<line25>}\n<line26>value = posixtest (nargs);\n<line27>if (argv[pos] == 0)\n<line28>test_syntax_error (_("%s expected"), quote (")"));\n<line29>else\n<line30>if (argv[pos][0] != ')' || argv[pos][1])\n<line31>test_syntax_error (_("%s expected, found %s"),\n<line32>quote_n (0, ")"), quote_n (1, argv[pos]));\n<line33>advance (false);\n<line34>}\n<line35>/* Are there enough arguments left that this could be dyadic?  */\n<line36>else if (4 <= argc - pos && STREQ (argv[pos], "-l") && binop (argv[pos + 2]))\n<line37>value = binary_operator (true);\n<line38>else if (3 <= argc - pos && binop (argv[pos + 1]))\n<line39>value = binary_operator (false);\n<line40>/* It might be a switch type argument.  */\n<line41>else if (argv[pos][0] == '-' && argv[pos][1] && argv[pos][2] == '\0')\n<line42>value = unary_operator ();\n<line43>else\n<line44>{\n<line45>value = (argv[pos][0] != '\0');\n<line46>advance (false);\n<line47>}\n<line48>return negated ^ value;\n<line49>}
----------------------------------------
Function: binary_operator
Content: <line0>static bool\n<line1>binary_operator (bool l_is_l)\n<line2>{\n<line3>int op;\n<line4>struct stat stat_buf, stat_spare;\n<line5>/* Is the right integer expression of the form '-l string'? */\n<line6>bool r_is_l;\n<line7>if (l_is_l)\n<line8>advance (false);\n<line9>op = pos + 1;\n<line10>if ((op < argc - 2) && STREQ (argv[op + 1], "-l"))\n<line11>{\n<line12>r_is_l = true;\n<line13>advance (false);\n<line14>}\n<line15>else\n<line16>r_is_l = false;\n<line17>if (argv[op][0] == '-')\n<line18>{\n<line19>/* check for eq, nt, and stuff */\n<line20>if ((((argv[op][1] == 'l' || argv[op][1] == 'g')\n<line21>&& (argv[op][2] == 'e' || argv[op][2] == 't'))\n<line22>|| (argv[op][1] == 'e' && argv[op][2] == 'q')\n<line23>|| (argv[op][1] == 'n' && argv[op][2] == 'e'))\n<line24>&& !argv[op][3])\n<line25>{\n<line26>char lbuf[INT_BUFSIZE_BOUND (uintmax_t)];\n<line27>char rbuf[INT_BUFSIZE_BOUND (uintmax_t)];\n<line28>char const *l = (l_is_l\n<line29>? umaxtostr (strlen (argv[op - 1]), lbuf)\n<line30>: find_int (argv[op - 1]));\n<line31>char const *r = (r_is_l\n<line32>? umaxtostr (strlen (argv[op + 2]), rbuf)\n<line33>: find_int (argv[op + 1]));\n<line34>int cmp = strintcmp (l, r);\n<line35>bool xe_operator = (argv[op][2] == 'e');\n<line36>pos += 3;\n<line37>return (argv[op][1] == 'l' ? cmp < xe_operator\n<line38>: argv[op][1] == 'g' ? cmp > - xe_operator\n<line39>: (cmp != 0) == xe_operator);\n<line40>}\n<line41>switch (argv[op][1])\n<line42>{\n<line43>default:\n<line44>break;\n<line45>case 'n':\n<line46>if (argv[op][2] == 't' && !argv[op][3])\n<line47>{\n<line48>/* nt - newer than */\n<line49>struct timespec lt, rt;\n<line50>bool le, re;\n<line51>pos += 3;\n<line52>if (l_is_l || r_is_l)\n<line53>test_syntax_error (_("-nt does not accept -l"));\n<line54>le = get_mtime (argv[op - 1], &lt);\n<line55>re = get_mtime (argv[op + 1], &rt);\n<line56>return le && (!re || timespec_cmp (lt, rt) > 0);\n<line57>}\n<line58>break;\n<line59>case 'e':\n<line60>if (argv[op][2] == 'f' && !argv[op][3])\n<line61>{\n<line62>/* ef - hard link? */\n<line63>pos += 3;\n<line64>if (l_is_l || r_is_l)\n<line65>test_syntax_error (_("-ef does not accept -l"));\n<line66>return (stat (argv[op - 1], &stat_buf) == 0\n<line67>&& stat (argv[op + 1], &stat_spare) == 0\n<line68>&& stat_buf.st_dev == stat_spare.st_dev\n<line69>&& stat_buf.st_ino == stat_spare.st_ino);\n<line70>}\n<line71>break;\n<line72>case 'o':\n<line73>if ('t' == argv[op][2] && '\000' == argv[op][3])\n<line74>{\n<line75>/* ot - older than */\n<line76>struct timespec lt, rt;\n<line77>bool le, re;\n<line78>pos += 3;\n<line79>if (l_is_l || r_is_l)\n<line80>test_syntax_error (_("-ot does not accept -l"));\n<line81>le = get_mtime (argv[op - 1], &lt);\n<line82>re = get_mtime (argv[op + 1], &rt);\n<line83>return re && (!le || timespec_cmp (lt, rt) < 0);\n<line84>}\n<line85>break;\n<line86>}\n<line87>/* FIXME: is this dead code? */\n<line88>test_syntax_error (_("%s: unknown binary operator"), quote (argv[op]));\n<line89>}\n<line90>if (argv[op][0] == '='\n<line91>&& (!argv[op][1] || ((argv[op][1] == '=') && !argv[op][2])))\n<line92>{\n<line93>bool value = STREQ (argv[pos], argv[pos + 2]);\n<line94>pos += 3;\n<line95>return value;\n<line96>}\n<line97>if (STREQ (argv[op], "!="))\n<line98>{\n<line99>bool value = !STREQ (argv[pos], argv[pos + 2]);\n<line100>pos += 3;\n<line101>return value;\n<line102>}\n<line103>/* Not reached.  */\n<line104>affirm (false);\n<line105>}
----------------------------------------
Function: unary_operator
Content: <line0>static bool\n<line1>unary_operator (void)\n<line2>{\n<line3>struct stat stat_buf;\n<line4>switch (argv[pos][1])\n<line5>{\n<line6>default:\n<line7>test_syntax_error (_("%s: unary operator expected"), quote (argv[pos]));\n<line8>/* All of the following unary operators use unary_advance (), which\n<line9>checks to make sure that there is an argument, and then advances\n<line10>pos right past it.  This means that pos - 1 is the location of the\n<line11>argument. */\n<line12>case 'e':			/* file exists in the file system? */\n<line13>unary_advance ();\n<line14>return stat (argv[pos - 1], &stat_buf) == 0;\n<line15>case 'r':			/* file is readable? */\n<line16>unary_advance ();\n<line17>return euidaccess (argv[pos - 1], R_OK) == 0;\n<line18>case 'w':			/* File is writable? */\n<line19>unary_advance ();\n<line20>return euidaccess (argv[pos - 1], W_OK) == 0;\n<line21>case 'x':			/* File is executable? */\n<line22>unary_advance ();\n<line23>return euidaccess (argv[pos - 1], X_OK) == 0;\n<line24>case 'N':  /* File exists and has been modified since it was last read? */\n<line25>{\n<line26>unary_advance ();\n<line27>if (stat (argv[pos - 1], &stat_buf) != 0)\n<line28>return false;\n<line29>struct timespec atime = get_stat_atime (&stat_buf);\n<line30>struct timespec mtime = get_stat_mtime (&stat_buf);\n<line31>return (timespec_cmp (mtime, atime) > 0);\n<line32>}\n<line33>case 'O':			/* File is owned by you? */\n<line34>{\n<line35>unary_advance ();\n<line36>if (stat (argv[pos - 1], &stat_buf) != 0)\n<line37>return false;\n<line38>errno = 0;\n<line39>uid_t euid = geteuid ();\n<line40>uid_t NO_UID = -1;\n<line41>return ! (euid == NO_UID && errno) && euid == stat_buf.st_uid;\n<line42>}\n<line43>case 'G':			/* File is owned by your group? */\n<line44>{\n<line45>unary_advance ();\n<line46>if (stat (argv[pos - 1], &stat_buf) != 0)\n<line47>return false;\n<line48>errno = 0;\n<line49>gid_t egid = getegid ();\n<line50>gid_t NO_GID = -1;\n<line51>return ! (egid == NO_GID && errno) && egid == stat_buf.st_gid;\n<line52>}\n<line53>case 'f':			/* File is a file? */\n<line54>unary_advance ();\n<line55>/* Under POSIX, -f is true if the given file exists\n<line56>and is a regular file. */\n<line57>return (stat (argv[pos - 1], &stat_buf) == 0\n<line58>&& S_ISREG (stat_buf.st_mode));\n<line59>case 'd':			/* File is a directory? */\n<line60>unary_advance ();\n<line61>return (stat (argv[pos - 1], &stat_buf) == 0\n<line62>&& S_ISDIR (stat_buf.st_mode));\n<line63>case 's':			/* File has something in it? */\n<line64>unary_advance ();\n<line65>return (stat (argv[pos - 1], &stat_buf) == 0\n<line66>&& 0 < stat_buf.st_size);\n<line67>case 'S':			/* File is a socket? */\n<line68>unary_advance ();\n<line69>return (stat (argv[pos - 1], &stat_buf) == 0\n<line70>&& S_ISSOCK (stat_buf.st_mode));\n<line71>case 'c':			/* File is character special? */\n<line72>unary_advance ();\n<line73>return (stat (argv[pos - 1], &stat_buf) == 0\n<line74>&& S_ISCHR (stat_buf.st_mode));\n<line75>case 'b':			/* File is block special? */\n<line76>unary_advance ();\n<line77>return (stat (argv[pos - 1], &stat_buf) == 0\n<line78>&& S_ISBLK (stat_buf.st_mode));\n<line79>case 'p':			/* File is a named pipe? */\n<line80>unary_advance ();\n<line81>return (stat (argv[pos - 1], &stat_buf) == 0\n<line82>&& S_ISFIFO (stat_buf.st_mode));\n<line83>case 'L':			/* Same as -h  */\n<line84>/*FALLTHROUGH*/\n<line85>case 'h':			/* File is a symbolic link? */\n<line86>unary_advance ();\n<line87>return (lstat (argv[pos - 1], &stat_buf) == 0\n<line88>&& S_ISLNK (stat_buf.st_mode));\n<line89>case 'u':			/* File is setuid? */\n<line90>unary_advance ();\n<line91>return (stat (argv[pos - 1], &stat_buf) == 0\n<line92>&& (stat_buf.st_mode & S_ISUID));\n<line93>case 'g':			/* File is setgid? */\n<line94>unary_advance ();\n<line95>return (stat (argv[pos - 1], &stat_buf) == 0\n<line96>&& (stat_buf.st_mode & S_ISGID));\n<line97>case 'k':			/* File has sticky bit set? */\n<line98>unary_advance ();\n<line99>return (stat (argv[pos - 1], &stat_buf) == 0\n<line100>&& (stat_buf.st_mode & S_ISVTX));\n<line101>case 't':			/* File (fd) is a terminal? */\n<line102>{\n<line103>long int fd;\n<line104>char const *arg;\n<line105>unary_advance ();\n<line106>arg = find_int (argv[pos - 1]);\n<line107>errno = 0;\n<line108>fd = strtol (arg, nullptr, 10);\n<line109>return (errno != ERANGE && 0 <= fd && fd <= INT_MAX && isatty (fd));\n<line110>}\n<line111>case 'n':			/* True if arg has some length. */\n<line112>unary_advance ();\n<line113>return argv[pos - 1][0] != 0;\n<line114>case 'z':			/* True if arg has no length. */\n<line115>unary_advance ();\n<line116>return argv[pos - 1][0] == '\0';\n<line117>}\n<line118>}
----------------------------------------
Function: and
Content: <line0>static bool\n<line1>and (void)\n<line2>{\n<line3>bool value = true;\n<line4>while (true)\n<line5>{\n<line6>value &= term ();\n<line7>if (! (pos < argc && STREQ (argv[pos], "-a")))\n<line8>return value;\n<line9>advance (false);\n<line10>}\n<line11>}
----------------------------------------
Function: or
Content: <line0>static bool\n<line1>or (void)\n<line2>{\n<line3>bool value = false;\n<line4>while (true)\n<line5>{\n<line6>value |= and ();\n<line7>if (! (pos < argc && STREQ (argv[pos], "-o")))\n<line8>return value;\n<line9>advance (false);\n<line10>}\n<line11>}
----------------------------------------
Function: expr
Content: <line0>static bool\n<line1>expr (void)\n<line2>{\n<line3>if (pos >= argc)\n<line4>beyond ();\n<line5>return or ();		/* Same with this. */\n<line6>}
----------------------------------------
Function: one_argument
Content: <line0>static bool\n<line1>one_argument (void)\n<line2>{\n<line3>return argv[pos++][0] != '\0';\n<line4>}
----------------------------------------
Function: two_arguments
Content: <line0>static bool\n<line1>two_arguments (void)\n<line2>{\n<line3>bool value;\n<line4>if (STREQ (argv[pos], "!"))\n<line5>{\n<line6>advance (false);\n<line7>value = ! one_argument ();\n<line8>}\n<line9>else if (argv[pos][0] == '-'\n<line10>&& argv[pos][1] != '\0'\n<line11>&& argv[pos][2] == '\0')\n<line12>{\n<line13>value = unary_operator ();\n<line14>}\n<line15>else\n<line16>beyond ();\n<line17>return (value);\n<line18>}
----------------------------------------
Function: three_arguments
Content: <line0>static bool\n<line1>three_arguments (void)\n<line2>{\n<line3>bool value;\n<line4>if (binop (argv[pos + 1]))\n<line5>value = binary_operator (false);\n<line6>else if (STREQ (argv[pos], "!"))\n<line7>{\n<line8>advance (true);\n<line9>value = !two_arguments ();\n<line10>}\n<line11>else if (STREQ (argv[pos], "(") && STREQ (argv[pos + 2], ")"))\n<line12>{\n<line13>advance (false);\n<line14>value = one_argument ();\n<line15>advance (false);\n<line16>}\n<line17>else if (STREQ (argv[pos + 1], "-a") || STREQ (argv[pos + 1], "-o"))\n<line18>value = expr ();\n<line19>else\n<line20>test_syntax_error (_("%s: binary operator expected"),\n<line21>quote (argv[pos + 1]));\n<line22>return (value);\n<line23>}
----------------------------------------
Function: posixtest
Content: <line0>static bool\n<line1>posixtest (int nargs)\n<line2>{\n<line3>bool value;\n<line4>switch (nargs)\n<line5>{\n<line6>case 1:\n<line7>value = one_argument ();\n<line8>break;\n<line9>case 2:\n<line10>value = two_arguments ();\n<line11>break;\n<line12>case 3:\n<line13>value = three_arguments ();\n<line14>break;\n<line15>case 4:\n<line16>if (STREQ (argv[pos], "!"))\n<line17>{\n<line18>advance (true);\n<line19>value = !three_arguments ();\n<line20>break;\n<line21>}\n<line22>if (STREQ (argv[pos], "(") && STREQ (argv[pos + 3], ")"))\n<line23>{\n<line24>advance (false);\n<line25>value = two_arguments ();\n<line26>advance (false);\n<line27>break;\n<line28>}\n<line29>FALLTHROUGH;\n<line30>case 5:\n<line31>default:\n<line32>affirm (0 < nargs);\n<line33>value = expr ();\n<line34>}\n<line35>return (value);\n<line36>}
----------------------------------------
Function: usage
Content: <line0>void\n<line1>usage (int status)\n<line2>{\n<line3>if (status != EXIT_SUCCESS)\n<line4>emit_try_help ();\n<line5>else\n<line6>{\n<line7>fputs (_("\\n<line8>Usage: test EXPRESSION\n\\n<line9>or:  test\n\\n<line10>or:  [ EXPRESSION ]\n\\n<line11>or:  [ ]\n\\n<line12>or:  [ OPTION\n\\n<line13>"), stdout);\n<line14>fputs (_("\\n<line15>Exit with the status determined by EXPRESSION.\n\\n<line16>\n\\n<line17>"), stdout);\n<line18>fputs (HELP_OPTION_DESCRIPTION, stdout);\n<line19>fputs (VERSION_OPTION_DESCRIPTION, stdout);\n<line20>fputs (_("\\n<line21>\n\\n<line22>An omitted EXPRESSION defaults to false.  Otherwise,\n\\n<line23>EXPRESSION is true or false and sets exit status.  It is one of:\n\\n<line24>"), stdout);\n<line25>fputs (_("\\n<line26>\n\\n<line27>( EXPRESSION )               EXPRESSION is true\n\\n<line28>! EXPRESSION                 EXPRESSION is false\n\\n<line29>EXPRESSION1 -a EXPRESSION2   both EXPRESSION1 and EXPRESSION2 are true\n\\n<line30>EXPRESSION1 -o EXPRESSION2   either EXPRESSION1 or EXPRESSION2 is true\n\\n<line31>"), stdout);\n<line32>fputs (_("\\n<line33>\n\\n<line34>-n STRING            the length of STRING is nonzero\n\\n<line35>STRING               equivalent to -n STRING\n\\n<line36>-z STRING            the length of STRING is zero\n\\n<line37>STRING1 = STRING2    the strings are equal\n\\n<line38>STRING1 != STRING2   the strings are not equal\n\\n<line39>"), stdout);\n<line40>fputs (_("\\n<line41>\n\\n<line42>INTEGER1 -eq INTEGER2   INTEGER1 is equal to INTEGER2\n\\n<line43>INTEGER1 -ge INTEGER2   INTEGER1 is greater than or equal to INTEGER2\n\\n<line44>INTEGER1 -gt INTEGER2   INTEGER1 is greater than INTEGER2\n\\n<line45>INTEGER1 -le INTEGER2   INTEGER1 is less than or equal to INTEGER2\n\\n<line46>INTEGER1 -lt INTEGER2   INTEGER1 is less than INTEGER2\n\\n<line47>INTEGER1 -ne INTEGER2   INTEGER1 is not equal to INTEGER2\n\\n<line48>"), stdout);\n<line49>fputs (_("\\n<line50>\n\\n<line51>FILE1 -ef FILE2   FILE1 and FILE2 have the same device and inode numbers\n\\n<line52>FILE1 -nt FILE2   FILE1 is newer (modification date) than FILE2\n\\n<line53>FILE1 -ot FILE2   FILE1 is older than FILE2\n\\n<line54>"), stdout);\n<line55>fputs (_("\\n<line56>\n\\n<line57>-b FILE     FILE exists and is block special\n\\n<line58>-c FILE     FILE exists and is character special\n\\n<line59>-d FILE     FILE exists and is a directory\n\\n<line60>-e FILE     FILE exists\n\\n<line61>"), stdout);\n<line62>fputs (_("\\n<line63>-f FILE     FILE exists and is a regular file\n\\n<line64>-g FILE     FILE exists and is set-group-ID\n\\n<line65>-G FILE     FILE exists and is owned by the effective group ID\n\\n<line66>-h FILE     FILE exists and is a symbolic link (same as -L)\n\\n<line67>-k FILE     FILE exists and has its sticky bit set\n\\n<line68>"), stdout);\n<line69>fputs (_("\\n<line70>-L FILE     FILE exists and is a symbolic link (same as -h)\n\\n<line71>-N FILE     FILE exists and has been modified since it was last read\n\\n<line72>-O FILE     FILE exists and is owned by the effective user ID\n\\n<line73>-p FILE     FILE exists and is a named pipe\n\\n<line74>-r FILE     FILE exists and the user has read access\n\\n<line75>-s FILE     FILE exists and has a size greater than zero\n\\n<line76>"), stdout);\n<line77>fputs (_("\\n<line78>-S FILE     FILE exists and is a socket\n\\n<line79>-t FD       file descriptor FD is opened on a terminal\n\\n<line80>-u FILE     FILE exists and its set-user-ID bit is set\n\\n<line81>-w FILE     FILE exists and the user has write access\n\\n<line82>-x FILE     FILE exists and the user has execute (or search) access\n\\n<line83>"), stdout);\n<line84>fputs (_("\\n<line85>\n\\n<line86>Except for -h and -L, all FILE-related tests dereference symbolic links.\n\\n<line87>Beware that parentheses need to be escaped (e.g., by backslashes) for shells.\n\\n<line88>INTEGER may also be -l STRING, which evaluates to the length of STRING.\n\\n<line89>"), stdout);\n<line90>fputs (_("\\n<line91>\n\\n<line92>NOTE: Binary -a and -o are inherently ambiguous.  Use 'test EXPR1 && test\n\\n<line93>EXPR2' or 'test EXPR1 || test EXPR2' instead.\n\\n<line94>"), stdout);\n<line95>fputs (_("\\n<line96>\n\\n<line97>NOTE: [ honors the --help and --version options, but test does not.\n\\n<line98>test treats each of those as it treats any other nonempty STRING.\n\\n<line99>"), stdout);\n<line100>printf (USAGE_BUILTIN_WARNING, _("test and/or ["));\n<line101>emit_ancillary_info (PROGRAM_NAME);\n<line102>}\n<line103>exit (status);\n<line104>}
----------------------------------------
Function: main
Content: <line0>int\n<line1>main (int margc, char **margv)\n<line2>{\n<line3>bool value;\n<line4>#if !defined TEST_STANDALONE\n<line5>int code;\n<line6>code = setjmp (test_exit_buf);\n<line7>if (code)\n<line8>return (test_error_return);\n<line9>#else /* TEST_STANDALONE */\n<line10>initialize_main (&margc, &margv);\n<line11>set_program_name (margv[0]);\n<line12>setlocale (LC_ALL, "");\n<line13>bindtextdomain (PACKAGE, LOCALEDIR);\n<line14>textdomain (PACKAGE);\n<line15>initialize_exit_failure (TEST_FAILURE);\n<line16>atexit (close_stdout);\n<line17>#endif /* TEST_STANDALONE */\n<line18>argv = margv;\n<line19>if (LBRACKET)\n<line20>{\n<line21>/* Recognize --help or --version, but only when invoked in the\n<line22>"[" form, when the last argument is not "]".  Use direct\n<line23>parsing, rather than parse_long_options, to avoid accepting\n<line24>abbreviations.  POSIX allows "[ --help" and "[ --version" to\n<line25>have the usual GNU behavior, but it requires "test --help"\n<line26>and "test --version" to exit silently with status 0.  */\n<line27>if (margc == 2)\n<line28>{\n<line29>if (STREQ (margv[1], "--help"))\n<line30>usage (EXIT_SUCCESS);\n<line31>if (STREQ (margv[1], "--version"))\n<line32>{\n<line33>version_etc (stdout, PROGRAM_NAME, PACKAGE_NAME, Version, AUTHORS,\n<line34>(char *) nullptr);\n<line35>test_main_return (EXIT_SUCCESS);\n<line36>}\n<line37>}\n<line38>if (margc < 2 || !STREQ (margv[margc - 1], "]"))\n<line39>test_syntax_error (_("missing %s"), quote ("]"));\n<line40>--margc;\n<line41>}\n<line42>argc = margc;\n<line43>pos = 1;\n<line44>if (pos >= argc)\n<line45>test_main_return (TEST_FALSE);\n<line46>value = posixtest (argc - 1);\n<line47>if (pos != argc)\n<line48>test_syntax_error (_("extra argument %s"), quote (argv[pos]));\n<line49>test_main_return (value ? TEST_TRUE : TEST_FALSE);\n<line50>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/src/touch.c
========================================
Function: date_relative
Content: <line0>static struct timespec\n<line1>date_relative (char const *flex_date, struct timespec now)\n<line2>{\n<line3>struct timespec result;\n<line4>if (! parse_datetime (&result, flex_date, &now))\n<line5>error (EXIT_FAILURE, 0, _("invalid date format %s"), quote (flex_date));\n<line6>return result;\n<line7>}
----------------------------------------
Function: touch
Content: <line0>static bool\n<line1>touch (char const *file)\n<line2>{\n<line3>int fd = -1;\n<line4>int open_errno = 0;\n<line5>struct timespec const *t = newtime;\n<line6>if (STREQ (file, "-"))\n<line7>fd = STDOUT_FILENO;\n<line8>else if (! (no_create || no_dereference))\n<line9>{\n<line10>/* Try to open FILE, creating it if necessary.  */\n<line11>fd = fd_reopen (STDIN_FILENO, file,\n<line12>O_WRONLY | O_CREAT | O_NONBLOCK | O_NOCTTY, MODE_RW_UGO);\n<line13>if (fd < 0)\n<line14>open_errno = errno;\n<line15>}\n<line16>if (change_times != (CH_ATIME | CH_MTIME))\n<line17>{\n<line18>/* We're setting only one of the time values.  */\n<line19>if (change_times == CH_MTIME)\n<line20>newtime[0].tv_nsec = UTIME_OMIT;\n<line21>else\n<line22>{\n<line23>affirm (change_times == CH_ATIME);\n<line24>newtime[1].tv_nsec = UTIME_OMIT;\n<line25>}\n<line26>}\n<line27>if (amtime_now)\n<line28>{\n<line29>/* Pass nullptr to futimens so it will not fail if we have\n<line30>write access to the file, but don't own it.  */\n<line31>t = nullptr;\n<line32>}\n<line33>char const *file_opt = fd == STDOUT_FILENO ? nullptr : file;\n<line34>int atflag = no_dereference ? AT_SYMLINK_NOFOLLOW : 0;\n<line35>int utime_errno = (fdutimensat (fd, AT_FDCWD, file_opt, t, atflag) == 0\n<line36>? 0 : errno);\n<line37>if (fd == STDIN_FILENO)\n<line38>{\n<line39>if (close (STDIN_FILENO) != 0)\n<line40>{\n<line41>error (0, errno, _("failed to close %s"), quoteaf (file));\n<line42>return false;\n<line43>}\n<line44>}\n<line45>else if (fd == STDOUT_FILENO)\n<line46>{\n<line47>/* Do not diagnose "touch -c - >&-".  */\n<line48>if (utime_errno == EBADF && no_create)\n<line49>return true;\n<line50>}\n<line51>if (utime_errno != 0)\n<line52>{\n<line53>/* Don't diagnose with open_errno if FILE is a directory, as that\n<line54>would give a bogus diagnostic for e.g., 'touch /' (assuming we\n<line55>don't own / or have write access).  On Solaris 10 and probably\n<line56>other systems, opening a directory like "." fails with EINVAL.\n<line57>(On SunOS 4 it was EPERM but that's obsolete.)  */\n<line58>struct stat st;\n<line59>if (open_errno\n<line60>&& ! (open_errno == EISDIR\n<line61>|| (open_errno == EINVAL\n<line62>&& stat (file, &st) == 0 && S_ISDIR (st.st_mode))))\n<line63>{\n<line64>/* The wording of this diagnostic should cover at least two cases:\n<line65>- the file does not exist, but the parent directory is unwritable\n<line66>- the file exists, but it isn't writable\n<line67>I think it's not worth trying to distinguish them.  */\n<line68>error (0, open_errno, _("cannot touch %s"), quoteaf (file));\n<line69>}\n<line70>else\n<line71>{\n<line72>if (no_create && utime_errno == ENOENT)\n<line73>return true;\n<line74>error (0, utime_errno, _("setting times of %s"), quoteaf (file));\n<line75>}\n<line76>return false;\n<line77>}\n<line78>return true;\n<line79>}
----------------------------------------
Function: usage
Content: <line0>void\n<line1>usage (int status)\n<line2>{\n<line3>if (status != EXIT_SUCCESS)\n<line4>emit_try_help ();\n<line5>else\n<line6>{\n<line7>printf (_("Usage: %s [OPTION]... FILE...\n"), program_name);\n<line8>fputs (_("\\n<line9>Update the access and modification times of each FILE to the current time.\n\\n<line10>\n\\n<line11>A FILE argument that does not exist is created empty, unless -c or -h\n\\n<line12>is supplied.\n\\n<line13>\n\\n<line14>A FILE argument string of - is handled specially and causes touch to\n\\n<line15>change the times of the file associated with standard output.\n\\n<line16>"), stdout);\n<line17>emit_mandatory_arg_note ();\n<line18>fputs (_("\\n<line19>-a                     change only the access time\n\\n<line20>-c, --no-create        do not create any files\n\\n<line21>-d, --date=STRING      parse STRING and use it instead of current time\n\\n<line22>-f                     (ignored)\n\\n<line23>"), stdout);\n<line24>fputs (_("\\n<line25>-h, --no-dereference   affect each symbolic link instead of any referenced\n\\n<line26>file (useful only on systems that can change the\n\\n<line27>timestamps of a symlink)\n\\n<line28>-m                     change only the modification time\n\\n<line29>"), stdout);\n<line30>fputs (_("\\n<line31>-r, --reference=FILE   use this file's times instead of current time\n\\n<line32>-t STAMP               use [[CC]YY]MMDDhhmm[.ss] instead of current time\n\\n<line33>--time=WORD        change the specified time:\n\\n<line34>WORD is access, atime, or use: equivalent to -a\n\\n<line35>WORD is modify or mtime: equivalent to -m\n\\n<line36>"), stdout);\n<line37>fputs (HELP_OPTION_DESCRIPTION, stdout);\n<line38>fputs (VERSION_OPTION_DESCRIPTION, stdout);\n<line39>fputs (_("\\n<line40>\n\\n<line41>Note that the -d and -t options accept different time-date formats.\n\\n<line42>"), stdout);\n<line43>emit_ancillary_info (PROGRAM_NAME);\n<line44>}\n<line45>exit (status);\n<line46>}
----------------------------------------
Function: main
Content: <line0>int\n<line1>main (int argc, char **argv)\n<line2>{\n<line3>int c;\n<line4>bool date_set = false;\n<line5>bool ok = true;\n<line6>char const *flex_date = nullptr;\n<line7>initialize_main (&argc, &argv);\n<line8>set_program_name (argv[0]);\n<line9>setlocale (LC_ALL, "");\n<line10>bindtextdomain (PACKAGE, LOCALEDIR);\n<line11>textdomain (PACKAGE);\n<line12>atexit (close_stdout);\n<line13>change_times = 0;\n<line14>no_create = use_ref = false;\n<line15>while ((c = getopt_long (argc, argv, "acd:fhmr:t:", longopts, nullptr)) != -1)\n<line16>{\n<line17>switch (c)\n<line18>{\n<line19>case 'a':\n<line20>change_times |= CH_ATIME;\n<line21>break;\n<line22>case 'c':\n<line23>no_create = true;\n<line24>break;\n<line25>case 'd':\n<line26>flex_date = optarg;\n<line27>break;\n<line28>case 'f':\n<line29>break;\n<line30>case 'h':\n<line31>no_dereference = true;\n<line32>break;\n<line33>case 'm':\n<line34>change_times |= CH_MTIME;\n<line35>break;\n<line36>case 'r':\n<line37>use_ref = true;\n<line38>ref_file = optarg;\n<line39>break;\n<line40>case 't':\n<line41>if (! posixtime (&newtime[0].tv_sec, optarg,\n<line42>PDS_LEADING_YEAR | PDS_CENTURY | PDS_SECONDS))\n<line43>error (EXIT_FAILURE, 0, _("invalid date format %s"),\n<line44>quote (optarg));\n<line45>newtime[0].tv_nsec = 0;\n<line46>newtime[1] = newtime[0];\n<line47>date_set = true;\n<line48>break;\n<line49>case TIME_OPTION:	/* --time */\n<line50>change_times |= XARGMATCH ("--time", optarg,\n<line51>time_args, time_masks);\n<line52>break;\n<line53>case_GETOPT_HELP_CHAR;\n<line54>case_GETOPT_VERSION_CHAR (PROGRAM_NAME, AUTHORS);\n<line55>default:\n<line56>usage (EXIT_FAILURE);\n<line57>}\n<line58>}\n<line59>if (change_times == 0)\n<line60>change_times = CH_ATIME | CH_MTIME;\n<line61>if (date_set && (use_ref || flex_date))\n<line62>{\n<line63>error (0, 0, _("cannot specify times from more than one source"));\n<line64>usage (EXIT_FAILURE);\n<line65>}\n<line66>if (use_ref)\n<line67>{\n<line68>struct stat ref_stats;\n<line69>/* Don't use (no_dereference?lstat:stat) (args), since stat\n<line70>might be an object-like macro.  */\n<line71>if (no_dereference ? lstat (ref_file, &ref_stats)\n<line72>: stat (ref_file, &ref_stats))\n<line73>error (EXIT_FAILURE, errno,\n<line74>_("failed to get attributes of %s"), quoteaf (ref_file));\n<line75>newtime[0] = get_stat_atime (&ref_stats);\n<line76>newtime[1] = get_stat_mtime (&ref_stats);\n<line77>date_set = true;\n<line78>if (flex_date)\n<line79>{\n<line80>if (change_times & CH_ATIME)\n<line81>newtime[0] = date_relative (flex_date, newtime[0]);\n<line82>if (change_times & CH_MTIME)\n<line83>newtime[1] = date_relative (flex_date, newtime[1]);\n<line84>}\n<line85>}\n<line86>else\n<line87>{\n<line88>if (flex_date)\n<line89>{\n<line90>struct timespec now = current_timespec ();\n<line91>newtime[1] = newtime[0] = date_relative (flex_date, now);\n<line92>date_set = true;\n<line93>/* If neither -a nor -m is specified, treat "-d now" as if\n<line94>it were absent; this lets "touch" succeed more often in\n<line95>the presence of restrictive permissions.  */\n<line96>if (change_times == (CH_ATIME | CH_MTIME)\n<line97>&& newtime[0].tv_sec == now.tv_sec\n<line98>&& newtime[0].tv_nsec == now.tv_nsec)\n<line99>{\n<line100>/* Check that it really was "-d now", and not a timestamp\n<line101>that just happens to be the current time.  */\n<line102>struct timespec notnow, notnow1;\n<line103>notnow.tv_sec = now.tv_sec ^ 1;\n<line104>notnow.tv_nsec = now.tv_nsec;\n<line105>notnow1 = date_relative (flex_date, notnow);\n<line106>if (notnow1.tv_sec == notnow.tv_sec\n<line107>&& notnow1.tv_nsec == notnow.tv_nsec)\n<line108>date_set = false;\n<line109>}\n<line110>}\n<line111>}\n<line112>/* The obsolete 'MMDDhhmm[YY]' form is valid IFF there are\n<line113>two or more non-option arguments.  */\n<line114>if (!date_set && 2 <= argc - optind && posix2_version () < 200112\n<line115>&& posixtime (&newtime[0].tv_sec, argv[optind],\n<line116>PDS_TRAILING_YEAR | PDS_PRE_2000))\n<line117>{\n<line118>newtime[0].tv_nsec = 0;\n<line119>newtime[1] = newtime[0];\n<line120>date_set = true;\n<line121>if (! getenv ("POSIXLY_CORRECT"))\n<line122>{\n<line123>struct tm const *tm = localtime (&newtime[0].tv_sec);\n<line124>/* Technically, it appears that even a deliberate attempt to cause\n<line125>the above localtime to return nullptr will always fail because our\n<line126>posixtime implementation rejects all dates for which localtime\n<line127>would fail.  However, skip the warning if it ever fails.  */\n<line128>if (tm)\n<line129>error (0, 0,\n<line130>_("warning: 'touch %s' is obsolete; use "\n<line131>"'touch -t %04ld%02d%02d%02d%02d.%02d'"),\n<line132>argv[optind],\n<line133>tm->tm_year + 1900L, tm->tm_mon + 1, tm->tm_mday,\n<line134>tm->tm_hour, tm->tm_min, tm->tm_sec);\n<line135>}\n<line136>optind++;\n<line137>}\n<line138>if (!date_set)\n<line139>{\n<line140>if (change_times == (CH_ATIME | CH_MTIME))\n<line141>amtime_now = true;\n<line142>else\n<line143>newtime[1].tv_nsec = newtime[0].tv_nsec = UTIME_NOW;\n<line144>}\n<line145>if (optind == argc)\n<line146>{\n<line147>error (0, 0, _("missing file operand"));\n<line148>usage (EXIT_FAILURE);\n<line149>}\n<line150>for (; optind < argc; ++optind)\n<line151>ok &= touch (argv[optind]);\n<line152>return ok ? EXIT_SUCCESS : EXIT_FAILURE;\n<line153>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/src/tr.c
========================================
Function: es_match
Content: <line0>static inline bool\n<line1>es_match (struct E_string const *es, size_t i, char c)\n<line2>{\n<line3>return es->s[i] == c && !es->escaped[i];\n<line4>}
----------------------------------------
Function: usage
Content: <line0>void\n<line1>usage (int status)\n<line2>{\n<line3>if (status != EXIT_SUCCESS)\n<line4>emit_try_help ();\n<line5>else\n<line6>{\n<line7>printf (_("\\n<line8>Usage: %s [OPTION]... STRING1 [STRING2]\n\\n<line9>"),\n<line10>program_name);\n<line11>fputs (_("\\n<line12>Translate, squeeze, and/or delete characters from standard input,\n\\n<line13>writing to standard output.  STRING1 and STRING2 specify arrays of\n\\n<line14>characters ARRAY1 and ARRAY2 that control the action.\n\\n<line15>\n\\n<line16>-c, -C, --complement    use the complement of ARRAY1\n\\n<line17>-d, --delete            delete characters in ARRAY1, do not translate\n\\n<line18>-s, --squeeze-repeats   replace each sequence of a repeated character\n\\n<line19>that is listed in the last specified ARRAY,\n\\n<line20>with a single occurrence of that character\n\\n<line21>-t, --truncate-set1     first truncate ARRAY1 to length of ARRAY2\n\\n<line22>"), stdout);\n<line23>fputs (HELP_OPTION_DESCRIPTION, stdout);\n<line24>fputs (VERSION_OPTION_DESCRIPTION, stdout);\n<line25>fputs (_("\\n<line26>\n\\n<line27>ARRAYs are specified as strings of characters.  Most represent themselves.\n\\n<line28>Interpreted sequences are:\n\\n<line29>\n\\n<line30>\\NNN            character with octal value NNN (1 to 3 octal digits)\n\\n<line31>\\\\              backslash\n\\n<line32>\\a              audible BEL\n\\n<line33>\\b              backspace\n\\n<line34>\\f              form feed\n\\n<line35>\\n              new line\n\\n<line36>\\r              return\n\\n<line37>\\t              horizontal tab\n\\n<line38>"), stdout);\n<line39>fputs (_("\\n<line40>\\v              vertical tab\n\\n<line41>CHAR1-CHAR2     all characters from CHAR1 to CHAR2 in ascending order\n\\n<line42>[CHAR*]         in ARRAY2, copies of CHAR until length of ARRAY1\n\\n<line43>[CHAR*REPEAT]   REPEAT copies of CHAR, REPEAT octal if starting with 0\n\\n<line44>[:alnum:]       all letters and digits\n\\n<line45>[:alpha:]       all letters\n\\n<line46>[:blank:]       all horizontal whitespace\n\\n<line47>[:cntrl:]       all control characters\n\\n<line48>[:digit:]       all digits\n\\n<line49>"), stdout);\n<line50>fputs (_("\\n<line51>[:graph:]       all printable characters, not including space\n\\n<line52>[:lower:]       all lower case letters\n\\n<line53>[:print:]       all printable characters, including space\n\\n<line54>[:punct:]       all punctuation characters\n\\n<line55>[:space:]       all horizontal or vertical whitespace\n\\n<line56>[:upper:]       all upper case letters\n\\n<line57>[:xdigit:]      all hexadecimal digits\n\\n<line58>[=CHAR=]        all characters which are equivalent to CHAR\n\\n<line59>"), stdout);\n<line60>fputs (_("\\n<line61>\n\\n<line62>Translation occurs if -d is not given and both STRING1 and STRING2 appear.\n\\n<line63>-t is only significant when translating.  ARRAY2 is extended to length of\n\\n<line64>ARRAY1 by repeating its last character as necessary.  Excess characters\n\\n<line65>of ARRAY2 are ignored.  Character classes expand in unspecified order;\n\\n<line66>while translating, [:lower:] and [:upper:] may be used in pairs to\n\\n<line67>specify case conversion.  Squeezing occurs after translation or deletion.\n\\n<line68>"), stdout);\n<line69>emit_ancillary_info (PROGRAM_NAME);\n<line70>}\n<line71>exit (status);\n<line72>}
----------------------------------------
Function: is_equiv_class_member
Content: <line0>static inline bool\n<line1>is_equiv_class_member (unsigned char equiv_class, unsigned char c)\n<line2>{\n<line3>return (equiv_class == c);\n<line4>}
----------------------------------------
Function: es_free
Content: <line0>static void\n<line1>es_free (struct E_string *es)\n<line2>{\n<line3>free (es->s);\n<line4>free (es->escaped);\n<line5>}
----------------------------------------
Function: unquote
Content: <line0>static bool\n<line1>unquote (char const *s, struct E_string *es)\n<line2>{\n<line3>size_t len = strlen (s);\n<line4>es->s = xmalloc (len);\n<line5>es->escaped = xcalloc (len, sizeof es->escaped[0]);\n<line6>unsigned int j = 0;\n<line7>for (unsigned int i = 0; s[i]; i++)\n<line8>{\n<line9>unsigned char c;\n<line10>int oct_digit;\n<line11>switch (s[i])\n<line12>{\n<line13>case '\\':\n<line14>es->escaped[j] = true;\n<line15>switch (s[i + 1])\n<line16>{\n<line17>case '\\':\n<line18>c = '\\';\n<line19>break;\n<line20>case 'a':\n<line21>c = '\a';\n<line22>break;\n<line23>case 'b':\n<line24>c = '\b';\n<line25>break;\n<line26>case 'f':\n<line27>c = '\f';\n<line28>break;\n<line29>case 'n':\n<line30>c = '\n';\n<line31>break;\n<line32>case 'r':\n<line33>c = '\r';\n<line34>break;\n<line35>case 't':\n<line36>c = '\t';\n<line37>break;\n<line38>case 'v':\n<line39>c = '\v';\n<line40>break;\n<line41>case '0':\n<line42>case '1':\n<line43>case '2':\n<line44>case '3':\n<line45>case '4':\n<line46>case '5':\n<line47>case '6':\n<line48>case '7':\n<line49>c = s[i + 1] - '0';\n<line50>oct_digit = s[i + 2] - '0';\n<line51>if (0 <= oct_digit && oct_digit <= 7)\n<line52>{\n<line53>c = 8 * c + oct_digit;\n<line54>++i;\n<line55>oct_digit = s[i + 2] - '0';\n<line56>if (0 <= oct_digit && oct_digit <= 7)\n<line57>{\n<line58>if (8 * c + oct_digit < N_CHARS)\n<line59>{\n<line60>c = 8 * c + oct_digit;\n<line61>++i;\n<line62>}\n<line63>else\n<line64>{\n<line65>/* A 3-digit octal number larger than \377 won't\n<line66>fit in 8 bits.  So we stop when adding the\n<line67>next digit would put us over the limit and\n<line68>give a warning about the ambiguity.  POSIX\n<line69>isn't clear on this, and we interpret this\n<line70>lack of clarity as meaning the resulting behavior\n<line71>is undefined, which means we're allowed to issue\n<line72>a warning.  */\n<line73>error (0, 0, _("warning: the ambiguous octal escape\\n<line74>\\%c%c%c is being\n\tinterpreted as the 2-byte sequence \\0%c%c, %c"),\n<line75>s[i], s[i + 1], s[i + 2],\n<line76>s[i], s[i + 1], s[i + 2]);\n<line77>}\n<line78>}\n<line79>}\n<line80>break;\n<line81>case '\0':\n<line82>error (0, 0, _("warning: an unescaped backslash "\n<line83>"at end of string is not portable"));\n<line84>/* POSIX is not clear about this.  */\n<line85>es->escaped[j] = false;\n<line86>i--;\n<line87>c = '\\';\n<line88>break;\n<line89>default:\n<line90>c = s[i + 1];\n<line91>break;\n<line92>}\n<line93>++i;\n<line94>es->s[j++] = c;\n<line95>break;\n<line96>default:\n<line97>es->s[j++] = s[i];\n<line98>break;\n<line99>}\n<line100>}\n<line101>es->len = j;\n<line102>return true;\n<line103>}
----------------------------------------
Function: make_printable_char
Content: <line0>static char *\n<line1>make_printable_char (unsigned char c)\n<line2>{\n<line3>char *buf = xmalloc (5);\n<line4>if (isprint (c))\n<line5>{\n<line6>buf[0] = c;\n<line7>buf[1] = '\0';\n<line8>}\n<line9>else\n<line10>{\n<line11>sprintf (buf, "\\%03o", c);\n<line12>}\n<line13>return buf;\n<line14>}
----------------------------------------
Function: make_printable_str
Content: <line0>static char *\n<line1>make_printable_str (char const *s, size_t len)\n<line2>{\n<line3>/* Worst case is that every character expands to a backslash\n<line4>followed by a 3-character octal escape sequence.  */\n<line5>char *printable_buf = xnmalloc (len + 1, 4);\n<line6>char *p = printable_buf;\n<line7>for (size_t i = 0; i < len; i++)\n<line8>{\n<line9>char buf[5];\n<line10>char const *tmp = nullptr;\n<line11>unsigned char c = s[i];\n<line12>switch (c)\n<line13>{\n<line14>case '\\':\n<line15>tmp = "\\";\n<line16>break;\n<line17>case '\a':\n<line18>tmp = "\\a";\n<line19>break;\n<line20>case '\b':\n<line21>tmp = "\\b";\n<line22>break;\n<line23>case '\f':\n<line24>tmp = "\\f";\n<line25>break;\n<line26>case '\n':\n<line27>tmp = "\\n";\n<line28>break;\n<line29>case '\r':\n<line30>tmp = "\\r";\n<line31>break;\n<line32>case '\t':\n<line33>tmp = "\\t";\n<line34>break;\n<line35>case '\v':\n<line36>tmp = "\\v";\n<line37>break;\n<line38>default:\n<line39>if (isprint (c))\n<line40>{\n<line41>buf[0] = c;\n<line42>buf[1] = '\0';\n<line43>}\n<line44>else\n<line45>sprintf (buf, "\\%03o", c);\n<line46>tmp = buf;\n<line47>break;\n<line48>}\n<line49>p = stpcpy (p, tmp);\n<line50>}\n<line51>return printable_buf;\n<line52>}
----------------------------------------
Function: append_normal_char
Content: <line0>static void\n<line1>append_normal_char (struct Spec_list *list, unsigned char c)\n<line2>{\n<line3>struct List_element *new = xmalloc (sizeof *new);\n<line4>new->next = nullptr;\n<line5>new->type = RE_NORMAL_CHAR;\n<line6>new->u.normal_char = c;\n<line7>list->tail->next = new;\n<line8>list->tail = new;\n<line9>}
----------------------------------------
Function: append_range
Content: <line0>static bool\n<line1>append_range (struct Spec_list *list, unsigned char first, unsigned char last)\n<line2>{\n<line3>if (last < first)\n<line4>{\n<line5>char *tmp1 = make_printable_char (first);\n<line6>char *tmp2 = make_printable_char (last);\n<line7>error (0, 0,\n<line8>_("range-endpoints of '%s-%s' are in reverse collating sequence order"),\n<line9>tmp1, tmp2);\n<line10>free (tmp1);\n<line11>free (tmp2);\n<line12>return false;\n<line13>}\n<line14>struct List_element *new = xmalloc (sizeof *new);\n<line15>new->next = nullptr;\n<line16>new->type = RE_RANGE;\n<line17>new->u.range.first_char = first;\n<line18>new->u.range.last_char = last;\n<line19>list->tail->next = new;\n<line20>list->tail = new;\n<line21>return true;\n<line22>}
----------------------------------------
Function: append_char_class
Content: <line0>static bool\n<line1>append_char_class (struct Spec_list *list,\n<line2>char const *char_class_str, size_t len)\n<line3>{\n<line4>enum Char_class char_class = look_up_char_class (char_class_str, len);\n<line5>if (char_class == CC_NO_CLASS)\n<line6>return false;\n<line7>struct List_element *new = xmalloc (sizeof *new);\n<line8>new->next = nullptr;\n<line9>new->type = RE_CHAR_CLASS;\n<line10>new->u.char_class = char_class;\n<line11>list->tail->next = new;\n<line12>list->tail = new;\n<line13>return true;\n<line14>}
----------------------------------------
Function: append_repeated_char
Content: <line0>static void\n<line1>append_repeated_char (struct Spec_list *list, unsigned char the_char,\n<line2>count repeat_count)\n<line3>{\n<line4>struct List_element *new = xmalloc (sizeof *new);\n<line5>new->next = nullptr;\n<line6>new->type = RE_REPEATED_CHAR;\n<line7>new->u.repeated_char.the_repeated_char = the_char;\n<line8>new->u.repeated_char.repeat_count = repeat_count;\n<line9>list->tail->next = new;\n<line10>list->tail = new;\n<line11>}
----------------------------------------
Function: append_equiv_class
Content: <line0>static bool\n<line1>append_equiv_class (struct Spec_list *list,\n<line2>char const *equiv_class_str, size_t len)\n<line3>{\n<line4>if (len != 1)\n<line5>return false;\n<line6>struct List_element *new = xmalloc (sizeof *new);\n<line7>new->next = nullptr;\n<line8>new->type = RE_EQUIV_CLASS;\n<line9>new->u.equiv_code = *equiv_class_str;\n<line10>list->tail->next = new;\n<line11>list->tail = new;\n<line12>return true;\n<line13>}
----------------------------------------
Function: find_closing_delim
Content: <line0>static bool\n<line1>find_closing_delim (const struct E_string *es, size_t start_idx,\n<line2>char pre_bracket_char, size_t *result_idx)\n<line3>{\n<line4>for (size_t i = start_idx; i < es->len - 1; i++)\n<line5>if (es->s[i] == pre_bracket_char && es->s[i + 1] == ']'\n<line6>&& !es->escaped[i] && !es->escaped[i + 1])\n<line7>{\n<line8>*result_idx = i;\n<line9>return true;\n<line10>}\n<line11>return false;\n<line12>}
----------------------------------------
Function: find_bracketed_repeat
Content: <line0>static int\n<line1>find_bracketed_repeat (const struct E_string *es, size_t start_idx,\n<line2>unsigned char *char_to_repeat, count *repeat_count,\n<line3>size_t *closing_bracket_idx)\n<line4>{\n<line5>affirm (start_idx + 1 < es->len);\n<line6>if (!es_match (es, start_idx + 1, '*'))\n<line7>return -1;\n<line8>for (size_t i = start_idx + 2; i < es->len && !es->escaped[i]; i++)\n<line9>{\n<line10>if (es->s[i] == ']')\n<line11>{\n<line12>size_t digit_str_len = i - start_idx - 2;\n<line13>*char_to_repeat = es->s[start_idx];\n<line14>if (digit_str_len == 0)\n<line15>{\n<line16>/* We've matched [c*] -- no explicit repeat count.  */\n<line17>*repeat_count = 0;\n<line18>}\n<line19>else\n<line20>{\n<line21>/* Here, we have found [c*s] where s should be a string\n<line22>of octal (if it starts with '0') or decimal digits.  */\n<line23>char const *digit_str = &es->s[start_idx + 2];\n<line24>char *d_end;\n<line25>if ((xstrtoumax (digit_str, &d_end, *digit_str == '0' ? 8 : 10,\n<line26>repeat_count, nullptr)\n<line27>!= LONGINT_OK)\n<line28>|| REPEAT_COUNT_MAXIMUM < *repeat_count\n<line29>|| digit_str + digit_str_len != d_end)\n<line30>{\n<line31>char *tmp = make_printable_str (digit_str, digit_str_len);\n<line32>error (0, 0,\n<line33>_("invalid repeat count %s in [c*n] construct"),\n<line34>quote (tmp));\n<line35>free (tmp);\n<line36>return -2;\n<line37>}\n<line38>}\n<line39>*closing_bracket_idx = i;\n<line40>return 0;\n<line41>}\n<line42>}\n<line43>return -1;			/* No bracket found.  */\n<line44>}
----------------------------------------
Function: build_spec_list
Content: <line0>static bool\n<line1>build_spec_list (const struct E_string *es, struct Spec_list *result)\n<line2>{\n<line3>char const *p = es->s;\n<line4>/* The main for-loop below recognizes the 4 multi-character constructs.\n<line5>A character that matches (in its context) none of the multi-character\n<line6>constructs is classified as 'normal'.  Since all multi-character\n<line7>constructs have at least 3 characters, any strings of length 2 or\n<line8>less are composed solely of normal characters.  Hence, the index of\n<line9>the outer for-loop runs only as far as LEN-2.  */\n<line10>size_t i;\n<line11>for (i = 0; i + 2 < es->len; /* empty */)\n<line12>{\n<line13>if (es_match (es, i, '['))\n<line14>{\n<line15>bool matched_multi_char_construct;\n<line16>size_t closing_bracket_idx;\n<line17>unsigned char char_to_repeat;\n<line18>count repeat_count;\n<line19>int err;\n<line20>matched_multi_char_construct = true;\n<line21>if (es_match (es, i + 1, ':') || es_match (es, i + 1, '='))\n<line22>{\n<line23>size_t closing_delim_idx;\n<line24>if (find_closing_delim (es, i + 2, p[i + 1], &closing_delim_idx))\n<line25>{\n<line26>size_t opnd_str_len = closing_delim_idx - 1 - (i + 2) + 1;\n<line27>char const *opnd_str = p + i + 2;\n<line28>if (opnd_str_len == 0)\n<line29>{\n<line30>if (p[i + 1] == ':')\n<line31>error (0, 0, _("missing character class name '[::]'"));\n<line32>else\n<line33>error (0, 0,\n<line34>_("missing equivalence class character '[==]'"));\n<line35>return false;\n<line36>}\n<line37>if (p[i + 1] == ':')\n<line38>{\n<line39>/* FIXME: big comment.  */\n<line40>if (!append_char_class (result, opnd_str, opnd_str_len))\n<line41>{\n<line42>if (star_digits_closebracket (es, i + 2))\n<line43>goto try_bracketed_repeat;\n<line44>else\n<line45>{\n<line46>char *tmp = make_printable_str (opnd_str,\n<line47>opnd_str_len);\n<line48>error (0, 0, _("invalid character class %s"),\n<line49>quote (tmp));\n<line50>free (tmp);\n<line51>return false;\n<line52>}\n<line53>}\n<line54>}\n<line55>else\n<line56>{\n<line57>/* FIXME: big comment.  */\n<line58>if (!append_equiv_class (result, opnd_str, opnd_str_len))\n<line59>{\n<line60>if (star_digits_closebracket (es, i + 2))\n<line61>goto try_bracketed_repeat;\n<line62>else\n<line63>{\n<line64>char *tmp = make_printable_str (opnd_str,\n<line65>opnd_str_len);\n<line66>error (0, 0,\n<line67>_("%s: equivalence class operand must be a single character"),\n<line68>tmp);\n<line69>free (tmp);\n<line70>return false;\n<line71>}\n<line72>}\n<line73>}\n<line74>i = closing_delim_idx + 2;\n<line75>continue;\n<line76>}\n<line77>/* Else fall through.  This could be [:*] or [=*].  */\n<line78>}\n<line79>try_bracketed_repeat:\n<line80>/* Determine whether this is a bracketed repeat range\n<line81>matching the RE \[.\*(dec_or_oct_number)?].  */\n<line82>err = find_bracketed_repeat (es, i + 1, &char_to_repeat,\n<line83>&repeat_count,\n<line84>&closing_bracket_idx);\n<line85>if (err == 0)\n<line86>{\n<line87>append_repeated_char (result, char_to_repeat, repeat_count);\n<line88>i = closing_bracket_idx + 1;\n<line89>}\n<line90>else if (err == -1)\n<line91>{\n<line92>matched_multi_char_construct = false;\n<line93>}\n<line94>else\n<line95>{\n<line96>/* Found a string that looked like [c*n] but the\n<line97>numeric part was invalid.  */\n<line98>return false;\n<line99>}\n<line100>if (matched_multi_char_construct)\n<line101>continue;\n<line102>/* We reach this point if P does not match [:str:], [=c=],\n<line103>[c*n], or [c*].  Now, see if P looks like a range '[-c'\n<line104>(from '[' to 'c').  */\n<line105>}\n<line106>/* Look ahead one char for ranges like a-z.  */\n<line107>if (es_match (es, i + 1, '-'))\n<line108>{\n<line109>if (!append_range (result, p[i], p[i + 2]))\n<line110>return false;\n<line111>i += 3;\n<line112>}\n<line113>else\n<line114>{\n<line115>append_normal_char (result, p[i]);\n<line116>++i;\n<line117>}\n<line118>}\n<line119>/* Now handle the (2 or fewer) remaining characters p[i]..p[es->len - 1].  */\n<line120>for (; i < es->len; i++)\n<line121>append_normal_char (result, p[i]);\n<line122>return true;\n<line123>}
----------------------------------------
Function: skip_construct
Content: <line0>static void\n<line1>skip_construct (struct Spec_list *s)\n<line2>{\n<line3>s->tail = s->tail->next;\n<line4>s->state = NEW_ELEMENT;\n<line5>}
----------------------------------------
Function: get_next
Content: <line0>static int\n<line1>get_next (struct Spec_list *s, enum Upper_Lower_class *class)\n<line2>{\n<line3>struct List_element *p;\n<line4>int return_val;\n<line5>int i;\n<line6>if (class)\n<line7>*class = UL_NONE;\n<line8>if (s->state == BEGIN_STATE)\n<line9>{\n<line10>s->tail = s->head->next;\n<line11>s->state = NEW_ELEMENT;\n<line12>}\n<line13>p = s->tail;\n<line14>if (p == nullptr)\n<line15>return -1;\n<line16>switch (p->type)\n<line17>{\n<line18>case RE_NORMAL_CHAR:\n<line19>return_val = p->u.normal_char;\n<line20>s->state = NEW_ELEMENT;\n<line21>s->tail = p->next;\n<line22>break;\n<line23>case RE_RANGE:\n<line24>if (s->state == NEW_ELEMENT)\n<line25>s->state = p->u.range.first_char;\n<line26>else\n<line27>++(s->state);\n<line28>return_val = s->state;\n<line29>if (s->state == p->u.range.last_char)\n<line30>{\n<line31>s->tail = p->next;\n<line32>s->state = NEW_ELEMENT;\n<line33>}\n<line34>break;\n<line35>case RE_CHAR_CLASS:\n<line36>if (class)\n<line37>{\n<line38>switch (p->u.char_class)\n<line39>{\n<line40>case CC_LOWER:\n<line41>*class = UL_LOWER;\n<line42>break;\n<line43>case CC_UPPER:\n<line44>*class = UL_UPPER;\n<line45>break;\n<line46>default:\n<line47>break;\n<line48>}\n<line49>}\n<line50>if (s->state == NEW_ELEMENT)\n<line51>{\n<line52>for (i = 0; i < N_CHARS; i++)\n<line53>if (is_char_class_member (p->u.char_class, i))\n<line54>break;\n<line55>affirm (i < N_CHARS);\n<line56>s->state = i;\n<line57>}\n<line58>assure (is_char_class_member (p->u.char_class, s->state));\n<line59>return_val = s->state;\n<line60>for (i = s->state + 1; i < N_CHARS; i++)\n<line61>if (is_char_class_member (p->u.char_class, i))\n<line62>break;\n<line63>if (i < N_CHARS)\n<line64>s->state = i;\n<line65>else\n<line66>{\n<line67>s->tail = p->next;\n<line68>s->state = NEW_ELEMENT;\n<line69>}\n<line70>break;\n<line71>case RE_EQUIV_CLASS:\n<line72>/* FIXME: this assumes that each character is alone in its own\n<line73>equivalence class (which appears to be correct for my\n<line74>LC_COLLATE.  But I don't know of any function that allows\n<line75>one to determine a character's equivalence class.  */\n<line76>return_val = p->u.equiv_code;\n<line77>s->state = NEW_ELEMENT;\n<line78>s->tail = p->next;\n<line79>break;\n<line80>case RE_REPEATED_CHAR:\n<line81>/* Here, a repeat count of n == 0 means don't repeat at all.  */\n<line82>if (p->u.repeated_char.repeat_count == 0)\n<line83>{\n<line84>s->tail = p->next;\n<line85>s->state = NEW_ELEMENT;\n<line86>return_val = get_next (s, class);\n<line87>}\n<line88>else\n<line89>{\n<line90>if (s->state == NEW_ELEMENT)\n<line91>{\n<line92>s->state = 0;\n<line93>}\n<line94>++(s->state);\n<line95>return_val = p->u.repeated_char.the_repeated_char;\n<line96>if (s->state == p->u.repeated_char.repeat_count)\n<line97>{\n<line98>s->tail = p->next;\n<line99>s->state = NEW_ELEMENT;\n<line100>}\n<line101>}\n<line102>break;\n<line103>default:\n<line104>unreachable ();\n<line105>}\n<line106>return return_val;\n<line107>}
----------------------------------------
Function: card_of_complement
Content: <line0>static int\n<line1>card_of_complement (struct Spec_list *s)\n<line2>{\n<line3>int c;\n<line4>int cardinality = N_CHARS;\n<line5>bool in_set[N_CHARS] = { 0, };\n<line6>s->state = BEGIN_STATE;\n<line7>while ((c = get_next (s, nullptr)) != -1)\n<line8>{\n<line9>cardinality -= (!in_set[c]);\n<line10>in_set[c] = true;\n<line11>}\n<line12>return cardinality;\n<line13>}
----------------------------------------
Function: validate_case_classes
Content: <line0>static void\n<line1>validate_case_classes (struct Spec_list *s1, struct Spec_list *s2)\n<line2>{\n<line3>size_t n_upper = 0;\n<line4>size_t n_lower = 0;\n<line5>int c1 = 0;\n<line6>int c2 = 0;\n<line7>MAYBE_UNUSED count old_s1_len = s1->length, old_s2_len = s2->length;\n<line8>struct List_element *s1_tail = s1->tail;\n<line9>struct List_element *s2_tail = s2->tail;\n<line10>bool s1_new_element = true;\n<line11>bool s2_new_element = true;\n<line12>if (complement || !s2->has_char_class)\n<line13>return;\n<line14>for (int i = 0; i < N_CHARS; i++)\n<line15>{\n<line16>if (isupper (i))\n<line17>n_upper++;\n<line18>if (islower (i))\n<line19>n_lower++;\n<line20>}\n<line21>s1->state = BEGIN_STATE;\n<line22>s2->state = BEGIN_STATE;\n<line23>while (c1 != -1 && c2 != -1)\n<line24>{\n<line25>enum Upper_Lower_class class_s1, class_s2;\n<line26>c1 = get_next (s1, &class_s1);\n<line27>c2 = get_next (s2, &class_s2);\n<line28>/* If c2 transitions to a new case class, then\n<line29>c1 must also transition at the same time.  */\n<line30>if (s2_new_element && class_s2 != UL_NONE\n<line31>&& !(s1_new_element && class_s1 != UL_NONE))\n<line32>error (EXIT_FAILURE, 0,\n<line33>_("misaligned [:upper:] and/or [:lower:] construct"));\n<line34>/* If case converting, quickly skip over the elements.  */\n<line35>if (class_s2 != UL_NONE)\n<line36>{\n<line37>skip_construct (s1);\n<line38>skip_construct (s2);\n<line39>/* Discount insignificant/problematic lengths.  */\n<line40>s1->length -= (class_s1 == UL_UPPER ? n_upper : n_lower) - 1;\n<line41>s2->length -= (class_s2 == UL_UPPER ? n_upper : n_lower) - 1;\n<line42>}\n<line43>s1_new_element = s1->state == NEW_ELEMENT; /* Next element is new.  */\n<line44>s2_new_element = s2->state == NEW_ELEMENT; /* Next element is new.  */\n<line45>}\n<line46>affirm (old_s1_len >= s1->length && old_s2_len >= s2->length);\n<line47>s1->tail = s1_tail;\n<line48>s2->tail = s2_tail;\n<line49>}
----------------------------------------
Function: get_spec_stats
Content: <line0>static void\n<line1>get_spec_stats (struct Spec_list *s)\n<line2>{\n<line3>struct List_element *p;\n<line4>count length = 0;\n<line5>s->n_indefinite_repeats = 0;\n<line6>s->has_equiv_class = false;\n<line7>s->has_restricted_char_class = false;\n<line8>s->has_char_class = false;\n<line9>for (p = s->head->next; p; p = p->next)\n<line10>{\n<line11>count len = 0;\n<line12>count new_length;\n<line13>switch (p->type)\n<line14>{\n<line15>case RE_NORMAL_CHAR:\n<line16>len = 1;\n<line17>break;\n<line18>case RE_RANGE:\n<line19>affirm (p->u.range.last_char >= p->u.range.first_char);\n<line20>len = p->u.range.last_char - p->u.range.first_char + 1;\n<line21>break;\n<line22>case RE_CHAR_CLASS:\n<line23>s->has_char_class = true;\n<line24>for (int i = 0; i < N_CHARS; i++)\n<line25>if (is_char_class_member (p->u.char_class, i))\n<line26>++len;\n<line27>switch (p->u.char_class)\n<line28>{\n<line29>case CC_UPPER:\n<line30>case CC_LOWER:\n<line31>break;\n<line32>default:\n<line33>s->has_restricted_char_class = true;\n<line34>break;\n<line35>}\n<line36>break;\n<line37>case RE_EQUIV_CLASS:\n<line38>for (int i = 0; i < N_CHARS; i++)\n<line39>if (is_equiv_class_member (p->u.equiv_code, i))\n<line40>++len;\n<line41>s->has_equiv_class = true;\n<line42>break;\n<line43>case RE_REPEATED_CHAR:\n<line44>if (p->u.repeated_char.repeat_count > 0)\n<line45>len = p->u.repeated_char.repeat_count;\n<line46>else\n<line47>{\n<line48>s->indefinite_repeat_element = p;\n<line49>++(s->n_indefinite_repeats);\n<line50>}\n<line51>break;\n<line52>default:\n<line53>unreachable ();\n<line54>}\n<line55>/* Check for arithmetic overflow in computing length.  Also, reject\n<line56>any length greater than the maximum repeat count, in case the\n<line57>length is later used to compute the repeat count for an\n<line58>indefinite element.  */\n<line59>new_length = length + len;\n<line60>if (! (length <= new_length && new_length <= REPEAT_COUNT_MAXIMUM))\n<line61>error (EXIT_FAILURE, 0, _("too many characters in set"));\n<line62>length = new_length;\n<line63>}\n<line64>s->length = length;\n<line65>}
----------------------------------------
Function: get_s1_spec_stats
Content: <line0>static void\n<line1>get_s1_spec_stats (struct Spec_list *s1)\n<line2>{\n<line3>get_spec_stats (s1);\n<line4>if (complement)\n<line5>s1->length = card_of_complement (s1);\n<line6>}
----------------------------------------
Function: get_s2_spec_stats
Content: <line0>static void\n<line1>get_s2_spec_stats (struct Spec_list *s2, count len_s1)\n<line2>{\n<line3>get_spec_stats (s2);\n<line4>if (len_s1 >= s2->length && s2->n_indefinite_repeats == 1)\n<line5>{\n<line6>s2->indefinite_repeat_element->u.repeated_char.repeat_count =\n<line7>len_s1 - s2->length;\n<line8>s2->length = len_s1;\n<line9>}\n<line10>}
----------------------------------------
Function: spec_init
Content: <line0>static void\n<line1>spec_init (struct Spec_list *spec_list)\n<line2>{\n<line3>struct List_element *new = xmalloc (sizeof *new);\n<line4>spec_list->head = spec_list->tail = new;\n<line5>spec_list->head->next = nullptr;\n<line6>}
----------------------------------------
Function: parse_str
Content: <line0>static bool\n<line1>parse_str (char const *s, struct Spec_list *spec_list)\n<line2>{\n<line3>struct E_string es;\n<line4>bool ok = unquote (s, &es) && build_spec_list (&es, spec_list);\n<line5>es_free (&es);\n<line6>return ok;\n<line7>}
----------------------------------------
Function: string2_extend
Content: <line0>static void\n<line1>string2_extend (const struct Spec_list *s1, struct Spec_list *s2)\n<line2>{\n<line3>struct List_element *p;\n<line4>unsigned char char_to_repeat;\n<line5>affirm (translating);\n<line6>affirm (s1->length > s2->length);\n<line7>affirm (s2->length > 0);\n<line8>p = s2->tail;\n<line9>switch (p->type)\n<line10>{\n<line11>case RE_NORMAL_CHAR:\n<line12>char_to_repeat = p->u.normal_char;\n<line13>break;\n<line14>case RE_RANGE:\n<line15>char_to_repeat = p->u.range.last_char;\n<line16>break;\n<line17>case RE_CHAR_CLASS:\n<line18>/* Note BSD allows extending of classes in string2.  For example:\n<line19>tr '[:upper:]0-9' '[:lower:]'\n<line20>That's not portable however, contradicts POSIX and is dependent\n<line21>on your collating sequence.  */\n<line22>error (EXIT_FAILURE, 0,\n<line23>_("when translating with string1 longer than string2,\n"\n<line24>"the latter string must not end with a character class"));\n<line25>case RE_REPEATED_CHAR:\n<line26>char_to_repeat = p->u.repeated_char.the_repeated_char;\n<line27>break;\n<line28>case RE_EQUIV_CLASS:\n<line29>/* This shouldn't happen, because validate exits with an error\n<line30>if it finds an equiv class in string2 when translating.  */\n<line31>affirm (false);\n<line32>default:\n<line33>unreachable ();\n<line34>}\n<line35>append_repeated_char (s2, char_to_repeat, s1->length - s2->length);\n<line36>s2->length = s1->length;\n<line37>}
----------------------------------------
Function: homogeneous_spec_list
Content: <line0>static bool\n<line1>homogeneous_spec_list (struct Spec_list *s)\n<line2>{\n<line3>int b, c;\n<line4>s->state = BEGIN_STATE;\n<line5>if ((b = get_next (s, nullptr)) == -1)\n<line6>return false;\n<line7>while ((c = get_next (s, nullptr)) != -1)\n<line8>if (c != b)\n<line9>return false;\n<line10>return true;\n<line11>}
----------------------------------------
Function: validate
Content: <line0>static void\n<line1>validate (struct Spec_list *s1, struct Spec_list *s2)\n<line2>{\n<line3>get_s1_spec_stats (s1);\n<line4>if (s1->n_indefinite_repeats > 0)\n<line5>error (EXIT_FAILURE, 0,\n<line6>_("the [c*] repeat construct may not appear in string1"));\n<line7>if (s2)\n<line8>{\n<line9>get_s2_spec_stats (s2, s1->length);\n<line10>if (s2->n_indefinite_repeats > 1)\n<line11>error (EXIT_FAILURE, 0,\n<line12>_("only one [c*] repeat construct may appear in string2"));\n<line13>if (translating)\n<line14>{\n<line15>if (s2->has_equiv_class)\n<line16>error (EXIT_FAILURE, 0,\n<line17>_("[=c=] expressions may not appear in string2"\n<line18>" when translating"));\n<line19>if (s2->has_restricted_char_class)\n<line20>error (EXIT_FAILURE, 0,\n<line21>_("when translating, the only character classes"\n<line22>" that may appear in\n"\n<line23>"string2 are 'upper' and 'lower'"));\n<line24>validate_case_classes (s1, s2);\n<line25>if (s1->length > s2->length)\n<line26>{\n<line27>if (!truncate_set1)\n<line28>{\n<line29>/* string2 must be non-empty unless --truncate-set1 is\n<line30>given or string1 is empty.  */\n<line31>if (s2->length == 0)\n<line32>error (EXIT_FAILURE, 0,\n<line33>_("when not truncating set1,"\n<line34>" string2 must be non-empty"));\n<line35>string2_extend (s1, s2);\n<line36>}\n<line37>}\n<line38>if (complement && s1->has_char_class\n<line39>&& ! (s2->length == s1->length && homogeneous_spec_list (s2)))\n<line40>error (EXIT_FAILURE, 0,\n<line41>_("when translating with complemented character classes,\n"\n<line42>"string2 must map all characters in the domain to one"));\n<line43>}\n<line44>else\n<line45>/* Not translating.  */\n<line46>{\n<line47>if (s2->n_indefinite_repeats > 0)\n<line48>error (EXIT_FAILURE, 0,\n<line49>_("the [c*] construct may appear in string2"\n<line50>" only when translating"));\n<line51>}\n<line52>}\n<line53>}
----------------------------------------
Function: squeeze_filter
Content: <line0>static void\n<line1>squeeze_filter (char *buf, size_t size, size_t (*reader) (char *, size_t))\n<line2>{\n<line3>/* A value distinct from any character that may have been stored in a\n<line4>buffer as the result of a block-read in the function squeeze_filter.  */\n<line5>const int NOT_A_CHAR = INT_MAX;\n<line6>int char_to_squeeze = NOT_A_CHAR;\n<line7>size_t i = 0;\n<line8>size_t nr = 0;\n<line9>while (true)\n<line10>{\n<line11>if (i >= nr)\n<line12>{\n<line13>nr = reader (buf, size);\n<line14>if (nr == 0)\n<line15>break;\n<line16>i = 0;\n<line17>}\n<line18>size_t begin = i;\n<line19>if (char_to_squeeze == NOT_A_CHAR)\n<line20>{\n<line21>size_t out_len;\n<line22>/* Here, by being a little tricky, we can get a significant\n<line23>performance increase in most cases when the input is\n<line24>reasonably large.  Since tr will modify the input only\n<line25>if two consecutive (and identical) input characters are\n<line26>in the squeeze set, we can step by two through the data\n<line27>when searching for a character in the squeeze set.  This\n<line28>means there may be a little more work in a few cases and\n<line29>perhaps twice as much work in the worst cases where most\n<line30>of the input is removed by squeezing repeats.  But most\n<line31>uses of this functionality seem to remove less than 20-30%\n<line32>of the input.  */\n<line33>for (; i < nr && !in_squeeze_set[to_uchar (buf[i])]; i += 2)\n<line34>continue;\n<line35>/* There is a special case when i == nr and we've just\n<line36>skipped a character (the last one in buf) that is in\n<line37>the squeeze set.  */\n<line38>if (i == nr && in_squeeze_set[to_uchar (buf[i - 1])])\n<line39>--i;\n<line40>if (i >= nr)\n<line41>out_len = nr - begin;\n<line42>else\n<line43>{\n<line44>char_to_squeeze = buf[i];\n<line45>/* We're about to output buf[begin..i].  */\n<line46>out_len = i - begin + 1;\n<line47>/* But since we stepped by 2 in the loop above,\n<line48>out_len may be one too large.  */\n<line49>if (i > 0 && buf[i - 1] == char_to_squeeze)\n<line50>--out_len;\n<line51>/* Advance i to the index of first character to be\n<line52>considered when looking for a char different from\n<line53>char_to_squeeze.  */\n<line54>++i;\n<line55>}\n<line56>if (out_len > 0\n<line57>&& fwrite (&buf[begin], 1, out_len, stdout) != out_len)\n<line58>write_error ();\n<line59>}\n<line60>if (char_to_squeeze != NOT_A_CHAR)\n<line61>{\n<line62>/* Advance i to index of first char != char_to_squeeze\n<line63>(or to nr if all the rest of the characters in this\n<line64>buffer are the same as char_to_squeeze).  */\n<line65>for (; i < nr && buf[i] == char_to_squeeze; i++)\n<line66>continue;\n<line67>if (i < nr)\n<line68>char_to_squeeze = NOT_A_CHAR;\n<line69>/* If (i >= nr) we've squeezed the last character in this buffer.\n<line70>So now we have to read a new buffer and continue comparing\n<line71>characters against char_to_squeeze.  */\n<line72>}\n<line73>}\n<line74>}
----------------------------------------
Function: plain_read
Content: <line0>static size_t\n<line1>plain_read (char *buf, size_t size)\n<line2>{\n<line3>size_t nr = safe_read (STDIN_FILENO, buf, size);\n<line4>if (nr == SAFE_READ_ERROR)\n<line5>error (EXIT_FAILURE, errno, _("read error"));\n<line6>return nr;\n<line7>}
----------------------------------------
Function: read_and_delete
Content: <line0>static size_t\n<line1>read_and_delete (char *buf, size_t size)\n<line2>{\n<line3>size_t n_saved;\n<line4>/* This enclosing do-while loop is to make sure that\n<line5>we don't return zero (indicating EOF) when we've\n<line6>just deleted all the characters in a buffer.  */\n<line7>do\n<line8>{\n<line9>size_t nr = plain_read (buf, size);\n<line10>if (nr == 0)\n<line11>return 0;\n<line12>/* This first loop may be a waste of code, but gives much\n<line13>better performance when no characters are deleted in\n<line14>the beginning of a buffer.  It just avoids the copying\n<line15>of buf[i] into buf[n_saved] when it would be a NOP.  */\n<line16>size_t i;\n<line17>for (i = 0; i < nr && !in_delete_set[to_uchar (buf[i])]; i++)\n<line18>continue;\n<line19>n_saved = i;\n<line20>for (++i; i < nr; i++)\n<line21>if (!in_delete_set[to_uchar (buf[i])])\n<line22>buf[n_saved++] = buf[i];\n<line23>}\n<line24>while (n_saved == 0);\n<line25>return n_saved;\n<line26>}
----------------------------------------
Function: read_and_xlate
Content: <line0>static size_t\n<line1>read_and_xlate (char *buf, size_t size)\n<line2>{\n<line3>size_t bytes_read = plain_read (buf, size);\n<line4>for (size_t i = 0; i < bytes_read; i++)\n<line5>buf[i] = xlate[to_uchar (buf[i])];\n<line6>return bytes_read;\n<line7>}
----------------------------------------
Function: set_initialize
Content: <line0>static void\n<line1>set_initialize (struct Spec_list *s, bool complement_this_set, bool *in_set)\n<line2>{\n<line3>int c;\n<line4>s->state = BEGIN_STATE;\n<line5>while ((c = get_next (s, nullptr)) != -1)\n<line6>in_set[c] = true;\n<line7>if (complement_this_set)\n<line8>for (size_t i = 0; i < N_CHARS; i++)\n<line9>in_set[i] = (!in_set[i]);\n<line10>}
----------------------------------------
Function: main
Content: <line0>int\n<line1>main (int argc, char **argv)\n<line2>{\n<line3>int c;\n<line4>int non_option_args;\n<line5>int min_operands;\n<line6>int max_operands;\n<line7>struct Spec_list buf1, buf2;\n<line8>struct Spec_list *s1 = &buf1;\n<line9>struct Spec_list *s2 = &buf2;\n<line10>initialize_main (&argc, &argv);\n<line11>set_program_name (argv[0]);\n<line12>setlocale (LC_ALL, "");\n<line13>bindtextdomain (PACKAGE, LOCALEDIR);\n<line14>textdomain (PACKAGE);\n<line15>atexit (close_stdout);\n<line16>while ((c = getopt_long (argc, argv, "+AcCdst", long_options, nullptr)) != -1)\n<line17>{\n<line18>switch (c)\n<line19>{\n<line20>case 'A':\n<line21>/* Undocumented option, for compatibility with AIX.  */\n<line22>setlocale (LC_COLLATE, "C");\n<line23>setlocale (LC_CTYPE, "C");\n<line24>break;\n<line25>case 'c':\n<line26>case 'C':\n<line27>complement = true;\n<line28>break;\n<line29>case 'd':\n<line30>delete = true;\n<line31>break;\n<line32>case 's':\n<line33>squeeze_repeats = true;\n<line34>break;\n<line35>case 't':\n<line36>truncate_set1 = true;\n<line37>break;\n<line38>case_GETOPT_HELP_CHAR;\n<line39>case_GETOPT_VERSION_CHAR (PROGRAM_NAME, AUTHORS);\n<line40>default:\n<line41>usage (EXIT_FAILURE);\n<line42>break;\n<line43>}\n<line44>}\n<line45>non_option_args = argc - optind;\n<line46>translating = (non_option_args == 2 && !delete);\n<line47>min_operands = 1 + (delete == squeeze_repeats);\n<line48>max_operands = 1 + (delete <= squeeze_repeats);\n<line49>if (non_option_args < min_operands)\n<line50>{\n<line51>if (non_option_args == 0)\n<line52>error (0, 0, _("missing operand"));\n<line53>else\n<line54>{\n<line55>error (0, 0, _("missing operand after %s"), quote (argv[argc - 1]));\n<line56>fprintf (stderr, "%s\n",\n<line57>_(squeeze_repeats\n<line58>? N_("Two strings must be given when "\n<line59>"both deleting and squeezing repeats.")\n<line60>: N_("Two strings must be given when translating.")));\n<line61>}\n<line62>usage (EXIT_FAILURE);\n<line63>}\n<line64>if (max_operands < non_option_args)\n<line65>{\n<line66>error (0, 0, _("extra operand %s"), quote (argv[optind + max_operands]));\n<line67>if (non_option_args == 2)\n<line68>fprintf (stderr, "%s\n",\n<line69>_("Only one string may be given when "\n<line70>"deleting without squeezing repeats."));\n<line71>usage (EXIT_FAILURE);\n<line72>}\n<line73>spec_init (s1);\n<line74>if (!parse_str (argv[optind], s1))\n<line75>main_exit (EXIT_FAILURE);\n<line76>if (non_option_args == 2)\n<line77>{\n<line78>spec_init (s2);\n<line79>if (!parse_str (argv[optind + 1], s2))\n<line80>main_exit (EXIT_FAILURE);\n<line81>}\n<line82>else\n<line83>s2 = nullptr;\n<line84>validate (s1, s2);\n<line85>/* Use binary I/O, since 'tr' is sometimes used to transliterate\n<line86>non-printable characters, or characters which are stripped away\n<line87>by text-mode reads (like CR and ^Z).  */\n<line88>xset_binary_mode (STDIN_FILENO, O_BINARY);\n<line89>xset_binary_mode (STDOUT_FILENO, O_BINARY);\n<line90>fadvise (stdin, FADVISE_SEQUENTIAL);\n<line91>if (squeeze_repeats && non_option_args == 1)\n<line92>{\n<line93>set_initialize (s1, complement, in_squeeze_set);\n<line94>squeeze_filter (io_buf, sizeof io_buf, plain_read);\n<line95>}\n<line96>else if (delete && non_option_args == 1)\n<line97>{\n<line98>set_initialize (s1, complement, in_delete_set);\n<line99>while (true)\n<line100>{\n<line101>size_t nr = read_and_delete (io_buf, sizeof io_buf);\n<line102>if (nr == 0)\n<line103>break;\n<line104>if (fwrite (io_buf, 1, nr, stdout) != nr)\n<line105>write_error ();\n<line106>}\n<line107>}\n<line108>else if (squeeze_repeats && delete && non_option_args == 2)\n<line109>{\n<line110>set_initialize (s1, complement, in_delete_set);\n<line111>set_initialize (s2, false, in_squeeze_set);\n<line112>squeeze_filter (io_buf, sizeof io_buf, read_and_delete);\n<line113>}\n<line114>else if (translating)\n<line115>{\n<line116>if (complement)\n<line117>{\n<line118>bool *in_s1 = in_delete_set;\n<line119>set_initialize (s1, false, in_s1);\n<line120>s2->state = BEGIN_STATE;\n<line121>for (int i = 0; i < N_CHARS; i++)\n<line122>xlate[i] = i;\n<line123>for (int i = 0; i < N_CHARS; i++)\n<line124>{\n<line125>if (!in_s1[i])\n<line126>{\n<line127>int ch = get_next (s2, nullptr);\n<line128>affirm (ch != -1 || truncate_set1);\n<line129>if (ch == -1)\n<line130>{\n<line131>/* This will happen when tr is invoked like e.g.\n<line132>tr -cs A-Za-z0-9 '\012'.  */\n<line133>break;\n<line134>}\n<line135>xlate[i] = ch;\n<line136>}\n<line137>}\n<line138>}\n<line139>else\n<line140>{\n<line141>int c1, c2;\n<line142>enum Upper_Lower_class class_s1;\n<line143>enum Upper_Lower_class class_s2;\n<line144>for (int i = 0; i < N_CHARS; i++)\n<line145>xlate[i] = i;\n<line146>s1->state = BEGIN_STATE;\n<line147>s2->state = BEGIN_STATE;\n<line148>while (true)\n<line149>{\n<line150>c1 = get_next (s1, &class_s1);\n<line151>c2 = get_next (s2, &class_s2);\n<line152>if (class_s1 == UL_LOWER && class_s2 == UL_UPPER)\n<line153>{\n<line154>for (int i = 0; i < N_CHARS; i++)\n<line155>if (islower (i))\n<line156>xlate[i] = toupper (i);\n<line157>}\n<line158>else if (class_s1 == UL_UPPER && class_s2 == UL_LOWER)\n<line159>{\n<line160>for (int i = 0; i < N_CHARS; i++)\n<line161>if (isupper (i))\n<line162>xlate[i] = tolower (i);\n<line163>}\n<line164>else\n<line165>{\n<line166>/* The following should have been checked by validate...  */\n<line167>if (c1 == -1 || c2 == -1)\n<line168>break;\n<line169>xlate[c1] = c2;\n<line170>}\n<line171>/* When case-converting, skip the elements as an optimization.  */\n<line172>if (class_s2 != UL_NONE)\n<line173>{\n<line174>skip_construct (s1);\n<line175>skip_construct (s2);\n<line176>}\n<line177>}\n<line178>affirm (c1 == -1 || truncate_set1);\n<line179>}\n<line180>if (squeeze_repeats)\n<line181>{\n<line182>set_initialize (s2, false, in_squeeze_set);\n<line183>squeeze_filter (io_buf, sizeof io_buf, read_and_xlate);\n<line184>}\n<line185>else\n<line186>{\n<line187>while (true)\n<line188>{\n<line189>size_t bytes_read = read_and_xlate (io_buf, sizeof io_buf);\n<line190>if (bytes_read == 0)\n<line191>break;\n<line192>if (fwrite (io_buf, 1, bytes_read, stdout) != bytes_read)\n<line193>write_error ();\n<line194>}\n<line195>}\n<line196>}\n<line197>if (close (STDIN_FILENO) != 0)\n<line198>error (EXIT_FAILURE, errno, _("standard input"));\n<line199>main_exit (EXIT_SUCCESS);\n<line200>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/src/true.c
========================================
Function: usage
Content: <line0>void\n<line1>usage (int status)\n<line2>{\n<line3>printf (_("\\n<line4>Usage: %s [ignored command line arguments]\n\\n<line5>or:  %s OPTION\n\\n<line6>"),\n<line7>program_name, program_name);\n<line8>printf ("%s\n\n",\n<line9>_(EXIT_STATUS == EXIT_SUCCESS\n<line10>? N_("Exit with a status code indicating success.")\n<line11>: N_("Exit with a status code indicating failure.")));\n<line12>fputs (HELP_OPTION_DESCRIPTION, stdout);\n<line13>fputs (VERSION_OPTION_DESCRIPTION, stdout);\n<line14>printf (USAGE_BUILTIN_WARNING, PROGRAM_NAME);\n<line15>emit_ancillary_info (PROGRAM_NAME);\n<line16>exit (status);\n<line17>}
----------------------------------------
Function: main
Content: <line0>int\n<line1>main (int argc, char **argv)\n<line2>{\n<line3>/* Recognize --help or --version only if it's the only command-line\n<line4>argument.  */\n<line5>if (argc == 2)\n<line6>{\n<line7>initialize_main (&argc, &argv);\n<line8>set_program_name (argv[0]);\n<line9>setlocale (LC_ALL, "");\n<line10>bindtextdomain (PACKAGE, LOCALEDIR);\n<line11>textdomain (PACKAGE);\n<line12>/* Note true(1) will return EXIT_FAILURE in the\n<line13>edge case where writes fail with GNU specific options.  */\n<line14>atexit (close_stdout);\n<line15>if (STREQ (argv[1], "--help"))\n<line16>usage (EXIT_STATUS);\n<line17>if (STREQ (argv[1], "--version"))\n<line18>version_etc (stdout, PROGRAM_NAME, PACKAGE_NAME, Version, AUTHORS,\n<line19>(char *) nullptr);\n<line20>}\n<line21>return EXIT_STATUS;\n<line22>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/src/truncate.c
========================================
Function: usage
Content: <line0>void\n<line1>usage (int status)\n<line2>{\n<line3>if (status != EXIT_SUCCESS)\n<line4>emit_try_help ();\n<line5>else\n<line6>{\n<line7>printf (_("Usage: %s OPTION... FILE...\n"), program_name);\n<line8>fputs (_("\\n<line9>Shrink or extend the size of each FILE to the specified size\n\\n<line10>\n\\n<line11>A FILE argument that does not exist is created.\n\\n<line12>\n\\n<line13>If a FILE is larger than the specified size, the extra data is lost.\n\\n<line14>If a FILE is shorter, it is extended and the sparse extended part (hole)\n\\n<line15>reads as zero bytes.\n\\n<line16>"), stdout);\n<line17>emit_mandatory_arg_note ();\n<line18>fputs (_("\\n<line19>-c, --no-create        do not create any files\n\\n<line20>"), stdout);\n<line21>fputs (_("\\n<line22>-o, --io-blocks        treat SIZE as number of IO blocks instead of bytes\n\\n<line23>"), stdout);\n<line24>fputs (_("\\n<line25>-r, --reference=RFILE  base size on RFILE\n\\n<line26>-s, --size=SIZE        set or adjust the file size by SIZE bytes\n"), stdout);\n<line27>fputs (HELP_OPTION_DESCRIPTION, stdout);\n<line28>fputs (VERSION_OPTION_DESCRIPTION, stdout);\n<line29>emit_size_note ();\n<line30>fputs (_("\n\\n<line31>SIZE may also be prefixed by one of the following modifying characters:\n\\n<line32>'+' extend by, '-' reduce by, '<' at most, '>' at least,\n\\n<line33>'/' round down to multiple of, '%' round up to multiple of.\n"), stdout);\n<line34>emit_ancillary_info (PROGRAM_NAME);\n<line35>}\n<line36>exit (status);\n<line37>}
----------------------------------------
Function: do_ftruncate
Content: <line0>static bool\n<line1>do_ftruncate (int fd, char const *fname, off_t ssize, off_t rsize,\n<line2>rel_mode_t rel_mode)\n<line3>{\n<line4>struct stat sb;\n<line5>off_t nsize;\n<line6>if ((block_mode || (rel_mode && rsize < 0)) && fstat (fd, &sb) != 0)\n<line7>{\n<line8>error (0, errno, _("cannot fstat %s"), quoteaf (fname));\n<line9>return false;\n<line10>}\n<line11>if (block_mode)\n<line12>{\n<line13>ptrdiff_t blksize = ST_BLKSIZE (sb);\n<line14>intmax_t ssize0 = ssize;\n<line15>if (ckd_mul (&ssize, ssize, blksize))\n<line16>{\n<line17>error (0, 0,\n<line18>_("overflow in %" PRIdMAX\n<line19>" * %" PRIdPTR " byte blocks for file %s"),\n<line20>ssize0, blksize, quoteaf (fname));\n<line21>return false;\n<line22>}\n<line23>}\n<line24>if (rel_mode)\n<line25>{\n<line26>off_t fsize;\n<line27>if (0 <= rsize)\n<line28>fsize = rsize;\n<line29>else\n<line30>{\n<line31>if (usable_st_size (&sb))\n<line32>{\n<line33>fsize = sb.st_size;\n<line34>if (fsize < 0)\n<line35>{\n<line36>/* Sanity check.  Overflow is the only reason I can think\n<line37>this would ever go negative. */\n<line38>error (0, 0, _("%s has unusable, apparently negative size"),\n<line39>quoteaf (fname));\n<line40>return false;\n<line41>}\n<line42>}\n<line43>else\n<line44>{\n<line45>fsize = lseek (fd, 0, SEEK_END);\n<line46>if (fsize < 0)\n<line47>{\n<line48>error (0, errno, _("cannot get the size of %s"),\n<line49>quoteaf (fname));\n<line50>return false;\n<line51>}\n<line52>}\n<line53>}\n<line54>if (rel_mode == rm_min)\n<line55>nsize = MAX (fsize, ssize);\n<line56>else if (rel_mode == rm_max)\n<line57>nsize = MIN (fsize, ssize);\n<line58>else if (rel_mode == rm_rdn)\n<line59>/* 0..ssize-1 -> 0 */\n<line60>nsize = fsize - fsize % ssize;\n<line61>else\n<line62>{\n<line63>if (rel_mode == rm_rup)\n<line64>{\n<line65>/* 1..ssize -> ssize */\n<line66>off_t r = fsize % ssize;\n<line67>ssize = r == 0 ? 0 : ssize - r;\n<line68>}\n<line69>if (ckd_add (&nsize, fsize, ssize))\n<line70>{\n<line71>error (0, 0, _("overflow extending size of file %s"),\n<line72>quoteaf (fname));\n<line73>return false;\n<line74>}\n<line75>}\n<line76>}\n<line77>else\n<line78>nsize = ssize;\n<line79>if (nsize < 0)\n<line80>nsize = 0;\n<line81>if (ftruncate (fd, nsize) != 0)\n<line82>{\n<line83>intmax_t s = nsize;\n<line84>error (0, errno, _("failed to truncate %s at %"PRIdMAX" bytes"),\n<line85>quoteaf (fname), s);\n<line86>return false;\n<line87>}\n<line88>return true;\n<line89>}
----------------------------------------
Function: main
Content: <line0>int\n<line1>main (int argc, char **argv)\n<line2>{\n<line3>bool got_size = false;\n<line4>off_t size IF_LINT ( = 0);\n<line5>off_t rsize = -1;\n<line6>rel_mode_t rel_mode = rm_abs;\n<line7>int c;\n<line8>initialize_main (&argc, &argv);\n<line9>set_program_name (argv[0]);\n<line10>setlocale (LC_ALL, "");\n<line11>bindtextdomain (PACKAGE, LOCALEDIR);\n<line12>textdomain (PACKAGE);\n<line13>atexit (close_stdout);\n<line14>while ((c = getopt_long (argc, argv, "cor:s:", longopts, nullptr)) != -1)\n<line15>{\n<line16>switch (c)\n<line17>{\n<line18>case 'c':\n<line19>no_create = true;\n<line20>break;\n<line21>case 'o':\n<line22>block_mode = true;\n<line23>break;\n<line24>case 'r':\n<line25>ref_file = optarg;\n<line26>break;\n<line27>case 's':\n<line28>/* skip any whitespace */\n<line29>while (isspace (to_uchar (*optarg)))\n<line30>optarg++;\n<line31>switch (*optarg)\n<line32>{\n<line33>case '<':\n<line34>rel_mode = rm_max;\n<line35>optarg++;\n<line36>break;\n<line37>case '>':\n<line38>rel_mode = rm_min;\n<line39>optarg++;\n<line40>break;\n<line41>case '/':\n<line42>rel_mode = rm_rdn;\n<line43>optarg++;\n<line44>break;\n<line45>case '%':\n<line46>rel_mode = rm_rup;\n<line47>optarg++;\n<line48>break;\n<line49>}\n<line50>/* skip any whitespace */\n<line51>while (isspace (to_uchar (*optarg)))\n<line52>optarg++;\n<line53>if (*optarg == '+' || *optarg == '-')\n<line54>{\n<line55>if (rel_mode)\n<line56>{\n<line57>error (0, 0, _("multiple relative modifiers specified"));\n<line58>/* Note other combinations are flagged as invalid numbers */\n<line59>usage (EXIT_FAILURE);\n<line60>}\n<line61>rel_mode = rm_rel;\n<line62>}\n<line63>/* Support dd BLOCK size suffixes + lowercase g,t,m for bsd compat.\n<line64>Note we don't support dd's b=512, c=1, w=2 or 21x512MiB formats. */\n<line65>size = xdectoimax (optarg, OFF_T_MIN, OFF_T_MAX, "EgGkKmMPQRtTYZ0",\n<line66>_("Invalid number"), 0);\n<line67>/* Rounding to multiple of 0 is nonsensical */\n<line68>if ((rel_mode == rm_rup || rel_mode == rm_rdn) && size == 0)\n<line69>error (EXIT_FAILURE, 0, _("division by zero"));\n<line70>got_size = true;\n<line71>break;\n<line72>case_GETOPT_HELP_CHAR;\n<line73>case_GETOPT_VERSION_CHAR (PROGRAM_NAME, AUTHORS);\n<line74>default:\n<line75>usage (EXIT_FAILURE);\n<line76>}\n<line77>}\n<line78>argv += optind;\n<line79>argc -= optind;\n<line80>/* must specify either size or reference file */\n<line81>if (!ref_file && !got_size)\n<line82>{\n<line83>error (0, 0, _("you must specify either %s or %s"),\n<line84>quote_n (0, "--size"), quote_n (1, "--reference"));\n<line85>usage (EXIT_FAILURE);\n<line86>}\n<line87>/* must specify a relative size with a reference file */\n<line88>if (ref_file && got_size && !rel_mode)\n<line89>{\n<line90>error (0, 0, _("you must specify a relative %s with %s"),\n<line91>quote_n (0, "--size"), quote_n (1, "--reference"));\n<line92>usage (EXIT_FAILURE);\n<line93>}\n<line94>/* block_mode without size is not valid */\n<line95>if (block_mode && !got_size)\n<line96>{\n<line97>error (0, 0, _("%s was specified but %s was not"),\n<line98>quote_n (0, "--io-blocks"), quote_n (1, "--size"));\n<line99>usage (EXIT_FAILURE);\n<line100>}\n<line101>/* must specify at least 1 file */\n<line102>if (argc < 1)\n<line103>{\n<line104>error (0, 0, _("missing file operand"));\n<line105>usage (EXIT_FAILURE);\n<line106>}\n<line107>if (ref_file)\n<line108>{\n<line109>struct stat sb;\n<line110>off_t file_size = -1;\n<line111>if (stat (ref_file, &sb) != 0)\n<line112>error (EXIT_FAILURE, errno, _("cannot stat %s"), quoteaf (ref_file));\n<line113>if (usable_st_size (&sb))\n<line114>file_size = sb.st_size;\n<line115>else\n<line116>{\n<line117>int ref_fd = open (ref_file, O_RDONLY);\n<line118>if (0 <= ref_fd)\n<line119>{\n<line120>off_t file_end = lseek (ref_fd, 0, SEEK_END);\n<line121>int saved_errno = errno;\n<line122>close (ref_fd); /* ignore failure */\n<line123>if (0 <= file_end)\n<line124>file_size = file_end;\n<line125>else\n<line126>{\n<line127>/* restore, in case close clobbered it. */\n<line128>errno = saved_errno;\n<line129>}\n<line130>}\n<line131>}\n<line132>if (file_size < 0)\n<line133>error (EXIT_FAILURE, errno, _("cannot get the size of %s"),\n<line134>quoteaf (ref_file));\n<line135>if (!got_size)\n<line136>size = file_size;\n<line137>else\n<line138>rsize = file_size;\n<line139>}\n<line140>int oflags = O_WRONLY | (no_create ? 0 : O_CREAT) | O_NONBLOCK;\n<line141>bool errors = false;\n<line142>for (char const *fname; (fname = *argv); argv++)\n<line143>{\n<line144>int fd = open (fname, oflags, MODE_RW_UGO);\n<line145>if (fd < 0)\n<line146>{\n<line147>/* 'truncate -s0 -c no-such-file'  shouldn't gen error\n<line148>'truncate -s0 no-such-dir/file' should gen ENOENT error\n<line149>'truncate -s0 no-such-dir/' should gen EISDIR error\n<line150>'truncate -s0 .' should gen EISDIR error */\n<line151>if (!(no_create && errno == ENOENT))\n<line152>{\n<line153>error (0, errno, _("cannot open %s for writing"),\n<line154>quoteaf (fname));\n<line155>errors = true;\n<line156>}\n<line157>}\n<line158>else\n<line159>{\n<line160>errors |= !do_ftruncate (fd, fname, size, rsize, rel_mode);\n<line161>if (close (fd) != 0)\n<line162>{\n<line163>error (0, errno, _("failed to close %s"), quoteaf (fname));\n<line164>errors = true;\n<line165>}\n<line166>}\n<line167>}\n<line168>return errors ? EXIT_FAILURE : EXIT_SUCCESS;\n<line169>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/src/tsort.c
========================================
Function: usage
Content: <line0>void\n<line1>usage (int status)\n<line2>{\n<line3>if (status != EXIT_SUCCESS)\n<line4>emit_try_help ();\n<line5>else\n<line6>{\n<line7>printf (_("\\n<line8>Usage: %s [OPTION] [FILE]\n\\n<line9>Write totally ordered list consistent with the partial ordering in FILE.\n\\n<line10>"), program_name);\n<line11>emit_stdin_note ();\n<line12>fputs (_("\\n<line13>\n\\n<line14>"), stdout);\n<line15>fputs (HELP_OPTION_DESCRIPTION, stdout);\n<line16>fputs (VERSION_OPTION_DESCRIPTION, stdout);\n<line17>emit_ancillary_info (PROGRAM_NAME);\n<line18>}\n<line19>exit (status);\n<line20>}
----------------------------------------
Function: new_item
Content: <line0>static struct item *\n<line1>new_item (char const *str)\n<line2>{\n<line3>/* T1. Initialize (COUNT[k] <- 0 and TOP[k] <- ^).  */\n<line4>struct item *k = xzalloc (sizeof *k);\n<line5>if (str)\n<line6>k->str = xstrdup (str);\n<line7>return k;\n<line8>}
----------------------------------------
Function: search_item
Content: <line0>static struct item *\n<line1>search_item (struct item *root, char const *str)\n<line2>{\n<line3>struct item *p, *q, *r, *s, *t;\n<line4>int a;\n<line5>/* Make sure the tree is not empty, since that is what the algorithm\n<line6>below expects.  */\n<line7>if (root->right == nullptr)\n<line8>return (root->right = new_item (str));\n<line9>/* A1. Initialize.  */\n<line10>t = root;\n<line11>s = p = root->right;\n<line12>while (true)\n<line13>{\n<line14>/* A2. Compare.  */\n<line15>a = strcmp (str, p->str);\n<line16>if (a == 0)\n<line17>return p;\n<line18>/* A3 & A4.  Move left & right.  */\n<line19>if (a < 0)\n<line20>q = p->left;\n<line21>else\n<line22>q = p->right;\n<line23>if (q == nullptr)\n<line24>{\n<line25>/* A5. Insert.  */\n<line26>q = new_item (str);\n<line27>/* A3 & A4.  (continued).  */\n<line28>if (a < 0)\n<line29>p->left = q;\n<line30>else\n<line31>p->right = q;\n<line32>/* A6. Adjust balance factors.  */\n<line33>a = strcmp (str, s->str);\n<line34>if (a < 0)\n<line35>{\n<line36>r = p = s->left;\n<line37>a = -1;\n<line38>}\n<line39>else\n<line40>{\n<line41>affirm (0 < a);\n<line42>r = p = s->right;\n<line43>a = 1;\n<line44>}\n<line45>while (p != q)\n<line46>{\n<line47>int cmp = strcmp (str, p->str);\n<line48>if (cmp < 0)\n<line49>{\n<line50>p->balance = -1;\n<line51>p = p->left;\n<line52>}\n<line53>else\n<line54>{\n<line55>affirm (0 < cmp);\n<line56>p->balance = 1;\n<line57>p = p->right;\n<line58>}\n<line59>}\n<line60>/* A7. Balancing act.  */\n<line61>if (s->balance == 0 || s->balance == -a)\n<line62>{\n<line63>s->balance += a;\n<line64>return q;\n<line65>}\n<line66>if (r->balance == a)\n<line67>{\n<line68>/* A8. Single Rotation.  */\n<line69>p = r;\n<line70>if (a < 0)\n<line71>{\n<line72>s->left = r->right;\n<line73>r->right = s;\n<line74>}\n<line75>else\n<line76>{\n<line77>s->right = r->left;\n<line78>r->left = s;\n<line79>}\n<line80>s->balance = r->balance = 0;\n<line81>}\n<line82>else\n<line83>{\n<line84>/* A9. Double rotation.  */\n<line85>if (a < 0)\n<line86>{\n<line87>p = r->right;\n<line88>r->right = p->left;\n<line89>p->left = r;\n<line90>s->left = p->right;\n<line91>p->right = s;\n<line92>}\n<line93>else\n<line94>{\n<line95>p = r->left;\n<line96>r->left = p->right;\n<line97>p->right = r;\n<line98>s->right = p->left;\n<line99>p->left = s;\n<line100>}\n<line101>s->balance = 0;\n<line102>r->balance = 0;\n<line103>if (p->balance == a)\n<line104>s->balance = -a;\n<line105>else if (p->balance == -a)\n<line106>r->balance = a;\n<line107>p->balance = 0;\n<line108>}\n<line109>/* A10. Finishing touch.  */\n<line110>if (s == t->right)\n<line111>t->right = p;\n<line112>else\n<line113>t->left = p;\n<line114>return q;\n<line115>}\n<line116>/* A3 & A4.  (continued).  */\n<line117>if (q->balance)\n<line118>{\n<line119>t = p;\n<line120>s = q;\n<line121>}\n<line122>p = q;\n<line123>}\n<line124>/* NOTREACHED */\n<line125>}
----------------------------------------
Function: record_relation
Content: <line0>static void\n<line1>record_relation (struct item *j, struct item *k)\n<line2>{\n<line3>struct successor *p;\n<line4>if (!STREQ (j->str, k->str))\n<line5>{\n<line6>k->count++;\n<line7>p = xmalloc (sizeof *p);\n<line8>p->suc = k;\n<line9>p->next = j->top;\n<line10>j->top = p;\n<line11>}\n<line12>}
----------------------------------------
Function: count_items
Content: <line0>static bool\n<line1>count_items (MAYBE_UNUSED struct item *unused)\n<line2>{\n<line3>n_strings++;\n<line4>return false;\n<line5>}
----------------------------------------
Function: scan_zeros
Content: <line0>static bool\n<line1>scan_zeros (struct item *k)\n<line2>{\n<line3>/* Ignore strings that have already been printed.  */\n<line4>if (k->count == 0 && !k->printed)\n<line5>{\n<line6>if (head == nullptr)\n<line7>head = k;\n<line8>else\n<line9>zeros->qlink = k;\n<line10>zeros = k;\n<line11>}\n<line12>return false;\n<line13>}
----------------------------------------
Function: detect_loop
Content: <line0>static bool\n<line1>detect_loop (struct item *k)\n<line2>{\n<line3>if (k->count > 0)\n<line4>{\n<line5>/* K does not have to be part of a cycle.  It is however part of\n<line6>a graph that contains a cycle.  */\n<line7>if (loop == nullptr)\n<line8>/* Start traversing the graph at K.  */\n<line9>loop = k;\n<line10>else\n<line11>{\n<line12>struct successor **p = &k->top;\n<line13>while (*p)\n<line14>{\n<line15>if ((*p)->suc == loop)\n<line16>{\n<line17>if (k->qlink)\n<line18>{\n<line19>/* We have found a loop.  Retrace our steps.  */\n<line20>while (loop)\n<line21>{\n<line22>struct item *tmp = loop->qlink;\n<line23>error (0, 0, "%s", (loop->str));\n<line24>/* Until we encounter K again.  */\n<line25>if (loop == k)\n<line26>{\n<line27>/* Remove relation.  */\n<line28>struct successor *s = *p;\n<line29>s->suc->count--;\n<line30>*p = s->next;\n<line31>IF_LINT (free (s));\n<line32>break;\n<line33>}\n<line34>/* Tidy things up since we might have to\n<line35>detect another loop.  */\n<line36>loop->qlink = nullptr;\n<line37>loop = tmp;\n<line38>}\n<line39>while (loop)\n<line40>{\n<line41>struct item *tmp = loop->qlink;\n<line42>loop->qlink = nullptr;\n<line43>loop = tmp;\n<line44>}\n<line45>/* Since we have found the loop, stop walking\n<line46>the tree.  */\n<line47>return true;\n<line48>}\n<line49>else\n<line50>{\n<line51>k->qlink = loop;\n<line52>loop = k;\n<line53>break;\n<line54>}\n<line55>}\n<line56>p = &(*p)->next;\n<line57>}\n<line58>}\n<line59>}\n<line60>return false;\n<line61>}
----------------------------------------
Function: recurse_tree
Content: <line0>static bool\n<line1>recurse_tree (struct item *root, bool (*action) (struct item *))\n<line2>{\n<line3>if (root->left == nullptr && root->right == nullptr)\n<line4>return (*action) (root);\n<line5>else\n<line6>{\n<line7>if (root->left != nullptr)\n<line8>if (recurse_tree (root->left, action))\n<line9>return true;\n<line10>if ((*action) (root))\n<line11>return true;\n<line12>if (root->right != nullptr)\n<line13>if (recurse_tree (root->right, action))\n<line14>return true;\n<line15>}\n<line16>return false;\n<line17>}
----------------------------------------
Function: walk_tree
Content: <line0>static void\n<line1>walk_tree (struct item *root, bool (*action) (struct item *))\n<line2>{\n<line3>if (root->right)\n<line4>recurse_tree (root->right, action);\n<line5>}
----------------------------------------
Function: tsort
Content: <line0>static _Noreturn void\n<line1>tsort (char const *file)\n<line2>{\n<line3>bool ok = true;\n<line4>struct item *j = nullptr;\n<line5>struct item *k = nullptr;\n<line6>token_buffer tokenbuffer;\n<line7>bool is_stdin = STREQ (file, "-");\n<line8>/* Initialize the head of the tree holding the strings we're sorting.  */\n<line9>struct item *root = new_item (nullptr);\n<line10>if (!is_stdin && ! freopen (file, "r", stdin))\n<line11>error (EXIT_FAILURE, errno, "%s", quotef (file));\n<line12>fadvise (stdin, FADVISE_SEQUENTIAL);\n<line13>init_tokenbuffer (&tokenbuffer);\n<line14>while (true)\n<line15>{\n<line16>/* T2. Next Relation.  */\n<line17>size_t len = readtoken (stdin, DELIM, sizeof (DELIM) - 1, &tokenbuffer);\n<line18>if (len == (size_t) -1)\n<line19>{\n<line20>if (ferror (stdin))\n<line21>error (EXIT_FAILURE, errno, _("%s: read error"), quotef (file));\n<line22>break;\n<line23>}\n<line24>affirm (len != 0);\n<line25>k = search_item (root, tokenbuffer.buffer);\n<line26>if (j)\n<line27>{\n<line28>/* T3. Record the relation.  */\n<line29>record_relation (j, k);\n<line30>k = nullptr;\n<line31>}\n<line32>j = k;\n<line33>}\n<line34>if (k != nullptr)\n<line35>error (EXIT_FAILURE, 0, _("%s: input contains an odd number of tokens"),\n<line36>quotef (file));\n<line37>/* T1. Initialize (N <- n).  */\n<line38>walk_tree (root, count_items);\n<line39>while (n_strings > 0)\n<line40>{\n<line41>/* T4. Scan for zeros.  */\n<line42>walk_tree (root, scan_zeros);\n<line43>while (head)\n<line44>{\n<line45>struct successor *p = head->top;\n<line46>/* T5. Output front of queue.  */\n<line47>puts (head->str);\n<line48>head->printed = true;\n<line49>n_strings--;\n<line50>/* T6. Erase relations.  */\n<line51>while (p)\n<line52>{\n<line53>p->suc->count--;\n<line54>if (p->suc->count == 0)\n<line55>{\n<line56>zeros->qlink = p->suc;\n<line57>zeros = p->suc;\n<line58>}\n<line59>p = p->next;\n<line60>}\n<line61>/* T7. Remove from queue.  */\n<line62>head = head->qlink;\n<line63>}\n<line64>/* T8.  End of process.  */\n<line65>if (n_strings > 0)\n<line66>{\n<line67>/* The input contains a loop.  */\n<line68>error (0, 0, _("%s: input contains a loop:"), quotef (file));\n<line69>ok = false;\n<line70>/* Print the loop and remove a relation to break it.  */\n<line71>do\n<line72>walk_tree (root, detect_loop);\n<line73>while (loop);\n<line74>}\n<line75>}\n<line76>if (fclose (stdin) != 0)\n<line77>error (EXIT_FAILURE, errno, "%s",\n<line78>is_stdin ? _("standard input") : quotef (file));\n<line79>exit (ok ? EXIT_SUCCESS : EXIT_FAILURE);\n<line80>}
----------------------------------------
Function: main
Content: <line0>int\n<line1>main (int argc, char **argv)\n<line2>{\n<line3>initialize_main (&argc, &argv);\n<line4>set_program_name (argv[0]);\n<line5>setlocale (LC_ALL, "");\n<line6>bindtextdomain (PACKAGE, LOCALEDIR);\n<line7>textdomain (PACKAGE);\n<line8>atexit (close_stdout);\n<line9>parse_gnu_standard_options_only (argc, argv, PROGRAM_NAME, PACKAGE_NAME,\n<line10>Version, true, usage, AUTHORS,\n<line11>(char const *) nullptr);\n<line12>if (1 < argc - optind)\n<line13>{\n<line14>error (0, 0, _("extra operand %s"), quote (argv[optind + 1]));\n<line15>usage (EXIT_FAILURE);\n<line16>}\n<line17>tsort (optind == argc ? "-" : argv[optind]);\n<line18>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/src/tty.c
========================================
Function: usage
Content: <line0>void\n<line1>usage (int status)\n<line2>{\n<line3>if (status != EXIT_SUCCESS)\n<line4>emit_try_help ();\n<line5>else\n<line6>{\n<line7>printf (_("Usage: %s [OPTION]...\n"), program_name);\n<line8>fputs (_("\\n<line9>Print the file name of the terminal connected to standard input.\n\\n<line10>\n\\n<line11>-s, --silent, --quiet   print nothing, only return an exit status\n\\n<line12>"), stdout);\n<line13>fputs (HELP_OPTION_DESCRIPTION, stdout);\n<line14>fputs (VERSION_OPTION_DESCRIPTION, stdout);\n<line15>emit_ancillary_info (PROGRAM_NAME);\n<line16>}\n<line17>exit (status);\n<line18>}
----------------------------------------
Function: main
Content: <line0>int\n<line1>main (int argc, char **argv)\n<line2>{\n<line3>int optc;\n<line4>initialize_main (&argc, &argv);\n<line5>set_program_name (argv[0]);\n<line6>setlocale (LC_ALL, "");\n<line7>bindtextdomain (PACKAGE, LOCALEDIR);\n<line8>textdomain (PACKAGE);\n<line9>initialize_exit_failure (TTY_WRITE_ERROR);\n<line10>atexit (close_stdout);\n<line11>silent = false;\n<line12>while ((optc = getopt_long (argc, argv, "s", longopts, nullptr)) != -1)\n<line13>{\n<line14>switch (optc)\n<line15>{\n<line16>case 's':\n<line17>silent = true;\n<line18>break;\n<line19>case_GETOPT_HELP_CHAR;\n<line20>case_GETOPT_VERSION_CHAR (PROGRAM_NAME, AUTHORS);\n<line21>default:\n<line22>usage (TTY_FAILURE);\n<line23>}\n<line24>}\n<line25>if (optind < argc)\n<line26>{\n<line27>error (0, 0, _("extra operand %s"), quote (argv[optind]));\n<line28>usage (TTY_FAILURE);\n<line29>}\n<line30>errno = ENOENT;\n<line31>if (silent)\n<line32>return isatty (STDIN_FILENO) ? EXIT_SUCCESS : TTY_STDIN_NOTTY;\n<line33>int status = EXIT_SUCCESS;\n<line34>char const *tty = ttyname (STDIN_FILENO);\n<line35>if (! tty)\n<line36>{\n<line37>tty = _("not a tty");\n<line38>status = TTY_STDIN_NOTTY;\n<line39>}\n<line40>puts (tty);\n<line41>return status;\n<line42>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/src/uname.c
========================================
Function: usage
Content: <line0>void\n<line1>usage (int status)\n<line2>{\n<line3>if (status != EXIT_SUCCESS)\n<line4>emit_try_help ();\n<line5>else\n<line6>{\n<line7>printf (_("Usage: %s [OPTION]...\n"), program_name);\n<line8>if (uname_mode == UNAME_UNAME)\n<line9>{\n<line10>fputs (_("\\n<line11>Print certain system information.  With no OPTION, same as -s.\n\\n<line12>\n\\n<line13>-a, --all                print all information, in the following order,\n\\n<line14>except omit -p and -i if unknown:\n\\n<line15>-s, --kernel-name        print the kernel name\n\\n<line16>-n, --nodename           print the network node hostname\n\\n<line17>-r, --kernel-release     print the kernel release\n\\n<line18>"), stdout);\n<line19>fputs (_("\\n<line20>-v, --kernel-version     print the kernel version\n\\n<line21>-m, --machine            print the machine hardware name\n\\n<line22>-p, --processor          print the processor type (non-portable)\n\\n<line23>-i, --hardware-platform  print the hardware platform (non-portable)\n\\n<line24>-o, --operating-system   print the operating system\n\\n<line25>"), stdout);\n<line26>}\n<line27>else\n<line28>{\n<line29>fputs (_("\\n<line30>Print machine architecture.\n\\n<line31>\n\\n<line32>"), stdout);\n<line33>}\n<line34>fputs (HELP_OPTION_DESCRIPTION, stdout);\n<line35>fputs (VERSION_OPTION_DESCRIPTION, stdout);\n<line36>emit_ancillary_info (PROGRAM_NAME);\n<line37>}\n<line38>exit (status);\n<line39>}
----------------------------------------
Function: print_element
Content: <line0>static void\n<line1>print_element (char const *element)\n<line2>{\n<line3>static bool printed;\n<line4>if (printed)\n<line5>putchar (' ');\n<line6>printed = true;\n<line7>fputs (element, stdout);\n<line8>}
----------------------------------------
Function: print_element_env
Content: <line0>static void\n<line1>print_element_env (char const *element, MAYBE_UNUSED char const *envvar)\n<line2>{\n<line3>#ifdef __APPLE__\n<line4>if (envvar)\n<line5>{\n<line6>char const *val = getenv (envvar);\n<line7>if (val)\n<line8>element = val;\n<line9>}\n<line10>#endif\n<line11>print_element (element);\n<line12>}
----------------------------------------
Function: decode_switches
Content: <line0>static int\n<line1>decode_switches (int argc, char **argv)\n<line2>{\n<line3>int c;\n<line4>unsigned int toprint = 0;\n<line5>if (uname_mode == UNAME_ARCH)\n<line6>{\n<line7>while ((c = getopt_long (argc, argv, "",\n<line8>arch_long_options, nullptr))\n<line9>!= -1)\n<line10>{\n<line11>switch (c)\n<line12>{\n<line13>case_GETOPT_HELP_CHAR;\n<line14>case_GETOPT_VERSION_CHAR (PROGRAM_NAME, ARCH_AUTHORS);\n<line15>default:\n<line16>usage (EXIT_FAILURE);\n<line17>}\n<line18>}\n<line19>toprint = PRINT_MACHINE;\n<line20>}\n<line21>else\n<line22>{\n<line23>while ((c = getopt_long (argc, argv, "asnrvmpio",\n<line24>uname_long_options, nullptr))\n<line25>!= -1)\n<line26>{\n<line27>switch (c)\n<line28>{\n<line29>case 'a':\n<line30>toprint = UINT_MAX;\n<line31>break;\n<line32>case 's':\n<line33>toprint |= PRINT_KERNEL_NAME;\n<line34>break;\n<line35>case 'n':\n<line36>toprint |= PRINT_NODENAME;\n<line37>break;\n<line38>case 'r':\n<line39>toprint |= PRINT_KERNEL_RELEASE;\n<line40>break;\n<line41>case 'v':\n<line42>toprint |= PRINT_KERNEL_VERSION;\n<line43>break;\n<line44>case 'm':\n<line45>toprint |= PRINT_MACHINE;\n<line46>break;\n<line47>case 'p':\n<line48>toprint |= PRINT_PROCESSOR;\n<line49>break;\n<line50>case 'i':\n<line51>toprint |= PRINT_HARDWARE_PLATFORM;\n<line52>break;\n<line53>case 'o':\n<line54>toprint |= PRINT_OPERATING_SYSTEM;\n<line55>break;\n<line56>case_GETOPT_HELP_CHAR;\n<line57>case_GETOPT_VERSION_CHAR (PROGRAM_NAME, AUTHORS);\n<line58>default:\n<line59>usage (EXIT_FAILURE);\n<line60>}\n<line61>}\n<line62>}\n<line63>if (argc != optind)\n<line64>{\n<line65>error (0, 0, _("extra operand %s"), quote (argv[optind]));\n<line66>usage (EXIT_FAILURE);\n<line67>}\n<line68>return toprint;\n<line69>}
----------------------------------------
Function: main
Content: <line0>int\n<line1>main (int argc, char **argv)\n<line2>{\n<line3>static char const unknown[] = "unknown";\n<line4>/* Mask indicating which elements to print. */\n<line5>unsigned int toprint = 0;\n<line6>initialize_main (&argc, &argv);\n<line7>set_program_name (argv[0]);\n<line8>setlocale (LC_ALL, "");\n<line9>bindtextdomain (PACKAGE, LOCALEDIR);\n<line10>textdomain (PACKAGE);\n<line11>atexit (close_stdout);\n<line12>toprint = decode_switches (argc, argv);\n<line13>if (toprint == 0)\n<line14>toprint = PRINT_KERNEL_NAME;\n<line15>if (toprint\n<line16>& (PRINT_KERNEL_NAME | PRINT_NODENAME | PRINT_KERNEL_RELEASE\n<line17>| PRINT_KERNEL_VERSION | PRINT_MACHINE))\n<line18>{\n<line19>struct utsname name;\n<line20>if (uname (&name) == -1)\n<line21>error (EXIT_FAILURE, errno, _("cannot get system name"));\n<line22>if (toprint & PRINT_KERNEL_NAME)\n<line23>print_element_env (name.sysname, "UNAME_SYSNAME");\n<line24>if (toprint & PRINT_NODENAME)\n<line25>print_element_env (name.nodename, "UNAME_NODENAME");\n<line26>if (toprint & PRINT_KERNEL_RELEASE)\n<line27>print_element_env (name.release, "UNAME_RELEASE");\n<line28>if (toprint & PRINT_KERNEL_VERSION)\n<line29>print_element_env (name.version, "UNAME_VERSION");\n<line30>if (toprint & PRINT_MACHINE)\n<line31>print_element_env (name.machine, "UNAME_MACHINE");\n<line32>}\n<line33>if (toprint & PRINT_PROCESSOR)\n<line34>{\n<line35>char const *element = unknown;\n<line36>#ifdef __APPLE__\n<line37># if defined __arm__ || defined __arm64__\n<line38>element = "arm";\n<line39># elif defined __i386__ || defined __x86_64__\n<line40>element = "i386";\n<line41># elif defined __ppc__ || defined __ppc64__\n<line42>element = "powerpc";\n<line43># endif\n<line44>#endif\n<line45>#if HAVE_SYSINFO && defined SI_ARCHITECTURE\n<line46>if (element == unknown)\n<line47>{\n<line48>static char processor[257];\n<line49>if (0 <= sysinfo (SI_ARCHITECTURE, processor, sizeof processor))\n<line50>element = processor;\n<line51>}\n<line52>#endif\n<line53>#ifdef UNAME_PROCESSOR\n<line54>if (element == unknown)\n<line55>{\n<line56>static char processor[257];\n<line57>size_t s = sizeof processor;\n<line58>static int mib[] = { CTL_HW, UNAME_PROCESSOR };\n<line59>if (sysctl (mib, 2, processor, &s, 0, 0) >= 0)\n<line60>element = processor;\n<line61>}\n<line62>#endif\n<line63>if (! (toprint == UINT_MAX && element == unknown))\n<line64>print_element (element);\n<line65>}\n<line66>if (toprint & PRINT_HARDWARE_PLATFORM)\n<line67>{\n<line68>char const *element = unknown;\n<line69>#if HAVE_SYSINFO && defined SI_PLATFORM\n<line70>{\n<line71>static char hardware_platform[257];\n<line72>if (0 <= sysinfo (SI_PLATFORM,\n<line73>hardware_platform, sizeof hardware_platform))\n<line74>element = hardware_platform;\n<line75>}\n<line76>#endif\n<line77>#ifdef UNAME_HARDWARE_PLATFORM\n<line78>if (element == unknown)\n<line79>{\n<line80>static char hardware_platform[257];\n<line81>size_t s = sizeof hardware_platform;\n<line82>static int mib[] = { CTL_HW, UNAME_HARDWARE_PLATFORM };\n<line83>if (sysctl (mib, 2, hardware_platform, &s, 0, 0) >= 0)\n<line84>element = hardware_platform;\n<line85>}\n<line86>#endif\n<line87>if (! (toprint == UINT_MAX && element == unknown))\n<line88>print_element (element);\n<line89>}\n<line90>if (toprint & PRINT_OPERATING_SYSTEM)\n<line91>print_element (HOST_OPERATING_SYSTEM);\n<line92>putchar ('\n');\n<line93>return EXIT_SUCCESS;\n<line94>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/src/uname-uname.c
========================================
========================================
/home/huihui/Downloads/coreutils-9.4/src/unexpand.c
========================================
Function: usage
Content: <line0>void\n<line1>usage (int status)\n<line2>{\n<line3>if (status != EXIT_SUCCESS)\n<line4>emit_try_help ();\n<line5>else\n<line6>{\n<line7>printf (_("\\n<line8>Usage: %s [OPTION]... [FILE]...\n\\n<line9>"),\n<line10>program_name);\n<line11>fputs (_("\\n<line12>Convert blanks in each FILE to tabs, writing to standard output.\n\\n<line13>"), stdout);\n<line14>emit_stdin_note ();\n<line15>emit_mandatory_arg_note ();\n<line16>fputs (_("\\n<line17>-a, --all        convert all blanks, instead of just initial blanks\n\\n<line18>--first-only  convert only leading sequences of blanks (overrides -a)\n\\n<line19>-t, --tabs=N     have tabs N characters apart instead of 8 (enables -a)\n\\n<line20>"), stdout);\n<line21>emit_tab_list_info ();\n<line22>fputs (HELP_OPTION_DESCRIPTION, stdout);\n<line23>fputs (VERSION_OPTION_DESCRIPTION, stdout);\n<line24>emit_ancillary_info (PROGRAM_NAME);\n<line25>}\n<line26>exit (status);\n<line27>}
----------------------------------------
Function: unexpand
Content: <line0>static void\n<line1>unexpand (void)\n<line2>{\n<line3>/* Input stream.  */\n<line4>FILE *fp = next_file (nullptr);\n<line5>/* The array of pending blanks.  In non-POSIX locales, blanks can\n<line6>include characters other than spaces, so the blanks must be\n<line7>stored, not merely counted.  */\n<line8>char *pending_blank;\n<line9>if (!fp)\n<line10>return;\n<line11>/* The worst case is a non-blank character, then one blank, then a\n<line12>tab stop, then MAX_COLUMN_WIDTH - 1 blanks, then a non-blank; so\n<line13>allocate MAX_COLUMN_WIDTH bytes to store the blanks.  */\n<line14>pending_blank = xmalloc (max_column_width);\n<line15>while (true)\n<line16>{\n<line17>/* Input character, or EOF.  */\n<line18>int c;\n<line19>/* If true, perform translations.  */\n<line20>bool convert = true;\n<line21>/* The following variables have valid values only when CONVERT\n<line22>is true:  */\n<line23>/* Column of next input character.  */\n<line24>uintmax_t column = 0;\n<line25>/* Column the next input tab stop is on.  */\n<line26>uintmax_t next_tab_column = 0;\n<line27>/* Index in TAB_LIST of next tab stop to examine.  */\n<line28>size_t tab_index = 0;\n<line29>/* If true, the first pending blank came just before a tab stop.  */\n<line30>bool one_blank_before_tab_stop = false;\n<line31>/* If true, the previous input character was a blank.  This is\n<line32>initially true, since initial strings of blanks are treated\n<line33>as if the line was preceded by a blank.  */\n<line34>bool prev_blank = true;\n<line35>/* Number of pending columns of blanks.  */\n<line36>size_t pending = 0;\n<line37>/* Convert a line of text.  */\n<line38>do\n<line39>{\n<line40>while ((c = getc (fp)) < 0 && (fp = next_file (fp)))\n<line41>continue;\n<line42>if (convert)\n<line43>{\n<line44>bool blank = !! isblank (c);\n<line45>if (blank)\n<line46>{\n<line47>bool last_tab;\n<line48>next_tab_column = get_next_tab_column (column, &tab_index,\n<line49>&last_tab);\n<line50>if (last_tab)\n<line51>convert = false;\n<line52>if (convert)\n<line53>{\n<line54>if (next_tab_column < column)\n<line55>error (EXIT_FAILURE, 0, _("input line is too long"));\n<line56>if (c == '\t')\n<line57>{\n<line58>column = next_tab_column;\n<line59>if (pending)\n<line60>pending_blank[0] = '\t';\n<line61>}\n<line62>else\n<line63>{\n<line64>column++;\n<line65>if (! (prev_blank && column == next_tab_column))\n<line66>{\n<line67>/* It is not yet known whether the pending blanks\n<line68>will be replaced by tabs.  */\n<line69>if (column == next_tab_column)\n<line70>one_blank_before_tab_stop = true;\n<line71>pending_blank[pending++] = c;\n<line72>prev_blank = true;\n<line73>continue;\n<line74>}\n<line75>/* Replace the pending blanks by a tab or two.  */\n<line76>pending_blank[0] = c = '\t';\n<line77>}\n<line78>/* Discard pending blanks, unless it was a single\n<line79>blank just before the previous tab stop.  */\n<line80>pending = one_blank_before_tab_stop;\n<line81>}\n<line82>}\n<line83>else if (c == '\b')\n<line84>{\n<line85>/* Go back one column, and force recalculation of the\n<line86>next tab stop.  */\n<line87>column -= !!column;\n<line88>next_tab_column = column;\n<line89>tab_index -= !!tab_index;\n<line90>}\n<line91>else\n<line92>{\n<line93>column++;\n<line94>if (!column)\n<line95>error (EXIT_FAILURE, 0, _("input line is too long"));\n<line96>}\n<line97>if (pending)\n<line98>{\n<line99>if (pending > 1 && one_blank_before_tab_stop)\n<line100>pending_blank[0] = '\t';\n<line101>if (fwrite (pending_blank, 1, pending, stdout) != pending)\n<line102>write_error ();\n<line103>pending = 0;\n<line104>one_blank_before_tab_stop = false;\n<line105>}\n<line106>prev_blank = blank;\n<line107>convert &= convert_entire_line || blank;\n<line108>}\n<line109>if (c < 0)\n<line110>{\n<line111>free (pending_blank);\n<line112>return;\n<line113>}\n<line114>if (putchar (c) < 0)\n<line115>write_error ();\n<line116>}\n<line117>while (c != '\n');\n<line118>}\n<line119>}
----------------------------------------
Function: main
Content: <line0>int\n<line1>main (int argc, char **argv)\n<line2>{\n<line3>bool have_tabval = false;\n<line4>uintmax_t tabval IF_LINT ( = 0);\n<line5>int c;\n<line6>/* If true, cancel the effect of any -a (explicit or implicit in -t),\n<line7>so that only leading blanks will be considered.  */\n<line8>bool convert_first_only = false;\n<line9>initialize_main (&argc, &argv);\n<line10>set_program_name (argv[0]);\n<line11>setlocale (LC_ALL, "");\n<line12>bindtextdomain (PACKAGE, LOCALEDIR);\n<line13>textdomain (PACKAGE);\n<line14>atexit (close_stdout);\n<line15>while ((c = getopt_long (argc, argv, ",0123456789at:", longopts, nullptr))\n<line16>!= -1)\n<line17>{\n<line18>switch (c)\n<line19>{\n<line20>case '?':\n<line21>usage (EXIT_FAILURE);\n<line22>case 'a':\n<line23>convert_entire_line = true;\n<line24>break;\n<line25>case 't':\n<line26>convert_entire_line = true;\n<line27>parse_tab_stops (optarg);\n<line28>break;\n<line29>case CONVERT_FIRST_ONLY_OPTION:\n<line30>convert_first_only = true;\n<line31>break;\n<line32>case ',':\n<line33>if (have_tabval)\n<line34>add_tab_stop (tabval);\n<line35>have_tabval = false;\n<line36>break;\n<line37>case_GETOPT_HELP_CHAR;\n<line38>case_GETOPT_VERSION_CHAR (PROGRAM_NAME, AUTHORS);\n<line39>default:\n<line40>if (!have_tabval)\n<line41>{\n<line42>tabval = 0;\n<line43>have_tabval = true;\n<line44>}\n<line45>if (!DECIMAL_DIGIT_ACCUMULATE (tabval, c - '0', uintmax_t))\n<line46>error (EXIT_FAILURE, 0, _("tab stop value is too large"));\n<line47>break;\n<line48>}\n<line49>}\n<line50>if (convert_first_only)\n<line51>convert_entire_line = false;\n<line52>if (have_tabval)\n<line53>add_tab_stop (tabval);\n<line54>finalize_tab_stops ();\n<line55>set_file_list ((optind < argc) ? &argv[optind] : nullptr);\n<line56>unexpand ();\n<line57>cleanup_file_list_stdin ();\n<line58>return exit_status;\n<line59>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/src/uniq.c
========================================
Function: usage
Content: <line0>void\n<line1>usage (int status)\n<line2>{\n<line3>if (status != EXIT_SUCCESS)\n<line4>emit_try_help ();\n<line5>else\n<line6>{\n<line7>printf (_("\\n<line8>Usage: %s [OPTION]... [INPUT [OUTPUT]]\n\\n<line9>"),\n<line10>program_name);\n<line11>fputs (_("\\n<line12>Filter adjacent matching lines from INPUT (or standard input),\n\\n<line13>writing to OUTPUT (or standard output).\n\\n<line14>\n\\n<line15>With no options, matching lines are merged to the first occurrence.\n\\n<line16>"), stdout);\n<line17>emit_mandatory_arg_note ();\n<line18>fputs (_("\\n<line19>-c, --count           prefix lines by the number of occurrences\n\\n<line20>-d, --repeated        only print duplicate lines, one for each group\n\\n<line21>"), stdout);\n<line22>fputs (_("\\n<line23>-D                    print all duplicate lines\n\\n<line24>--all-repeated[=METHOD]  like -D, but allow separating groups\n\\n<line25>with an empty line;\n\\n<line26>METHOD={none(default),prepend,separate}\n\\n<line27>"), stdout);\n<line28>fputs (_("\\n<line29>-f, --skip-fields=N   avoid comparing the first N fields\n\\n<line30>"), stdout);\n<line31>fputs (_("\\n<line32>--group[=METHOD]  show all items, separating groups with an empty line;\n\\n<line33>METHOD={separate(default),prepend,append,both}\n\\n<line34>"), stdout);\n<line35>fputs (_("\\n<line36>-i, --ignore-case     ignore differences in case when comparing\n\\n<line37>-s, --skip-chars=N    avoid comparing the first N characters\n\\n<line38>-u, --unique          only print unique lines\n\\n<line39>"), stdout);\n<line40>fputs (_("\\n<line41>-z, --zero-terminated     line delimiter is NUL, not newline\n\\n<line42>"), stdout);\n<line43>fputs (_("\\n<line44>-w, --check-chars=N   compare no more than N characters in lines\n\\n<line45>"), stdout);\n<line46>fputs (HELP_OPTION_DESCRIPTION, stdout);\n<line47>fputs (VERSION_OPTION_DESCRIPTION, stdout);\n<line48>fputs (_("\\n<line49>\n\\n<line50>A field is a run of blanks (usually spaces and/or TABs), then non-blank\n\\n<line51>characters.  Fields are skipped before chars.\n\\n<line52>"), stdout);\n<line53>fputs (_("\\n<line54>\n\\n<line55>Note: 'uniq' does not detect repeated lines unless they are adjacent.\n\\n<line56>You may want to sort the input first, or use 'sort -u' without 'uniq'.\n\\n<line57>"), stdout);\n<line58>emit_ancillary_info (PROGRAM_NAME);\n<line59>}\n<line60>exit (status);\n<line61>}
----------------------------------------
Function: strict_posix2
Content: <line0>static bool\n<line1>strict_posix2 (void)\n<line2>{\n<line3>int posix_ver = posix2_version ();\n<line4>return 200112 <= posix_ver && posix_ver < 200809;\n<line5>}
----------------------------------------
Function: size_opt
Content: <line0>static size_t\n<line1>size_opt (char const *opt, char const *msgid)\n<line2>{\n<line3>uintmax_t size;\n<line4>switch (xstrtoumax (opt, nullptr, 10, &size, ""))\n<line5>{\n<line6>case LONGINT_OK:\n<line7>case LONGINT_OVERFLOW:\n<line8>break;\n<line9>default:\n<line10>error (EXIT_FAILURE, 0, "%s: %s", opt, _(msgid));\n<line11>}\n<line12>return MIN (size, SIZE_MAX);\n<line13>}
----------------------------------------
Function: different
Content: <line0>static bool\n<line1>different (char *old, char *new, size_t oldlen, size_t newlen)\n<line2>{\n<line3>if (check_chars < oldlen)\n<line4>oldlen = check_chars;\n<line5>if (check_chars < newlen)\n<line6>newlen = check_chars;\n<line7>if (ignore_case)\n<line8>return oldlen != newlen || memcasecmp (old, new, oldlen);\n<line9>else\n<line10>return oldlen != newlen || memcmp (old, new, oldlen);\n<line11>}
----------------------------------------
Function: writeline
Content: <line0>static void\n<line1>writeline (struct linebuffer const *line,\n<line2>bool match, uintmax_t linecount)\n<line3>{\n<line4>if (! (linecount == 0 ? output_unique\n<line5>: !match ? output_first_repeated\n<line6>: output_later_repeated))\n<line7>return;\n<line8>if (countmode == count_occurrences)\n<line9>printf ("%7" PRIuMAX " ", linecount + 1);\n<line10>if (fwrite (line->buffer, sizeof (char), line->length, stdout)\n<line11>!= line->length)\n<line12>write_error ();\n<line13>}
----------------------------------------
Function: check_file
Content: <line0>static void\n<line1>check_file (char const *infile, char const *outfile, char delimiter)\n<line2>{\n<line3>struct linebuffer lb1, lb2;\n<line4>struct linebuffer *thisline, *prevline;\n<line5>if (! (STREQ (infile, "-") || freopen (infile, "r", stdin)))\n<line6>error (EXIT_FAILURE, errno, "%s", quotef (infile));\n<line7>if (! (STREQ (outfile, "-") || freopen (outfile, "w", stdout)))\n<line8>error (EXIT_FAILURE, errno, "%s", quotef (outfile));\n<line9>fadvise (stdin, FADVISE_SEQUENTIAL);\n<line10>thisline = &lb1;\n<line11>prevline = &lb2;\n<line12>initbuffer (thisline);\n<line13>initbuffer (prevline);\n<line14>/* The duplication in the following 'if' and 'else' blocks is an\n<line15>optimization to distinguish between when we can print input\n<line16>lines immediately (1. & 2.) or not.\n<line17>1. --group => all input lines are printed.\n<line18>checking for unique/duplicated lines is used only for printing\n<line19>group separators.\n<line20>2. The default case in which none of these options has been specified:\n<line21>--count, --repeated,  --all-repeated, --unique\n<line22>In the default case, this optimization lets uniq output each different\n<line23>line right away, without waiting to see if the next one is different.\n<line24>3. All other cases.\n<line25>*/\n<line26>if (output_unique && output_first_repeated && countmode == count_none)\n<line27>{\n<line28>char *prevfield = nullptr;\n<line29>size_t prevlen;\n<line30>bool first_group_printed = false;\n<line31>while (!feof (stdin))\n<line32>{\n<line33>char *thisfield;\n<line34>size_t thislen;\n<line35>bool new_group;\n<line36>if (readlinebuffer_delim (thisline, stdin, delimiter) == 0)\n<line37>break;\n<line38>thisfield = find_field (thisline);\n<line39>thislen = thisline->length - 1 - (thisfield - thisline->buffer);\n<line40>new_group = (!prevfield\n<line41>|| different (thisfield, prevfield, thislen, prevlen));\n<line42>if (new_group && grouping != GM_NONE\n<line43>&& (grouping == GM_PREPEND || grouping == GM_BOTH\n<line44>|| (first_group_printed && (grouping == GM_APPEND\n<line45>|| grouping == GM_SEPARATE))))\n<line46>putchar (delimiter);\n<line47>if (new_group || grouping != GM_NONE)\n<line48>{\n<line49>if (fwrite (thisline->buffer, sizeof (char), thisline->length,\n<line50>stdout) != thisline->length)\n<line51>write_error ();\n<line52>SWAP_LINES (prevline, thisline);\n<line53>prevfield = thisfield;\n<line54>prevlen = thislen;\n<line55>first_group_printed = true;\n<line56>}\n<line57>}\n<line58>if ((grouping == GM_BOTH || grouping == GM_APPEND) && first_group_printed)\n<line59>putchar (delimiter);\n<line60>}\n<line61>else\n<line62>{\n<line63>char *prevfield;\n<line64>size_t prevlen;\n<line65>uintmax_t match_count = 0;\n<line66>bool first_delimiter = true;\n<line67>if (readlinebuffer_delim (prevline, stdin, delimiter) == 0)\n<line68>goto closefiles;\n<line69>prevfield = find_field (prevline);\n<line70>prevlen = prevline->length - 1 - (prevfield - prevline->buffer);\n<line71>while (!feof (stdin))\n<line72>{\n<line73>bool match;\n<line74>char *thisfield;\n<line75>size_t thislen;\n<line76>if (readlinebuffer_delim (thisline, stdin, delimiter) == 0)\n<line77>{\n<line78>if (ferror (stdin))\n<line79>goto closefiles;\n<line80>break;\n<line81>}\n<line82>thisfield = find_field (thisline);\n<line83>thislen = thisline->length - 1 - (thisfield - thisline->buffer);\n<line84>match = !different (thisfield, prevfield, thislen, prevlen);\n<line85>match_count += match;\n<line86>if (match_count == UINTMAX_MAX)\n<line87>{\n<line88>if (count_occurrences)\n<line89>error (EXIT_FAILURE, 0, _("too many repeated lines"));\n<line90>match_count--;\n<line91>}\n<line92>if (delimit_groups != DM_NONE)\n<line93>{\n<line94>if (!match)\n<line95>{\n<line96>if (match_count) /* a previous match */\n<line97>first_delimiter = false; /* Only used when DM_SEPARATE */\n<line98>}\n<line99>else if (match_count == 1)\n<line100>{\n<line101>if ((delimit_groups == DM_PREPEND)\n<line102>|| (delimit_groups == DM_SEPARATE\n<line103>&& !first_delimiter))\n<line104>putchar (delimiter);\n<line105>}\n<line106>}\n<line107>if (!match || output_later_repeated)\n<line108>{\n<line109>writeline (prevline, match, match_count);\n<line110>SWAP_LINES (prevline, thisline);\n<line111>prevfield = thisfield;\n<line112>prevlen = thislen;\n<line113>if (!match)\n<line114>match_count = 0;\n<line115>}\n<line116>}\n<line117>writeline (prevline, false, match_count);\n<line118>}\n<line119>closefiles:\n<line120>if (ferror (stdin) || fclose (stdin) != 0)\n<line121>error (EXIT_FAILURE, errno, _("error reading %s"), quoteaf (infile));\n<line122>/* stdout is handled via the atexit-invoked close_stdout function.  */\n<line123>free (lb1.buffer);\n<line124>free (lb2.buffer);\n<line125>}
----------------------------------------
Function: main
Content: <line0>int\n<line1>main (int argc, char **argv)\n<line2>{\n<line3>int optc = 0;\n<line4>bool posixly_correct = (getenv ("POSIXLY_CORRECT") != nullptr);\n<line5>enum Skip_field_option_type skip_field_option_type = SFO_NONE;\n<line6>unsigned int nfiles = 0;\n<line7>char const *file[2];\n<line8>char delimiter = '\n';	/* change with --zero-terminated, -z */\n<line9>bool output_option_used = false;   /* if true, one of -u/-d/-D/-c was used */\n<line10>file[0] = file[1] = "-";\n<line11>initialize_main (&argc, &argv);\n<line12>set_program_name (argv[0]);\n<line13>setlocale (LC_ALL, "");\n<line14>bindtextdomain (PACKAGE, LOCALEDIR);\n<line15>textdomain (PACKAGE);\n<line16>atexit (close_stdout);\n<line17>skip_chars = 0;\n<line18>skip_fields = 0;\n<line19>check_chars = SIZE_MAX;\n<line20>output_unique = output_first_repeated = true;\n<line21>output_later_repeated = false;\n<line22>countmode = count_none;\n<line23>delimit_groups = DM_NONE;\n<line24>while (true)\n<line25>{\n<line26>/* Parse an operand with leading "+" as a file after "--" was\n<line27>seen; or if pedantic and a file was seen; or if not\n<line28>obsolete.  */\n<line29>if (optc == -1\n<line30>|| (posixly_correct && nfiles != 0)\n<line31>|| ((optc = getopt_long (argc, argv,\n<line32>"-0123456789Dcdf:is:uw:z",\n<line33>longopts, nullptr))\n<line34>== -1))\n<line35>{\n<line36>if (argc <= optind)\n<line37>break;\n<line38>if (nfiles == 2)\n<line39>{\n<line40>error (0, 0, _("extra operand %s"), quote (argv[optind]));\n<line41>usage (EXIT_FAILURE);\n<line42>}\n<line43>file[nfiles++] = argv[optind++];\n<line44>}\n<line45>else switch (optc)\n<line46>{\n<line47>case 1:\n<line48>{\n<line49>uintmax_t size;\n<line50>if (optarg[0] == '+'\n<line51>&& ! strict_posix2 ()\n<line52>&& xstrtoumax (optarg, nullptr, 10, &size, "") == LONGINT_OK\n<line53>&& size <= SIZE_MAX)\n<line54>skip_chars = size;\n<line55>else if (nfiles == 2)\n<line56>{\n<line57>error (0, 0, _("extra operand %s"), quote (optarg));\n<line58>usage (EXIT_FAILURE);\n<line59>}\n<line60>else\n<line61>file[nfiles++] = optarg;\n<line62>}\n<line63>break;\n<line64>case '0':\n<line65>case '1':\n<line66>case '2':\n<line67>case '3':\n<line68>case '4':\n<line69>case '5':\n<line70>case '6':\n<line71>case '7':\n<line72>case '8':\n<line73>case '9':\n<line74>{\n<line75>if (skip_field_option_type == SFO_NEW)\n<line76>skip_fields = 0;\n<line77>if (!DECIMAL_DIGIT_ACCUMULATE (skip_fields, optc - '0', size_t))\n<line78>skip_fields = SIZE_MAX;\n<line79>skip_field_option_type = SFO_OBSOLETE;\n<line80>}\n<line81>break;\n<line82>case 'c':\n<line83>countmode = count_occurrences;\n<line84>output_option_used = true;\n<line85>break;\n<line86>case 'd':\n<line87>output_unique = false;\n<line88>output_option_used = true;\n<line89>break;\n<line90>case 'D':\n<line91>output_unique = false;\n<line92>output_later_repeated = true;\n<line93>if (optarg == nullptr)\n<line94>delimit_groups = DM_NONE;\n<line95>else\n<line96>delimit_groups = XARGMATCH ("--all-repeated", optarg,\n<line97>delimit_method_string,\n<line98>delimit_method_map);\n<line99>output_option_used = true;\n<line100>break;\n<line101>case GROUP_OPTION:\n<line102>if (optarg == nullptr)\n<line103>grouping = GM_SEPARATE;\n<line104>else\n<line105>grouping = XARGMATCH ("--group", optarg,\n<line106>grouping_method_string,\n<line107>grouping_method_map);\n<line108>break;\n<line109>case 'f':\n<line110>skip_field_option_type = SFO_NEW;\n<line111>skip_fields = size_opt (optarg,\n<line112>N_("invalid number of fields to skip"));\n<line113>break;\n<line114>case 'i':\n<line115>ignore_case = true;\n<line116>break;\n<line117>case 's':\n<line118>skip_chars = size_opt (optarg,\n<line119>N_("invalid number of bytes to skip"));\n<line120>break;\n<line121>case 'u':\n<line122>output_first_repeated = false;\n<line123>output_option_used = true;\n<line124>break;\n<line125>case 'w':\n<line126>check_chars = size_opt (optarg,\n<line127>N_("invalid number of bytes to compare"));\n<line128>break;\n<line129>case 'z':\n<line130>delimiter = '\0';\n<line131>break;\n<line132>case_GETOPT_HELP_CHAR;\n<line133>case_GETOPT_VERSION_CHAR (PROGRAM_NAME, AUTHORS);\n<line134>default:\n<line135>usage (EXIT_FAILURE);\n<line136>}\n<line137>}\n<line138>/* Note we could allow --group with -D at least, and that would\n<line139>avoid the need to specify a grouping method to --all-repeated.\n<line140>It was thought best to avoid deprecating those parameters though\n<line141>and keep --group separate to other options.  */\n<line142>if (grouping != GM_NONE && output_option_used)\n<line143>{\n<line144>error (0, 0, _("--group is mutually exclusive with -c/-d/-D/-u"));\n<line145>usage (EXIT_FAILURE);\n<line146>}\n<line147>if (grouping != GM_NONE && countmode != count_none)\n<line148>{\n<line149>error (0, 0,\n<line150>_("grouping and printing repeat counts is meaningless"));\n<line151>usage (EXIT_FAILURE);\n<line152>}\n<line153>if (countmode == count_occurrences && output_later_repeated)\n<line154>{\n<line155>error (0, 0,\n<line156>_("printing all duplicated lines and repeat counts is meaningless"));\n<line157>usage (EXIT_FAILURE);\n<line158>}\n<line159>check_file (file[0], file[1], delimiter);\n<line160>return EXIT_SUCCESS;\n<line161>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/src/unlink.c
========================================
Function: usage
Content: <line0>void\n<line1>usage (int status)\n<line2>{\n<line3>if (status != EXIT_SUCCESS)\n<line4>emit_try_help ();\n<line5>else\n<line6>{\n<line7>printf (_("\\n<line8>Usage: %s FILE\n\\n<line9>or:  %s OPTION\n"), program_name, program_name);\n<line10>fputs (_("Call the unlink function to remove the specified FILE.\n\n"),\n<line11>stdout);\n<line12>fputs (HELP_OPTION_DESCRIPTION, stdout);\n<line13>fputs (VERSION_OPTION_DESCRIPTION, stdout);\n<line14>emit_ancillary_info (PROGRAM_NAME);\n<line15>}\n<line16>exit (status);\n<line17>}
----------------------------------------
Function: main
Content: <line0>int\n<line1>main (int argc, char **argv)\n<line2>{\n<line3>initialize_main (&argc, &argv);\n<line4>set_program_name (argv[0]);\n<line5>setlocale (LC_ALL, "");\n<line6>bindtextdomain (PACKAGE, LOCALEDIR);\n<line7>textdomain (PACKAGE);\n<line8>atexit (close_stdout);\n<line9>parse_gnu_standard_options_only (argc, argv, PROGRAM_NAME, PACKAGE_NAME,\n<line10>Version, true, usage, AUTHORS,\n<line11>(char const *) nullptr);\n<line12>if (argc < optind + 1)\n<line13>{\n<line14>error (0, 0, _("missing operand"));\n<line15>usage (EXIT_FAILURE);\n<line16>}\n<line17>if (optind + 1 < argc)\n<line18>{\n<line19>error (0, 0, _("extra operand %s"), quote (argv[optind + 1]));\n<line20>usage (EXIT_FAILURE);\n<line21>}\n<line22>if (unlink (argv[optind]) != 0)\n<line23>error (EXIT_FAILURE, errno, _("cannot unlink %s"), quoteaf (argv[optind]));\n<line24>return EXIT_SUCCESS;\n<line25>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/src/uptime.c
========================================
Function: print_uptime
Content: <line0>static int\n<line1>print_uptime (idx_t n, struct gl_utmp const *utmp_buf)\n<line2>{\n<line3>int status = EXIT_SUCCESS;\n<line4>time_t boot_time = 0;\n<line5>/* Loop through all the utmp entries we just read and count up the valid\n<line6>ones, also in the process possibly gleaning boottime. */\n<line7>idx_t entries = 0;\n<line8>for (idx_t i = 0; i < n; i++)\n<line9>{\n<line10>struct gl_utmp const *this = &utmp_buf[i];\n<line11>entries += IS_USER_PROCESS (this);\n<line12>if (UT_TYPE_BOOT_TIME (this))\n<line13>boot_time = this->ut_ts.tv_sec;\n<line14>}\n<line15>/* The gnulib module 'readutmp' is supposed to provide a BOOT_TIME entry\n<line16>on all platforms.  */\n<line17>if (boot_time == 0)\n<line18>{\n<line19>error (0, errno, _("couldn't get boot time"));\n<line20>status = EXIT_FAILURE;\n<line21>}\n<line22>time_t time_now = time (nullptr);\n<line23>struct tm *tmn = time_now == (time_t) -1 ? nullptr : localtime (&time_now);\n<line24>/* procps' version of uptime also prints the seconds field, but\n<line25>previous versions of coreutils don't. */\n<line26>if (tmn)\n<line27>/* TRANSLATORS: This prints the current clock time. */\n<line28>fprintftime (stdout, _(" %H:%M:%S  "), tmn, 0, 0);\n<line29>else\n<line30>{\n<line31>printf (_(" ??:????  "));\n<line32>status = EXIT_FAILURE;\n<line33>}\n<line34>intmax_t uptime;\n<line35>if (time_now == (time_t) -1 || boot_time == 0\n<line36>|| ckd_sub (&uptime, time_now, boot_time) || uptime < 0)\n<line37>{\n<line38>printf (_("up ???? days ??:??,  "));\n<line39>status = EXIT_FAILURE;\n<line40>}\n<line41>else\n<line42>{\n<line43>intmax_t updays = uptime / 86400;\n<line44>int uphours = uptime % 86400 / 3600;\n<line45>int upmins = uptime % 86400 % 3600 / 60;\n<line46>if (0 < updays)\n<line47>printf (ngettext ("up %"PRIdMAX" day %2d:%02d,  ",\n<line48>"up %"PRIdMAX" days %2d:%02d,  ",\n<line49>select_plural (updays)),\n<line50>updays, uphours, upmins);\n<line51>else\n<line52>printf (_("up  %2d:%02d,  "), uphours, upmins);\n<line53>}\n<line54>printf (ngettext ("%td user", "%td users", select_plural (entries)),\n<line55>entries);\n<line56>double avg[3];\n<line57>int loads = getloadavg (avg, 3);\n<line58>if (loads == -1)\n<line59>putchar ('\n');\n<line60>else\n<line61>{\n<line62>if (loads > 0)\n<line63>printf (_(",  load average: %.2f"), avg[0]);\n<line64>if (loads > 1)\n<line65>printf (", %.2f", avg[1]);\n<line66>if (loads > 2)\n<line67>printf (", %.2f", avg[2]);\n<line68>if (loads > 0)\n<line69>putchar ('\n');\n<line70>}\n<line71>return status;\n<line72>}
----------------------------------------
Function: uptime
Content: <line0>static _Noreturn void\n<line1>uptime (char const *filename, int options)\n<line2>{\n<line3>idx_t n_users;\n<line4>struct gl_utmp *utmp_buf;\n<line5>int read_utmp_status = (read_utmp (filename, &n_users, &utmp_buf, options) < 0\n<line6>? EXIT_FAILURE : EXIT_SUCCESS);\n<line7>if (read_utmp_status != EXIT_SUCCESS)\n<line8>{\n<line9>error (0, errno, "%s", quotef (filename));\n<line10>n_users = 0;\n<line11>utmp_buf = nullptr;\n<line12>}\n<line13>int print_uptime_status = print_uptime (n_users, utmp_buf);\n<line14>exit (MAX (read_utmp_status, print_uptime_status));\n<line15>}
----------------------------------------
Function: usage
Content: <line0>void\n<line1>usage (int status)\n<line2>{\n<line3>if (status != EXIT_SUCCESS)\n<line4>emit_try_help ();\n<line5>else\n<line6>{\n<line7>printf (_("Usage: %s [OPTION]... [FILE]\n"), program_name);\n<line8>printf (_("\\n<line9>Print the current time, the length of time the system has been up,\n\\n<line10>the number of users on the system, and the average number of jobs\n\\n<line11>in the run queue over the last 1, 5 and 15 minutes."));\n<line12>#ifdef __linux__\n<line13>/* It would be better to introduce a configure test for this,\n<line14>but such a test is hard to write.  For the moment then, we\n<line15>have a hack which depends on the preprocessor used at compile\n<line16>time to tell us what the running kernel is.  Ugh.  */\n<line17>printf (_("  \\n<line18>Processes in\n\\n<line19>an uninterruptible sleep state also contribute to the load average.\n"));\n<line20>#else\n<line21>printf (_("\n"));\n<line22>#endif\n<line23>printf (_("\\n<line24>If FILE is not specified, use %s.  %s as FILE is common.\n\\n<line25>\n"),\n<line26>UTMP_FILE, WTMP_FILE);\n<line27>fputs (HELP_OPTION_DESCRIPTION, stdout);\n<line28>fputs (VERSION_OPTION_DESCRIPTION, stdout);\n<line29>emit_ancillary_info (PROGRAM_NAME);\n<line30>}\n<line31>exit (status);\n<line32>}
----------------------------------------
Function: main
Content: <line0>int\n<line1>main (int argc, char **argv)\n<line2>{\n<line3>initialize_main (&argc, &argv);\n<line4>set_program_name (argv[0]);\n<line5>setlocale (LC_ALL, "");\n<line6>bindtextdomain (PACKAGE, LOCALEDIR);\n<line7>textdomain (PACKAGE);\n<line8>atexit (close_stdout);\n<line9>parse_gnu_standard_options_only (argc, argv, PROGRAM_NAME, PACKAGE_NAME,\n<line10>Version, true, usage, AUTHORS,\n<line11>(char const *) nullptr);\n<line12>switch (argc - optind)\n<line13>{\n<line14>case 0:			/* uptime */\n<line15>uptime (UTMP_FILE, READ_UTMP_CHECK_PIDS);\n<line16>break;\n<line17>case 1:			/* uptime <utmp file> */\n<line18>uptime (argv[optind], 0);\n<line19>break;\n<line20>default:			/* lose */\n<line21>error (0, 0, _("extra operand %s"), quote (argv[optind + 1]));\n<line22>usage (EXIT_FAILURE);\n<line23>}\n<line24>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/src/ls-vdir.c
========================================
========================================
/home/huihui/Downloads/coreutils-9.4/src/wc.c
========================================
/home/huihui/Downloads/coreutils-9.4/src/wc.c:143:1: warning: '_Static_assert' with no message is a C2x extension [-Wc2x-extensions]
ARGMATCH_VERIFY (total_args, total_types);
^
./lib/argmatch.h:49:54: note: expanded from macro 'ARGMATCH_VERIFY'
                   == ARRAY_CARDINALITY (Vallist) + 1)
                                                     ^
1 warning generated.
Function: avx2_supported
Content: <line0>static bool\n<line1>avx2_supported (void)\n<line2>{\n<line3>bool avx_enabled = 0 < __builtin_cpu_supports ("avx2");\n<line4>if (debug)\n<line5>error (0, 0, (avx_enabled\n<line6>? _("using avx2 hardware support")\n<line7>: _("avx2 support not detected")));\n<line8>return avx_enabled;\n<line9>}
----------------------------------------
Function: usage
Content: <line0>void\n<line1>usage (int status)\n<line2>{\n<line3>if (status != EXIT_SUCCESS)\n<line4>emit_try_help ();\n<line5>else\n<line6>{\n<line7>printf (_("\\n<line8>Usage: %s [OPTION]... [FILE]...\n\\n<line9>or:  %s [OPTION]... --files0-from=F\n\\n<line10>"),\n<line11>program_name, program_name);\n<line12>fputs (_("\\n<line13>Print newline, word, and byte counts for each FILE, and a total line if\n\\n<line14>more than one FILE is specified.  A word is a non-zero-length sequence of\n\\n<line15>printable characters delimited by white space.\n\\n<line16>"), stdout);\n<line17>emit_stdin_note ();\n<line18>fputs (_("\\n<line19>\n\\n<line20>The options below may be used to select which counts are printed, always in\n\\n<line21>the following order: newline, word, character, byte, maximum line length.\n\\n<line22>-c, --bytes            print the byte counts\n\\n<line23>-m, --chars            print the character counts\n\\n<line24>-l, --lines            print the newline counts\n\\n<line25>"), stdout);\n<line26>fputs (_("\\n<line27>--files0-from=F    read input from the files specified by\n\\n<line28>NUL-terminated names in file F;\n\\n<line29>If F is - then read names from standard input\n\\n<line30>-L, --max-line-length  print the maximum display width\n\\n<line31>-w, --words            print the word counts\n\\n<line32>"), stdout);\n<line33>fputs (_("\\n<line34>--total=WHEN       when to print a line with total counts;\n\\n<line35>WHEN can be: auto, always, only, never\n\\n<line36>"), stdout);\n<line37>fputs (HELP_OPTION_DESCRIPTION, stdout);\n<line38>fputs (VERSION_OPTION_DESCRIPTION, stdout);\n<line39>emit_ancillary_info (PROGRAM_NAME);\n<line40>}\n<line41>exit (status);\n<line42>}
----------------------------------------
Function: isnbspace
Content: <line0>static int\n<line1>isnbspace (int c)\n<line2>{\n<line3>return iswnbspace (btowc (c));\n<line4>}
----------------------------------------
Function: write_counts
Content: <line0>static void\n<line1>write_counts (uintmax_t lines,\n<line2>uintmax_t words,\n<line3>uintmax_t chars,\n<line4>uintmax_t bytes,\n<line5>uintmax_t linelength,\n<line6>char const *file)\n<line7>{\n<line8>static char const format_sp_int[] = " %*s";\n<line9>char const *format_int = format_sp_int + 1;\n<line10>char buf[INT_BUFSIZE_BOUND (uintmax_t)];\n<line11>if (print_lines)\n<line12>{\n<line13>printf (format_int, number_width, umaxtostr (lines, buf));\n<line14>format_int = format_sp_int;\n<line15>}\n<line16>if (print_words)\n<line17>{\n<line18>printf (format_int, number_width, umaxtostr (words, buf));\n<line19>format_int = format_sp_int;\n<line20>}\n<line21>if (print_chars)\n<line22>{\n<line23>printf (format_int, number_width, umaxtostr (chars, buf));\n<line24>format_int = format_sp_int;\n<line25>}\n<line26>if (print_bytes)\n<line27>{\n<line28>printf (format_int, number_width, umaxtostr (bytes, buf));\n<line29>format_int = format_sp_int;\n<line30>}\n<line31>if (print_linelength)\n<line32>{\n<line33>printf (format_int, number_width, umaxtostr (linelength, buf));\n<line34>}\n<line35>if (file)\n<line36>printf (" %s", strchr (file, '\n') ? quotef (file) : file);\n<line37>putchar ('\n');\n<line38>}
----------------------------------------
Function: wc_lines
Content: <line0>static bool\n<line1>wc_lines (char const *file, int fd, uintmax_t *lines_out, uintmax_t *bytes_out)\n<line2>{\n<line3>size_t bytes_read;\n<line4>uintmax_t lines, bytes;\n<line5>char buf[BUFFER_SIZE + 1];\n<line6>bool long_lines = false;\n<line7>if (!lines_out || !bytes_out)\n<line8>{\n<line9>return false;\n<line10>}\n<line11>lines = bytes = 0;\n<line12>while ((bytes_read = safe_read (fd, buf, BUFFER_SIZE)) > 0)\n<line13>{\n<line14>if (bytes_read == SAFE_READ_ERROR)\n<line15>{\n<line16>error (0, errno, "%s", quotef (file));\n<line17>return false;\n<line18>}\n<line19>bytes += bytes_read;\n<line20>char *p = buf;\n<line21>char *end = buf + bytes_read;\n<line22>uintmax_t plines = lines;\n<line23>if (! long_lines)\n<line24>{\n<line25>/* Avoid function call overhead for shorter lines.  */\n<line26>while (p != end)\n<line27>lines += *p++ == '\n';\n<line28>}\n<line29>else\n<line30>{\n<line31>/* rawmemchr is more efficient with longer lines.  */\n<line32>*end = '\n';\n<line33>while ((p = rawmemchr (p, '\n')) < end)\n<line34>{\n<line35>++p;\n<line36>++lines;\n<line37>}\n<line38>}\n<line39>/* If the average line length in the block is >= 15, then use\n<line40>memchr for the next block, where system specific optimizations\n<line41>may outweigh function call overhead.\n<line42>FIXME: This line length was determined in 2015, on both\n<line43>x86_64 and ppc64, but it's worth re-evaluating in future with\n<line44>newer compilers, CPUs, or memchr() implementations etc.  */\n<line45>if (lines - plines <= bytes_read / 15)\n<line46>long_lines = true;\n<line47>else\n<line48>long_lines = false;\n<line49>}\n<line50>*bytes_out = bytes;\n<line51>*lines_out = lines;\n<line52>return true;\n<line53>}
----------------------------------------
Function: wc
Content: <line0>static bool\n<line1>wc (int fd, char const *file_x, struct fstatus *fstatus, off_t current_pos)\n<line2>{\n<line3>bool ok = true;\n<line4>char buf[BUFFER_SIZE + 1];\n<line5>size_t bytes_read;\n<line6>uintmax_t lines, words, chars, bytes, linelength;\n<line7>bool count_bytes, count_chars, count_complicated;\n<line8>char const *file = file_x ? file_x : _("standard input");\n<line9>lines = words = chars = bytes = linelength = 0;\n<line10>/* If in the current locale, chars are equivalent to bytes, we prefer\n<line11>counting bytes, because that's easier.  */\n<line12>#if MB_LEN_MAX > 1\n<line13>if (MB_CUR_MAX > 1)\n<line14>{\n<line15>count_bytes = print_bytes;\n<line16>count_chars = print_chars;\n<line17>}\n<line18>else\n<line19>#endif\n<line20>{\n<line21>count_bytes = print_bytes || print_chars;\n<line22>count_chars = false;\n<line23>}\n<line24>count_complicated = print_words || print_linelength;\n<line25>/* Advise the kernel of our access pattern only if we will read().  */\n<line26>if (!count_bytes || count_chars || print_lines || count_complicated)\n<line27>fdadvise (fd, 0, 0, FADVISE_SEQUENTIAL);\n<line28>/* When counting only bytes, save some line- and word-counting\n<line29>overhead.  If FD is a 'regular' Unix file, using lseek is enough\n<line30>to get its 'size' in bytes.  Otherwise, read blocks of BUFFER_SIZE\n<line31>bytes at a time until EOF.  Note that the 'size' (number of bytes)\n<line32>that wc reports is smaller than stats.st_size when the file is not\n<line33>positioned at its beginning.  That's why the lseek calls below are\n<line34>necessary.  For example the command\n<line35>'(dd ibs=99k skip=1 count=0; ./wc -c) < /etc/group'\n<line36>should make wc report '0' bytes.  */\n<line37>if (count_bytes && !count_chars && !print_lines && !count_complicated)\n<line38>{\n<line39>bool skip_read = false;\n<line40>if (0 < fstatus->failed)\n<line41>fstatus->failed = fstat (fd, &fstatus->st);\n<line42>/* For sized files, seek to one st_blksize before EOF rather than to EOF.\n<line43>This works better for files in proc-like file systems where\n<line44>the size is only approximate.  */\n<line45>if (! fstatus->failed && usable_st_size (&fstatus->st)\n<line46>&& 0 <= fstatus->st.st_size)\n<line47>{\n<line48>off_t end_pos = fstatus->st.st_size;\n<line49>if (current_pos < 0)\n<line50>current_pos = lseek (fd, 0, SEEK_CUR);\n<line51>if (end_pos % page_size)\n<line52>{\n<line53>/* We only need special handling of /proc and /sys files etc.\n<line54>when they're a multiple of PAGE_SIZE.  In the common case\n<line55>for files with st_size not a multiple of PAGE_SIZE,\n<line56>it's more efficient and accurate to use st_size.\n<line57>Be careful here.  The current position may actually be\n<line58>beyond the end of the file.  As in the example above.  */\n<line59>bytes = end_pos < current_pos ? 0 : end_pos - current_pos;\n<line60>if (bytes && 0 <= lseek (fd, bytes, SEEK_CUR))\n<line61>skip_read = true;\n<line62>else\n<line63>bytes = 0;\n<line64>}\n<line65>else\n<line66>{\n<line67>off_t hi_pos = end_pos - end_pos % (ST_BLKSIZE (fstatus->st) + 1);\n<line68>if (0 <= current_pos && current_pos < hi_pos\n<line69>&& 0 <= lseek (fd, hi_pos, SEEK_CUR))\n<line70>bytes = hi_pos - current_pos;\n<line71>}\n<line72>}\n<line73>if (! skip_read)\n<line74>{\n<line75>fdadvise (fd, 0, 0, FADVISE_SEQUENTIAL);\n<line76>while ((bytes_read = safe_read (fd, buf, BUFFER_SIZE)) > 0)\n<line77>{\n<line78>if (bytes_read == SAFE_READ_ERROR)\n<line79>{\n<line80>error (0, errno, "%s", quotef (file));\n<line81>ok = false;\n<line82>break;\n<line83>}\n<line84>bytes += bytes_read;\n<line85>}\n<line86>}\n<line87>}\n<line88>else if (!count_chars && !count_complicated)\n<line89>{\n<line90>#ifdef USE_AVX2_WC_LINECOUNT\n<line91>static bool (*wc_lines_p) (char const *, int, uintmax_t *, uintmax_t *);\n<line92>if (!wc_lines_p)\n<line93>wc_lines_p = avx2_supported () ? wc_lines_avx2 : wc_lines;\n<line94>#else\n<line95>bool (*wc_lines_p) (char const *, int, uintmax_t *, uintmax_t *)\n<line96>= wc_lines;\n<line97>#endif\n<line98>/* Use a separate loop when counting only lines or lines and bytes --\n<line99>but not chars or words.  */\n<line100>ok = wc_lines_p (file, fd, &lines, &bytes);\n<line101>}\n<line102>#if MB_LEN_MAX > 1\n<line103># define SUPPORT_OLD_MBRTOWC 1\n<line104>else if (MB_CUR_MAX > 1)\n<line105>{\n<line106>bool in_word = false;\n<line107>uintmax_t linepos = 0;\n<line108>mbstate_t state = { 0, };\n<line109>bool in_shift = false;\n<line110># if SUPPORT_OLD_MBRTOWC\n<line111>/* Back-up the state before each multibyte character conversion and\n<line112>move the last incomplete character of the buffer to the front\n<line113>of the buffer.  This is needed because we don't know whether\n<line114>the 'mbrtowc' function updates the state when it returns -2, --\n<line115>this is the ISO C 99 and glibc-2.2 behavior - or not - amended\n<line116>ANSI C, glibc-2.1 and Solaris 5.7 behavior.  We don't have an\n<line117>autoconf test for this, yet.  */\n<line118>size_t prev = 0; /* number of bytes carried over from previous round */\n<line119># else\n<line120>const size_t prev = 0;\n<line121># endif\n<line122>while ((bytes_read = safe_read (fd, buf + prev, BUFFER_SIZE - prev)) > 0)\n<line123>{\n<line124>char const *p;\n<line125># if SUPPORT_OLD_MBRTOWC\n<line126>mbstate_t backup_state;\n<line127># endif\n<line128>if (bytes_read == SAFE_READ_ERROR)\n<line129>{\n<line130>error (0, errno, "%s", quotef (file));\n<line131>ok = false;\n<line132>break;\n<line133>}\n<line134>bytes += bytes_read;\n<line135>p = buf;\n<line136>bytes_read += prev;\n<line137>do\n<line138>{\n<line139>wchar_t wide_char;\n<line140>size_t n;\n<line141>bool wide = true;\n<line142>if (!in_shift && is_basic (*p))\n<line143>{\n<line144>/* Handle most ASCII characters quickly, without calling\n<line145>mbrtowc().  */\n<line146>n = 1;\n<line147>wide_char = *p;\n<line148>wide = false;\n<line149>}\n<line150>else\n<line151>{\n<line152>in_shift = true;\n<line153># if SUPPORT_OLD_MBRTOWC\n<line154>backup_state = state;\n<line155># endif\n<line156>n = mbrtowc (&wide_char, p, bytes_read, &state);\n<line157>if (n == (size_t) -2)\n<line158>{\n<line159># if SUPPORT_OLD_MBRTOWC\n<line160>state = backup_state;\n<line161># endif\n<line162>break;\n<line163>}\n<line164>if (n == (size_t) -1)\n<line165>{\n<line166>/* Remember that we read a byte, but don't complain\n<line167>about the error.  Because of the decoding error,\n<line168>this is a considered to be byte but not a\n<line169>character (that is, chars is not incremented).  */\n<line170>p++;\n<line171>bytes_read--;\n<line172>continue;\n<line173>}\n<line174>if (mbsinit (&state))\n<line175>in_shift = false;\n<line176>if (n == 0)\n<line177>{\n<line178>wide_char = 0;\n<line179>n = 1;\n<line180>}\n<line181>}\n<line182>switch (wide_char)\n<line183>{\n<line184>case '\n':\n<line185>lines++;\n<line186>FALLTHROUGH;\n<line187>case '\r':\n<line188>case '\f':\n<line189>if (linepos > linelength)\n<line190>linelength = linepos;\n<line191>linepos = 0;\n<line192>goto mb_word_separator;\n<line193>case '\t':\n<line194>linepos += 8 - (linepos % 8);\n<line195>goto mb_word_separator;\n<line196>case ' ':\n<line197>linepos++;\n<line198>FALLTHROUGH;\n<line199>case '\v':\n<line200>mb_word_separator:\n<line201>words += in_word;\n<line202>in_word = false;\n<line203>break;\n<line204>default:\n<line205>if (wide && iswprint (wide_char))\n<line206>{\n<line207>/* wcwidth can be expensive on OSX for example,\n<line208>so avoid if not needed.  */\n<line209>if (print_linelength)\n<line210>{\n<line211>int width = wcwidth (wide_char);\n<line212>if (width > 0)\n<line213>linepos += width;\n<line214>}\n<line215>if (iswspace (wide_char) || iswnbspace (wide_char))\n<line216>goto mb_word_separator;\n<line217>in_word = true;\n<line218>}\n<line219>else if (!wide && isprint (to_uchar (*p)))\n<line220>{\n<line221>linepos++;\n<line222>if (isspace (to_uchar (*p)))\n<line223>goto mb_word_separator;\n<line224>in_word = true;\n<line225>}\n<line226>break;\n<line227>}\n<line228>p += n;\n<line229>bytes_read -= n;\n<line230>chars++;\n<line231>}\n<line232>while (bytes_read > 0);\n<line233># if SUPPORT_OLD_MBRTOWC\n<line234>if (bytes_read > 0)\n<line235>{\n<line236>if (bytes_read == BUFFER_SIZE)\n<line237>{\n<line238>/* Encountered a very long redundant shift sequence.  */\n<line239>p++;\n<line240>bytes_read--;\n<line241>}\n<line242>memmove (buf, p, bytes_read);\n<line243>}\n<line244>prev = bytes_read;\n<line245># endif\n<line246>}\n<line247>if (linepos > linelength)\n<line248>linelength = linepos;\n<line249>words += in_word;\n<line250>}\n<line251>#endif\n<line252>else\n<line253>{\n<line254>bool in_word = false;\n<line255>uintmax_t linepos = 0;\n<line256>while ((bytes_read = safe_read (fd, buf, BUFFER_SIZE)) > 0)\n<line257>{\n<line258>char const *p = buf;\n<line259>if (bytes_read == SAFE_READ_ERROR)\n<line260>{\n<line261>error (0, errno, "%s", quotef (file));\n<line262>ok = false;\n<line263>break;\n<line264>}\n<line265>bytes += bytes_read;\n<line266>do\n<line267>{\n<line268>switch (*p++)\n<line269>{\n<line270>case '\n':\n<line271>lines++;\n<line272>FALLTHROUGH;\n<line273>case '\r':\n<line274>case '\f':\n<line275>if (linepos > linelength)\n<line276>linelength = linepos;\n<line277>linepos = 0;\n<line278>goto word_separator;\n<line279>case '\t':\n<line280>linepos += 8 - (linepos % 8);\n<line281>goto word_separator;\n<line282>case ' ':\n<line283>linepos++;\n<line284>FALLTHROUGH;\n<line285>case '\v':\n<line286>word_separator:\n<line287>words += in_word;\n<line288>in_word = false;\n<line289>break;\n<line290>default:\n<line291>if (isprint (to_uchar (p[-1])))\n<line292>{\n<line293>linepos++;\n<line294>if (isspace (to_uchar (p[-1]))\n<line295>|| isnbspace (to_uchar (p[-1])))\n<line296>goto word_separator;\n<line297>in_word = true;\n<line298>}\n<line299>break;\n<line300>}\n<line301>}\n<line302>while (--bytes_read);\n<line303>}\n<line304>if (linepos > linelength)\n<line305>linelength = linepos;\n<line306>words += in_word;\n<line307>}\n<line308>if (count_chars < print_chars)\n<line309>chars = bytes;\n<line310>if (total_mode != total_only)\n<line311>write_counts (lines, words, chars, bytes, linelength, file_x);\n<line312>if (ckd_add (&total_lines, total_lines, lines))\n<line313>total_lines_overflow = true;\n<line314>if (ckd_add (&total_words, total_words, words))\n<line315>total_words_overflow = true;\n<line316>if (ckd_add (&total_chars, total_chars, chars))\n<line317>total_chars_overflow = true;\n<line318>if (ckd_add (&total_bytes, total_bytes, bytes))\n<line319>total_bytes_overflow = true;\n<line320>if (linelength > max_line_length)\n<line321>max_line_length = linelength;\n<line322>return ok;\n<line323>}
----------------------------------------
Function: wc_file
Content: <line0>static bool\n<line1>wc_file (char const *file, struct fstatus *fstatus)\n<line2>{\n<line3>if (! file || STREQ (file, "-"))\n<line4>{\n<line5>have_read_stdin = true;\n<line6>xset_binary_mode (STDIN_FILENO, O_BINARY);\n<line7>return wc (STDIN_FILENO, file, fstatus, -1);\n<line8>}\n<line9>else\n<line10>{\n<line11>int fd = open (file, O_RDONLY | O_BINARY);\n<line12>if (fd == -1)\n<line13>{\n<line14>error (0, errno, "%s", quotef (file));\n<line15>return false;\n<line16>}\n<line17>else\n<line18>{\n<line19>bool ok = wc (fd, file, fstatus, 0);\n<line20>if (close (fd) != 0)\n<line21>{\n<line22>error (0, errno, "%s", quotef (file));\n<line23>return false;\n<line24>}\n<line25>return ok;\n<line26>}\n<line27>}\n<line28>}
----------------------------------------
Function: get_input_fstatus
Content: <line0>static struct fstatus *\n<line1>get_input_fstatus (size_t nfiles, char *const *file)\n<line2>{\n<line3>struct fstatus *fstatus = xnmalloc (nfiles ? nfiles : 1, sizeof *fstatus);\n<line4>if (nfiles == 0\n<line5>|| (nfiles == 1\n<line6>&& ((print_lines + print_words + print_chars\n<line7>+ print_bytes + print_linelength)\n<line8>== 1)))\n<line9>fstatus[0].failed = 1;\n<line10>else\n<line11>{\n<line12>for (size_t i = 0; i < nfiles; i++)\n<line13>fstatus[i].failed = (! file[i] || STREQ (file[i], "-")\n<line14>? fstat (STDIN_FILENO, &fstatus[i].st)\n<line15>: stat (file[i], &fstatus[i].st));\n<line16>}\n<line17>return fstatus;\n<line18>}
----------------------------------------
Function: main
Content: <line0>int\n<line1>main (int argc, char **argv)\n<line2>{\n<line3>bool ok;\n<line4>int optc;\n<line5>size_t nfiles;\n<line6>char **files;\n<line7>char *files_from = nullptr;\n<line8>struct fstatus *fstatus;\n<line9>struct Tokens tok;\n<line10>initialize_main (&argc, &argv);\n<line11>set_program_name (argv[0]);\n<line12>setlocale (LC_ALL, "");\n<line13>bindtextdomain (PACKAGE, LOCALEDIR);\n<line14>textdomain (PACKAGE);\n<line15>atexit (close_stdout);\n<line16>page_size = getpagesize ();\n<line17>/* Line buffer stdout to ensure lines are written atomically and immediately\n<line18>so that processes running in parallel do not intersperse their output.  */\n<line19>setvbuf (stdout, nullptr, _IOLBF, 0);\n<line20>posixly_correct = (getenv ("POSIXLY_CORRECT") != nullptr);\n<line21>print_lines = print_words = print_chars = print_bytes = false;\n<line22>print_linelength = false;\n<line23>total_lines = total_words = total_chars = total_bytes = max_line_length = 0;\n<line24>while ((optc = getopt_long (argc, argv, "clLmw", longopts, nullptr)) != -1)\n<line25>switch (optc)\n<line26>{\n<line27>case 'c':\n<line28>print_bytes = true;\n<line29>break;\n<line30>case 'm':\n<line31>print_chars = true;\n<line32>break;\n<line33>case 'l':\n<line34>print_lines = true;\n<line35>break;\n<line36>case 'w':\n<line37>print_words = true;\n<line38>break;\n<line39>case 'L':\n<line40>print_linelength = true;\n<line41>break;\n<line42>case DEBUG_PROGRAM_OPTION:\n<line43>debug = true;\n<line44>break;\n<line45>case FILES0_FROM_OPTION:\n<line46>files_from = optarg;\n<line47>break;\n<line48>case TOTAL_OPTION:\n<line49>total_mode = XARGMATCH ("--total", optarg, total_args, total_types);\n<line50>break;\n<line51>case_GETOPT_HELP_CHAR;\n<line52>case_GETOPT_VERSION_CHAR (PROGRAM_NAME, AUTHORS);\n<line53>default:\n<line54>usage (EXIT_FAILURE);\n<line55>}\n<line56>if (! (print_lines || print_words || print_chars || print_bytes\n<line57>|| print_linelength))\n<line58>print_lines = print_words = print_bytes = true;\n<line59>bool read_tokens = false;\n<line60>struct argv_iterator *ai;\n<line61>if (files_from)\n<line62>{\n<line63>FILE *stream;\n<line64>/* When using --files0-from=F, you may not specify any files\n<line65>on the command-line.  */\n<line66>if (optind < argc)\n<line67>{\n<line68>error (0, 0, _("extra operand %s"), quoteaf (argv[optind]));\n<line69>fprintf (stderr, "%s\n",\n<line70>_("file operands cannot be combined with --files0-from"));\n<line71>usage (EXIT_FAILURE);\n<line72>}\n<line73>if (STREQ (files_from, "-"))\n<line74>stream = stdin;\n<line75>else\n<line76>{\n<line77>stream = fopen (files_from, "r");\n<line78>if (stream == nullptr)\n<line79>error (EXIT_FAILURE, errno, _("cannot open %s for reading"),\n<line80>quoteaf (files_from));\n<line81>}\n<line82>/* Read the file list into RAM if we can detect its size and that\n<line83>size is reasonable.  Otherwise, we'll read a name at a time.  */\n<line84>struct stat st;\n<line85>if (fstat (fileno (stream), &st) == 0\n<line86>&& S_ISREG (st.st_mode)\n<line87>&& st.st_size <= MIN (10 * 1024 * 1024, physmem_available () / 2))\n<line88>{\n<line89>read_tokens = true;\n<line90>readtokens0_init (&tok);\n<line91>if (! readtokens0 (stream, &tok) || fclose (stream) != 0)\n<line92>error (EXIT_FAILURE, 0, _("cannot read file names from %s"),\n<line93>quoteaf (files_from));\n<line94>files = tok.tok;\n<line95>nfiles = tok.n_tok;\n<line96>ai = argv_iter_init_argv (files);\n<line97>}\n<line98>else\n<line99>{\n<line100>files = nullptr;\n<line101>nfiles = 0;\n<line102>ai = argv_iter_init_stream (stream);\n<line103>}\n<line104>}\n<line105>else\n<line106>{\n<line107>static char *stdin_only[] = { nullptr };\n<line108>files = (optind < argc ? argv + optind : stdin_only);\n<line109>nfiles = (optind < argc ? argc - optind : 1);\n<line110>ai = argv_iter_init_argv (files);\n<line111>}\n<line112>if (!ai)\n<line113>xalloc_die ();\n<line114>fstatus = get_input_fstatus (nfiles, files);\n<line115>if (total_mode == total_only)\n<line116>number_width = 1;  /* No extra padding, since no alignment requirement.  */\n<line117>else\n<line118>number_width = compute_number_width (nfiles, fstatus);\n<line119>ok = true;\n<line120>for (int i = 0; /* */; i++)\n<line121>{\n<line122>bool skip_file = false;\n<line123>enum argv_iter_err ai_err;\n<line124>char *file_name = argv_iter (ai, &ai_err);\n<line125>if (!file_name)\n<line126>{\n<line127>switch (ai_err)\n<line128>{\n<line129>case AI_ERR_EOF:\n<line130>goto argv_iter_done;\n<line131>case AI_ERR_READ:\n<line132>error (0, errno, _("%s: read error"),\n<line133>quotef (files_from));\n<line134>ok = false;\n<line135>goto argv_iter_done;\n<line136>case AI_ERR_MEM:\n<line137>xalloc_die ();\n<line138>default:\n<line139>affirm (!"unexpected error code from argv_iter");\n<line140>}\n<line141>}\n<line142>if (files_from && STREQ (files_from, "-") && STREQ (file_name, "-"))\n<line143>{\n<line144>/* Give a better diagnostic in an unusual case:\n<line145>printf - | wc --files0-from=- */\n<line146>error (0, 0, _("when reading file names from stdin, "\n<line147>"no file name of %s allowed"),\n<line148>quoteaf (file_name));\n<line149>skip_file = true;\n<line150>}\n<line151>if (!file_name[0])\n<line152>{\n<line153>/* Diagnose a zero-length file name.  When it's one\n<line154>among many, knowing the record number may help.\n<line155>FIXME: currently print the record number only with\n<line156>--files0-from=FILE.  Maybe do it for argv, too?  */\n<line157>if (files_from == nullptr)\n<line158>error (0, 0, "%s", _("invalid zero-length file name"));\n<line159>else\n<line160>{\n<line161>/* Using the standard 'filename:line-number:' prefix here is\n<line162>not totally appropriate, since NUL is the separator, not NL,\n<line163>but it might be better than nothing.  */\n<line164>unsigned long int file_number = argv_iter_n_args (ai);\n<line165>error (0, 0, "%s:%lu: %s", quotef (files_from),\n<line166>file_number, _("invalid zero-length file name"));\n<line167>}\n<line168>skip_file = true;\n<line169>}\n<line170>if (skip_file)\n<line171>ok = false;\n<line172>else\n<line173>ok &= wc_file (file_name, &fstatus[nfiles ? i : 0]);\n<line174>if (! nfiles)\n<line175>fstatus[0].failed = 1;\n<line176>}\n<line177>argv_iter_done:\n<line178>/* No arguments on the command line is fine.  That means read from stdin.\n<line179>However, no arguments on the --files0-from input stream is an error\n<line180>means don't read anything.  */\n<line181>if (ok && !files_from && argv_iter_n_args (ai) == 0)\n<line182>ok &= wc_file (nullptr, &fstatus[0]);\n<line183>if (read_tokens)\n<line184>readtokens0_free (&tok);\n<line185>if (total_mode != total_never\n<line186>&& (total_mode != total_auto || 1 < argv_iter_n_args (ai)))\n<line187>{\n<line188>if (total_lines_overflow)\n<line189>{\n<line190>total_lines = UINTMAX_MAX;\n<line191>error (0, EOVERFLOW, _("total lines"));\n<line192>ok = false;\n<line193>}\n<line194>if (total_words_overflow)\n<line195>{\n<line196>total_words = UINTMAX_MAX;\n<line197>error (0, EOVERFLOW, _("total words"));\n<line198>ok = false;\n<line199>}\n<line200>if (total_chars_overflow)\n<line201>{\n<line202>total_chars = UINTMAX_MAX;\n<line203>error (0, EOVERFLOW, _("total characters"));\n<line204>ok = false;\n<line205>}\n<line206>if (total_bytes_overflow)\n<line207>{\n<line208>total_bytes = UINTMAX_MAX;\n<line209>error (0, EOVERFLOW, _("total bytes"));\n<line210>ok = false;\n<line211>}\n<line212>write_counts (total_lines, total_words, total_chars, total_bytes,\n<line213>max_line_length,\n<line214>total_mode != total_only ? _("total") : nullptr);\n<line215>}\n<line216>argv_iter_free (ai);\n<line217>free (fstatus);\n<line218>if (have_read_stdin && close (STDIN_FILENO) != 0)\n<line219>error (EXIT_FAILURE, errno, "-");\n<line220>return ok ? EXIT_SUCCESS : EXIT_FAILURE;\n<line221>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/src/wc_avx2.c
========================================
Function: wc_lines_avx2
Content: <line0>extern bool\n<line1>wc_lines_avx2 (char const *file, int fd, uintmax_t *lines_out,\n<line2>uintmax_t *bytes_out)\n<line3>{\n<line4>__m256i accumulator;\n<line5>__m256i accumulator2;\n<line6>__m256i zeroes;\n<line7>__m256i endlines;\n<line8>__m256i avx_buf[BUFSIZE / sizeof (__m256i)];\n<line9>__m256i *datap;\n<line10>uintmax_t lines = 0;\n<line11>uintmax_t bytes = 0;\n<line12>size_t bytes_read = 0;\n<line13>if (!lines_out || !bytes_out)\n<line14>return false;\n<line15>/* Using two parallel accumulators gave a good performance increase.\n<line16>Adding a third gave no additional benefit, at least on an\n<line17>Intel Xeon E3-1231v3.  Maybe on a newer CPU with additional vector\n<line18>execution engines it would be a win. */\n<line19>accumulator = _mm256_setzero_si256 ();\n<line20>accumulator2 = _mm256_setzero_si256 ();\n<line21>zeroes = _mm256_setzero_si256 ();\n<line22>endlines = _mm256_set1_epi8 ('\n');\n<line23>while ((bytes_read = safe_read (fd, avx_buf, sizeof (avx_buf))) > 0)\n<line24>{\n<line25>__m256i to_match;\n<line26>__m256i to_match2;\n<line27>__m256i matches;\n<line28>__m256i matches2;\n<line29>if (bytes_read == SAFE_READ_ERROR)\n<line30>{\n<line31>error (0, errno, "%s", quotef (file));\n<line32>return false;\n<line33>}\n<line34>bytes += bytes_read;\n<line35>datap = avx_buf;\n<line36>char *end = ((char *)avx_buf) + bytes_read;\n<line37>while (bytes_read >= 64)\n<line38>{\n<line39>to_match = _mm256_load_si256 (datap);\n<line40>to_match2 = _mm256_load_si256 (datap + 1);\n<line41>matches = _mm256_cmpeq_epi8 (to_match, endlines);\n<line42>matches2 = _mm256_cmpeq_epi8 (to_match2, endlines);\n<line43>/* Compare will set each 8 bit integer in the register to 0xFF\n<line44>on match.  When we subtract it the 8 bit accumulators\n<line45>will underflow, so this is equal to adding 1. */\n<line46>accumulator = _mm256_sub_epi8 (accumulator, matches);\n<line47>accumulator2 = _mm256_sub_epi8 (accumulator2, matches2);\n<line48>datap += 2;\n<line49>bytes_read -= 64;\n<line50>}\n<line51>/* Horizontally add all 8 bit integers in the register,\n<line52>and then reset it */\n<line53>accumulator = _mm256_sad_epu8 (accumulator, zeroes);\n<line54>lines +=   _mm256_extract_epi16 (accumulator, 0)\n<line55>+ _mm256_extract_epi16 (accumulator, 4)\n<line56>+ _mm256_extract_epi16 (accumulator, 8)\n<line57>+ _mm256_extract_epi16 (accumulator, 12);\n<line58>accumulator = _mm256_setzero_si256 ();\n<line59>accumulator2 = _mm256_sad_epu8 (accumulator2, zeroes);\n<line60>lines +=   _mm256_extract_epi16 (accumulator2, 0)\n<line61>+ _mm256_extract_epi16 (accumulator2, 4)\n<line62>+ _mm256_extract_epi16 (accumulator2, 8)\n<line63>+ _mm256_extract_epi16 (accumulator2, 12);\n<line64>accumulator2 = _mm256_setzero_si256 ();\n<line65>/* Finish up any left over bytes */\n<line66>char *p = (char *)datap;\n<line67>while (p != end)\n<line68>lines += *p++ == '\n';\n<line69>}\n<line70>*lines_out = lines;\n<line71>*bytes_out = bytes;\n<line72>return true;\n<line73>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/src/whoami.c
========================================
Function: usage
Content: <line0>void\n<line1>usage (int status)\n<line2>{\n<line3>if (status != EXIT_SUCCESS)\n<line4>emit_try_help ();\n<line5>else\n<line6>{\n<line7>printf (_("Usage: %s [OPTION]...\n"), program_name);\n<line8>fputs (_("\\n<line9>Print the user name associated with the current effective user ID.\n\\n<line10>Same as id -un.\n\\n<line11>\n\\n<line12>"), stdout);\n<line13>fputs (HELP_OPTION_DESCRIPTION, stdout);\n<line14>fputs (VERSION_OPTION_DESCRIPTION, stdout);\n<line15>emit_ancillary_info (PROGRAM_NAME);\n<line16>}\n<line17>exit (status);\n<line18>}
----------------------------------------
Function: main
Content: <line0>int\n<line1>main (int argc, char **argv)\n<line2>{\n<line3>struct passwd *pw;\n<line4>uid_t uid;\n<line5>uid_t NO_UID = -1;\n<line6>initialize_main (&argc, &argv);\n<line7>set_program_name (argv[0]);\n<line8>setlocale (LC_ALL, "");\n<line9>bindtextdomain (PACKAGE, LOCALEDIR);\n<line10>textdomain (PACKAGE);\n<line11>atexit (close_stdout);\n<line12>parse_gnu_standard_options_only (argc, argv, PROGRAM_NAME, PACKAGE_NAME,\n<line13>Version, true, usage, AUTHORS,\n<line14>(char const *) nullptr);\n<line15>if (optind != argc)\n<line16>{\n<line17>error (0, 0, _("extra operand %s"), quote (argv[optind]));\n<line18>usage (EXIT_FAILURE);\n<line19>}\n<line20>errno = 0;\n<line21>uid = geteuid ();\n<line22>pw = uid == NO_UID && errno ? nullptr : getpwuid (uid);\n<line23>if (!pw)\n<line24>error (EXIT_FAILURE, errno, _("cannot find name for user ID %lu"),\n<line25>(unsigned long int) uid);\n<line26>puts (pw->pw_name);\n<line27>return EXIT_SUCCESS;\n<line28>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/src/yes.c
========================================
Function: usage
Content: <line0>void\n<line1>usage (int status)\n<line2>{\n<line3>if (status != EXIT_SUCCESS)\n<line4>emit_try_help ();\n<line5>else\n<line6>{\n<line7>printf (_("\\n<line8>Usage: %s [STRING]...\n\\n<line9>or:  %s OPTION\n\\n<line10>"),\n<line11>program_name, program_name);\n<line12>fputs (_("\\n<line13>Repeatedly output a line with all specified STRING(s), or 'y'.\n\\n<line14>\n\\n<line15>"), stdout);\n<line16>fputs (HELP_OPTION_DESCRIPTION, stdout);\n<line17>fputs (VERSION_OPTION_DESCRIPTION, stdout);\n<line18>emit_ancillary_info (PROGRAM_NAME);\n<line19>}\n<line20>exit (status);\n<line21>}
----------------------------------------
Function: main
Content: <line0>int\n<line1>main (int argc, char **argv)\n<line2>{\n<line3>initialize_main (&argc, &argv);\n<line4>set_program_name (argv[0]);\n<line5>setlocale (LC_ALL, "");\n<line6>bindtextdomain (PACKAGE, LOCALEDIR);\n<line7>textdomain (PACKAGE);\n<line8>atexit (close_stdout);\n<line9>parse_gnu_standard_options_only (argc, argv, PROGRAM_NAME, PACKAGE_NAME,\n<line10>Version, true, usage, AUTHORS,\n<line11>(char const *) nullptr);\n<line12>char **operands = argv + optind;\n<line13>char **operand_lim = argv + argc;\n<line14>if (optind == argc)\n<line15>*operand_lim++ = bad_cast ("y");\n<line16>/* Buffer data locally once, rather than having the\n<line17>large overhead of stdio buffering each item.  */\n<line18>size_t bufalloc = 0;\n<line19>bool reuse_operand_strings = true;\n<line20>char **operandp = operands;\n<line21>do\n<line22>{\n<line23>size_t operand_len = strlen (*operandp);\n<line24>bufalloc += operand_len + 1;\n<line25>if (operandp + 1 < operand_lim\n<line26>&& *operandp + operand_len + 1 != operandp[1])\n<line27>reuse_operand_strings = false;\n<line28>}\n<line29>while (++operandp < operand_lim);\n<line30>/* Improve performance by using a buffer size greater than BUFSIZ / 2.  */\n<line31>if (bufalloc <= BUFSIZ / 2)\n<line32>{\n<line33>bufalloc = BUFSIZ;\n<line34>reuse_operand_strings = false;\n<line35>}\n<line36>/* Fill the buffer with one copy of the output.  If possible, reuse\n<line37>the operands strings; this wins when the buffer would be large.  */\n<line38>char *buf = reuse_operand_strings ? *operands : xmalloc (bufalloc);\n<line39>size_t bufused = 0;\n<line40>operandp = operands;\n<line41>do\n<line42>{\n<line43>size_t operand_len = strlen (*operandp);\n<line44>if (! reuse_operand_strings)\n<line45>memcpy (buf + bufused, *operandp, operand_len);\n<line46>bufused += operand_len;\n<line47>buf[bufused++] = ' ';\n<line48>}\n<line49>while (++operandp < operand_lim);\n<line50>buf[bufused - 1] = '\n';\n<line51>/* If a larger buffer was allocated, fill it by repeating the buffer\n<line52>contents.  */\n<line53>size_t copysize = bufused;\n<line54>for (size_t copies = bufalloc / copysize; --copies; )\n<line55>{\n<line56>memcpy (buf + bufused, buf, copysize);\n<line57>bufused += copysize;\n<line58>}\n<line59>/* Repeatedly output the buffer until there is a write error; then fail.  */\n<line60>while (full_write (STDOUT_FILENO, buf, bufused) == bufused)\n<line61>continue;\n<line62>error (0, errno, _("standard output"));\n<line63>main_exit (EXIT_FAILURE);\n<line64>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/src/getlimits.c
========================================
Function: usage
Content: <line0>void\n<line1>usage (int status)\n<line2>{\n<line3>if (status != EXIT_SUCCESS)\n<line4>emit_try_help ();\n<line5>else\n<line6>{\n<line7>printf (_("\\n<line8>Usage: %s\n\\n<line9>"), program_name);\n<line10>fputs (_("\\n<line11>Output platform dependent limits in a format useful for shell scripts.\n\\n<line12>\n\\n<line13>"), stdout);\n<line14>fputs (HELP_OPTION_DESCRIPTION, stdout);\n<line15>fputs (VERSION_OPTION_DESCRIPTION, stdout);\n<line16>emit_ancillary_info (PROGRAM_NAME);\n<line17>}\n<line18>exit (status);\n<line19>}
----------------------------------------
Function: decimal_absval_add_one
Content: <line0>static char const *\n<line1>decimal_absval_add_one (char *buf)\n<line2>{\n<line3>bool negative = (buf[1] == '-');\n<line4>char *absnum = buf + 1 + negative;\n<line5>char *p = absnum + strlen (absnum);\n<line6>absnum[-1] = '0';\n<line7>while (*--p == '9')\n<line8>*p = '0';\n<line9>++*p;\n<line10>char *result = MIN (absnum, p);\n<line11>if (negative)\n<line12>*--result = '-';\n<line13>return result;\n<line14>}
----------------------------------------
Function: main
Content: <line0>int\n<line1>main (int argc, char **argv)\n<line2>{\n<line3>char limit[1 + MAX (INT_BUFSIZE_BOUND (intmax_t),\n<line4>INT_BUFSIZE_BOUND (uintmax_t))];\n<line5>initialize_main (&argc, &argv);\n<line6>set_program_name (argv[0]);\n<line7>setlocale (LC_ALL, "");\n<line8>bindtextdomain (PACKAGE, LOCALEDIR);\n<line9>textdomain (PACKAGE);\n<line10>atexit (close_stdout);\n<line11>parse_gnu_standard_options_only (argc, argv, PROGRAM_NAME, PACKAGE_NAME,\n<line12>VERSION, true, usage, AUTHORS,\n<line13>(char const *) nullptr);\n<line14>#define print_int(TYPE)                                                  \\n<line15>sprintf (limit + 1, "%"PRIuMAX, (uintmax_t) TYPE##_MAX);               \\n<line16>printf (#TYPE"_MAX=%s\n", limit + 1);                                  \\n<line17>printf (#TYPE"_OFLOW=%s\n", decimal_absval_add_one (limit));           \\n<line18>if (TYPE##_MIN)                                                        \\n<line19>{                                                                    \\n<line20>sprintf (limit + 1, "%"PRIdMAX, (intmax_t) TYPE##_MIN);            \\n<line21>printf (#TYPE"_MIN=%s\n", limit + 1);                              \\n<line22>printf (#TYPE"_UFLOW=%s\n", decimal_absval_add_one (limit));       \\n<line23>}\n<line24>#define print_float(TYPE)                                                \\n<line25>printf (#TYPE"_MIN="); print_##TYPE (TYPE##_MIN);                      \\n<line26>printf (#TYPE"_MAX="); print_##TYPE (TYPE##_MAX);\n<line27>/* Variable sized ints */\n<line28>print_int (CHAR);\n<line29>print_int (SCHAR);\n<line30>print_int (UCHAR);\n<line31>print_int (SHRT);\n<line32>print_int (INT);\n<line33>print_int (UINT);\n<line34>print_int (LONG);\n<line35>print_int (ULONG);\n<line36>print_int (SIZE);\n<line37>print_int (SSIZE);\n<line38>print_int (TIME_T);\n<line39>print_int (UID_T);\n<line40>print_int (GID_T);\n<line41>print_int (PID_T);\n<line42>print_int (OFF_T);\n<line43>print_int (INTMAX);\n<line44>print_int (UINTMAX);\n<line45>/* Variable sized floats */\n<line46>print_float (FLT);\n<line47>print_float (DBL);\n<line48>print_float (LDBL);\n<line49>return EXIT_SUCCESS;\n<line50>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/src/make-prime-list.c
========================================
Function: process_prime
Content: <line0>static void\n<line1>process_prime (struct prime *info, unsigned p)\n<line2>{\n<line3>wide_uint max = -1;\n<line4>info->p = p;\n<line5>info->pinv = binvert (p);\n<line6>info->lim = max / p;\n<line7>}
----------------------------------------
Function: print_wide_uint
Content: <line0>static void\n<line1>print_wide_uint (wide_uint n, int nesting, unsigned wide_uint_bits)\n<line2>{\n<line3>/* Number of bits per integer literal.  8 is too many, because\n<line4>uintmax_t is 32 bits on some machines so we cannot shift by 32 bits.\n<line5>So use 7.  */\n<line6>int hex_digits_per_literal = 7;\n<line7>int bits_per_literal = hex_digits_per_literal * 4;\n<line8>unsigned remainder = n & ((1 << bits_per_literal) - 1);\n<line9>if (n != remainder)\n<line10>{\n<line11>int needs_parentheses = n >> bits_per_literal >> bits_per_literal != 0;\n<line12>if (needs_parentheses)\n<line13>printf ("(");\n<line14>print_wide_uint (n >> bits_per_literal, nesting + 1, wide_uint_bits);\n<line15>if (needs_parentheses)\n<line16>printf (")\n%*s", nesting + 3, "");\n<line17>printf (" << %d | ", bits_per_literal);\n<line18>}\n<line19>else if (nesting)\n<line20>{\n<line21>printf ("(uintmax_t) ");\n<line22>hex_digits_per_literal\n<line23>= ((wide_uint_bits - 1) % bits_per_literal) % 4 + 1;\n<line24>}\n<line25>printf ("0x%0*xU", hex_digits_per_literal, remainder);\n<line26>}
----------------------------------------
Function: output_primes
Content: <line0>static void\n<line1>output_primes (const struct prime *primes, unsigned nprimes)\n<line2>{\n<line3>unsigned i;\n<line4>unsigned p;\n<line5>int is_prime;\n<line6>/* Compute wide_uint_bits by repeated shifting, rather than by\n<line7>multiplying sizeof by CHAR_BIT, as this works even if the\n<line8>wide_uint representation has holes.  */\n<line9>unsigned wide_uint_bits = 0;\n<line10>wide_uint mask = -1;\n<line11>for (wide_uint_bits = 0; mask; wide_uint_bits++)\n<line12>mask >>= 1;\n<line13>puts ("/* Generated file -- DO NOT EDIT */\n");\n<line14>printf ("#define WIDE_UINT_BITS %u\n", wide_uint_bits);\n<line15>for (i = 0, p = 2; i < nprimes; i++)\n<line16>{\n<line17>unsigned int d8 = i + 8 < nprimes ? primes[i + 8].p - primes[i].p : 0xff;\n<line18>if (255 < d8) /* this happens at 668221 */\n<line19>abort ();\n<line20>printf ("P (%u, %u,\n   (", primes[i].p - p, d8);\n<line21>print_wide_uint (primes[i].pinv, 0, wide_uint_bits);\n<line22>printf ("),\n   UINTMAX_MAX / %u)\n", primes[i].p);\n<line23>p = primes[i].p;\n<line24>}\n<line25>printf ("\n#undef FIRST_OMITTED_PRIME\n");\n<line26>/* Find next prime */\n<line27>do\n<line28>{\n<line29>p += 2;\n<line30>for (i = 0, is_prime = 1; is_prime; i++)\n<line31>{\n<line32>if (primes[i].p * primes[i].p > p)\n<line33>break;\n<line34>if (p * primes[i].pinv <= primes[i].lim)\n<line35>{\n<line36>is_prime = 0;\n<line37>break;\n<line38>}\n<line39>}\n<line40>}\n<line41>while (!is_prime);\n<line42>printf ("#define FIRST_OMITTED_PRIME %u\n", p);\n<line43>}
----------------------------------------
Function: main
Content: <line0>int\n<line1>main (int argc, char **argv)\n<line2>{\n<line3>int limit;\n<line4>char *sieve;\n<line5>size_t size, i;\n<line6>struct prime *prime_list;\n<line7>unsigned nprimes;\n<line8>if (argc != 2)\n<line9>{\n<line10>fprintf (stderr, "Usage: %s LIMIT\n"\n<line11>"Produces a list of odd primes <= LIMIT\n", argv[0]);\n<line12>return EXIT_FAILURE;\n<line13>}\n<line14>limit = atoi (argv[1]);\n<line15>if (limit < 3)\n<line16>return EXIT_SUCCESS;\n<line17>/* Make limit odd */\n<line18>if ( !(limit & 1))\n<line19>limit--;\n<line20>size = (limit - 1) / 2;\n<line21>/* sieve[i] represents 3+2*i */\n<line22>sieve = xalloc (size);\n<line23>memset (sieve, 1, size);\n<line24>prime_list = xalloc (size * sizeof (*prime_list));\n<line25>nprimes = 0;\n<line26>for (i = 0; i < size;)\n<line27>{\n<line28>unsigned p = 3 + 2 * i;\n<line29>unsigned j;\n<line30>process_prime (&prime_list[nprimes++], p);\n<line31>for (j = (p * p - 3) / 2; j < size; j += p)\n<line32>sieve[j] = 0;\n<line33>while (++i < size && sieve[i] == 0)\n<line34>;\n<line35>}\n<line36>output_primes (prime_list, nprimes);\n<line37>free (sieve);\n<line38>free (prime_list);\n<line39>if (ferror (stdout) + fclose (stdout))\n<line40>{\n<line41>fprintf (stderr, "write error: %s\n", strerror (errno));\n<line42>return EXIT_FAILURE;\n<line43>}\n<line44>return EXIT_SUCCESS;\n<line45>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/src/libstdbuf.c
========================================
Function: fileno_to_name
Content: <line0>static char const *\n<line1>fileno_to_name (const int fd)\n<line2>{\n<line3>char const *ret = nullptr;\n<line4>switch (fd)\n<line5>{\n<line6>case 0:\n<line7>ret = "stdin";\n<line8>break;\n<line9>case 1:\n<line10>ret = "stdout";\n<line11>break;\n<line12>case 2:\n<line13>ret = "stderr";\n<line14>break;\n<line15>default:\n<line16>ret = "unknown";\n<line17>break;\n<line18>}\n<line19>return ret;\n<line20>}
----------------------------------------
Function: apply_mode
Content: <line0>static void\n<line1>apply_mode (FILE *stream, char const *mode)\n<line2>{\n<line3>char *buf = nullptr;\n<line4>int setvbuf_mode;\n<line5>uintmax_t size = 0;\n<line6>if (*mode == '0')\n<line7>setvbuf_mode = _IONBF;\n<line8>else if (*mode == 'L')\n<line9>setvbuf_mode = _IOLBF;      /* FIXME: should we allow 1ML  */\n<line10>else\n<line11>{\n<line12>setvbuf_mode = _IOFBF;\n<line13>char *mode_end;\n<line14>size = strtoumax (mode, &mode_end, 10);\n<line15>if (size == 0 || *mode_end)\n<line16>{\n<line17>fprintf (stderr, _("invalid buffering mode %s for %s\n"),\n<line18>mode, fileno_to_name (fileno (stream)));\n<line19>return;\n<line20>}\n<line21>buf = size <= SIZE_MAX ? malloc (size) : nullptr;\n<line22>if (!buf)\n<line23>{\n<line24>/* We could defer the allocation to libc, however since\n<line25>glibc currently ignores the combination of null buffer\n<line26>with non zero size, we'll fail here.  */\n<line27>fprintf (stderr,\n<line28>_("failed to allocate a %" PRIuMAX\n<line29>" byte stdio buffer\n"),\n<line30>size);\n<line31>return;\n<line32>}\n<line33>/* buf will be freed by fclose.  */\n<line34>}\n<line35>if (setvbuf (stream, buf, setvbuf_mode, size) != 0)\n<line36>{\n<line37>fprintf (stderr, _("could not set buffering of %s to mode %s\n"),\n<line38>fileno_to_name (fileno (stream)), mode);\n<line39>free (buf);\n<line40>}\n<line41>}
----------------------------------------
Function: stdbuf
Content: <line0>static void __attribute ((constructor))\n<line1>stdbuf (void)\n<line2>{\n<line3>char *e_mode = getenv ("_STDBUF_E");\n<line4>char *i_mode = getenv ("_STDBUF_I");\n<line5>char *o_mode = getenv ("_STDBUF_O");\n<line6>if (e_mode) /* Do first so can write errors to stderr  */\n<line7>apply_mode (stderr, e_mode);\n<line8>if (i_mode)\n<line9>apply_mode (stdin, i_mode);\n<line10>if (o_mode)\n<line11>apply_mode (stdout, o_mode);\n<line12>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/gnulib-tests/bench-md5.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
========================================
/home/huihui/Downloads/coreutils-9.4/gnulib-tests/c-strcasestr.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
Function: c_strcasestr
Content: <line0>char *\n<line1>c_strcasestr (const char *haystack_start, const char *needle_start)\n<line2>{\n<line3>const char *haystack = haystack_start;\n<line4>const char *needle = needle_start;\n<line5>size_t needle_len; /* Length of NEEDLE.  */\n<line6>size_t haystack_len; /* Known minimum length of HAYSTACK.  */\n<line7>bool ok = true; /* True if NEEDLE is prefix of HAYSTACK.  */\n<line8>/* Determine length of NEEDLE, and in the process, make sure\n<line9>HAYSTACK is at least as long (no point processing all of a long\n<line10>NEEDLE if HAYSTACK is too short).  */\n<line11>while (*haystack && *needle)\n<line12>ok &= (c_tolower ((unsigned char) *haystack++)\n<line13>== c_tolower ((unsigned char) *needle++));\n<line14>if (*needle)\n<line15>return NULL;\n<line16>if (ok)\n<line17>return (char *) haystack_start;\n<line18>needle_len = needle - needle_start;\n<line19>haystack = haystack_start + 1;\n<line20>haystack_len = needle_len - 1;\n<line21>/* Perform the search.  Abstract memory is considered to be an array\n<line22>of 'unsigned char' values, not an array of 'char' values.  See\n<line23>ISO C 99 section 6.2.6.1.  */\n<line24>if (needle_len < LONG_NEEDLE_THRESHOLD)\n<line25>return two_way_short_needle ((const unsigned char *) haystack,\n<line26>haystack_len,\n<line27>(const unsigned char *) needle_start,\n<line28>needle_len);\n<line29>return two_way_long_needle ((const unsigned char *) haystack, haystack_len,\n<line30>(const unsigned char *) needle_start,\n<line31>needle_len);\n<line32>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/gnulib-tests/c32tob.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
========================================
/home/huihui/Downloads/coreutils-9.4/gnulib-tests/ioctl.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
Function: rpl_ioctl
Content: <line0>int\n<line1>rpl_ioctl (int fd, int request, ... /* {void *,char *} arg */)\n<line2>{\n<line3>void *buf;\n<line4>va_list args;\n<line5>va_start (args, request);\n<line6>buf = va_arg (args, void *);\n<line7>va_end (args);\n<line8>/* Cast 'request' so that when the system's ioctl function takes a 64-bit\n<line9>request argument, the value gets zero-extended, not sign-extended.  */\n<line10>return ioctl (fd, (unsigned int) request, buf);\n<line11>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/gnulib-tests/localename.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
Function: string_hash
Content: <line0>static size_t _GL_ATTRIBUTE_PURE\n<line1>string_hash (const void *x)\n<line2>{\n<line3>const char *s = (const char *) x;\n<line4>size_t h = 0;\n<line5>for (; *s; s++)\n<line6>h = *s + ((h << 9) | (h >> (SIZE_BITS - 9)));\n<line7>return h;\n<line8>}
----------------------------------------
Function: struniq
Content: <line0>static const char *\n<line1>struniq (const char *string)\n<line2>{\n<line3>size_t hashcode = string_hash (string);\n<line4>size_t slot = hashcode % STRUNIQ_HASH_TABLE_SIZE;\n<line5>size_t size;\n<line6>struct struniq_hash_node *new_node;\n<line7>struct struniq_hash_node *p;\n<line8>for (p = struniq_hash_table[slot]; p != NULL; p = p->next)\n<line9>if (strcmp (p->contents, string) == 0)\n<line10>return p->contents;\n<line11>size = strlen (string) + 1;\n<line12>new_node =\n<line13>(struct struniq_hash_node *)\n<line14>malloc (FLEXSIZEOF (struct struniq_hash_node, contents, size));\n<line15>if (new_node == NULL)\n<line16>/* Out of memory.  Return a statically allocated string.  */\n<line17>return "C";\n<line18>memcpy (new_node->contents, string, size);\n<line19>{\n<line20>bool mt = gl_multithreaded ();\n<line21>/* Lock while inserting new_node.  */\n<line22>if (mt) gl_lock_lock (struniq_lock);\n<line23>/* Check whether another thread already added the string while we were\n<line24>waiting on the lock.  */\n<line25>for (p = struniq_hash_table[slot]; p != NULL; p = p->next)\n<line26>if (strcmp (p->contents, string) == 0)\n<line27>{\n<line28>free (new_node);\n<line29>new_node = p;\n<line30>goto done;\n<line31>}\n<line32>/* Really insert new_node into the hash table.  Fill new_node entirely\n<line33>first, because other threads may be iterating over the linked list.  */\n<line34>new_node->next = struniq_hash_table[slot];\n<line35>struniq_hash_table[slot] = new_node;\n<line36>done:\n<line37>/* Unlock after new_node is inserted.  */\n<line38>if (mt) gl_lock_unlock (struniq_lock);\n<line39>}\n<line40>return new_node->contents;\n<line41>}
----------------------------------------
Function: gl_locale_name_thread_unsafe
Content: <line0>static\n<line1># endif\n<line2>const char *\n<line3>gl_locale_name_thread_unsafe (int category, _GL_UNUSED const char *categoryname)\n<line4>{\n<line5># if HAVE_GOOD_USELOCALE\n<line6>{\n<line7>locale_t thread_locale = uselocale (NULL);\n<line8>if (thread_locale != LC_GLOBAL_LOCALE)\n<line9>{\n<line10>#  if __GLIBC__ >= 2 && !defined __UCLIBC__\n<line11>/* Work around an incorrect definition of the _NL_LOCALE_NAME macro in\n<line12>glibc < 2.12.\n<line13>See <https://sourceware.org/bugzilla/show_bug.cgi?id=10968>.  */\n<line14>const char *name =\n<line15>nl_langinfo (_NL_ITEM ((category), _NL_ITEM_INDEX (-1)));\n<line16>if (name[0] == '\0')\n<line17>/* Fallback code for glibc < 2.4, which did not implement\n<line18>nl_langinfo (_NL_LOCALE_NAME (category)).  */\n<line19>name = thread_locale->__names[category];\n<line20>return name;\n<line21>#  elif defined __linux__ && HAVE_LANGINFO_H && defined NL_LOCALE_NAME\n<line22>/* musl libc */\n<line23>return nl_langinfo_l (NL_LOCALE_NAME (category), thread_locale);\n<line24>#  elif (defined __FreeBSD__ || defined __DragonFly__) || (defined __APPLE__ && defined __MACH__)\n<line25>/* FreeBSD, Mac OS X */\n<line26>int mask;\n<line27>switch (category)\n<line28>{\n<line29>case LC_CTYPE:\n<line30>mask = LC_CTYPE_MASK;\n<line31>break;\n<line32>case LC_NUMERIC:\n<line33>mask = LC_NUMERIC_MASK;\n<line34>break;\n<line35>case LC_TIME:\n<line36>mask = LC_TIME_MASK;\n<line37>break;\n<line38>case LC_COLLATE:\n<line39>mask = LC_COLLATE_MASK;\n<line40>break;\n<line41>case LC_MONETARY:\n<line42>mask = LC_MONETARY_MASK;\n<line43>break;\n<line44>case LC_MESSAGES:\n<line45>mask = LC_MESSAGES_MASK;\n<line46>break;\n<line47>default: /* We shouldn't get here.  */\n<line48>return "";\n<line49>}\n<line50>return querylocale (mask, thread_locale);\n<line51>#  elif defined __sun\n<line52>#   if HAVE_GETLOCALENAME_L\n<line53>/* Solaris >= 12.  */\n<line54>return getlocalename_l (category, thread_locale);\n<line55>#   elif HAVE_SOLARIS114_LOCALES\n<line56>/* Solaris >= 11.4.  */\n<line57>void *lcp = (*thread_locale)->core.data->lcp;\n<line58>if (lcp != NULL)\n<line59>switch (category)\n<line60>{\n<line61>case LC_CTYPE:\n<line62>case LC_NUMERIC:\n<line63>case LC_TIME:\n<line64>case LC_COLLATE:\n<line65>case LC_MONETARY:\n<line66>case LC_MESSAGES:\n<line67>return ((const char * const *) lcp)[category];\n<line68>default: /* We shouldn't get here.  */\n<line69>return "";\n<line70>}\n<line71>#   elif HAVE_NAMELESS_LOCALES\n<line72>return get_locale_t_name (category, thread_locale);\n<line73>#   else\n<line74>/* Solaris 11 OpenIndiana.\n<line75>For the internal structure of locale objects, see\n<line76>https://github.com/OpenIndiana/illumos-gate/blob/master/usr/src/lib/libc/port/locale/localeimpl.h  */\n<line77>switch (category)\n<line78>{\n<line79>case LC_CTYPE:\n<line80>case LC_NUMERIC:\n<line81>case LC_TIME:\n<line82>case LC_COLLATE:\n<line83>case LC_MONETARY:\n<line84>case LC_MESSAGES:\n<line85>return ((const char * const *) thread_locale)[category];\n<line86>default: /* We shouldn't get here.  */\n<line87>return "";\n<line88>}\n<line89>#   endif\n<line90>#  elif defined _AIX && HAVE_NAMELESS_LOCALES\n<line91>return get_locale_t_name (category, thread_locale);\n<line92>#  elif defined __CYGWIN__\n<line93>/* Cygwin < 2.6 lacks uselocale and thread-local locales altogether.\n<line94>Cygwin <= 2.6.1 lacks NL_LOCALE_NAME, requiring peeking inside\n<line95>an opaque struct.  */\n<line96>#   ifdef NL_LOCALE_NAME\n<line97>return nl_langinfo_l (NL_LOCALE_NAME (category), thread_locale);\n<line98>#   else\n<line99>/* FIXME: Remove when we can assume new-enough Cygwin.  */\n<line100>struct __locale_t {\n<line101>char categories[7][32];\n<line102>};\n<line103>return ((struct __locale_t *) thread_locale)->categories[category];\n<line104>#   endif\n<line105>#  elif defined __HAIKU__\n<line106>/* Since 2022, Haiku has per-thread locales.  locale_t is 'void *',\n<line107>but in fact a 'LocaleBackendData *'.  */\n<line108>struct LocaleBackendData {\n<line109>int magic;\n<line110>void /*BPrivate::Libroot::LocaleBackend*/ *backend;\n<line111>void /*BPrivate::Libroot::LocaleDataBridge*/ *databridge;\n<line112>};\n<line113>void *thread_locale_backend =\n<line114>((struct LocaleBackendData *) thread_locale)->backend;\n<line115>if (thread_locale_backend != NULL)\n<line116>{\n<line117>/* The only existing concrete subclass of\n<line118>BPrivate::Libroot::LocaleBackend is\n<line119>BPrivate::Libroot::ICULocaleBackend.\n<line120>Invoke the (non-virtual) method\n<line121>BPrivate::Libroot::ICULocaleBackend::_QueryLocale on it.\n<line122>This method is located in a separate shared library,\n<line123>libroot-addon-icu.so.  */\n<line124>static void * volatile querylocale_method /* = NULL */;\n<line125>static int volatile querylocale_found /* = 0 */;\n<line126>/* Attempt to open this shared library, the first time we get\n<line127>here.  */\n<line128>if (querylocale_found == 0)\n<line129>{\n<line130>void *handle =\n<line131>dlopen ("/boot/system/lib/libroot-addon-icu.so", 0);\n<line132>if (handle != NULL)\n<line133>{\n<line134>void *sym =\n<line135>dlsym (handle, "_ZN8BPrivate7Libroot16ICULocaleBackend12_QueryLocaleEi");\n<line136>if (sym != NULL)\n<line137>{\n<line138>querylocale_method = sym;\n<line139>querylocale_found = 1;\n<line140>}\n<line141>else\n<line142>/* Could not find the symbol.  */\n<line143>querylocale_found = -1;\n<line144>}\n<line145>else\n<line146>/* Could not open the separate shared library.  */\n<line147>querylocale_found = -1;\n<line148>}\n<line149>if (querylocale_found > 0)\n<line150>{\n<line151>/* The _QueryLocale method is a non-static C++ method with\n<line152>parameters (int category) and return type 'const char *'.\n<line153>See\n<line154>haiku/headers/private/libroot/locale/ICULocaleBackend.h\n<line155>haiku/src/system/libroot/add-ons/icu/ICULocaleBackend.cpp\n<line156>This is the same as a C function with parameters\n<line157>(BPrivate::Libroot::LocaleBackend* this, int category)\n<line158>and return type 'const char *'.  Invoke it.  */\n<line159>const char * (*querylocale_func) (void *, int) =\n<line160>(const char * (*) (void *, int)) querylocale_method;\n<line161>return querylocale_func (thread_locale_backend, category);\n<line162>}\n<line163>}\n<line164>else\n<line165>/* It's the "C" or "POSIX" locale.  */\n<line166>return "C";\n<line167>#  elif defined __ANDROID__\n<line168>return MB_CUR_MAX == 4 ? "C.UTF-8" : "C";\n<line169>#  endif\n<line170>}\n<line171>}\n<line172># endif\n<line173>return NULL;\n<line174>}
----------------------------------------
Function: gl_locale_name_thread
Content: <line0>const char *\n<line1>gl_locale_name_thread (int category, _GL_UNUSED const char *categoryname)\n<line2>{\n<line3>#if HAVE_GOOD_USELOCALE\n<line4>const char *name = gl_locale_name_thread_unsafe (category, categoryname);\n<line5>if (name != NULL)\n<line6>return struniq (name);\n<line7>#endif\n<line8>/* On WINDOWS_NATIVE, don't use GetThreadLocale() here, because when\n<line9>SetThreadLocale has not been called - which is a very frequent case -\n<line10>the value of GetThreadLocale() ignores past calls to 'setlocale'.  */\n<line11>return NULL;\n<line12>}
----------------------------------------
Function: gl_locale_name_posix
Content: <line0>const char *\n<line1>gl_locale_name_posix (int category, _GL_UNUSED const char *categoryname)\n<line2>{\n<line3>#if defined WINDOWS_NATIVE\n<line4>if (LC_MIN <= category && category <= LC_MAX)\n<line5>{\n<line6>const char *locname =\n<line7>/* setlocale_null (category) is identical to setlocale (category, NULL)\n<line8>on this platform.  */\n<line9>setlocale (category, NULL);\n<line10>/* Convert locale name to LCID.  We don't want to use\n<line11>LocaleNameToLCID because (a) it is only available since Vista,\n<line12>and (b) it doesn't accept locale names returned by 'setlocale'.  */\n<line13>LCID lcid = get_lcid (locname);\n<line14>if (lcid > 0)\n<line15>return gl_locale_name_from_win32_LCID (lcid);\n<line16>}\n<line17>#endif\n<line18>{\n<line19>const char *locname;\n<line20>/* Use the POSIX methods of looking to 'LC_ALL', 'LC_xxx', and 'LANG'.\n<line21>On some systems this can be done by the 'setlocale' function itself.  */\n<line22>#if defined HAVE_LC_MESSAGES && defined HAVE_LOCALE_NULL\n<line23>locname = setlocale_null (category);\n<line24>#else\n<line25>/* On other systems we ignore what setlocale reports and instead look at the\n<line26>environment variables directly.  This is necessary\n<line27>1. on systems which have a facility for customizing the default locale\n<line28>(Mac OS X, native Windows, Cygwin) and where the system's setlocale()\n<line29>function ignores this default locale (Mac OS X, Cygwin), in two cases:\n<line30>a. when the user missed to use the setlocale() override from libintl\n<line31>(for example by not including <libintl.h>),\n<line32>b. when setlocale supports only the "C" locale, such as on Cygwin\n<line33>1.5.x.  In this case even the override from libintl cannot help.\n<line34>2. on all systems where setlocale supports only the "C" locale.  */\n<line35>/* Strictly speaking, it is a POSIX violation to look at the environment\n<line36>variables regardless whether setlocale has been called or not.  POSIX\n<line37>says:\n<line38>"For C-language programs, the POSIX locale shall be the\n<line39>default locale when the setlocale() function is not called."\n<line40>But we assume that all programs that use internationalized APIs call\n<line41>setlocale (LC_ALL, "").  */\n<line42>locname = gl_locale_name_environ (category, categoryname);\n<line43>#endif\n<line44>/* Convert the locale name from the format returned by setlocale() or found\n<line45>in the environment variables to the XPG syntax.  */\n<line46>#if defined WINDOWS_NATIVE\n<line47>if (locname != NULL)\n<line48>{\n<line49>/* Convert locale name to LCID.  We don't want to use\n<line50>LocaleNameToLCID because (a) it is only available since Vista,\n<line51>and (b) it doesn't accept locale names returned by 'setlocale'.  */\n<line52>LCID lcid = get_lcid (locname);\n<line53>if (lcid > 0)\n<line54>return gl_locale_name_from_win32_LCID (lcid);\n<line55>}\n<line56>#endif\n<line57>return locname;\n<line58>}\n<line59>}
----------------------------------------
Function: gl_locale_name_environ
Content: <line0>const char *\n<line1>gl_locale_name_environ (_GL_UNUSED int category, const char *categoryname)\n<line2>{\n<line3>const char *retval;\n<line4>/* Setting of LC_ALL overrides all other.  */\n<line5>retval = getenv ("LC_ALL");\n<line6>if (retval != NULL && retval[0] != '\0')\n<line7>return retval;\n<line8>/* Next comes the name of the desired category.  */\n<line9>retval = getenv (categoryname);\n<line10>if (retval != NULL && retval[0] != '\0')\n<line11>return retval;\n<line12>/* Last possibility is the LANG environment variable.  */\n<line13>retval = getenv ("LANG");\n<line14>if (retval != NULL && retval[0] != '\0')\n<line15>{\n<line16>#if HAVE_CFPREFERENCESCOPYAPPVALUE\n<line17>/* Mac OS X 10.2 or newer.\n<line18>Ignore invalid LANG value set by the Terminal application.  */\n<line19>if (strcmp (retval, "UTF-8") != 0)\n<line20>#endif\n<line21>#if defined __CYGWIN__\n<line22>/* Cygwin.\n<line23>Ignore dummy LANG value set by ~/.profile.  */\n<line24>if (strcmp (retval, "C.UTF-8") != 0)\n<line25>#endif\n<line26>return retval;\n<line27>}\n<line28>return NULL;\n<line29>}
----------------------------------------
Function: gl_locale_name_default
Content: <line0>const char *\n<line1>gl_locale_name_default (void)\n<line2>{\n<line3>/* POSIX:2001 says:\n<line4>"All implementations shall define a locale as the default locale, to be\n<line5>invoked when no environment variables are set, or set to the empty\n<line6>string.  This default locale can be the POSIX locale or any other\n<line7>implementation-defined locale.  Some implementations may provide\n<line8>facilities for local installation administrators to set the default\n<line9>locale, customizing it for each location.  POSIX:2001 does not require\n<line10>such a facility.\n<line11>The systems with such a facility are Mac OS X and Windows: They provide a\n<line12>GUI that allows the user to choose a locale.\n<line13>- On Mac OS X, by default, none of LC_* or LANG are set.  Starting with\n<line14>Mac OS X 10.4 or 10.5, LANG is set for processes launched by the\n<line15>'Terminal' application (but sometimes to an incorrect value "UTF-8").\n<line16>When no environment variable is set, setlocale (LC_ALL, "") uses the\n<line17>"C" locale.\n<line18>- On native Windows, by default, none of LC_* or LANG are set.\n<line19>When no environment variable is set, setlocale (LC_ALL, "") uses the\n<line20>locale chosen by the user.\n<line21>- On Cygwin 1.5.x, by default, none of LC_* or LANG are set.\n<line22>When no environment variable is set, setlocale (LC_ALL, "") uses the\n<line23>"C" locale.\n<line24>- On Cygwin 1.7, by default, LANG is set to "C.UTF-8" when the default\n<line25>~/.profile is executed.\n<line26>When no environment variable is set, setlocale (LC_ALL, "") uses the\n<line27>"C.UTF-8" locale, which operates in the same way as the "C" locale.\n<line28>*/\n<line29>#if !(HAVE_CFPREFERENCESCOPYAPPVALUE || defined WINDOWS_NATIVE || defined __CYGWIN__)\n<line30>/* The system does not have a way of setting the locale, other than the\n<line31>POSIX specified environment variables.  We use C as default locale.  */\n<line32>return "C";\n<line33>#else\n<line34>/* Return an XPG style locale name language[_territory][@modifier].\n<line35>Don't even bother determining the codeset; it's not useful in this\n<line36>context, because message catalogs are not specific to a single\n<line37>codeset.  */\n<line38># if HAVE_CFPREFERENCESCOPYAPPVALUE\n<line39>/* Mac OS X 10.4 or newer */\n<line40>/* Don't use the API introduced in Mac OS X 10.5, CFLocaleCopyCurrent,\n<line41>because in macOS 10.13.4 it has the following behaviour:\n<line42>When two or more languages are specified in the\n<line43>"System Preferences > Language & Region > Preferred Languages" panel,\n<line44>it returns en_CC where CC is the territory (even when English is not among\n<line45>the preferred languages!).  What we want instead is what\n<line46>CFLocaleCopyCurrent returned in earlier macOS releases and what\n<line47>CFPreferencesCopyAppValue still returns, namely ll_CC where ll is the\n<line48>first among the preferred languages and CC is the territory.  */\n<line49>{\n<line50>/* Cache the locale name, since CoreFoundation calls are expensive.  */\n<line51>static const char *cached_localename;\n<line52>if (cached_localename == NULL)\n<line53>{\n<line54>char namebuf[256];\n<line55>CFTypeRef value =\n<line56>CFPreferencesCopyAppValue (CFSTR ("AppleLocale"),\n<line57>kCFPreferencesCurrentApplication);\n<line58>if (value != NULL && CFGetTypeID (value) == CFStringGetTypeID ())\n<line59>{\n<line60>CFStringRef name = (CFStringRef)value;\n<line61>if (CFStringGetCString (name, namebuf, sizeof (namebuf),\n<line62>kCFStringEncodingASCII))\n<line63>{\n<line64>gl_locale_name_canonicalize (namebuf);\n<line65>cached_localename = strdup (namebuf);\n<line66>}\n<line67>}\n<line68>if (cached_localename == NULL)\n<line69>cached_localename = "C";\n<line70>}\n<line71>return cached_localename;\n<line72>}\n<line73># endif\n<line74># if defined WINDOWS_NATIVE || defined __CYGWIN__ /* Native Windows or Cygwin */\n<line75>{\n<line76>LCID lcid;\n<line77>/* Use native Windows API locale ID.  */\n<line78>lcid = GetThreadLocale ();\n<line79>return gl_locale_name_from_win32_LCID (lcid);\n<line80>}\n<line81># endif\n<line82>#endif\n<line83>}
----------------------------------------
Function: gl_locale_name
Content: <line0>const char *\n<line1>gl_locale_name (int category, const char *categoryname)\n<line2>{\n<line3>const char *retval;\n<line4>retval = gl_locale_name_thread (category, categoryname);\n<line5>if (retval != NULL)\n<line6>return retval;\n<line7>retval = gl_locale_name_posix (category, categoryname);\n<line8>if (retval != NULL)\n<line9>return retval;\n<line10>return gl_locale_name_default ();\n<line11>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/gnulib-tests/localename-table.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
========================================
/home/huihui/Downloads/coreutils-9.4/gnulib-tests/glthread/thread.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
Function: gl_thread_create
Content: <line0>gl_thread_t\n<line1>gl_thread_create (void *(*func) (void *arg), void *arg)\n<line2>{\n<line3>gl_thread_t thread;\n<line4>int ret;\n<line5>ret = glthread_create (&thread, func, arg);\n<line6>if (ret != 0)\n<line7>abort ();\n<line8>return thread;\n<line9>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/gnulib-tests/timespec-add.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
Function: timespec_add
Content: <line0>struct timespec\n<line1>timespec_add (struct timespec a, struct timespec b)\n<line2>{\n<line3>time_t rs = a.tv_sec;\n<line4>time_t bs = b.tv_sec;\n<line5>int ns = a.tv_nsec + b.tv_nsec;\n<line6>int nsd = ns - TIMESPEC_HZ;\n<line7>int rns = ns;\n<line8>if (0 <= nsd)\n<line9>{\n<line10>rns = nsd;\n<line11>time_t bs1;\n<line12>if (!ckd_add (&bs1, bs, 1))\n<line13>bs = bs1;\n<line14>else if (rs < 0)\n<line15>rs++;\n<line16>else\n<line17>goto high_overflow;\n<line18>}\n<line19>if (ckd_add (&rs, rs, bs))\n<line20>{\n<line21>if (bs < 0)\n<line22>{\n<line23>rs = TYPE_MINIMUM (time_t);\n<line24>rns = 0;\n<line25>}\n<line26>else\n<line27>{\n<line28>high_overflow:\n<line29>rs = TYPE_MAXIMUM (time_t);\n<line30>rns = TIMESPEC_HZ - 1;\n<line31>}\n<line32>}\n<line33>return make_timespec (rs, rns);\n<line34>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/gnulib-tests/timespec-sub.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
Function: timespec_sub
Content: <line0>struct timespec\n<line1>timespec_sub (struct timespec a, struct timespec b)\n<line2>{\n<line3>time_t rs = a.tv_sec;\n<line4>time_t bs = b.tv_sec;\n<line5>int ns = a.tv_nsec - b.tv_nsec;\n<line6>int rns = ns;\n<line7>if (ns < 0)\n<line8>{\n<line9>rns = ns + TIMESPEC_HZ;\n<line10>time_t bs1;\n<line11>if (!ckd_add (&bs1, bs, 1))\n<line12>bs = bs1;\n<line13>else if (- TYPE_SIGNED (time_t) < rs)\n<line14>rs--;\n<line15>else\n<line16>goto low_overflow;\n<line17>}\n<line18>if (ckd_sub (&rs, rs, bs))\n<line19>{\n<line20>if (0 < bs)\n<line21>{\n<line22>low_overflow:\n<line23>rs = TYPE_MINIMUM (time_t);\n<line24>rns = 0;\n<line25>}\n<line26>else\n<line27>{\n<line28>rs = TYPE_MAXIMUM (time_t);\n<line29>rns = TIMESPEC_HZ - 1;\n<line30>}\n<line31>}\n<line32>return make_timespec (rs, rns);\n<line33>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/gnulib-tests/unistr/u32-set.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
========================================
/home/huihui/Downloads/coreutils-9.4/gnulib-tests/vma-iter.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
Function: rof_open
Content: <line0>static int\n<line1>rof_open (struct rofile *rof, const char *filename)\n<line2>{\n<line3>int fd;\n<line4>unsigned long pagesize;\n<line5>size_t size;\n<line6>fd = open (filename, O_RDONLY | O_CLOEXEC);\n<line7>if (fd < 0)\n<line8>return -1;\n<line9>rof->position = 0;\n<line10>rof->eof_seen = 0;\n<line11>/* Try the static buffer first.  */\n<line12>pagesize = 0;\n<line13>rof->buffer = rof->stack_allocated_buffer;\n<line14>size = sizeof (rof->stack_allocated_buffer);\n<line15>rof->auxmap = NULL;\n<line16>rof->auxmap_start = 0;\n<line17>rof->auxmap_end = 0;\n<line18>for (;;)\n<line19>{\n<line20>/* Attempt to read the contents in a single system call.  */\n<line21>if (size > MIN_LEFTOVER)\n<line22>{\n<line23>int n = read (fd, rof->buffer, size);\n<line24>if (n < 0 && errno == EINTR)\n<line25>goto retry;\n<line26># if defined __DragonFly__\n<line27>if (!(n < 0 && errno == EFBIG))\n<line28># endif\n<line29>{\n<line30>if (n <= 0)\n<line31>/* Empty file.  */\n<line32>goto fail1;\n<line33>if (n + MIN_LEFTOVER <= size)\n<line34>{\n<line35>/* The buffer was sufficiently large.  */\n<line36>rof->filled = n;\n<line37># if defined __linux__ || defined __ANDROID__\n<line38>/* On Linux, the read() call may stop even if the buffer was\n<line39>large enough.  We need the equivalent of full_read().  */\n<line40>for (;;)\n<line41>{\n<line42>n = read (fd, rof->buffer + rof->filled, size - rof->filled);\n<line43>if (n < 0 && errno == EINTR)\n<line44>goto retry;\n<line45>if (n < 0)\n<line46>/* Some error.  */\n<line47>goto fail1;\n<line48>if (n + MIN_LEFTOVER > size - rof->filled)\n<line49>/* Allocate a larger buffer.  */\n<line50>break;\n<line51>if (n == 0)\n<line52>{\n<line53>/* Reached the end of file.  */\n<line54>close (fd);\n<line55>return 0;\n<line56>}\n<line57>rof->filled += n;\n<line58>}\n<line59># else\n<line60>close (fd);\n<line61>return 0;\n<line62># endif\n<line63>}\n<line64>}\n<line65>}\n<line66>/* Allocate a larger buffer.  */\n<line67>if (pagesize == 0)\n<line68>{\n<line69>pagesize = getpagesize ();\n<line70>size = pagesize;\n<line71>while (size <= MIN_LEFTOVER)\n<line72>size = 2 * size;\n<line73>}\n<line74>else\n<line75>{\n<line76>size = 2 * size;\n<line77>if (size == 0)\n<line78>/* Wraparound.  */\n<line79>goto fail1;\n<line80>if (rof->auxmap != NULL)\n<line81>munmap (rof->auxmap, rof->auxmap_length);\n<line82>}\n<line83>rof->auxmap = (void *) mmap ((void *) 0, size, PROT_READ | PROT_WRITE,\n<line84>MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);\n<line85>if (rof->auxmap == (void *) -1)\n<line86>{\n<line87>close (fd);\n<line88>return -1;\n<line89>}\n<line90>rof->auxmap_length = size;\n<line91>rof->auxmap_start = (unsigned long) rof->auxmap;\n<line92>rof->auxmap_end = rof->auxmap_start + size;\n<line93>rof->buffer = (char *) rof->auxmap;\n<line94>retry:\n<line95>/* Restart.  */\n<line96>if (lseek (fd, 0, SEEK_SET) < 0)\n<line97>{\n<line98>close (fd);\n<line99>fd = open (filename, O_RDONLY | O_CLOEXEC);\n<line100>if (fd < 0)\n<line101>goto fail2;\n<line102>}\n<line103>}\n<line104>fail1:\n<line105>close (fd);\n<line106>fail2:\n<line107>if (rof->auxmap != NULL)\n<line108>munmap (rof->auxmap, rof->auxmap_length);\n<line109>return -1;\n<line110>}
----------------------------------------
Function: rof_peekchar
Content: <line0>static int\n<line1>rof_peekchar (struct rofile *rof)\n<line2>{\n<line3>if (rof->position == rof->filled)\n<line4>{\n<line5>rof->eof_seen = 1;\n<line6>return -1;\n<line7>}\n<line8>return (unsigned char) rof->buffer[rof->position];\n<line9>}
----------------------------------------
Function: rof_getchar
Content: <line0>static int\n<line1>rof_getchar (struct rofile *rof)\n<line2>{\n<line3>int c = rof_peekchar (rof);\n<line4>if (c >= 0)\n<line5>rof->position++;\n<line6>return c;\n<line7>}
----------------------------------------
Function: rof_scanf_lx
Content: <line0>static int\n<line1>rof_scanf_lx (struct rofile *rof, unsigned long *valuep)\n<line2>{\n<line3>unsigned long value = 0;\n<line4>unsigned int numdigits = 0;\n<line5>for (;;)\n<line6>{\n<line7>int c = rof_peekchar (rof);\n<line8>if (c >= '0' && c <= '9')\n<line9>value = (value << 4) + (c - '0');\n<line10>else if (c >= 'A' && c <= 'F')\n<line11>value = (value << 4) + (c - 'A' + 10);\n<line12>else if (c >= 'a' && c <= 'f')\n<line13>value = (value << 4) + (c - 'a' + 10);\n<line14>else\n<line15>break;\n<line16>rof_getchar (rof);\n<line17>numdigits++;\n<line18>}\n<line19>if (numdigits == 0)\n<line20>return -1;\n<line21>*valuep = value;\n<line22>return 0;\n<line23>}
----------------------------------------
Function: rof_close
Content: <line0>static void\n<line1>rof_close (struct rofile *rof)\n<line2>{\n<line3>if (rof->auxmap != NULL)\n<line4>munmap (rof->auxmap, rof->auxmap_length);\n<line5>}
----------------------------------------
Function: vma_iterate_proc
Content: <line0>static int\n<line1>vma_iterate_proc (vma_iterate_callback_fn callback, void *data)\n<line2>{\n<line3>struct rofile rof;\n<line4>/* Open the current process' maps file.  It describes one VMA per line.  */\n<line5>if (rof_open (&rof, "/proc/self/maps") >= 0)\n<line6>{\n<line7>unsigned long auxmap_start = rof.auxmap_start;\n<line8>unsigned long auxmap_end = rof.auxmap_end;\n<line9>for (;;)\n<line10>{\n<line11>unsigned long start, end;\n<line12>unsigned int flags;\n<line13>int c;\n<line14>/* Parse one line.  First start and end.  */\n<line15>if (!(rof_scanf_lx (&rof, &start) >= 0\n<line16>&& rof_getchar (&rof) == '-'\n<line17>&& rof_scanf_lx (&rof, &end) >= 0))\n<line18>break;\n<line19>/* Then the flags.  */\n<line20>do\n<line21>c = rof_getchar (&rof);\n<line22>while (c == ' ');\n<line23>flags = 0;\n<line24>if (c == 'r')\n<line25>flags |= VMA_PROT_READ;\n<line26>c = rof_getchar (&rof);\n<line27>if (c == 'w')\n<line28>flags |= VMA_PROT_WRITE;\n<line29>c = rof_getchar (&rof);\n<line30>if (c == 'x')\n<line31>flags |= VMA_PROT_EXECUTE;\n<line32>while (c = rof_getchar (&rof), c != -1 && c != '\n')\n<line33>;\n<line34>if (start <= auxmap_start && auxmap_end - 1 <= end - 1)\n<line35>{\n<line36>/* Consider [start,end-1] \ [auxmap_start,auxmap_end-1]\n<line37>= [start,auxmap_start-1] u [auxmap_end,end-1].  */\n<line38>if (start < auxmap_start)\n<line39>if (callback (data, start, auxmap_start, flags))\n<line40>break;\n<line41>if (auxmap_end - 1 < end - 1)\n<line42>if (callback (data, auxmap_end, end, flags))\n<line43>break;\n<line44>}\n<line45>else\n<line46>{\n<line47>if (callback (data, start, end, flags))\n<line48>break;\n<line49>}\n<line50>}\n<line51>rof_close (&rof);\n<line52>return 0;\n<line53>}\n<line54>return -1;\n<line55>}
----------------------------------------
Function: vma_iterate_bsd
Content: <line0>static inline int\n<line1>vma_iterate_bsd (vma_iterate_callback_fn callback, void *data)\n<line2>{\n<line3>return -1;\n<line4>}
----------------------------------------
Function: vma_iterate
Content: <line0>int\n<line1>vma_iterate (vma_iterate_callback_fn callback, void *data)\n<line2>{\n<line3>#if defined __linux__ || defined __ANDROID__ || defined __FreeBSD_kernel__ || defined __FreeBSD__ || defined __DragonFly__ || defined __NetBSD__ || defined __minix /* || defined __CYGWIN__ */\n<line4># if defined __FreeBSD__\n<line5>/* On FreeBSD with procfs (but not GNU/kFreeBSD, which uses linprocfs), the\n<line6>function vma_iterate_proc does not return the virtual memory areas that\n<line7>were created by anonymous mmap.  See\n<line8><https://svnweb.freebsd.org/base/head/sys/fs/procfs/procfs_map.c?view=markup>\n<line9>So use vma_iterate_proc only as a fallback.  */\n<line10>int retval = vma_iterate_bsd (callback, data);\n<line11>if (retval == 0)\n<line12>return 0;\n<line13>return vma_iterate_proc (callback, data);\n<line14># else\n<line15>/* On the other platforms, try the /proc approach first, and the sysctl()\n<line16>as a fallback.  */\n<line17>int retval = vma_iterate_proc (callback, data);\n<line18>if (retval == 0)\n<line19>return 0;\n<line20>return vma_iterate_bsd (callback, data);\n<line21># endif\n<line22>#elif defined _AIX /* AIX */\n<line23>/* On AIX, there is a /proc/$pic/map file, that contains records of type\n<line24>prmap_t, defined in <sys/procfs.h>.  In older versions of AIX, it lists\n<line25>only the virtual memory areas that are connected to a file, not the\n<line26>anonymous ones.  But at least since AIX 7.1, it is well usable.  */\n<line27>size_t pagesize;\n<line28>char fnamebuf[6+10+4+1];\n<line29>char *fname;\n<line30>int fd;\n<line31>size_t memneed;\n<line32>pagesize = getpagesize ();\n<line33>/* Construct fname = sprintf (fnamebuf+i, "/proc/%u/map", getpid ()).  */\n<line34>fname = fnamebuf + sizeof (fnamebuf) - (4+1);\n<line35>memcpy (fname, "/map", 4+1);\n<line36>{\n<line37>unsigned int value = getpid ();\n<line38>do\n<line39>*--fname = (value % 10) + '0';\n<line40>while ((value = value / 10) > 0);\n<line41>}\n<line42>fname -= 6;\n<line43>memcpy (fname, "/proc/", 6);\n<line44>fd = open (fname, O_RDONLY | O_CLOEXEC);\n<line45>if (fd < 0)\n<line46>return -1;\n<line47>/* The contents of /proc/<pid>/map contains a number of prmap_t entries,\n<line48>then an entirely null prmap_t entry, then a heap of NUL terminated\n<line49>strings.\n<line50>Documentation: https://www.ibm.com/docs/en/aix/7.1?topic=files-proc-file\n<line51>We read the entire contents, but look only at the prmap_t entries and\n<line52>ignore the tail part.  */\n<line53>for (memneed = 2 * pagesize; ; memneed = 2 * memneed)\n<line54>{\n<line55>/* Allocate memneed bytes of memory.\n<line56>We cannot use alloca here, because not much stack space is guaranteed.\n<line57>We also cannot use malloc here, because a malloc() call may call mmap()\n<line58>and thus pre-allocate available memory.\n<line59>So use mmap(), and ignore the resulting VMA if it occurs among the\n<line60>resulting VMAs.  (Normally it doesn't, because it was allocated after\n<line61>the open() call.)  */\n<line62>void *auxmap;\n<line63>unsigned long auxmap_start;\n<line64>unsigned long auxmap_end;\n<line65>ssize_t nbytes;\n<line66>auxmap = (void *) mmap ((void *) 0, memneed, PROT_READ | PROT_WRITE,\n<line67>MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);\n<line68>if (auxmap == (void *) -1)\n<line69>{\n<line70>close (fd);\n<line71>return -1;\n<line72>}\n<line73>auxmap_start = (unsigned long) auxmap;\n<line74>auxmap_end = auxmap_start + memneed;\n<line75>/* Read the contents of /proc/<pid>/map in a single system call.\n<line76>This guarantees a consistent result (no duplicated or omitted\n<line77>entries).  */\n<line78>retry:\n<line79>do\n<line80>nbytes = read (fd, auxmap, memneed);\n<line81>while (nbytes < 0 && errno == EINTR);\n<line82>if (nbytes <= 0)\n<line83>{\n<line84>munmap (auxmap, memneed);\n<line85>close (fd);\n<line86>return -1;\n<line87>}\n<line88>if (nbytes == memneed)\n<line89>{\n<line90>/* Need more memory.  */\n<line91>munmap (auxmap, memneed);\n<line92>if (lseek (fd, 0, SEEK_SET) < 0)\n<line93>{\n<line94>close (fd);\n<line95>return -1;\n<line96>}\n<line97>}\n<line98>else\n<line99>{\n<line100>if (read (fd, (char *) auxmap + nbytes, 1) > 0)\n<line101>{\n<line102>/* Oops, we had a short read.  Retry.  */\n<line103>if (lseek (fd, 0, SEEK_SET) < 0)\n<line104>{\n<line105>munmap (auxmap, memneed);\n<line106>close (fd);\n<line107>return -1;\n<line108>}\n<line109>goto retry;\n<line110>}\n<line111>/* We now have the entire contents of /proc/<pid>/map in memory.  */\n<line112>prmap_t* maps = (prmap_t *) auxmap;\n<line113>/* The entries are not sorted by address.  Therefore\n<line114>1. Extract the relevant information into an array.\n<line115>2. Sort the array in ascending order.\n<line116>3. Invoke the callback.  */\n<line117>typedef struct\n<line118>{\n<line119>uintptr_t start;\n<line120>uintptr_t end;\n<line121>unsigned int flags;\n<line122>}\n<line123>vma_t;\n<line124>/* Since 2 * sizeof (vma_t) <= sizeof (prmap_t), we can reuse the\n<line125>same memory.  */\n<line126>vma_t *vmas = (vma_t *) auxmap;\n<line127>vma_t *vp = vmas;\n<line128>{\n<line129>prmap_t* mp;\n<line130>for (mp = maps;;)\n<line131>{\n<line132>unsigned long start, end;\n<line133>start = (unsigned long) mp->pr_vaddr;\n<line134>end = start + mp->pr_size;\n<line135>if (start == 0 && end == 0 && mp->pr_mflags == 0)\n<line136>break;\n<line137>/* Discard empty VMAs and kernel VMAs.  */\n<line138>if (start < end && (mp->pr_mflags & MA_KERNTEXT) == 0)\n<line139>{\n<line140>unsigned int flags;\n<line141>flags = 0;\n<line142>if (mp->pr_mflags & MA_READ)\n<line143>flags |= VMA_PROT_READ;\n<line144>if (mp->pr_mflags & MA_WRITE)\n<line145>flags |= VMA_PROT_WRITE;\n<line146>if (mp->pr_mflags & MA_EXEC)\n<line147>flags |= VMA_PROT_EXECUTE;\n<line148>if (start <= auxmap_start && auxmap_end - 1 <= end - 1)\n<line149>{\n<line150>/* Consider [start,end-1] \ [auxmap_start,auxmap_end-1]\n<line151>= [start,auxmap_start-1] u [auxmap_end,end-1].  */\n<line152>if (start < auxmap_start)\n<line153>{\n<line154>vp->start = start;\n<line155>vp->end = auxmap_start;\n<line156>vp->flags = flags;\n<line157>vp++;\n<line158>}\n<line159>if (auxmap_end - 1 < end - 1)\n<line160>{\n<line161>vp->start = auxmap_end;\n<line162>vp->end = end;\n<line163>vp->flags = flags;\n<line164>vp++;\n<line165>}\n<line166>}\n<line167>else\n<line168>{\n<line169>vp->start = start;\n<line170>vp->end = end;\n<line171>vp->flags = flags;\n<line172>vp++;\n<line173>}\n<line174>}\n<line175>mp++;\n<line176>}\n<line177>}\n<line178>size_t nvmas = vp - vmas;\n<line179>/* Sort the array in ascending order.\n<line180>Better not call qsort(), since it may call malloc().\n<line181>Insertion-sort is OK in this case, despite its worst-case running\n<line182>time of O(N), since the number of VMAs will rarely be larger than\n<line183>1000.  */\n<line184>{\n<line185>size_t i;\n<line186>for (i = 1; i < nvmas; i++)\n<line187>{\n<line188>/* Invariant: Here vmas[0..i-1] is sorted.  */\n<line189>size_t j;\n<line190>for (j = i; j > 0 && vmas[j - 1].start > vmas[j].start; j--)\n<line191>{\n<line192>vma_t tmp = vmas[j - 1];\n<line193>vmas[j - 1] = vmas[j];\n<line194>vmas[j] = tmp;\n<line195>}\n<line196>/* Invariant: Here vmas[0..i] is sorted.  */\n<line197>}\n<line198>}\n<line199>/* Invoke the callback.  */\n<line200>{\n<line201>size_t i;\n<line202>for (i = 0; i < nvmas; i++)\n<line203>{\n<line204>vma_t *vpi = &vmas[i];\n<line205>if (callback (data, vpi->start, vpi->end, vpi->flags))\n<line206>break;\n<line207>}\n<line208>}\n<line209>munmap (auxmap, memneed);\n<line210>break;\n<line211>}\n<line212>}\n<line213>close (fd);\n<line214>return 0;\n<line215>#elif defined __sgi || defined __osf__ /* IRIX, OSF/1 */\n<line216>size_t pagesize;\n<line217>char fnamebuf[6+10+1];\n<line218>char *fname;\n<line219>int fd;\n<line220>int nmaps;\n<line221>size_t memneed;\n<line222># if HAVE_MAP_ANONYMOUS\n<line223>#  define zero_fd -1\n<line224>#  define map_flags MAP_ANONYMOUS\n<line225># else\n<line226>int zero_fd;\n<line227>#  define map_flags 0\n<line228># endif\n<line229>void *auxmap;\n<line230>unsigned long auxmap_start;\n<line231>unsigned long auxmap_end;\n<line232>prmap_t* maps;\n<line233>prmap_t* mp;\n<line234>pagesize = getpagesize ();\n<line235>/* Construct fname = sprintf (fnamebuf+i, "/proc/%u", getpid ()).  */\n<line236>fname = fnamebuf + sizeof (fnamebuf) - 1;\n<line237>*fname = '\0';\n<line238>{\n<line239>unsigned int value = getpid ();\n<line240>do\n<line241>*--fname = (value % 10) + '0';\n<line242>while ((value = value / 10) > 0);\n<line243>}\n<line244>fname -= 6;\n<line245>memcpy (fname, "/proc/", 6);\n<line246>fd = open (fname, O_RDONLY | O_CLOEXEC);\n<line247>if (fd < 0)\n<line248>return -1;\n<line249>if (ioctl (fd, PIOCNMAP, &nmaps) < 0)\n<line250>goto fail2;\n<line251>memneed = (nmaps + 10) * sizeof (prmap_t);\n<line252>/* Allocate memneed bytes of memory.\n<line253>We cannot use alloca here, because not much stack space is guaranteed.\n<line254>We also cannot use malloc here, because a malloc() call may call mmap()\n<line255>and thus pre-allocate available memory.\n<line256>So use mmap(), and ignore the resulting VMA.  */\n<line257>memneed = ((memneed - 1) / pagesize + 1) * pagesize;\n<line258># if !HAVE_MAP_ANONYMOUS\n<line259>zero_fd = open ("/dev/zero", O_RDONLY | O_CLOEXEC, 0644);\n<line260>if (zero_fd < 0)\n<line261>goto fail2;\n<line262># endif\n<line263>auxmap = (void *) mmap ((void *) 0, memneed, PROT_READ | PROT_WRITE,\n<line264>map_flags | MAP_PRIVATE, zero_fd, 0);\n<line265># if !HAVE_MAP_ANONYMOUS\n<line266>close (zero_fd);\n<line267># endif\n<line268>if (auxmap == (void *) -1)\n<line269>goto fail2;\n<line270>auxmap_start = (unsigned long) auxmap;\n<line271>auxmap_end = auxmap_start + memneed;\n<line272>maps = (prmap_t *) auxmap;\n<line273>if (ioctl (fd, PIOCMAP, maps) < 0)\n<line274>goto fail1;\n<line275>for (mp = maps;;)\n<line276>{\n<line277>unsigned long start, end;\n<line278>unsigned int flags;\n<line279>start = (unsigned long) mp->pr_vaddr;\n<line280>end = start + mp->pr_size;\n<line281>if (start == 0 && end == 0)\n<line282>break;\n<line283>flags = 0;\n<line284>if (mp->pr_mflags & MA_READ)\n<line285>flags |= VMA_PROT_READ;\n<line286>if (mp->pr_mflags & MA_WRITE)\n<line287>flags |= VMA_PROT_WRITE;\n<line288>if (mp->pr_mflags & MA_EXEC)\n<line289>flags |= VMA_PROT_EXECUTE;\n<line290>mp++;\n<line291>if (start <= auxmap_start && auxmap_end - 1 <= end - 1)\n<line292>{\n<line293>/* Consider [start,end-1] \ [auxmap_start,auxmap_end-1]\n<line294>= [start,auxmap_start-1] u [auxmap_end,end-1].  */\n<line295>if (start < auxmap_start)\n<line296>if (callback (data, start, auxmap_start, flags))\n<line297>break;\n<line298>if (auxmap_end - 1 < end - 1)\n<line299>if (callback (data, auxmap_end, end, flags))\n<line300>break;\n<line301>}\n<line302>else\n<line303>{\n<line304>if (callback (data, start, end, flags))\n<line305>break;\n<line306>}\n<line307>}\n<line308>munmap (auxmap, memneed);\n<line309>close (fd);\n<line310>return 0;\n<line311>fail1:\n<line312>munmap (auxmap, memneed);\n<line313>fail2:\n<line314>close (fd);\n<line315>return -1;\n<line316>#elif defined __sun /* Solaris */\n<line317>/* Note: Solaris <sys/procfs.h> defines a different type prmap_t with\n<line318>_STRUCTURED_PROC than without! Here's a table of sizeof(prmap_t):\n<line319>32-bit   64-bit\n<line320>_STRUCTURED_PROC = 0       32       56\n<line321>_STRUCTURED_PROC = 1       96      104\n<line322>Therefore, if the include files provide the newer API, prmap_t has\n<line323>the bigger size, and thus you MUST use the newer API.  And if the\n<line324>include files provide the older API, prmap_t has the smaller size,\n<line325>and thus you MUST use the older API.  */\n<line326># if defined PIOCNMAP && defined PIOCMAP\n<line327>/* We must use the older /proc interface.  */\n<line328>size_t pagesize;\n<line329>char fnamebuf[6+10+1];\n<line330>char *fname;\n<line331>int fd;\n<line332>int nmaps;\n<line333>size_t memneed;\n<line334>#  if HAVE_MAP_ANONYMOUS\n<line335>#   define zero_fd -1\n<line336>#   define map_flags MAP_ANONYMOUS\n<line337>#  else /* Solaris <= 7 */\n<line338>int zero_fd;\n<line339>#   define map_flags 0\n<line340>#  endif\n<line341>void *auxmap;\n<line342>unsigned long auxmap_start;\n<line343>unsigned long auxmap_end;\n<line344>prmap_t* maps;\n<line345>prmap_t* mp;\n<line346>pagesize = getpagesize ();\n<line347>/* Construct fname = sprintf (fnamebuf+i, "/proc/%u", getpid ()).  */\n<line348>fname = fnamebuf + sizeof (fnamebuf) - 1;\n<line349>*fname = '\0';\n<line350>{\n<line351>unsigned int value = getpid ();\n<line352>do\n<line353>*--fname = (value % 10) + '0';\n<line354>while ((value = value / 10) > 0);\n<line355>}\n<line356>fname -= 6;\n<line357>memcpy (fname, "/proc/", 6);\n<line358>fd = open (fname, O_RDONLY | O_CLOEXEC);\n<line359>if (fd < 0)\n<line360>return -1;\n<line361>if (ioctl (fd, PIOCNMAP, &nmaps) < 0)\n<line362>goto fail2;\n<line363>memneed = (nmaps + 10) * sizeof (prmap_t);\n<line364>/* Allocate memneed bytes of memory.\n<line365>We cannot use alloca here, because not much stack space is guaranteed.\n<line366>We also cannot use malloc here, because a malloc() call may call mmap()\n<line367>and thus pre-allocate available memory.\n<line368>So use mmap(), and ignore the resulting VMA.  */\n<line369>memneed = ((memneed - 1) / pagesize + 1) * pagesize;\n<line370>#  if !HAVE_MAP_ANONYMOUS\n<line371>zero_fd = open ("/dev/zero", O_RDONLY | O_CLOEXEC, 0644);\n<line372>if (zero_fd < 0)\n<line373>goto fail2;\n<line374>#  endif\n<line375>auxmap = (void *) mmap ((void *) 0, memneed, PROT_READ | PROT_WRITE,\n<line376>map_flags | MAP_PRIVATE, zero_fd, 0);\n<line377>#  if !HAVE_MAP_ANONYMOUS\n<line378>close (zero_fd);\n<line379>#  endif\n<line380>if (auxmap == (void *) -1)\n<line381>goto fail2;\n<line382>auxmap_start = (unsigned long) auxmap;\n<line383>auxmap_end = auxmap_start + memneed;\n<line384>maps = (prmap_t *) auxmap;\n<line385>if (ioctl (fd, PIOCMAP, maps) < 0)\n<line386>goto fail1;\n<line387>for (mp = maps;;)\n<line388>{\n<line389>unsigned long start, end;\n<line390>unsigned int flags;\n<line391>start = (unsigned long) mp->pr_vaddr;\n<line392>end = start + mp->pr_size;\n<line393>if (start == 0 && end == 0)\n<line394>break;\n<line395>flags = 0;\n<line396>if (mp->pr_mflags & MA_READ)\n<line397>flags |= VMA_PROT_READ;\n<line398>if (mp->pr_mflags & MA_WRITE)\n<line399>flags |= VMA_PROT_WRITE;\n<line400>if (mp->pr_mflags & MA_EXEC)\n<line401>flags |= VMA_PROT_EXECUTE;\n<line402>mp++;\n<line403>if (start <= auxmap_start && auxmap_end - 1 <= end - 1)\n<line404>{\n<line405>/* Consider [start,end-1] \ [auxmap_start,auxmap_end-1]\n<line406>= [start,auxmap_start-1] u [auxmap_end,end-1].  */\n<line407>if (start < auxmap_start)\n<line408>if (callback (data, start, auxmap_start, flags))\n<line409>break;\n<line410>if (auxmap_end - 1 < end - 1)\n<line411>if (callback (data, auxmap_end, end, flags))\n<line412>break;\n<line413>}\n<line414>else\n<line415>{\n<line416>if (callback (data, start, end, flags))\n<line417>break;\n<line418>}\n<line419>}\n<line420>munmap (auxmap, memneed);\n<line421>close (fd);\n<line422>return 0;\n<line423>fail1:\n<line424>munmap (auxmap, memneed);\n<line425>fail2:\n<line426>close (fd);\n<line427>return -1;\n<line428># else\n<line429>/* We must use the newer /proc interface.\n<line430>Documentation:\n<line431>https://docs.oracle.com/cd/E23824_01/html/821-1473/proc-4.html\n<line432>The contents of /proc/<pid>/map consists of records of type\n<line433>prmap_t.  These are different in 32-bit and 64-bit processes,\n<line434>but here we are fortunately accessing only the current process.  */\n<line435>size_t pagesize;\n<line436>char fnamebuf[6+10+4+1];\n<line437>char *fname;\n<line438>int fd;\n<line439>int nmaps;\n<line440>size_t memneed;\n<line441>#  if HAVE_MAP_ANONYMOUS\n<line442>#   define zero_fd -1\n<line443>#   define map_flags MAP_ANONYMOUS\n<line444>#  else /* Solaris <= 7 */\n<line445>int zero_fd;\n<line446>#   define map_flags 0\n<line447>#  endif\n<line448>void *auxmap;\n<line449>unsigned long auxmap_start;\n<line450>unsigned long auxmap_end;\n<line451>prmap_t* maps;\n<line452>prmap_t* maps_end;\n<line453>prmap_t* mp;\n<line454>pagesize = getpagesize ();\n<line455>/* Construct fname = sprintf (fnamebuf+i, "/proc/%u/map", getpid ()).  */\n<line456>fname = fnamebuf + sizeof (fnamebuf) - 1 - 4;\n<line457>memcpy (fname, "/map", 4 + 1);\n<line458>{\n<line459>unsigned int value = getpid ();\n<line460>do\n<line461>*--fname = (value % 10) + '0';\n<line462>while ((value = value / 10) > 0);\n<line463>}\n<line464>fname -= 6;\n<line465>memcpy (fname, "/proc/", 6);\n<line466>fd = open (fname, O_RDONLY | O_CLOEXEC);\n<line467>if (fd < 0)\n<line468>return -1;\n<line469>{\n<line470>struct stat statbuf;\n<line471>if (fstat (fd, &statbuf) < 0)\n<line472>goto fail2;\n<line473>nmaps = statbuf.st_size / sizeof (prmap_t);\n<line474>}\n<line475>memneed = (nmaps + 10) * sizeof (prmap_t);\n<line476>/* Allocate memneed bytes of memory.\n<line477>We cannot use alloca here, because not much stack space is guaranteed.\n<line478>We also cannot use malloc here, because a malloc() call may call mmap()\n<line479>and thus pre-allocate available memory.\n<line480>So use mmap(), and ignore the resulting VMA.  */\n<line481>memneed = ((memneed - 1) / pagesize + 1) * pagesize;\n<line482>#  if !HAVE_MAP_ANONYMOUS\n<line483>zero_fd = open ("/dev/zero", O_RDONLY | O_CLOEXEC, 0644);\n<line484>if (zero_fd < 0)\n<line485>goto fail2;\n<line486>#  endif\n<line487>auxmap = (void *) mmap ((void *) 0, memneed, PROT_READ | PROT_WRITE,\n<line488>map_flags | MAP_PRIVATE, zero_fd, 0);\n<line489>#  if !HAVE_MAP_ANONYMOUS\n<line490>close (zero_fd);\n<line491>#  endif\n<line492>if (auxmap == (void *) -1)\n<line493>goto fail2;\n<line494>auxmap_start = (unsigned long) auxmap;\n<line495>auxmap_end = auxmap_start + memneed;\n<line496>maps = (prmap_t *) auxmap;\n<line497>/* Read up to memneed bytes from fd into maps.  */\n<line498>{\n<line499>size_t remaining = memneed;\n<line500>size_t total_read = 0;\n<line501>char *ptr = (char *) maps;\n<line502>do\n<line503>{\n<line504>size_t nread = read (fd, ptr, remaining);\n<line505>if (nread == (size_t)-1)\n<line506>{\n<line507>if (errno == EINTR)\n<line508>continue;\n<line509>goto fail1;\n<line510>}\n<line511>if (nread == 0)\n<line512>/* EOF */\n<line513>break;\n<line514>total_read += nread;\n<line515>ptr += nread;\n<line516>remaining -= nread;\n<line517>}\n<line518>while (remaining > 0);\n<line519>nmaps = (memneed - remaining) / sizeof (prmap_t);\n<line520>maps_end = maps + nmaps;\n<line521>}\n<line522>for (mp = maps; mp < maps_end; mp++)\n<line523>{\n<line524>unsigned long start, end;\n<line525>unsigned int flags;\n<line526>start = (unsigned long) mp->pr_vaddr;\n<line527>end = start + mp->pr_size;\n<line528>flags = 0;\n<line529>if (mp->pr_mflags & MA_READ)\n<line530>flags |= VMA_PROT_READ;\n<line531>if (mp->pr_mflags & MA_WRITE)\n<line532>flags |= VMA_PROT_WRITE;\n<line533>if (mp->pr_mflags & MA_EXEC)\n<line534>flags |= VMA_PROT_EXECUTE;\n<line535>if (start <= auxmap_start && auxmap_end - 1 <= end - 1)\n<line536>{\n<line537>/* Consider [start,end-1] \ [auxmap_start,auxmap_end-1]\n<line538>= [start,auxmap_start-1] u [auxmap_end,end-1].  */\n<line539>if (start < auxmap_start)\n<line540>if (callback (data, start, auxmap_start, flags))\n<line541>break;\n<line542>if (auxmap_end - 1 < end - 1)\n<line543>if (callback (data, auxmap_end, end, flags))\n<line544>break;\n<line545>}\n<line546>else\n<line547>{\n<line548>if (callback (data, start, end, flags))\n<line549>break;\n<line550>}\n<line551>}\n<line552>munmap (auxmap, memneed);\n<line553>close (fd);\n<line554>return 0;\n<line555>fail1:\n<line556>munmap (auxmap, memneed);\n<line557>fail2:\n<line558>close (fd);\n<line559>return -1;\n<line560># endif\n<line561>#elif HAVE_PSTAT_GETPROCVM /* HP-UX */\n<line562>unsigned long pagesize = getpagesize ();\n<line563>int i;\n<line564>for (i = 0; ; i++)\n<line565>{\n<line566>struct pst_vm_status info;\n<line567>int ret = pstat_getprocvm (&info, sizeof (info), 0, i);\n<line568>if (ret < 0)\n<line569>return -1;\n<line570>if (ret == 0)\n<line571>break;\n<line572>{\n<line573>unsigned long start = info.pst_vaddr;\n<line574>unsigned long end = start + info.pst_length * pagesize;\n<line575>unsigned int flags = 0;\n<line576>if (info.pst_permission & PS_PROT_READ)\n<line577>flags |= VMA_PROT_READ;\n<line578>if (info.pst_permission & PS_PROT_WRITE)\n<line579>flags |= VMA_PROT_WRITE;\n<line580>if (info.pst_permission & PS_PROT_EXECUTE)\n<line581>flags |= VMA_PROT_EXECUTE;\n<line582>if (callback (data, start, end, flags))\n<line583>break;\n<line584>}\n<line585>}\n<line586>#elif defined __APPLE__ && defined __MACH__ /* Mac OS X */\n<line587>task_t task = mach_task_self ();\n<line588>vm_address_t address;\n<line589>vm_size_t size;\n<line590>for (address = VM_MIN_ADDRESS;; address += size)\n<line591>{\n<line592>int more;\n<line593>mach_port_t object_name;\n<line594>unsigned int flags;\n<line595>/* In Mac OS X 10.5, the types vm_address_t, vm_offset_t, vm_size_t have\n<line596>32 bits in 32-bit processes and 64 bits in 64-bit processes. Whereas\n<line597>mach_vm_address_t and mach_vm_size_t are always 64 bits large.\n<line598>Mac OS X 10.5 has three vm_region like methods:\n<line599>- vm_region. It has arguments that depend on whether the current\n<line600>process is 32-bit or 64-bit. When linking dynamically, this\n<line601>function exists only in 32-bit processes. Therefore we use it only\n<line602>in 32-bit processes.\n<line603>- vm_region_64. It has arguments that depend on whether the current\n<line604>process is 32-bit or 64-bit. It interprets a flavor\n<line605>VM_REGION_BASIC_INFO as VM_REGION_BASIC_INFO_64, which is\n<line606>dangerous since 'struct vm_region_basic_info_64' is larger than\n<line607>'struct vm_region_basic_info'; therefore let's write\n<line608>VM_REGION_BASIC_INFO_64 explicitly.\n<line609>- mach_vm_region. It has arguments that are 64-bit always. This\n<line610>function is useful when you want to access the VM of a process\n<line611>other than the current process.\n<line612>In 64-bit processes, we could use vm_region_64 or mach_vm_region.\n<line613>I choose vm_region_64 because it uses the same types as vm_region,\n<line614>resulting in less conditional code.  */\n<line615># if defined __aarch64__ || defined __ppc64__ || defined __x86_64__\n<line616>struct vm_region_basic_info_64 info;\n<line617>mach_msg_type_number_t info_count = VM_REGION_BASIC_INFO_COUNT_64;\n<line618>more = (vm_region_64 (task, &address, &size, VM_REGION_BASIC_INFO_64,\n<line619>(vm_region_info_t)&info, &info_count, &object_name)\n<line620>== KERN_SUCCESS);\n<line621># else\n<line622>struct vm_region_basic_info info;\n<line623>mach_msg_type_number_t info_count = VM_REGION_BASIC_INFO_COUNT;\n<line624>more = (vm_region (task, &address, &size, VM_REGION_BASIC_INFO,\n<line625>(vm_region_info_t)&info, &info_count, &object_name)\n<line626>== KERN_SUCCESS);\n<line627># endif\n<line628>if (object_name != MACH_PORT_NULL)\n<line629>mach_port_deallocate (mach_task_self (), object_name);\n<line630>if (!more)\n<line631>break;\n<line632>flags = 0;\n<line633>if (info.protection & VM_PROT_READ)\n<line634>flags |= VMA_PROT_READ;\n<line635>if (info.protection & VM_PROT_WRITE)\n<line636>flags |= VMA_PROT_WRITE;\n<line637>if (info.protection & VM_PROT_EXECUTE)\n<line638>flags |= VMA_PROT_EXECUTE;\n<line639>if (callback (data, address, address + size, flags))\n<line640>break;\n<line641>}\n<line642>return 0;\n<line643>#elif defined __GNU__ /* GNU/Hurd */\n<line644>/* The Hurd has a /proc/self/maps that looks like the Linux one, but it\n<line645>lacks the VMAs created through anonymous mmap.  Therefore use the Mach\n<line646>API.\n<line647>Documentation:\n<line648>https://www.gnu.org/software/hurd/gnumach-doc/Memory-Attributes.html */\n<line649>task_t task = mach_task_self ();\n<line650>vm_address_t address;\n<line651>vm_size_t size;\n<line652>for (address = 0;; address += size)\n<line653>{\n<line654>vm_prot_t protection;\n<line655>vm_prot_t max_protection;\n<line656>vm_inherit_t inheritance;\n<line657>boolean_t shared;\n<line658>memory_object_name_t object_name;\n<line659>vm_offset_t offset;\n<line660>unsigned int flags;\n<line661>if (!(vm_region (task, &address, &size, &protection, &max_protection,\n<line662>&inheritance, &shared, &object_name, &offset)\n<line663>== KERN_SUCCESS))\n<line664>break;\n<line665>mach_port_deallocate (task, object_name);\n<line666>flags = 0;\n<line667>if (protection & VM_PROT_READ)\n<line668>flags |= VMA_PROT_READ;\n<line669>if (protection & VM_PROT_WRITE)\n<line670>flags |= VMA_PROT_WRITE;\n<line671>if (protection & VM_PROT_EXECUTE)\n<line672>flags |= VMA_PROT_EXECUTE;\n<line673>if (callback (data, address, address + size, flags))\n<line674>break;\n<line675>}\n<line676>return 0;\n<line677>#elif defined _WIN32 || defined __CYGWIN__\n<line678>/* Windows platform.  Use the native Windows API.  */\n<line679>MEMORY_BASIC_INFORMATION info;\n<line680>uintptr_t address = 0;\n<line681>while (VirtualQuery ((void*)address, &info, sizeof(info)) == sizeof(info))\n<line682>{\n<line683>if (info.State != MEM_FREE)\n<line684>/* Ignore areas where info.State has the value MEM_RESERVE or,\n<line685>equivalently, info.Protect has the undocumented value 0.\n<line686>This is needed, so that on Cygwin, areas used by malloc() are\n<line687>distinguished from areas reserved for future malloc().  */\n<line688>if (info.State != MEM_RESERVE)\n<line689>{\n<line690>uintptr_t start, end;\n<line691>unsigned int flags;\n<line692>start = (uintptr_t)info.BaseAddress;\n<line693>end = start + info.RegionSize;\n<line694>switch (info.Protect & ~(PAGE_GUARD|PAGE_NOCACHE))\n<line695>{\n<line696>case PAGE_READONLY:\n<line697>flags = VMA_PROT_READ;\n<line698>break;\n<line699>case PAGE_READWRITE:\n<line700>case PAGE_WRITECOPY:\n<line701>flags = VMA_PROT_READ | VMA_PROT_WRITE;\n<line702>break;\n<line703>case PAGE_EXECUTE:\n<line704>flags = VMA_PROT_EXECUTE;\n<line705>break;\n<line706>case PAGE_EXECUTE_READ:\n<line707>flags = VMA_PROT_READ | VMA_PROT_EXECUTE;\n<line708>break;\n<line709>case PAGE_EXECUTE_READWRITE:\n<line710>case PAGE_EXECUTE_WRITECOPY:\n<line711>flags = VMA_PROT_READ | VMA_PROT_WRITE | VMA_PROT_EXECUTE;\n<line712>break;\n<line713>case PAGE_NOACCESS:\n<line714>default:\n<line715>flags = 0;\n<line716>break;\n<line717>}\n<line718>if (callback (data, start, end, flags))\n<line719>break;\n<line720>}\n<line721>address = (uintptr_t)info.BaseAddress + info.RegionSize;\n<line722>}\n<line723>return 0;\n<line724>#elif defined __BEOS__ || defined __HAIKU__\n<line725>/* Use the BeOS specific API.  */\n<line726>area_info info;\n<line727>ssize_t cookie;\n<line728>cookie = 0;\n<line729>while (get_next_area_info (0, &cookie, &info) == B_OK)\n<line730>{\n<line731>unsigned long start, end;\n<line732>unsigned int flags;\n<line733>start = (unsigned long) info.address;\n<line734>end = start + info.size;\n<line735>flags = 0;\n<line736>if (info.protection & B_READ_AREA)\n<line737>flags |= VMA_PROT_READ | VMA_PROT_EXECUTE;\n<line738>if (info.protection & B_WRITE_AREA)\n<line739>flags |= VMA_PROT_WRITE;\n<line740>if (callback (data, start, end, flags))\n<line741>break;\n<line742>}\n<line743>return 0;\n<line744>#elif HAVE_MQUERY /* OpenBSD */\n<line745># if defined __OpenBSD__\n<line746>/* Try sysctl() first.  It is more efficient than the mquery() loop below\n<line747>and also provides the flags.  */\n<line748>{\n<line749>int retval = vma_iterate_bsd (callback, data);\n<line750>if (retval == 0)\n<line751>return 0;\n<line752>}\n<line753># endif\n<line754>{\n<line755>uintptr_t pagesize;\n<line756>uintptr_t address;\n<line757>int /*bool*/ address_known_mapped;\n<line758>pagesize = getpagesize ();\n<line759>/* Avoid calling mquery with a NULL first argument, because this argument\n<line760>value has a specific meaning.  We know the NULL page is unmapped.  */\n<line761>address = pagesize;\n<line762>address_known_mapped = 0;\n<line763>for (;;)\n<line764>{\n<line765>/* Test whether the page at address is mapped.  */\n<line766>if (address_known_mapped\n<line767>|| mquery ((void *) address, pagesize, 0, MAP_FIXED, -1, 0)\n<line768>== (void *) -1)\n<line769>{\n<line770>/* The page at address is mapped.\n<line771>This is the start of an interval.  */\n<line772>uintptr_t start = address;\n<line773>uintptr_t end;\n<line774>/* Find the end of the interval.  */\n<line775>end = (uintptr_t) mquery ((void *) address, pagesize, 0, 0, -1, 0);\n<line776>if (end == (uintptr_t) (void *) -1)\n<line777>end = 0; /* wrap around */\n<line778>address = end;\n<line779>/* It's too complicated to find out about the flags.\n<line780>Just pass 0.  */\n<line781>if (callback (data, start, end, 0))\n<line782>break;\n<line783>if (address < pagesize) /* wrap around? */\n<line784>break;\n<line785>}\n<line786>/* Here we know that the page at address is unmapped.  */\n<line787>{\n<line788>uintptr_t query_size = pagesize;\n<line789>address += pagesize;\n<line790>/* Query larger and larger blocks, to get through the unmapped address\n<line791>range with few mquery() calls.  */\n<line792>for (;;)\n<line793>{\n<line794>if (2 * query_size > query_size)\n<line795>query_size = 2 * query_size;\n<line796>if (address + query_size - 1 < query_size) /* wrap around? */\n<line797>{\n<line798>address_known_mapped = 0;\n<line799>break;\n<line800>}\n<line801>if (mquery ((void *) address, query_size, 0, MAP_FIXED, -1, 0)\n<line802>== (void *) -1)\n<line803>{\n<line804>/* Not all the interval [address .. address + query_size - 1]\n<line805>is unmapped.  */\n<line806>address_known_mapped = (query_size == pagesize);\n<line807>break;\n<line808>}\n<line809>/* The interval [address .. address + query_size - 1] is\n<line810>unmapped.  */\n<line811>address += query_size;\n<line812>}\n<line813>/* Reduce the query size again, to determine the precise size of the\n<line814>unmapped interval that starts at address.  */\n<line815>while (query_size > pagesize)\n<line816>{\n<line817>query_size = query_size / 2;\n<line818>if (address + query_size - 1 >= query_size)\n<line819>{\n<line820>if (mquery ((void *) address, query_size, 0, MAP_FIXED, -1, 0)\n<line821>!= (void *) -1)\n<line822>{\n<line823>/* The interval [address .. address + query_size - 1] is\n<line824>unmapped.  */\n<line825>address += query_size;\n<line826>address_known_mapped = 0;\n<line827>}\n<line828>else\n<line829>address_known_mapped = (query_size == pagesize);\n<line830>}\n<line831>}\n<line832>/* Here again query_size = pagesize, and\n<line833>either address + pagesize - 1 < pagesize, or\n<line834>mquery ((void *) address, pagesize, 0, MAP_FIXED, -1, 0) fails.\n<line835>So, the unmapped area ends at address.  */\n<line836>}\n<line837>if (address + pagesize - 1 < pagesize) /* wrap around? */\n<line838>break;\n<line839>}\n<line840>return 0;\n<line841>}\n<line842>#else\n<line843>/* Not implemented.  */\n<line844>return -1;\n<line845>#endif\n<line846>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/gnulib-tests/strerror_r.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
Function: safe_copy
Content: <line0>static int\n<line1>safe_copy (char *buf, size_t buflen, const char *msg)\n<line2>{\n<line3>size_t len = strlen (msg);\n<line4>size_t moved = len < buflen ? len : buflen - 1;\n<line5>/* Although POSIX lets memmove corrupt errno, we don't\n<line6>know of any implementation where this is a real problem.  */\n<line7>memmove (buf, msg, moved);\n<line8>buf[moved] = '\0';\n<line9>return len < buflen ? 0 : ERANGE;\n<line10>}
----------------------------------------
Function: rpl_strerror_r
Content: <line0>int\n<line1>strerror_r (int errnum, char *buf, size_t buflen)\n<line2>#undef strerror_r\n<line3>{\n<line4>/* Filter this out now, so that rest of this replacement knows that\n<line5>there is room for a non-empty message and trailing NUL.  */\n<line6>if (buflen <= 1)\n<line7>{\n<line8>if (buflen)\n<line9>*buf = '\0';\n<line10>return ERANGE;\n<line11>}\n<line12>*buf = '\0';\n<line13>/* Check for gnulib overrides.  */\n<line14>{\n<line15>char const *msg = strerror_override (errnum);\n<line16>if (msg)\n<line17>return safe_copy (buf, buflen, msg);\n<line18>}\n<line19>{\n<line20>int ret;\n<line21>int saved_errno = errno;\n<line22>#if STRERROR_R_CHAR_P\n<line23>{\n<line24>ret = 0;\n<line25># if HAVE___XPG_STRERROR_R\n<line26>ret = __xpg_strerror_r (errnum, buf, buflen);\n<line27>/* ret is 0 upon success, or EINVAL or ERANGE upon failure.  */\n<line28># endif\n<line29>if (!*buf)\n<line30>{\n<line31>/* glibc 2.13 ... 2.34 (at least) don't touch buf upon failure.\n<line32>Therefore we have to fall back to strerror_r which, for valid\n<line33>errnum, returns a thread-safe untruncated string.  For invalid\n<line34>errnum, though, it returns a truncated string, which does not\n<line35>allow us to determine whether to return ERANGE or 0.  Thus we\n<line36>need to pass a sufficiently large buffer.  */\n<line37>char stackbuf[80];\n<line38>char *errstring = strerror_r (errnum, stackbuf, sizeof stackbuf);\n<line39>ret = errstring ? safe_copy (buf, buflen, errstring) : errno;\n<line40>}\n<line41>}\n<line42>#elif HAVE_DECL_STRERROR_R\n<line43>if (buflen > INT_MAX)\n<line44>buflen = INT_MAX;\n<line45># ifdef __hpux\n<line46>/* On HP-UX 11.31, strerror_r always fails when buflen < 80; it\n<line47>also fails to change buf on EINVAL.  */\n<line48>{\n<line49>char stackbuf[80];\n<line50>if (buflen < sizeof stackbuf)\n<line51>{\n<line52>ret = strerror_r (errnum, stackbuf, sizeof stackbuf);\n<line53>if (ret == 0)\n<line54>ret = safe_copy (buf, buflen, stackbuf);\n<line55>}\n<line56>else\n<line57>ret = strerror_r (errnum, buf, buflen);\n<line58>}\n<line59># else\n<line60>ret = strerror_r (errnum, buf, buflen);\n<line61>/* Some old implementations may return (-1, EINVAL) instead of EINVAL.\n<line62>But on Haiku, valid error numbers are negative.  */\n<line63>#  if !defined __HAIKU__\n<line64>if (ret < 0)\n<line65>ret = errno;\n<line66>#  endif\n<line67># endif\n<line68># if defined _AIX || defined __HAIKU__\n<line69>/* AIX and Haiku return 0 rather than ERANGE when truncating strings; try\n<line70>again until we are sure we got the entire string.  */\n<line71>if (!ret && strlen (buf) == buflen - 1)\n<line72>{\n<line73>char stackbuf[STACKBUF_LEN];\n<line74>size_t len;\n<line75>strerror_r (errnum, stackbuf, sizeof stackbuf);\n<line76>len = strlen (stackbuf);\n<line77>/* STACKBUF_LEN should have been large enough.  */\n<line78>if (len + 1 == sizeof stackbuf)\n<line79>abort ();\n<line80>if (buflen <= len)\n<line81>ret = ERANGE;\n<line82>}\n<line83># else\n<line84>/* Solaris 10 does not populate buf on ERANGE.  OpenBSD 4.7\n<line85>truncates early on ERANGE rather than return a partial integer.\n<line86>We prefer the maximal string.  We set buf[0] earlier, and we\n<line87>know of no implementation that modifies buf to be an\n<line88>unterminated string, so this strlen should be portable in\n<line89>practice (rather than pulling in a safer strnlen).  */\n<line90>if (ret == ERANGE && strlen (buf) < buflen - 1)\n<line91>{\n<line92>char stackbuf[STACKBUF_LEN];\n<line93>/* STACKBUF_LEN should have been large enough.  */\n<line94>if (strerror_r (errnum, stackbuf, sizeof stackbuf) == ERANGE)\n<line95>abort ();\n<line96>safe_copy (buf, buflen, stackbuf);\n<line97>}\n<line98># endif\n<line99>#else /* strerror_r is not declared.  */\n<line100>/* Try to do what strerror (errnum) does, but without clobbering the\n<line101>buffer used by strerror().  */\n<line102># if defined __NetBSD__ || defined __hpux || (defined _WIN32 && !defined __CYGWIN__) || defined __CYGWIN__ /* NetBSD, HP-UX, native Windows, Cygwin */\n<line103>/* NetBSD:         sys_nerr, sys_errlist are declared through _NETBSD_SOURCE\n<line104>and <errno.h> above.\n<line105>HP-UX:          sys_nerr, sys_errlist are declared explicitly above.\n<line106>native Windows: sys_nerr, sys_errlist are declared in <stdlib.h>.\n<line107>Cygwin:         sys_nerr, sys_errlist are declared in <errno.h>.  */\n<line108>if (errnum >= 0 && errnum < sys_nerr)\n<line109>{\n<line110>#  if HAVE_CATGETS && (defined __NetBSD__ || defined __hpux)\n<line111>#   if defined __NetBSD__\n<line112>nl_catd catd = catopen ("libc", NL_CAT_LOCALE);\n<line113>const char *errmsg =\n<line114>(catd != (nl_catd)-1\n<line115>? catgets (catd, 1, errnum, sys_errlist[errnum])\n<line116>: sys_errlist[errnum]);\n<line117>#   endif\n<line118>#   if defined __hpux\n<line119>nl_catd catd = catopen ("perror", NL_CAT_LOCALE);\n<line120>const char *errmsg =\n<line121>(catd != (nl_catd)-1\n<line122>? catgets (catd, 1, 1 + errnum, sys_errlist[errnum])\n<line123>: sys_errlist[errnum]);\n<line124>#   endif\n<line125>#  else\n<line126>const char *errmsg = sys_errlist[errnum];\n<line127>#  endif\n<line128>if (errmsg == NULL || *errmsg == '\0')\n<line129>ret = EINVAL;\n<line130>else\n<line131>ret = safe_copy (buf, buflen, errmsg);\n<line132>#  if HAVE_CATGETS && (defined __NetBSD__ || defined __hpux)\n<line133>if (catd != (nl_catd)-1)\n<line134>catclose (catd);\n<line135>#  endif\n<line136>}\n<line137>else\n<line138>ret = EINVAL;\n<line139># elif defined __sgi || (defined __sun && !defined _LP64) /* IRIX, Solaris <= 9 32-bit */\n<line140>/* For a valid error number, the system's strerror() function returns\n<line141>a pointer to a not copied string, not to a buffer.  */\n<line142>if (errnum >= 0 && errnum < sys_nerr)\n<line143>{\n<line144>char *errmsg = strerror (errnum);\n<line145>if (errmsg == NULL || *errmsg == '\0')\n<line146>ret = EINVAL;\n<line147>else\n<line148>ret = safe_copy (buf, buflen, errmsg);\n<line149>}\n<line150>else\n<line151>ret = EINVAL;\n<line152># else\n<line153>gl_lock_lock (strerror_lock);\n<line154>{\n<line155>char *errmsg = strerror (errnum);\n<line156>/* For invalid error numbers, strerror() on\n<line157>- IRIX 6.5 returns NULL,\n<line158>- HP-UX 11 returns an empty string.  */\n<line159>if (errmsg == NULL || *errmsg == '\0')\n<line160>ret = EINVAL;\n<line161>else\n<line162>ret = safe_copy (buf, buflen, errmsg);\n<line163>}\n<line164>gl_lock_unlock (strerror_lock);\n<line165># endif\n<line166>#endif\n<line167>#if defined _WIN32 && !defined __CYGWIN__\n<line168>/* MSVC 14 defines names for many error codes in the range 100..140,\n<line169>but _sys_errlist contains strings only for the error codes\n<line170>< _sys_nerr = 43.  */\n<line171>if (ret == EINVAL)\n<line172>{\n<line173>const char *errmsg;\n<line174>switch (errnum)\n<line175>{\n<line176>case 100 /* EADDRINUSE */:\n<line177>errmsg = "Address already in use";\n<line178>break;\n<line179>case 101 /* EADDRNOTAVAIL */:\n<line180>errmsg = "Cannot assign requested address";\n<line181>break;\n<line182>case 102 /* EAFNOSUPPORT */:\n<line183>errmsg = "Address family not supported by protocol";\n<line184>break;\n<line185>case 103 /* EALREADY */:\n<line186>errmsg = "Operation already in progress";\n<line187>break;\n<line188>case 105 /* ECANCELED */:\n<line189>errmsg = "Operation canceled";\n<line190>break;\n<line191>case 106 /* ECONNABORTED */:\n<line192>errmsg = "Software caused connection abort";\n<line193>break;\n<line194>case 107 /* ECONNREFUSED */:\n<line195>errmsg = "Connection refused";\n<line196>break;\n<line197>case 108 /* ECONNRESET */:\n<line198>errmsg = "Connection reset by peer";\n<line199>break;\n<line200>case 109 /* EDESTADDRREQ */:\n<line201>errmsg = "Destination address required";\n<line202>break;\n<line203>case 110 /* EHOSTUNREACH */:\n<line204>errmsg = "No route to host";\n<line205>break;\n<line206>case 112 /* EINPROGRESS */:\n<line207>errmsg = "Operation now in progress";\n<line208>break;\n<line209>case 113 /* EISCONN */:\n<line210>errmsg = "Transport endpoint is already connected";\n<line211>break;\n<line212>case 114 /* ELOOP */:\n<line213>errmsg = "Too many levels of symbolic links";\n<line214>break;\n<line215>case 115 /* EMSGSIZE */:\n<line216>errmsg = "Message too long";\n<line217>break;\n<line218>case 116 /* ENETDOWN */:\n<line219>errmsg = "Network is down";\n<line220>break;\n<line221>case 117 /* ENETRESET */:\n<line222>errmsg = "Network dropped connection on reset";\n<line223>break;\n<line224>case 118 /* ENETUNREACH */:\n<line225>errmsg = "Network is unreachable";\n<line226>break;\n<line227>case 119 /* ENOBUFS */:\n<line228>errmsg = "No buffer space available";\n<line229>break;\n<line230>case 123 /* ENOPROTOOPT */:\n<line231>errmsg = "Protocol not available";\n<line232>break;\n<line233>case 126 /* ENOTCONN */:\n<line234>errmsg = "Transport endpoint is not connected";\n<line235>break;\n<line236>case 128 /* ENOTSOCK */:\n<line237>errmsg = "Socket operation on non-socket";\n<line238>break;\n<line239>case 129 /* ENOTSUP */:\n<line240>errmsg = "Not supported";\n<line241>break;\n<line242>case 130 /* EOPNOTSUPP */:\n<line243>errmsg = "Operation not supported";\n<line244>break;\n<line245>case 132 /* EOVERFLOW */:\n<line246>errmsg = "Value too large for defined data type";\n<line247>break;\n<line248>case 133 /* EOWNERDEAD */:\n<line249>errmsg = "Owner died";\n<line250>break;\n<line251>case 134 /* EPROTO */:\n<line252>errmsg = "Protocol error";\n<line253>break;\n<line254>case 135 /* EPROTONOSUPPORT */:\n<line255>errmsg = "Protocol not supported";\n<line256>break;\n<line257>case 136 /* EPROTOTYPE */:\n<line258>errmsg = "Protocol wrong type for socket";\n<line259>break;\n<line260>case 138 /* ETIMEDOUT */:\n<line261>errmsg = "Connection timed out";\n<line262>break;\n<line263>case 140 /* EWOULDBLOCK */:\n<line264>errmsg = "Operation would block";\n<line265>break;\n<line266>default:\n<line267>errmsg = NULL;\n<line268>break;\n<line269>}\n<line270>if (errmsg != NULL)\n<line271>ret = safe_copy (buf, buflen, errmsg);\n<line272>}\n<line273>#endif\n<line274>if (ret == EINVAL && !*buf)\n<line275>{\n<line276>#if defined __HAIKU__\n<line277>/* For consistency with perror().  */\n<line278>snprintf (buf, buflen, "Unknown Application Error (%d)", errnum);\n<line279>#else\n<line280>snprintf (buf, buflen, "Unknown error %d", errnum);\n<line281>#endif\n<line282>}\n<line283>errno = saved_errno;\n<line284>return ret;\n<line285>}\n<line286>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/gnulib-tests/bench-sha1.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
========================================
/home/huihui/Downloads/coreutils-9.4/gnulib-tests/bench-sha224.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
========================================
/home/huihui/Downloads/coreutils-9.4/gnulib-tests/bench-sha256.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
========================================
/home/huihui/Downloads/coreutils-9.4/gnulib-tests/bench-sha384.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
========================================
/home/huihui/Downloads/coreutils-9.4/gnulib-tests/bench-sha512.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
========================================
/home/huihui/Downloads/coreutils-9.4/gnulib-tests/locale.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
Function: defaulted_getenv
Content: <line0>static const char *\n<line1>defaulted_getenv (const char *variable)\n<line2>{\n<line3>const char *value = getenv (variable);\n<line4>return (value != NULL ? value : "");\n<line5>}
----------------------------------------
Function: print_category
Content: <line0>static void\n<line1>print_category (int category, const char *variable)\n<line2>{\n<line3>const char *value = defaulted_getenv (variable);\n<line4>if (value[0] != '\0' && defaulted_getenv ("LC_ALL")[0] == '\0')\n<line5>/* The variable is set in the environment and not overridden by LC_ALL.  */\n<line6>printf ("%s=%s\n", variable, value);\n<line7>else\n<line8>printf ("%s=\"%s\"\n", variable, setlocale (category, NULL));\n<line9>}
----------------------------------------
Function: main
Content: <line0>int\n<line1>main (void)\n<line2>{\n<line3>setlocale (LC_ALL, "");\n<line4>printf ("LANG=%s\n", defaulted_getenv ("LANG"));\n<line5>print_category (LC_CTYPE, "LC_CTYPE");\n<line6>print_category (LC_NUMERIC, "LC_NUMERIC");\n<line7>print_category (LC_TIME, "LC_TIME");\n<line8>print_category (LC_COLLATE, "LC_COLLATE");\n<line9>print_category (LC_MONETARY, "LC_MONETARY");\n<line10>print_category (LC_MESSAGES, "LC_MESSAGES");\n<line11>#ifdef LC_PAPER\n<line12>print_category (LC_PAPER, "LC_PAPER");\n<line13>#endif\n<line14>#ifdef LC_NAME\n<line15>print_category (LC_NAME, "LC_NAME");\n<line16>#endif\n<line17>#ifdef LC_ADDRESS\n<line18>print_category (LC_ADDRESS, "LC_ADDRESS");\n<line19>#endif\n<line20>#ifdef LC_TELEPHONE\n<line21>print_category (LC_TELEPHONE, "LC_TELEPHONE");\n<line22>#endif\n<line23>#ifdef LC_MEASUREMENT\n<line24>print_category (LC_MEASUREMENT, "LC_MEASUREMENT");\n<line25>#endif\n<line26>#ifdef LC_IDENTIFICATION\n<line27>print_category (LC_IDENTIFICATION, "LC_IDENTIFICATION");\n<line28>#endif\n<line29>printf ("LC_ALL=%s\n", defaulted_getenv ("LC_ALL"));\n<line30>return 0;\n<line31>}
----------------------------------------
========================================
/home/huihui/Downloads/coreutils-9.4/gnulib-tests/test-localcharset.c
========================================
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unsuffixed-float-constants' [-Wunknown-warning-option]
1 warning generated.
Function: main
Content: <line0>int\n<line1>main (void)\n<line2>{\n<line3>setlocale (LC_ALL, "");\n<line4>printf ("%s\n", locale_charset ());\n<line5>return 0;\n<line6>}
----------------------------------------
